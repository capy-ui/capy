//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (4)
//--------------------------------------------------------------------------------
pub const NETCON_MAX_NAME_LEN = @as(u32, 256);
pub const S_OBJECT_NO_LONGER_VALID = @import("../zig.zig").typedConst(HRESULT, @as(i32, 2));
pub const NETISO_GEID_FOR_WDAG = @as(u32, 1);
pub const NETISO_GEID_FOR_NEUTRAL_AWARE = @as(u32, 2);

//--------------------------------------------------------------------------------
// Section: Types (97)
//--------------------------------------------------------------------------------
const CLSID_UPnPNAT_Value = Guid.initString("ae1e00aa-3fd5-403c-8a27-2bbdc30cd0e1");
pub const CLSID_UPnPNAT = &CLSID_UPnPNAT_Value;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IUPnPNAT_Value = Guid.initString("b171c812-cc76-485a-94d8-b6b3a2794e99");
pub const IID_IUPnPNAT = &IID_IUPnPNAT_Value;
pub const IUPnPNAT = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StaticPortMappingCollection: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IUPnPNAT,
                ppSPMs: ?*?*IStaticPortMappingCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IUPnPNAT,
                ppSPMs: ?*?*IStaticPortMappingCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DynamicPortMappingCollection: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IUPnPNAT,
                ppDPMs: ?*?*IDynamicPortMappingCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IUPnPNAT,
                ppDPMs: ?*?*IDynamicPortMappingCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NATEventManager: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IUPnPNAT,
                ppNEM: ?*?*INATEventManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IUPnPNAT,
                ppNEM: ?*?*INATEventManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUPnPNAT_get_StaticPortMappingCollection(self: *const T, ppSPMs: ?*?*IStaticPortMappingCollection) HRESULT {
                return @as(*const IUPnPNAT.VTable, @ptrCast(self.vtable)).get_StaticPortMappingCollection(@as(*const IUPnPNAT, @ptrCast(self)), ppSPMs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUPnPNAT_get_DynamicPortMappingCollection(self: *const T, ppDPMs: ?*?*IDynamicPortMappingCollection) HRESULT {
                return @as(*const IUPnPNAT.VTable, @ptrCast(self.vtable)).get_DynamicPortMappingCollection(@as(*const IUPnPNAT, @ptrCast(self)), ppDPMs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUPnPNAT_get_NATEventManager(self: *const T, ppNEM: ?*?*INATEventManager) HRESULT {
                return @as(*const IUPnPNAT.VTable, @ptrCast(self.vtable)).get_NATEventManager(@as(*const IUPnPNAT, @ptrCast(self)), ppNEM);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_INATEventManager_Value = Guid.initString("624bd588-9060-4109-b0b0-1adbbcac32df");
pub const IID_INATEventManager = &IID_INATEventManager_Value;
pub const INATEventManager = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ExternalIPAddressCallback: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INATEventManager,
                pUnk: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INATEventManager,
                pUnk: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_NumberOfEntriesCallback: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INATEventManager,
                pUnk: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INATEventManager,
                pUnk: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INATEventManager_put_ExternalIPAddressCallback(self: *const T, pUnk: ?*IUnknown) HRESULT {
                return @as(*const INATEventManager.VTable, @ptrCast(self.vtable)).put_ExternalIPAddressCallback(@as(*const INATEventManager, @ptrCast(self)), pUnk);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INATEventManager_put_NumberOfEntriesCallback(self: *const T, pUnk: ?*IUnknown) HRESULT {
                return @as(*const INATEventManager.VTable, @ptrCast(self.vtable)).put_NumberOfEntriesCallback(@as(*const INATEventManager, @ptrCast(self)), pUnk);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_INATExternalIPAddressCallback_Value = Guid.initString("9c416740-a34e-446f-ba06-abd04c3149ae");
pub const IID_INATExternalIPAddressCallback = &IID_INATExternalIPAddressCallback_Value;
pub const INATExternalIPAddressCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        NewExternalIPAddress: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INATExternalIPAddressCallback,
                bstrNewExternalIPAddress: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INATExternalIPAddressCallback,
                bstrNewExternalIPAddress: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INATExternalIPAddressCallback_NewExternalIPAddress(self: *const T, bstrNewExternalIPAddress: ?BSTR) HRESULT {
                return @as(*const INATExternalIPAddressCallback.VTable, @ptrCast(self.vtable)).NewExternalIPAddress(@as(*const INATExternalIPAddressCallback, @ptrCast(self)), bstrNewExternalIPAddress);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_INATNumberOfEntriesCallback_Value = Guid.initString("c83a0a74-91ee-41b6-b67a-67e0f00bbd78");
pub const IID_INATNumberOfEntriesCallback = &IID_INATNumberOfEntriesCallback_Value;
pub const INATNumberOfEntriesCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        NewNumberOfEntries: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INATNumberOfEntriesCallback,
                lNewNumberOfEntries: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INATNumberOfEntriesCallback,
                lNewNumberOfEntries: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INATNumberOfEntriesCallback_NewNumberOfEntries(self: *const T, lNewNumberOfEntries: i32) HRESULT {
                return @as(*const INATNumberOfEntriesCallback.VTable, @ptrCast(self.vtable)).NewNumberOfEntries(@as(*const INATNumberOfEntriesCallback, @ptrCast(self)), lNewNumberOfEntries);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDynamicPortMappingCollection_Value = Guid.initString("b60de00f-156e-4e8d-9ec1-3a2342c10899");
pub const IID_IDynamicPortMappingCollection = &IID_IDynamicPortMappingCollection_Value;
pub const IDynamicPortMappingCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IDynamicPortMappingCollection,
                pVal: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IDynamicPortMappingCollection,
                pVal: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Item: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IDynamicPortMappingCollection,
                bstrRemoteHost: ?BSTR,
                lExternalPort: i32,
                bstrProtocol: ?BSTR,
                ppDPM: ?*?*IDynamicPortMapping,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IDynamicPortMappingCollection,
                bstrRemoteHost: ?BSTR,
                lExternalPort: i32,
                bstrProtocol: ?BSTR,
                ppDPM: ?*?*IDynamicPortMapping,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IDynamicPortMappingCollection,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IDynamicPortMappingCollection,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Remove: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDynamicPortMappingCollection,
                bstrRemoteHost: ?BSTR,
                lExternalPort: i32,
                bstrProtocol: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDynamicPortMappingCollection,
                bstrRemoteHost: ?BSTR,
                lExternalPort: i32,
                bstrProtocol: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Add: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDynamicPortMappingCollection,
                bstrRemoteHost: ?BSTR,
                lExternalPort: i32,
                bstrProtocol: ?BSTR,
                lInternalPort: i32,
                bstrInternalClient: ?BSTR,
                bEnabled: i16,
                bstrDescription: ?BSTR,
                lLeaseDuration: i32,
                ppDPM: ?*?*IDynamicPortMapping,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDynamicPortMappingCollection,
                bstrRemoteHost: ?BSTR,
                lExternalPort: i32,
                bstrProtocol: ?BSTR,
                lInternalPort: i32,
                bstrInternalClient: ?BSTR,
                bEnabled: i16,
                bstrDescription: ?BSTR,
                lLeaseDuration: i32,
                ppDPM: ?*?*IDynamicPortMapping,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDynamicPortMappingCollection_get__NewEnum(self: *const T, pVal: ?*?*IUnknown) HRESULT {
                return @as(*const IDynamicPortMappingCollection.VTable, @ptrCast(self.vtable)).get__NewEnum(@as(*const IDynamicPortMappingCollection, @ptrCast(self)), pVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDynamicPortMappingCollection_get_Item(self: *const T, bstrRemoteHost: ?BSTR, lExternalPort: i32, bstrProtocol: ?BSTR, ppDPM: ?*?*IDynamicPortMapping) HRESULT {
                return @as(*const IDynamicPortMappingCollection.VTable, @ptrCast(self.vtable)).get_Item(@as(*const IDynamicPortMappingCollection, @ptrCast(self)), bstrRemoteHost, lExternalPort, bstrProtocol, ppDPM);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDynamicPortMappingCollection_get_Count(self: *const T, pVal: ?*i32) HRESULT {
                return @as(*const IDynamicPortMappingCollection.VTable, @ptrCast(self.vtable)).get_Count(@as(*const IDynamicPortMappingCollection, @ptrCast(self)), pVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDynamicPortMappingCollection_Remove(self: *const T, bstrRemoteHost: ?BSTR, lExternalPort: i32, bstrProtocol: ?BSTR) HRESULT {
                return @as(*const IDynamicPortMappingCollection.VTable, @ptrCast(self.vtable)).Remove(@as(*const IDynamicPortMappingCollection, @ptrCast(self)), bstrRemoteHost, lExternalPort, bstrProtocol);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDynamicPortMappingCollection_Add(self: *const T, bstrRemoteHost: ?BSTR, lExternalPort: i32, bstrProtocol: ?BSTR, lInternalPort: i32, bstrInternalClient: ?BSTR, bEnabled: i16, bstrDescription: ?BSTR, lLeaseDuration: i32, ppDPM: ?*?*IDynamicPortMapping) HRESULT {
                return @as(*const IDynamicPortMappingCollection.VTable, @ptrCast(self.vtable)).Add(@as(*const IDynamicPortMappingCollection, @ptrCast(self)), bstrRemoteHost, lExternalPort, bstrProtocol, lInternalPort, bstrInternalClient, bEnabled, bstrDescription, lLeaseDuration, ppDPM);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDynamicPortMapping_Value = Guid.initString("4fc80282-23b6-4378-9a27-cd8f17c9400c");
pub const IID_IDynamicPortMapping = &IID_IDynamicPortMapping_Value;
pub const IDynamicPortMapping = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ExternalIPAddress: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IDynamicPortMapping,
                pVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IDynamicPortMapping,
                pVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RemoteHost: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IDynamicPortMapping,
                pVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IDynamicPortMapping,
                pVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ExternalPort: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IDynamicPortMapping,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IDynamicPortMapping,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Protocol: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IDynamicPortMapping,
                pVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IDynamicPortMapping,
                pVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InternalPort: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IDynamicPortMapping,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IDynamicPortMapping,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InternalClient: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IDynamicPortMapping,
                pVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IDynamicPortMapping,
                pVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Enabled: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IDynamicPortMapping,
                pVal: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IDynamicPortMapping,
                pVal: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Description: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IDynamicPortMapping,
                pVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IDynamicPortMapping,
                pVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LeaseDuration: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IDynamicPortMapping,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IDynamicPortMapping,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RenewLease: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDynamicPortMapping,
                lLeaseDurationDesired: i32,
                pLeaseDurationReturned: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDynamicPortMapping,
                lLeaseDurationDesired: i32,
                pLeaseDurationReturned: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EditInternalClient: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDynamicPortMapping,
                bstrInternalClient: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDynamicPortMapping,
                bstrInternalClient: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Enable: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDynamicPortMapping,
                vb: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDynamicPortMapping,
                vb: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EditDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDynamicPortMapping,
                bstrDescription: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDynamicPortMapping,
                bstrDescription: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EditInternalPort: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDynamicPortMapping,
                lInternalPort: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDynamicPortMapping,
                lInternalPort: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDynamicPortMapping_get_ExternalIPAddress(self: *const T, pVal: ?*?BSTR) HRESULT {
                return @as(*const IDynamicPortMapping.VTable, @ptrCast(self.vtable)).get_ExternalIPAddress(@as(*const IDynamicPortMapping, @ptrCast(self)), pVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDynamicPortMapping_get_RemoteHost(self: *const T, pVal: ?*?BSTR) HRESULT {
                return @as(*const IDynamicPortMapping.VTable, @ptrCast(self.vtable)).get_RemoteHost(@as(*const IDynamicPortMapping, @ptrCast(self)), pVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDynamicPortMapping_get_ExternalPort(self: *const T, pVal: ?*i32) HRESULT {
                return @as(*const IDynamicPortMapping.VTable, @ptrCast(self.vtable)).get_ExternalPort(@as(*const IDynamicPortMapping, @ptrCast(self)), pVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDynamicPortMapping_get_Protocol(self: *const T, pVal: ?*?BSTR) HRESULT {
                return @as(*const IDynamicPortMapping.VTable, @ptrCast(self.vtable)).get_Protocol(@as(*const IDynamicPortMapping, @ptrCast(self)), pVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDynamicPortMapping_get_InternalPort(self: *const T, pVal: ?*i32) HRESULT {
                return @as(*const IDynamicPortMapping.VTable, @ptrCast(self.vtable)).get_InternalPort(@as(*const IDynamicPortMapping, @ptrCast(self)), pVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDynamicPortMapping_get_InternalClient(self: *const T, pVal: ?*?BSTR) HRESULT {
                return @as(*const IDynamicPortMapping.VTable, @ptrCast(self.vtable)).get_InternalClient(@as(*const IDynamicPortMapping, @ptrCast(self)), pVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDynamicPortMapping_get_Enabled(self: *const T, pVal: ?*i16) HRESULT {
                return @as(*const IDynamicPortMapping.VTable, @ptrCast(self.vtable)).get_Enabled(@as(*const IDynamicPortMapping, @ptrCast(self)), pVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDynamicPortMapping_get_Description(self: *const T, pVal: ?*?BSTR) HRESULT {
                return @as(*const IDynamicPortMapping.VTable, @ptrCast(self.vtable)).get_Description(@as(*const IDynamicPortMapping, @ptrCast(self)), pVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDynamicPortMapping_get_LeaseDuration(self: *const T, pVal: ?*i32) HRESULT {
                return @as(*const IDynamicPortMapping.VTable, @ptrCast(self.vtable)).get_LeaseDuration(@as(*const IDynamicPortMapping, @ptrCast(self)), pVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDynamicPortMapping_RenewLease(self: *const T, lLeaseDurationDesired: i32, pLeaseDurationReturned: ?*i32) HRESULT {
                return @as(*const IDynamicPortMapping.VTable, @ptrCast(self.vtable)).RenewLease(@as(*const IDynamicPortMapping, @ptrCast(self)), lLeaseDurationDesired, pLeaseDurationReturned);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDynamicPortMapping_EditInternalClient(self: *const T, bstrInternalClient: ?BSTR) HRESULT {
                return @as(*const IDynamicPortMapping.VTable, @ptrCast(self.vtable)).EditInternalClient(@as(*const IDynamicPortMapping, @ptrCast(self)), bstrInternalClient);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDynamicPortMapping_Enable(self: *const T, vb: i16) HRESULT {
                return @as(*const IDynamicPortMapping.VTable, @ptrCast(self.vtable)).Enable(@as(*const IDynamicPortMapping, @ptrCast(self)), vb);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDynamicPortMapping_EditDescription(self: *const T, bstrDescription: ?BSTR) HRESULT {
                return @as(*const IDynamicPortMapping.VTable, @ptrCast(self.vtable)).EditDescription(@as(*const IDynamicPortMapping, @ptrCast(self)), bstrDescription);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDynamicPortMapping_EditInternalPort(self: *const T, lInternalPort: i32) HRESULT {
                return @as(*const IDynamicPortMapping.VTable, @ptrCast(self.vtable)).EditInternalPort(@as(*const IDynamicPortMapping, @ptrCast(self)), lInternalPort);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IStaticPortMappingCollection_Value = Guid.initString("cd1f3e77-66d6-4664-82c7-36dbb641d0f1");
pub const IID_IStaticPortMappingCollection = &IID_IStaticPortMappingCollection_Value;
pub const IStaticPortMappingCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IStaticPortMappingCollection,
                pVal: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IStaticPortMappingCollection,
                pVal: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Item: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IStaticPortMappingCollection,
                lExternalPort: i32,
                bstrProtocol: ?BSTR,
                ppSPM: ?*?*IStaticPortMapping,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IStaticPortMappingCollection,
                lExternalPort: i32,
                bstrProtocol: ?BSTR,
                ppSPM: ?*?*IStaticPortMapping,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IStaticPortMappingCollection,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IStaticPortMappingCollection,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Remove: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IStaticPortMappingCollection,
                lExternalPort: i32,
                bstrProtocol: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IStaticPortMappingCollection,
                lExternalPort: i32,
                bstrProtocol: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Add: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IStaticPortMappingCollection,
                lExternalPort: i32,
                bstrProtocol: ?BSTR,
                lInternalPort: i32,
                bstrInternalClient: ?BSTR,
                bEnabled: i16,
                bstrDescription: ?BSTR,
                ppSPM: ?*?*IStaticPortMapping,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IStaticPortMappingCollection,
                lExternalPort: i32,
                bstrProtocol: ?BSTR,
                lInternalPort: i32,
                bstrInternalClient: ?BSTR,
                bEnabled: i16,
                bstrDescription: ?BSTR,
                ppSPM: ?*?*IStaticPortMapping,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IStaticPortMappingCollection_get__NewEnum(self: *const T, pVal: ?*?*IUnknown) HRESULT {
                return @as(*const IStaticPortMappingCollection.VTable, @ptrCast(self.vtable)).get__NewEnum(@as(*const IStaticPortMappingCollection, @ptrCast(self)), pVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IStaticPortMappingCollection_get_Item(self: *const T, lExternalPort: i32, bstrProtocol: ?BSTR, ppSPM: ?*?*IStaticPortMapping) HRESULT {
                return @as(*const IStaticPortMappingCollection.VTable, @ptrCast(self.vtable)).get_Item(@as(*const IStaticPortMappingCollection, @ptrCast(self)), lExternalPort, bstrProtocol, ppSPM);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IStaticPortMappingCollection_get_Count(self: *const T, pVal: ?*i32) HRESULT {
                return @as(*const IStaticPortMappingCollection.VTable, @ptrCast(self.vtable)).get_Count(@as(*const IStaticPortMappingCollection, @ptrCast(self)), pVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IStaticPortMappingCollection_Remove(self: *const T, lExternalPort: i32, bstrProtocol: ?BSTR) HRESULT {
                return @as(*const IStaticPortMappingCollection.VTable, @ptrCast(self.vtable)).Remove(@as(*const IStaticPortMappingCollection, @ptrCast(self)), lExternalPort, bstrProtocol);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IStaticPortMappingCollection_Add(self: *const T, lExternalPort: i32, bstrProtocol: ?BSTR, lInternalPort: i32, bstrInternalClient: ?BSTR, bEnabled: i16, bstrDescription: ?BSTR, ppSPM: ?*?*IStaticPortMapping) HRESULT {
                return @as(*const IStaticPortMappingCollection.VTable, @ptrCast(self.vtable)).Add(@as(*const IStaticPortMappingCollection, @ptrCast(self)), lExternalPort, bstrProtocol, lInternalPort, bstrInternalClient, bEnabled, bstrDescription, ppSPM);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IStaticPortMapping_Value = Guid.initString("6f10711f-729b-41e5-93b8-f21d0f818df1");
pub const IID_IStaticPortMapping = &IID_IStaticPortMapping_Value;
pub const IStaticPortMapping = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ExternalIPAddress: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IStaticPortMapping,
                pVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IStaticPortMapping,
                pVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ExternalPort: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IStaticPortMapping,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IStaticPortMapping,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InternalPort: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IStaticPortMapping,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IStaticPortMapping,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Protocol: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IStaticPortMapping,
                pVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IStaticPortMapping,
                pVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InternalClient: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IStaticPortMapping,
                pVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IStaticPortMapping,
                pVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Enabled: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IStaticPortMapping,
                pVal: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IStaticPortMapping,
                pVal: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Description: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IStaticPortMapping,
                pVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IStaticPortMapping,
                pVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EditInternalClient: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IStaticPortMapping,
                bstrInternalClient: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IStaticPortMapping,
                bstrInternalClient: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Enable: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IStaticPortMapping,
                vb: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IStaticPortMapping,
                vb: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EditDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IStaticPortMapping,
                bstrDescription: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IStaticPortMapping,
                bstrDescription: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EditInternalPort: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IStaticPortMapping,
                lInternalPort: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IStaticPortMapping,
                lInternalPort: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IStaticPortMapping_get_ExternalIPAddress(self: *const T, pVal: ?*?BSTR) HRESULT {
                return @as(*const IStaticPortMapping.VTable, @ptrCast(self.vtable)).get_ExternalIPAddress(@as(*const IStaticPortMapping, @ptrCast(self)), pVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IStaticPortMapping_get_ExternalPort(self: *const T, pVal: ?*i32) HRESULT {
                return @as(*const IStaticPortMapping.VTable, @ptrCast(self.vtable)).get_ExternalPort(@as(*const IStaticPortMapping, @ptrCast(self)), pVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IStaticPortMapping_get_InternalPort(self: *const T, pVal: ?*i32) HRESULT {
                return @as(*const IStaticPortMapping.VTable, @ptrCast(self.vtable)).get_InternalPort(@as(*const IStaticPortMapping, @ptrCast(self)), pVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IStaticPortMapping_get_Protocol(self: *const T, pVal: ?*?BSTR) HRESULT {
                return @as(*const IStaticPortMapping.VTable, @ptrCast(self.vtable)).get_Protocol(@as(*const IStaticPortMapping, @ptrCast(self)), pVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IStaticPortMapping_get_InternalClient(self: *const T, pVal: ?*?BSTR) HRESULT {
                return @as(*const IStaticPortMapping.VTable, @ptrCast(self.vtable)).get_InternalClient(@as(*const IStaticPortMapping, @ptrCast(self)), pVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IStaticPortMapping_get_Enabled(self: *const T, pVal: ?*i16) HRESULT {
                return @as(*const IStaticPortMapping.VTable, @ptrCast(self.vtable)).get_Enabled(@as(*const IStaticPortMapping, @ptrCast(self)), pVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IStaticPortMapping_get_Description(self: *const T, pVal: ?*?BSTR) HRESULT {
                return @as(*const IStaticPortMapping.VTable, @ptrCast(self.vtable)).get_Description(@as(*const IStaticPortMapping, @ptrCast(self)), pVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IStaticPortMapping_EditInternalClient(self: *const T, bstrInternalClient: ?BSTR) HRESULT {
                return @as(*const IStaticPortMapping.VTable, @ptrCast(self.vtable)).EditInternalClient(@as(*const IStaticPortMapping, @ptrCast(self)), bstrInternalClient);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IStaticPortMapping_Enable(self: *const T, vb: i16) HRESULT {
                return @as(*const IStaticPortMapping.VTable, @ptrCast(self.vtable)).Enable(@as(*const IStaticPortMapping, @ptrCast(self)), vb);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IStaticPortMapping_EditDescription(self: *const T, bstrDescription: ?BSTR) HRESULT {
                return @as(*const IStaticPortMapping.VTable, @ptrCast(self.vtable)).EditDescription(@as(*const IStaticPortMapping, @ptrCast(self)), bstrDescription);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IStaticPortMapping_EditInternalPort(self: *const T, lInternalPort: i32) HRESULT {
                return @as(*const IStaticPortMapping.VTable, @ptrCast(self.vtable)).EditInternalPort(@as(*const IStaticPortMapping, @ptrCast(self)), lInternalPort);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const CLSID_NetSharingManager_Value = Guid.initString("5c63c1ad-3956-4ff8-8486-40034758315b");
pub const CLSID_NetSharingManager = &CLSID_NetSharingManager_Value;

const IID_IEnumNetConnection_Value = Guid.initString("c08956a0-1cd3-11d1-b1c5-00805fc1270e");
pub const IID_IEnumNetConnection = &IID_IEnumNetConnection_Value;
pub const IEnumNetConnection = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumNetConnection,
                celt: u32,
                rgelt: [*]?*INetConnection,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumNetConnection,
                celt: u32,
                rgelt: [*]?*INetConnection,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumNetConnection,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumNetConnection,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumNetConnection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumNetConnection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumNetConnection,
                ppenum: ?*?*IEnumNetConnection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumNetConnection,
                ppenum: ?*?*IEnumNetConnection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumNetConnection_Next(self: *const T, celt: u32, rgelt: [*]?*INetConnection, pceltFetched: ?*u32) HRESULT {
                return @as(*const IEnumNetConnection.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumNetConnection, @ptrCast(self)), celt, rgelt, pceltFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumNetConnection_Skip(self: *const T, celt: u32) HRESULT {
                return @as(*const IEnumNetConnection.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumNetConnection, @ptrCast(self)), celt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumNetConnection_Reset(self: *const T) HRESULT {
                return @as(*const IEnumNetConnection.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumNetConnection, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumNetConnection_Clone(self: *const T, ppenum: ?*?*IEnumNetConnection) HRESULT {
                return @as(*const IEnumNetConnection.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumNetConnection, @ptrCast(self)), ppenum);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const NETCON_CHARACTERISTIC_FLAGS = enum(i32) {
    NONE = 0,
    ALL_USERS = 1,
    ALLOW_DUPLICATION = 2,
    ALLOW_REMOVAL = 4,
    ALLOW_RENAME = 8,
    INCOMING_ONLY = 32,
    OUTGOING_ONLY = 64,
    BRANDED = 128,
    SHARED = 256,
    BRIDGED = 512,
    FIREWALLED = 1024,
    DEFAULT = 2048,
    HOMENET_CAPABLE = 4096,
    SHARED_PRIVATE = 8192,
    QUARANTINED = 16384,
    RESERVED = 32768,
    HOSTED_NETWORK = 65536,
    VIRTUAL_STATION = 131072,
    WIFI_DIRECT = 262144,
    BLUETOOTH_MASK = 983040,
    LAN_MASK = 15728640,
};
pub const NCCF_NONE = NETCON_CHARACTERISTIC_FLAGS.NONE;
pub const NCCF_ALL_USERS = NETCON_CHARACTERISTIC_FLAGS.ALL_USERS;
pub const NCCF_ALLOW_DUPLICATION = NETCON_CHARACTERISTIC_FLAGS.ALLOW_DUPLICATION;
pub const NCCF_ALLOW_REMOVAL = NETCON_CHARACTERISTIC_FLAGS.ALLOW_REMOVAL;
pub const NCCF_ALLOW_RENAME = NETCON_CHARACTERISTIC_FLAGS.ALLOW_RENAME;
pub const NCCF_INCOMING_ONLY = NETCON_CHARACTERISTIC_FLAGS.INCOMING_ONLY;
pub const NCCF_OUTGOING_ONLY = NETCON_CHARACTERISTIC_FLAGS.OUTGOING_ONLY;
pub const NCCF_BRANDED = NETCON_CHARACTERISTIC_FLAGS.BRANDED;
pub const NCCF_SHARED = NETCON_CHARACTERISTIC_FLAGS.SHARED;
pub const NCCF_BRIDGED = NETCON_CHARACTERISTIC_FLAGS.BRIDGED;
pub const NCCF_FIREWALLED = NETCON_CHARACTERISTIC_FLAGS.FIREWALLED;
pub const NCCF_DEFAULT = NETCON_CHARACTERISTIC_FLAGS.DEFAULT;
pub const NCCF_HOMENET_CAPABLE = NETCON_CHARACTERISTIC_FLAGS.HOMENET_CAPABLE;
pub const NCCF_SHARED_PRIVATE = NETCON_CHARACTERISTIC_FLAGS.SHARED_PRIVATE;
pub const NCCF_QUARANTINED = NETCON_CHARACTERISTIC_FLAGS.QUARANTINED;
pub const NCCF_RESERVED = NETCON_CHARACTERISTIC_FLAGS.RESERVED;
pub const NCCF_HOSTED_NETWORK = NETCON_CHARACTERISTIC_FLAGS.HOSTED_NETWORK;
pub const NCCF_VIRTUAL_STATION = NETCON_CHARACTERISTIC_FLAGS.VIRTUAL_STATION;
pub const NCCF_WIFI_DIRECT = NETCON_CHARACTERISTIC_FLAGS.WIFI_DIRECT;
pub const NCCF_BLUETOOTH_MASK = NETCON_CHARACTERISTIC_FLAGS.BLUETOOTH_MASK;
pub const NCCF_LAN_MASK = NETCON_CHARACTERISTIC_FLAGS.LAN_MASK;

pub const NETCON_STATUS = enum(i32) {
    DISCONNECTED = 0,
    CONNECTING = 1,
    CONNECTED = 2,
    DISCONNECTING = 3,
    HARDWARE_NOT_PRESENT = 4,
    HARDWARE_DISABLED = 5,
    HARDWARE_MALFUNCTION = 6,
    MEDIA_DISCONNECTED = 7,
    AUTHENTICATING = 8,
    AUTHENTICATION_SUCCEEDED = 9,
    AUTHENTICATION_FAILED = 10,
    INVALID_ADDRESS = 11,
    CREDENTIALS_REQUIRED = 12,
    ACTION_REQUIRED = 13,
    ACTION_REQUIRED_RETRY = 14,
    CONNECT_FAILED = 15,
};
pub const NCS_DISCONNECTED = NETCON_STATUS.DISCONNECTED;
pub const NCS_CONNECTING = NETCON_STATUS.CONNECTING;
pub const NCS_CONNECTED = NETCON_STATUS.CONNECTED;
pub const NCS_DISCONNECTING = NETCON_STATUS.DISCONNECTING;
pub const NCS_HARDWARE_NOT_PRESENT = NETCON_STATUS.HARDWARE_NOT_PRESENT;
pub const NCS_HARDWARE_DISABLED = NETCON_STATUS.HARDWARE_DISABLED;
pub const NCS_HARDWARE_MALFUNCTION = NETCON_STATUS.HARDWARE_MALFUNCTION;
pub const NCS_MEDIA_DISCONNECTED = NETCON_STATUS.MEDIA_DISCONNECTED;
pub const NCS_AUTHENTICATING = NETCON_STATUS.AUTHENTICATING;
pub const NCS_AUTHENTICATION_SUCCEEDED = NETCON_STATUS.AUTHENTICATION_SUCCEEDED;
pub const NCS_AUTHENTICATION_FAILED = NETCON_STATUS.AUTHENTICATION_FAILED;
pub const NCS_INVALID_ADDRESS = NETCON_STATUS.INVALID_ADDRESS;
pub const NCS_CREDENTIALS_REQUIRED = NETCON_STATUS.CREDENTIALS_REQUIRED;
pub const NCS_ACTION_REQUIRED = NETCON_STATUS.ACTION_REQUIRED;
pub const NCS_ACTION_REQUIRED_RETRY = NETCON_STATUS.ACTION_REQUIRED_RETRY;
pub const NCS_CONNECT_FAILED = NETCON_STATUS.CONNECT_FAILED;

pub const NETCON_TYPE = enum(i32) {
    DIRECT_CONNECT = 0,
    INBOUND = 1,
    INTERNET = 2,
    LAN = 3,
    PHONE = 4,
    TUNNEL = 5,
    BRIDGE = 6,
};
pub const NCT_DIRECT_CONNECT = NETCON_TYPE.DIRECT_CONNECT;
pub const NCT_INBOUND = NETCON_TYPE.INBOUND;
pub const NCT_INTERNET = NETCON_TYPE.INTERNET;
pub const NCT_LAN = NETCON_TYPE.LAN;
pub const NCT_PHONE = NETCON_TYPE.PHONE;
pub const NCT_TUNNEL = NETCON_TYPE.TUNNEL;
pub const NCT_BRIDGE = NETCON_TYPE.BRIDGE;

pub const NETCON_MEDIATYPE = enum(i32) {
    NONE = 0,
    DIRECT = 1,
    ISDN = 2,
    LAN = 3,
    PHONE = 4,
    TUNNEL = 5,
    PPPOE = 6,
    BRIDGE = 7,
    SHAREDACCESSHOST_LAN = 8,
    SHAREDACCESSHOST_RAS = 9,
};
pub const NCM_NONE = NETCON_MEDIATYPE.NONE;
pub const NCM_DIRECT = NETCON_MEDIATYPE.DIRECT;
pub const NCM_ISDN = NETCON_MEDIATYPE.ISDN;
pub const NCM_LAN = NETCON_MEDIATYPE.LAN;
pub const NCM_PHONE = NETCON_MEDIATYPE.PHONE;
pub const NCM_TUNNEL = NETCON_MEDIATYPE.TUNNEL;
pub const NCM_PPPOE = NETCON_MEDIATYPE.PPPOE;
pub const NCM_BRIDGE = NETCON_MEDIATYPE.BRIDGE;
pub const NCM_SHAREDACCESSHOST_LAN = NETCON_MEDIATYPE.SHAREDACCESSHOST_LAN;
pub const NCM_SHAREDACCESSHOST_RAS = NETCON_MEDIATYPE.SHAREDACCESSHOST_RAS;

pub const NETCON_PROPERTIES = extern struct {
    guidId: Guid,
    pszwName: ?PWSTR,
    pszwDeviceName: ?PWSTR,
    Status: NETCON_STATUS,
    MediaType: NETCON_MEDIATYPE,
    dwCharacter: u32,
    clsidThisObject: Guid,
    clsidUiObject: Guid,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_INetConnection_Value = Guid.initString("c08956a1-1cd3-11d1-b1c5-00805fc1270e");
pub const IID_INetConnection = &IID_INetConnection_Value;
pub const INetConnection = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Connect: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INetConnection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INetConnection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Disconnect: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INetConnection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INetConnection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Delete: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INetConnection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INetConnection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Duplicate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INetConnection,
                pszwDuplicateName: ?[*:0]const u16,
                ppCon: ?*?*INetConnection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INetConnection,
                pszwDuplicateName: ?[*:0]const u16,
                ppCon: ?*?*INetConnection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProperties: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INetConnection,
                ppProps: ?*?*NETCON_PROPERTIES,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INetConnection,
                ppProps: ?*?*NETCON_PROPERTIES,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetUiObjectClassId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INetConnection,
                pclsid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INetConnection,
                pclsid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Rename: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INetConnection,
                pszwNewName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INetConnection,
                pszwNewName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetConnection_Connect(self: *const T) HRESULT {
                return @as(*const INetConnection.VTable, @ptrCast(self.vtable)).Connect(@as(*const INetConnection, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetConnection_Disconnect(self: *const T) HRESULT {
                return @as(*const INetConnection.VTable, @ptrCast(self.vtable)).Disconnect(@as(*const INetConnection, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetConnection_Delete(self: *const T) HRESULT {
                return @as(*const INetConnection.VTable, @ptrCast(self.vtable)).Delete(@as(*const INetConnection, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetConnection_Duplicate(self: *const T, pszwDuplicateName: ?[*:0]const u16, ppCon: ?*?*INetConnection) HRESULT {
                return @as(*const INetConnection.VTable, @ptrCast(self.vtable)).Duplicate(@as(*const INetConnection, @ptrCast(self)), pszwDuplicateName, ppCon);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetConnection_GetProperties(self: *const T, ppProps: ?*?*NETCON_PROPERTIES) HRESULT {
                return @as(*const INetConnection.VTable, @ptrCast(self.vtable)).GetProperties(@as(*const INetConnection, @ptrCast(self)), ppProps);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetConnection_GetUiObjectClassId(self: *const T, pclsid: ?*Guid) HRESULT {
                return @as(*const INetConnection.VTable, @ptrCast(self.vtable)).GetUiObjectClassId(@as(*const INetConnection, @ptrCast(self)), pclsid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetConnection_Rename(self: *const T, pszwNewName: ?[*:0]const u16) HRESULT {
                return @as(*const INetConnection.VTable, @ptrCast(self.vtable)).Rename(@as(*const INetConnection, @ptrCast(self)), pszwNewName);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const NETCONMGR_ENUM_FLAGS = enum(i32) {
    DEFAULT = 0,
    HIDDEN = 1,
};
pub const NCME_DEFAULT = NETCONMGR_ENUM_FLAGS.DEFAULT;
pub const NCME_HIDDEN = NETCONMGR_ENUM_FLAGS.HIDDEN;

const IID_INetConnectionManager_Value = Guid.initString("c08956a2-1cd3-11d1-b1c5-00805fc1270e");
pub const IID_INetConnectionManager = &IID_INetConnectionManager_Value;
pub const INetConnectionManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EnumConnections: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INetConnectionManager,
                Flags: NETCONMGR_ENUM_FLAGS,
                ppEnum: ?*?*IEnumNetConnection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INetConnectionManager,
                Flags: NETCONMGR_ENUM_FLAGS,
                ppEnum: ?*?*IEnumNetConnection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetConnectionManager_EnumConnections(self: *const T, Flags: NETCONMGR_ENUM_FLAGS, ppEnum: ?*?*IEnumNetConnection) HRESULT {
                return @as(*const INetConnectionManager.VTable, @ptrCast(self.vtable)).EnumConnections(@as(*const INetConnectionManager, @ptrCast(self)), Flags, ppEnum);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const NETCONUI_CONNECT_FLAGS = enum(i32) {
    DEFAULT = 0,
    NO_UI = 1,
    ENABLE_DISABLE = 2,
};
pub const NCUC_DEFAULT = NETCONUI_CONNECT_FLAGS.DEFAULT;
pub const NCUC_NO_UI = NETCONUI_CONNECT_FLAGS.NO_UI;
pub const NCUC_ENABLE_DISABLE = NETCONUI_CONNECT_FLAGS.ENABLE_DISABLE;

const IID_INetConnectionConnectUi_Value = Guid.initString("c08956a3-1cd3-11d1-b1c5-00805fc1270e");
pub const IID_INetConnectionConnectUi = &IID_INetConnectionConnectUi_Value;
pub const INetConnectionConnectUi = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetConnection: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INetConnectionConnectUi,
                pCon: ?*INetConnection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INetConnectionConnectUi,
                pCon: ?*INetConnection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Connect: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INetConnectionConnectUi,
                hwndParent: ?HWND,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INetConnectionConnectUi,
                hwndParent: ?HWND,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Disconnect: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INetConnectionConnectUi,
                hwndParent: ?HWND,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INetConnectionConnectUi,
                hwndParent: ?HWND,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetConnectionConnectUi_SetConnection(self: *const T, pCon: ?*INetConnection) HRESULT {
                return @as(*const INetConnectionConnectUi.VTable, @ptrCast(self.vtable)).SetConnection(@as(*const INetConnectionConnectUi, @ptrCast(self)), pCon);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetConnectionConnectUi_Connect(self: *const T, hwndParent: ?HWND, dwFlags: u32) HRESULT {
                return @as(*const INetConnectionConnectUi.VTable, @ptrCast(self.vtable)).Connect(@as(*const INetConnectionConnectUi, @ptrCast(self)), hwndParent, dwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetConnectionConnectUi_Disconnect(self: *const T, hwndParent: ?HWND, dwFlags: u32) HRESULT {
                return @as(*const INetConnectionConnectUi.VTable, @ptrCast(self.vtable)).Disconnect(@as(*const INetConnectionConnectUi, @ptrCast(self)), hwndParent, dwFlags);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IEnumNetSharingPortMapping_Value = Guid.initString("c08956b0-1cd3-11d1-b1c5-00805fc1270e");
pub const IID_IEnumNetSharingPortMapping = &IID_IEnumNetSharingPortMapping_Value;
pub const IEnumNetSharingPortMapping = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumNetSharingPortMapping,
                celt: u32,
                rgVar: [*]VARIANT,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumNetSharingPortMapping,
                celt: u32,
                rgVar: [*]VARIANT,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumNetSharingPortMapping,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumNetSharingPortMapping,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumNetSharingPortMapping,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumNetSharingPortMapping,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumNetSharingPortMapping,
                ppenum: ?*?*IEnumNetSharingPortMapping,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumNetSharingPortMapping,
                ppenum: ?*?*IEnumNetSharingPortMapping,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumNetSharingPortMapping_Next(self: *const T, celt: u32, rgVar: [*]VARIANT, pceltFetched: ?*u32) HRESULT {
                return @as(*const IEnumNetSharingPortMapping.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumNetSharingPortMapping, @ptrCast(self)), celt, rgVar, pceltFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumNetSharingPortMapping_Skip(self: *const T, celt: u32) HRESULT {
                return @as(*const IEnumNetSharingPortMapping.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumNetSharingPortMapping, @ptrCast(self)), celt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumNetSharingPortMapping_Reset(self: *const T) HRESULT {
                return @as(*const IEnumNetSharingPortMapping.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumNetSharingPortMapping, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumNetSharingPortMapping_Clone(self: *const T, ppenum: ?*?*IEnumNetSharingPortMapping) HRESULT {
                return @as(*const IEnumNetSharingPortMapping.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumNetSharingPortMapping, @ptrCast(self)), ppenum);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_INetSharingPortMappingProps_Value = Guid.initString("24b7e9b5-e38f-4685-851b-00892cf5f940");
pub const IID_INetSharingPortMappingProps = &IID_INetSharingPortMappingProps_Value;
pub const INetSharingPortMappingProps = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetSharingPortMappingProps,
                pbstrName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetSharingPortMappingProps,
                pbstrName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IPProtocol: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetSharingPortMappingProps,
                pucIPProt: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetSharingPortMappingProps,
                pucIPProt: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ExternalPort: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetSharingPortMappingProps,
                pusPort: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetSharingPortMappingProps,
                pusPort: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InternalPort: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetSharingPortMappingProps,
                pusPort: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetSharingPortMappingProps,
                pusPort: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Options: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetSharingPortMappingProps,
                pdwOptions: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetSharingPortMappingProps,
                pdwOptions: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TargetName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetSharingPortMappingProps,
                pbstrTargetName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetSharingPortMappingProps,
                pbstrTargetName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TargetIPAddress: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetSharingPortMappingProps,
                pbstrTargetIPAddress: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetSharingPortMappingProps,
                pbstrTargetIPAddress: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Enabled: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetSharingPortMappingProps,
                pbool: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetSharingPortMappingProps,
                pbool: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetSharingPortMappingProps_get_Name(self: *const T, pbstrName: ?*?BSTR) HRESULT {
                return @as(*const INetSharingPortMappingProps.VTable, @ptrCast(self.vtable)).get_Name(@as(*const INetSharingPortMappingProps, @ptrCast(self)), pbstrName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetSharingPortMappingProps_get_IPProtocol(self: *const T, pucIPProt: ?*u8) HRESULT {
                return @as(*const INetSharingPortMappingProps.VTable, @ptrCast(self.vtable)).get_IPProtocol(@as(*const INetSharingPortMappingProps, @ptrCast(self)), pucIPProt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetSharingPortMappingProps_get_ExternalPort(self: *const T, pusPort: ?*i32) HRESULT {
                return @as(*const INetSharingPortMappingProps.VTable, @ptrCast(self.vtable)).get_ExternalPort(@as(*const INetSharingPortMappingProps, @ptrCast(self)), pusPort);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetSharingPortMappingProps_get_InternalPort(self: *const T, pusPort: ?*i32) HRESULT {
                return @as(*const INetSharingPortMappingProps.VTable, @ptrCast(self.vtable)).get_InternalPort(@as(*const INetSharingPortMappingProps, @ptrCast(self)), pusPort);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetSharingPortMappingProps_get_Options(self: *const T, pdwOptions: ?*i32) HRESULT {
                return @as(*const INetSharingPortMappingProps.VTable, @ptrCast(self.vtable)).get_Options(@as(*const INetSharingPortMappingProps, @ptrCast(self)), pdwOptions);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetSharingPortMappingProps_get_TargetName(self: *const T, pbstrTargetName: ?*?BSTR) HRESULT {
                return @as(*const INetSharingPortMappingProps.VTable, @ptrCast(self.vtable)).get_TargetName(@as(*const INetSharingPortMappingProps, @ptrCast(self)), pbstrTargetName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetSharingPortMappingProps_get_TargetIPAddress(self: *const T, pbstrTargetIPAddress: ?*?BSTR) HRESULT {
                return @as(*const INetSharingPortMappingProps.VTable, @ptrCast(self.vtable)).get_TargetIPAddress(@as(*const INetSharingPortMappingProps, @ptrCast(self)), pbstrTargetIPAddress);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetSharingPortMappingProps_get_Enabled(self: *const T, pbool: ?*i16) HRESULT {
                return @as(*const INetSharingPortMappingProps.VTable, @ptrCast(self.vtable)).get_Enabled(@as(*const INetSharingPortMappingProps, @ptrCast(self)), pbool);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_INetSharingPortMapping_Value = Guid.initString("c08956b1-1cd3-11d1-b1c5-00805fc1270e");
pub const IID_INetSharingPortMapping = &IID_INetSharingPortMapping_Value;
pub const INetSharingPortMapping = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Disable: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INetSharingPortMapping,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INetSharingPortMapping,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Enable: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INetSharingPortMapping,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INetSharingPortMapping,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Properties: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetSharingPortMapping,
                ppNSPMP: ?*?*INetSharingPortMappingProps,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetSharingPortMapping,
                ppNSPMP: ?*?*INetSharingPortMappingProps,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Delete: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INetSharingPortMapping,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INetSharingPortMapping,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetSharingPortMapping_Disable(self: *const T) HRESULT {
                return @as(*const INetSharingPortMapping.VTable, @ptrCast(self.vtable)).Disable(@as(*const INetSharingPortMapping, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetSharingPortMapping_Enable(self: *const T) HRESULT {
                return @as(*const INetSharingPortMapping.VTable, @ptrCast(self.vtable)).Enable(@as(*const INetSharingPortMapping, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetSharingPortMapping_get_Properties(self: *const T, ppNSPMP: ?*?*INetSharingPortMappingProps) HRESULT {
                return @as(*const INetSharingPortMapping.VTable, @ptrCast(self.vtable)).get_Properties(@as(*const INetSharingPortMapping, @ptrCast(self)), ppNSPMP);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetSharingPortMapping_Delete(self: *const T) HRESULT {
                return @as(*const INetSharingPortMapping.VTable, @ptrCast(self.vtable)).Delete(@as(*const INetSharingPortMapping, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IEnumNetSharingEveryConnection_Value = Guid.initString("c08956b8-1cd3-11d1-b1c5-00805fc1270e");
pub const IID_IEnumNetSharingEveryConnection = &IID_IEnumNetSharingEveryConnection_Value;
pub const IEnumNetSharingEveryConnection = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumNetSharingEveryConnection,
                celt: u32,
                rgVar: [*]VARIANT,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumNetSharingEveryConnection,
                celt: u32,
                rgVar: [*]VARIANT,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumNetSharingEveryConnection,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumNetSharingEveryConnection,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumNetSharingEveryConnection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumNetSharingEveryConnection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumNetSharingEveryConnection,
                ppenum: ?*?*IEnumNetSharingEveryConnection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumNetSharingEveryConnection,
                ppenum: ?*?*IEnumNetSharingEveryConnection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumNetSharingEveryConnection_Next(self: *const T, celt: u32, rgVar: [*]VARIANT, pceltFetched: ?*u32) HRESULT {
                return @as(*const IEnumNetSharingEveryConnection.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumNetSharingEveryConnection, @ptrCast(self)), celt, rgVar, pceltFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumNetSharingEveryConnection_Skip(self: *const T, celt: u32) HRESULT {
                return @as(*const IEnumNetSharingEveryConnection.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumNetSharingEveryConnection, @ptrCast(self)), celt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumNetSharingEveryConnection_Reset(self: *const T) HRESULT {
                return @as(*const IEnumNetSharingEveryConnection.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumNetSharingEveryConnection, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumNetSharingEveryConnection_Clone(self: *const T, ppenum: ?*?*IEnumNetSharingEveryConnection) HRESULT {
                return @as(*const IEnumNetSharingEveryConnection.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumNetSharingEveryConnection, @ptrCast(self)), ppenum);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IEnumNetSharingPublicConnection_Value = Guid.initString("c08956b4-1cd3-11d1-b1c5-00805fc1270e");
pub const IID_IEnumNetSharingPublicConnection = &IID_IEnumNetSharingPublicConnection_Value;
pub const IEnumNetSharingPublicConnection = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumNetSharingPublicConnection,
                celt: u32,
                rgVar: [*]VARIANT,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumNetSharingPublicConnection,
                celt: u32,
                rgVar: [*]VARIANT,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumNetSharingPublicConnection,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumNetSharingPublicConnection,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumNetSharingPublicConnection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumNetSharingPublicConnection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumNetSharingPublicConnection,
                ppenum: ?*?*IEnumNetSharingPublicConnection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumNetSharingPublicConnection,
                ppenum: ?*?*IEnumNetSharingPublicConnection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumNetSharingPublicConnection_Next(self: *const T, celt: u32, rgVar: [*]VARIANT, pceltFetched: ?*u32) HRESULT {
                return @as(*const IEnumNetSharingPublicConnection.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumNetSharingPublicConnection, @ptrCast(self)), celt, rgVar, pceltFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumNetSharingPublicConnection_Skip(self: *const T, celt: u32) HRESULT {
                return @as(*const IEnumNetSharingPublicConnection.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumNetSharingPublicConnection, @ptrCast(self)), celt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumNetSharingPublicConnection_Reset(self: *const T) HRESULT {
                return @as(*const IEnumNetSharingPublicConnection.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumNetSharingPublicConnection, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumNetSharingPublicConnection_Clone(self: *const T, ppenum: ?*?*IEnumNetSharingPublicConnection) HRESULT {
                return @as(*const IEnumNetSharingPublicConnection.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumNetSharingPublicConnection, @ptrCast(self)), ppenum);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IEnumNetSharingPrivateConnection_Value = Guid.initString("c08956b5-1cd3-11d1-b1c5-00805fc1270e");
pub const IID_IEnumNetSharingPrivateConnection = &IID_IEnumNetSharingPrivateConnection_Value;
pub const IEnumNetSharingPrivateConnection = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumNetSharingPrivateConnection,
                celt: u32,
                rgVar: [*]VARIANT,
                pCeltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumNetSharingPrivateConnection,
                celt: u32,
                rgVar: [*]VARIANT,
                pCeltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumNetSharingPrivateConnection,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumNetSharingPrivateConnection,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumNetSharingPrivateConnection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumNetSharingPrivateConnection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumNetSharingPrivateConnection,
                ppenum: ?*?*IEnumNetSharingPrivateConnection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumNetSharingPrivateConnection,
                ppenum: ?*?*IEnumNetSharingPrivateConnection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumNetSharingPrivateConnection_Next(self: *const T, celt: u32, rgVar: [*]VARIANT, pCeltFetched: ?*u32) HRESULT {
                return @as(*const IEnumNetSharingPrivateConnection.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumNetSharingPrivateConnection, @ptrCast(self)), celt, rgVar, pCeltFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumNetSharingPrivateConnection_Skip(self: *const T, celt: u32) HRESULT {
                return @as(*const IEnumNetSharingPrivateConnection.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumNetSharingPrivateConnection, @ptrCast(self)), celt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumNetSharingPrivateConnection_Reset(self: *const T) HRESULT {
                return @as(*const IEnumNetSharingPrivateConnection.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumNetSharingPrivateConnection, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumNetSharingPrivateConnection_Clone(self: *const T, ppenum: ?*?*IEnumNetSharingPrivateConnection) HRESULT {
                return @as(*const IEnumNetSharingPrivateConnection.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumNetSharingPrivateConnection, @ptrCast(self)), ppenum);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_INetSharingPortMappingCollection_Value = Guid.initString("02e4a2de-da20-4e34-89c8-ac22275a010b");
pub const IID_INetSharingPortMappingCollection = &IID_INetSharingPortMappingCollection_Value;
pub const INetSharingPortMappingCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetSharingPortMappingCollection,
                pVal: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetSharingPortMappingCollection,
                pVal: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetSharingPortMappingCollection,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetSharingPortMappingCollection,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetSharingPortMappingCollection_get__NewEnum(self: *const T, pVal: ?*?*IUnknown) HRESULT {
                return @as(*const INetSharingPortMappingCollection.VTable, @ptrCast(self.vtable)).get__NewEnum(@as(*const INetSharingPortMappingCollection, @ptrCast(self)), pVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetSharingPortMappingCollection_get_Count(self: *const T, pVal: ?*i32) HRESULT {
                return @as(*const INetSharingPortMappingCollection.VTable, @ptrCast(self.vtable)).get_Count(@as(*const INetSharingPortMappingCollection, @ptrCast(self)), pVal);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_INetConnectionProps_Value = Guid.initString("f4277c95-ce5b-463d-8167-5662d9bcaa72");
pub const IID_INetConnectionProps = &IID_INetConnectionProps_Value;
pub const INetConnectionProps = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Guid: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetConnectionProps,
                pbstrGuid: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetConnectionProps,
                pbstrGuid: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetConnectionProps,
                pbstrName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetConnectionProps,
                pbstrName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DeviceName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetConnectionProps,
                pbstrDeviceName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetConnectionProps,
                pbstrDeviceName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Status: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetConnectionProps,
                pStatus: ?*NETCON_STATUS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetConnectionProps,
                pStatus: ?*NETCON_STATUS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MediaType: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetConnectionProps,
                pMediaType: ?*NETCON_MEDIATYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetConnectionProps,
                pMediaType: ?*NETCON_MEDIATYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Characteristics: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetConnectionProps,
                pdwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetConnectionProps,
                pdwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetConnectionProps_get_Guid(self: *const T, pbstrGuid: ?*?BSTR) HRESULT {
                return @as(*const INetConnectionProps.VTable, @ptrCast(self.vtable)).get_Guid(@as(*const INetConnectionProps, @ptrCast(self)), pbstrGuid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetConnectionProps_get_Name(self: *const T, pbstrName: ?*?BSTR) HRESULT {
                return @as(*const INetConnectionProps.VTable, @ptrCast(self.vtable)).get_Name(@as(*const INetConnectionProps, @ptrCast(self)), pbstrName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetConnectionProps_get_DeviceName(self: *const T, pbstrDeviceName: ?*?BSTR) HRESULT {
                return @as(*const INetConnectionProps.VTable, @ptrCast(self.vtable)).get_DeviceName(@as(*const INetConnectionProps, @ptrCast(self)), pbstrDeviceName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetConnectionProps_get_Status(self: *const T, pStatus: ?*NETCON_STATUS) HRESULT {
                return @as(*const INetConnectionProps.VTable, @ptrCast(self.vtable)).get_Status(@as(*const INetConnectionProps, @ptrCast(self)), pStatus);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetConnectionProps_get_MediaType(self: *const T, pMediaType: ?*NETCON_MEDIATYPE) HRESULT {
                return @as(*const INetConnectionProps.VTable, @ptrCast(self.vtable)).get_MediaType(@as(*const INetConnectionProps, @ptrCast(self)), pMediaType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetConnectionProps_get_Characteristics(self: *const T, pdwFlags: ?*u32) HRESULT {
                return @as(*const INetConnectionProps.VTable, @ptrCast(self.vtable)).get_Characteristics(@as(*const INetConnectionProps, @ptrCast(self)), pdwFlags);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SHARINGCONNECTIONTYPE = enum(i32) {
    UBLIC = 0,
    RIVATE = 1,
};
pub const ICSSHARINGTYPE_PUBLIC = SHARINGCONNECTIONTYPE.UBLIC;
pub const ICSSHARINGTYPE_PRIVATE = SHARINGCONNECTIONTYPE.RIVATE;

pub const SHARINGCONNECTION_ENUM_FLAGS = enum(i32) {
    DEFAULT = 0,
    ENABLED = 1,
};
pub const ICSSC_DEFAULT = SHARINGCONNECTION_ENUM_FLAGS.DEFAULT;
pub const ICSSC_ENABLED = SHARINGCONNECTION_ENUM_FLAGS.ENABLED;

pub const ICS_TARGETTYPE = enum(i32) {
    NAME = 0,
    IPADDRESS = 1,
};
pub const ICSTT_NAME = ICS_TARGETTYPE.NAME;
pub const ICSTT_IPADDRESS = ICS_TARGETTYPE.IPADDRESS;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_INetSharingConfiguration_Value = Guid.initString("c08956b6-1cd3-11d1-b1c5-00805fc1270e");
pub const IID_INetSharingConfiguration = &IID_INetSharingConfiguration_Value;
pub const INetSharingConfiguration = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SharingEnabled: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetSharingConfiguration,
                pbEnabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetSharingConfiguration,
                pbEnabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SharingConnectionType: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetSharingConfiguration,
                pType: ?*SHARINGCONNECTIONTYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetSharingConfiguration,
                pType: ?*SHARINGCONNECTIONTYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DisableSharing: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INetSharingConfiguration,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INetSharingConfiguration,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnableSharing: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INetSharingConfiguration,
                Type: SHARINGCONNECTIONTYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INetSharingConfiguration,
                Type: SHARINGCONNECTIONTYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InternetFirewallEnabled: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetSharingConfiguration,
                pbEnabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetSharingConfiguration,
                pbEnabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DisableInternetFirewall: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INetSharingConfiguration,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INetSharingConfiguration,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnableInternetFirewall: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INetSharingConfiguration,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INetSharingConfiguration,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EnumPortMappings: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetSharingConfiguration,
                Flags: SHARINGCONNECTION_ENUM_FLAGS,
                ppColl: ?*?*INetSharingPortMappingCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetSharingConfiguration,
                Flags: SHARINGCONNECTION_ENUM_FLAGS,
                ppColl: ?*?*INetSharingPortMappingCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddPortMapping: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INetSharingConfiguration,
                bstrName: ?BSTR,
                ucIPProtocol: u8,
                usExternalPort: u16,
                usInternalPort: u16,
                dwOptions: u32,
                bstrTargetNameOrIPAddress: ?BSTR,
                eTargetType: ICS_TARGETTYPE,
                ppMapping: ?*?*INetSharingPortMapping,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INetSharingConfiguration,
                bstrName: ?BSTR,
                ucIPProtocol: u8,
                usExternalPort: u16,
                usInternalPort: u16,
                dwOptions: u32,
                bstrTargetNameOrIPAddress: ?BSTR,
                eTargetType: ICS_TARGETTYPE,
                ppMapping: ?*?*INetSharingPortMapping,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemovePortMapping: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INetSharingConfiguration,
                pMapping: ?*INetSharingPortMapping,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INetSharingConfiguration,
                pMapping: ?*INetSharingPortMapping,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetSharingConfiguration_get_SharingEnabled(self: *const T, pbEnabled: ?*i16) HRESULT {
                return @as(*const INetSharingConfiguration.VTable, @ptrCast(self.vtable)).get_SharingEnabled(@as(*const INetSharingConfiguration, @ptrCast(self)), pbEnabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetSharingConfiguration_get_SharingConnectionType(self: *const T, pType: ?*SHARINGCONNECTIONTYPE) HRESULT {
                return @as(*const INetSharingConfiguration.VTable, @ptrCast(self.vtable)).get_SharingConnectionType(@as(*const INetSharingConfiguration, @ptrCast(self)), pType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetSharingConfiguration_DisableSharing(self: *const T) HRESULT {
                return @as(*const INetSharingConfiguration.VTable, @ptrCast(self.vtable)).DisableSharing(@as(*const INetSharingConfiguration, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetSharingConfiguration_EnableSharing(self: *const T, Type: SHARINGCONNECTIONTYPE) HRESULT {
                return @as(*const INetSharingConfiguration.VTable, @ptrCast(self.vtable)).EnableSharing(@as(*const INetSharingConfiguration, @ptrCast(self)), Type);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetSharingConfiguration_get_InternetFirewallEnabled(self: *const T, pbEnabled: ?*i16) HRESULT {
                return @as(*const INetSharingConfiguration.VTable, @ptrCast(self.vtable)).get_InternetFirewallEnabled(@as(*const INetSharingConfiguration, @ptrCast(self)), pbEnabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetSharingConfiguration_DisableInternetFirewall(self: *const T) HRESULT {
                return @as(*const INetSharingConfiguration.VTable, @ptrCast(self.vtable)).DisableInternetFirewall(@as(*const INetSharingConfiguration, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetSharingConfiguration_EnableInternetFirewall(self: *const T) HRESULT {
                return @as(*const INetSharingConfiguration.VTable, @ptrCast(self.vtable)).EnableInternetFirewall(@as(*const INetSharingConfiguration, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetSharingConfiguration_get_EnumPortMappings(self: *const T, Flags: SHARINGCONNECTION_ENUM_FLAGS, ppColl: ?*?*INetSharingPortMappingCollection) HRESULT {
                return @as(*const INetSharingConfiguration.VTable, @ptrCast(self.vtable)).get_EnumPortMappings(@as(*const INetSharingConfiguration, @ptrCast(self)), Flags, ppColl);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetSharingConfiguration_AddPortMapping(self: *const T, bstrName: ?BSTR, ucIPProtocol: u8, usExternalPort: u16, usInternalPort: u16, dwOptions: u32, bstrTargetNameOrIPAddress: ?BSTR, eTargetType: ICS_TARGETTYPE, ppMapping: ?*?*INetSharingPortMapping) HRESULT {
                return @as(*const INetSharingConfiguration.VTable, @ptrCast(self.vtable)).AddPortMapping(@as(*const INetSharingConfiguration, @ptrCast(self)), bstrName, ucIPProtocol, usExternalPort, usInternalPort, dwOptions, bstrTargetNameOrIPAddress, eTargetType, ppMapping);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetSharingConfiguration_RemovePortMapping(self: *const T, pMapping: ?*INetSharingPortMapping) HRESULT {
                return @as(*const INetSharingConfiguration.VTable, @ptrCast(self.vtable)).RemovePortMapping(@as(*const INetSharingConfiguration, @ptrCast(self)), pMapping);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_INetSharingEveryConnectionCollection_Value = Guid.initString("33c4643c-7811-46fa-a89a-768597bd7223");
pub const IID_INetSharingEveryConnectionCollection = &IID_INetSharingEveryConnectionCollection_Value;
pub const INetSharingEveryConnectionCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetSharingEveryConnectionCollection,
                pVal: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetSharingEveryConnectionCollection,
                pVal: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetSharingEveryConnectionCollection,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetSharingEveryConnectionCollection,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetSharingEveryConnectionCollection_get__NewEnum(self: *const T, pVal: ?*?*IUnknown) HRESULT {
                return @as(*const INetSharingEveryConnectionCollection.VTable, @ptrCast(self.vtable)).get__NewEnum(@as(*const INetSharingEveryConnectionCollection, @ptrCast(self)), pVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetSharingEveryConnectionCollection_get_Count(self: *const T, pVal: ?*i32) HRESULT {
                return @as(*const INetSharingEveryConnectionCollection.VTable, @ptrCast(self.vtable)).get_Count(@as(*const INetSharingEveryConnectionCollection, @ptrCast(self)), pVal);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_INetSharingPublicConnectionCollection_Value = Guid.initString("7d7a6355-f372-4971-a149-bfc927be762a");
pub const IID_INetSharingPublicConnectionCollection = &IID_INetSharingPublicConnectionCollection_Value;
pub const INetSharingPublicConnectionCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetSharingPublicConnectionCollection,
                pVal: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetSharingPublicConnectionCollection,
                pVal: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetSharingPublicConnectionCollection,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetSharingPublicConnectionCollection,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetSharingPublicConnectionCollection_get__NewEnum(self: *const T, pVal: ?*?*IUnknown) HRESULT {
                return @as(*const INetSharingPublicConnectionCollection.VTable, @ptrCast(self.vtable)).get__NewEnum(@as(*const INetSharingPublicConnectionCollection, @ptrCast(self)), pVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetSharingPublicConnectionCollection_get_Count(self: *const T, pVal: ?*i32) HRESULT {
                return @as(*const INetSharingPublicConnectionCollection.VTable, @ptrCast(self.vtable)).get_Count(@as(*const INetSharingPublicConnectionCollection, @ptrCast(self)), pVal);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_INetSharingPrivateConnectionCollection_Value = Guid.initString("38ae69e0-4409-402a-a2cb-e965c727f840");
pub const IID_INetSharingPrivateConnectionCollection = &IID_INetSharingPrivateConnectionCollection_Value;
pub const INetSharingPrivateConnectionCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetSharingPrivateConnectionCollection,
                pVal: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetSharingPrivateConnectionCollection,
                pVal: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetSharingPrivateConnectionCollection,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetSharingPrivateConnectionCollection,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetSharingPrivateConnectionCollection_get__NewEnum(self: *const T, pVal: ?*?*IUnknown) HRESULT {
                return @as(*const INetSharingPrivateConnectionCollection.VTable, @ptrCast(self.vtable)).get__NewEnum(@as(*const INetSharingPrivateConnectionCollection, @ptrCast(self)), pVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetSharingPrivateConnectionCollection_get_Count(self: *const T, pVal: ?*i32) HRESULT {
                return @as(*const INetSharingPrivateConnectionCollection.VTable, @ptrCast(self.vtable)).get_Count(@as(*const INetSharingPrivateConnectionCollection, @ptrCast(self)), pVal);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_INetSharingManager_Value = Guid.initString("c08956b7-1cd3-11d1-b1c5-00805fc1270e");
pub const IID_INetSharingManager = &IID_INetSharingManager_Value;
pub const INetSharingManager = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SharingInstalled: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetSharingManager,
                pbInstalled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetSharingManager,
                pbInstalled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EnumPublicConnections: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetSharingManager,
                Flags: SHARINGCONNECTION_ENUM_FLAGS,
                ppColl: ?*?*INetSharingPublicConnectionCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetSharingManager,
                Flags: SHARINGCONNECTION_ENUM_FLAGS,
                ppColl: ?*?*INetSharingPublicConnectionCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EnumPrivateConnections: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetSharingManager,
                Flags: SHARINGCONNECTION_ENUM_FLAGS,
                ppColl: ?*?*INetSharingPrivateConnectionCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetSharingManager,
                Flags: SHARINGCONNECTION_ENUM_FLAGS,
                ppColl: ?*?*INetSharingPrivateConnectionCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_INetSharingConfigurationForINetConnection: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetSharingManager,
                pNetConnection: ?*INetConnection,
                ppNetSharingConfiguration: ?*?*INetSharingConfiguration,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetSharingManager,
                pNetConnection: ?*INetConnection,
                ppNetSharingConfiguration: ?*?*INetSharingConfiguration,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EnumEveryConnection: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetSharingManager,
                ppColl: ?*?*INetSharingEveryConnectionCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetSharingManager,
                ppColl: ?*?*INetSharingEveryConnectionCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NetConnectionProps: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetSharingManager,
                pNetConnection: ?*INetConnection,
                ppProps: ?*?*INetConnectionProps,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetSharingManager,
                pNetConnection: ?*INetConnection,
                ppProps: ?*?*INetConnectionProps,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetSharingManager_get_SharingInstalled(self: *const T, pbInstalled: ?*i16) HRESULT {
                return @as(*const INetSharingManager.VTable, @ptrCast(self.vtable)).get_SharingInstalled(@as(*const INetSharingManager, @ptrCast(self)), pbInstalled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetSharingManager_get_EnumPublicConnections(self: *const T, Flags: SHARINGCONNECTION_ENUM_FLAGS, ppColl: ?*?*INetSharingPublicConnectionCollection) HRESULT {
                return @as(*const INetSharingManager.VTable, @ptrCast(self.vtable)).get_EnumPublicConnections(@as(*const INetSharingManager, @ptrCast(self)), Flags, ppColl);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetSharingManager_get_EnumPrivateConnections(self: *const T, Flags: SHARINGCONNECTION_ENUM_FLAGS, ppColl: ?*?*INetSharingPrivateConnectionCollection) HRESULT {
                return @as(*const INetSharingManager.VTable, @ptrCast(self.vtable)).get_EnumPrivateConnections(@as(*const INetSharingManager, @ptrCast(self)), Flags, ppColl);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetSharingManager_get_INetSharingConfigurationForINetConnection(self: *const T, pNetConnection: ?*INetConnection, ppNetSharingConfiguration: ?*?*INetSharingConfiguration) HRESULT {
                return @as(*const INetSharingManager.VTable, @ptrCast(self.vtable)).get_INetSharingConfigurationForINetConnection(@as(*const INetSharingManager, @ptrCast(self)), pNetConnection, ppNetSharingConfiguration);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetSharingManager_get_EnumEveryConnection(self: *const T, ppColl: ?*?*INetSharingEveryConnectionCollection) HRESULT {
                return @as(*const INetSharingManager.VTable, @ptrCast(self.vtable)).get_EnumEveryConnection(@as(*const INetSharingManager, @ptrCast(self)), ppColl);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetSharingManager_get_NetConnectionProps(self: *const T, pNetConnection: ?*INetConnection, ppProps: ?*?*INetConnectionProps) HRESULT {
                return @as(*const INetSharingManager.VTable, @ptrCast(self.vtable)).get_NetConnectionProps(@as(*const INetSharingManager, @ptrCast(self)), pNetConnection, ppProps);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const CLSID_NetFwRule_Value = Guid.initString("2c5bc43e-3369-4c33-ab0c-be9469677af4");
pub const CLSID_NetFwRule = &CLSID_NetFwRule_Value;

const CLSID_NetFwOpenPort_Value = Guid.initString("0ca545c6-37ad-4a6c-bf92-9f7610067ef5");
pub const CLSID_NetFwOpenPort = &CLSID_NetFwOpenPort_Value;

const CLSID_NetFwAuthorizedApplication_Value = Guid.initString("ec9846b3-2762-4a6b-a214-6acb603462d2");
pub const CLSID_NetFwAuthorizedApplication = &CLSID_NetFwAuthorizedApplication_Value;

const CLSID_NetFwPolicy2_Value = Guid.initString("e2b3c97f-6ae1-41ac-817a-f6f92166d7dd");
pub const CLSID_NetFwPolicy2 = &CLSID_NetFwPolicy2_Value;

const CLSID_NetFwProduct_Value = Guid.initString("9d745ed8-c514-4d1d-bf42-751fed2d5ac7");
pub const CLSID_NetFwProduct = &CLSID_NetFwProduct_Value;

const CLSID_NetFwProducts_Value = Guid.initString("cc19079b-8272-4d73-bb70-cdb533527b61");
pub const CLSID_NetFwProducts = &CLSID_NetFwProducts_Value;

const CLSID_NetFwMgr_Value = Guid.initString("304ce942-6e39-40d8-943a-b913c40c9cd4");
pub const CLSID_NetFwMgr = &CLSID_NetFwMgr_Value;

pub const NET_FW_POLICY_TYPE = enum(i32) {
    GROUP = 0,
    LOCAL = 1,
    EFFECTIVE = 2,
    TYPE_MAX = 3,
};
pub const NET_FW_POLICY_GROUP = NET_FW_POLICY_TYPE.GROUP;
pub const NET_FW_POLICY_LOCAL = NET_FW_POLICY_TYPE.LOCAL;
pub const NET_FW_POLICY_EFFECTIVE = NET_FW_POLICY_TYPE.EFFECTIVE;
pub const NET_FW_POLICY_TYPE_MAX = NET_FW_POLICY_TYPE.TYPE_MAX;

pub const NET_FW_PROFILE_TYPE = enum(i32) {
    DOMAIN = 0,
    STANDARD = 1,
    CURRENT = 2,
    TYPE_MAX = 3,
};
pub const NET_FW_PROFILE_DOMAIN = NET_FW_PROFILE_TYPE.DOMAIN;
pub const NET_FW_PROFILE_STANDARD = NET_FW_PROFILE_TYPE.STANDARD;
pub const NET_FW_PROFILE_CURRENT = NET_FW_PROFILE_TYPE.CURRENT;
pub const NET_FW_PROFILE_TYPE_MAX = NET_FW_PROFILE_TYPE.TYPE_MAX;

pub const NET_FW_PROFILE_TYPE2 = enum(i32) {
    DOMAIN = 1,
    PRIVATE = 2,
    PUBLIC = 4,
    ALL = 2147483647,
};
pub const NET_FW_PROFILE2_DOMAIN = NET_FW_PROFILE_TYPE2.DOMAIN;
pub const NET_FW_PROFILE2_PRIVATE = NET_FW_PROFILE_TYPE2.PRIVATE;
pub const NET_FW_PROFILE2_PUBLIC = NET_FW_PROFILE_TYPE2.PUBLIC;
pub const NET_FW_PROFILE2_ALL = NET_FW_PROFILE_TYPE2.ALL;

pub const NET_FW_IP_VERSION = enum(i32) {
    V4 = 0,
    V6 = 1,
    ANY = 2,
    MAX = 3,
};
pub const NET_FW_IP_VERSION_V4 = NET_FW_IP_VERSION.V4;
pub const NET_FW_IP_VERSION_V6 = NET_FW_IP_VERSION.V6;
pub const NET_FW_IP_VERSION_ANY = NET_FW_IP_VERSION.ANY;
pub const NET_FW_IP_VERSION_MAX = NET_FW_IP_VERSION.MAX;

pub const NET_FW_SCOPE = enum(i32) {
    ALL = 0,
    LOCAL_SUBNET = 1,
    CUSTOM = 2,
    MAX = 3,
};
pub const NET_FW_SCOPE_ALL = NET_FW_SCOPE.ALL;
pub const NET_FW_SCOPE_LOCAL_SUBNET = NET_FW_SCOPE.LOCAL_SUBNET;
pub const NET_FW_SCOPE_CUSTOM = NET_FW_SCOPE.CUSTOM;
pub const NET_FW_SCOPE_MAX = NET_FW_SCOPE.MAX;

pub const NET_FW_IP_PROTOCOL = enum(i32) {
    TCP = 6,
    UDP = 17,
    ANY = 256,
};
pub const NET_FW_IP_PROTOCOL_TCP = NET_FW_IP_PROTOCOL.TCP;
pub const NET_FW_IP_PROTOCOL_UDP = NET_FW_IP_PROTOCOL.UDP;
pub const NET_FW_IP_PROTOCOL_ANY = NET_FW_IP_PROTOCOL.ANY;

pub const NET_FW_SERVICE_TYPE = enum(i32) {
    FILE_AND_PRINT = 0,
    UPNP = 1,
    REMOTE_DESKTOP = 2,
    NONE = 3,
    TYPE_MAX = 4,
};
pub const NET_FW_SERVICE_FILE_AND_PRINT = NET_FW_SERVICE_TYPE.FILE_AND_PRINT;
pub const NET_FW_SERVICE_UPNP = NET_FW_SERVICE_TYPE.UPNP;
pub const NET_FW_SERVICE_REMOTE_DESKTOP = NET_FW_SERVICE_TYPE.REMOTE_DESKTOP;
pub const NET_FW_SERVICE_NONE = NET_FW_SERVICE_TYPE.NONE;
pub const NET_FW_SERVICE_TYPE_MAX = NET_FW_SERVICE_TYPE.TYPE_MAX;

pub const NET_FW_RULE_DIRECTION = enum(i32) {
    IN = 1,
    OUT = 2,
    MAX = 3,
};
pub const NET_FW_RULE_DIR_IN = NET_FW_RULE_DIRECTION.IN;
pub const NET_FW_RULE_DIR_OUT = NET_FW_RULE_DIRECTION.OUT;
pub const NET_FW_RULE_DIR_MAX = NET_FW_RULE_DIRECTION.MAX;

pub const NET_FW_ACTION = enum(i32) {
    BLOCK = 0,
    ALLOW = 1,
    MAX = 2,
};
pub const NET_FW_ACTION_BLOCK = NET_FW_ACTION.BLOCK;
pub const NET_FW_ACTION_ALLOW = NET_FW_ACTION.ALLOW;
pub const NET_FW_ACTION_MAX = NET_FW_ACTION.MAX;

pub const NET_FW_MODIFY_STATE = enum(i32) {
    OK = 0,
    GP_OVERRIDE = 1,
    INBOUND_BLOCKED = 2,
};
pub const NET_FW_MODIFY_STATE_OK = NET_FW_MODIFY_STATE.OK;
pub const NET_FW_MODIFY_STATE_GP_OVERRIDE = NET_FW_MODIFY_STATE.GP_OVERRIDE;
pub const NET_FW_MODIFY_STATE_INBOUND_BLOCKED = NET_FW_MODIFY_STATE.INBOUND_BLOCKED;

pub const NET_FW_RULE_CATEGORY = enum(i32) {
    BOOT = 0,
    STEALTH = 1,
    FIREWALL = 2,
    CONSEC = 3,
    MAX = 4,
};
pub const NET_FW_RULE_CATEGORY_BOOT = NET_FW_RULE_CATEGORY.BOOT;
pub const NET_FW_RULE_CATEGORY_STEALTH = NET_FW_RULE_CATEGORY.STEALTH;
pub const NET_FW_RULE_CATEGORY_FIREWALL = NET_FW_RULE_CATEGORY.FIREWALL;
pub const NET_FW_RULE_CATEGORY_CONSEC = NET_FW_RULE_CATEGORY.CONSEC;
pub const NET_FW_RULE_CATEGORY_MAX = NET_FW_RULE_CATEGORY.MAX;

pub const NET_FW_EDGE_TRAVERSAL_TYPE = enum(i32) {
    DENY = 0,
    ALLOW = 1,
    DEFER_TO_APP = 2,
    DEFER_TO_USER = 3,
};
pub const NET_FW_EDGE_TRAVERSAL_TYPE_DENY = NET_FW_EDGE_TRAVERSAL_TYPE.DENY;
pub const NET_FW_EDGE_TRAVERSAL_TYPE_ALLOW = NET_FW_EDGE_TRAVERSAL_TYPE.ALLOW;
pub const NET_FW_EDGE_TRAVERSAL_TYPE_DEFER_TO_APP = NET_FW_EDGE_TRAVERSAL_TYPE.DEFER_TO_APP;
pub const NET_FW_EDGE_TRAVERSAL_TYPE_DEFER_TO_USER = NET_FW_EDGE_TRAVERSAL_TYPE.DEFER_TO_USER;

pub const NET_FW_AUTHENTICATE_TYPE = enum(i32) {
    NONE = 0,
    NO_ENCAPSULATION = 1,
    WITH_INTEGRITY = 2,
    AND_NEGOTIATE_ENCRYPTION = 3,
    AND_ENCRYPT = 4,
};
pub const NET_FW_AUTHENTICATE_NONE = NET_FW_AUTHENTICATE_TYPE.NONE;
pub const NET_FW_AUTHENTICATE_NO_ENCAPSULATION = NET_FW_AUTHENTICATE_TYPE.NO_ENCAPSULATION;
pub const NET_FW_AUTHENTICATE_WITH_INTEGRITY = NET_FW_AUTHENTICATE_TYPE.WITH_INTEGRITY;
pub const NET_FW_AUTHENTICATE_AND_NEGOTIATE_ENCRYPTION = NET_FW_AUTHENTICATE_TYPE.AND_NEGOTIATE_ENCRYPTION;
pub const NET_FW_AUTHENTICATE_AND_ENCRYPT = NET_FW_AUTHENTICATE_TYPE.AND_ENCRYPT;

pub const NETISO_FLAG = enum(i32) {
    FORCE_COMPUTE_BINARIES = 1,
    MAX = 2,
};
pub const NETISO_FLAG_FORCE_COMPUTE_BINARIES = NETISO_FLAG.FORCE_COMPUTE_BINARIES;
pub const NETISO_FLAG_MAX = NETISO_FLAG.MAX;

pub const INET_FIREWALL_AC_CREATION_TYPE = enum(i32) {
    NONE = 0,
    PACKAGE_ID_ONLY = 1,
    BINARY = 2,
    MAX = 4,
};
pub const INET_FIREWALL_AC_NONE = INET_FIREWALL_AC_CREATION_TYPE.NONE;
pub const INET_FIREWALL_AC_PACKAGE_ID_ONLY = INET_FIREWALL_AC_CREATION_TYPE.PACKAGE_ID_ONLY;
pub const INET_FIREWALL_AC_BINARY = INET_FIREWALL_AC_CREATION_TYPE.BINARY;
pub const INET_FIREWALL_AC_MAX = INET_FIREWALL_AC_CREATION_TYPE.MAX;

pub const INET_FIREWALL_AC_CHANGE_TYPE = enum(i32) {
    INVALID = 0,
    CREATE = 1,
    DELETE = 2,
    MAX = 3,
};
pub const INET_FIREWALL_AC_CHANGE_INVALID = INET_FIREWALL_AC_CHANGE_TYPE.INVALID;
pub const INET_FIREWALL_AC_CHANGE_CREATE = INET_FIREWALL_AC_CHANGE_TYPE.CREATE;
pub const INET_FIREWALL_AC_CHANGE_DELETE = INET_FIREWALL_AC_CHANGE_TYPE.DELETE;
pub const INET_FIREWALL_AC_CHANGE_MAX = INET_FIREWALL_AC_CHANGE_TYPE.MAX;

pub const INET_FIREWALL_AC_CAPABILITIES = extern struct {
    count: u32,
    capabilities: ?*SID_AND_ATTRIBUTES,
};

pub const INET_FIREWALL_AC_BINARIES = extern struct {
    count: u32,
    binaries: ?*?PWSTR,
};

pub const INET_FIREWALL_AC_CHANGE = extern struct {
    changeType: INET_FIREWALL_AC_CHANGE_TYPE,
    createType: INET_FIREWALL_AC_CREATION_TYPE,
    appContainerSid: ?*SID,
    userSid: ?*SID,
    displayName: ?PWSTR,
    Anonymous: extern union {
        capabilities: INET_FIREWALL_AC_CAPABILITIES,
        binaries: INET_FIREWALL_AC_BINARIES,
    },
};

pub const INET_FIREWALL_APP_CONTAINER = extern struct {
    appContainerSid: ?*SID,
    userSid: ?*SID,
    appContainerName: ?PWSTR,
    displayName: ?PWSTR,
    description: ?PWSTR,
    capabilities: INET_FIREWALL_AC_CAPABILITIES,
    binaries: INET_FIREWALL_AC_BINARIES,
    workingDirectory: ?PWSTR,
    packageFullName: ?PWSTR,
};

pub const PAC_CHANGES_CALLBACK_FN = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        context: ?*anyopaque,
        pChange: ?*const INET_FIREWALL_AC_CHANGE,
    ) callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn (
        context: ?*anyopaque,
        pChange: ?*const INET_FIREWALL_AC_CHANGE,
    ) callconv(@import("std").os.windows.WINAPI) void,
};

pub const NETISO_ERROR_TYPE = enum(i32) {
    NONE = 0,
    PRIVATE_NETWORK = 1,
    INTERNET_CLIENT = 2,
    INTERNET_CLIENT_SERVER = 3,
    MAX = 4,
};
pub const NETISO_ERROR_TYPE_NONE = NETISO_ERROR_TYPE.NONE;
pub const NETISO_ERROR_TYPE_PRIVATE_NETWORK = NETISO_ERROR_TYPE.PRIVATE_NETWORK;
pub const NETISO_ERROR_TYPE_INTERNET_CLIENT = NETISO_ERROR_TYPE.INTERNET_CLIENT;
pub const NETISO_ERROR_TYPE_INTERNET_CLIENT_SERVER = NETISO_ERROR_TYPE.INTERNET_CLIENT_SERVER;
pub const NETISO_ERROR_TYPE_MAX = NETISO_ERROR_TYPE.MAX;

pub const PNETISO_EDP_ID_CALLBACK_FN = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        context: ?*anyopaque,
        wszEnterpriseId: ?[*:0]const u16,
        dwErr: u32,
    ) callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn (
        context: ?*anyopaque,
        wszEnterpriseId: ?[*:0]const u16,
        dwErr: u32,
    ) callconv(@import("std").os.windows.WINAPI) void,
};

pub const _tag_FW_DYNAMIC_KEYWORD_ORIGIN_TYPE = enum(i32) {
    INVALID = 0,
    LOCAL = 1,
    MDM = 2,
};
pub const FW_DYNAMIC_KEYWORD_ORIGIN_INVALID = _tag_FW_DYNAMIC_KEYWORD_ORIGIN_TYPE.INVALID;
pub const FW_DYNAMIC_KEYWORD_ORIGIN_LOCAL = _tag_FW_DYNAMIC_KEYWORD_ORIGIN_TYPE.LOCAL;
pub const FW_DYNAMIC_KEYWORD_ORIGIN_MDM = _tag_FW_DYNAMIC_KEYWORD_ORIGIN_TYPE.MDM;

pub const _tag_FW_DYNAMIC_KEYWORD_ADDRESS0 = extern struct {
    id: Guid,
    keyword: ?[*:0]const u16,
    flags: u32,
    addresses: ?[*:0]const u16,
};

pub const _tag_FW_DYNAMIC_KEYWORD_ADDRESS_DATA0 = extern struct {
    dynamicKeywordAddress: _tag_FW_DYNAMIC_KEYWORD_ADDRESS0,
    next: ?*_tag_FW_DYNAMIC_KEYWORD_ADDRESS_DATA0,
    schemaVersion: u16,
    originType: _tag_FW_DYNAMIC_KEYWORD_ORIGIN_TYPE,
};

pub const _tag_FW_DYNAMIC_KEYWORD_ADDRESS_FLAGS = enum(i32) {
    E = 1,
};
pub const FW_DYNAMIC_KEYWORD_ADDRESS_FLAGS_AUTO_RESOLVE = _tag_FW_DYNAMIC_KEYWORD_ADDRESS_FLAGS.E;

pub const _tag_FW_DYNAMIC_KEYWORD_ADDRESS_ENUM_FLAGS = enum(i32) {
    AUTO_RESOLVE = 1,
    NON_AUTO_RESOLVE = 2,
    ALL = 3,
};
pub const FW_DYNAMIC_KEYWORD_ADDRESS_ENUM_FLAGS_AUTO_RESOLVE = _tag_FW_DYNAMIC_KEYWORD_ADDRESS_ENUM_FLAGS.AUTO_RESOLVE;
pub const FW_DYNAMIC_KEYWORD_ADDRESS_ENUM_FLAGS_NON_AUTO_RESOLVE = _tag_FW_DYNAMIC_KEYWORD_ADDRESS_ENUM_FLAGS.NON_AUTO_RESOLVE;
pub const FW_DYNAMIC_KEYWORD_ADDRESS_ENUM_FLAGS_ALL = _tag_FW_DYNAMIC_KEYWORD_ADDRESS_ENUM_FLAGS.ALL;

pub const PFN_FWADDDYNAMICKEYWORDADDRESS0 = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        dynamicKeywordAddress: ?*const _tag_FW_DYNAMIC_KEYWORD_ADDRESS0,
    ) callconv(@import("std").os.windows.WINAPI) u32,
    else => *const fn (
        dynamicKeywordAddress: ?*const _tag_FW_DYNAMIC_KEYWORD_ADDRESS0,
    ) callconv(@import("std").os.windows.WINAPI) u32,
};

pub const PFN_FWDELETEDYNAMICKEYWORDADDRESS0 = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        dynamicKeywordAddressId: Guid,
    ) callconv(@import("std").os.windows.WINAPI) u32,
    else => *const fn (
        dynamicKeywordAddressId: Guid,
    ) callconv(@import("std").os.windows.WINAPI) u32,
};

pub const PFN_FWENUMDYNAMICKEYWORDADDRESSESBYTYPE0 = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        flags: u32,
        dynamicKeywordAddressData: ?*?*_tag_FW_DYNAMIC_KEYWORD_ADDRESS_DATA0,
    ) callconv(@import("std").os.windows.WINAPI) u32,
    else => *const fn (
        flags: u32,
        dynamicKeywordAddressData: ?*?*_tag_FW_DYNAMIC_KEYWORD_ADDRESS_DATA0,
    ) callconv(@import("std").os.windows.WINAPI) u32,
};

pub const PFN_FWENUMDYNAMICKEYWORDADDRESSBYID0 = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        dynamicKeywordAddressId: Guid,
        dynamicKeywordAddressData: ?*?*_tag_FW_DYNAMIC_KEYWORD_ADDRESS_DATA0,
    ) callconv(@import("std").os.windows.WINAPI) u32,
    else => *const fn (
        dynamicKeywordAddressId: Guid,
        dynamicKeywordAddressData: ?*?*_tag_FW_DYNAMIC_KEYWORD_ADDRESS_DATA0,
    ) callconv(@import("std").os.windows.WINAPI) u32,
};

pub const PFN_FWFREEDYNAMICKEYWORDADDRESSDATA0 = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        dynamicKeywordAddressData: ?*_tag_FW_DYNAMIC_KEYWORD_ADDRESS_DATA0,
    ) callconv(@import("std").os.windows.WINAPI) u32,
    else => *const fn (
        dynamicKeywordAddressData: ?*_tag_FW_DYNAMIC_KEYWORD_ADDRESS_DATA0,
    ) callconv(@import("std").os.windows.WINAPI) u32,
};

pub const PFN_FWUPDATEDYNAMICKEYWORDADDRESS0 = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        dynamicKeywordAddressId: Guid,
        updatedAddresses: ?[*:0]const u16,
        append: BOOL,
    ) callconv(@import("std").os.windows.WINAPI) u32,
    else => *const fn (
        dynamicKeywordAddressId: Guid,
        updatedAddresses: ?[*:0]const u16,
        append: BOOL,
    ) callconv(@import("std").os.windows.WINAPI) u32,
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_INetFwRemoteAdminSettings_Value = Guid.initString("d4becddf-6f73-4a83-b832-9c66874cd20e");
pub const IID_INetFwRemoteAdminSettings = &IID_INetFwRemoteAdminSettings_Value;
pub const INetFwRemoteAdminSettings = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IpVersion: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwRemoteAdminSettings,
                ipVersion: ?*NET_FW_IP_VERSION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwRemoteAdminSettings,
                ipVersion: ?*NET_FW_IP_VERSION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_IpVersion: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwRemoteAdminSettings,
                ipVersion: NET_FW_IP_VERSION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwRemoteAdminSettings,
                ipVersion: NET_FW_IP_VERSION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Scope: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwRemoteAdminSettings,
                scope: ?*NET_FW_SCOPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwRemoteAdminSettings,
                scope: ?*NET_FW_SCOPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Scope: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwRemoteAdminSettings,
                scope: NET_FW_SCOPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwRemoteAdminSettings,
                scope: NET_FW_SCOPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RemoteAddresses: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwRemoteAdminSettings,
                remoteAddrs: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwRemoteAdminSettings,
                remoteAddrs: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_RemoteAddresses: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwRemoteAdminSettings,
                remoteAddrs: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwRemoteAdminSettings,
                remoteAddrs: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Enabled: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwRemoteAdminSettings,
                enabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwRemoteAdminSettings,
                enabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Enabled: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwRemoteAdminSettings,
                enabled: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwRemoteAdminSettings,
                enabled: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwRemoteAdminSettings_get_IpVersion(self: *const T, ipVersion: ?*NET_FW_IP_VERSION) HRESULT {
                return @as(*const INetFwRemoteAdminSettings.VTable, @ptrCast(self.vtable)).get_IpVersion(@as(*const INetFwRemoteAdminSettings, @ptrCast(self)), ipVersion);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwRemoteAdminSettings_put_IpVersion(self: *const T, ipVersion: NET_FW_IP_VERSION) HRESULT {
                return @as(*const INetFwRemoteAdminSettings.VTable, @ptrCast(self.vtable)).put_IpVersion(@as(*const INetFwRemoteAdminSettings, @ptrCast(self)), ipVersion);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwRemoteAdminSettings_get_Scope(self: *const T, scope: ?*NET_FW_SCOPE) HRESULT {
                return @as(*const INetFwRemoteAdminSettings.VTable, @ptrCast(self.vtable)).get_Scope(@as(*const INetFwRemoteAdminSettings, @ptrCast(self)), scope);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwRemoteAdminSettings_put_Scope(self: *const T, scope: NET_FW_SCOPE) HRESULT {
                return @as(*const INetFwRemoteAdminSettings.VTable, @ptrCast(self.vtable)).put_Scope(@as(*const INetFwRemoteAdminSettings, @ptrCast(self)), scope);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwRemoteAdminSettings_get_RemoteAddresses(self: *const T, remoteAddrs: ?*?BSTR) HRESULT {
                return @as(*const INetFwRemoteAdminSettings.VTable, @ptrCast(self.vtable)).get_RemoteAddresses(@as(*const INetFwRemoteAdminSettings, @ptrCast(self)), remoteAddrs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwRemoteAdminSettings_put_RemoteAddresses(self: *const T, remoteAddrs: ?BSTR) HRESULT {
                return @as(*const INetFwRemoteAdminSettings.VTable, @ptrCast(self.vtable)).put_RemoteAddresses(@as(*const INetFwRemoteAdminSettings, @ptrCast(self)), remoteAddrs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwRemoteAdminSettings_get_Enabled(self: *const T, enabled: ?*i16) HRESULT {
                return @as(*const INetFwRemoteAdminSettings.VTable, @ptrCast(self.vtable)).get_Enabled(@as(*const INetFwRemoteAdminSettings, @ptrCast(self)), enabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwRemoteAdminSettings_put_Enabled(self: *const T, enabled: i16) HRESULT {
                return @as(*const INetFwRemoteAdminSettings.VTable, @ptrCast(self.vtable)).put_Enabled(@as(*const INetFwRemoteAdminSettings, @ptrCast(self)), enabled);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_INetFwIcmpSettings_Value = Guid.initString("a6207b2e-7cdd-426a-951e-5e1cbc5afead");
pub const IID_INetFwIcmpSettings = &IID_INetFwIcmpSettings_Value;
pub const INetFwIcmpSettings = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AllowOutboundDestinationUnreachable: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwIcmpSettings,
                allow: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwIcmpSettings,
                allow: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AllowOutboundDestinationUnreachable: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwIcmpSettings,
                allow: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwIcmpSettings,
                allow: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AllowRedirect: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwIcmpSettings,
                allow: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwIcmpSettings,
                allow: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AllowRedirect: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwIcmpSettings,
                allow: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwIcmpSettings,
                allow: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AllowInboundEchoRequest: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwIcmpSettings,
                allow: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwIcmpSettings,
                allow: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AllowInboundEchoRequest: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwIcmpSettings,
                allow: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwIcmpSettings,
                allow: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AllowOutboundTimeExceeded: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwIcmpSettings,
                allow: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwIcmpSettings,
                allow: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AllowOutboundTimeExceeded: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwIcmpSettings,
                allow: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwIcmpSettings,
                allow: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AllowOutboundParameterProblem: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwIcmpSettings,
                allow: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwIcmpSettings,
                allow: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AllowOutboundParameterProblem: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwIcmpSettings,
                allow: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwIcmpSettings,
                allow: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AllowOutboundSourceQuench: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwIcmpSettings,
                allow: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwIcmpSettings,
                allow: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AllowOutboundSourceQuench: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwIcmpSettings,
                allow: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwIcmpSettings,
                allow: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AllowInboundRouterRequest: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwIcmpSettings,
                allow: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwIcmpSettings,
                allow: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AllowInboundRouterRequest: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwIcmpSettings,
                allow: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwIcmpSettings,
                allow: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AllowInboundTimestampRequest: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwIcmpSettings,
                allow: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwIcmpSettings,
                allow: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AllowInboundTimestampRequest: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwIcmpSettings,
                allow: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwIcmpSettings,
                allow: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AllowInboundMaskRequest: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwIcmpSettings,
                allow: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwIcmpSettings,
                allow: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AllowInboundMaskRequest: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwIcmpSettings,
                allow: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwIcmpSettings,
                allow: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AllowOutboundPacketTooBig: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwIcmpSettings,
                allow: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwIcmpSettings,
                allow: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AllowOutboundPacketTooBig: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwIcmpSettings,
                allow: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwIcmpSettings,
                allow: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwIcmpSettings_get_AllowOutboundDestinationUnreachable(self: *const T, allow: ?*i16) HRESULT {
                return @as(*const INetFwIcmpSettings.VTable, @ptrCast(self.vtable)).get_AllowOutboundDestinationUnreachable(@as(*const INetFwIcmpSettings, @ptrCast(self)), allow);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwIcmpSettings_put_AllowOutboundDestinationUnreachable(self: *const T, allow: i16) HRESULT {
                return @as(*const INetFwIcmpSettings.VTable, @ptrCast(self.vtable)).put_AllowOutboundDestinationUnreachable(@as(*const INetFwIcmpSettings, @ptrCast(self)), allow);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwIcmpSettings_get_AllowRedirect(self: *const T, allow: ?*i16) HRESULT {
                return @as(*const INetFwIcmpSettings.VTable, @ptrCast(self.vtable)).get_AllowRedirect(@as(*const INetFwIcmpSettings, @ptrCast(self)), allow);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwIcmpSettings_put_AllowRedirect(self: *const T, allow: i16) HRESULT {
                return @as(*const INetFwIcmpSettings.VTable, @ptrCast(self.vtable)).put_AllowRedirect(@as(*const INetFwIcmpSettings, @ptrCast(self)), allow);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwIcmpSettings_get_AllowInboundEchoRequest(self: *const T, allow: ?*i16) HRESULT {
                return @as(*const INetFwIcmpSettings.VTable, @ptrCast(self.vtable)).get_AllowInboundEchoRequest(@as(*const INetFwIcmpSettings, @ptrCast(self)), allow);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwIcmpSettings_put_AllowInboundEchoRequest(self: *const T, allow: i16) HRESULT {
                return @as(*const INetFwIcmpSettings.VTable, @ptrCast(self.vtable)).put_AllowInboundEchoRequest(@as(*const INetFwIcmpSettings, @ptrCast(self)), allow);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwIcmpSettings_get_AllowOutboundTimeExceeded(self: *const T, allow: ?*i16) HRESULT {
                return @as(*const INetFwIcmpSettings.VTable, @ptrCast(self.vtable)).get_AllowOutboundTimeExceeded(@as(*const INetFwIcmpSettings, @ptrCast(self)), allow);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwIcmpSettings_put_AllowOutboundTimeExceeded(self: *const T, allow: i16) HRESULT {
                return @as(*const INetFwIcmpSettings.VTable, @ptrCast(self.vtable)).put_AllowOutboundTimeExceeded(@as(*const INetFwIcmpSettings, @ptrCast(self)), allow);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwIcmpSettings_get_AllowOutboundParameterProblem(self: *const T, allow: ?*i16) HRESULT {
                return @as(*const INetFwIcmpSettings.VTable, @ptrCast(self.vtable)).get_AllowOutboundParameterProblem(@as(*const INetFwIcmpSettings, @ptrCast(self)), allow);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwIcmpSettings_put_AllowOutboundParameterProblem(self: *const T, allow: i16) HRESULT {
                return @as(*const INetFwIcmpSettings.VTable, @ptrCast(self.vtable)).put_AllowOutboundParameterProblem(@as(*const INetFwIcmpSettings, @ptrCast(self)), allow);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwIcmpSettings_get_AllowOutboundSourceQuench(self: *const T, allow: ?*i16) HRESULT {
                return @as(*const INetFwIcmpSettings.VTable, @ptrCast(self.vtable)).get_AllowOutboundSourceQuench(@as(*const INetFwIcmpSettings, @ptrCast(self)), allow);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwIcmpSettings_put_AllowOutboundSourceQuench(self: *const T, allow: i16) HRESULT {
                return @as(*const INetFwIcmpSettings.VTable, @ptrCast(self.vtable)).put_AllowOutboundSourceQuench(@as(*const INetFwIcmpSettings, @ptrCast(self)), allow);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwIcmpSettings_get_AllowInboundRouterRequest(self: *const T, allow: ?*i16) HRESULT {
                return @as(*const INetFwIcmpSettings.VTable, @ptrCast(self.vtable)).get_AllowInboundRouterRequest(@as(*const INetFwIcmpSettings, @ptrCast(self)), allow);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwIcmpSettings_put_AllowInboundRouterRequest(self: *const T, allow: i16) HRESULT {
                return @as(*const INetFwIcmpSettings.VTable, @ptrCast(self.vtable)).put_AllowInboundRouterRequest(@as(*const INetFwIcmpSettings, @ptrCast(self)), allow);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwIcmpSettings_get_AllowInboundTimestampRequest(self: *const T, allow: ?*i16) HRESULT {
                return @as(*const INetFwIcmpSettings.VTable, @ptrCast(self.vtable)).get_AllowInboundTimestampRequest(@as(*const INetFwIcmpSettings, @ptrCast(self)), allow);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwIcmpSettings_put_AllowInboundTimestampRequest(self: *const T, allow: i16) HRESULT {
                return @as(*const INetFwIcmpSettings.VTable, @ptrCast(self.vtable)).put_AllowInboundTimestampRequest(@as(*const INetFwIcmpSettings, @ptrCast(self)), allow);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwIcmpSettings_get_AllowInboundMaskRequest(self: *const T, allow: ?*i16) HRESULT {
                return @as(*const INetFwIcmpSettings.VTable, @ptrCast(self.vtable)).get_AllowInboundMaskRequest(@as(*const INetFwIcmpSettings, @ptrCast(self)), allow);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwIcmpSettings_put_AllowInboundMaskRequest(self: *const T, allow: i16) HRESULT {
                return @as(*const INetFwIcmpSettings.VTable, @ptrCast(self.vtable)).put_AllowInboundMaskRequest(@as(*const INetFwIcmpSettings, @ptrCast(self)), allow);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwIcmpSettings_get_AllowOutboundPacketTooBig(self: *const T, allow: ?*i16) HRESULT {
                return @as(*const INetFwIcmpSettings.VTable, @ptrCast(self.vtable)).get_AllowOutboundPacketTooBig(@as(*const INetFwIcmpSettings, @ptrCast(self)), allow);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwIcmpSettings_put_AllowOutboundPacketTooBig(self: *const T, allow: i16) HRESULT {
                return @as(*const INetFwIcmpSettings.VTable, @ptrCast(self.vtable)).put_AllowOutboundPacketTooBig(@as(*const INetFwIcmpSettings, @ptrCast(self)), allow);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_INetFwOpenPort_Value = Guid.initString("e0483ba0-47ff-4d9c-a6d6-7741d0b195f7");
pub const IID_INetFwOpenPort = &IID_INetFwOpenPort_Value;
pub const INetFwOpenPort = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwOpenPort,
                name: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwOpenPort,
                name: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Name: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwOpenPort,
                name: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwOpenPort,
                name: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IpVersion: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwOpenPort,
                ipVersion: ?*NET_FW_IP_VERSION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwOpenPort,
                ipVersion: ?*NET_FW_IP_VERSION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_IpVersion: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwOpenPort,
                ipVersion: NET_FW_IP_VERSION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwOpenPort,
                ipVersion: NET_FW_IP_VERSION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Protocol: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwOpenPort,
                ipProtocol: ?*NET_FW_IP_PROTOCOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwOpenPort,
                ipProtocol: ?*NET_FW_IP_PROTOCOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Protocol: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwOpenPort,
                ipProtocol: NET_FW_IP_PROTOCOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwOpenPort,
                ipProtocol: NET_FW_IP_PROTOCOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Port: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwOpenPort,
                portNumber: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwOpenPort,
                portNumber: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Port: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwOpenPort,
                portNumber: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwOpenPort,
                portNumber: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Scope: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwOpenPort,
                scope: ?*NET_FW_SCOPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwOpenPort,
                scope: ?*NET_FW_SCOPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Scope: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwOpenPort,
                scope: NET_FW_SCOPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwOpenPort,
                scope: NET_FW_SCOPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RemoteAddresses: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwOpenPort,
                remoteAddrs: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwOpenPort,
                remoteAddrs: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_RemoteAddresses: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwOpenPort,
                remoteAddrs: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwOpenPort,
                remoteAddrs: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Enabled: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwOpenPort,
                enabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwOpenPort,
                enabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Enabled: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwOpenPort,
                enabled: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwOpenPort,
                enabled: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BuiltIn: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwOpenPort,
                builtIn: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwOpenPort,
                builtIn: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwOpenPort_get_Name(self: *const T, name: ?*?BSTR) HRESULT {
                return @as(*const INetFwOpenPort.VTable, @ptrCast(self.vtable)).get_Name(@as(*const INetFwOpenPort, @ptrCast(self)), name);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwOpenPort_put_Name(self: *const T, name: ?BSTR) HRESULT {
                return @as(*const INetFwOpenPort.VTable, @ptrCast(self.vtable)).put_Name(@as(*const INetFwOpenPort, @ptrCast(self)), name);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwOpenPort_get_IpVersion(self: *const T, ipVersion: ?*NET_FW_IP_VERSION) HRESULT {
                return @as(*const INetFwOpenPort.VTable, @ptrCast(self.vtable)).get_IpVersion(@as(*const INetFwOpenPort, @ptrCast(self)), ipVersion);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwOpenPort_put_IpVersion(self: *const T, ipVersion: NET_FW_IP_VERSION) HRESULT {
                return @as(*const INetFwOpenPort.VTable, @ptrCast(self.vtable)).put_IpVersion(@as(*const INetFwOpenPort, @ptrCast(self)), ipVersion);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwOpenPort_get_Protocol(self: *const T, ipProtocol: ?*NET_FW_IP_PROTOCOL) HRESULT {
                return @as(*const INetFwOpenPort.VTable, @ptrCast(self.vtable)).get_Protocol(@as(*const INetFwOpenPort, @ptrCast(self)), ipProtocol);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwOpenPort_put_Protocol(self: *const T, ipProtocol: NET_FW_IP_PROTOCOL) HRESULT {
                return @as(*const INetFwOpenPort.VTable, @ptrCast(self.vtable)).put_Protocol(@as(*const INetFwOpenPort, @ptrCast(self)), ipProtocol);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwOpenPort_get_Port(self: *const T, portNumber: ?*i32) HRESULT {
                return @as(*const INetFwOpenPort.VTable, @ptrCast(self.vtable)).get_Port(@as(*const INetFwOpenPort, @ptrCast(self)), portNumber);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwOpenPort_put_Port(self: *const T, portNumber: i32) HRESULT {
                return @as(*const INetFwOpenPort.VTable, @ptrCast(self.vtable)).put_Port(@as(*const INetFwOpenPort, @ptrCast(self)), portNumber);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwOpenPort_get_Scope(self: *const T, scope: ?*NET_FW_SCOPE) HRESULT {
                return @as(*const INetFwOpenPort.VTable, @ptrCast(self.vtable)).get_Scope(@as(*const INetFwOpenPort, @ptrCast(self)), scope);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwOpenPort_put_Scope(self: *const T, scope: NET_FW_SCOPE) HRESULT {
                return @as(*const INetFwOpenPort.VTable, @ptrCast(self.vtable)).put_Scope(@as(*const INetFwOpenPort, @ptrCast(self)), scope);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwOpenPort_get_RemoteAddresses(self: *const T, remoteAddrs: ?*?BSTR) HRESULT {
                return @as(*const INetFwOpenPort.VTable, @ptrCast(self.vtable)).get_RemoteAddresses(@as(*const INetFwOpenPort, @ptrCast(self)), remoteAddrs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwOpenPort_put_RemoteAddresses(self: *const T, remoteAddrs: ?BSTR) HRESULT {
                return @as(*const INetFwOpenPort.VTable, @ptrCast(self.vtable)).put_RemoteAddresses(@as(*const INetFwOpenPort, @ptrCast(self)), remoteAddrs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwOpenPort_get_Enabled(self: *const T, enabled: ?*i16) HRESULT {
                return @as(*const INetFwOpenPort.VTable, @ptrCast(self.vtable)).get_Enabled(@as(*const INetFwOpenPort, @ptrCast(self)), enabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwOpenPort_put_Enabled(self: *const T, enabled: i16) HRESULT {
                return @as(*const INetFwOpenPort.VTable, @ptrCast(self.vtable)).put_Enabled(@as(*const INetFwOpenPort, @ptrCast(self)), enabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwOpenPort_get_BuiltIn(self: *const T, builtIn: ?*i16) HRESULT {
                return @as(*const INetFwOpenPort.VTable, @ptrCast(self.vtable)).get_BuiltIn(@as(*const INetFwOpenPort, @ptrCast(self)), builtIn);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_INetFwOpenPorts_Value = Guid.initString("c0e9d7fa-e07e-430a-b19a-090ce82d92e2");
pub const IID_INetFwOpenPorts = &IID_INetFwOpenPorts_Value;
pub const INetFwOpenPorts = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwOpenPorts,
                count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwOpenPorts,
                count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Add: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INetFwOpenPorts,
                port: ?*INetFwOpenPort,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INetFwOpenPorts,
                port: ?*INetFwOpenPort,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Remove: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INetFwOpenPorts,
                portNumber: i32,
                ipProtocol: NET_FW_IP_PROTOCOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INetFwOpenPorts,
                portNumber: i32,
                ipProtocol: NET_FW_IP_PROTOCOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Item: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INetFwOpenPorts,
                portNumber: i32,
                ipProtocol: NET_FW_IP_PROTOCOL,
                openPort: ?*?*INetFwOpenPort,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INetFwOpenPorts,
                portNumber: i32,
                ipProtocol: NET_FW_IP_PROTOCOL,
                openPort: ?*?*INetFwOpenPort,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwOpenPorts,
                newEnum: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwOpenPorts,
                newEnum: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwOpenPorts_get_Count(self: *const T, count: ?*i32) HRESULT {
                return @as(*const INetFwOpenPorts.VTable, @ptrCast(self.vtable)).get_Count(@as(*const INetFwOpenPorts, @ptrCast(self)), count);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwOpenPorts_Add(self: *const T, port: ?*INetFwOpenPort) HRESULT {
                return @as(*const INetFwOpenPorts.VTable, @ptrCast(self.vtable)).Add(@as(*const INetFwOpenPorts, @ptrCast(self)), port);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwOpenPorts_Remove(self: *const T, portNumber: i32, ipProtocol: NET_FW_IP_PROTOCOL) HRESULT {
                return @as(*const INetFwOpenPorts.VTable, @ptrCast(self.vtable)).Remove(@as(*const INetFwOpenPorts, @ptrCast(self)), portNumber, ipProtocol);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwOpenPorts_Item(self: *const T, portNumber: i32, ipProtocol: NET_FW_IP_PROTOCOL, openPort: ?*?*INetFwOpenPort) HRESULT {
                return @as(*const INetFwOpenPorts.VTable, @ptrCast(self.vtable)).Item(@as(*const INetFwOpenPorts, @ptrCast(self)), portNumber, ipProtocol, openPort);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwOpenPorts_get__NewEnum(self: *const T, newEnum: ?*?*IUnknown) HRESULT {
                return @as(*const INetFwOpenPorts.VTable, @ptrCast(self.vtable)).get__NewEnum(@as(*const INetFwOpenPorts, @ptrCast(self)), newEnum);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_INetFwService_Value = Guid.initString("79fd57c8-908e-4a36-9888-d5b3f0a444cf");
pub const IID_INetFwService = &IID_INetFwService_Value;
pub const INetFwService = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwService,
                name: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwService,
                name: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Type: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwService,
                type: ?*NET_FW_SERVICE_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwService,
                type: ?*NET_FW_SERVICE_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Customized: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwService,
                customized: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwService,
                customized: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IpVersion: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwService,
                ipVersion: ?*NET_FW_IP_VERSION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwService,
                ipVersion: ?*NET_FW_IP_VERSION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_IpVersion: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwService,
                ipVersion: NET_FW_IP_VERSION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwService,
                ipVersion: NET_FW_IP_VERSION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Scope: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwService,
                scope: ?*NET_FW_SCOPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwService,
                scope: ?*NET_FW_SCOPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Scope: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwService,
                scope: NET_FW_SCOPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwService,
                scope: NET_FW_SCOPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RemoteAddresses: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwService,
                remoteAddrs: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwService,
                remoteAddrs: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_RemoteAddresses: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwService,
                remoteAddrs: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwService,
                remoteAddrs: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Enabled: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwService,
                enabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwService,
                enabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Enabled: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwService,
                enabled: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwService,
                enabled: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_GloballyOpenPorts: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwService,
                openPorts: ?*?*INetFwOpenPorts,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwService,
                openPorts: ?*?*INetFwOpenPorts,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwService_get_Name(self: *const T, name: ?*?BSTR) HRESULT {
                return @as(*const INetFwService.VTable, @ptrCast(self.vtable)).get_Name(@as(*const INetFwService, @ptrCast(self)), name);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwService_get_Type(self: *const T, type_: ?*NET_FW_SERVICE_TYPE) HRESULT {
                return @as(*const INetFwService.VTable, @ptrCast(self.vtable)).get_Type(@as(*const INetFwService, @ptrCast(self)), type_);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwService_get_Customized(self: *const T, customized: ?*i16) HRESULT {
                return @as(*const INetFwService.VTable, @ptrCast(self.vtable)).get_Customized(@as(*const INetFwService, @ptrCast(self)), customized);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwService_get_IpVersion(self: *const T, ipVersion: ?*NET_FW_IP_VERSION) HRESULT {
                return @as(*const INetFwService.VTable, @ptrCast(self.vtable)).get_IpVersion(@as(*const INetFwService, @ptrCast(self)), ipVersion);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwService_put_IpVersion(self: *const T, ipVersion: NET_FW_IP_VERSION) HRESULT {
                return @as(*const INetFwService.VTable, @ptrCast(self.vtable)).put_IpVersion(@as(*const INetFwService, @ptrCast(self)), ipVersion);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwService_get_Scope(self: *const T, scope: ?*NET_FW_SCOPE) HRESULT {
                return @as(*const INetFwService.VTable, @ptrCast(self.vtable)).get_Scope(@as(*const INetFwService, @ptrCast(self)), scope);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwService_put_Scope(self: *const T, scope: NET_FW_SCOPE) HRESULT {
                return @as(*const INetFwService.VTable, @ptrCast(self.vtable)).put_Scope(@as(*const INetFwService, @ptrCast(self)), scope);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwService_get_RemoteAddresses(self: *const T, remoteAddrs: ?*?BSTR) HRESULT {
                return @as(*const INetFwService.VTable, @ptrCast(self.vtable)).get_RemoteAddresses(@as(*const INetFwService, @ptrCast(self)), remoteAddrs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwService_put_RemoteAddresses(self: *const T, remoteAddrs: ?BSTR) HRESULT {
                return @as(*const INetFwService.VTable, @ptrCast(self.vtable)).put_RemoteAddresses(@as(*const INetFwService, @ptrCast(self)), remoteAddrs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwService_get_Enabled(self: *const T, enabled: ?*i16) HRESULT {
                return @as(*const INetFwService.VTable, @ptrCast(self.vtable)).get_Enabled(@as(*const INetFwService, @ptrCast(self)), enabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwService_put_Enabled(self: *const T, enabled: i16) HRESULT {
                return @as(*const INetFwService.VTable, @ptrCast(self.vtable)).put_Enabled(@as(*const INetFwService, @ptrCast(self)), enabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwService_get_GloballyOpenPorts(self: *const T, openPorts: ?*?*INetFwOpenPorts) HRESULT {
                return @as(*const INetFwService.VTable, @ptrCast(self.vtable)).get_GloballyOpenPorts(@as(*const INetFwService, @ptrCast(self)), openPorts);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_INetFwServices_Value = Guid.initString("79649bb4-903e-421b-94c9-79848e79f6ee");
pub const IID_INetFwServices = &IID_INetFwServices_Value;
pub const INetFwServices = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwServices,
                count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwServices,
                count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Item: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INetFwServices,
                svcType: NET_FW_SERVICE_TYPE,
                service: ?*?*INetFwService,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INetFwServices,
                svcType: NET_FW_SERVICE_TYPE,
                service: ?*?*INetFwService,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwServices,
                newEnum: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwServices,
                newEnum: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwServices_get_Count(self: *const T, count: ?*i32) HRESULT {
                return @as(*const INetFwServices.VTable, @ptrCast(self.vtable)).get_Count(@as(*const INetFwServices, @ptrCast(self)), count);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwServices_Item(self: *const T, svcType: NET_FW_SERVICE_TYPE, service: ?*?*INetFwService) HRESULT {
                return @as(*const INetFwServices.VTable, @ptrCast(self.vtable)).Item(@as(*const INetFwServices, @ptrCast(self)), svcType, service);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwServices_get__NewEnum(self: *const T, newEnum: ?*?*IUnknown) HRESULT {
                return @as(*const INetFwServices.VTable, @ptrCast(self.vtable)).get__NewEnum(@as(*const INetFwServices, @ptrCast(self)), newEnum);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_INetFwAuthorizedApplication_Value = Guid.initString("b5e64ffa-c2c5-444e-a301-fb5e00018050");
pub const IID_INetFwAuthorizedApplication = &IID_INetFwAuthorizedApplication_Value;
pub const INetFwAuthorizedApplication = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwAuthorizedApplication,
                name: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwAuthorizedApplication,
                name: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Name: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwAuthorizedApplication,
                name: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwAuthorizedApplication,
                name: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ProcessImageFileName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwAuthorizedApplication,
                imageFileName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwAuthorizedApplication,
                imageFileName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ProcessImageFileName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwAuthorizedApplication,
                imageFileName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwAuthorizedApplication,
                imageFileName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IpVersion: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwAuthorizedApplication,
                ipVersion: ?*NET_FW_IP_VERSION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwAuthorizedApplication,
                ipVersion: ?*NET_FW_IP_VERSION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_IpVersion: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwAuthorizedApplication,
                ipVersion: NET_FW_IP_VERSION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwAuthorizedApplication,
                ipVersion: NET_FW_IP_VERSION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Scope: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwAuthorizedApplication,
                scope: ?*NET_FW_SCOPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwAuthorizedApplication,
                scope: ?*NET_FW_SCOPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Scope: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwAuthorizedApplication,
                scope: NET_FW_SCOPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwAuthorizedApplication,
                scope: NET_FW_SCOPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RemoteAddresses: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwAuthorizedApplication,
                remoteAddrs: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwAuthorizedApplication,
                remoteAddrs: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_RemoteAddresses: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwAuthorizedApplication,
                remoteAddrs: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwAuthorizedApplication,
                remoteAddrs: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Enabled: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwAuthorizedApplication,
                enabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwAuthorizedApplication,
                enabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Enabled: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwAuthorizedApplication,
                enabled: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwAuthorizedApplication,
                enabled: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwAuthorizedApplication_get_Name(self: *const T, name: ?*?BSTR) HRESULT {
                return @as(*const INetFwAuthorizedApplication.VTable, @ptrCast(self.vtable)).get_Name(@as(*const INetFwAuthorizedApplication, @ptrCast(self)), name);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwAuthorizedApplication_put_Name(self: *const T, name: ?BSTR) HRESULT {
                return @as(*const INetFwAuthorizedApplication.VTable, @ptrCast(self.vtable)).put_Name(@as(*const INetFwAuthorizedApplication, @ptrCast(self)), name);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwAuthorizedApplication_get_ProcessImageFileName(self: *const T, imageFileName: ?*?BSTR) HRESULT {
                return @as(*const INetFwAuthorizedApplication.VTable, @ptrCast(self.vtable)).get_ProcessImageFileName(@as(*const INetFwAuthorizedApplication, @ptrCast(self)), imageFileName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwAuthorizedApplication_put_ProcessImageFileName(self: *const T, imageFileName: ?BSTR) HRESULT {
                return @as(*const INetFwAuthorizedApplication.VTable, @ptrCast(self.vtable)).put_ProcessImageFileName(@as(*const INetFwAuthorizedApplication, @ptrCast(self)), imageFileName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwAuthorizedApplication_get_IpVersion(self: *const T, ipVersion: ?*NET_FW_IP_VERSION) HRESULT {
                return @as(*const INetFwAuthorizedApplication.VTable, @ptrCast(self.vtable)).get_IpVersion(@as(*const INetFwAuthorizedApplication, @ptrCast(self)), ipVersion);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwAuthorizedApplication_put_IpVersion(self: *const T, ipVersion: NET_FW_IP_VERSION) HRESULT {
                return @as(*const INetFwAuthorizedApplication.VTable, @ptrCast(self.vtable)).put_IpVersion(@as(*const INetFwAuthorizedApplication, @ptrCast(self)), ipVersion);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwAuthorizedApplication_get_Scope(self: *const T, scope: ?*NET_FW_SCOPE) HRESULT {
                return @as(*const INetFwAuthorizedApplication.VTable, @ptrCast(self.vtable)).get_Scope(@as(*const INetFwAuthorizedApplication, @ptrCast(self)), scope);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwAuthorizedApplication_put_Scope(self: *const T, scope: NET_FW_SCOPE) HRESULT {
                return @as(*const INetFwAuthorizedApplication.VTable, @ptrCast(self.vtable)).put_Scope(@as(*const INetFwAuthorizedApplication, @ptrCast(self)), scope);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwAuthorizedApplication_get_RemoteAddresses(self: *const T, remoteAddrs: ?*?BSTR) HRESULT {
                return @as(*const INetFwAuthorizedApplication.VTable, @ptrCast(self.vtable)).get_RemoteAddresses(@as(*const INetFwAuthorizedApplication, @ptrCast(self)), remoteAddrs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwAuthorizedApplication_put_RemoteAddresses(self: *const T, remoteAddrs: ?BSTR) HRESULT {
                return @as(*const INetFwAuthorizedApplication.VTable, @ptrCast(self.vtable)).put_RemoteAddresses(@as(*const INetFwAuthorizedApplication, @ptrCast(self)), remoteAddrs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwAuthorizedApplication_get_Enabled(self: *const T, enabled: ?*i16) HRESULT {
                return @as(*const INetFwAuthorizedApplication.VTable, @ptrCast(self.vtable)).get_Enabled(@as(*const INetFwAuthorizedApplication, @ptrCast(self)), enabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwAuthorizedApplication_put_Enabled(self: *const T, enabled: i16) HRESULT {
                return @as(*const INetFwAuthorizedApplication.VTable, @ptrCast(self.vtable)).put_Enabled(@as(*const INetFwAuthorizedApplication, @ptrCast(self)), enabled);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_INetFwAuthorizedApplications_Value = Guid.initString("644efd52-ccf9-486c-97a2-39f352570b30");
pub const IID_INetFwAuthorizedApplications = &IID_INetFwAuthorizedApplications_Value;
pub const INetFwAuthorizedApplications = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwAuthorizedApplications,
                count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwAuthorizedApplications,
                count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Add: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INetFwAuthorizedApplications,
                app: ?*INetFwAuthorizedApplication,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INetFwAuthorizedApplications,
                app: ?*INetFwAuthorizedApplication,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Remove: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INetFwAuthorizedApplications,
                imageFileName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INetFwAuthorizedApplications,
                imageFileName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Item: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INetFwAuthorizedApplications,
                imageFileName: ?BSTR,
                app: ?*?*INetFwAuthorizedApplication,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INetFwAuthorizedApplications,
                imageFileName: ?BSTR,
                app: ?*?*INetFwAuthorizedApplication,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwAuthorizedApplications,
                newEnum: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwAuthorizedApplications,
                newEnum: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwAuthorizedApplications_get_Count(self: *const T, count: ?*i32) HRESULT {
                return @as(*const INetFwAuthorizedApplications.VTable, @ptrCast(self.vtable)).get_Count(@as(*const INetFwAuthorizedApplications, @ptrCast(self)), count);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwAuthorizedApplications_Add(self: *const T, app: ?*INetFwAuthorizedApplication) HRESULT {
                return @as(*const INetFwAuthorizedApplications.VTable, @ptrCast(self.vtable)).Add(@as(*const INetFwAuthorizedApplications, @ptrCast(self)), app);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwAuthorizedApplications_Remove(self: *const T, imageFileName: ?BSTR) HRESULT {
                return @as(*const INetFwAuthorizedApplications.VTable, @ptrCast(self.vtable)).Remove(@as(*const INetFwAuthorizedApplications, @ptrCast(self)), imageFileName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwAuthorizedApplications_Item(self: *const T, imageFileName: ?BSTR, app: ?*?*INetFwAuthorizedApplication) HRESULT {
                return @as(*const INetFwAuthorizedApplications.VTable, @ptrCast(self.vtable)).Item(@as(*const INetFwAuthorizedApplications, @ptrCast(self)), imageFileName, app);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwAuthorizedApplications_get__NewEnum(self: *const T, newEnum: ?*?*IUnknown) HRESULT {
                return @as(*const INetFwAuthorizedApplications.VTable, @ptrCast(self.vtable)).get__NewEnum(@as(*const INetFwAuthorizedApplications, @ptrCast(self)), newEnum);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_INetFwRule_Value = Guid.initString("af230d27-baba-4e42-aced-f524f22cfce2");
pub const IID_INetFwRule = &IID_INetFwRule_Value;
pub const INetFwRule = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwRule,
                name: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwRule,
                name: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Name: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwRule,
                name: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwRule,
                name: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Description: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwRule,
                desc: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwRule,
                desc: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Description: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwRule,
                desc: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwRule,
                desc: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ApplicationName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwRule,
                imageFileName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwRule,
                imageFileName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ApplicationName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwRule,
                imageFileName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwRule,
                imageFileName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ServiceName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwRule,
                serviceName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwRule,
                serviceName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ServiceName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwRule,
                serviceName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwRule,
                serviceName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Protocol: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwRule,
                protocol: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwRule,
                protocol: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Protocol: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwRule,
                protocol: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwRule,
                protocol: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LocalPorts: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwRule,
                portNumbers: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwRule,
                portNumbers: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_LocalPorts: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwRule,
                portNumbers: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwRule,
                portNumbers: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RemotePorts: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwRule,
                portNumbers: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwRule,
                portNumbers: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_RemotePorts: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwRule,
                portNumbers: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwRule,
                portNumbers: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LocalAddresses: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwRule,
                localAddrs: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwRule,
                localAddrs: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_LocalAddresses: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwRule,
                localAddrs: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwRule,
                localAddrs: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RemoteAddresses: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwRule,
                remoteAddrs: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwRule,
                remoteAddrs: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_RemoteAddresses: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwRule,
                remoteAddrs: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwRule,
                remoteAddrs: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IcmpTypesAndCodes: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwRule,
                icmpTypesAndCodes: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwRule,
                icmpTypesAndCodes: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_IcmpTypesAndCodes: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwRule,
                icmpTypesAndCodes: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwRule,
                icmpTypesAndCodes: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Direction: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwRule,
                dir: ?*NET_FW_RULE_DIRECTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwRule,
                dir: ?*NET_FW_RULE_DIRECTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Direction: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwRule,
                dir: NET_FW_RULE_DIRECTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwRule,
                dir: NET_FW_RULE_DIRECTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Interfaces: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwRule,
                interfaces: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwRule,
                interfaces: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Interfaces: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwRule,
                interfaces: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwRule,
                interfaces: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InterfaceTypes: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwRule,
                interfaceTypes: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwRule,
                interfaceTypes: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_InterfaceTypes: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwRule,
                interfaceTypes: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwRule,
                interfaceTypes: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Enabled: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwRule,
                enabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwRule,
                enabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Enabled: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwRule,
                enabled: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwRule,
                enabled: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Grouping: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwRule,
                context: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwRule,
                context: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Grouping: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwRule,
                context: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwRule,
                context: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Profiles: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwRule,
                profileTypesBitmask: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwRule,
                profileTypesBitmask: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Profiles: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwRule,
                profileTypesBitmask: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwRule,
                profileTypesBitmask: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EdgeTraversal: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwRule,
                enabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwRule,
                enabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_EdgeTraversal: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwRule,
                enabled: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwRule,
                enabled: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Action: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwRule,
                action: ?*NET_FW_ACTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwRule,
                action: ?*NET_FW_ACTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Action: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwRule,
                action: NET_FW_ACTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwRule,
                action: NET_FW_ACTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwRule_get_Name(self: *const T, name: ?*?BSTR) HRESULT {
                return @as(*const INetFwRule.VTable, @ptrCast(self.vtable)).get_Name(@as(*const INetFwRule, @ptrCast(self)), name);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwRule_put_Name(self: *const T, name: ?BSTR) HRESULT {
                return @as(*const INetFwRule.VTable, @ptrCast(self.vtable)).put_Name(@as(*const INetFwRule, @ptrCast(self)), name);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwRule_get_Description(self: *const T, desc: ?*?BSTR) HRESULT {
                return @as(*const INetFwRule.VTable, @ptrCast(self.vtable)).get_Description(@as(*const INetFwRule, @ptrCast(self)), desc);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwRule_put_Description(self: *const T, desc: ?BSTR) HRESULT {
                return @as(*const INetFwRule.VTable, @ptrCast(self.vtable)).put_Description(@as(*const INetFwRule, @ptrCast(self)), desc);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwRule_get_ApplicationName(self: *const T, imageFileName: ?*?BSTR) HRESULT {
                return @as(*const INetFwRule.VTable, @ptrCast(self.vtable)).get_ApplicationName(@as(*const INetFwRule, @ptrCast(self)), imageFileName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwRule_put_ApplicationName(self: *const T, imageFileName: ?BSTR) HRESULT {
                return @as(*const INetFwRule.VTable, @ptrCast(self.vtable)).put_ApplicationName(@as(*const INetFwRule, @ptrCast(self)), imageFileName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwRule_get_ServiceName(self: *const T, serviceName: ?*?BSTR) HRESULT {
                return @as(*const INetFwRule.VTable, @ptrCast(self.vtable)).get_ServiceName(@as(*const INetFwRule, @ptrCast(self)), serviceName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwRule_put_ServiceName(self: *const T, serviceName: ?BSTR) HRESULT {
                return @as(*const INetFwRule.VTable, @ptrCast(self.vtable)).put_ServiceName(@as(*const INetFwRule, @ptrCast(self)), serviceName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwRule_get_Protocol(self: *const T, protocol: ?*i32) HRESULT {
                return @as(*const INetFwRule.VTable, @ptrCast(self.vtable)).get_Protocol(@as(*const INetFwRule, @ptrCast(self)), protocol);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwRule_put_Protocol(self: *const T, protocol: i32) HRESULT {
                return @as(*const INetFwRule.VTable, @ptrCast(self.vtable)).put_Protocol(@as(*const INetFwRule, @ptrCast(self)), protocol);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwRule_get_LocalPorts(self: *const T, portNumbers: ?*?BSTR) HRESULT {
                return @as(*const INetFwRule.VTable, @ptrCast(self.vtable)).get_LocalPorts(@as(*const INetFwRule, @ptrCast(self)), portNumbers);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwRule_put_LocalPorts(self: *const T, portNumbers: ?BSTR) HRESULT {
                return @as(*const INetFwRule.VTable, @ptrCast(self.vtable)).put_LocalPorts(@as(*const INetFwRule, @ptrCast(self)), portNumbers);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwRule_get_RemotePorts(self: *const T, portNumbers: ?*?BSTR) HRESULT {
                return @as(*const INetFwRule.VTable, @ptrCast(self.vtable)).get_RemotePorts(@as(*const INetFwRule, @ptrCast(self)), portNumbers);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwRule_put_RemotePorts(self: *const T, portNumbers: ?BSTR) HRESULT {
                return @as(*const INetFwRule.VTable, @ptrCast(self.vtable)).put_RemotePorts(@as(*const INetFwRule, @ptrCast(self)), portNumbers);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwRule_get_LocalAddresses(self: *const T, localAddrs: ?*?BSTR) HRESULT {
                return @as(*const INetFwRule.VTable, @ptrCast(self.vtable)).get_LocalAddresses(@as(*const INetFwRule, @ptrCast(self)), localAddrs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwRule_put_LocalAddresses(self: *const T, localAddrs: ?BSTR) HRESULT {
                return @as(*const INetFwRule.VTable, @ptrCast(self.vtable)).put_LocalAddresses(@as(*const INetFwRule, @ptrCast(self)), localAddrs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwRule_get_RemoteAddresses(self: *const T, remoteAddrs: ?*?BSTR) HRESULT {
                return @as(*const INetFwRule.VTable, @ptrCast(self.vtable)).get_RemoteAddresses(@as(*const INetFwRule, @ptrCast(self)), remoteAddrs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwRule_put_RemoteAddresses(self: *const T, remoteAddrs: ?BSTR) HRESULT {
                return @as(*const INetFwRule.VTable, @ptrCast(self.vtable)).put_RemoteAddresses(@as(*const INetFwRule, @ptrCast(self)), remoteAddrs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwRule_get_IcmpTypesAndCodes(self: *const T, icmpTypesAndCodes: ?*?BSTR) HRESULT {
                return @as(*const INetFwRule.VTable, @ptrCast(self.vtable)).get_IcmpTypesAndCodes(@as(*const INetFwRule, @ptrCast(self)), icmpTypesAndCodes);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwRule_put_IcmpTypesAndCodes(self: *const T, icmpTypesAndCodes: ?BSTR) HRESULT {
                return @as(*const INetFwRule.VTable, @ptrCast(self.vtable)).put_IcmpTypesAndCodes(@as(*const INetFwRule, @ptrCast(self)), icmpTypesAndCodes);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwRule_get_Direction(self: *const T, dir: ?*NET_FW_RULE_DIRECTION) HRESULT {
                return @as(*const INetFwRule.VTable, @ptrCast(self.vtable)).get_Direction(@as(*const INetFwRule, @ptrCast(self)), dir);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwRule_put_Direction(self: *const T, dir: NET_FW_RULE_DIRECTION) HRESULT {
                return @as(*const INetFwRule.VTable, @ptrCast(self.vtable)).put_Direction(@as(*const INetFwRule, @ptrCast(self)), dir);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwRule_get_Interfaces(self: *const T, interfaces: ?*VARIANT) HRESULT {
                return @as(*const INetFwRule.VTable, @ptrCast(self.vtable)).get_Interfaces(@as(*const INetFwRule, @ptrCast(self)), interfaces);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwRule_put_Interfaces(self: *const T, interfaces: VARIANT) HRESULT {
                return @as(*const INetFwRule.VTable, @ptrCast(self.vtable)).put_Interfaces(@as(*const INetFwRule, @ptrCast(self)), interfaces);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwRule_get_InterfaceTypes(self: *const T, interfaceTypes: ?*?BSTR) HRESULT {
                return @as(*const INetFwRule.VTable, @ptrCast(self.vtable)).get_InterfaceTypes(@as(*const INetFwRule, @ptrCast(self)), interfaceTypes);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwRule_put_InterfaceTypes(self: *const T, interfaceTypes: ?BSTR) HRESULT {
                return @as(*const INetFwRule.VTable, @ptrCast(self.vtable)).put_InterfaceTypes(@as(*const INetFwRule, @ptrCast(self)), interfaceTypes);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwRule_get_Enabled(self: *const T, enabled: ?*i16) HRESULT {
                return @as(*const INetFwRule.VTable, @ptrCast(self.vtable)).get_Enabled(@as(*const INetFwRule, @ptrCast(self)), enabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwRule_put_Enabled(self: *const T, enabled: i16) HRESULT {
                return @as(*const INetFwRule.VTable, @ptrCast(self.vtable)).put_Enabled(@as(*const INetFwRule, @ptrCast(self)), enabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwRule_get_Grouping(self: *const T, context: ?*?BSTR) HRESULT {
                return @as(*const INetFwRule.VTable, @ptrCast(self.vtable)).get_Grouping(@as(*const INetFwRule, @ptrCast(self)), context);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwRule_put_Grouping(self: *const T, context: ?BSTR) HRESULT {
                return @as(*const INetFwRule.VTable, @ptrCast(self.vtable)).put_Grouping(@as(*const INetFwRule, @ptrCast(self)), context);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwRule_get_Profiles(self: *const T, profileTypesBitmask: ?*i32) HRESULT {
                return @as(*const INetFwRule.VTable, @ptrCast(self.vtable)).get_Profiles(@as(*const INetFwRule, @ptrCast(self)), profileTypesBitmask);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwRule_put_Profiles(self: *const T, profileTypesBitmask: i32) HRESULT {
                return @as(*const INetFwRule.VTable, @ptrCast(self.vtable)).put_Profiles(@as(*const INetFwRule, @ptrCast(self)), profileTypesBitmask);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwRule_get_EdgeTraversal(self: *const T, enabled: ?*i16) HRESULT {
                return @as(*const INetFwRule.VTable, @ptrCast(self.vtable)).get_EdgeTraversal(@as(*const INetFwRule, @ptrCast(self)), enabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwRule_put_EdgeTraversal(self: *const T, enabled: i16) HRESULT {
                return @as(*const INetFwRule.VTable, @ptrCast(self.vtable)).put_EdgeTraversal(@as(*const INetFwRule, @ptrCast(self)), enabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwRule_get_Action(self: *const T, action: ?*NET_FW_ACTION) HRESULT {
                return @as(*const INetFwRule.VTable, @ptrCast(self.vtable)).get_Action(@as(*const INetFwRule, @ptrCast(self)), action);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwRule_put_Action(self: *const T, action: NET_FW_ACTION) HRESULT {
                return @as(*const INetFwRule.VTable, @ptrCast(self.vtable)).put_Action(@as(*const INetFwRule, @ptrCast(self)), action);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_INetFwRule2_Value = Guid.initString("9c27c8da-189b-4dde-89f7-8b39a316782c");
pub const IID_INetFwRule2 = &IID_INetFwRule2_Value;
pub const INetFwRule2 = extern struct {
    pub const VTable = extern struct {
        base: INetFwRule.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EdgeTraversalOptions: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwRule2,
                lOptions: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwRule2,
                lOptions: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_EdgeTraversalOptions: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwRule2,
                lOptions: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwRule2,
                lOptions: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace INetFwRule.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwRule2_get_EdgeTraversalOptions(self: *const T, lOptions: ?*i32) HRESULT {
                return @as(*const INetFwRule2.VTable, @ptrCast(self.vtable)).get_EdgeTraversalOptions(@as(*const INetFwRule2, @ptrCast(self)), lOptions);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwRule2_put_EdgeTraversalOptions(self: *const T, lOptions: i32) HRESULT {
                return @as(*const INetFwRule2.VTable, @ptrCast(self.vtable)).put_EdgeTraversalOptions(@as(*const INetFwRule2, @ptrCast(self)), lOptions);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_INetFwRule3_Value = Guid.initString("b21563ff-d696-4222-ab46-4e89b73ab34a");
pub const IID_INetFwRule3 = &IID_INetFwRule3_Value;
pub const INetFwRule3 = extern struct {
    pub const VTable = extern struct {
        base: INetFwRule2.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LocalAppPackageId: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwRule3,
                wszPackageId: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwRule3,
                wszPackageId: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_LocalAppPackageId: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwRule3,
                wszPackageId: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwRule3,
                wszPackageId: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LocalUserOwner: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwRule3,
                wszUserOwner: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwRule3,
                wszUserOwner: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_LocalUserOwner: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwRule3,
                wszUserOwner: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwRule3,
                wszUserOwner: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LocalUserAuthorizedList: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwRule3,
                wszUserAuthList: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwRule3,
                wszUserAuthList: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_LocalUserAuthorizedList: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwRule3,
                wszUserAuthList: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwRule3,
                wszUserAuthList: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RemoteUserAuthorizedList: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwRule3,
                wszUserAuthList: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwRule3,
                wszUserAuthList: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_RemoteUserAuthorizedList: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwRule3,
                wszUserAuthList: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwRule3,
                wszUserAuthList: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RemoteMachineAuthorizedList: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwRule3,
                wszUserAuthList: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwRule3,
                wszUserAuthList: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_RemoteMachineAuthorizedList: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwRule3,
                wszUserAuthList: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwRule3,
                wszUserAuthList: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SecureFlags: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwRule3,
                lOptions: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwRule3,
                lOptions: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SecureFlags: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwRule3,
                lOptions: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwRule3,
                lOptions: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace INetFwRule2.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwRule3_get_LocalAppPackageId(self: *const T, wszPackageId: ?*?BSTR) HRESULT {
                return @as(*const INetFwRule3.VTable, @ptrCast(self.vtable)).get_LocalAppPackageId(@as(*const INetFwRule3, @ptrCast(self)), wszPackageId);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwRule3_put_LocalAppPackageId(self: *const T, wszPackageId: ?BSTR) HRESULT {
                return @as(*const INetFwRule3.VTable, @ptrCast(self.vtable)).put_LocalAppPackageId(@as(*const INetFwRule3, @ptrCast(self)), wszPackageId);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwRule3_get_LocalUserOwner(self: *const T, wszUserOwner: ?*?BSTR) HRESULT {
                return @as(*const INetFwRule3.VTable, @ptrCast(self.vtable)).get_LocalUserOwner(@as(*const INetFwRule3, @ptrCast(self)), wszUserOwner);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwRule3_put_LocalUserOwner(self: *const T, wszUserOwner: ?BSTR) HRESULT {
                return @as(*const INetFwRule3.VTable, @ptrCast(self.vtable)).put_LocalUserOwner(@as(*const INetFwRule3, @ptrCast(self)), wszUserOwner);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwRule3_get_LocalUserAuthorizedList(self: *const T, wszUserAuthList: ?*?BSTR) HRESULT {
                return @as(*const INetFwRule3.VTable, @ptrCast(self.vtable)).get_LocalUserAuthorizedList(@as(*const INetFwRule3, @ptrCast(self)), wszUserAuthList);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwRule3_put_LocalUserAuthorizedList(self: *const T, wszUserAuthList: ?BSTR) HRESULT {
                return @as(*const INetFwRule3.VTable, @ptrCast(self.vtable)).put_LocalUserAuthorizedList(@as(*const INetFwRule3, @ptrCast(self)), wszUserAuthList);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwRule3_get_RemoteUserAuthorizedList(self: *const T, wszUserAuthList: ?*?BSTR) HRESULT {
                return @as(*const INetFwRule3.VTable, @ptrCast(self.vtable)).get_RemoteUserAuthorizedList(@as(*const INetFwRule3, @ptrCast(self)), wszUserAuthList);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwRule3_put_RemoteUserAuthorizedList(self: *const T, wszUserAuthList: ?BSTR) HRESULT {
                return @as(*const INetFwRule3.VTable, @ptrCast(self.vtable)).put_RemoteUserAuthorizedList(@as(*const INetFwRule3, @ptrCast(self)), wszUserAuthList);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwRule3_get_RemoteMachineAuthorizedList(self: *const T, wszUserAuthList: ?*?BSTR) HRESULT {
                return @as(*const INetFwRule3.VTable, @ptrCast(self.vtable)).get_RemoteMachineAuthorizedList(@as(*const INetFwRule3, @ptrCast(self)), wszUserAuthList);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwRule3_put_RemoteMachineAuthorizedList(self: *const T, wszUserAuthList: ?BSTR) HRESULT {
                return @as(*const INetFwRule3.VTable, @ptrCast(self.vtable)).put_RemoteMachineAuthorizedList(@as(*const INetFwRule3, @ptrCast(self)), wszUserAuthList);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwRule3_get_SecureFlags(self: *const T, lOptions: ?*i32) HRESULT {
                return @as(*const INetFwRule3.VTable, @ptrCast(self.vtable)).get_SecureFlags(@as(*const INetFwRule3, @ptrCast(self)), lOptions);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwRule3_put_SecureFlags(self: *const T, lOptions: i32) HRESULT {
                return @as(*const INetFwRule3.VTable, @ptrCast(self.vtable)).put_SecureFlags(@as(*const INetFwRule3, @ptrCast(self)), lOptions);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_INetFwRules_Value = Guid.initString("9c4c6277-5027-441e-afae-ca1f542da009");
pub const IID_INetFwRules = &IID_INetFwRules_Value;
pub const INetFwRules = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwRules,
                count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwRules,
                count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Add: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INetFwRules,
                rule: ?*INetFwRule,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INetFwRules,
                rule: ?*INetFwRule,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Remove: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INetFwRules,
                name: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INetFwRules,
                name: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Item: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INetFwRules,
                name: ?BSTR,
                rule: ?*?*INetFwRule,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INetFwRules,
                name: ?BSTR,
                rule: ?*?*INetFwRule,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwRules,
                newEnum: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwRules,
                newEnum: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwRules_get_Count(self: *const T, count: ?*i32) HRESULT {
                return @as(*const INetFwRules.VTable, @ptrCast(self.vtable)).get_Count(@as(*const INetFwRules, @ptrCast(self)), count);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwRules_Add(self: *const T, rule: ?*INetFwRule) HRESULT {
                return @as(*const INetFwRules.VTable, @ptrCast(self.vtable)).Add(@as(*const INetFwRules, @ptrCast(self)), rule);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwRules_Remove(self: *const T, name: ?BSTR) HRESULT {
                return @as(*const INetFwRules.VTable, @ptrCast(self.vtable)).Remove(@as(*const INetFwRules, @ptrCast(self)), name);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwRules_Item(self: *const T, name: ?BSTR, rule: ?*?*INetFwRule) HRESULT {
                return @as(*const INetFwRules.VTable, @ptrCast(self.vtable)).Item(@as(*const INetFwRules, @ptrCast(self)), name, rule);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwRules_get__NewEnum(self: *const T, newEnum: ?*?*IUnknown) HRESULT {
                return @as(*const INetFwRules.VTable, @ptrCast(self.vtable)).get__NewEnum(@as(*const INetFwRules, @ptrCast(self)), newEnum);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_INetFwServiceRestriction_Value = Guid.initString("8267bbe3-f890-491c-b7b6-2db1ef0e5d2b");
pub const IID_INetFwServiceRestriction = &IID_INetFwServiceRestriction_Value;
pub const INetFwServiceRestriction = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        RestrictService: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INetFwServiceRestriction,
                serviceName: ?BSTR,
                appName: ?BSTR,
                restrictService: i16,
                serviceSidRestricted: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INetFwServiceRestriction,
                serviceName: ?BSTR,
                appName: ?BSTR,
                restrictService: i16,
                serviceSidRestricted: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ServiceRestricted: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INetFwServiceRestriction,
                serviceName: ?BSTR,
                appName: ?BSTR,
                serviceRestricted: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INetFwServiceRestriction,
                serviceName: ?BSTR,
                appName: ?BSTR,
                serviceRestricted: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Rules: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwServiceRestriction,
                rules: ?*?*INetFwRules,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwServiceRestriction,
                rules: ?*?*INetFwRules,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwServiceRestriction_RestrictService(self: *const T, serviceName: ?BSTR, appName: ?BSTR, restrictService: i16, serviceSidRestricted: i16) HRESULT {
                return @as(*const INetFwServiceRestriction.VTable, @ptrCast(self.vtable)).RestrictService(@as(*const INetFwServiceRestriction, @ptrCast(self)), serviceName, appName, restrictService, serviceSidRestricted);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwServiceRestriction_ServiceRestricted(self: *const T, serviceName: ?BSTR, appName: ?BSTR, serviceRestricted: ?*i16) HRESULT {
                return @as(*const INetFwServiceRestriction.VTable, @ptrCast(self.vtable)).ServiceRestricted(@as(*const INetFwServiceRestriction, @ptrCast(self)), serviceName, appName, serviceRestricted);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwServiceRestriction_get_Rules(self: *const T, rules: ?*?*INetFwRules) HRESULT {
                return @as(*const INetFwServiceRestriction.VTable, @ptrCast(self.vtable)).get_Rules(@as(*const INetFwServiceRestriction, @ptrCast(self)), rules);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_INetFwProfile_Value = Guid.initString("174a0dda-e9f9-449d-993b-21ab667ca456");
pub const IID_INetFwProfile = &IID_INetFwProfile_Value;
pub const INetFwProfile = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Type: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwProfile,
                type: ?*NET_FW_PROFILE_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwProfile,
                type: ?*NET_FW_PROFILE_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FirewallEnabled: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwProfile,
                enabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwProfile,
                enabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_FirewallEnabled: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwProfile,
                enabled: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwProfile,
                enabled: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ExceptionsNotAllowed: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwProfile,
                notAllowed: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwProfile,
                notAllowed: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ExceptionsNotAllowed: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwProfile,
                notAllowed: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwProfile,
                notAllowed: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NotificationsDisabled: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwProfile,
                disabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwProfile,
                disabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_NotificationsDisabled: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwProfile,
                disabled: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwProfile,
                disabled: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UnicastResponsesToMulticastBroadcastDisabled: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwProfile,
                disabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwProfile,
                disabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_UnicastResponsesToMulticastBroadcastDisabled: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwProfile,
                disabled: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwProfile,
                disabled: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RemoteAdminSettings: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwProfile,
                remoteAdminSettings: ?*?*INetFwRemoteAdminSettings,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwProfile,
                remoteAdminSettings: ?*?*INetFwRemoteAdminSettings,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IcmpSettings: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwProfile,
                icmpSettings: ?*?*INetFwIcmpSettings,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwProfile,
                icmpSettings: ?*?*INetFwIcmpSettings,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_GloballyOpenPorts: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwProfile,
                openPorts: ?*?*INetFwOpenPorts,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwProfile,
                openPorts: ?*?*INetFwOpenPorts,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Services: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwProfile,
                services: ?*?*INetFwServices,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwProfile,
                services: ?*?*INetFwServices,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AuthorizedApplications: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwProfile,
                apps: ?*?*INetFwAuthorizedApplications,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwProfile,
                apps: ?*?*INetFwAuthorizedApplications,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwProfile_get_Type(self: *const T, type_: ?*NET_FW_PROFILE_TYPE) HRESULT {
                return @as(*const INetFwProfile.VTable, @ptrCast(self.vtable)).get_Type(@as(*const INetFwProfile, @ptrCast(self)), type_);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwProfile_get_FirewallEnabled(self: *const T, enabled: ?*i16) HRESULT {
                return @as(*const INetFwProfile.VTable, @ptrCast(self.vtable)).get_FirewallEnabled(@as(*const INetFwProfile, @ptrCast(self)), enabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwProfile_put_FirewallEnabled(self: *const T, enabled: i16) HRESULT {
                return @as(*const INetFwProfile.VTable, @ptrCast(self.vtable)).put_FirewallEnabled(@as(*const INetFwProfile, @ptrCast(self)), enabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwProfile_get_ExceptionsNotAllowed(self: *const T, notAllowed: ?*i16) HRESULT {
                return @as(*const INetFwProfile.VTable, @ptrCast(self.vtable)).get_ExceptionsNotAllowed(@as(*const INetFwProfile, @ptrCast(self)), notAllowed);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwProfile_put_ExceptionsNotAllowed(self: *const T, notAllowed: i16) HRESULT {
                return @as(*const INetFwProfile.VTable, @ptrCast(self.vtable)).put_ExceptionsNotAllowed(@as(*const INetFwProfile, @ptrCast(self)), notAllowed);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwProfile_get_NotificationsDisabled(self: *const T, disabled: ?*i16) HRESULT {
                return @as(*const INetFwProfile.VTable, @ptrCast(self.vtable)).get_NotificationsDisabled(@as(*const INetFwProfile, @ptrCast(self)), disabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwProfile_put_NotificationsDisabled(self: *const T, disabled: i16) HRESULT {
                return @as(*const INetFwProfile.VTable, @ptrCast(self.vtable)).put_NotificationsDisabled(@as(*const INetFwProfile, @ptrCast(self)), disabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwProfile_get_UnicastResponsesToMulticastBroadcastDisabled(self: *const T, disabled: ?*i16) HRESULT {
                return @as(*const INetFwProfile.VTable, @ptrCast(self.vtable)).get_UnicastResponsesToMulticastBroadcastDisabled(@as(*const INetFwProfile, @ptrCast(self)), disabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwProfile_put_UnicastResponsesToMulticastBroadcastDisabled(self: *const T, disabled: i16) HRESULT {
                return @as(*const INetFwProfile.VTable, @ptrCast(self.vtable)).put_UnicastResponsesToMulticastBroadcastDisabled(@as(*const INetFwProfile, @ptrCast(self)), disabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwProfile_get_RemoteAdminSettings(self: *const T, remoteAdminSettings: ?*?*INetFwRemoteAdminSettings) HRESULT {
                return @as(*const INetFwProfile.VTable, @ptrCast(self.vtable)).get_RemoteAdminSettings(@as(*const INetFwProfile, @ptrCast(self)), remoteAdminSettings);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwProfile_get_IcmpSettings(self: *const T, icmpSettings: ?*?*INetFwIcmpSettings) HRESULT {
                return @as(*const INetFwProfile.VTable, @ptrCast(self.vtable)).get_IcmpSettings(@as(*const INetFwProfile, @ptrCast(self)), icmpSettings);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwProfile_get_GloballyOpenPorts(self: *const T, openPorts: ?*?*INetFwOpenPorts) HRESULT {
                return @as(*const INetFwProfile.VTable, @ptrCast(self.vtable)).get_GloballyOpenPorts(@as(*const INetFwProfile, @ptrCast(self)), openPorts);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwProfile_get_Services(self: *const T, services: ?*?*INetFwServices) HRESULT {
                return @as(*const INetFwProfile.VTable, @ptrCast(self.vtable)).get_Services(@as(*const INetFwProfile, @ptrCast(self)), services);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwProfile_get_AuthorizedApplications(self: *const T, apps: ?*?*INetFwAuthorizedApplications) HRESULT {
                return @as(*const INetFwProfile.VTable, @ptrCast(self.vtable)).get_AuthorizedApplications(@as(*const INetFwProfile, @ptrCast(self)), apps);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_INetFwPolicy_Value = Guid.initString("d46d2478-9ac9-4008-9dc7-5563ce5536cc");
pub const IID_INetFwPolicy = &IID_INetFwPolicy_Value;
pub const INetFwPolicy = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentProfile: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwPolicy,
                profile: ?*?*INetFwProfile,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwPolicy,
                profile: ?*?*INetFwProfile,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProfileByType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INetFwPolicy,
                profileType: NET_FW_PROFILE_TYPE,
                profile: ?*?*INetFwProfile,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INetFwPolicy,
                profileType: NET_FW_PROFILE_TYPE,
                profile: ?*?*INetFwProfile,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwPolicy_get_CurrentProfile(self: *const T, profile: ?*?*INetFwProfile) HRESULT {
                return @as(*const INetFwPolicy.VTable, @ptrCast(self.vtable)).get_CurrentProfile(@as(*const INetFwPolicy, @ptrCast(self)), profile);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwPolicy_GetProfileByType(self: *const T, profileType: NET_FW_PROFILE_TYPE, profile: ?*?*INetFwProfile) HRESULT {
                return @as(*const INetFwPolicy.VTable, @ptrCast(self.vtable)).GetProfileByType(@as(*const INetFwPolicy, @ptrCast(self)), profileType, profile);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_INetFwPolicy2_Value = Guid.initString("98325047-c671-4174-8d81-defcd3f03186");
pub const IID_INetFwPolicy2 = &IID_INetFwPolicy2_Value;
pub const INetFwPolicy2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentProfileTypes: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwPolicy2,
                profileTypesBitmask: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwPolicy2,
                profileTypesBitmask: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FirewallEnabled: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwPolicy2,
                profileType: NET_FW_PROFILE_TYPE2,
                enabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwPolicy2,
                profileType: NET_FW_PROFILE_TYPE2,
                enabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_FirewallEnabled: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwPolicy2,
                profileType: NET_FW_PROFILE_TYPE2,
                enabled: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwPolicy2,
                profileType: NET_FW_PROFILE_TYPE2,
                enabled: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ExcludedInterfaces: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwPolicy2,
                profileType: NET_FW_PROFILE_TYPE2,
                interfaces: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwPolicy2,
                profileType: NET_FW_PROFILE_TYPE2,
                interfaces: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ExcludedInterfaces: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwPolicy2,
                profileType: NET_FW_PROFILE_TYPE2,
                interfaces: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwPolicy2,
                profileType: NET_FW_PROFILE_TYPE2,
                interfaces: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BlockAllInboundTraffic: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwPolicy2,
                profileType: NET_FW_PROFILE_TYPE2,
                Block: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwPolicy2,
                profileType: NET_FW_PROFILE_TYPE2,
                Block: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BlockAllInboundTraffic: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwPolicy2,
                profileType: NET_FW_PROFILE_TYPE2,
                Block: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwPolicy2,
                profileType: NET_FW_PROFILE_TYPE2,
                Block: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NotificationsDisabled: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwPolicy2,
                profileType: NET_FW_PROFILE_TYPE2,
                disabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwPolicy2,
                profileType: NET_FW_PROFILE_TYPE2,
                disabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_NotificationsDisabled: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwPolicy2,
                profileType: NET_FW_PROFILE_TYPE2,
                disabled: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwPolicy2,
                profileType: NET_FW_PROFILE_TYPE2,
                disabled: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UnicastResponsesToMulticastBroadcastDisabled: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwPolicy2,
                profileType: NET_FW_PROFILE_TYPE2,
                disabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwPolicy2,
                profileType: NET_FW_PROFILE_TYPE2,
                disabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_UnicastResponsesToMulticastBroadcastDisabled: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwPolicy2,
                profileType: NET_FW_PROFILE_TYPE2,
                disabled: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwPolicy2,
                profileType: NET_FW_PROFILE_TYPE2,
                disabled: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Rules: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwPolicy2,
                rules: ?*?*INetFwRules,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwPolicy2,
                rules: ?*?*INetFwRules,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ServiceRestriction: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwPolicy2,
                ServiceRestriction: ?*?*INetFwServiceRestriction,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwPolicy2,
                ServiceRestriction: ?*?*INetFwServiceRestriction,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnableRuleGroup: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INetFwPolicy2,
                profileTypesBitmask: i32,
                group: ?BSTR,
                enable: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INetFwPolicy2,
                profileTypesBitmask: i32,
                group: ?BSTR,
                enable: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsRuleGroupEnabled: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INetFwPolicy2,
                profileTypesBitmask: i32,
                group: ?BSTR,
                enabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INetFwPolicy2,
                profileTypesBitmask: i32,
                group: ?BSTR,
                enabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RestoreLocalFirewallDefaults: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INetFwPolicy2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INetFwPolicy2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DefaultInboundAction: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwPolicy2,
                profileType: NET_FW_PROFILE_TYPE2,
                action: ?*NET_FW_ACTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwPolicy2,
                profileType: NET_FW_PROFILE_TYPE2,
                action: ?*NET_FW_ACTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DefaultInboundAction: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwPolicy2,
                profileType: NET_FW_PROFILE_TYPE2,
                action: NET_FW_ACTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwPolicy2,
                profileType: NET_FW_PROFILE_TYPE2,
                action: NET_FW_ACTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DefaultOutboundAction: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwPolicy2,
                profileType: NET_FW_PROFILE_TYPE2,
                action: ?*NET_FW_ACTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwPolicy2,
                profileType: NET_FW_PROFILE_TYPE2,
                action: ?*NET_FW_ACTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DefaultOutboundAction: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwPolicy2,
                profileType: NET_FW_PROFILE_TYPE2,
                action: NET_FW_ACTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwPolicy2,
                profileType: NET_FW_PROFILE_TYPE2,
                action: NET_FW_ACTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsRuleGroupCurrentlyEnabled: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwPolicy2,
                group: ?BSTR,
                enabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwPolicy2,
                group: ?BSTR,
                enabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LocalPolicyModifyState: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwPolicy2,
                modifyState: ?*NET_FW_MODIFY_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwPolicy2,
                modifyState: ?*NET_FW_MODIFY_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwPolicy2_get_CurrentProfileTypes(self: *const T, profileTypesBitmask: ?*i32) HRESULT {
                return @as(*const INetFwPolicy2.VTable, @ptrCast(self.vtable)).get_CurrentProfileTypes(@as(*const INetFwPolicy2, @ptrCast(self)), profileTypesBitmask);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwPolicy2_get_FirewallEnabled(self: *const T, profileType: NET_FW_PROFILE_TYPE2, enabled: ?*i16) HRESULT {
                return @as(*const INetFwPolicy2.VTable, @ptrCast(self.vtable)).get_FirewallEnabled(@as(*const INetFwPolicy2, @ptrCast(self)), profileType, enabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwPolicy2_put_FirewallEnabled(self: *const T, profileType: NET_FW_PROFILE_TYPE2, enabled: i16) HRESULT {
                return @as(*const INetFwPolicy2.VTable, @ptrCast(self.vtable)).put_FirewallEnabled(@as(*const INetFwPolicy2, @ptrCast(self)), profileType, enabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwPolicy2_get_ExcludedInterfaces(self: *const T, profileType: NET_FW_PROFILE_TYPE2, interfaces: ?*VARIANT) HRESULT {
                return @as(*const INetFwPolicy2.VTable, @ptrCast(self.vtable)).get_ExcludedInterfaces(@as(*const INetFwPolicy2, @ptrCast(self)), profileType, interfaces);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwPolicy2_put_ExcludedInterfaces(self: *const T, profileType: NET_FW_PROFILE_TYPE2, interfaces: VARIANT) HRESULT {
                return @as(*const INetFwPolicy2.VTable, @ptrCast(self.vtable)).put_ExcludedInterfaces(@as(*const INetFwPolicy2, @ptrCast(self)), profileType, interfaces);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwPolicy2_get_BlockAllInboundTraffic(self: *const T, profileType: NET_FW_PROFILE_TYPE2, Block: ?*i16) HRESULT {
                return @as(*const INetFwPolicy2.VTable, @ptrCast(self.vtable)).get_BlockAllInboundTraffic(@as(*const INetFwPolicy2, @ptrCast(self)), profileType, Block);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwPolicy2_put_BlockAllInboundTraffic(self: *const T, profileType: NET_FW_PROFILE_TYPE2, Block: i16) HRESULT {
                return @as(*const INetFwPolicy2.VTable, @ptrCast(self.vtable)).put_BlockAllInboundTraffic(@as(*const INetFwPolicy2, @ptrCast(self)), profileType, Block);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwPolicy2_get_NotificationsDisabled(self: *const T, profileType: NET_FW_PROFILE_TYPE2, disabled: ?*i16) HRESULT {
                return @as(*const INetFwPolicy2.VTable, @ptrCast(self.vtable)).get_NotificationsDisabled(@as(*const INetFwPolicy2, @ptrCast(self)), profileType, disabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwPolicy2_put_NotificationsDisabled(self: *const T, profileType: NET_FW_PROFILE_TYPE2, disabled: i16) HRESULT {
                return @as(*const INetFwPolicy2.VTable, @ptrCast(self.vtable)).put_NotificationsDisabled(@as(*const INetFwPolicy2, @ptrCast(self)), profileType, disabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwPolicy2_get_UnicastResponsesToMulticastBroadcastDisabled(self: *const T, profileType: NET_FW_PROFILE_TYPE2, disabled: ?*i16) HRESULT {
                return @as(*const INetFwPolicy2.VTable, @ptrCast(self.vtable)).get_UnicastResponsesToMulticastBroadcastDisabled(@as(*const INetFwPolicy2, @ptrCast(self)), profileType, disabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwPolicy2_put_UnicastResponsesToMulticastBroadcastDisabled(self: *const T, profileType: NET_FW_PROFILE_TYPE2, disabled: i16) HRESULT {
                return @as(*const INetFwPolicy2.VTable, @ptrCast(self.vtable)).put_UnicastResponsesToMulticastBroadcastDisabled(@as(*const INetFwPolicy2, @ptrCast(self)), profileType, disabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwPolicy2_get_Rules(self: *const T, rules: ?*?*INetFwRules) HRESULT {
                return @as(*const INetFwPolicy2.VTable, @ptrCast(self.vtable)).get_Rules(@as(*const INetFwPolicy2, @ptrCast(self)), rules);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwPolicy2_get_ServiceRestriction(self: *const T, ServiceRestriction: ?*?*INetFwServiceRestriction) HRESULT {
                return @as(*const INetFwPolicy2.VTable, @ptrCast(self.vtable)).get_ServiceRestriction(@as(*const INetFwPolicy2, @ptrCast(self)), ServiceRestriction);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwPolicy2_EnableRuleGroup(self: *const T, profileTypesBitmask: i32, group: ?BSTR, enable: i16) HRESULT {
                return @as(*const INetFwPolicy2.VTable, @ptrCast(self.vtable)).EnableRuleGroup(@as(*const INetFwPolicy2, @ptrCast(self)), profileTypesBitmask, group, enable);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwPolicy2_IsRuleGroupEnabled(self: *const T, profileTypesBitmask: i32, group: ?BSTR, enabled: ?*i16) HRESULT {
                return @as(*const INetFwPolicy2.VTable, @ptrCast(self.vtable)).IsRuleGroupEnabled(@as(*const INetFwPolicy2, @ptrCast(self)), profileTypesBitmask, group, enabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwPolicy2_RestoreLocalFirewallDefaults(self: *const T) HRESULT {
                return @as(*const INetFwPolicy2.VTable, @ptrCast(self.vtable)).RestoreLocalFirewallDefaults(@as(*const INetFwPolicy2, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwPolicy2_get_DefaultInboundAction(self: *const T, profileType: NET_FW_PROFILE_TYPE2, action: ?*NET_FW_ACTION) HRESULT {
                return @as(*const INetFwPolicy2.VTable, @ptrCast(self.vtable)).get_DefaultInboundAction(@as(*const INetFwPolicy2, @ptrCast(self)), profileType, action);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwPolicy2_put_DefaultInboundAction(self: *const T, profileType: NET_FW_PROFILE_TYPE2, action: NET_FW_ACTION) HRESULT {
                return @as(*const INetFwPolicy2.VTable, @ptrCast(self.vtable)).put_DefaultInboundAction(@as(*const INetFwPolicy2, @ptrCast(self)), profileType, action);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwPolicy2_get_DefaultOutboundAction(self: *const T, profileType: NET_FW_PROFILE_TYPE2, action: ?*NET_FW_ACTION) HRESULT {
                return @as(*const INetFwPolicy2.VTable, @ptrCast(self.vtable)).get_DefaultOutboundAction(@as(*const INetFwPolicy2, @ptrCast(self)), profileType, action);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwPolicy2_put_DefaultOutboundAction(self: *const T, profileType: NET_FW_PROFILE_TYPE2, action: NET_FW_ACTION) HRESULT {
                return @as(*const INetFwPolicy2.VTable, @ptrCast(self.vtable)).put_DefaultOutboundAction(@as(*const INetFwPolicy2, @ptrCast(self)), profileType, action);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwPolicy2_get_IsRuleGroupCurrentlyEnabled(self: *const T, group: ?BSTR, enabled: ?*i16) HRESULT {
                return @as(*const INetFwPolicy2.VTable, @ptrCast(self.vtable)).get_IsRuleGroupCurrentlyEnabled(@as(*const INetFwPolicy2, @ptrCast(self)), group, enabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwPolicy2_get_LocalPolicyModifyState(self: *const T, modifyState: ?*NET_FW_MODIFY_STATE) HRESULT {
                return @as(*const INetFwPolicy2.VTable, @ptrCast(self.vtable)).get_LocalPolicyModifyState(@as(*const INetFwPolicy2, @ptrCast(self)), modifyState);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_INetFwMgr_Value = Guid.initString("f7898af5-cac4-4632-a2ec-da06e5111af2");
pub const IID_INetFwMgr = &IID_INetFwMgr_Value;
pub const INetFwMgr = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LocalPolicy: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwMgr,
                localPolicy: ?*?*INetFwPolicy,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwMgr,
                localPolicy: ?*?*INetFwPolicy,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentProfileType: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwMgr,
                profileType: ?*NET_FW_PROFILE_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwMgr,
                profileType: ?*NET_FW_PROFILE_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RestoreDefaults: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INetFwMgr,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INetFwMgr,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsPortAllowed: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INetFwMgr,
                imageFileName: ?BSTR,
                ipVersion: NET_FW_IP_VERSION,
                portNumber: i32,
                localAddress: ?BSTR,
                ipProtocol: NET_FW_IP_PROTOCOL,
                allowed: ?*VARIANT,
                restricted: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INetFwMgr,
                imageFileName: ?BSTR,
                ipVersion: NET_FW_IP_VERSION,
                portNumber: i32,
                localAddress: ?BSTR,
                ipProtocol: NET_FW_IP_PROTOCOL,
                allowed: ?*VARIANT,
                restricted: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsIcmpTypeAllowed: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INetFwMgr,
                ipVersion: NET_FW_IP_VERSION,
                localAddress: ?BSTR,
                type: u8,
                allowed: ?*VARIANT,
                restricted: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INetFwMgr,
                ipVersion: NET_FW_IP_VERSION,
                localAddress: ?BSTR,
                type: u8,
                allowed: ?*VARIANT,
                restricted: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwMgr_get_LocalPolicy(self: *const T, localPolicy: ?*?*INetFwPolicy) HRESULT {
                return @as(*const INetFwMgr.VTable, @ptrCast(self.vtable)).get_LocalPolicy(@as(*const INetFwMgr, @ptrCast(self)), localPolicy);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwMgr_get_CurrentProfileType(self: *const T, profileType: ?*NET_FW_PROFILE_TYPE) HRESULT {
                return @as(*const INetFwMgr.VTable, @ptrCast(self.vtable)).get_CurrentProfileType(@as(*const INetFwMgr, @ptrCast(self)), profileType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwMgr_RestoreDefaults(self: *const T) HRESULT {
                return @as(*const INetFwMgr.VTable, @ptrCast(self.vtable)).RestoreDefaults(@as(*const INetFwMgr, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwMgr_IsPortAllowed(self: *const T, imageFileName: ?BSTR, ipVersion: NET_FW_IP_VERSION, portNumber: i32, localAddress: ?BSTR, ipProtocol: NET_FW_IP_PROTOCOL, allowed: ?*VARIANT, restricted: ?*VARIANT) HRESULT {
                return @as(*const INetFwMgr.VTable, @ptrCast(self.vtable)).IsPortAllowed(@as(*const INetFwMgr, @ptrCast(self)), imageFileName, ipVersion, portNumber, localAddress, ipProtocol, allowed, restricted);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwMgr_IsIcmpTypeAllowed(self: *const T, ipVersion: NET_FW_IP_VERSION, localAddress: ?BSTR, type_: u8, allowed: ?*VARIANT, restricted: ?*VARIANT) HRESULT {
                return @as(*const INetFwMgr.VTable, @ptrCast(self.vtable)).IsIcmpTypeAllowed(@as(*const INetFwMgr, @ptrCast(self)), ipVersion, localAddress, type_, allowed, restricted);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_INetFwProduct_Value = Guid.initString("71881699-18f4-458b-b892-3ffce5e07f75");
pub const IID_INetFwProduct = &IID_INetFwProduct_Value;
pub const INetFwProduct = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RuleCategories: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwProduct,
                ruleCategories: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwProduct,
                ruleCategories: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_RuleCategories: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwProduct,
                ruleCategories: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwProduct,
                ruleCategories: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DisplayName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwProduct,
                displayName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwProduct,
                displayName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DisplayName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwProduct,
                displayName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwProduct,
                displayName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PathToSignedProductExe: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwProduct,
                path: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwProduct,
                path: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwProduct_get_RuleCategories(self: *const T, ruleCategories: ?*VARIANT) HRESULT {
                return @as(*const INetFwProduct.VTable, @ptrCast(self.vtable)).get_RuleCategories(@as(*const INetFwProduct, @ptrCast(self)), ruleCategories);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwProduct_put_RuleCategories(self: *const T, ruleCategories: VARIANT) HRESULT {
                return @as(*const INetFwProduct.VTable, @ptrCast(self.vtable)).put_RuleCategories(@as(*const INetFwProduct, @ptrCast(self)), ruleCategories);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwProduct_get_DisplayName(self: *const T, displayName: ?*?BSTR) HRESULT {
                return @as(*const INetFwProduct.VTable, @ptrCast(self.vtable)).get_DisplayName(@as(*const INetFwProduct, @ptrCast(self)), displayName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwProduct_put_DisplayName(self: *const T, displayName: ?BSTR) HRESULT {
                return @as(*const INetFwProduct.VTable, @ptrCast(self.vtable)).put_DisplayName(@as(*const INetFwProduct, @ptrCast(self)), displayName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwProduct_get_PathToSignedProductExe(self: *const T, path: ?*?BSTR) HRESULT {
                return @as(*const INetFwProduct.VTable, @ptrCast(self.vtable)).get_PathToSignedProductExe(@as(*const INetFwProduct, @ptrCast(self)), path);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_INetFwProducts_Value = Guid.initString("39eb36e0-2097-40bd-8af2-63a13b525362");
pub const IID_INetFwProducts = &IID_INetFwProducts_Value;
pub const INetFwProducts = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwProducts,
                count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwProducts,
                count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Register: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INetFwProducts,
                product: ?*INetFwProduct,
                registration: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INetFwProducts,
                product: ?*INetFwProduct,
                registration: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Item: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INetFwProducts,
                index: i32,
                product: ?*?*INetFwProduct,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INetFwProducts,
                index: i32,
                product: ?*?*INetFwProduct,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const INetFwProducts,
                newEnum: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const INetFwProducts,
                newEnum: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwProducts_get_Count(self: *const T, count: ?*i32) HRESULT {
                return @as(*const INetFwProducts.VTable, @ptrCast(self.vtable)).get_Count(@as(*const INetFwProducts, @ptrCast(self)), count);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwProducts_Register(self: *const T, product: ?*INetFwProduct, registration: ?*?*IUnknown) HRESULT {
                return @as(*const INetFwProducts.VTable, @ptrCast(self.vtable)).Register(@as(*const INetFwProducts, @ptrCast(self)), product, registration);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwProducts_Item(self: *const T, index: i32, product: ?*?*INetFwProduct) HRESULT {
                return @as(*const INetFwProducts.VTable, @ptrCast(self.vtable)).Item(@as(*const INetFwProducts, @ptrCast(self)), index, product);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetFwProducts_get__NewEnum(self: *const T, newEnum: ?*?*IUnknown) HRESULT {
                return @as(*const INetFwProducts.VTable, @ptrCast(self.vtable)).get__NewEnum(@as(*const INetFwProducts, @ptrCast(self)), newEnum);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

//--------------------------------------------------------------------------------
// Section: Functions (8)
//--------------------------------------------------------------------------------
// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-net-isolation-l1-1-0" fn NetworkIsolationSetupAppContainerBinaries(
    applicationContainerSid: ?PSID,
    packageFullName: ?[*:0]const u16,
    packageFolder: ?[*:0]const u16,
    displayName: ?[*:0]const u16,
    bBinariesFullyComputed: BOOL,
    binaries: [*]?PWSTR,
    binariesCount: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-net-isolation-l1-1-0" fn NetworkIsolationRegisterForAppContainerChanges(
    flags: u32,
    callback: ?PAC_CHANGES_CALLBACK_FN,
    context: ?*anyopaque,
    registrationObject: ?*?HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-net-isolation-l1-1-0" fn NetworkIsolationUnregisterForAppContainerChanges(
    registrationObject: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-net-isolation-l1-1-0" fn NetworkIsolationFreeAppContainers(
    pPublicAppCs: ?*INET_FIREWALL_APP_CONTAINER,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-net-isolation-l1-1-0" fn NetworkIsolationEnumAppContainers(
    Flags: u32,
    pdwNumPublicAppCs: ?*u32,
    ppPublicAppCs: ?*?*INET_FIREWALL_APP_CONTAINER,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-net-isolation-l1-1-0" fn NetworkIsolationGetAppContainerConfig(
    pdwNumPublicAppCs: ?*u32,
    appContainerSids: ?*?*SID_AND_ATTRIBUTES,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-net-isolation-l1-1-0" fn NetworkIsolationSetAppContainerConfig(
    dwNumPublicAppCs: u32,
    appContainerSids: [*]SID_AND_ATTRIBUTES,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-net-isolation-l1-1-0" fn NetworkIsolationDiagnoseConnectFailureAndGetInfo(
    wszServerName: ?[*:0]const u16,
    netIsoError: ?*NETISO_ERROR_TYPE,
) callconv(@import("std").os.windows.WINAPI) u32;

//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {},
    .wide => struct {},
    .unspecified => if (@import("builtin").is_test) struct {} else struct {},
};
//--------------------------------------------------------------------------------
// Section: Imports (13)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const BOOL = @import("../foundation.zig").BOOL;
const BSTR = @import("../foundation.zig").BSTR;
const HANDLE = @import("../foundation.zig").HANDLE;
const HRESULT = @import("../foundation.zig").HRESULT;
const HWND = @import("../foundation.zig").HWND;
const IDispatch = @import("../system/com.zig").IDispatch;
const IUnknown = @import("../system/com.zig").IUnknown;
const PSID = @import("../foundation.zig").PSID;
const PWSTR = @import("../foundation.zig").PWSTR;
const SID = @import("../security.zig").SID;
const SID_AND_ATTRIBUTES = @import("../security.zig").SID_AND_ATTRIBUTES;
const VARIANT = @import("../system/com.zig").VARIANT;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "PAC_CHANGES_CALLBACK_FN")) {
        _ = PAC_CHANGES_CALLBACK_FN;
    }
    if (@hasDecl(@This(), "PNETISO_EDP_ID_CALLBACK_FN")) {
        _ = PNETISO_EDP_ID_CALLBACK_FN;
    }
    if (@hasDecl(@This(), "PFN_FWADDDYNAMICKEYWORDADDRESS0")) {
        _ = PFN_FWADDDYNAMICKEYWORDADDRESS0;
    }
    if (@hasDecl(@This(), "PFN_FWDELETEDYNAMICKEYWORDADDRESS0")) {
        _ = PFN_FWDELETEDYNAMICKEYWORDADDRESS0;
    }
    if (@hasDecl(@This(), "PFN_FWENUMDYNAMICKEYWORDADDRESSESBYTYPE0")) {
        _ = PFN_FWENUMDYNAMICKEYWORDADDRESSESBYTYPE0;
    }
    if (@hasDecl(@This(), "PFN_FWENUMDYNAMICKEYWORDADDRESSBYID0")) {
        _ = PFN_FWENUMDYNAMICKEYWORDADDRESSBYID0;
    }
    if (@hasDecl(@This(), "PFN_FWFREEDYNAMICKEYWORDADDRESSDATA0")) {
        _ = PFN_FWFREEDYNAMICKEYWORDADDRESSDATA0;
    }
    if (@hasDecl(@This(), "PFN_FWUPDATEDYNAMICKEYWORDADDRESS0")) {
        _ = PFN_FWUPDATEDYNAMICKEYWORDADDRESS0;
    }

    @setEvalBranchQuota(comptime @import("std").meta.declarations(@This()).len * 3);

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        if (decl.is_pub) {
            _ = @field(@This(), decl.name);
        }
    }
}
