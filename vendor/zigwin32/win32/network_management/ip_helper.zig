//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (445)
//--------------------------------------------------------------------------------
pub const ANY_SIZE = @as(u32, 1);
pub const MAXLEN_PHYSADDR = @as(u32, 8);
pub const MAXLEN_IFDESCR = @as(u32, 256);
pub const MAX_INTERFACE_NAME_LEN = @as(u32, 256);
pub const MIN_IF_TYPE = @as(u32, 1);
pub const IF_TYPE_OTHER = @as(u32, 1);
pub const IF_TYPE_REGULAR_1822 = @as(u32, 2);
pub const IF_TYPE_HDH_1822 = @as(u32, 3);
pub const IF_TYPE_DDN_X25 = @as(u32, 4);
pub const IF_TYPE_RFC877_X25 = @as(u32, 5);
pub const IF_TYPE_ETHERNET_CSMACD = @as(u32, 6);
pub const IF_TYPE_IS088023_CSMACD = @as(u32, 7);
pub const IF_TYPE_ISO88024_TOKENBUS = @as(u32, 8);
pub const IF_TYPE_ISO88025_TOKENRING = @as(u32, 9);
pub const IF_TYPE_ISO88026_MAN = @as(u32, 10);
pub const IF_TYPE_STARLAN = @as(u32, 11);
pub const IF_TYPE_PROTEON_10MBIT = @as(u32, 12);
pub const IF_TYPE_PROTEON_80MBIT = @as(u32, 13);
pub const IF_TYPE_HYPERCHANNEL = @as(u32, 14);
pub const IF_TYPE_FDDI = @as(u32, 15);
pub const IF_TYPE_LAP_B = @as(u32, 16);
pub const IF_TYPE_SDLC = @as(u32, 17);
pub const IF_TYPE_DS1 = @as(u32, 18);
pub const IF_TYPE_E1 = @as(u32, 19);
pub const IF_TYPE_BASIC_ISDN = @as(u32, 20);
pub const IF_TYPE_PRIMARY_ISDN = @as(u32, 21);
pub const IF_TYPE_PROP_POINT2POINT_SERIAL = @as(u32, 22);
pub const IF_TYPE_PPP = @as(u32, 23);
pub const IF_TYPE_SOFTWARE_LOOPBACK = @as(u32, 24);
pub const IF_TYPE_EON = @as(u32, 25);
pub const IF_TYPE_ETHERNET_3MBIT = @as(u32, 26);
pub const IF_TYPE_NSIP = @as(u32, 27);
pub const IF_TYPE_SLIP = @as(u32, 28);
pub const IF_TYPE_ULTRA = @as(u32, 29);
pub const IF_TYPE_DS3 = @as(u32, 30);
pub const IF_TYPE_SIP = @as(u32, 31);
pub const IF_TYPE_FRAMERELAY = @as(u32, 32);
pub const IF_TYPE_RS232 = @as(u32, 33);
pub const IF_TYPE_PARA = @as(u32, 34);
pub const IF_TYPE_ARCNET = @as(u32, 35);
pub const IF_TYPE_ARCNET_PLUS = @as(u32, 36);
pub const IF_TYPE_ATM = @as(u32, 37);
pub const IF_TYPE_MIO_X25 = @as(u32, 38);
pub const IF_TYPE_SONET = @as(u32, 39);
pub const IF_TYPE_X25_PLE = @as(u32, 40);
pub const IF_TYPE_ISO88022_LLC = @as(u32, 41);
pub const IF_TYPE_LOCALTALK = @as(u32, 42);
pub const IF_TYPE_SMDS_DXI = @as(u32, 43);
pub const IF_TYPE_FRAMERELAY_SERVICE = @as(u32, 44);
pub const IF_TYPE_V35 = @as(u32, 45);
pub const IF_TYPE_HSSI = @as(u32, 46);
pub const IF_TYPE_HIPPI = @as(u32, 47);
pub const IF_TYPE_MODEM = @as(u32, 48);
pub const IF_TYPE_AAL5 = @as(u32, 49);
pub const IF_TYPE_SONET_PATH = @as(u32, 50);
pub const IF_TYPE_SONET_VT = @as(u32, 51);
pub const IF_TYPE_SMDS_ICIP = @as(u32, 52);
pub const IF_TYPE_PROP_VIRTUAL = @as(u32, 53);
pub const IF_TYPE_PROP_MULTIPLEXOR = @as(u32, 54);
pub const IF_TYPE_IEEE80212 = @as(u32, 55);
pub const IF_TYPE_FIBRECHANNEL = @as(u32, 56);
pub const IF_TYPE_HIPPIINTERFACE = @as(u32, 57);
pub const IF_TYPE_FRAMERELAY_INTERCONNECT = @as(u32, 58);
pub const IF_TYPE_AFLANE_8023 = @as(u32, 59);
pub const IF_TYPE_AFLANE_8025 = @as(u32, 60);
pub const IF_TYPE_CCTEMUL = @as(u32, 61);
pub const IF_TYPE_FASTETHER = @as(u32, 62);
pub const IF_TYPE_ISDN = @as(u32, 63);
pub const IF_TYPE_V11 = @as(u32, 64);
pub const IF_TYPE_V36 = @as(u32, 65);
pub const IF_TYPE_G703_64K = @as(u32, 66);
pub const IF_TYPE_G703_2MB = @as(u32, 67);
pub const IF_TYPE_QLLC = @as(u32, 68);
pub const IF_TYPE_FASTETHER_FX = @as(u32, 69);
pub const IF_TYPE_CHANNEL = @as(u32, 70);
pub const IF_TYPE_IEEE80211 = @as(u32, 71);
pub const IF_TYPE_IBM370PARCHAN = @as(u32, 72);
pub const IF_TYPE_ESCON = @as(u32, 73);
pub const IF_TYPE_DLSW = @as(u32, 74);
pub const IF_TYPE_ISDN_S = @as(u32, 75);
pub const IF_TYPE_ISDN_U = @as(u32, 76);
pub const IF_TYPE_LAP_D = @as(u32, 77);
pub const IF_TYPE_IPSWITCH = @as(u32, 78);
pub const IF_TYPE_RSRB = @as(u32, 79);
pub const IF_TYPE_ATM_LOGICAL = @as(u32, 80);
pub const IF_TYPE_DS0 = @as(u32, 81);
pub const IF_TYPE_DS0_BUNDLE = @as(u32, 82);
pub const IF_TYPE_BSC = @as(u32, 83);
pub const IF_TYPE_ASYNC = @as(u32, 84);
pub const IF_TYPE_CNR = @as(u32, 85);
pub const IF_TYPE_ISO88025R_DTR = @as(u32, 86);
pub const IF_TYPE_EPLRS = @as(u32, 87);
pub const IF_TYPE_ARAP = @as(u32, 88);
pub const IF_TYPE_PROP_CNLS = @as(u32, 89);
pub const IF_TYPE_HOSTPAD = @as(u32, 90);
pub const IF_TYPE_TERMPAD = @as(u32, 91);
pub const IF_TYPE_FRAMERELAY_MPI = @as(u32, 92);
pub const IF_TYPE_X213 = @as(u32, 93);
pub const IF_TYPE_ADSL = @as(u32, 94);
pub const IF_TYPE_RADSL = @as(u32, 95);
pub const IF_TYPE_SDSL = @as(u32, 96);
pub const IF_TYPE_VDSL = @as(u32, 97);
pub const IF_TYPE_ISO88025_CRFPRINT = @as(u32, 98);
pub const IF_TYPE_MYRINET = @as(u32, 99);
pub const IF_TYPE_VOICE_EM = @as(u32, 100);
pub const IF_TYPE_VOICE_FXO = @as(u32, 101);
pub const IF_TYPE_VOICE_FXS = @as(u32, 102);
pub const IF_TYPE_VOICE_ENCAP = @as(u32, 103);
pub const IF_TYPE_VOICE_OVERIP = @as(u32, 104);
pub const IF_TYPE_ATM_DXI = @as(u32, 105);
pub const IF_TYPE_ATM_FUNI = @as(u32, 106);
pub const IF_TYPE_ATM_IMA = @as(u32, 107);
pub const IF_TYPE_PPPMULTILINKBUNDLE = @as(u32, 108);
pub const IF_TYPE_IPOVER_CDLC = @as(u32, 109);
pub const IF_TYPE_IPOVER_CLAW = @as(u32, 110);
pub const IF_TYPE_STACKTOSTACK = @as(u32, 111);
pub const IF_TYPE_VIRTUALIPADDRESS = @as(u32, 112);
pub const IF_TYPE_MPC = @as(u32, 113);
pub const IF_TYPE_IPOVER_ATM = @as(u32, 114);
pub const IF_TYPE_ISO88025_FIBER = @as(u32, 115);
pub const IF_TYPE_TDLC = @as(u32, 116);
pub const IF_TYPE_GIGABITETHERNET = @as(u32, 117);
pub const IF_TYPE_HDLC = @as(u32, 118);
pub const IF_TYPE_LAP_F = @as(u32, 119);
pub const IF_TYPE_V37 = @as(u32, 120);
pub const IF_TYPE_X25_MLP = @as(u32, 121);
pub const IF_TYPE_X25_HUNTGROUP = @as(u32, 122);
pub const IF_TYPE_TRANSPHDLC = @as(u32, 123);
pub const IF_TYPE_INTERLEAVE = @as(u32, 124);
pub const IF_TYPE_FAST = @as(u32, 125);
pub const IF_TYPE_IP = @as(u32, 126);
pub const IF_TYPE_DOCSCABLE_MACLAYER = @as(u32, 127);
pub const IF_TYPE_DOCSCABLE_DOWNSTREAM = @as(u32, 128);
pub const IF_TYPE_DOCSCABLE_UPSTREAM = @as(u32, 129);
pub const IF_TYPE_A12MPPSWITCH = @as(u32, 130);
pub const IF_TYPE_TUNNEL = @as(u32, 131);
pub const IF_TYPE_COFFEE = @as(u32, 132);
pub const IF_TYPE_CES = @as(u32, 133);
pub const IF_TYPE_ATM_SUBINTERFACE = @as(u32, 134);
pub const IF_TYPE_L2_VLAN = @as(u32, 135);
pub const IF_TYPE_L3_IPVLAN = @as(u32, 136);
pub const IF_TYPE_L3_IPXVLAN = @as(u32, 137);
pub const IF_TYPE_DIGITALPOWERLINE = @as(u32, 138);
pub const IF_TYPE_MEDIAMAILOVERIP = @as(u32, 139);
pub const IF_TYPE_DTM = @as(u32, 140);
pub const IF_TYPE_DCN = @as(u32, 141);
pub const IF_TYPE_IPFORWARD = @as(u32, 142);
pub const IF_TYPE_MSDSL = @as(u32, 143);
pub const IF_TYPE_IEEE1394 = @as(u32, 144);
pub const IF_TYPE_IF_GSN = @as(u32, 145);
pub const IF_TYPE_DVBRCC_MACLAYER = @as(u32, 146);
pub const IF_TYPE_DVBRCC_DOWNSTREAM = @as(u32, 147);
pub const IF_TYPE_DVBRCC_UPSTREAM = @as(u32, 148);
pub const IF_TYPE_ATM_VIRTUAL = @as(u32, 149);
pub const IF_TYPE_MPLS_TUNNEL = @as(u32, 150);
pub const IF_TYPE_SRP = @as(u32, 151);
pub const IF_TYPE_VOICEOVERATM = @as(u32, 152);
pub const IF_TYPE_VOICEOVERFRAMERELAY = @as(u32, 153);
pub const IF_TYPE_IDSL = @as(u32, 154);
pub const IF_TYPE_COMPOSITELINK = @as(u32, 155);
pub const IF_TYPE_SS7_SIGLINK = @as(u32, 156);
pub const IF_TYPE_PROP_WIRELESS_P2P = @as(u32, 157);
pub const IF_TYPE_FR_FORWARD = @as(u32, 158);
pub const IF_TYPE_RFC1483 = @as(u32, 159);
pub const IF_TYPE_USB = @as(u32, 160);
pub const IF_TYPE_IEEE8023AD_LAG = @as(u32, 161);
pub const IF_TYPE_BGP_POLICY_ACCOUNTING = @as(u32, 162);
pub const IF_TYPE_FRF16_MFR_BUNDLE = @as(u32, 163);
pub const IF_TYPE_H323_GATEKEEPER = @as(u32, 164);
pub const IF_TYPE_H323_PROXY = @as(u32, 165);
pub const IF_TYPE_MPLS = @as(u32, 166);
pub const IF_TYPE_MF_SIGLINK = @as(u32, 167);
pub const IF_TYPE_HDSL2 = @as(u32, 168);
pub const IF_TYPE_SHDSL = @as(u32, 169);
pub const IF_TYPE_DS1_FDL = @as(u32, 170);
pub const IF_TYPE_POS = @as(u32, 171);
pub const IF_TYPE_DVB_ASI_IN = @as(u32, 172);
pub const IF_TYPE_DVB_ASI_OUT = @as(u32, 173);
pub const IF_TYPE_PLC = @as(u32, 174);
pub const IF_TYPE_NFAS = @as(u32, 175);
pub const IF_TYPE_TR008 = @as(u32, 176);
pub const IF_TYPE_GR303_RDT = @as(u32, 177);
pub const IF_TYPE_GR303_IDT = @as(u32, 178);
pub const IF_TYPE_ISUP = @as(u32, 179);
pub const IF_TYPE_PROP_DOCS_WIRELESS_MACLAYER = @as(u32, 180);
pub const IF_TYPE_PROP_DOCS_WIRELESS_DOWNSTREAM = @as(u32, 181);
pub const IF_TYPE_PROP_DOCS_WIRELESS_UPSTREAM = @as(u32, 182);
pub const IF_TYPE_HIPERLAN2 = @as(u32, 183);
pub const IF_TYPE_PROP_BWA_P2MP = @as(u32, 184);
pub const IF_TYPE_SONET_OVERHEAD_CHANNEL = @as(u32, 185);
pub const IF_TYPE_DIGITAL_WRAPPER_OVERHEAD_CHANNEL = @as(u32, 186);
pub const IF_TYPE_AAL2 = @as(u32, 187);
pub const IF_TYPE_RADIO_MAC = @as(u32, 188);
pub const IF_TYPE_ATM_RADIO = @as(u32, 189);
pub const IF_TYPE_IMT = @as(u32, 190);
pub const IF_TYPE_MVL = @as(u32, 191);
pub const IF_TYPE_REACH_DSL = @as(u32, 192);
pub const IF_TYPE_FR_DLCI_ENDPT = @as(u32, 193);
pub const IF_TYPE_ATM_VCI_ENDPT = @as(u32, 194);
pub const IF_TYPE_OPTICAL_CHANNEL = @as(u32, 195);
pub const IF_TYPE_OPTICAL_TRANSPORT = @as(u32, 196);
pub const IF_TYPE_IEEE80216_WMAN = @as(u32, 237);
pub const IF_TYPE_WWANPP = @as(u32, 243);
pub const IF_TYPE_WWANPP2 = @as(u32, 244);
pub const IF_TYPE_IEEE802154 = @as(u32, 259);
pub const IF_TYPE_XBOX_WIRELESS = @as(u32, 281);
pub const MAX_IF_TYPE = @as(u32, 281);
pub const IF_CHECK_NONE = @as(u32, 0);
pub const IF_CHECK_MCAST = @as(u32, 1);
pub const IF_CHECK_SEND = @as(u32, 2);
pub const IF_CONNECTION_DEDICATED = @as(u32, 1);
pub const IF_CONNECTION_PASSIVE = @as(u32, 2);
pub const IF_CONNECTION_DEMAND = @as(u32, 3);
pub const IF_ADMIN_STATUS_UP = @as(u32, 1);
pub const IF_ADMIN_STATUS_DOWN = @as(u32, 2);
pub const IF_ADMIN_STATUS_TESTING = @as(u32, 3);
pub const MIB_IF_TYPE_OTHER = @as(u32, 1);
pub const MIB_IF_TYPE_ETHERNET = @as(u32, 6);
pub const MIB_IF_TYPE_TOKENRING = @as(u32, 9);
pub const MIB_IF_TYPE_FDDI = @as(u32, 15);
pub const MIB_IF_TYPE_PPP = @as(u32, 23);
pub const MIB_IF_TYPE_LOOPBACK = @as(u32, 24);
pub const MIB_IF_TYPE_SLIP = @as(u32, 28);
pub const MIB_IF_ADMIN_STATUS_UP = @as(u32, 1);
pub const MIB_IF_ADMIN_STATUS_DOWN = @as(u32, 2);
pub const MIB_IF_ADMIN_STATUS_TESTING = @as(u32, 3);
pub const MIB_IPADDR_PRIMARY = @as(u32, 1);
pub const MIB_IPADDR_DYNAMIC = @as(u32, 4);
pub const MIB_IPADDR_DISCONNECTED = @as(u32, 8);
pub const MIB_IPADDR_DELETED = @as(u32, 64);
pub const MIB_IPADDR_TRANSIENT = @as(u32, 128);
pub const MIB_IPADDR_DNS_ELIGIBLE = @as(u32, 256);
pub const MIB_IPROUTE_METRIC_UNUSED = @as(u32, 4294967295);
pub const MIB_USE_CURRENT_TTL = @as(u32, 4294967295);
pub const MIB_USE_CURRENT_FORWARDING = @as(u32, 4294967295);
pub const ICMP6_INFOMSG_MASK = @as(u32, 128);
pub const IPRTRMGR_PID = @as(u32, 10000);
pub const IF_NUMBER = @as(u32, 0);
pub const IF_TABLE = @as(u32, 1);
pub const IF_ROW = @as(u32, 2);
pub const IP_STATS = @as(u32, 3);
pub const IP_ADDRTABLE = @as(u32, 4);
pub const IP_ADDRROW = @as(u32, 5);
pub const IP_FORWARDNUMBER = @as(u32, 6);
pub const IP_FORWARDTABLE = @as(u32, 7);
pub const IP_FORWARDROW = @as(u32, 8);
pub const IP_NETTABLE = @as(u32, 9);
pub const IP_NETROW = @as(u32, 10);
pub const ICMP_STATS = @as(u32, 11);
pub const TCP_STATS = @as(u32, 12);
pub const TCP_TABLE = @as(u32, 13);
pub const TCP_ROW = @as(u32, 14);
pub const UDP_STATS = @as(u32, 15);
pub const UDP_TABLE = @as(u32, 16);
pub const UDP_ROW = @as(u32, 17);
pub const MCAST_MFE = @as(u32, 18);
pub const MCAST_MFE_STATS = @as(u32, 19);
pub const BEST_IF = @as(u32, 20);
pub const BEST_ROUTE = @as(u32, 21);
pub const PROXY_ARP = @as(u32, 22);
pub const MCAST_IF_ENTRY = @as(u32, 23);
pub const MCAST_GLOBAL = @as(u32, 24);
pub const IF_STATUS = @as(u32, 25);
pub const MCAST_BOUNDARY = @as(u32, 26);
pub const MCAST_SCOPE = @as(u32, 27);
pub const DEST_MATCHING = @as(u32, 28);
pub const DEST_LONGER = @as(u32, 29);
pub const DEST_SHORTER = @as(u32, 30);
pub const ROUTE_MATCHING = @as(u32, 31);
pub const ROUTE_LONGER = @as(u32, 32);
pub const ROUTE_SHORTER = @as(u32, 33);
pub const ROUTE_STATE = @as(u32, 34);
pub const MCAST_MFE_STATS_EX = @as(u32, 35);
pub const IP6_STATS = @as(u32, 36);
pub const UDP6_STATS = @as(u32, 37);
pub const TCP6_STATS = @as(u32, 38);
pub const NUMBER_OF_EXPORTED_VARIABLES = @as(u32, 39);
pub const MAX_SCOPE_NAME_LEN = @as(u32, 255);
pub const MAX_MIB_OFFSET = @as(u32, 8);
pub const MIB_INVALID_TEREDO_PORT_NUMBER = @as(u32, 0);
pub const DNS_SETTINGS_VERSION1 = @as(u32, 1);
pub const DNS_SETTINGS_VERSION2 = @as(u32, 2);
pub const DNS_INTERFACE_SETTINGS_VERSION1 = @as(u32, 1);
pub const DNS_INTERFACE_SETTINGS_VERSION2 = @as(u32, 2);
pub const DNS_INTERFACE_SETTINGS_VERSION3 = @as(u32, 3);
pub const DNS_SETTING_IPV6 = @as(u32, 1);
pub const DNS_SETTING_NAMESERVER = @as(u32, 2);
pub const DNS_SETTING_SEARCHLIST = @as(u32, 4);
pub const DNS_SETTING_REGISTRATION_ENABLED = @as(u32, 8);
pub const DNS_SETTING_REGISTER_ADAPTER_NAME = @as(u32, 16);
pub const DNS_SETTING_DOMAIN = @as(u32, 32);
pub const DNS_SETTING_HOSTNAME = @as(u32, 64);
pub const DNS_SETTINGS_ENABLE_LLMNR = @as(u32, 128);
pub const DNS_SETTINGS_QUERY_ADAPTER_NAME = @as(u32, 256);
pub const DNS_SETTING_PROFILE_NAMESERVER = @as(u32, 512);
pub const DNS_SETTING_DISABLE_UNCONSTRAINED_QUERIES = @as(u32, 1024);
pub const DNS_SETTING_SUPPLEMENTAL_SEARCH_LIST = @as(u32, 2048);
pub const DNS_SETTING_DOH = @as(u32, 4096);
pub const DNS_SETTING_DOH_PROFILE = @as(u32, 8192);
pub const DNS_ENABLE_DOH = @as(u32, 1);
pub const DNS_DOH_POLICY_NOT_CONFIGURED = @as(u32, 4);
pub const DNS_DOH_POLICY_DISABLE = @as(u32, 8);
pub const DNS_DOH_POLICY_AUTO = @as(u32, 16);
pub const DNS_DOH_POLICY_REQUIRED = @as(u32, 32);
pub const DNS_SERVER_PROPERTY_VERSION1 = @as(u32, 1);
pub const DNS_DOH_SERVER_SETTINGS_ENABLE_AUTO = @as(u32, 1);
pub const DNS_DOH_SERVER_SETTINGS_ENABLE = @as(u32, 2);
pub const DNS_DOH_SERVER_SETTINGS_FALLBACK_TO_UDP = @as(u32, 4);
pub const DNS_DOH_AUTO_UPGRADE_SERVER = @as(u32, 8);
pub const TCPIP_OWNING_MODULE_SIZE = @as(u32, 16);
pub const FD_FLAGS_NOSYN = @as(u32, 1);
pub const FD_FLAGS_ALLFLAGS = @as(u32, 1);
pub const LB_SRC_ADDR_USE_SRCADDR_FLAG = @as(u32, 1);
pub const LB_SRC_ADDR_USE_DSTADDR_FLAG = @as(u32, 2);
pub const LB_DST_ADDR_USE_SRCADDR_FLAG = @as(u32, 4);
pub const LB_DST_ADDR_USE_DSTADDR_FLAG = @as(u32, 8);
pub const LB_SRC_MASK_LATE_FLAG = @as(u32, 16);
pub const LB_DST_MASK_LATE_FLAG = @as(u32, 32);
pub const ERROR_BASE = @as(u32, 23000);
pub const PFERROR_NO_PF_INTERFACE = @as(u32, 23000);
pub const PFERROR_NO_FILTERS_GIVEN = @as(u32, 23001);
pub const PFERROR_BUFFER_TOO_SMALL = @as(u32, 23002);
pub const ERROR_IPV6_NOT_IMPLEMENTED = @as(u32, 23003);
pub const IP_EXPORT_INCLUDED = @as(u32, 1);
pub const MAX_ADAPTER_NAME = @as(u32, 128);
pub const IP_STATUS_BASE = @as(u32, 11000);
pub const IP_SUCCESS = @as(u32, 0);
pub const IP_BUF_TOO_SMALL = @as(u32, 11001);
pub const IP_DEST_NET_UNREACHABLE = @as(u32, 11002);
pub const IP_DEST_HOST_UNREACHABLE = @as(u32, 11003);
pub const IP_DEST_PROT_UNREACHABLE = @as(u32, 11004);
pub const IP_DEST_PORT_UNREACHABLE = @as(u32, 11005);
pub const IP_NO_RESOURCES = @as(u32, 11006);
pub const IP_BAD_OPTION = @as(u32, 11007);
pub const IP_HW_ERROR = @as(u32, 11008);
pub const IP_PACKET_TOO_BIG = @as(u32, 11009);
pub const IP_REQ_TIMED_OUT = @as(u32, 11010);
pub const IP_BAD_REQ = @as(u32, 11011);
pub const IP_BAD_ROUTE = @as(u32, 11012);
pub const IP_TTL_EXPIRED_TRANSIT = @as(u32, 11013);
pub const IP_TTL_EXPIRED_REASSEM = @as(u32, 11014);
pub const IP_PARAM_PROBLEM = @as(u32, 11015);
pub const IP_SOURCE_QUENCH = @as(u32, 11016);
pub const IP_OPTION_TOO_BIG = @as(u32, 11017);
pub const IP_BAD_DESTINATION = @as(u32, 11018);
pub const IP_DEST_NO_ROUTE = @as(u32, 11002);
pub const IP_DEST_ADDR_UNREACHABLE = @as(u32, 11003);
pub const IP_DEST_PROHIBITED = @as(u32, 11004);
pub const IP_HOP_LIMIT_EXCEEDED = @as(u32, 11013);
pub const IP_REASSEMBLY_TIME_EXCEEDED = @as(u32, 11014);
pub const IP_PARAMETER_PROBLEM = @as(u32, 11015);
pub const IP_DEST_UNREACHABLE = @as(u32, 11040);
pub const IP_TIME_EXCEEDED = @as(u32, 11041);
pub const IP_BAD_HEADER = @as(u32, 11042);
pub const IP_UNRECOGNIZED_NEXT_HEADER = @as(u32, 11043);
pub const IP_ICMP_ERROR = @as(u32, 11044);
pub const IP_DEST_SCOPE_MISMATCH = @as(u32, 11045);
pub const IP_ADDR_DELETED = @as(u32, 11019);
pub const IP_SPEC_MTU_CHANGE = @as(u32, 11020);
pub const IP_MTU_CHANGE = @as(u32, 11021);
pub const IP_UNLOAD = @as(u32, 11022);
pub const IP_ADDR_ADDED = @as(u32, 11023);
pub const IP_MEDIA_CONNECT = @as(u32, 11024);
pub const IP_MEDIA_DISCONNECT = @as(u32, 11025);
pub const IP_BIND_ADAPTER = @as(u32, 11026);
pub const IP_UNBIND_ADAPTER = @as(u32, 11027);
pub const IP_DEVICE_DOES_NOT_EXIST = @as(u32, 11028);
pub const IP_DUPLICATE_ADDRESS = @as(u32, 11029);
pub const IP_INTERFACE_METRIC_CHANGE = @as(u32, 11030);
pub const IP_RECONFIG_SECFLTR = @as(u32, 11031);
pub const IP_NEGOTIATING_IPSEC = @as(u32, 11032);
pub const IP_INTERFACE_WOL_CAPABILITY_CHANGE = @as(u32, 11033);
pub const IP_DUPLICATE_IPADD = @as(u32, 11034);
pub const IP_GENERAL_FAILURE = @as(u32, 11050);
pub const MAX_IP_STATUS = @as(u32, 11050);
pub const IP_PENDING = @as(u32, 11255);
pub const IP_FLAG_REVERSE = @as(u32, 1);
pub const IP_FLAG_DF = @as(u32, 2);
pub const MAX_OPT_SIZE = @as(u32, 40);
pub const IOCTL_IP_RTCHANGE_NOTIFY_REQUEST = @as(u32, 101);
pub const IOCTL_IP_ADDCHANGE_NOTIFY_REQUEST = @as(u32, 102);
pub const IOCTL_ARP_SEND_REQUEST = @as(u32, 103);
pub const IOCTL_IP_INTERFACE_INFO = @as(u32, 104);
pub const IOCTL_IP_GET_BEST_INTERFACE = @as(u32, 105);
pub const IOCTL_IP_UNIDIRECTIONAL_ADAPTER_ADDRESS = @as(u32, 106);
pub const NET_STRING_IPV4_ADDRESS = @as(u32, 1);
pub const NET_STRING_IPV4_SERVICE = @as(u32, 2);
pub const NET_STRING_IPV4_NETWORK = @as(u32, 4);
pub const NET_STRING_IPV6_ADDRESS = @as(u32, 8);
pub const NET_STRING_IPV6_ADDRESS_NO_SCOPE = @as(u32, 16);
pub const NET_STRING_IPV6_SERVICE = @as(u32, 32);
pub const NET_STRING_IPV6_SERVICE_NO_SCOPE = @as(u32, 64);
pub const NET_STRING_IPV6_NETWORK = @as(u32, 128);
pub const NET_STRING_NAMED_ADDRESS = @as(u32, 256);
pub const NET_STRING_NAMED_SERVICE = @as(u32, 512);
pub const MAX_ADAPTER_DESCRIPTION_LENGTH = @as(u32, 128);
pub const MAX_ADAPTER_NAME_LENGTH = @as(u32, 256);
pub const MAX_ADAPTER_ADDRESS_LENGTH = @as(u32, 8);
pub const DEFAULT_MINIMUM_ENTITIES = @as(u32, 32);
pub const MAX_HOSTNAME_LEN = @as(u32, 128);
pub const MAX_DOMAIN_NAME_LEN = @as(u32, 128);
pub const MAX_SCOPE_ID_LEN = @as(u32, 256);
pub const MAX_DHCPV6_DUID_LENGTH = @as(u32, 130);
pub const MAX_DNS_SUFFIX_STRING_LENGTH = @as(u32, 256);
pub const BROADCAST_NODETYPE = @as(u32, 1);
pub const PEER_TO_PEER_NODETYPE = @as(u32, 2);
pub const MIXED_NODETYPE = @as(u32, 4);
pub const HYBRID_NODETYPE = @as(u32, 8);
pub const IP_ADAPTER_ADDRESS_DNS_ELIGIBLE = @as(u32, 1);
pub const IP_ADAPTER_ADDRESS_TRANSIENT = @as(u32, 2);
pub const IP_ADAPTER_DDNS_ENABLED = @as(u32, 1);
pub const IP_ADAPTER_REGISTER_ADAPTER_SUFFIX = @as(u32, 2);
pub const IP_ADAPTER_DHCP_ENABLED = @as(u32, 4);
pub const IP_ADAPTER_RECEIVE_ONLY = @as(u32, 8);
pub const IP_ADAPTER_NO_MULTICAST = @as(u32, 16);
pub const IP_ADAPTER_IPV6_OTHER_STATEFUL_CONFIG = @as(u32, 32);
pub const IP_ADAPTER_NETBIOS_OVER_TCPIP_ENABLED = @as(u32, 64);
pub const IP_ADAPTER_IPV4_ENABLED = @as(u32, 128);
pub const IP_ADAPTER_IPV6_ENABLED = @as(u32, 256);
pub const IP_ADAPTER_IPV6_MANAGE_ADDRESS_CONFIG = @as(u32, 512);
pub const GAA_FLAG_SKIP_DNS_INFO = @as(u32, 2048);
pub const IP_ROUTER_MANAGER_VERSION = @as(u32, 1);
pub const IP_GENERAL_INFO_BASE = @as(u32, 4294901760);
pub const IP_IN_FILTER_INFO = @as(u32, 4294901761);
pub const IP_OUT_FILTER_INFO = @as(u32, 4294901762);
pub const IP_GLOBAL_INFO = @as(u32, 4294901763);
pub const IP_INTERFACE_STATUS_INFO = @as(u32, 4294901764);
pub const IP_ROUTE_INFO = @as(u32, 4294901765);
pub const IP_PROT_PRIORITY_INFO = @as(u32, 4294901766);
pub const IP_ROUTER_DISC_INFO = @as(u32, 4294901767);
pub const IP_DEMAND_DIAL_FILTER_INFO = @as(u32, 4294901769);
pub const IP_MCAST_HEARBEAT_INFO = @as(u32, 4294901770);
pub const IP_MCAST_BOUNDARY_INFO = @as(u32, 4294901771);
pub const IP_IPINIP_CFG_INFO = @as(u32, 4294901772);
pub const IP_IFFILTER_INFO = @as(u32, 4294901773);
pub const IP_MCAST_LIMIT_INFO = @as(u32, 4294901774);
pub const IPV6_GLOBAL_INFO = @as(u32, 4294901775);
pub const IPV6_ROUTE_INFO = @as(u32, 4294901776);
pub const IP_IN_FILTER_INFO_V6 = @as(u32, 4294901777);
pub const IP_OUT_FILTER_INFO_V6 = @as(u32, 4294901778);
pub const IP_DEMAND_DIAL_FILTER_INFO_V6 = @as(u32, 4294901779);
pub const IP_IFFILTER_INFO_V6 = @as(u32, 4294901780);
pub const IP_FILTER_ENABLE_INFO = @as(u32, 4294901781);
pub const IP_FILTER_ENABLE_INFO_V6 = @as(u32, 4294901782);
pub const IP_PROT_PRIORITY_INFO_EX = @as(u32, 4294901783);

//--------------------------------------------------------------------------------
// Section: Types (206)
//--------------------------------------------------------------------------------
pub const GET_ADAPTERS_ADDRESSES_FLAGS = packed struct(u32) {
    SKIP_UNICAST: u1 = 0,
    SKIP_ANYCAST: u1 = 0,
    SKIP_MULTICAST: u1 = 0,
    SKIP_DNS_SERVER: u1 = 0,
    INCLUDE_PREFIX: u1 = 0,
    SKIP_FRIENDLY_NAME: u1 = 0,
    INCLUDE_WINS_INFO: u1 = 0,
    INCLUDE_GATEWAYS: u1 = 0,
    INCLUDE_ALL_INTERFACES: u1 = 0,
    INCLUDE_ALL_COMPARTMENTS: u1 = 0,
    INCLUDE_TUNNEL_BINDINGORDER: u1 = 0,
    _11: u1 = 0,
    _12: u1 = 0,
    _13: u1 = 0,
    _14: u1 = 0,
    _15: u1 = 0,
    _16: u1 = 0,
    _17: u1 = 0,
    _18: u1 = 0,
    _19: u1 = 0,
    _20: u1 = 0,
    _21: u1 = 0,
    _22: u1 = 0,
    _23: u1 = 0,
    _24: u1 = 0,
    _25: u1 = 0,
    _26: u1 = 0,
    _27: u1 = 0,
    _28: u1 = 0,
    _29: u1 = 0,
    _30: u1 = 0,
    _31: u1 = 0,
};
pub const GAA_FLAG_SKIP_UNICAST = GET_ADAPTERS_ADDRESSES_FLAGS{ .SKIP_UNICAST = 1 };
pub const GAA_FLAG_SKIP_ANYCAST = GET_ADAPTERS_ADDRESSES_FLAGS{ .SKIP_ANYCAST = 1 };
pub const GAA_FLAG_SKIP_MULTICAST = GET_ADAPTERS_ADDRESSES_FLAGS{ .SKIP_MULTICAST = 1 };
pub const GAA_FLAG_SKIP_DNS_SERVER = GET_ADAPTERS_ADDRESSES_FLAGS{ .SKIP_DNS_SERVER = 1 };
pub const GAA_FLAG_INCLUDE_PREFIX = GET_ADAPTERS_ADDRESSES_FLAGS{ .INCLUDE_PREFIX = 1 };
pub const GAA_FLAG_SKIP_FRIENDLY_NAME = GET_ADAPTERS_ADDRESSES_FLAGS{ .SKIP_FRIENDLY_NAME = 1 };
pub const GAA_FLAG_INCLUDE_WINS_INFO = GET_ADAPTERS_ADDRESSES_FLAGS{ .INCLUDE_WINS_INFO = 1 };
pub const GAA_FLAG_INCLUDE_GATEWAYS = GET_ADAPTERS_ADDRESSES_FLAGS{ .INCLUDE_GATEWAYS = 1 };
pub const GAA_FLAG_INCLUDE_ALL_INTERFACES = GET_ADAPTERS_ADDRESSES_FLAGS{ .INCLUDE_ALL_INTERFACES = 1 };
pub const GAA_FLAG_INCLUDE_ALL_COMPARTMENTS = GET_ADAPTERS_ADDRESSES_FLAGS{ .INCLUDE_ALL_COMPARTMENTS = 1 };
pub const GAA_FLAG_INCLUDE_TUNNEL_BINDINGORDER = GET_ADAPTERS_ADDRESSES_FLAGS{ .INCLUDE_TUNNEL_BINDINGORDER = 1 };

// TODO: this type has a FreeFunc 'IcmpCloseHandle', what can Zig do with this information?
// TODO: this type has an InvalidHandleValue of '0', what can Zig do with this information?
pub const IcmpHandle = isize;

// TODO: this type has an InvalidHandleValue of '0', what can Zig do with this information?
pub const HIFTIMESTAMPCHANGE = *opaque{};

pub const ip_option_information = extern struct {
    Ttl: u8,
    Tos: u8,
    Flags: u8,
    OptionsSize: u8,
    OptionsData: ?*u8,
};


pub const icmp_echo_reply = extern struct {
    Address: u32,
    Status: u32,
    RoundTripTime: u32,
    DataSize: u16,
    Reserved: u16,
    Data: ?*anyopaque,
    Options: ip_option_information,
};


pub const IPV6_ADDRESS_EX = extern struct {
    sin6_port: u16 align(1),
    sin6_flowinfo: u32 align(1),
    sin6_addr: [8]u16 align(1),
    sin6_scope_id: u32 align(1),
};

pub const icmpv6_echo_reply_lh = extern struct {
    Address: IPV6_ADDRESS_EX,
    Status: u32,
    RoundTripTime: u32,
};

pub const arp_send_reply = extern struct {
    DestAddress: u32,
    SrcAddress: u32,
};

pub const tcp_reserve_port_range = extern struct {
    UpperRange: u16,
    LowerRange: u16,
};

pub const IP_ADAPTER_INDEX_MAP = extern struct {
    Index: u32,
    Name: [128]u16,
};

pub const IP_INTERFACE_INFO = extern struct {
    NumAdapters: i32,
    Adapter: [1]IP_ADAPTER_INDEX_MAP,
};

pub const IP_UNIDIRECTIONAL_ADAPTER_ADDRESS = extern struct {
    NumAdapters: u32,
    Address: [1]u32,
};

pub const IP_ADAPTER_ORDER_MAP = extern struct {
    NumAdapters: u32,
    AdapterOrder: [1]u32,
};

pub const IP_MCAST_COUNTER_INFO = extern struct {
    InMcastOctets: u64,
    OutMcastOctets: u64,
    InMcastPkts: u64,
    OutMcastPkts: u64,
};

pub const IF_ACCESS_TYPE = enum(i32) {
    LOOPBACK = 1,
    BROADCAST = 2,
    POINT_TO_POINT = 3,
    POINT_TO_MULTI_POINT = 4,
    pub const POINTTOPOINT = .POINT_TO_POINT;
    pub const POINTTOMULTIPOINT = .POINT_TO_MULTI_POINT;
};
pub const IF_ACCESS_LOOPBACK = IF_ACCESS_TYPE.LOOPBACK;
pub const IF_ACCESS_BROADCAST = IF_ACCESS_TYPE.BROADCAST;
pub const IF_ACCESS_POINT_TO_POINT = IF_ACCESS_TYPE.POINT_TO_POINT;
pub const IF_ACCESS_POINTTOPOINT = IF_ACCESS_TYPE.POINT_TO_POINT;
pub const IF_ACCESS_POINT_TO_MULTI_POINT = IF_ACCESS_TYPE.POINT_TO_MULTI_POINT;
pub const IF_ACCESS_POINTTOMULTIPOINT = IF_ACCESS_TYPE.POINT_TO_MULTI_POINT;

pub const INTERNAL_IF_OPER_STATUS = enum(i32) {
    NON_OPERATIONAL = 0,
    UNREACHABLE = 1,
    DISCONNECTED = 2,
    CONNECTING = 3,
    CONNECTED = 4,
    OPERATIONAL = 5,
};
pub const IF_OPER_STATUS_NON_OPERATIONAL = INTERNAL_IF_OPER_STATUS.NON_OPERATIONAL;
pub const IF_OPER_STATUS_UNREACHABLE = INTERNAL_IF_OPER_STATUS.UNREACHABLE;
pub const IF_OPER_STATUS_DISCONNECTED = INTERNAL_IF_OPER_STATUS.DISCONNECTED;
pub const IF_OPER_STATUS_CONNECTING = INTERNAL_IF_OPER_STATUS.CONNECTING;
pub const IF_OPER_STATUS_CONNECTED = INTERNAL_IF_OPER_STATUS.CONNECTED;
pub const IF_OPER_STATUS_OPERATIONAL = INTERNAL_IF_OPER_STATUS.OPERATIONAL;

pub const MIB_NOTIFICATION_TYPE = enum(i32) {
    ParameterNotification = 0,
    AddInstance = 1,
    DeleteInstance = 2,
    InitialNotification = 3,
};
pub const MibParameterNotification = MIB_NOTIFICATION_TYPE.ParameterNotification;
pub const MibAddInstance = MIB_NOTIFICATION_TYPE.AddInstance;
pub const MibDeleteInstance = MIB_NOTIFICATION_TYPE.DeleteInstance;
pub const MibInitialNotification = MIB_NOTIFICATION_TYPE.InitialNotification;

pub const MIB_IF_ROW2 = extern struct {
    InterfaceLuid: NET_LUID_LH,
    InterfaceIndex: u32,
    InterfaceGuid: Guid,
    Alias: [257]u16,
    Description: [257]u16,
    PhysicalAddressLength: u32,
    PhysicalAddress: [32]u8,
    PermanentPhysicalAddress: [32]u8,
    Mtu: u32,
    Type: u32,
    TunnelType: TUNNEL_TYPE,
    MediaType: NDIS_MEDIUM,
    PhysicalMediumType: NDIS_PHYSICAL_MEDIUM,
    AccessType: NET_IF_ACCESS_TYPE,
    DirectionType: NET_IF_DIRECTION_TYPE,
    InterfaceAndOperStatusFlags: extern struct {
        _bitfield: u8,
    },
    OperStatus: IF_OPER_STATUS,
    AdminStatus: NET_IF_ADMIN_STATUS,
    MediaConnectState: NET_IF_MEDIA_CONNECT_STATE,
    NetworkGuid: Guid,
    ConnectionType: NET_IF_CONNECTION_TYPE,
    TransmitLinkSpeed: u64,
    ReceiveLinkSpeed: u64,
    InOctets: u64,
    InUcastPkts: u64,
    InNUcastPkts: u64,
    InDiscards: u64,
    InErrors: u64,
    InUnknownProtos: u64,
    InUcastOctets: u64,
    InMulticastOctets: u64,
    InBroadcastOctets: u64,
    OutOctets: u64,
    OutUcastPkts: u64,
    OutNUcastPkts: u64,
    OutDiscards: u64,
    OutErrors: u64,
    OutUcastOctets: u64,
    OutMulticastOctets: u64,
    OutBroadcastOctets: u64,
    OutQLen: u64,
};

pub const MIB_IF_TABLE2 = extern struct {
    NumEntries: u32,
    Table: [1]MIB_IF_ROW2,
};

pub const MIB_IF_ENTRY_LEVEL = enum(i32) {
    l = 0,
    WithoutStatistics = 2,
};
pub const MibIfEntryNormal = MIB_IF_ENTRY_LEVEL.l;
pub const MibIfEntryNormalWithoutStatistics = MIB_IF_ENTRY_LEVEL.WithoutStatistics;

pub const MIB_IF_TABLE_LEVEL = enum(i32) {
    Normal = 0,
    Raw = 1,
    NormalWithoutStatistics = 2,
};
pub const MibIfTableNormal = MIB_IF_TABLE_LEVEL.Normal;
pub const MibIfTableRaw = MIB_IF_TABLE_LEVEL.Raw;
pub const MibIfTableNormalWithoutStatistics = MIB_IF_TABLE_LEVEL.NormalWithoutStatistics;

pub const MIB_IPINTERFACE_ROW = extern struct {
    Family: u16,
    InterfaceLuid: NET_LUID_LH,
    InterfaceIndex: u32,
    MaxReassemblySize: u32,
    InterfaceIdentifier: u64,
    MinRouterAdvertisementInterval: u32,
    MaxRouterAdvertisementInterval: u32,
    AdvertisingEnabled: BOOLEAN,
    ForwardingEnabled: BOOLEAN,
    WeakHostSend: BOOLEAN,
    WeakHostReceive: BOOLEAN,
    UseAutomaticMetric: BOOLEAN,
    UseNeighborUnreachabilityDetection: BOOLEAN,
    ManagedAddressConfigurationSupported: BOOLEAN,
    OtherStatefulConfigurationSupported: BOOLEAN,
    AdvertiseDefaultRoute: BOOLEAN,
    RouterDiscoveryBehavior: NL_ROUTER_DISCOVERY_BEHAVIOR,
    DadTransmits: u32,
    BaseReachableTime: u32,
    RetransmitTime: u32,
    PathMtuDiscoveryTimeout: u32,
    LinkLocalAddressBehavior: NL_LINK_LOCAL_ADDRESS_BEHAVIOR,
    LinkLocalAddressTimeout: u32,
    ZoneIndices: [16]u32,
    SitePrefixLength: u32,
    Metric: u32,
    NlMtu: u32,
    Connected: BOOLEAN,
    SupportsWakeUpPatterns: BOOLEAN,
    SupportsNeighborDiscovery: BOOLEAN,
    SupportsRouterDiscovery: BOOLEAN,
    ReachableTime: u32,
    TransmitOffload: NL_INTERFACE_OFFLOAD_ROD,
    ReceiveOffload: NL_INTERFACE_OFFLOAD_ROD,
    DisableDefaultRoutes: BOOLEAN,
};

pub const MIB_IPINTERFACE_TABLE = extern struct {
    NumEntries: u32,
    Table: [1]MIB_IPINTERFACE_ROW,
};

pub const MIB_IFSTACK_ROW = extern struct {
    HigherLayerInterfaceIndex: u32,
    LowerLayerInterfaceIndex: u32,
};

pub const MIB_INVERTEDIFSTACK_ROW = extern struct {
    LowerLayerInterfaceIndex: u32,
    HigherLayerInterfaceIndex: u32,
};

pub const MIB_IFSTACK_TABLE = extern struct {
    NumEntries: u32,
    Table: [1]MIB_IFSTACK_ROW,
};

pub const MIB_INVERTEDIFSTACK_TABLE = extern struct {
    NumEntries: u32,
    Table: [1]MIB_INVERTEDIFSTACK_ROW,
};

pub const PIPINTERFACE_CHANGE_CALLBACK = *const fn(
    CallerContext: ?*anyopaque,
    Row: ?*MIB_IPINTERFACE_ROW,
    NotificationType: MIB_NOTIFICATION_TYPE,
) callconv(@import("std").os.windows.WINAPI) void;

pub const MIB_IP_NETWORK_CONNECTION_BANDWIDTH_ESTIMATES = extern struct {
    InboundBandwidthInformation: NL_BANDWIDTH_INFORMATION,
    OutboundBandwidthInformation: NL_BANDWIDTH_INFORMATION,
};

pub const MIB_UNICASTIPADDRESS_ROW = extern struct {
    Address: SOCKADDR_INET,
    InterfaceLuid: NET_LUID_LH,
    InterfaceIndex: u32,
    PrefixOrigin: NL_PREFIX_ORIGIN,
    SuffixOrigin: NL_SUFFIX_ORIGIN,
    ValidLifetime: u32,
    PreferredLifetime: u32,
    OnLinkPrefixLength: u8,
    SkipAsSource: BOOLEAN,
    DadState: NL_DAD_STATE,
    ScopeId: SCOPE_ID,
    CreationTimeStamp: LARGE_INTEGER,
};

pub const MIB_UNICASTIPADDRESS_TABLE = extern struct {
    NumEntries: u32,
    Table: [1]MIB_UNICASTIPADDRESS_ROW,
};

pub const PUNICAST_IPADDRESS_CHANGE_CALLBACK = *const fn(
    CallerContext: ?*anyopaque,
    Row: ?*MIB_UNICASTIPADDRESS_ROW,
    NotificationType: MIB_NOTIFICATION_TYPE,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PSTABLE_UNICAST_IPADDRESS_TABLE_CALLBACK = *const fn(
    CallerContext: ?*anyopaque,
    AddressTable: ?*MIB_UNICASTIPADDRESS_TABLE,
) callconv(@import("std").os.windows.WINAPI) void;

pub const MIB_ANYCASTIPADDRESS_ROW = extern struct {
    Address: SOCKADDR_INET,
    InterfaceLuid: NET_LUID_LH,
    InterfaceIndex: u32,
    ScopeId: SCOPE_ID,
};

pub const MIB_ANYCASTIPADDRESS_TABLE = extern struct {
    NumEntries: u32,
    Table: [1]MIB_ANYCASTIPADDRESS_ROW,
};

pub const MIB_MULTICASTIPADDRESS_ROW = extern struct {
    Address: SOCKADDR_INET,
    InterfaceIndex: u32,
    InterfaceLuid: NET_LUID_LH,
    ScopeId: SCOPE_ID,
};

pub const MIB_MULTICASTIPADDRESS_TABLE = extern struct {
    NumEntries: u32,
    Table: [1]MIB_MULTICASTIPADDRESS_ROW,
};

pub const IP_ADDRESS_PREFIX = extern struct {
    Prefix: SOCKADDR_INET,
    PrefixLength: u8,
};

pub const MIB_IPFORWARD_ROW2 = extern struct {
    InterfaceLuid: NET_LUID_LH,
    InterfaceIndex: u32,
    DestinationPrefix: IP_ADDRESS_PREFIX,
    NextHop: SOCKADDR_INET,
    SitePrefixLength: u8,
    ValidLifetime: u32,
    PreferredLifetime: u32,
    Metric: u32,
    Protocol: NL_ROUTE_PROTOCOL,
    Loopback: BOOLEAN,
    AutoconfigureAddress: BOOLEAN,
    Publish: BOOLEAN,
    Immortal: BOOLEAN,
    Age: u32,
    Origin: NL_ROUTE_ORIGIN,
};

pub const MIB_IPFORWARD_TABLE2 = extern struct {
    NumEntries: u32,
    Table: [1]MIB_IPFORWARD_ROW2,
};

pub const PIPFORWARD_CHANGE_CALLBACK = *const fn(
    CallerContext: ?*anyopaque,
    Row: ?*MIB_IPFORWARD_ROW2,
    NotificationType: MIB_NOTIFICATION_TYPE,
) callconv(@import("std").os.windows.WINAPI) void;

pub const MIB_IPPATH_ROW = extern struct {
    Source: SOCKADDR_INET,
    Destination: SOCKADDR_INET,
    InterfaceLuid: NET_LUID_LH,
    InterfaceIndex: u32,
    CurrentNextHop: SOCKADDR_INET,
    PathMtu: u32,
    RttMean: u32,
    RttDeviation: u32,
    Anonymous: extern union {
        LastReachable: u32,
        LastUnreachable: u32,
    },
    IsReachable: BOOLEAN,
    LinkTransmitSpeed: u64,
    LinkReceiveSpeed: u64,
};

pub const MIB_IPPATH_TABLE = extern struct {
    NumEntries: u32,
    Table: [1]MIB_IPPATH_ROW,
};

pub const MIB_IPNET_ROW2 = extern struct {
    Address: SOCKADDR_INET,
    InterfaceIndex: u32,
    InterfaceLuid: NET_LUID_LH,
    PhysicalAddress: [32]u8,
    PhysicalAddressLength: u32,
    State: NL_NEIGHBOR_STATE,
    Anonymous: extern union {
        Anonymous: extern struct {
            _bitfield: u8,
        },
        Flags: u8,
    },
    ReachabilityTime: extern union {
        LastReachable: u32,
        LastUnreachable: u32,
    },
};

pub const MIB_IPNET_TABLE2 = extern struct {
    NumEntries: u32,
    Table: [1]MIB_IPNET_ROW2,
};

pub const PTEREDO_PORT_CHANGE_CALLBACK = *const fn(
    CallerContext: ?*anyopaque,
    Port: u16,
    NotificationType: MIB_NOTIFICATION_TYPE,
) callconv(@import("std").os.windows.WINAPI) void;

pub const DNS_SETTINGS = extern struct {
    Version: u32,
    Flags: u64,
    Hostname: ?PWSTR,
    Domain: ?PWSTR,
    SearchList: ?PWSTR,
};

pub const DNS_SETTINGS2 = extern struct {
    Version: u32,
    Flags: u64,
    Hostname: ?PWSTR,
    Domain: ?PWSTR,
    SearchList: ?PWSTR,
    SettingFlags: u64,
};

pub const DNS_DOH_SERVER_SETTINGS = extern struct {
    Template: ?PWSTR,
    Flags: u64,
};

pub const DNS_SERVER_PROPERTY_TYPE = enum(i32) {
    InvalidProperty = 0,
    DohProperty = 1,
};
pub const DnsServerInvalidProperty = DNS_SERVER_PROPERTY_TYPE.InvalidProperty;
pub const DnsServerDohProperty = DNS_SERVER_PROPERTY_TYPE.DohProperty;

pub const DNS_SERVER_PROPERTY_TYPES = extern union {
    DohSettings: ?*DNS_DOH_SERVER_SETTINGS,
};

pub const DNS_SERVER_PROPERTY = extern struct {
    Version: u32,
    ServerIndex: u32,
    Type: DNS_SERVER_PROPERTY_TYPE,
    Property: DNS_SERVER_PROPERTY_TYPES,
};

pub const DNS_INTERFACE_SETTINGS = extern struct {
    Version: u32,
    Flags: u64,
    Domain: ?PWSTR,
    NameServer: ?PWSTR,
    SearchList: ?PWSTR,
    RegistrationEnabled: u32,
    RegisterAdapterName: u32,
    EnableLLMNR: u32,
    QueryAdapterName: u32,
    ProfileNameServer: ?PWSTR,
};

pub const DNS_INTERFACE_SETTINGS_EX = extern struct {
    SettingsV1: DNS_INTERFACE_SETTINGS,
    DisableUnconstrainedQueries: u32,
    SupplementalSearchList: ?PWSTR,
};

pub const DNS_INTERFACE_SETTINGS3 = extern struct {
    Version: u32,
    Flags: u64,
    Domain: ?PWSTR,
    NameServer: ?PWSTR,
    SearchList: ?PWSTR,
    RegistrationEnabled: u32,
    RegisterAdapterName: u32,
    EnableLLMNR: u32,
    QueryAdapterName: u32,
    ProfileNameServer: ?PWSTR,
    DisableUnconstrainedQueries: u32,
    SupplementalSearchList: ?PWSTR,
    cServerProperties: u32,
    ServerProperties: ?*DNS_SERVER_PROPERTY,
    cProfileServerProperties: u32,
    ProfileServerProperties: ?*DNS_SERVER_PROPERTY,
};

pub const PNETWORK_CONNECTIVITY_HINT_CHANGE_CALLBACK = *const fn(
    CallerContext: ?*anyopaque,
    ConnectivityHint: NL_NETWORK_CONNECTIVITY_HINT,
) callconv(@import("std").os.windows.WINAPI) void;

pub const MIB_OPAQUE_QUERY = extern struct {
    dwVarId: u32,
    rgdwVarIndex: [1]u32,
};

pub const MIB_IFNUMBER = extern struct {
    dwValue: u32,
};

pub const MIB_IFROW = extern struct {
    wszName: [256]u16,
    dwIndex: u32,
    dwType: u32,
    dwMtu: u32,
    dwSpeed: u32,
    dwPhysAddrLen: u32,
    bPhysAddr: [8]u8,
    dwAdminStatus: u32,
    dwOperStatus: INTERNAL_IF_OPER_STATUS,
    dwLastChange: u32,
    dwInOctets: u32,
    dwInUcastPkts: u32,
    dwInNUcastPkts: u32,
    dwInDiscards: u32,
    dwInErrors: u32,
    dwInUnknownProtos: u32,
    dwOutOctets: u32,
    dwOutUcastPkts: u32,
    dwOutNUcastPkts: u32,
    dwOutDiscards: u32,
    dwOutErrors: u32,
    dwOutQLen: u32,
    dwDescrLen: u32,
    bDescr: [256]u8,
};

pub const MIB_IFTABLE = extern struct {
    dwNumEntries: u32,
    table: [1]MIB_IFROW,
};

pub const MIB_IPADDRROW_XP = extern struct {
    dwAddr: u32,
    dwIndex: u32,
    dwMask: u32,
    dwBCastAddr: u32,
    dwReasmSize: u32,
    unused1: u16,
    wType: u16,
};

pub const MIB_IPADDRROW_W2K = extern struct {
    dwAddr: u32,
    dwIndex: u32,
    dwMask: u32,
    dwBCastAddr: u32,
    dwReasmSize: u32,
    unused1: u16,
    unused2: u16,
};

pub const MIB_IPADDRTABLE = extern struct {
    dwNumEntries: u32,
    table: [1]MIB_IPADDRROW_XP,
};

pub const MIB_IPFORWARDNUMBER = extern struct {
    dwValue: u32,
};

pub const MIB_IPFORWARD_TYPE = enum(i32) {
    OTHER = 1,
    INVALID = 2,
    DIRECT = 3,
    INDIRECT = 4,
};
// TODO: enum 'MIB_IPFORWARD_TYPE' has known issues with its value aliases

pub const MIB_IPFORWARDROW = extern struct {
    dwForwardDest: u32,
    dwForwardMask: u32,
    dwForwardPolicy: u32,
    dwForwardNextHop: u32,
    dwForwardIfIndex: u32,
    Anonymous1: extern union {
        dwForwardType: u32,
        ForwardType: MIB_IPFORWARD_TYPE,
    },
    Anonymous2: extern union {
        dwForwardProto: u32,
        ForwardProto: NL_ROUTE_PROTOCOL,
    },
    dwForwardAge: u32,
    dwForwardNextHopAS: u32,
    dwForwardMetric1: u32,
    dwForwardMetric2: u32,
    dwForwardMetric3: u32,
    dwForwardMetric4: u32,
    dwForwardMetric5: u32,
};

pub const MIB_IPFORWARDTABLE = extern struct {
    dwNumEntries: u32,
    table: [1]MIB_IPFORWARDROW,
};

pub const MIB_IPNET_TYPE = enum(i32) {
    OTHER = 1,
    INVALID = 2,
    DYNAMIC = 3,
    STATIC = 4,
};
pub const MIB_IPNET_TYPE_OTHER = MIB_IPNET_TYPE.OTHER;
pub const MIB_IPNET_TYPE_INVALID = MIB_IPNET_TYPE.INVALID;
pub const MIB_IPNET_TYPE_DYNAMIC = MIB_IPNET_TYPE.DYNAMIC;
pub const MIB_IPNET_TYPE_STATIC = MIB_IPNET_TYPE.STATIC;

pub const MIB_IPNETROW_LH = extern struct {
    dwIndex: u32,
    dwPhysAddrLen: u32,
    bPhysAddr: [8]u8,
    dwAddr: u32,
    Anonymous: extern union {
        dwType: u32,
        Type: MIB_IPNET_TYPE,
    },
};

pub const MIB_IPNETROW_W2K = extern struct {
    dwIndex: u32,
    dwPhysAddrLen: u32,
    bPhysAddr: [8]u8,
    dwAddr: u32,
    dwType: u32,
};

pub const MIB_IPNETTABLE = extern struct {
    dwNumEntries: u32,
    table: [1]MIB_IPNETROW_LH,
};

pub const MIB_IPSTATS_FORWARDING = enum(i32) {
    FORWARDING = 1,
    NOT_FORWARDING = 2,
};
pub const MIB_IP_FORWARDING = MIB_IPSTATS_FORWARDING.FORWARDING;
pub const MIB_IP_NOT_FORWARDING = MIB_IPSTATS_FORWARDING.NOT_FORWARDING;

pub const MIB_IPSTATS_LH = extern struct {
    Anonymous: extern union {
        dwForwarding: u32,
        Forwarding: MIB_IPSTATS_FORWARDING,
    },
    dwDefaultTTL: u32,
    dwInReceives: u32,
    dwInHdrErrors: u32,
    dwInAddrErrors: u32,
    dwForwDatagrams: u32,
    dwInUnknownProtos: u32,
    dwInDiscards: u32,
    dwInDelivers: u32,
    dwOutRequests: u32,
    dwRoutingDiscards: u32,
    dwOutDiscards: u32,
    dwOutNoRoutes: u32,
    dwReasmTimeout: u32,
    dwReasmReqds: u32,
    dwReasmOks: u32,
    dwReasmFails: u32,
    dwFragOks: u32,
    dwFragFails: u32,
    dwFragCreates: u32,
    dwNumIf: u32,
    dwNumAddr: u32,
    dwNumRoutes: u32,
};

pub const MIB_IPSTATS_W2K = extern struct {
    dwForwarding: u32,
    dwDefaultTTL: u32,
    dwInReceives: u32,
    dwInHdrErrors: u32,
    dwInAddrErrors: u32,
    dwForwDatagrams: u32,
    dwInUnknownProtos: u32,
    dwInDiscards: u32,
    dwInDelivers: u32,
    dwOutRequests: u32,
    dwRoutingDiscards: u32,
    dwOutDiscards: u32,
    dwOutNoRoutes: u32,
    dwReasmTimeout: u32,
    dwReasmReqds: u32,
    dwReasmOks: u32,
    dwReasmFails: u32,
    dwFragOks: u32,
    dwFragFails: u32,
    dwFragCreates: u32,
    dwNumIf: u32,
    dwNumAddr: u32,
    dwNumRoutes: u32,
};

pub const MIBICMPSTATS = extern struct {
    dwMsgs: u32,
    dwErrors: u32,
    dwDestUnreachs: u32,
    dwTimeExcds: u32,
    dwParmProbs: u32,
    dwSrcQuenchs: u32,
    dwRedirects: u32,
    dwEchos: u32,
    dwEchoReps: u32,
    dwTimestamps: u32,
    dwTimestampReps: u32,
    dwAddrMasks: u32,
    dwAddrMaskReps: u32,
};

pub const MIBICMPINFO = extern struct {
    icmpInStats: MIBICMPSTATS,
    icmpOutStats: MIBICMPSTATS,
};

pub const MIB_ICMP = extern struct {
    stats: MIBICMPINFO,
};

pub const MIBICMPSTATS_EX_XPSP1 = extern struct {
    dwMsgs: u32,
    dwErrors: u32,
    rgdwTypeCount: [256]u32,
};

pub const MIB_ICMP_EX_XPSP1 = extern struct {
    icmpInStats: MIBICMPSTATS_EX_XPSP1,
    icmpOutStats: MIBICMPSTATS_EX_XPSP1,
};

pub const ICMP6_TYPE = enum(i32) {
    ICMP6_DST_UNREACH = 1,
    ICMP6_PACKET_TOO_BIG = 2,
    ICMP6_TIME_EXCEEDED = 3,
    ICMP6_PARAM_PROB = 4,
    ICMP6_ECHO_REQUEST = 128,
    ICMP6_ECHO_REPLY = 129,
    ICMP6_MEMBERSHIP_QUERY = 130,
    ICMP6_MEMBERSHIP_REPORT = 131,
    ICMP6_MEMBERSHIP_REDUCTION = 132,
    ND_ROUTER_SOLICIT = 133,
    ND_ROUTER_ADVERT = 134,
    ND_NEIGHBOR_SOLICIT = 135,
    ND_NEIGHBOR_ADVERT = 136,
    ND_REDIRECT = 137,
    ICMP6_V2_MEMBERSHIP_REPORT = 143,
};
pub const ICMP6_DST_UNREACH = ICMP6_TYPE.ICMP6_DST_UNREACH;
pub const ICMP6_PACKET_TOO_BIG = ICMP6_TYPE.ICMP6_PACKET_TOO_BIG;
pub const ICMP6_TIME_EXCEEDED = ICMP6_TYPE.ICMP6_TIME_EXCEEDED;
pub const ICMP6_PARAM_PROB = ICMP6_TYPE.ICMP6_PARAM_PROB;
pub const ICMP6_ECHO_REQUEST = ICMP6_TYPE.ICMP6_ECHO_REQUEST;
pub const ICMP6_ECHO_REPLY = ICMP6_TYPE.ICMP6_ECHO_REPLY;
pub const ICMP6_MEMBERSHIP_QUERY = ICMP6_TYPE.ICMP6_MEMBERSHIP_QUERY;
pub const ICMP6_MEMBERSHIP_REPORT = ICMP6_TYPE.ICMP6_MEMBERSHIP_REPORT;
pub const ICMP6_MEMBERSHIP_REDUCTION = ICMP6_TYPE.ICMP6_MEMBERSHIP_REDUCTION;
pub const ND_ROUTER_SOLICIT = ICMP6_TYPE.ND_ROUTER_SOLICIT;
pub const ND_ROUTER_ADVERT = ICMP6_TYPE.ND_ROUTER_ADVERT;
pub const ND_NEIGHBOR_SOLICIT = ICMP6_TYPE.ND_NEIGHBOR_SOLICIT;
pub const ND_NEIGHBOR_ADVERT = ICMP6_TYPE.ND_NEIGHBOR_ADVERT;
pub const ND_REDIRECT = ICMP6_TYPE.ND_REDIRECT;
pub const ICMP6_V2_MEMBERSHIP_REPORT = ICMP6_TYPE.ICMP6_V2_MEMBERSHIP_REPORT;

pub const ICMP4_TYPE = enum(i32) {
    ECHO_REPLY = 0,
    DST_UNREACH = 3,
    SOURCE_QUENCH = 4,
    REDIRECT = 5,
    ECHO_REQUEST = 8,
    ROUTER_ADVERT = 9,
    ROUTER_SOLICIT = 10,
    TIME_EXCEEDED = 11,
    PARAM_PROB = 12,
    TIMESTAMP_REQUEST = 13,
    TIMESTAMP_REPLY = 14,
    MASK_REQUEST = 17,
    MASK_REPLY = 18,
};
pub const ICMP4_ECHO_REPLY = ICMP4_TYPE.ECHO_REPLY;
pub const ICMP4_DST_UNREACH = ICMP4_TYPE.DST_UNREACH;
pub const ICMP4_SOURCE_QUENCH = ICMP4_TYPE.SOURCE_QUENCH;
pub const ICMP4_REDIRECT = ICMP4_TYPE.REDIRECT;
pub const ICMP4_ECHO_REQUEST = ICMP4_TYPE.ECHO_REQUEST;
pub const ICMP4_ROUTER_ADVERT = ICMP4_TYPE.ROUTER_ADVERT;
pub const ICMP4_ROUTER_SOLICIT = ICMP4_TYPE.ROUTER_SOLICIT;
pub const ICMP4_TIME_EXCEEDED = ICMP4_TYPE.TIME_EXCEEDED;
pub const ICMP4_PARAM_PROB = ICMP4_TYPE.PARAM_PROB;
pub const ICMP4_TIMESTAMP_REQUEST = ICMP4_TYPE.TIMESTAMP_REQUEST;
pub const ICMP4_TIMESTAMP_REPLY = ICMP4_TYPE.TIMESTAMP_REPLY;
pub const ICMP4_MASK_REQUEST = ICMP4_TYPE.MASK_REQUEST;
pub const ICMP4_MASK_REPLY = ICMP4_TYPE.MASK_REPLY;

pub const MIB_IPMCAST_OIF_XP = extern struct {
    dwOutIfIndex: u32,
    dwNextHopAddr: u32,
    dwReserved: u32,
    dwReserved1: u32,
};

pub const MIB_IPMCAST_OIF_W2K = extern struct {
    dwOutIfIndex: u32,
    dwNextHopAddr: u32,
    pvReserved: ?*anyopaque,
    dwReserved: u32,
};

pub const MIB_IPMCAST_MFE = extern struct {
    dwGroup: u32,
    dwSource: u32,
    dwSrcMask: u32,
    dwUpStrmNgbr: u32,
    dwInIfIndex: u32,
    dwInIfProtocol: u32,
    dwRouteProtocol: u32,
    dwRouteNetwork: u32,
    dwRouteMask: u32,
    ulUpTime: u32,
    ulExpiryTime: u32,
    ulTimeOut: u32,
    ulNumOutIf: u32,
    fFlags: u32,
    dwReserved: u32,
    rgmioOutInfo: [1]MIB_IPMCAST_OIF_XP,
};

pub const MIB_MFE_TABLE = extern struct {
    dwNumEntries: u32,
    table: [1]MIB_IPMCAST_MFE,
};

pub const MIB_IPMCAST_OIF_STATS_LH = extern struct {
    dwOutIfIndex: u32,
    dwNextHopAddr: u32,
    dwDialContext: u32,
    ulTtlTooLow: u32,
    ulFragNeeded: u32,
    ulOutPackets: u32,
    ulOutDiscards: u32,
};

pub const MIB_IPMCAST_OIF_STATS_W2K = extern struct {
    dwOutIfIndex: u32,
    dwNextHopAddr: u32,
    pvDialContext: ?*anyopaque,
    ulTtlTooLow: u32,
    ulFragNeeded: u32,
    ulOutPackets: u32,
    ulOutDiscards: u32,
};

pub const MIB_IPMCAST_MFE_STATS = extern struct {
    dwGroup: u32,
    dwSource: u32,
    dwSrcMask: u32,
    dwUpStrmNgbr: u32,
    dwInIfIndex: u32,
    dwInIfProtocol: u32,
    dwRouteProtocol: u32,
    dwRouteNetwork: u32,
    dwRouteMask: u32,
    ulUpTime: u32,
    ulExpiryTime: u32,
    ulNumOutIf: u32,
    ulInPkts: u32,
    ulInOctets: u32,
    ulPktsDifferentIf: u32,
    ulQueueOverflow: u32,
    rgmiosOutStats: [1]MIB_IPMCAST_OIF_STATS_LH,
};

pub const MIB_MFE_STATS_TABLE = extern struct {
    dwNumEntries: u32,
    table: [1]MIB_IPMCAST_MFE_STATS,
};

pub const MIB_IPMCAST_MFE_STATS_EX_XP = extern struct {
    dwGroup: u32,
    dwSource: u32,
    dwSrcMask: u32,
    dwUpStrmNgbr: u32,
    dwInIfIndex: u32,
    dwInIfProtocol: u32,
    dwRouteProtocol: u32,
    dwRouteNetwork: u32,
    dwRouteMask: u32,
    ulUpTime: u32,
    ulExpiryTime: u32,
    ulNumOutIf: u32,
    ulInPkts: u32,
    ulInOctets: u32,
    ulPktsDifferentIf: u32,
    ulQueueOverflow: u32,
    ulUninitMfe: u32,
    ulNegativeMfe: u32,
    ulInDiscards: u32,
    ulInHdrErrors: u32,
    ulTotalOutPackets: u32,
    rgmiosOutStats: [1]MIB_IPMCAST_OIF_STATS_LH,
};

pub const MIB_MFE_STATS_TABLE_EX_XP = extern struct {
    dwNumEntries: u32,
    table: [1]?*MIB_IPMCAST_MFE_STATS_EX_XP,
};

pub const MIB_IPMCAST_GLOBAL = extern struct {
    dwEnable: u32,
};

pub const MIB_IPMCAST_IF_ENTRY = extern struct {
    dwIfIndex: u32,
    dwTtl: u32,
    dwProtocol: u32,
    dwRateLimit: u32,
    ulInMcastOctets: u32,
    ulOutMcastOctets: u32,
};

pub const MIB_IPMCAST_IF_TABLE = extern struct {
    dwNumEntries: u32,
    table: [1]MIB_IPMCAST_IF_ENTRY,
};

pub const MIB_TCP_STATE = enum(i32) {
    CLOSED = 1,
    LISTEN = 2,
    SYN_SENT = 3,
    SYN_RCVD = 4,
    ESTAB = 5,
    FIN_WAIT1 = 6,
    FIN_WAIT2 = 7,
    CLOSE_WAIT = 8,
    CLOSING = 9,
    LAST_ACK = 10,
    TIME_WAIT = 11,
    DELETE_TCB = 12,
    RESERVED = 100,
};
pub const MIB_TCP_STATE_CLOSED = MIB_TCP_STATE.CLOSED;
pub const MIB_TCP_STATE_LISTEN = MIB_TCP_STATE.LISTEN;
pub const MIB_TCP_STATE_SYN_SENT = MIB_TCP_STATE.SYN_SENT;
pub const MIB_TCP_STATE_SYN_RCVD = MIB_TCP_STATE.SYN_RCVD;
pub const MIB_TCP_STATE_ESTAB = MIB_TCP_STATE.ESTAB;
pub const MIB_TCP_STATE_FIN_WAIT1 = MIB_TCP_STATE.FIN_WAIT1;
pub const MIB_TCP_STATE_FIN_WAIT2 = MIB_TCP_STATE.FIN_WAIT2;
pub const MIB_TCP_STATE_CLOSE_WAIT = MIB_TCP_STATE.CLOSE_WAIT;
pub const MIB_TCP_STATE_CLOSING = MIB_TCP_STATE.CLOSING;
pub const MIB_TCP_STATE_LAST_ACK = MIB_TCP_STATE.LAST_ACK;
pub const MIB_TCP_STATE_TIME_WAIT = MIB_TCP_STATE.TIME_WAIT;
pub const MIB_TCP_STATE_DELETE_TCB = MIB_TCP_STATE.DELETE_TCB;
pub const MIB_TCP_STATE_RESERVED = MIB_TCP_STATE.RESERVED;

pub const TCP_CONNECTION_OFFLOAD_STATE = enum(i32) {
    InHost = 0,
    Offloading = 1,
    Offloaded = 2,
    Uploading = 3,
    Max = 4,
};
pub const TcpConnectionOffloadStateInHost = TCP_CONNECTION_OFFLOAD_STATE.InHost;
pub const TcpConnectionOffloadStateOffloading = TCP_CONNECTION_OFFLOAD_STATE.Offloading;
pub const TcpConnectionOffloadStateOffloaded = TCP_CONNECTION_OFFLOAD_STATE.Offloaded;
pub const TcpConnectionOffloadStateUploading = TCP_CONNECTION_OFFLOAD_STATE.Uploading;
pub const TcpConnectionOffloadStateMax = TCP_CONNECTION_OFFLOAD_STATE.Max;

pub const MIB_TCPROW_LH = extern struct {
    Anonymous: extern union {
        dwState: u32,
        State: MIB_TCP_STATE,
    },
    dwLocalAddr: u32,
    dwLocalPort: u32,
    dwRemoteAddr: u32,
    dwRemotePort: u32,
};

pub const MIB_TCPROW_W2K = extern struct {
    dwState: u32,
    dwLocalAddr: u32,
    dwLocalPort: u32,
    dwRemoteAddr: u32,
    dwRemotePort: u32,
};

pub const MIB_TCPTABLE = extern struct {
    dwNumEntries: u32,
    table: [1]MIB_TCPROW_LH,
};

pub const MIB_TCPROW2 = extern struct {
    dwState: u32,
    dwLocalAddr: u32,
    dwLocalPort: u32,
    dwRemoteAddr: u32,
    dwRemotePort: u32,
    dwOwningPid: u32,
    dwOffloadState: TCP_CONNECTION_OFFLOAD_STATE,
};

pub const MIB_TCPTABLE2 = extern struct {
    dwNumEntries: u32,
    table: [1]MIB_TCPROW2,
};

pub const MIB_TCPROW_OWNER_PID = extern struct {
    dwState: u32,
    dwLocalAddr: u32,
    dwLocalPort: u32,
    dwRemoteAddr: u32,
    dwRemotePort: u32,
    dwOwningPid: u32,
};

pub const MIB_TCPTABLE_OWNER_PID = extern struct {
    dwNumEntries: u32,
    table: [1]MIB_TCPROW_OWNER_PID,
};

pub const MIB_TCPROW_OWNER_MODULE = extern struct {
    dwState: u32,
    dwLocalAddr: u32,
    dwLocalPort: u32,
    dwRemoteAddr: u32,
    dwRemotePort: u32,
    dwOwningPid: u32,
    liCreateTimestamp: LARGE_INTEGER,
    OwningModuleInfo: [16]u64,
};

pub const MIB_TCPTABLE_OWNER_MODULE = extern struct {
    dwNumEntries: u32,
    table: [1]MIB_TCPROW_OWNER_MODULE,
};

pub const MIB_TCP6ROW = extern struct {
    State: MIB_TCP_STATE,
    LocalAddr: IN6_ADDR,
    dwLocalScopeId: u32,
    dwLocalPort: u32,
    RemoteAddr: IN6_ADDR,
    dwRemoteScopeId: u32,
    dwRemotePort: u32,
};

pub const MIB_TCP6TABLE = extern struct {
    dwNumEntries: u32,
    table: [1]MIB_TCP6ROW,
};

pub const MIB_TCP6ROW2 = extern struct {
    LocalAddr: IN6_ADDR,
    dwLocalScopeId: u32,
    dwLocalPort: u32,
    RemoteAddr: IN6_ADDR,
    dwRemoteScopeId: u32,
    dwRemotePort: u32,
    State: MIB_TCP_STATE,
    dwOwningPid: u32,
    dwOffloadState: TCP_CONNECTION_OFFLOAD_STATE,
};

pub const MIB_TCP6TABLE2 = extern struct {
    dwNumEntries: u32,
    table: [1]MIB_TCP6ROW2,
};

pub const MIB_TCP6ROW_OWNER_PID = extern struct {
    ucLocalAddr: [16]u8,
    dwLocalScopeId: u32,
    dwLocalPort: u32,
    ucRemoteAddr: [16]u8,
    dwRemoteScopeId: u32,
    dwRemotePort: u32,
    dwState: u32,
    dwOwningPid: u32,
};

pub const MIB_TCP6TABLE_OWNER_PID = extern struct {
    dwNumEntries: u32,
    table: [1]MIB_TCP6ROW_OWNER_PID,
};

pub const MIB_TCP6ROW_OWNER_MODULE = extern struct {
    ucLocalAddr: [16]u8,
    dwLocalScopeId: u32,
    dwLocalPort: u32,
    ucRemoteAddr: [16]u8,
    dwRemoteScopeId: u32,
    dwRemotePort: u32,
    dwState: u32,
    dwOwningPid: u32,
    liCreateTimestamp: LARGE_INTEGER,
    OwningModuleInfo: [16]u64,
};

pub const MIB_TCP6TABLE_OWNER_MODULE = extern struct {
    dwNumEntries: u32,
    table: [1]MIB_TCP6ROW_OWNER_MODULE,
};

pub const TCP_RTO_ALGORITHM = enum(i32) {
    TcpRtoAlgorithmOther = 1,
    TcpRtoAlgorithmConstant = 2,
    TcpRtoAlgorithmRsre = 3,
    TcpRtoAlgorithmVanj = 4,
    pub const MIB_TCP_RTO_OTHER = .TcpRtoAlgorithmOther;
    pub const MIB_TCP_RTO_CONSTANT = .TcpRtoAlgorithmConstant;
    pub const MIB_TCP_RTO_RSRE = .TcpRtoAlgorithmRsre;
    pub const MIB_TCP_RTO_VANJ = .TcpRtoAlgorithmVanj;
};
pub const TcpRtoAlgorithmOther = TCP_RTO_ALGORITHM.TcpRtoAlgorithmOther;
pub const TcpRtoAlgorithmConstant = TCP_RTO_ALGORITHM.TcpRtoAlgorithmConstant;
pub const TcpRtoAlgorithmRsre = TCP_RTO_ALGORITHM.TcpRtoAlgorithmRsre;
pub const TcpRtoAlgorithmVanj = TCP_RTO_ALGORITHM.TcpRtoAlgorithmVanj;
pub const MIB_TCP_RTO_OTHER = TCP_RTO_ALGORITHM.TcpRtoAlgorithmOther;
pub const MIB_TCP_RTO_CONSTANT = TCP_RTO_ALGORITHM.TcpRtoAlgorithmConstant;
pub const MIB_TCP_RTO_RSRE = TCP_RTO_ALGORITHM.TcpRtoAlgorithmRsre;
pub const MIB_TCP_RTO_VANJ = TCP_RTO_ALGORITHM.TcpRtoAlgorithmVanj;

pub const MIB_TCPSTATS_LH = extern struct {
    Anonymous: extern union {
        dwRtoAlgorithm: u32,
        RtoAlgorithm: TCP_RTO_ALGORITHM,
    },
    dwRtoMin: u32,
    dwRtoMax: u32,
    dwMaxConn: u32,
    dwActiveOpens: u32,
    dwPassiveOpens: u32,
    dwAttemptFails: u32,
    dwEstabResets: u32,
    dwCurrEstab: u32,
    dwInSegs: u32,
    dwOutSegs: u32,
    dwRetransSegs: u32,
    dwInErrs: u32,
    dwOutRsts: u32,
    dwNumConns: u32,
};

pub const MIB_TCPSTATS_W2K = extern struct {
    dwRtoAlgorithm: u32,
    dwRtoMin: u32,
    dwRtoMax: u32,
    dwMaxConn: u32,
    dwActiveOpens: u32,
    dwPassiveOpens: u32,
    dwAttemptFails: u32,
    dwEstabResets: u32,
    dwCurrEstab: u32,
    dwInSegs: u32,
    dwOutSegs: u32,
    dwRetransSegs: u32,
    dwInErrs: u32,
    dwOutRsts: u32,
    dwNumConns: u32,
};

pub const MIB_TCPSTATS2 = extern struct {
    RtoAlgorithm: TCP_RTO_ALGORITHM,
    dwRtoMin: u32,
    dwRtoMax: u32,
    dwMaxConn: u32,
    dwActiveOpens: u32,
    dwPassiveOpens: u32,
    dwAttemptFails: u32,
    dwEstabResets: u32,
    dwCurrEstab: u32,
    dw64InSegs: u64,
    dw64OutSegs: u64,
    dwRetransSegs: u32,
    dwInErrs: u32,
    dwOutRsts: u32,
    dwNumConns: u32,
};

pub const MIB_UDPROW = extern struct {
    dwLocalAddr: u32,
    dwLocalPort: u32,
};

pub const MIB_UDPTABLE = extern struct {
    dwNumEntries: u32,
    table: [1]MIB_UDPROW,
};

pub const MIB_UDPROW_OWNER_PID = extern struct {
    dwLocalAddr: u32,
    dwLocalPort: u32,
    dwOwningPid: u32,
};

pub const MIB_UDPTABLE_OWNER_PID = extern struct {
    dwNumEntries: u32,
    table: [1]MIB_UDPROW_OWNER_PID,
};

pub const MIB_UDPROW_OWNER_MODULE = extern struct {
    dwLocalAddr: u32,
    dwLocalPort: u32,
    dwOwningPid: u32,
    liCreateTimestamp: LARGE_INTEGER,
    Anonymous: extern union {
        Anonymous: extern struct {
            _bitfield: i32,
        },
        dwFlags: i32,
    },
    OwningModuleInfo: [16]u64,
};

pub const MIB_UDPTABLE_OWNER_MODULE = extern struct {
    dwNumEntries: u32,
    table: [1]MIB_UDPROW_OWNER_MODULE,
};

pub const MIB_UDPROW2 = extern struct {
    dwLocalAddr: u32,
    dwLocalPort: u32,
    dwOwningPid: u32,
    liCreateTimestamp: LARGE_INTEGER,
    Anonymous: extern union {
        Anonymous: extern struct {
            _bitfield: i32,
        },
        dwFlags: i32,
    },
    OwningModuleInfo: [16]u64,
    dwRemoteAddr: u32,
    dwRemotePort: u32,
};

pub const MIB_UDPTABLE2 = extern struct {
    dwNumEntries: u32,
    table: [1]MIB_UDPROW2,
};

pub const MIB_UDP6ROW = extern struct {
    dwLocalAddr: IN6_ADDR,
    dwLocalScopeId: u32,
    dwLocalPort: u32,
};

pub const MIB_UDP6TABLE = extern struct {
    dwNumEntries: u32,
    table: [1]MIB_UDP6ROW,
};

pub const MIB_UDP6ROW_OWNER_PID = extern struct {
    ucLocalAddr: [16]u8,
    dwLocalScopeId: u32,
    dwLocalPort: u32,
    dwOwningPid: u32,
};

pub const MIB_UDP6TABLE_OWNER_PID = extern struct {
    dwNumEntries: u32,
    table: [1]MIB_UDP6ROW_OWNER_PID,
};

pub const MIB_UDP6ROW_OWNER_MODULE = extern struct {
    ucLocalAddr: [16]u8,
    dwLocalScopeId: u32,
    dwLocalPort: u32,
    dwOwningPid: u32,
    liCreateTimestamp: LARGE_INTEGER,
    Anonymous: extern union {
        Anonymous: extern struct {
            _bitfield: i32,
        },
        dwFlags: i32,
    },
    OwningModuleInfo: [16]u64,
};

pub const MIB_UDP6TABLE_OWNER_MODULE = extern struct {
    dwNumEntries: u32,
    table: [1]MIB_UDP6ROW_OWNER_MODULE,
};

pub const MIB_UDP6ROW2 = extern struct {
    ucLocalAddr: [16]u8,
    dwLocalScopeId: u32,
    dwLocalPort: u32,
    dwOwningPid: u32,
    liCreateTimestamp: LARGE_INTEGER,
    Anonymous: extern union {
        Anonymous: extern struct {
            _bitfield: i32,
        },
        dwFlags: i32,
    },
    OwningModuleInfo: [16]u64,
    ucRemoteAddr: [16]u8,
    dwRemoteScopeId: u32,
    dwRemotePort: u32,
};

pub const MIB_UDP6TABLE2 = extern struct {
    dwNumEntries: u32,
    table: [1]MIB_UDP6ROW2,
};

pub const MIB_UDPSTATS = extern struct {
    dwInDatagrams: u32,
    dwNoPorts: u32,
    dwInErrors: u32,
    dwOutDatagrams: u32,
    dwNumAddrs: u32,
};

pub const MIB_UDPSTATS2 = extern struct {
    dw64InDatagrams: u64,
    dwNoPorts: u32,
    dwInErrors: u32,
    dw64OutDatagrams: u64,
    dwNumAddrs: u32,
};

pub const TCP_TABLE_CLASS = enum(i32) {
    BASIC_LISTENER = 0,
    BASIC_CONNECTIONS = 1,
    BASIC_ALL = 2,
    OWNER_PID_LISTENER = 3,
    OWNER_PID_CONNECTIONS = 4,
    OWNER_PID_ALL = 5,
    OWNER_MODULE_LISTENER = 6,
    OWNER_MODULE_CONNECTIONS = 7,
    OWNER_MODULE_ALL = 8,
};
pub const TCP_TABLE_BASIC_LISTENER = TCP_TABLE_CLASS.BASIC_LISTENER;
pub const TCP_TABLE_BASIC_CONNECTIONS = TCP_TABLE_CLASS.BASIC_CONNECTIONS;
pub const TCP_TABLE_BASIC_ALL = TCP_TABLE_CLASS.BASIC_ALL;
pub const TCP_TABLE_OWNER_PID_LISTENER = TCP_TABLE_CLASS.OWNER_PID_LISTENER;
pub const TCP_TABLE_OWNER_PID_CONNECTIONS = TCP_TABLE_CLASS.OWNER_PID_CONNECTIONS;
pub const TCP_TABLE_OWNER_PID_ALL = TCP_TABLE_CLASS.OWNER_PID_ALL;
pub const TCP_TABLE_OWNER_MODULE_LISTENER = TCP_TABLE_CLASS.OWNER_MODULE_LISTENER;
pub const TCP_TABLE_OWNER_MODULE_CONNECTIONS = TCP_TABLE_CLASS.OWNER_MODULE_CONNECTIONS;
pub const TCP_TABLE_OWNER_MODULE_ALL = TCP_TABLE_CLASS.OWNER_MODULE_ALL;

pub const UDP_TABLE_CLASS = enum(i32) {
    BASIC = 0,
    OWNER_PID = 1,
    OWNER_MODULE = 2,
};
pub const UDP_TABLE_BASIC = UDP_TABLE_CLASS.BASIC;
pub const UDP_TABLE_OWNER_PID = UDP_TABLE_CLASS.OWNER_PID;
pub const UDP_TABLE_OWNER_MODULE = UDP_TABLE_CLASS.OWNER_MODULE;

pub const TCPIP_OWNER_MODULE_INFO_CLASS = enum(i32) {
    C = 0,
};
pub const TCPIP_OWNER_MODULE_INFO_BASIC = TCPIP_OWNER_MODULE_INFO_CLASS.C;

pub const TCPIP_OWNER_MODULE_BASIC_INFO = extern struct {
    pModuleName: ?[*]u16,
    pModulePath: ?[*]u16,
};

pub const MIB_IPMCAST_BOUNDARY = extern struct {
    dwIfIndex: u32,
    dwGroupAddress: u32,
    dwGroupMask: u32,
    dwStatus: u32,
};

pub const MIB_IPMCAST_BOUNDARY_TABLE = extern struct {
    dwNumEntries: u32,
    table: [1]MIB_IPMCAST_BOUNDARY,
};

pub const MIB_BOUNDARYROW = extern struct {
    dwGroupAddress: u32,
    dwGroupMask: u32,
};

pub const MIB_MCAST_LIMIT_ROW = extern struct {
    dwTtl: u32,
    dwRateLimit: u32,
};

pub const MIB_IPMCAST_SCOPE = extern struct {
    dwGroupAddress: u32,
    dwGroupMask: u32,
    snNameBuffer: [256]u16,
    dwStatus: u32,
};

pub const MIB_IPDESTROW = extern struct {
    ForwardRow: MIB_IPFORWARDROW,
    dwForwardPreference: u32,
    dwForwardViewSet: u32,
};

pub const MIB_IPDESTTABLE = extern struct {
    dwNumEntries: u32,
    table: [1]MIB_IPDESTROW,
};

pub const MIB_BEST_IF = extern struct {
    dwDestAddr: u32,
    dwIfIndex: u32,
};

pub const MIB_PROXYARP = extern struct {
    dwAddress: u32,
    dwMask: u32,
    dwIfIndex: u32,
};

pub const MIB_IFSTATUS = extern struct {
    dwIfIndex: u32,
    dwAdminStatus: u32,
    dwOperationalStatus: u32,
    bMHbeatActive: BOOL,
    bMHbeatAlive: BOOL,
};

pub const MIB_ROUTESTATE = extern struct {
    bRoutesSetToStack: BOOL,
};

pub const MIB_OPAQUE_INFO = extern struct {
    dwId: u32,
    Anonymous: extern union {
        ullAlign: u64,
        rgbyData: [1]u8,
    },
};

pub const IP_ADDRESS_STRING = extern struct {
    String: [16]CHAR,
};

pub const IP_ADDR_STRING = extern struct {
    Next: ?*IP_ADDR_STRING,
    IpAddress: IP_ADDRESS_STRING,
    IpMask: IP_ADDRESS_STRING,
    Context: u32,
};

pub const IP_ADAPTER_INFO = extern struct {
    Next: ?*IP_ADAPTER_INFO,
    ComboIndex: u32,
    AdapterName: [260]CHAR,
    Description: [132]CHAR,
    AddressLength: u32,
    Address: [8]u8,
    Index: u32,
    Type: u32,
    DhcpEnabled: u32,
    CurrentIpAddress: ?*IP_ADDR_STRING,
    IpAddressList: IP_ADDR_STRING,
    GatewayList: IP_ADDR_STRING,
    DhcpServer: IP_ADDR_STRING,
    HaveWins: BOOL,
    PrimaryWinsServer: IP_ADDR_STRING,
    SecondaryWinsServer: IP_ADDR_STRING,
    LeaseObtained: i64,
    LeaseExpires: i64,
};

pub const IP_ADAPTER_UNICAST_ADDRESS_LH = extern struct {
    Anonymous: extern union {
        Alignment: u64,
        Anonymous: extern struct {
            Length: u32,
            Flags: u32,
        },
    },
    Next: ?*IP_ADAPTER_UNICAST_ADDRESS_LH,
    Address: SOCKET_ADDRESS,
    PrefixOrigin: NL_PREFIX_ORIGIN,
    SuffixOrigin: NL_SUFFIX_ORIGIN,
    DadState: NL_DAD_STATE,
    ValidLifetime: u32,
    PreferredLifetime: u32,
    LeaseLifetime: u32,
    OnLinkPrefixLength: u8,
};

pub const IP_ADAPTER_UNICAST_ADDRESS_XP = extern struct {
    Anonymous: extern union {
        Alignment: u64,
        Anonymous: extern struct {
            Length: u32,
            Flags: u32,
        },
    },
    Next: ?*IP_ADAPTER_UNICAST_ADDRESS_XP,
    Address: SOCKET_ADDRESS,
    PrefixOrigin: NL_PREFIX_ORIGIN,
    SuffixOrigin: NL_SUFFIX_ORIGIN,
    DadState: NL_DAD_STATE,
    ValidLifetime: u32,
    PreferredLifetime: u32,
    LeaseLifetime: u32,
};

pub const IP_ADAPTER_ANYCAST_ADDRESS_XP = extern struct {
    Anonymous: extern union {
        Alignment: u64,
        Anonymous: extern struct {
            Length: u32,
            Flags: u32,
        },
    },
    Next: ?*IP_ADAPTER_ANYCAST_ADDRESS_XP,
    Address: SOCKET_ADDRESS,
};

pub const IP_ADAPTER_MULTICAST_ADDRESS_XP = extern struct {
    Anonymous: extern union {
        Alignment: u64,
        Anonymous: extern struct {
            Length: u32,
            Flags: u32,
        },
    },
    Next: ?*IP_ADAPTER_MULTICAST_ADDRESS_XP,
    Address: SOCKET_ADDRESS,
};

pub const IP_ADAPTER_DNS_SERVER_ADDRESS_XP = extern struct {
    Anonymous: extern union {
        Alignment: u64,
        Anonymous: extern struct {
            Length: u32,
            Reserved: u32,
        },
    },
    Next: ?*IP_ADAPTER_DNS_SERVER_ADDRESS_XP,
    Address: SOCKET_ADDRESS,
};

pub const IP_ADAPTER_WINS_SERVER_ADDRESS_LH = extern struct {
    Anonymous: extern union {
        Alignment: u64,
        Anonymous: extern struct {
            Length: u32,
            Reserved: u32,
        },
    },
    Next: ?*IP_ADAPTER_WINS_SERVER_ADDRESS_LH,
    Address: SOCKET_ADDRESS,
};

pub const IP_ADAPTER_GATEWAY_ADDRESS_LH = extern struct {
    Anonymous: extern union {
        Alignment: u64,
        Anonymous: extern struct {
            Length: u32,
            Reserved: u32,
        },
    },
    Next: ?*IP_ADAPTER_GATEWAY_ADDRESS_LH,
    Address: SOCKET_ADDRESS,
};

pub const IP_ADAPTER_PREFIX_XP = extern struct {
    Anonymous: extern union {
        Alignment: u64,
        Anonymous: extern struct {
            Length: u32,
            Flags: u32,
        },
    },
    Next: ?*IP_ADAPTER_PREFIX_XP,
    Address: SOCKET_ADDRESS,
    PrefixLength: u32,
};

pub const IP_ADAPTER_DNS_SUFFIX = extern struct {
    Next: ?*IP_ADAPTER_DNS_SUFFIX,
    String: [256]u16,
};

pub const IP_ADAPTER_ADDRESSES_LH = extern struct {
    Anonymous1: extern union {
        Alignment: u64,
        Anonymous: extern struct {
            Length: u32,
            IfIndex: u32,
        },
    },
    Next: ?*IP_ADAPTER_ADDRESSES_LH,
    AdapterName: ?[*]u8,
    FirstUnicastAddress: ?*IP_ADAPTER_UNICAST_ADDRESS_LH,
    FirstAnycastAddress: ?*IP_ADAPTER_ANYCAST_ADDRESS_XP,
    FirstMulticastAddress: ?*IP_ADAPTER_MULTICAST_ADDRESS_XP,
    FirstDnsServerAddress: ?*IP_ADAPTER_DNS_SERVER_ADDRESS_XP,
    DnsSuffix: ?[*]u16,
    Description: ?[*]u16,
    FriendlyName: ?[*]u16,
    PhysicalAddress: [8]u8,
    PhysicalAddressLength: u32,
    Anonymous2: extern union {
        Flags: u32,
        Anonymous: extern struct {
            _bitfield: u32,
        },
    },
    Mtu: u32,
    IfType: u32,
    OperStatus: IF_OPER_STATUS,
    Ipv6IfIndex: u32,
    ZoneIndices: [16]u32,
    FirstPrefix: ?*IP_ADAPTER_PREFIX_XP,
    TransmitLinkSpeed: u64,
    ReceiveLinkSpeed: u64,
    FirstWinsServerAddress: ?*IP_ADAPTER_WINS_SERVER_ADDRESS_LH,
    FirstGatewayAddress: ?*IP_ADAPTER_GATEWAY_ADDRESS_LH,
    Ipv4Metric: u32,
    Ipv6Metric: u32,
    Luid: NET_LUID_LH,
    Dhcpv4Server: SOCKET_ADDRESS,
    CompartmentId: u32,
    NetworkGuid: Guid,
    ConnectionType: NET_IF_CONNECTION_TYPE,
    TunnelType: TUNNEL_TYPE,
    Dhcpv6Server: SOCKET_ADDRESS,
    Dhcpv6ClientDuid: [130]u8,
    Dhcpv6ClientDuidLength: u32,
    Dhcpv6Iaid: u32,
    FirstDnsSuffix: ?*IP_ADAPTER_DNS_SUFFIX,
};

pub const IP_ADAPTER_ADDRESSES_XP = extern struct {
    Anonymous: extern union {
        Alignment: u64,
        Anonymous: extern struct {
            Length: u32,
            IfIndex: u32,
        },
    },
    Next: ?*IP_ADAPTER_ADDRESSES_XP,
    AdapterName: ?[*]u8,
    FirstUnicastAddress: ?*IP_ADAPTER_UNICAST_ADDRESS_XP,
    FirstAnycastAddress: ?*IP_ADAPTER_ANYCAST_ADDRESS_XP,
    FirstMulticastAddress: ?*IP_ADAPTER_MULTICAST_ADDRESS_XP,
    FirstDnsServerAddress: ?*IP_ADAPTER_DNS_SERVER_ADDRESS_XP,
    DnsSuffix: ?[*]u16,
    Description: ?[*]u16,
    FriendlyName: ?[*]u16,
    PhysicalAddress: [8]u8,
    PhysicalAddressLength: u32,
    Flags: u32,
    Mtu: u32,
    IfType: u32,
    OperStatus: IF_OPER_STATUS,
    Ipv6IfIndex: u32,
    ZoneIndices: [16]u32,
    FirstPrefix: ?*IP_ADAPTER_PREFIX_XP,
};

pub const IP_PER_ADAPTER_INFO_W2KSP1 = extern struct {
    AutoconfigEnabled: u32,
    AutoconfigActive: u32,
    CurrentDnsServer: ?*IP_ADDR_STRING,
    DnsServerList: IP_ADDR_STRING,
};

pub const FIXED_INFO_W2KSP1 = extern struct {
    HostName: [132]CHAR,
    DomainName: [132]CHAR,
    CurrentDnsServer: ?*IP_ADDR_STRING,
    DnsServerList: IP_ADDR_STRING,
    NodeType: u32,
    ScopeId: [260]CHAR,
    EnableRouting: u32,
    EnableProxy: u32,
    EnableDns: u32,
};

pub const ip_interface_name_info_w2ksp1 = extern struct {
    Index: u32,
    MediaType: u32,
    ConnectionType: u8,
    AccessType: u8,
    DeviceGuid: Guid,
    InterfaceGuid: Guid,
};

pub const TCP_ESTATS_TYPE = enum(i32) {
    SynOpts = 0,
    Data = 1,
    SndCong = 2,
    Path = 3,
    SendBuff = 4,
    Rec = 5,
    ObsRec = 6,
    Bandwidth = 7,
    FineRtt = 8,
    Maximum = 9,
};
pub const TcpConnectionEstatsSynOpts = TCP_ESTATS_TYPE.SynOpts;
pub const TcpConnectionEstatsData = TCP_ESTATS_TYPE.Data;
pub const TcpConnectionEstatsSndCong = TCP_ESTATS_TYPE.SndCong;
pub const TcpConnectionEstatsPath = TCP_ESTATS_TYPE.Path;
pub const TcpConnectionEstatsSendBuff = TCP_ESTATS_TYPE.SendBuff;
pub const TcpConnectionEstatsRec = TCP_ESTATS_TYPE.Rec;
pub const TcpConnectionEstatsObsRec = TCP_ESTATS_TYPE.ObsRec;
pub const TcpConnectionEstatsBandwidth = TCP_ESTATS_TYPE.Bandwidth;
pub const TcpConnectionEstatsFineRtt = TCP_ESTATS_TYPE.FineRtt;
pub const TcpConnectionEstatsMaximum = TCP_ESTATS_TYPE.Maximum;

pub const TCP_BOOLEAN_OPTIONAL = enum(i32) {
    Disabled = 0,
    Enabled = 1,
    Unchanged = -1,
};
pub const TcpBoolOptDisabled = TCP_BOOLEAN_OPTIONAL.Disabled;
pub const TcpBoolOptEnabled = TCP_BOOLEAN_OPTIONAL.Enabled;
pub const TcpBoolOptUnchanged = TCP_BOOLEAN_OPTIONAL.Unchanged;

pub const TCP_ESTATS_SYN_OPTS_ROS_v0 = extern struct {
    ActiveOpen: BOOLEAN,
    MssRcvd: u32,
    MssSent: u32,
};

pub const TCP_SOFT_ERROR = enum(i32) {
    None = 0,
    BelowDataWindow = 1,
    AboveDataWindow = 2,
    BelowAckWindow = 3,
    AboveAckWindow = 4,
    BelowTsWindow = 5,
    AboveTsWindow = 6,
    DataChecksumError = 7,
    DataLengthError = 8,
    MaxSoftError = 9,
};
pub const TcpErrorNone = TCP_SOFT_ERROR.None;
pub const TcpErrorBelowDataWindow = TCP_SOFT_ERROR.BelowDataWindow;
pub const TcpErrorAboveDataWindow = TCP_SOFT_ERROR.AboveDataWindow;
pub const TcpErrorBelowAckWindow = TCP_SOFT_ERROR.BelowAckWindow;
pub const TcpErrorAboveAckWindow = TCP_SOFT_ERROR.AboveAckWindow;
pub const TcpErrorBelowTsWindow = TCP_SOFT_ERROR.BelowTsWindow;
pub const TcpErrorAboveTsWindow = TCP_SOFT_ERROR.AboveTsWindow;
pub const TcpErrorDataChecksumError = TCP_SOFT_ERROR.DataChecksumError;
pub const TcpErrorDataLengthError = TCP_SOFT_ERROR.DataLengthError;
pub const TcpErrorMaxSoftError = TCP_SOFT_ERROR.MaxSoftError;

pub const TCP_ESTATS_DATA_ROD_v0 = extern struct {
    DataBytesOut: u64,
    DataSegsOut: u64,
    DataBytesIn: u64,
    DataSegsIn: u64,
    SegsOut: u64,
    SegsIn: u64,
    SoftErrors: u32,
    SoftErrorReason: u32,
    SndUna: u32,
    SndNxt: u32,
    SndMax: u32,
    ThruBytesAcked: u64,
    RcvNxt: u32,
    ThruBytesReceived: u64,
};

pub const TCP_ESTATS_DATA_RW_v0 = extern struct {
    EnableCollection: BOOLEAN,
};

pub const TCP_ESTATS_SND_CONG_ROD_v0 = extern struct {
    SndLimTransRwin: u32,
    SndLimTimeRwin: u32,
    SndLimBytesRwin: usize,
    SndLimTransCwnd: u32,
    SndLimTimeCwnd: u32,
    SndLimBytesCwnd: usize,
    SndLimTransSnd: u32,
    SndLimTimeSnd: u32,
    SndLimBytesSnd: usize,
    SlowStart: u32,
    CongAvoid: u32,
    OtherReductions: u32,
    CurCwnd: u32,
    MaxSsCwnd: u32,
    MaxCaCwnd: u32,
    CurSsthresh: u32,
    MaxSsthresh: u32,
    MinSsthresh: u32,
};

pub const TCP_ESTATS_SND_CONG_ROS_v0 = extern struct {
    LimCwnd: u32,
};

pub const TCP_ESTATS_SND_CONG_RW_v0 = extern struct {
    EnableCollection: BOOLEAN,
};

pub const TCP_ESTATS_PATH_ROD_v0 = extern struct {
    FastRetran: u32,
    Timeouts: u32,
    SubsequentTimeouts: u32,
    CurTimeoutCount: u32,
    AbruptTimeouts: u32,
    PktsRetrans: u32,
    BytesRetrans: u32,
    DupAcksIn: u32,
    SacksRcvd: u32,
    SackBlocksRcvd: u32,
    CongSignals: u32,
    PreCongSumCwnd: u32,
    PreCongSumRtt: u32,
    PostCongSumRtt: u32,
    PostCongCountRtt: u32,
    EcnSignals: u32,
    EceRcvd: u32,
    SendStall: u32,
    QuenchRcvd: u32,
    RetranThresh: u32,
    SndDupAckEpisodes: u32,
    SumBytesReordered: u32,
    NonRecovDa: u32,
    NonRecovDaEpisodes: u32,
    AckAfterFr: u32,
    DsackDups: u32,
    SampleRtt: u32,
    SmoothedRtt: u32,
    RttVar: u32,
    MaxRtt: u32,
    MinRtt: u32,
    SumRtt: u32,
    CountRtt: u32,
    CurRto: u32,
    MaxRto: u32,
    MinRto: u32,
    CurMss: u32,
    MaxMss: u32,
    MinMss: u32,
    SpuriousRtoDetections: u32,
};

pub const TCP_ESTATS_PATH_RW_v0 = extern struct {
    EnableCollection: BOOLEAN,
};

pub const TCP_ESTATS_SEND_BUFF_ROD_v0 = extern struct {
    CurRetxQueue: usize,
    MaxRetxQueue: usize,
    CurAppWQueue: usize,
    MaxAppWQueue: usize,
};

pub const TCP_ESTATS_SEND_BUFF_RW_v0 = extern struct {
    EnableCollection: BOOLEAN,
};

pub const TCP_ESTATS_REC_ROD_v0 = extern struct {
    CurRwinSent: u32,
    MaxRwinSent: u32,
    MinRwinSent: u32,
    LimRwin: u32,
    DupAckEpisodes: u32,
    DupAcksOut: u32,
    CeRcvd: u32,
    EcnSent: u32,
    EcnNoncesRcvd: u32,
    CurReasmQueue: u32,
    MaxReasmQueue: u32,
    CurAppRQueue: usize,
    MaxAppRQueue: usize,
    WinScaleSent: u8,
};

pub const TCP_ESTATS_REC_RW_v0 = extern struct {
    EnableCollection: BOOLEAN,
};

pub const TCP_ESTATS_OBS_REC_ROD_v0 = extern struct {
    CurRwinRcvd: u32,
    MaxRwinRcvd: u32,
    MinRwinRcvd: u32,
    WinScaleRcvd: u8,
};

pub const TCP_ESTATS_OBS_REC_RW_v0 = extern struct {
    EnableCollection: BOOLEAN,
};

pub const TCP_ESTATS_BANDWIDTH_RW_v0 = extern struct {
    EnableCollectionOutbound: TCP_BOOLEAN_OPTIONAL,
    EnableCollectionInbound: TCP_BOOLEAN_OPTIONAL,
};

pub const TCP_ESTATS_BANDWIDTH_ROD_v0 = extern struct {
    OutboundBandwidth: u64,
    InboundBandwidth: u64,
    OutboundInstability: u64,
    InboundInstability: u64,
    OutboundBandwidthPeaked: BOOLEAN,
    InboundBandwidthPeaked: BOOLEAN,
};

pub const TCP_ESTATS_FINE_RTT_RW_v0 = extern struct {
    EnableCollection: BOOLEAN,
};

pub const TCP_ESTATS_FINE_RTT_ROD_v0 = extern struct {
    RttVar: u32,
    MaxRtt: u32,
    MinRtt: u32,
    SumRtt: u32,
};

pub const INTERFACE_HARDWARE_TIMESTAMP_CAPABILITIES = extern struct {
    PtpV2OverUdpIPv4EventMessageReceive: BOOLEAN,
    PtpV2OverUdpIPv4AllMessageReceive: BOOLEAN,
    PtpV2OverUdpIPv4EventMessageTransmit: BOOLEAN,
    PtpV2OverUdpIPv4AllMessageTransmit: BOOLEAN,
    PtpV2OverUdpIPv6EventMessageReceive: BOOLEAN,
    PtpV2OverUdpIPv6AllMessageReceive: BOOLEAN,
    PtpV2OverUdpIPv6EventMessageTransmit: BOOLEAN,
    PtpV2OverUdpIPv6AllMessageTransmit: BOOLEAN,
    AllReceive: BOOLEAN,
    AllTransmit: BOOLEAN,
    TaggedTransmit: BOOLEAN,
};

pub const INTERFACE_SOFTWARE_TIMESTAMP_CAPABILITIES = extern struct {
    AllReceive: BOOLEAN,
    AllTransmit: BOOLEAN,
    TaggedTransmit: BOOLEAN,
};

pub const INTERFACE_TIMESTAMP_CAPABILITIES = extern struct {
    HardwareClockFrequencyHz: u64,
    SupportsCrossTimestamp: BOOLEAN,
    HardwareCapabilities: INTERFACE_HARDWARE_TIMESTAMP_CAPABILITIES,
    SoftwareCapabilities: INTERFACE_SOFTWARE_TIMESTAMP_CAPABILITIES,
};

pub const INTERFACE_HARDWARE_CROSSTIMESTAMP = extern struct {
    SystemTimestamp1: u64,
    HardwareClockTimestamp: u64,
    SystemTimestamp2: u64,
};

pub const PINTERFACE_TIMESTAMP_CONFIG_CHANGE_CALLBACK = *const fn(
    CallerContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

pub const NET_ADDRESS_FORMAT = enum(i32) {
    FORMAT_UNSPECIFIED = 0,
    DNS_NAME = 1,
    IPV4 = 2,
    IPV6 = 3,
};
pub const NET_ADDRESS_FORMAT_UNSPECIFIED = NET_ADDRESS_FORMAT.FORMAT_UNSPECIFIED;
pub const NET_ADDRESS_DNS_NAME = NET_ADDRESS_FORMAT.DNS_NAME;
pub const NET_ADDRESS_IPV4 = NET_ADDRESS_FORMAT.IPV4;
pub const NET_ADDRESS_IPV6 = NET_ADDRESS_FORMAT.IPV6;

pub const GLOBAL_FILTER = enum(i32) {
    FRAGMENTS = 2,
    STRONGHOST = 8,
    FRAGCACHE = 9,
};
pub const GF_FRAGMENTS = GLOBAL_FILTER.FRAGMENTS;
pub const GF_STRONGHOST = GLOBAL_FILTER.STRONGHOST;
pub const GF_FRAGCACHE = GLOBAL_FILTER.FRAGCACHE;

pub const PFFORWARD_ACTION = enum(i32) {
    FORWARD = 0,
    DROP = 1,
};
pub const PF_ACTION_FORWARD = PFFORWARD_ACTION.FORWARD;
pub const PF_ACTION_DROP = PFFORWARD_ACTION.DROP;

pub const PFADDRESSTYPE = enum(i32) {
    @"4" = 0,
    @"6" = 1,
};
pub const PF_IPV4 = PFADDRESSTYPE.@"4";
pub const PF_IPV6 = PFADDRESSTYPE.@"6";

pub const PF_FILTER_DESCRIPTOR = extern struct {
    dwFilterFlags: u32,
    dwRule: u32,
    pfatType: PFADDRESSTYPE,
    SrcAddr: ?*u8,
    SrcMask: ?*u8,
    DstAddr: ?*u8,
    DstMask: ?*u8,
    dwProtocol: u32,
    fLateBound: u32,
    wSrcPort: u16,
    wDstPort: u16,
    wSrcPortHighRange: u16,
    wDstPortHighRange: u16,
};

pub const PF_FILTER_STATS = extern struct {
    dwNumPacketsFiltered: u32,
    info: PF_FILTER_DESCRIPTOR,
};

pub const PF_INTERFACE_STATS = extern struct {
    pvDriverContext: ?*anyopaque,
    dwFlags: u32,
    dwInDrops: u32,
    dwOutDrops: u32,
    eaInAction: PFFORWARD_ACTION,
    eaOutAction: PFFORWARD_ACTION,
    dwNumInFilters: u32,
    dwNumOutFilters: u32,
    dwFrag: u32,
    dwSpoof: u32,
    dwReserved1: u32,
    dwReserved2: u32,
    liSYN: LARGE_INTEGER,
    liTotalLogged: LARGE_INTEGER,
    dwLostLogEntries: u32,
    FilterInfo: [1]PF_FILTER_STATS,
};

pub const PF_LATEBIND_INFO = extern struct {
    SrcAddr: ?*u8,
    DstAddr: ?*u8,
    Mask: ?*u8,
};

pub const PFFRAMETYPE = enum(i32) {
    FILTER = 1,
    FRAG = 2,
    SPOOF = 3,
};
pub const PFFT_FILTER = PFFRAMETYPE.FILTER;
pub const PFFT_FRAG = PFFRAMETYPE.FRAG;
pub const PFFT_SPOOF = PFFRAMETYPE.SPOOF;

pub const PFLOGFRAME = extern struct {
    Timestamp: LARGE_INTEGER,
    pfeTypeOfFrame: PFFRAMETYPE,
    dwTotalSizeUsed: u32,
    dwFilterRule: u32,
    wSizeOfAdditionalData: u16,
    wSizeOfIpHeader: u16,
    dwInterfaceName: u32,
    dwIPIndex: u32,
    bPacketData: [1]u8,
};

pub const ip_option_information32 = switch(@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        Ttl: u8,
        Tos: u8,
        Flags: u8,
        OptionsSize: u8,
        OptionsData: ?*u8,
    },
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
pub const icmp_echo_reply32 = switch(@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        Address: u32,
        Status: u32,
        RoundTripTime: u32,
        DataSize: u16,
        Reserved: u16,
        Data: ?*anyopaque,
        Options: ip_option_information32,
    },
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};

//--------------------------------------------------------------------------------
// Section: Functions (196)
//--------------------------------------------------------------------------------
// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "iphlpapi" fn GetIfEntry2(
    Row: ?*MIB_IF_ROW2,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows10.0.15063'
pub extern "iphlpapi" fn GetIfEntry2Ex(
    Level: MIB_IF_ENTRY_LEVEL,
    Row: ?*MIB_IF_ROW2,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "iphlpapi" fn GetIfTable2(
    Table: ?*?*MIB_IF_TABLE2,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "iphlpapi" fn GetIfTable2Ex(
    Level: MIB_IF_TABLE_LEVEL,
    Table: ?*?*MIB_IF_TABLE2,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "iphlpapi" fn GetIfStackTable(
    Table: ?*?*MIB_IFSTACK_TABLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "iphlpapi" fn GetInvertedIfStackTable(
    Table: ?*?*MIB_INVERTEDIFSTACK_TABLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "iphlpapi" fn GetIpInterfaceEntry(
    Row: ?*MIB_IPINTERFACE_ROW,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "iphlpapi" fn GetIpInterfaceTable(
    Family: u16,
    Table: ?*?*MIB_IPINTERFACE_TABLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "iphlpapi" fn InitializeIpInterfaceEntry(
    Row: ?*MIB_IPINTERFACE_ROW,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "iphlpapi" fn NotifyIpInterfaceChange(
    Family: u16,
    Callback: ?PIPINTERFACE_CHANGE_CALLBACK,
    CallerContext: ?*anyopaque,
    InitialNotification: BOOLEAN,
    NotificationHandle: ?*?HANDLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "iphlpapi" fn SetIpInterfaceEntry(
    Row: ?*MIB_IPINTERFACE_ROW,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows8.0'
pub extern "iphlpapi" fn GetIpNetworkConnectionBandwidthEstimates(
    InterfaceIndex: u32,
    AddressFamily: u16,
    BandwidthEstimates: ?*MIB_IP_NETWORK_CONNECTION_BANDWIDTH_ESTIMATES,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "iphlpapi" fn CreateUnicastIpAddressEntry(
    Row: ?*const MIB_UNICASTIPADDRESS_ROW,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "iphlpapi" fn DeleteUnicastIpAddressEntry(
    Row: ?*const MIB_UNICASTIPADDRESS_ROW,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "iphlpapi" fn GetUnicastIpAddressEntry(
    Row: ?*MIB_UNICASTIPADDRESS_ROW,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "iphlpapi" fn GetUnicastIpAddressTable(
    Family: u16,
    Table: ?*?*MIB_UNICASTIPADDRESS_TABLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "iphlpapi" fn InitializeUnicastIpAddressEntry(
    Row: ?*MIB_UNICASTIPADDRESS_ROW,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "iphlpapi" fn NotifyUnicastIpAddressChange(
    Family: u16,
    Callback: ?PUNICAST_IPADDRESS_CHANGE_CALLBACK,
    CallerContext: ?*anyopaque,
    InitialNotification: BOOLEAN,
    NotificationHandle: ?*?HANDLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "iphlpapi" fn NotifyStableUnicastIpAddressTable(
    Family: u16,
    Table: ?*?*MIB_UNICASTIPADDRESS_TABLE,
    CallerCallback: ?PSTABLE_UNICAST_IPADDRESS_TABLE_CALLBACK,
    CallerContext: ?*anyopaque,
    NotificationHandle: ?*?HANDLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "iphlpapi" fn SetUnicastIpAddressEntry(
    Row: ?*const MIB_UNICASTIPADDRESS_ROW,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "iphlpapi" fn CreateAnycastIpAddressEntry(
    Row: ?*const MIB_ANYCASTIPADDRESS_ROW,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "iphlpapi" fn DeleteAnycastIpAddressEntry(
    Row: ?*const MIB_ANYCASTIPADDRESS_ROW,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "iphlpapi" fn GetAnycastIpAddressEntry(
    Row: ?*MIB_ANYCASTIPADDRESS_ROW,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "iphlpapi" fn GetAnycastIpAddressTable(
    Family: u16,
    Table: ?*?*MIB_ANYCASTIPADDRESS_TABLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "iphlpapi" fn GetMulticastIpAddressEntry(
    Row: ?*MIB_MULTICASTIPADDRESS_ROW,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "iphlpapi" fn GetMulticastIpAddressTable(
    Family: u16,
    Table: ?*?*MIB_MULTICASTIPADDRESS_TABLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "iphlpapi" fn CreateIpForwardEntry2(
    Row: ?*const MIB_IPFORWARD_ROW2,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "iphlpapi" fn DeleteIpForwardEntry2(
    Row: ?*const MIB_IPFORWARD_ROW2,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "iphlpapi" fn GetBestRoute2(
    InterfaceLuid: ?*NET_LUID_LH,
    InterfaceIndex: u32,
    SourceAddress: ?*const SOCKADDR_INET,
    DestinationAddress: ?*const SOCKADDR_INET,
    AddressSortOptions: u32,
    BestRoute: ?*MIB_IPFORWARD_ROW2,
    BestSourceAddress: ?*SOCKADDR_INET,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "iphlpapi" fn GetIpForwardEntry2(
    Row: ?*MIB_IPFORWARD_ROW2,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "iphlpapi" fn GetIpForwardTable2(
    Family: u16,
    Table: ?*?*MIB_IPFORWARD_TABLE2,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "iphlpapi" fn InitializeIpForwardEntry(
    Row: ?*MIB_IPFORWARD_ROW2,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "iphlpapi" fn NotifyRouteChange2(
    AddressFamily: u16,
    Callback: ?PIPFORWARD_CHANGE_CALLBACK,
    CallerContext: ?*anyopaque,
    InitialNotification: BOOLEAN,
    NotificationHandle: ?*?HANDLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "iphlpapi" fn SetIpForwardEntry2(
    Route: ?*const MIB_IPFORWARD_ROW2,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "iphlpapi" fn FlushIpPathTable(
    Family: u16,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "iphlpapi" fn GetIpPathEntry(
    Row: ?*MIB_IPPATH_ROW,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "iphlpapi" fn GetIpPathTable(
    Family: u16,
    Table: ?*?*MIB_IPPATH_TABLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "iphlpapi" fn CreateIpNetEntry2(
    Row: ?*const MIB_IPNET_ROW2,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "iphlpapi" fn DeleteIpNetEntry2(
    Row: ?*const MIB_IPNET_ROW2,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "iphlpapi" fn FlushIpNetTable2(
    Family: u16,
    InterfaceIndex: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "iphlpapi" fn GetIpNetEntry2(
    Row: ?*MIB_IPNET_ROW2,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "iphlpapi" fn GetIpNetTable2(
    Family: u16,
    Table: ?*?*MIB_IPNET_TABLE2,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "iphlpapi" fn ResolveIpNetEntry2(
    Row: ?*MIB_IPNET_ROW2,
    SourceAddress: ?*const SOCKADDR_INET,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "iphlpapi" fn SetIpNetEntry2(
    Row: ?*MIB_IPNET_ROW2,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "iphlpapi" fn NotifyTeredoPortChange(
    Callback: ?PTEREDO_PORT_CHANGE_CALLBACK,
    CallerContext: ?*anyopaque,
    InitialNotification: BOOLEAN,
    NotificationHandle: ?*?HANDLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "iphlpapi" fn GetTeredoPort(
    Port: ?*u16,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "iphlpapi" fn CancelMibChangeNotify2(
    NotificationHandle: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "iphlpapi" fn FreeMibTable(
    Memory: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "iphlpapi" fn CreateSortedAddressPairs(
    SourceAddressList: ?*const SOCKADDR_IN6,
    SourceAddressCount: u32,
    DestinationAddressList: ?*const SOCKADDR_IN6,
    DestinationAddressCount: u32,
    AddressSortOptions: u32,
    SortedAddressPairList: ?*?*SOCKADDR_IN6_PAIR,
    SortedAddressPairCount: ?*u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "iphlpapi" fn ConvertCompartmentGuidToId(
    CompartmentGuid: ?*const Guid,
    CompartmentId: ?*u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "iphlpapi" fn ConvertCompartmentIdToGuid(
    CompartmentId: u32,
    CompartmentGuid: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "iphlpapi" fn ConvertInterfaceNameToLuidA(
    InterfaceName: ?[*:0]const u8,
    InterfaceLuid: ?*NET_LUID_LH,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "iphlpapi" fn ConvertInterfaceNameToLuidW(
    InterfaceName: ?[*:0]const u16,
    InterfaceLuid: ?*NET_LUID_LH,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "iphlpapi" fn ConvertInterfaceLuidToNameA(
    InterfaceLuid: ?*const NET_LUID_LH,
    InterfaceName: [*:0]u8,
    Length: usize,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "iphlpapi" fn ConvertInterfaceLuidToNameW(
    InterfaceLuid: ?*const NET_LUID_LH,
    InterfaceName: [*:0]u16,
    Length: usize,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "iphlpapi" fn ConvertInterfaceLuidToIndex(
    InterfaceLuid: ?*const NET_LUID_LH,
    InterfaceIndex: ?*u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "iphlpapi" fn ConvertInterfaceIndexToLuid(
    InterfaceIndex: u32,
    InterfaceLuid: ?*NET_LUID_LH,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "iphlpapi" fn ConvertInterfaceLuidToAlias(
    InterfaceLuid: ?*const NET_LUID_LH,
    InterfaceAlias: [*:0]u16,
    Length: usize,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "iphlpapi" fn ConvertInterfaceAliasToLuid(
    InterfaceAlias: ?[*:0]const u16,
    InterfaceLuid: ?*NET_LUID_LH,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "iphlpapi" fn ConvertInterfaceLuidToGuid(
    InterfaceLuid: ?*const NET_LUID_LH,
    InterfaceGuid: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "iphlpapi" fn ConvertInterfaceGuidToLuid(
    InterfaceGuid: ?*const Guid,
    InterfaceLuid: ?*NET_LUID_LH,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "iphlpapi" fn if_nametoindex(
    InterfaceName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "iphlpapi" fn if_indextoname(
    InterfaceIndex: u32,
    InterfaceName: *[256]u8,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "iphlpapi" fn GetCurrentThreadCompartmentId(
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "iphlpapi" fn SetCurrentThreadCompartmentId(
    CompartmentId: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "iphlpapi" fn GetCurrentThreadCompartmentScope(
    CompartmentScope: ?*u32,
    CompartmentId: ?*u32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "iphlpapi" fn SetCurrentThreadCompartmentScope(
    CompartmentScope: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "iphlpapi" fn GetJobCompartmentId(
    JobHandle: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "iphlpapi" fn SetJobCompartmentId(
    JobHandle: ?HANDLE,
    CompartmentId: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "iphlpapi" fn GetSessionCompartmentId(
    SessionId: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "iphlpapi" fn SetSessionCompartmentId(
    SessionId: u32,
    CompartmentId: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "iphlpapi" fn GetDefaultCompartmentId(
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "iphlpapi" fn GetNetworkInformation(
    NetworkGuid: ?*const Guid,
    CompartmentId: ?*u32,
    SiteId: ?*u32,
    NetworkName: [*]u16,
    Length: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "iphlpapi" fn SetNetworkInformation(
    NetworkGuid: ?*const Guid,
    CompartmentId: u32,
    NetworkName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "iphlpapi" fn ConvertLengthToIpv4Mask(
    MaskLength: u32,
    Mask: ?*u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "iphlpapi" fn ConvertIpv4MaskToLength(
    Mask: u32,
    MaskLength: ?*u8,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "iphlpapi" fn GetDnsSettings(
    Settings: ?*DNS_SETTINGS,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "iphlpapi" fn FreeDnsSettings(
    Settings: ?*DNS_SETTINGS,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "iphlpapi" fn SetDnsSettings(
    Settings: ?*const DNS_SETTINGS,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "iphlpapi" fn GetInterfaceDnsSettings(
    Interface: Guid,
    Settings: ?*DNS_INTERFACE_SETTINGS,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "iphlpapi" fn FreeInterfaceDnsSettings(
    Settings: ?*DNS_INTERFACE_SETTINGS,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "iphlpapi" fn SetInterfaceDnsSettings(
    Interface: Guid,
    Settings: ?*const DNS_INTERFACE_SETTINGS,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows10.0.19041'
pub extern "iphlpapi" fn GetNetworkConnectivityHint(
    ConnectivityHint: ?*NL_NETWORK_CONNECTIVITY_HINT,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows10.0.19041'
pub extern "iphlpapi" fn GetNetworkConnectivityHintForInterface(
    InterfaceIndex: u32,
    ConnectivityHint: ?*NL_NETWORK_CONNECTIVITY_HINT,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows10.0.19041'
pub extern "iphlpapi" fn NotifyNetworkConnectivityHintChange(
    Callback: ?PNETWORK_CONNECTIVITY_HINT_CHANGE_CALLBACK,
    CallerContext: ?*anyopaque,
    InitialNotification: BOOLEAN,
    NotificationHandle: ?*?HANDLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "iphlpapi" fn IcmpCreateFile(
) callconv(@import("std").os.windows.WINAPI) IcmpHandle;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "iphlpapi" fn Icmp6CreateFile(
) callconv(@import("std").os.windows.WINAPI) IcmpHandle;

// TODO: this type is limited to platform 'windows5.0'
pub extern "iphlpapi" fn IcmpCloseHandle(
    IcmpHandle: IcmpHandle,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "iphlpapi" fn IcmpSendEcho(
    IcmpHandle: IcmpHandle,
    DestinationAddress: u32,
    // TODO: what to do with BytesParamIndex 3?
    RequestData: ?*anyopaque,
    RequestSize: u16,
    RequestOptions: ?*ip_option_information,
    // TODO: what to do with BytesParamIndex 6?
    ReplyBuffer: ?*anyopaque,
    ReplySize: u32,
    Timeout: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "iphlpapi" fn IcmpSendEcho2(
    IcmpHandle: IcmpHandle,
    Event: ?HANDLE,
    ApcRoutine: ?PIO_APC_ROUTINE,
    ApcContext: ?*anyopaque,
    DestinationAddress: u32,
    // TODO: what to do with BytesParamIndex 6?
    RequestData: ?*anyopaque,
    RequestSize: u16,
    RequestOptions: ?*ip_option_information,
    // TODO: what to do with BytesParamIndex 9?
    ReplyBuffer: ?*anyopaque,
    ReplySize: u32,
    Timeout: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "iphlpapi" fn IcmpSendEcho2Ex(
    IcmpHandle: IcmpHandle,
    Event: ?HANDLE,
    ApcRoutine: ?PIO_APC_ROUTINE,
    ApcContext: ?*anyopaque,
    SourceAddress: u32,
    DestinationAddress: u32,
    // TODO: what to do with BytesParamIndex 7?
    RequestData: ?*anyopaque,
    RequestSize: u16,
    RequestOptions: ?*ip_option_information,
    // TODO: what to do with BytesParamIndex 10?
    ReplyBuffer: ?*anyopaque,
    ReplySize: u32,
    Timeout: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "iphlpapi" fn Icmp6SendEcho2(
    IcmpHandle: IcmpHandle,
    Event: ?HANDLE,
    ApcRoutine: ?PIO_APC_ROUTINE,
    ApcContext: ?*anyopaque,
    SourceAddress: ?*SOCKADDR_IN6,
    DestinationAddress: ?*SOCKADDR_IN6,
    // TODO: what to do with BytesParamIndex 7?
    RequestData: ?*anyopaque,
    RequestSize: u16,
    RequestOptions: ?*ip_option_information,
    // TODO: what to do with BytesParamIndex 10?
    ReplyBuffer: ?*anyopaque,
    ReplySize: u32,
    Timeout: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "iphlpapi" fn IcmpParseReplies(
    // TODO: what to do with BytesParamIndex 1?
    ReplyBuffer: ?*anyopaque,
    ReplySize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "iphlpapi" fn Icmp6ParseReplies(
    // TODO: what to do with BytesParamIndex 1?
    ReplyBuffer: ?*anyopaque,
    ReplySize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "iphlpapi" fn GetNumberOfInterfaces(
    pdwNumIf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "iphlpapi" fn GetIfEntry(
    pIfRow: ?*MIB_IFROW,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "iphlpapi" fn GetIfTable(
    // TODO: what to do with BytesParamIndex 1?
    pIfTable: ?*MIB_IFTABLE,
    pdwSize: ?*u32,
    bOrder: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "iphlpapi" fn GetIpAddrTable(
    // TODO: what to do with BytesParamIndex 1?
    pIpAddrTable: ?*MIB_IPADDRTABLE,
    pdwSize: ?*u32,
    bOrder: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "iphlpapi" fn GetIpNetTable(
    // TODO: what to do with BytesParamIndex 1?
    IpNetTable: ?*MIB_IPNETTABLE,
    SizePointer: ?*u32,
    Order: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "iphlpapi" fn GetIpForwardTable(
    // TODO: what to do with BytesParamIndex 1?
    pIpForwardTable: ?*MIB_IPFORWARDTABLE,
    pdwSize: ?*u32,
    bOrder: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "iphlpapi" fn GetTcpTable(
    // TODO: what to do with BytesParamIndex 1?
    TcpTable: ?*MIB_TCPTABLE,
    SizePointer: ?*u32,
    Order: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "iphlpapi" fn GetExtendedTcpTable(
    // TODO: what to do with BytesParamIndex 1?
    pTcpTable: ?*anyopaque,
    pdwSize: ?*u32,
    bOrder: BOOL,
    ulAf: u32,
    TableClass: TCP_TABLE_CLASS,
    Reserved: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "iphlpapi" fn GetOwnerModuleFromTcpEntry(
    pTcpEntry: ?*MIB_TCPROW_OWNER_MODULE,
    Class: TCPIP_OWNER_MODULE_INFO_CLASS,
    // TODO: what to do with BytesParamIndex 3?
    pBuffer: ?*anyopaque,
    pdwSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "iphlpapi" fn GetUdpTable(
    // TODO: what to do with BytesParamIndex 1?
    UdpTable: ?*MIB_UDPTABLE,
    SizePointer: ?*u32,
    Order: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "iphlpapi" fn GetExtendedUdpTable(
    // TODO: what to do with BytesParamIndex 1?
    pUdpTable: ?*anyopaque,
    pdwSize: ?*u32,
    bOrder: BOOL,
    ulAf: u32,
    TableClass: UDP_TABLE_CLASS,
    Reserved: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "iphlpapi" fn GetOwnerModuleFromUdpEntry(
    pUdpEntry: ?*MIB_UDPROW_OWNER_MODULE,
    Class: TCPIP_OWNER_MODULE_INFO_CLASS,
    // TODO: what to do with BytesParamIndex 3?
    pBuffer: ?*anyopaque,
    pdwSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "iphlpapi" fn GetTcpTable2(
    // TODO: what to do with BytesParamIndex 1?
    TcpTable: ?*MIB_TCPTABLE2,
    SizePointer: ?*u32,
    Order: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "iphlpapi" fn GetTcp6Table(
    // TODO: what to do with BytesParamIndex 1?
    TcpTable: ?*MIB_TCP6TABLE,
    SizePointer: ?*u32,
    Order: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "iphlpapi" fn GetTcp6Table2(
    // TODO: what to do with BytesParamIndex 1?
    TcpTable: ?*MIB_TCP6TABLE2,
    SizePointer: ?*u32,
    Order: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "iphlpapi" fn GetPerTcpConnectionEStats(
    Row: ?*MIB_TCPROW_LH,
    EstatsType: TCP_ESTATS_TYPE,
    // TODO: what to do with BytesParamIndex 4?
    Rw: ?*u8,
    RwVersion: u32,
    RwSize: u32,
    // TODO: what to do with BytesParamIndex 7?
    Ros: ?*u8,
    RosVersion: u32,
    RosSize: u32,
    // TODO: what to do with BytesParamIndex 10?
    Rod: ?*u8,
    RodVersion: u32,
    RodSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "iphlpapi" fn SetPerTcpConnectionEStats(
    Row: ?*MIB_TCPROW_LH,
    EstatsType: TCP_ESTATS_TYPE,
    // TODO: what to do with BytesParamIndex 4?
    Rw: ?*u8,
    RwVersion: u32,
    RwSize: u32,
    Offset: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "iphlpapi" fn GetPerTcp6ConnectionEStats(
    Row: ?*MIB_TCP6ROW,
    EstatsType: TCP_ESTATS_TYPE,
    // TODO: what to do with BytesParamIndex 4?
    Rw: ?*u8,
    RwVersion: u32,
    RwSize: u32,
    // TODO: what to do with BytesParamIndex 7?
    Ros: ?*u8,
    RosVersion: u32,
    RosSize: u32,
    // TODO: what to do with BytesParamIndex 10?
    Rod: ?*u8,
    RodVersion: u32,
    RodSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "iphlpapi" fn SetPerTcp6ConnectionEStats(
    Row: ?*MIB_TCP6ROW,
    EstatsType: TCP_ESTATS_TYPE,
    // TODO: what to do with BytesParamIndex 4?
    Rw: ?*u8,
    RwVersion: u32,
    RwSize: u32,
    Offset: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "iphlpapi" fn GetOwnerModuleFromTcp6Entry(
    pTcpEntry: ?*MIB_TCP6ROW_OWNER_MODULE,
    Class: TCPIP_OWNER_MODULE_INFO_CLASS,
    // TODO: what to do with BytesParamIndex 3?
    pBuffer: ?*anyopaque,
    pdwSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "iphlpapi" fn GetUdp6Table(
    // TODO: what to do with BytesParamIndex 1?
    Udp6Table: ?*MIB_UDP6TABLE,
    SizePointer: ?*u32,
    Order: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "iphlpapi" fn GetOwnerModuleFromUdp6Entry(
    pUdpEntry: ?*MIB_UDP6ROW_OWNER_MODULE,
    Class: TCPIP_OWNER_MODULE_INFO_CLASS,
    // TODO: what to do with BytesParamIndex 3?
    pBuffer: ?*anyopaque,
    pdwSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "iphlpapi" fn GetOwnerModuleFromPidAndInfo(
    ulPid: u32,
    pInfo: ?*u64,
    Class: TCPIP_OWNER_MODULE_INFO_CLASS,
    // TODO: what to do with BytesParamIndex 4?
    pBuffer: ?*anyopaque,
    pdwSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "iphlpapi" fn GetIpStatistics(
    Statistics: ?*MIB_IPSTATS_LH,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "iphlpapi" fn GetIcmpStatistics(
    Statistics: ?*MIB_ICMP,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "iphlpapi" fn GetTcpStatistics(
    Statistics: ?*MIB_TCPSTATS_LH,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "iphlpapi" fn GetUdpStatistics(
    Stats: ?*MIB_UDPSTATS,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "iphlpapi" fn SetIpStatisticsEx(
    Statistics: ?*MIB_IPSTATS_LH,
    Family: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "iphlpapi" fn GetIpStatisticsEx(
    Statistics: ?*MIB_IPSTATS_LH,
    Family: ADDRESS_FAMILY,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "iphlpapi" fn GetIcmpStatisticsEx(
    Statistics: ?*MIB_ICMP_EX_XPSP1,
    Family: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "iphlpapi" fn GetTcpStatisticsEx(
    Statistics: ?*MIB_TCPSTATS_LH,
    Family: ADDRESS_FAMILY,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "iphlpapi" fn GetUdpStatisticsEx(
    Statistics: ?*MIB_UDPSTATS,
    Family: ADDRESS_FAMILY,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows10.0.16299'
pub extern "iphlpapi" fn GetTcpStatisticsEx2(
    Statistics: ?*MIB_TCPSTATS2,
    Family: ADDRESS_FAMILY,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows10.0.16299'
pub extern "iphlpapi" fn GetUdpStatisticsEx2(
    Statistics: ?*MIB_UDPSTATS2,
    Family: ADDRESS_FAMILY,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "iphlpapi" fn SetIfEntry(
    pIfRow: ?*MIB_IFROW,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "iphlpapi" fn CreateIpForwardEntry(
    pRoute: ?*MIB_IPFORWARDROW,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "iphlpapi" fn SetIpForwardEntry(
    pRoute: ?*MIB_IPFORWARDROW,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "iphlpapi" fn DeleteIpForwardEntry(
    pRoute: ?*MIB_IPFORWARDROW,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "iphlpapi" fn SetIpStatistics(
    pIpStats: ?*MIB_IPSTATS_LH,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "iphlpapi" fn SetIpTTL(
    nTTL: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "iphlpapi" fn CreateIpNetEntry(
    pArpEntry: ?*MIB_IPNETROW_LH,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "iphlpapi" fn SetIpNetEntry(
    pArpEntry: ?*MIB_IPNETROW_LH,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "iphlpapi" fn DeleteIpNetEntry(
    pArpEntry: ?*MIB_IPNETROW_LH,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "iphlpapi" fn FlushIpNetTable(
    dwIfIndex: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "iphlpapi" fn CreateProxyArpEntry(
    dwAddress: u32,
    dwMask: u32,
    dwIfIndex: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "iphlpapi" fn DeleteProxyArpEntry(
    dwAddress: u32,
    dwMask: u32,
    dwIfIndex: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "iphlpapi" fn SetTcpEntry(
    pTcpRow: ?*MIB_TCPROW_LH,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "iphlpapi" fn GetInterfaceInfo(
    // TODO: what to do with BytesParamIndex 1?
    pIfTable: ?*IP_INTERFACE_INFO,
    dwOutBufLen: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "iphlpapi" fn GetUniDirectionalAdapterInfo(
    // TODO: what to do with BytesParamIndex 1?
    pIPIfInfo: ?*IP_UNIDIRECTIONAL_ADAPTER_ADDRESS,
    dwOutBufLen: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "iphlpapi" fn NhpAllocateAndGetInterfaceInfoFromStack(
    ppTable: ?*?*ip_interface_name_info_w2ksp1,
    pdwCount: ?*u32,
    bOrder: BOOL,
    hHeap: ?HANDLE,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "iphlpapi" fn GetBestInterface(
    dwDestAddr: u32,
    pdwBestIfIndex: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "iphlpapi" fn GetBestInterfaceEx(
    pDestAddr: ?*SOCKADDR,
    pdwBestIfIndex: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "iphlpapi" fn GetBestRoute(
    dwDestAddr: u32,
    dwSourceAddr: u32,
    pBestRoute: ?*MIB_IPFORWARDROW,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "iphlpapi" fn NotifyAddrChange(
    Handle: ?*?HANDLE,
    overlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "iphlpapi" fn NotifyRouteChange(
    Handle: ?*?HANDLE,
    overlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "iphlpapi" fn CancelIPChangeNotify(
    notifyOverlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "iphlpapi" fn GetAdapterIndex(
    AdapterName: ?PWSTR,
    IfIndex: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "iphlpapi" fn AddIPAddress(
    Address: u32,
    IpMask: u32,
    IfIndex: u32,
    NTEContext: ?*u32,
    NTEInstance: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "iphlpapi" fn DeleteIPAddress(
    NTEContext: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "iphlpapi" fn GetNetworkParams(
    // TODO: what to do with BytesParamIndex 1?
    pFixedInfo: ?*FIXED_INFO_W2KSP1,
    pOutBufLen: ?*u32,
) callconv(@import("std").os.windows.WINAPI) WIN32_ERROR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "iphlpapi" fn GetAdaptersInfo(
    // TODO: what to do with BytesParamIndex 1?
    AdapterInfo: ?*IP_ADAPTER_INFO,
    SizePointer: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "iphlpapi" fn GetAdapterOrderMap(
) callconv(@import("std").os.windows.WINAPI) ?*IP_ADAPTER_ORDER_MAP;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "iphlpapi" fn GetAdaptersAddresses(
    Family: ADDRESS_FAMILY,
    Flags: GET_ADAPTERS_ADDRESSES_FLAGS,
    Reserved: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 4?
    AdapterAddresses: ?*IP_ADAPTER_ADDRESSES_LH,
    SizePointer: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "iphlpapi" fn GetPerAdapterInfo(
    IfIndex: u32,
    // TODO: what to do with BytesParamIndex 2?
    pPerAdapterInfo: ?*IP_PER_ADAPTER_INFO_W2KSP1,
    pOutBufLen: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "iphlpapi" fn GetInterfaceActiveTimestampCapabilities(
    InterfaceLuid: ?*const NET_LUID_LH,
    TimestampCapabilites: ?*INTERFACE_TIMESTAMP_CAPABILITIES,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "iphlpapi" fn GetInterfaceSupportedTimestampCapabilities(
    InterfaceLuid: ?*const NET_LUID_LH,
    TimestampCapabilites: ?*INTERFACE_TIMESTAMP_CAPABILITIES,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "iphlpapi" fn CaptureInterfaceHardwareCrossTimestamp(
    InterfaceLuid: ?*const NET_LUID_LH,
    CrossTimestamp: ?*INTERFACE_HARDWARE_CROSSTIMESTAMP,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "iphlpapi" fn RegisterInterfaceTimestampConfigChange(
    Callback: ?PINTERFACE_TIMESTAMP_CONFIG_CHANGE_CALLBACK,
    CallerContext: ?*anyopaque,
    NotificationHandle: ?*?HIFTIMESTAMPCHANGE,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "iphlpapi" fn UnregisterInterfaceTimestampConfigChange(
    NotificationHandle: ?HIFTIMESTAMPCHANGE,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "iphlpapi" fn IpReleaseAddress(
    AdapterInfo: ?*IP_ADAPTER_INDEX_MAP,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "iphlpapi" fn IpRenewAddress(
    AdapterInfo: ?*IP_ADAPTER_INDEX_MAP,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "iphlpapi" fn SendARP(
    DestIP: u32,
    SrcIP: u32,
    // TODO: what to do with BytesParamIndex 3?
    pMacAddr: ?*anyopaque,
    PhyAddrLen: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "iphlpapi" fn GetRTTAndHopCount(
    DestIpAddress: u32,
    HopCount: ?*u32,
    MaxHops: u32,
    RTT: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "iphlpapi" fn GetFriendlyIfIndex(
    IfIndex: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "iphlpapi" fn EnableRouter(
    pHandle: ?*?HANDLE,
    pOverlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "iphlpapi" fn UnenableRouter(
    pOverlapped: ?*OVERLAPPED,
    lpdwEnableCount: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "iphlpapi" fn DisableMediaSense(
    pHandle: ?*?HANDLE,
    pOverLapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "iphlpapi" fn RestoreMediaSense(
    pOverlapped: ?*OVERLAPPED,
    lpdwEnableCount: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "iphlpapi" fn GetIpErrorString(
    ErrorCode: u32,
    Buffer: ?PWSTR,
    Size: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "iphlpapi" fn ResolveNeighbor(
    NetworkAddress: ?*SOCKADDR,
    // TODO: what to do with BytesParamIndex 2?
    PhysicalAddress: ?*anyopaque,
    PhysicalAddressLength: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "iphlpapi" fn CreatePersistentTcpPortReservation(
    StartPort: u16,
    NumberOfPorts: u16,
    Token: ?*u64,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "iphlpapi" fn CreatePersistentUdpPortReservation(
    StartPort: u16,
    NumberOfPorts: u16,
    Token: ?*u64,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "iphlpapi" fn DeletePersistentTcpPortReservation(
    StartPort: u16,
    NumberOfPorts: u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "iphlpapi" fn DeletePersistentUdpPortReservation(
    StartPort: u16,
    NumberOfPorts: u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "iphlpapi" fn LookupPersistentTcpPortReservation(
    StartPort: u16,
    NumberOfPorts: u16,
    Token: ?*u64,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "iphlpapi" fn LookupPersistentUdpPortReservation(
    StartPort: u16,
    NumberOfPorts: u16,
    Token: ?*u64,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "iphlpapi" fn PfCreateInterface(
    dwName: u32,
    inAction: PFFORWARD_ACTION,
    outAction: PFFORWARD_ACTION,
    bUseLog: BOOL,
    bMustBeUnique: BOOL,
    ppInterface: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "iphlpapi" fn PfDeleteInterface(
    pInterface: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "iphlpapi" fn PfAddFiltersToInterface(
    ih: ?*anyopaque,
    cInFilters: u32,
    pfiltIn: ?*PF_FILTER_DESCRIPTOR,
    cOutFilters: u32,
    pfiltOut: ?*PF_FILTER_DESCRIPTOR,
    pfHandle: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "iphlpapi" fn PfRemoveFiltersFromInterface(
    ih: ?*anyopaque,
    cInFilters: u32,
    pfiltIn: ?*PF_FILTER_DESCRIPTOR,
    cOutFilters: u32,
    pfiltOut: ?*PF_FILTER_DESCRIPTOR,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "iphlpapi" fn PfRemoveFilterHandles(
    pInterface: ?*anyopaque,
    cFilters: u32,
    pvHandles: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "iphlpapi" fn PfUnBindInterface(
    pInterface: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "iphlpapi" fn PfBindInterfaceToIndex(
    pInterface: ?*anyopaque,
    dwIndex: u32,
    pfatLinkType: PFADDRESSTYPE,
    LinkIPAddress: ?*u8,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "iphlpapi" fn PfBindInterfaceToIPAddress(
    pInterface: ?*anyopaque,
    pfatType: PFADDRESSTYPE,
    IPAddress: ?*u8,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "iphlpapi" fn PfRebindFilters(
    pInterface: ?*anyopaque,
    pLateBindInfo: ?*PF_LATEBIND_INFO,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "iphlpapi" fn PfAddGlobalFilterToInterface(
    pInterface: ?*anyopaque,
    gfFilter: GLOBAL_FILTER,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "iphlpapi" fn PfRemoveGlobalFilterFromInterface(
    pInterface: ?*anyopaque,
    gfFilter: GLOBAL_FILTER,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "iphlpapi" fn PfMakeLog(
    hEvent: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "iphlpapi" fn PfSetLogBuffer(
    pbBuffer: ?*u8,
    dwSize: u32,
    dwThreshold: u32,
    dwEntries: u32,
    pdwLoggedEntries: ?*u32,
    pdwLostEntries: ?*u32,
    pdwSizeUsed: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "iphlpapi" fn PfDeleteLog(
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "iphlpapi" fn PfGetInterfaceStatistics(
    pInterface: ?*anyopaque,
    ppfStats: ?*PF_INTERFACE_STATS,
    pdwBufferSize: ?*u32,
    fResetCounters: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "iphlpapi" fn PfTestPacket(
    pInInterface: ?*anyopaque,
    pOutInterface: ?*anyopaque,
    cBytes: u32,
    pbPacket: ?*u8,
    ppAction: ?*PFFORWARD_ACTION,
) callconv(@import("std").os.windows.WINAPI) u32;


//--------------------------------------------------------------------------------
// Section: Unicode Aliases (2)
//--------------------------------------------------------------------------------
pub const ConvertInterfaceNameToLuid = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().ConvertInterfaceNameToLuidA,
    .wide => @This().ConvertInterfaceNameToLuidW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'ConvertInterfaceNameToLuid' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const ConvertInterfaceLuidToName = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().ConvertInterfaceLuidToNameA,
    .wide => @This().ConvertInterfaceLuidToNameW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'ConvertInterfaceLuidToName' requires that UNICODE be set to true or false in the root module",
    ),
};
//--------------------------------------------------------------------------------
// Section: Imports (41)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const ADDRESS_FAMILY = @import("../networking/win_sock.zig").ADDRESS_FAMILY;
const BOOL = @import("../foundation.zig").BOOL;
const BOOLEAN = @import("../foundation.zig").BOOLEAN;
const CHAR = @import("../foundation.zig").CHAR;
const HANDLE = @import("../foundation.zig").HANDLE;
const IF_OPER_STATUS = @import("../network_management/ndis.zig").IF_OPER_STATUS;
const IN6_ADDR = @import("../networking/win_sock.zig").IN6_ADDR;
const LARGE_INTEGER = @import("../foundation.zig").LARGE_INTEGER;
const NDIS_MEDIUM = @import("../network_management/ndis.zig").NDIS_MEDIUM;
const NDIS_PHYSICAL_MEDIUM = @import("../network_management/ndis.zig").NDIS_PHYSICAL_MEDIUM;
const NET_IF_ACCESS_TYPE = @import("../network_management/ndis.zig").NET_IF_ACCESS_TYPE;
const NET_IF_ADMIN_STATUS = @import("../network_management/ndis.zig").NET_IF_ADMIN_STATUS;
const NET_IF_CONNECTION_TYPE = @import("../network_management/ndis.zig").NET_IF_CONNECTION_TYPE;
const NET_IF_DIRECTION_TYPE = @import("../network_management/ndis.zig").NET_IF_DIRECTION_TYPE;
const NET_IF_MEDIA_CONNECT_STATE = @import("../network_management/ndis.zig").NET_IF_MEDIA_CONNECT_STATE;
const NET_LUID_LH = @import("../network_management/ndis.zig").NET_LUID_LH;
const NL_BANDWIDTH_INFORMATION = @import("../networking/win_sock.zig").NL_BANDWIDTH_INFORMATION;
const NL_DAD_STATE = @import("../networking/win_sock.zig").NL_DAD_STATE;
const NL_INTERFACE_OFFLOAD_ROD = @import("../networking/win_sock.zig").NL_INTERFACE_OFFLOAD_ROD;
const NL_LINK_LOCAL_ADDRESS_BEHAVIOR = @import("../networking/win_sock.zig").NL_LINK_LOCAL_ADDRESS_BEHAVIOR;
const NL_NEIGHBOR_STATE = @import("../networking/win_sock.zig").NL_NEIGHBOR_STATE;
const NL_NETWORK_CONNECTIVITY_HINT = @import("../networking/win_sock.zig").NL_NETWORK_CONNECTIVITY_HINT;
const NL_PREFIX_ORIGIN = @import("../networking/win_sock.zig").NL_PREFIX_ORIGIN;
const NL_ROUTE_ORIGIN = @import("../networking/win_sock.zig").NL_ROUTE_ORIGIN;
const NL_ROUTE_PROTOCOL = @import("../networking/win_sock.zig").NL_ROUTE_PROTOCOL;
const NL_ROUTER_DISCOVERY_BEHAVIOR = @import("../networking/win_sock.zig").NL_ROUTER_DISCOVERY_BEHAVIOR;
const NL_SUFFIX_ORIGIN = @import("../networking/win_sock.zig").NL_SUFFIX_ORIGIN;
const NTSTATUS = @import("../foundation.zig").NTSTATUS;
const OVERLAPPED = @import("../system/io.zig").OVERLAPPED;
const PIO_APC_ROUTINE = @import("../system/windows_programming.zig").PIO_APC_ROUTINE;
const PSTR = @import("../foundation.zig").PSTR;
const PWSTR = @import("../foundation.zig").PWSTR;
const SCOPE_ID = @import("../networking/win_sock.zig").SCOPE_ID;
const SOCKADDR = @import("../networking/win_sock.zig").SOCKADDR;
const SOCKADDR_IN6 = @import("../networking/win_sock.zig").SOCKADDR_IN6;
const SOCKADDR_IN6_PAIR = @import("../networking/win_sock.zig").SOCKADDR_IN6_PAIR;
const SOCKADDR_INET = @import("../networking/win_sock.zig").SOCKADDR_INET;
const SOCKET_ADDRESS = @import("../networking/win_sock.zig").SOCKET_ADDRESS;
const TUNNEL_TYPE = @import("../network_management/ndis.zig").TUNNEL_TYPE;
const WIN32_ERROR = @import("../foundation.zig").WIN32_ERROR;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "PIPINTERFACE_CHANGE_CALLBACK")) { _ = PIPINTERFACE_CHANGE_CALLBACK; }
    if (@hasDecl(@This(), "PUNICAST_IPADDRESS_CHANGE_CALLBACK")) { _ = PUNICAST_IPADDRESS_CHANGE_CALLBACK; }
    if (@hasDecl(@This(), "PSTABLE_UNICAST_IPADDRESS_TABLE_CALLBACK")) { _ = PSTABLE_UNICAST_IPADDRESS_TABLE_CALLBACK; }
    if (@hasDecl(@This(), "PIPFORWARD_CHANGE_CALLBACK")) { _ = PIPFORWARD_CHANGE_CALLBACK; }
    if (@hasDecl(@This(), "PTEREDO_PORT_CHANGE_CALLBACK")) { _ = PTEREDO_PORT_CHANGE_CALLBACK; }
    if (@hasDecl(@This(), "PNETWORK_CONNECTIVITY_HINT_CHANGE_CALLBACK")) { _ = PNETWORK_CONNECTIVITY_HINT_CHANGE_CALLBACK; }
    if (@hasDecl(@This(), "PINTERFACE_TIMESTAMP_CONFIG_CHANGE_CALLBACK")) { _ = PINTERFACE_TIMESTAMP_CONFIG_CHANGE_CALLBACK; }

    @setEvalBranchQuota(
        comptime @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        _ = @field(@This(), decl.name);
    }
}
