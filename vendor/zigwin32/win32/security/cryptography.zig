//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (2847)
//--------------------------------------------------------------------------------
pub const CERT_COMPARE_SHIFT = @as(i32, 16);
pub const BCRYPT_OBJECT_ALIGNMENT = @as(u32, 16);
pub const BCRYPT_KDF_HASH = "HASH";
pub const BCRYPT_KDF_HMAC = "HMAC";
pub const BCRYPT_KDF_TLS_PRF = "TLS_PRF";
pub const BCRYPT_KDF_SP80056A_CONCAT = "SP800_56A_CONCAT";
pub const BCRYPT_KDF_RAW_SECRET = "TRUNCATE";
pub const BCRYPT_KDF_HKDF = "HKDF";
pub const KDF_HASH_ALGORITHM = @as(u32, 0);
pub const KDF_SECRET_PREPEND = @as(u32, 1);
pub const KDF_SECRET_APPEND = @as(u32, 2);
pub const KDF_HMAC_KEY = @as(u32, 3);
pub const KDF_TLS_PRF_LABEL = @as(u32, 4);
pub const KDF_TLS_PRF_SEED = @as(u32, 5);
pub const KDF_SECRET_HANDLE = @as(u32, 6);
pub const KDF_TLS_PRF_PROTOCOL = @as(u32, 7);
pub const KDF_ALGORITHMID = @as(u32, 8);
pub const KDF_PARTYUINFO = @as(u32, 9);
pub const KDF_PARTYVINFO = @as(u32, 10);
pub const KDF_SUPPPUBINFO = @as(u32, 11);
pub const KDF_SUPPPRIVINFO = @as(u32, 12);
pub const KDF_LABEL = @as(u32, 13);
pub const KDF_CONTEXT = @as(u32, 14);
pub const KDF_SALT = @as(u32, 15);
pub const KDF_ITERATION_COUNT = @as(u32, 16);
pub const KDF_GENERIC_PARAMETER = @as(u32, 17);
pub const KDF_KEYBITLENGTH = @as(u32, 18);
pub const KDF_HKDF_SALT = @as(u32, 19);
pub const KDF_HKDF_INFO = @as(u32, 20);
pub const KDF_USE_SECRET_AS_HMAC_KEY_FLAG = @as(u32, 1);
pub const BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO_VERSION = @as(u32, 1);
pub const BCRYPT_AUTH_MODE_CHAIN_CALLS_FLAG = @as(u32, 1);
pub const BCRYPT_AUTH_MODE_IN_PROGRESS_FLAG = @as(u32, 2);
pub const BCRYPT_OPAQUE_KEY_BLOB = "OpaqueKeyBlob";
pub const BCRYPT_KEY_DATA_BLOB = "KeyDataBlob";
pub const BCRYPT_AES_WRAP_KEY_BLOB = "Rfc3565KeyWrapBlob";
pub const BCRYPT_OBJECT_LENGTH = "ObjectLength";
pub const BCRYPT_ALGORITHM_NAME = "AlgorithmName";
pub const BCRYPT_PROVIDER_HANDLE = "ProviderHandle";
pub const BCRYPT_CHAINING_MODE = "ChainingMode";
pub const BCRYPT_BLOCK_LENGTH = "BlockLength";
pub const BCRYPT_KEY_LENGTH = "KeyLength";
pub const BCRYPT_KEY_OBJECT_LENGTH = "KeyObjectLength";
pub const BCRYPT_KEY_STRENGTH = "KeyStrength";
pub const BCRYPT_KEY_LENGTHS = "KeyLengths";
pub const BCRYPT_BLOCK_SIZE_LIST = "BlockSizeList";
pub const BCRYPT_EFFECTIVE_KEY_LENGTH = "EffectiveKeyLength";
pub const BCRYPT_HASH_LENGTH = "HashDigestLength";
pub const BCRYPT_HASH_OID_LIST = "HashOIDList";
pub const BCRYPT_PADDING_SCHEMES = "PaddingSchemes";
pub const BCRYPT_SIGNATURE_LENGTH = "SignatureLength";
pub const BCRYPT_HASH_BLOCK_LENGTH = "HashBlockLength";
pub const BCRYPT_AUTH_TAG_LENGTH = "AuthTagLength";
pub const BCRYPT_PRIMITIVE_TYPE = "PrimitiveType";
pub const BCRYPT_IS_KEYED_HASH = "IsKeyedHash";
pub const BCRYPT_IS_REUSABLE_HASH = "IsReusableHash";
pub const BCRYPT_MESSAGE_BLOCK_LENGTH = "MessageBlockLength";
pub const BCRYPT_PUBLIC_KEY_LENGTH = "PublicKeyLength";
pub const BCRYPT_PCP_PLATFORM_TYPE_PROPERTY = "PCP_PLATFORM_TYPE";
pub const BCRYPT_PCP_PROVIDER_VERSION_PROPERTY = "PCP_PROVIDER_VERSION";
pub const BCRYPT_MULTI_OBJECT_LENGTH = "MultiObjectLength";
pub const BCRYPT_IS_IFX_TPM_WEAK_KEY = "IsIfxTpmWeakKey";
pub const BCRYPT_HKDF_HASH_ALGORITHM = "HkdfHashAlgorithm";
pub const BCRYPT_HKDF_SALT_AND_FINALIZE = "HkdfSaltAndFinalize";
pub const BCRYPT_HKDF_PRK_AND_FINALIZE = "HkdfPrkAndFinalize";
pub const BCRYPT_INITIALIZATION_VECTOR = "IV";
pub const BCRYPT_CHAIN_MODE_NA = "ChainingModeN/A";
pub const BCRYPT_CHAIN_MODE_CBC = "ChainingModeCBC";
pub const BCRYPT_CHAIN_MODE_ECB = "ChainingModeECB";
pub const BCRYPT_CHAIN_MODE_CFB = "ChainingModeCFB";
pub const BCRYPT_CHAIN_MODE_CCM = "ChainingModeCCM";
pub const BCRYPT_CHAIN_MODE_GCM = "ChainingModeGCM";
pub const BCRYPT_SUPPORTED_PAD_ROUTER = @as(u32, 1);
pub const BCRYPT_SUPPORTED_PAD_PKCS1_ENC = @as(u32, 2);
pub const BCRYPT_SUPPORTED_PAD_PKCS1_SIG = @as(u32, 4);
pub const BCRYPT_SUPPORTED_PAD_OAEP = @as(u32, 8);
pub const BCRYPT_SUPPORTED_PAD_PSS = @as(u32, 16);
pub const BCRYPT_BLOCK_PADDING = @as(u32, 1);
pub const BCRYPT_GENERATE_IV = @as(u32, 32);
pub const BCRYPT_PAD_PKCS1_OPTIONAL_HASH_OID = @as(u32, 16);
pub const BCRYPTBUFFER_VERSION = @as(u32, 0);
pub const BCRYPT_PUBLIC_KEY_BLOB = "PUBLICBLOB";
pub const BCRYPT_PRIVATE_KEY_BLOB = "PRIVATEBLOB";
pub const BCRYPT_RSAPUBLIC_BLOB = "RSAPUBLICBLOB";
pub const BCRYPT_RSAPRIVATE_BLOB = "RSAPRIVATEBLOB";
pub const LEGACY_RSAPUBLIC_BLOB = "CAPIPUBLICBLOB";
pub const LEGACY_RSAPRIVATE_BLOB = "CAPIPRIVATEBLOB";
pub const BCRYPT_RSAFULLPRIVATE_BLOB = "RSAFULLPRIVATEBLOB";
pub const BCRYPT_GLOBAL_PARAMETERS = "SecretAgreementParam";
pub const BCRYPT_PRIVATE_KEY = "PrivKeyVal";
pub const BCRYPT_ECCPUBLIC_BLOB = "ECCPUBLICBLOB";
pub const BCRYPT_ECCPRIVATE_BLOB = "ECCPRIVATEBLOB";
pub const BCRYPT_ECCFULLPUBLIC_BLOB = "ECCFULLPUBLICBLOB";
pub const BCRYPT_ECCFULLPRIVATE_BLOB = "ECCFULLPRIVATEBLOB";
pub const SSL_ECCPUBLIC_BLOB = "SSLECCPUBLICBLOB";
pub const BCRYPT_ECDH_PUBLIC_P256_MAGIC = @as(u32, 827016005);
pub const BCRYPT_ECDH_PRIVATE_P256_MAGIC = @as(u32, 843793221);
pub const BCRYPT_ECDH_PUBLIC_P384_MAGIC = @as(u32, 860570437);
pub const BCRYPT_ECDH_PRIVATE_P384_MAGIC = @as(u32, 877347653);
pub const BCRYPT_ECDH_PUBLIC_P521_MAGIC = @as(u32, 894124869);
pub const BCRYPT_ECDH_PRIVATE_P521_MAGIC = @as(u32, 910902085);
pub const BCRYPT_ECDH_PUBLIC_GENERIC_MAGIC = @as(u32, 1347109701);
pub const BCRYPT_ECDH_PRIVATE_GENERIC_MAGIC = @as(u32, 1447772997);
pub const BCRYPT_ECDSA_PUBLIC_P256_MAGIC = @as(u32, 827540293);
pub const BCRYPT_ECDSA_PRIVATE_P256_MAGIC = @as(u32, 844317509);
pub const BCRYPT_ECDSA_PUBLIC_P384_MAGIC = @as(u32, 861094725);
pub const BCRYPT_ECDSA_PRIVATE_P384_MAGIC = @as(u32, 877871941);
pub const BCRYPT_ECDSA_PUBLIC_P521_MAGIC = @as(u32, 894649157);
pub const BCRYPT_ECDSA_PRIVATE_P521_MAGIC = @as(u32, 911426373);
pub const BCRYPT_ECDSA_PUBLIC_GENERIC_MAGIC = @as(u32, 1346650949);
pub const BCRYPT_ECDSA_PRIVATE_GENERIC_MAGIC = @as(u32, 1447314245);
pub const BCRYPT_ECC_FULLKEY_BLOB_V1 = @as(u32, 1);
pub const BCRYPT_DH_PUBLIC_BLOB = "DHPUBLICBLOB";
pub const BCRYPT_DH_PRIVATE_BLOB = "DHPRIVATEBLOB";
pub const LEGACY_DH_PUBLIC_BLOB = "CAPIDHPUBLICBLOB";
pub const LEGACY_DH_PRIVATE_BLOB = "CAPIDHPRIVATEBLOB";
pub const BCRYPT_DH_PARAMETERS = "DHParameters";
pub const BCRYPT_DH_PARAMETERS_MAGIC = @as(u32, 1297107012);
pub const BCRYPT_DSA_PUBLIC_BLOB = "DSAPUBLICBLOB";
pub const BCRYPT_DSA_PRIVATE_BLOB = "DSAPRIVATEBLOB";
pub const LEGACY_DSA_PUBLIC_BLOB = "CAPIDSAPUBLICBLOB";
pub const LEGACY_DSA_PRIVATE_BLOB = "CAPIDSAPRIVATEBLOB";
pub const LEGACY_DSA_V2_PUBLIC_BLOB = "V2CAPIDSAPUBLICBLOB";
pub const LEGACY_DSA_V2_PRIVATE_BLOB = "V2CAPIDSAPRIVATEBLOB";
pub const BCRYPT_DSA_PUBLIC_MAGIC_V2 = @as(u32, 843206724);
pub const BCRYPT_DSA_PRIVATE_MAGIC_V2 = @as(u32, 844517444);
pub const BCRYPT_KEY_DATA_BLOB_MAGIC = @as(u32, 1296188491);
pub const BCRYPT_KEY_DATA_BLOB_VERSION1 = @as(u32, 1);
pub const BCRYPT_DSA_PARAMETERS = "DSAParameters";
pub const BCRYPT_DSA_PARAMETERS_MAGIC = @as(u32, 1297109828);
pub const BCRYPT_DSA_PARAMETERS_MAGIC_V2 = @as(u32, 843927620);
pub const BCRYPT_ECC_PARAMETERS = "ECCParameters";
pub const BCRYPT_ECC_CURVE_NAME = "ECCCurveName";
pub const BCRYPT_ECC_CURVE_NAME_LIST = "ECCCurveNameList";
pub const BCRYPT_ECC_PARAMETERS_MAGIC = @as(u32, 1346585413);
pub const BCRYPT_ECC_CURVE_BRAINPOOLP160R1 = "brainpoolP160r1";
pub const BCRYPT_ECC_CURVE_BRAINPOOLP160T1 = "brainpoolP160t1";
pub const BCRYPT_ECC_CURVE_BRAINPOOLP192R1 = "brainpoolP192r1";
pub const BCRYPT_ECC_CURVE_BRAINPOOLP192T1 = "brainpoolP192t1";
pub const BCRYPT_ECC_CURVE_BRAINPOOLP224R1 = "brainpoolP224r1";
pub const BCRYPT_ECC_CURVE_BRAINPOOLP224T1 = "brainpoolP224t1";
pub const BCRYPT_ECC_CURVE_BRAINPOOLP256R1 = "brainpoolP256r1";
pub const BCRYPT_ECC_CURVE_BRAINPOOLP256T1 = "brainpoolP256t1";
pub const BCRYPT_ECC_CURVE_BRAINPOOLP320R1 = "brainpoolP320r1";
pub const BCRYPT_ECC_CURVE_BRAINPOOLP320T1 = "brainpoolP320t1";
pub const BCRYPT_ECC_CURVE_BRAINPOOLP384R1 = "brainpoolP384r1";
pub const BCRYPT_ECC_CURVE_BRAINPOOLP384T1 = "brainpoolP384t1";
pub const BCRYPT_ECC_CURVE_BRAINPOOLP512R1 = "brainpoolP512r1";
pub const BCRYPT_ECC_CURVE_BRAINPOOLP512T1 = "brainpoolP512t1";
pub const BCRYPT_ECC_CURVE_25519 = "curve25519";
pub const BCRYPT_ECC_CURVE_EC192WAPI = "ec192wapi";
pub const BCRYPT_ECC_CURVE_NISTP192 = "nistP192";
pub const BCRYPT_ECC_CURVE_NISTP224 = "nistP224";
pub const BCRYPT_ECC_CURVE_NISTP256 = "nistP256";
pub const BCRYPT_ECC_CURVE_NISTP384 = "nistP384";
pub const BCRYPT_ECC_CURVE_NISTP521 = "nistP521";
pub const BCRYPT_ECC_CURVE_NUMSP256T1 = "numsP256t1";
pub const BCRYPT_ECC_CURVE_NUMSP384T1 = "numsP384t1";
pub const BCRYPT_ECC_CURVE_NUMSP512T1 = "numsP512t1";
pub const BCRYPT_ECC_CURVE_SECP160K1 = "secP160k1";
pub const BCRYPT_ECC_CURVE_SECP160R1 = "secP160r1";
pub const BCRYPT_ECC_CURVE_SECP160R2 = "secP160r2";
pub const BCRYPT_ECC_CURVE_SECP192K1 = "secP192k1";
pub const BCRYPT_ECC_CURVE_SECP192R1 = "secP192r1";
pub const BCRYPT_ECC_CURVE_SECP224K1 = "secP224k1";
pub const BCRYPT_ECC_CURVE_SECP224R1 = "secP224r1";
pub const BCRYPT_ECC_CURVE_SECP256K1 = "secP256k1";
pub const BCRYPT_ECC_CURVE_SECP256R1 = "secP256r1";
pub const BCRYPT_ECC_CURVE_SECP384R1 = "secP384r1";
pub const BCRYPT_ECC_CURVE_SECP521R1 = "secP521r1";
pub const BCRYPT_ECC_CURVE_WTLS7 = "wtls7";
pub const BCRYPT_ECC_CURVE_WTLS9 = "wtls9";
pub const BCRYPT_ECC_CURVE_WTLS12 = "wtls12";
pub const BCRYPT_ECC_CURVE_X962P192V1 = "x962P192v1";
pub const BCRYPT_ECC_CURVE_X962P192V2 = "x962P192v2";
pub const BCRYPT_ECC_CURVE_X962P192V3 = "x962P192v3";
pub const BCRYPT_ECC_CURVE_X962P239V1 = "x962P239v1";
pub const BCRYPT_ECC_CURVE_X962P239V2 = "x962P239v2";
pub const BCRYPT_ECC_CURVE_X962P239V3 = "x962P239v3";
pub const BCRYPT_ECC_CURVE_X962P256V1 = "x962P256v1";
pub const MS_PRIMITIVE_PROVIDER = "Microsoft Primitive Provider";
pub const MS_PLATFORM_CRYPTO_PROVIDER = "Microsoft Platform Crypto Provider";
pub const BCRYPT_RSA_ALGORITHM = "RSA";
pub const BCRYPT_RSA_SIGN_ALGORITHM = "RSA_SIGN";
pub const BCRYPT_DH_ALGORITHM = "DH";
pub const BCRYPT_DSA_ALGORITHM = "DSA";
pub const BCRYPT_RC2_ALGORITHM = "RC2";
pub const BCRYPT_RC4_ALGORITHM = "RC4";
pub const BCRYPT_AES_ALGORITHM = "AES";
pub const BCRYPT_DES_ALGORITHM = "DES";
pub const BCRYPT_DESX_ALGORITHM = "DESX";
pub const BCRYPT_3DES_ALGORITHM = "3DES";
pub const BCRYPT_3DES_112_ALGORITHM = "3DES_112";
pub const BCRYPT_MD2_ALGORITHM = "MD2";
pub const BCRYPT_MD4_ALGORITHM = "MD4";
pub const BCRYPT_MD5_ALGORITHM = "MD5";
pub const BCRYPT_SHA1_ALGORITHM = "SHA1";
pub const BCRYPT_SHA256_ALGORITHM = "SHA256";
pub const BCRYPT_SHA384_ALGORITHM = "SHA384";
pub const BCRYPT_SHA512_ALGORITHM = "SHA512";
pub const BCRYPT_AES_GMAC_ALGORITHM = "AES-GMAC";
pub const BCRYPT_AES_CMAC_ALGORITHM = "AES-CMAC";
pub const BCRYPT_ECDSA_P256_ALGORITHM = "ECDSA_P256";
pub const BCRYPT_ECDSA_P384_ALGORITHM = "ECDSA_P384";
pub const BCRYPT_ECDSA_P521_ALGORITHM = "ECDSA_P521";
pub const BCRYPT_ECDH_P256_ALGORITHM = "ECDH_P256";
pub const BCRYPT_ECDH_P384_ALGORITHM = "ECDH_P384";
pub const BCRYPT_ECDH_P521_ALGORITHM = "ECDH_P521";
pub const BCRYPT_RNG_ALGORITHM = "RNG";
pub const BCRYPT_RNG_FIPS186_DSA_ALGORITHM = "FIPS186DSARNG";
pub const BCRYPT_RNG_DUAL_EC_ALGORITHM = "DUALECRNG";
pub const BCRYPT_SP800108_CTR_HMAC_ALGORITHM = "SP800_108_CTR_HMAC";
pub const BCRYPT_SP80056A_CONCAT_ALGORITHM = "SP800_56A_CONCAT";
pub const BCRYPT_PBKDF2_ALGORITHM = "PBKDF2";
pub const BCRYPT_CAPI_KDF_ALGORITHM = "CAPI_KDF";
pub const BCRYPT_TLS1_1_KDF_ALGORITHM = "TLS1_1_KDF";
pub const BCRYPT_TLS1_2_KDF_ALGORITHM = "TLS1_2_KDF";
pub const BCRYPT_ECDSA_ALGORITHM = "ECDSA";
pub const BCRYPT_ECDH_ALGORITHM = "ECDH";
pub const BCRYPT_XTS_AES_ALGORITHM = "XTS-AES";
pub const BCRYPT_HKDF_ALGORITHM = "HKDF";
pub const BCRYPT_CHACHA20_POLY1305_ALGORITHM = "CHACHA20_POLY1305";
pub const BCRYPT_KEY_DERIVATION_INTERFACE = @as(u32, 7);
pub const BCRYPT_MD2_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 1));
pub const BCRYPT_MD4_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 17));
pub const BCRYPT_MD5_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 33));
pub const BCRYPT_SHA1_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 49));
pub const BCRYPT_SHA256_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 65));
pub const BCRYPT_SHA384_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 81));
pub const BCRYPT_SHA512_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 97));
pub const BCRYPT_RC4_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 113));
pub const BCRYPT_RNG_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 129));
pub const BCRYPT_HMAC_MD5_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 145));
pub const BCRYPT_HMAC_SHA1_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 161));
pub const BCRYPT_HMAC_SHA256_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 177));
pub const BCRYPT_HMAC_SHA384_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 193));
pub const BCRYPT_HMAC_SHA512_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 209));
pub const BCRYPT_RSA_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 225));
pub const BCRYPT_ECDSA_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 241));
pub const BCRYPT_AES_CMAC_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 257));
pub const BCRYPT_AES_GMAC_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 273));
pub const BCRYPT_HMAC_MD2_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 289));
pub const BCRYPT_HMAC_MD4_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 305));
pub const BCRYPT_3DES_CBC_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 321));
pub const BCRYPT_3DES_ECB_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 337));
pub const BCRYPT_3DES_CFB_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 353));
pub const BCRYPT_3DES_112_CBC_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 369));
pub const BCRYPT_3DES_112_ECB_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 385));
pub const BCRYPT_3DES_112_CFB_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 401));
pub const BCRYPT_AES_CBC_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 417));
pub const BCRYPT_AES_ECB_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 433));
pub const BCRYPT_AES_CFB_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 449));
pub const BCRYPT_AES_CCM_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 465));
pub const BCRYPT_AES_GCM_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 481));
pub const BCRYPT_DES_CBC_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 497));
pub const BCRYPT_DES_ECB_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 513));
pub const BCRYPT_DES_CFB_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 529));
pub const BCRYPT_DESX_CBC_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 545));
pub const BCRYPT_DESX_ECB_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 561));
pub const BCRYPT_DESX_CFB_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 577));
pub const BCRYPT_RC2_CBC_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 593));
pub const BCRYPT_RC2_ECB_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 609));
pub const BCRYPT_RC2_CFB_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 625));
pub const BCRYPT_DH_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 641));
pub const BCRYPT_ECDH_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 657));
pub const BCRYPT_ECDH_P256_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 673));
pub const BCRYPT_ECDH_P384_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 689));
pub const BCRYPT_ECDH_P521_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 705));
pub const BCRYPT_DSA_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 721));
pub const BCRYPT_ECDSA_P256_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 737));
pub const BCRYPT_ECDSA_P384_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 753));
pub const BCRYPT_ECDSA_P521_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 769));
pub const BCRYPT_RSA_SIGN_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 785));
pub const BCRYPT_CAPI_KDF_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 801));
pub const BCRYPT_PBKDF2_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 817));
pub const BCRYPT_SP800108_CTR_HMAC_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 833));
pub const BCRYPT_SP80056A_CONCAT_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 849));
pub const BCRYPT_TLS1_1_KDF_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 865));
pub const BCRYPT_TLS1_2_KDF_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 881));
pub const BCRYPT_XTS_AES_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 897));
pub const BCRYPT_HKDF_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 913));
pub const BCRYPT_CHACHA20_POLY1305_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 929));
pub const BCRYPT_CAPI_AES_FLAG = @as(u32, 16);
pub const BCRYPT_MULTI_FLAG = @as(u32, 64);
pub const BCRYPT_TLS_CBC_HMAC_VERIFY_FLAG = @as(u32, 4);
pub const BCRYPT_BUFFERS_LOCKED_FLAG = @as(u32, 64);
pub const BCRYPT_EXTENDED_KEYSIZE = @as(u32, 128);
pub const BCRYPT_ENABLE_INCOMPATIBLE_FIPS_CHECKS = @as(u32, 256);
pub const BCRYPT_KEY_DERIVATION_OPERATION = @as(u32, 64);
pub const BCRYPT_PUBLIC_KEY_FLAG = @as(u32, 1);
pub const BCRYPT_PRIVATE_KEY_FLAG = @as(u32, 2);
pub const BCRYPT_NO_KEY_VALIDATION = @as(u32, 8);
pub const BCRYPT_KEY_VALIDATION_RANGE = @as(u32, 16);
pub const BCRYPT_KEY_VALIDATION_RANGE_AND_ORDER = @as(u32, 24);
pub const BCRYPT_KEY_VALIDATION_REGENERATE = @as(u32, 32);
pub const BCRYPT_RNG_USE_ENTROPY_IN_BUFFER = @as(u32, 1);
pub const BCRYPT_USE_SYSTEM_PREFERRED_RNG = @as(u32, 2);
pub const BCRYPT_HASH_INTERFACE_MAJORVERSION_2 = @as(u32, 2);
pub const CRYPT_OVERWRITE = @as(u32, 1);
pub const CRYPT_PRIORITY_TOP = @as(u32, 0);
pub const CRYPT_PRIORITY_BOTTOM = @as(u32, 4294967295);
pub const CRYPT_DEFAULT_CONTEXT = "Default";
pub const wszXMLNS_DIGSIG = "http://www.w3.org/2000/09/xmldsig#";
pub const wszXMLNS_DIGSIG_SignatureProperties = "http://www.w3.org/2000/09/xmldsig#SignatureProperties";
pub const wszXMLNS_DIGSIG_Id = "Id";
pub const wszURI_XMLNS_DIGSIG_BASE64 = "http://www.w3.org/2000/09/xmldsig#base64";
pub const wszURI_XMLNS_DIGSIG_SHA1 = "http://www.w3.org/2000/09/xmldsig#sha1";
pub const wszURI_XMLNS_DIGSIG_SHA256 = "http://www.w3.org/2001/04/xmlenc#sha256";
pub const wszURI_XMLNS_DIGSIG_SHA384 = "http://www.w3.org/2001/04/xmldsig-more#sha384";
pub const wszURI_XMLNS_DIGSIG_SHA512 = "http://www.w3.org/2001/04/xmlenc#sha512";
pub const wszURI_XMLNS_DIGSIG_RSA_SHA1 = "http://www.w3.org/2000/09/xmldsig#rsa-sha1";
pub const wszURI_XMLNS_DIGSIG_DSA_SHA1 = "http://www.w3.org/2000/09/xmldsig#dsa-sha1";
pub const wszURI_XMLNS_DIGSIG_RSA_SHA256 = "http://www.w3.org/2001/04/xmldsig-more#rsa-sha256";
pub const wszURI_XMLNS_DIGSIG_RSA_SHA384 = "http://www.w3.org/2001/04/xmldsig-more#rsa-sha384";
pub const wszURI_XMLNS_DIGSIG_RSA_SHA512 = "http://www.w3.org/2001/04/xmldsig-more#rsa-sha512";
pub const wszURI_XMLNS_DIGSIG_ECDSA_SHA1 = "http://www.w3.org/2001/04/xmldsig-more#ecdsa-sha1";
pub const wszURI_XMLNS_DIGSIG_ECDSA_SHA256 = "http://www.w3.org/2001/04/xmldsig-more#ecdsa-sha256";
pub const wszURI_XMLNS_DIGSIG_ECDSA_SHA384 = "http://www.w3.org/2001/04/xmldsig-more#ecdsa-sha384";
pub const wszURI_XMLNS_DIGSIG_ECDSA_SHA512 = "http://www.w3.org/2001/04/xmldsig-more#ecdsa-sha512";
pub const wszURI_XMLNS_DIGSIG_HMAC_SHA1 = "http://www.w3.org/2000/09/xmldsig#hmac-sha1";
pub const wszURI_XMLNS_DIGSIG_HMAC_SHA256 = "http://www.w3.org/2001/04/xmldsig-more#hmac-sha256";
pub const wszURI_XMLNS_DIGSIG_HMAC_SHA384 = "http://www.w3.org/2001/04/xmldsig-more#hmac-sha384";
pub const wszURI_XMLNS_DIGSIG_HMAC_SHA512 = "http://www.w3.org/2001/04/xmldsig-more#hmac-sha512";
pub const wszURI_CANONICALIZATION_C14N = "http://www.w3.org/TR/2001/REC-xml-c14n-20010315";
pub const wszURI_CANONICALIZATION_C14NC = "http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComments";
pub const wszURI_CANONICALIZATION_EXSLUSIVE_C14N = "http://www.w3.org/2001/10/xml-exc-c14n#";
pub const wszURI_CANONICALIZATION_EXSLUSIVE_C14NC = "http://www.w3.org/2001/10/xml-exc-c14n#WithComments";
pub const wszURI_TRANSFORM_XPATH = "http://www.w3.org/TR/1999/REC-xpath-19991116";
pub const wszURI_XMLNS_TRANSFORM_BASE64 = "http://www.w3.org/2000/09/xmldsig#base64";
pub const wszURI_XMLNS_TRANSFORM_ENVELOPED = "http://www.w3.org/2000/09/xmldsig#enveloped-signature";
pub const CRYPT_XML_BLOB_MAX = @as(u32, 2147483640);
pub const CRYPT_XML_ID_MAX = @as(u32, 256);
pub const CRYPT_XML_SIGNATURES_MAX = @as(u32, 16);
pub const CRYPT_XML_TRANSFORM_MAX = @as(u32, 16);
pub const CRYPT_XML_SIGNATURE_VALUE_MAX = @as(u32, 2048);
pub const CRYPT_XML_DIGEST_VALUE_MAX = @as(u32, 128);
pub const CRYPT_XML_OBJECTS_MAX = @as(u32, 256);
pub const CRYPT_XML_REFERENCES_MAX = @as(u32, 32760);
pub const CRYPT_XML_E_BASE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885376));
pub const CRYPT_XML_E_LARGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885375));
pub const CRYPT_XML_E_TOO_MANY_TRANSFORMS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885374));
pub const CRYPT_XML_E_ENCODING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885373));
pub const CRYPT_XML_E_ALGORITHM = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885372));
pub const CRYPT_XML_E_TRANSFORM = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885371));
pub const CRYPT_XML_E_HANDLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885370));
pub const CRYPT_XML_E_OPERATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885369));
pub const CRYPT_XML_E_UNRESOLVED_REFERENCE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885368));
pub const CRYPT_XML_E_INVALID_DIGEST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885367));
pub const CRYPT_XML_E_INVALID_SIGNATURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885366));
pub const CRYPT_XML_E_HASH_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885365));
pub const CRYPT_XML_E_SIGN_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885364));
pub const CRYPT_XML_E_VERIFY_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885363));
pub const CRYPT_XML_E_TOO_MANY_SIGNATURES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885362));
pub const CRYPT_XML_E_INVALID_KEYVALUE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885361));
pub const CRYPT_XML_E_UNEXPECTED_XML = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885360));
pub const CRYPT_XML_E_SIGNER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885359));
pub const CRYPT_XML_E_NON_UNIQUE_ID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885358));
pub const CRYPT_XML_E_LAST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885358));
pub const CRYPT_XML_FLAG_ALWAYS_RETURN_ENCODED_OBJECT = @as(u32, 1073741824);
pub const CRYPT_XML_FLAG_ENFORCE_ID_NCNAME_FORMAT = @as(u32, 536870912);
pub const CRYPT_XML_FLAG_ENFORCE_ID_NAME_FORMAT = @as(u32, 134217728);
pub const CRYPT_XML_FLAG_ECDSA_DSIG11 = @as(u32, 67108864);
pub const CRYPT_XML_STATUS_NO_ERROR = @as(u32, 0);
pub const CRYPT_XML_FLAG_ADD_OBJECT_CREATE_COPY = @as(u32, 1);
pub const CRYPT_XML_FLAG_CREATE_REFERENCE_AS_OBJECT = @as(u32, 1);
pub const CRYPT_XML_DIGEST_REFERENCE_DATA_TRANSFORMED = @as(u32, 1);
pub const CRYPT_XML_ALGORITHM_INFO_FIND_BY_URI = @as(u32, 1);
pub const CRYPT_XML_ALGORITHM_INFO_FIND_BY_NAME = @as(u32, 2);
pub const CRYPT_XML_ALGORITHM_INFO_FIND_BY_CNG_ALGID = @as(u32, 3);
pub const CRYPT_XML_ALGORITHM_INFO_FIND_BY_CNG_SIGN_ALGID = @as(u32, 4);
pub const szFORCE_KEY_PROTECTION = "ForceKeyProtection";
pub const dwFORCE_KEY_PROTECTION_DISABLED = @as(u32, 0);
pub const dwFORCE_KEY_PROTECTION_USER_SELECT = @as(u32, 1);
pub const dwFORCE_KEY_PROTECTION_HIGH = @as(u32, 2);
pub const CRYPTPROTECT_PROMPT_ON_UNPROTECT = @as(u32, 1);
pub const CRYPTPROTECT_PROMPT_ON_PROTECT = @as(u32, 2);
pub const CRYPTPROTECT_PROMPT_RESERVED = @as(u32, 4);
pub const CRYPTPROTECT_PROMPT_STRONG = @as(u32, 8);
pub const CRYPTPROTECT_PROMPT_REQUIRE_STRONG = @as(u32, 16);
pub const CRYPTPROTECT_UI_FORBIDDEN = @as(u32, 1);
pub const CRYPTPROTECT_LOCAL_MACHINE = @as(u32, 4);
pub const CRYPTPROTECT_CRED_SYNC = @as(u32, 8);
pub const CRYPTPROTECT_AUDIT = @as(u32, 16);
pub const CRYPTPROTECT_NO_RECOVERY = @as(u32, 32);
pub const CRYPTPROTECT_VERIFY_PROTECTION = @as(u32, 64);
pub const CRYPTPROTECT_CRED_REGENERATE = @as(u32, 128);
pub const CRYPTPROTECT_FIRST_RESERVED_FLAGVAL = @as(u32, 268435455);
pub const CRYPTPROTECT_LAST_RESERVED_FLAGVAL = @as(u32, 4294967295);
pub const CRYPTPROTECTMEMORY_BLOCK_SIZE = @as(u32, 16);
pub const CRYPTPROTECTMEMORY_SAME_PROCESS = @as(u32, 0);
pub const CRYPTPROTECTMEMORY_CROSS_PROCESS = @as(u32, 1);
pub const CRYPTPROTECTMEMORY_SAME_LOGON = @as(u32, 2);
pub const NCRYPT_MAX_KEY_NAME_LENGTH = @as(u32, 512);
pub const NCRYPT_MAX_ALG_ID_LENGTH = @as(u32, 512);
pub const MS_KEY_STORAGE_PROVIDER = "Microsoft Software Key Storage Provider";
pub const MS_SMART_CARD_KEY_STORAGE_PROVIDER = "Microsoft Smart Card Key Storage Provider";
pub const MS_PLATFORM_KEY_STORAGE_PROVIDER = "Microsoft Platform Crypto Provider";
pub const MS_NGC_KEY_STORAGE_PROVIDER = "Microsoft Passport Key Storage Provider";
pub const TPM_RSA_SRK_SEAL_KEY = "MICROSOFT_PCP_KSP_RSA_SEAL_KEY_3BD1C4BF-004E-4E2F-8A4D-0BF633DCB074";
pub const NCRYPT_RSA_ALGORITHM = "RSA";
pub const NCRYPT_RSA_SIGN_ALGORITHM = "RSA_SIGN";
pub const NCRYPT_DH_ALGORITHM = "DH";
pub const NCRYPT_DSA_ALGORITHM = "DSA";
pub const NCRYPT_MD2_ALGORITHM = "MD2";
pub const NCRYPT_MD4_ALGORITHM = "MD4";
pub const NCRYPT_MD5_ALGORITHM = "MD5";
pub const NCRYPT_SHA1_ALGORITHM = "SHA1";
pub const NCRYPT_SHA256_ALGORITHM = "SHA256";
pub const NCRYPT_SHA384_ALGORITHM = "SHA384";
pub const NCRYPT_SHA512_ALGORITHM = "SHA512";
pub const NCRYPT_ECDSA_P256_ALGORITHM = "ECDSA_P256";
pub const NCRYPT_ECDSA_P384_ALGORITHM = "ECDSA_P384";
pub const NCRYPT_ECDSA_P521_ALGORITHM = "ECDSA_P521";
pub const NCRYPT_ECDH_P256_ALGORITHM = "ECDH_P256";
pub const NCRYPT_ECDH_P384_ALGORITHM = "ECDH_P384";
pub const NCRYPT_ECDH_P521_ALGORITHM = "ECDH_P521";
pub const NCRYPT_AES_ALGORITHM = "AES";
pub const NCRYPT_RC2_ALGORITHM = "RC2";
pub const NCRYPT_3DES_ALGORITHM = "3DES";
pub const NCRYPT_DES_ALGORITHM = "DES";
pub const NCRYPT_DESX_ALGORITHM = "DESX";
pub const NCRYPT_3DES_112_ALGORITHM = "3DES_112";
pub const NCRYPT_SP800108_CTR_HMAC_ALGORITHM = "SP800_108_CTR_HMAC";
pub const NCRYPT_SP80056A_CONCAT_ALGORITHM = "SP800_56A_CONCAT";
pub const NCRYPT_PBKDF2_ALGORITHM = "PBKDF2";
pub const NCRYPT_CAPI_KDF_ALGORITHM = "CAPI_KDF";
pub const NCRYPT_ECDSA_ALGORITHM = "ECDSA";
pub const NCRYPT_ECDH_ALGORITHM = "ECDH";
pub const NCRYPT_KEY_STORAGE_ALGORITHM = "KEY_STORAGE";
pub const NCRYPT_HMAC_SHA256_ALGORITHM = "HMAC-SHA256";
pub const NCRYPT_KEY_DERIVATION_INTERFACE = @as(u32, 7);
pub const NCRYPT_KEY_PROTECTION_INTERFACE = @as(u32, 65540);
pub const NCRYPT_RSA_ALGORITHM_GROUP = "RSA";
pub const NCRYPT_DH_ALGORITHM_GROUP = "DH";
pub const NCRYPT_DSA_ALGORITHM_GROUP = "DSA";
pub const NCRYPT_ECDSA_ALGORITHM_GROUP = "ECDSA";
pub const NCRYPT_ECDH_ALGORITHM_GROUP = "ECDH";
pub const NCRYPT_AES_ALGORITHM_GROUP = "AES";
pub const NCRYPT_RC2_ALGORITHM_GROUP = "RC2";
pub const NCRYPT_DES_ALGORITHM_GROUP = "DES";
pub const NCRYPT_KEY_DERIVATION_GROUP = "KEY_DERIVATION";
pub const NCRYPTBUFFER_VERSION = @as(u32, 0);
pub const NCRYPTBUFFER_EMPTY = @as(u32, 0);
pub const NCRYPTBUFFER_DATA = @as(u32, 1);
pub const NCRYPTBUFFER_PROTECTION_DESCRIPTOR_STRING = @as(u32, 3);
pub const NCRYPTBUFFER_PROTECTION_FLAGS = @as(u32, 4);
pub const NCRYPTBUFFER_SSL_CLIENT_RANDOM = @as(u32, 20);
pub const NCRYPTBUFFER_SSL_SERVER_RANDOM = @as(u32, 21);
pub const NCRYPTBUFFER_SSL_HIGHEST_VERSION = @as(u32, 22);
pub const NCRYPTBUFFER_SSL_CLEAR_KEY = @as(u32, 23);
pub const NCRYPTBUFFER_SSL_KEY_ARG_DATA = @as(u32, 24);
pub const NCRYPTBUFFER_SSL_SESSION_HASH = @as(u32, 25);
pub const NCRYPTBUFFER_PKCS_OID = @as(u32, 40);
pub const NCRYPTBUFFER_PKCS_ALG_OID = @as(u32, 41);
pub const NCRYPTBUFFER_PKCS_ALG_PARAM = @as(u32, 42);
pub const NCRYPTBUFFER_PKCS_ALG_ID = @as(u32, 43);
pub const NCRYPTBUFFER_PKCS_ATTRS = @as(u32, 44);
pub const NCRYPTBUFFER_PKCS_KEY_NAME = @as(u32, 45);
pub const NCRYPTBUFFER_PKCS_SECRET = @as(u32, 46);
pub const NCRYPTBUFFER_CERT_BLOB = @as(u32, 47);
pub const NCRYPTBUFFER_CLAIM_IDBINDING_NONCE = @as(u32, 48);
pub const NCRYPTBUFFER_CLAIM_KEYATTESTATION_NONCE = @as(u32, 49);
pub const NCRYPTBUFFER_KEY_PROPERTY_FLAGS = @as(u32, 50);
pub const NCRYPTBUFFER_ATTESTATIONSTATEMENT_BLOB = @as(u32, 51);
pub const NCRYPTBUFFER_ATTESTATION_CLAIM_TYPE = @as(u32, 52);
pub const NCRYPTBUFFER_ATTESTATION_CLAIM_CHALLENGE_REQUIRED = @as(u32, 53);
pub const NCRYPTBUFFER_VSM_KEY_ATTESTATION_CLAIM_RESTRICTIONS = @as(u32, 54);
pub const NCRYPTBUFFER_ECC_CURVE_NAME = @as(u32, 60);
pub const NCRYPTBUFFER_ECC_PARAMETERS = @as(u32, 61);
pub const NCRYPTBUFFER_TPM_SEAL_PASSWORD = @as(u32, 70);
pub const NCRYPTBUFFER_TPM_SEAL_POLICYINFO = @as(u32, 71);
pub const NCRYPTBUFFER_TPM_SEAL_TICKET = @as(u32, 72);
pub const NCRYPTBUFFER_TPM_SEAL_NO_DA_PROTECTION = @as(u32, 73);
pub const NCRYPTBUFFER_TPM_PLATFORM_CLAIM_PCR_MASK = @as(u32, 80);
pub const NCRYPTBUFFER_TPM_PLATFORM_CLAIM_NONCE = @as(u32, 81);
pub const NCRYPTBUFFER_TPM_PLATFORM_CLAIM_STATIC_CREATE = @as(u32, 82);
pub const NCRYPT_CIPHER_NO_PADDING_FLAG = @as(u32, 0);
pub const NCRYPT_CIPHER_BLOCK_PADDING_FLAG = @as(u32, 1);
pub const NCRYPT_CIPHER_OTHER_PADDING_FLAG = @as(u32, 2);
pub const NCRYPT_PLATFORM_ATTEST_MAGIC = @as(u32, 1146110288);
pub const NCRYPT_KEY_ATTEST_MAGIC = @as(u32, 1146110283);
pub const NCRYPT_CLAIM_AUTHORITY_ONLY = @as(u32, 1);
pub const NCRYPT_CLAIM_SUBJECT_ONLY = @as(u32, 2);
pub const NCRYPT_CLAIM_WEB_AUTH_SUBJECT_ONLY = @as(u32, 258);
pub const NCRYPT_CLAIM_AUTHORITY_AND_SUBJECT = @as(u32, 3);
pub const NCRYPT_CLAIM_VSM_KEY_ATTESTATION_STATEMENT = @as(u32, 4);
pub const NCRYPT_CLAIM_UNKNOWN = @as(u32, 4096);
pub const NCRYPT_CLAIM_PLATFORM = @as(u32, 65536);
pub const NCRYPT_ISOLATED_KEY_FLAG_CREATED_IN_ISOLATION = @as(u32, 1);
pub const NCRYPT_ISOLATED_KEY_FLAG_IMPORT_ONLY = @as(u32, 2);
pub const NCRYPT_ISOLATED_KEY_ATTESTED_ATTRIBUTES_V0 = @as(u32, 0);
pub const NCRYPT_ISOLATED_KEY_ATTESTED_ATTRIBUTES_CURRENT_VERSION = @as(u32, 0);
pub const NCRYPT_VSM_KEY_ATTESTATION_STATEMENT_V0 = @as(u32, 0);
pub const NCRYPT_VSM_KEY_ATTESTATION_STATEMENT_CURRENT_VERSION = @as(u32, 0);
pub const NCRYPT_VSM_KEY_ATTESTATION_CLAIM_RESTRICTIONS_V0 = @as(u32, 0);
pub const NCRYPT_VSM_KEY_ATTESTATION_CLAIM_RESTRICTIONS_CURRENT_VERSION = @as(u32, 0);
pub const NCRYPT_EXPORTED_ISOLATED_KEY_HEADER_V0 = @as(u32, 0);
pub const NCRYPT_EXPORTED_ISOLATED_KEY_HEADER_CURRENT_VERSION = @as(u32, 0);
pub const NCRYPT_TPM_PLATFORM_ATTESTATION_STATEMENT_V0 = @as(u32, 0);
pub const NCRYPT_TPM_PLATFORM_ATTESTATION_STATEMENT_CURRENT_VERSION = @as(u32, 0);
pub const NCRYPT_PAD_CIPHER_FLAG = @as(u32, 16);
pub const NCRYPT_ATTESTATION_FLAG = @as(u32, 32);
pub const NCRYPT_SEALING_FLAG = @as(u32, 256);
pub const NCRYPT_DO_NOT_FINALIZE_FLAG = @as(u32, 1024);
pub const NCRYPT_EXPORT_LEGACY_FLAG = @as(u32, 2048);
pub const NCRYPT_IGNORE_DEVICE_STATE_FLAG = @as(u32, 4096);
pub const NCRYPT_TREAT_NIST_AS_GENERIC_ECC_FLAG = @as(u32, 8192);
pub const NCRYPT_NO_CACHED_PASSWORD = @as(u32, 16384);
pub const NCRYPT_PROTECT_TO_LOCAL_SYSTEM = @as(u32, 32768);
pub const NCRYPT_PREFER_VIRTUAL_ISOLATION_FLAG = @as(u32, 65536);
pub const NCRYPT_USE_VIRTUAL_ISOLATION_FLAG = @as(u32, 131072);
pub const NCRYPT_USE_PER_BOOT_KEY_FLAG = @as(u32, 262144);
pub const NCRYPT_KEY_DERIVATION_OPERATION = @as(u32, 64);
pub const NCRYPT_AUTHORITY_KEY_FLAG = @as(u32, 256);
pub const NCRYPT_NAME_PROPERTY = "Name";
pub const NCRYPT_UNIQUE_NAME_PROPERTY = "Unique Name";
pub const NCRYPT_ALGORITHM_PROPERTY = "Algorithm Name";
pub const NCRYPT_LENGTH_PROPERTY = "Length";
pub const NCRYPT_LENGTHS_PROPERTY = "Lengths";
pub const NCRYPT_BLOCK_LENGTH_PROPERTY = "Block Length";
pub const NCRYPT_PUBLIC_LENGTH_PROPERTY = "PublicKeyLength";
pub const NCRYPT_SIGNATURE_LENGTH_PROPERTY = "SignatureLength";
pub const NCRYPT_CHAINING_MODE_PROPERTY = "Chaining Mode";
pub const NCRYPT_AUTH_TAG_LENGTH = "AuthTagLength";
pub const NCRYPT_UI_POLICY_PROPERTY = "UI Policy";
pub const NCRYPT_EXPORT_POLICY_PROPERTY = "Export Policy";
pub const NCRYPT_WINDOW_HANDLE_PROPERTY = "HWND Handle";
pub const NCRYPT_USE_CONTEXT_PROPERTY = "Use Context";
pub const NCRYPT_IMPL_TYPE_PROPERTY = "Impl Type";
pub const NCRYPT_KEY_USAGE_PROPERTY = "Key Usage";
pub const NCRYPT_KEY_TYPE_PROPERTY = "Key Type";
pub const NCRYPT_VERSION_PROPERTY = "Version";
pub const NCRYPT_SECURITY_DESCR_SUPPORT_PROPERTY = "Security Descr Support";
pub const NCRYPT_SECURITY_DESCR_PROPERTY = "Security Descr";
pub const NCRYPT_USE_COUNT_ENABLED_PROPERTY = "Enabled Use Count";
pub const NCRYPT_USE_COUNT_PROPERTY = "Use Count";
pub const NCRYPT_LAST_MODIFIED_PROPERTY = "Modified";
pub const NCRYPT_MAX_NAME_LENGTH_PROPERTY = "Max Name Length";
pub const NCRYPT_ALGORITHM_GROUP_PROPERTY = "Algorithm Group";
pub const NCRYPT_DH_PARAMETERS_PROPERTY = "DHParameters";
pub const NCRYPT_ECC_PARAMETERS_PROPERTY = "ECCParameters";
pub const NCRYPT_ECC_CURVE_NAME_PROPERTY = "ECCCurveName";
pub const NCRYPT_ECC_CURVE_NAME_LIST_PROPERTY = "ECCCurveNameList";
pub const NCRYPT_USE_VIRTUAL_ISOLATION_PROPERTY = "Virtual Iso";
pub const NCRYPT_USE_PER_BOOT_KEY_PROPERTY = "Per Boot Key";
pub const NCRYPT_PROVIDER_HANDLE_PROPERTY = "Provider Handle";
pub const NCRYPT_PIN_PROPERTY = "SmartCardPin";
pub const NCRYPT_READER_PROPERTY = "SmartCardReader";
pub const NCRYPT_SMARTCARD_GUID_PROPERTY = "SmartCardGuid";
pub const NCRYPT_CERTIFICATE_PROPERTY = "SmartCardKeyCertificate";
pub const NCRYPT_PIN_PROMPT_PROPERTY = "SmartCardPinPrompt";
pub const NCRYPT_USER_CERTSTORE_PROPERTY = "SmartCardUserCertStore";
pub const NCRYPT_ROOT_CERTSTORE_PROPERTY = "SmartcardRootCertStore";
pub const NCRYPT_SECURE_PIN_PROPERTY = "SmartCardSecurePin";
pub const NCRYPT_ASSOCIATED_ECDH_KEY = "SmartCardAssociatedECDHKey";
pub const NCRYPT_SCARD_PIN_ID = "SmartCardPinId";
pub const NCRYPT_SCARD_PIN_INFO = "SmartCardPinInfo";
pub const NCRYPT_READER_ICON_PROPERTY = "SmartCardReaderIcon";
pub const NCRYPT_KDF_SECRET_VALUE = "KDFKeySecret";
pub const NCRYPT_DISMISS_UI_TIMEOUT_SEC_PROPERTY = "SmartCardDismissUITimeoutSeconds";
pub const NCRYPT_PCP_PLATFORM_TYPE_PROPERTY = "PCP_PLATFORM_TYPE";
pub const NCRYPT_PCP_PROVIDER_VERSION_PROPERTY = "PCP_PROVIDER_VERSION";
pub const NCRYPT_PCP_EKPUB_PROPERTY = "PCP_EKPUB";
pub const NCRYPT_PCP_EKCERT_PROPERTY = "PCP_EKCERT";
pub const NCRYPT_PCP_EKNVCERT_PROPERTY = "PCP_EKNVCERT";
pub const NCRYPT_PCP_RSA_EKPUB_PROPERTY = "PCP_RSA_EKPUB";
pub const NCRYPT_PCP_RSA_EKCERT_PROPERTY = "PCP_RSA_EKCERT";
pub const NCRYPT_PCP_RSA_EKNVCERT_PROPERTY = "PCP_RSA_EKNVCERT";
pub const NCRYPT_PCP_ECC_EKPUB_PROPERTY = "PCP_ECC_EKPUB";
pub const NCRYPT_PCP_ECC_EKCERT_PROPERTY = "PCP_ECC_EKCERT";
pub const NCRYPT_PCP_ECC_EKNVCERT_PROPERTY = "PCP_ECC_EKNVCERT";
pub const NCRYPT_PCP_SRKPUB_PROPERTY = "PCP_SRKPUB";
pub const NCRYPT_PCP_PCRTABLE_PROPERTY = "PCP_PCRTABLE";
pub const NCRYPT_PCP_CHANGEPASSWORD_PROPERTY = "PCP_CHANGEPASSWORD";
pub const NCRYPT_PCP_PASSWORD_REQUIRED_PROPERTY = "PCP_PASSWORD_REQUIRED";
pub const NCRYPT_PCP_USAGEAUTH_PROPERTY = "PCP_USAGEAUTH";
pub const NCRYPT_PCP_MIGRATIONPASSWORD_PROPERTY = "PCP_MIGRATIONPASSWORD";
pub const NCRYPT_PCP_EXPORT_ALLOWED_PROPERTY = "PCP_EXPORT_ALLOWED";
pub const NCRYPT_PCP_STORAGEPARENT_PROPERTY = "PCP_STORAGEPARENT";
pub const NCRYPT_PCP_PROVIDERHANDLE_PROPERTY = "PCP_PROVIDERMHANDLE";
pub const NCRYPT_PCP_PLATFORMHANDLE_PROPERTY = "PCP_PLATFORMHANDLE";
pub const NCRYPT_PCP_PLATFORM_BINDING_PCRMASK_PROPERTY = "PCP_PLATFORM_BINDING_PCRMASK";
pub const NCRYPT_PCP_PLATFORM_BINDING_PCRDIGESTLIST_PROPERTY = "PCP_PLATFORM_BINDING_PCRDIGESTLIST";
pub const NCRYPT_PCP_PLATFORM_BINDING_PCRDIGEST_PROPERTY = "PCP_PLATFORM_BINDING_PCRDIGEST";
pub const NCRYPT_PCP_KEY_USAGE_POLICY_PROPERTY = "PCP_KEY_USAGE_POLICY";
pub const NCRYPT_PCP_RSA_SCHEME_PROPERTY = "PCP_RSA_SCHEME";
pub const NCRYPT_PCP_TPM12_IDBINDING_PROPERTY = "PCP_TPM12_IDBINDING";
pub const NCRYPT_PCP_TPM12_IDBINDING_DYNAMIC_PROPERTY = "PCP_TPM12_IDBINDING_DYNAMIC";
pub const NCRYPT_PCP_TPM12_IDACTIVATION_PROPERTY = "PCP_TPM12_IDACTIVATION";
pub const NCRYPT_PCP_KEYATTESTATION_PROPERTY = "PCP_TPM12_KEYATTESTATION";
pub const NCRYPT_PCP_ALTERNATE_KEY_STORAGE_LOCATION_PROPERTY = "PCP_ALTERNATE_KEY_STORAGE_LOCATION";
pub const NCRYPT_PCP_PLATFORM_BINDING_PCRALGID_PROPERTY = "PCP_PLATFORM_BINDING_PCRALGID";
pub const NCRYPT_PCP_HMAC_AUTH_POLICYREF = "PCP_HMAC_AUTH_POLICYREF";
pub const NCRYPT_PCP_HMAC_AUTH_POLICYINFO = "PCP_HMAC_AUTH_POLICYINFO";
pub const NCRYPT_PCP_HMAC_AUTH_NONCE = "PCP_HMAC_AUTH_NONCE";
pub const NCRYPT_PCP_HMAC_AUTH_SIGNATURE = "PCP_HMAC_AUTH_SIGNATURE";
pub const NCRYPT_PCP_HMAC_AUTH_TICKET = "PCP_HMAC_AUTH_TICKET";
pub const NCRYPT_PCP_NO_DA_PROTECTION_PROPERTY = "PCP_NO_DA_PROTECTION";
pub const NCRYPT_PCP_TPM_MANUFACTURER_ID_PROPERTY = "PCP_TPM_MANUFACTURER_ID";
pub const NCRYPT_PCP_TPM_FW_VERSION_PROPERTY = "PCP_TPM_FW_VERSION";
pub const NCRYPT_PCP_TPM2BNAME_PROPERTY = "PCP_TPM2BNAME";
pub const NCRYPT_PCP_TPM_VERSION_PROPERTY = "PCP_TPM_VERSION";
pub const NCRYPT_PCP_RAW_POLICYDIGEST_PROPERTY = "PCP_RAW_POLICYDIGEST";
pub const NCRYPT_PCP_KEY_CREATIONHASH_PROPERTY = "PCP_KEY_CREATIONHASH";
pub const NCRYPT_PCP_KEY_CREATIONTICKET_PROPERTY = "PCP_KEY_CREATIONTICKET";
pub const NCRYPT_PCP_RSA_SCHEME_HASH_ALG_PROPERTY = "PCP_RSA_SCHEME_HASH_ALG";
pub const NCRYPT_PCP_TPM_IFX_RSA_KEYGEN_PROHIBITED_PROPERTY = "PCP_TPM_IFX_RSA_KEYGEN_PROHIBITED";
pub const NCRYPT_PCP_TPM_IFX_RSA_KEYGEN_VULNERABILITY_PROPERTY = "PCP_TPM_IFX_RSA_KEYGEN_VULNERABILITY";
pub const IFX_RSA_KEYGEN_VUL_NOT_AFFECTED = @as(u32, 0);
pub const IFX_RSA_KEYGEN_VUL_AFFECTED_LEVEL_1 = @as(u32, 1);
pub const IFX_RSA_KEYGEN_VUL_AFFECTED_LEVEL_2 = @as(u32, 2);
pub const NCRYPT_PCP_SESSIONID_PROPERTY = "PCP_SESSIONID";
pub const NCRYPT_PCP_PSS_SALT_SIZE_PROPERTY = "PSS Salt Size";
pub const NCRYPT_TPM_PSS_SALT_SIZE_UNKNOWN = @as(u32, 0);
pub const NCRYPT_TPM_PSS_SALT_SIZE_MAXIMUM = @as(u32, 1);
pub const NCRYPT_TPM_PSS_SALT_SIZE_HASHSIZE = @as(u32, 2);
pub const NCRYPT_PCP_INTERMEDIATE_CA_EKCERT_PROPERTY = "PCP_INTERMEDIATE_CA_EKCERT";
pub const NCRYPT_PCP_PCRTABLE_ALGORITHM_PROPERTY = "PCP_PCRTABLE_ALGORITHM";
pub const NCRYPT_PCP_SYMMETRIC_KEYBITS_PROPERTY = "PCP_SYMMETRIC_KEYBITS";
pub const NCRYPT_TPM_PAD_PSS_IGNORE_SALT = @as(u32, 32);
pub const NCRYPT_TPM12_PROVIDER = @as(u32, 65536);
pub const NCRYPT_PCP_SIGNATURE_KEY = @as(u32, 1);
pub const NCRYPT_PCP_ENCRYPTION_KEY = @as(u32, 2);
pub const NCRYPT_PCP_STORAGE_KEY = @as(u32, 4);
pub const NCRYPT_PCP_IDENTITY_KEY = @as(u32, 8);
pub const NCRYPT_PCP_HMACVERIFICATION_KEY = @as(u32, 16);
pub const NCRYPT_SCARD_NGC_KEY_NAME = "SmartCardNgcKeyName";
pub const NCRYPT_INITIALIZATION_VECTOR = "IV";
pub const NCRYPT_CHANGEPASSWORD_PROPERTY = "PCP_CHANGEPASSWORD";
pub const NCRYPT_ALTERNATE_KEY_STORAGE_LOCATION_PROPERTY = "PCP_ALTERNATE_KEY_STORAGE_LOCATION";
pub const NCRYPT_KEY_ACCESS_POLICY_PROPERTY = "Key Access Policy";
pub const NCRYPT_MAX_PROPERTY_NAME = @as(u32, 64);
pub const NCRYPT_MAX_PROPERTY_DATA = @as(u32, 1048576);
pub const NCRYPT_ALLOW_EXPORT_FLAG = @as(u32, 1);
pub const NCRYPT_ALLOW_PLAINTEXT_EXPORT_FLAG = @as(u32, 2);
pub const NCRYPT_ALLOW_ARCHIVING_FLAG = @as(u32, 4);
pub const NCRYPT_ALLOW_PLAINTEXT_ARCHIVING_FLAG = @as(u32, 8);
pub const NCRYPT_IMPL_HARDWARE_FLAG = @as(u32, 1);
pub const NCRYPT_IMPL_SOFTWARE_FLAG = @as(u32, 2);
pub const NCRYPT_IMPL_REMOVABLE_FLAG = @as(u32, 8);
pub const NCRYPT_IMPL_HARDWARE_RNG_FLAG = @as(u32, 16);
pub const NCRYPT_IMPL_VIRTUAL_ISOLATION_FLAG = @as(u32, 32);
pub const NCRYPT_ALLOW_DECRYPT_FLAG = @as(u32, 1);
pub const NCRYPT_ALLOW_SIGNING_FLAG = @as(u32, 2);
pub const NCRYPT_ALLOW_KEY_AGREEMENT_FLAG = @as(u32, 4);
pub const NCRYPT_ALLOW_KEY_IMPORT_FLAG = @as(u32, 8);
pub const NCRYPT_ALLOW_ALL_USAGES = @as(u32, 16777215);
pub const NCRYPT_UI_PROTECT_KEY_FLAG = @as(u32, 1);
pub const NCRYPT_UI_FORCE_HIGH_PROTECTION_FLAG = @as(u32, 2);
pub const NCRYPT_UI_FINGERPRINT_PROTECTION_FLAG = @as(u32, 4);
pub const NCRYPT_UI_APPCONTAINER_ACCESS_MEDIUM_FLAG = @as(u32, 8);
pub const NCRYPT_PIN_CACHE_FREE_APPLICATION_TICKET_PROPERTY = "PinCacheFreeApplicationTicket";
pub const NCRYPT_PIN_CACHE_FLAGS_PROPERTY = "PinCacheFlags";
pub const NCRYPT_PIN_CACHE_DISABLE_DPL_FLAG = @as(u32, 1);
pub const NCRYPT_PIN_CACHE_APPLICATION_TICKET_PROPERTY = "PinCacheApplicationTicket";
pub const NCRYPT_PIN_CACHE_APPLICATION_IMAGE_PROPERTY = "PinCacheApplicationImage";
pub const NCRYPT_PIN_CACHE_APPLICATION_STATUS_PROPERTY = "PinCacheApplicationStatus";
pub const NCRYPT_PIN_CACHE_PIN_PROPERTY = "PinCachePin";
pub const NCRYPT_PIN_CACHE_IS_GESTURE_REQUIRED_PROPERTY = "PinCacheIsGestureRequired";
pub const NCRYPT_PIN_CACHE_REQUIRE_GESTURE_FLAG = @as(u32, 1);
pub const NCRYPT_PIN_CACHE_APPLICATION_TICKET_BYTE_LENGTH = @as(u32, 90);
pub const NCRYPT_PIN_CACHE_CLEAR_PROPERTY = "PinCacheClear";
pub const NCRYPT_PIN_CACHE_CLEAR_FOR_CALLING_PROCESS_OPTION = @as(u32, 1);
pub const NCRYPT_KEY_ACCESS_POLICY_VERSION = @as(u32, 1);
pub const NCRYPT_ALLOW_SILENT_KEY_ACCESS = @as(u32, 1);
pub const NCRYPT_CIPHER_KEY_BLOB_MAGIC = @as(u32, 1380470851);
pub const NCRYPT_KDF_KEY_BLOB_MAGIC = @as(u32, 826688587);
pub const NCRYPT_PROTECTED_KEY_BLOB_MAGIC = @as(u32, 1263817296);
pub const NCRYPT_CIPHER_KEY_BLOB = "CipherKeyBlob";
pub const NCRYPT_KDF_KEY_BLOB = "KDFKeyBlob";
pub const NCRYPT_PROTECTED_KEY_BLOB = "ProtectedKeyBlob";
pub const NCRYPT_TPM_LOADABLE_KEY_BLOB = "PcpTpmProtectedKeyBlob";
pub const NCRYPT_TPM_LOADABLE_KEY_BLOB_MAGIC = @as(u32, 1297371211);
pub const NCRYPT_PKCS7_ENVELOPE_BLOB = "PKCS7_ENVELOPE";
pub const NCRYPT_PKCS8_PRIVATE_KEY_BLOB = "PKCS8_PRIVATEKEY";
pub const NCRYPT_OPAQUETRANSPORT_BLOB = "OpaqueTransport";
pub const NCRYPT_ISOLATED_KEY_ENVELOPE_BLOB = "ISOLATED_KEY_ENVELOPE";
pub const NCRYPT_DESCR_DELIMITER_OR = "OR";
pub const NCRYPT_DESCR_DELIMITER_AND = "AND";
pub const NCRYPT_DESCR_EQUAL = "=";
pub const MS_KEY_PROTECTION_PROVIDER = "Microsoft Key Protection Provider";
pub const NCRYPT_KEY_PROTECTION_ALGORITHM_SID = "SID";
pub const NCRYPT_KEY_PROTECTION_ALGORITHM_LOCAL = "LOCAL";
pub const NCRYPT_KEY_PROTECTION_LOCAL_LOGON = "logon";
pub const NCRYPT_KEY_PROTECTION_LOCAL_USER = "user";
pub const NCRYPT_KEY_PROTECTION_LOCAL_MACHINE = "machine";
pub const NCRYPT_KEY_PROTECTION_ALGORITHM_SDDL = "SDDL";
pub const NCRYPT_KEY_PROTECTION_ALGORITHM_WEBCREDENTIALS = "WEBCREDENTIALS";
pub const NCRYPT_KEY_PROTECTION_ALGORITHM_LOCKEDCREDENTIALS = "LOCKEDCREDENTIALS";
pub const NCRYPT_KEY_PROTECTION_ALGORITHM_CERTIFICATE = "CERTIFICATE";
pub const NCRYPT_KEY_PROTECTION_CERT_HASHID = "HashId";
pub const NCRYPT_KEY_PROTECTION_CERT_CERTBLOB = "CertBlob";
pub const NCRYPT_NAMED_DESCRIPTOR_FLAG = @as(u32, 1);
pub const NCRYPT_PROTECTION_INFO_TYPE_DESCRIPTOR_STRING = @as(u32, 1);
pub const ALG_CLASS_ANY = @as(u32, 0);
pub const ALG_CLASS_SIGNATURE = @as(u32, 8192);
pub const ALG_CLASS_MSG_ENCRYPT = @as(u32, 16384);
pub const ALG_CLASS_DATA_ENCRYPT = @as(u32, 24576);
pub const ALG_CLASS_HASH = @as(u32, 32768);
pub const ALG_CLASS_KEY_EXCHANGE = @as(u32, 40960);
pub const ALG_CLASS_ALL = @as(u32, 57344);
pub const ALG_TYPE_ANY = @as(u32, 0);
pub const ALG_TYPE_DSS = @as(u32, 512);
pub const ALG_TYPE_RSA = @as(u32, 1024);
pub const ALG_TYPE_BLOCK = @as(u32, 1536);
pub const ALG_TYPE_STREAM = @as(u32, 2048);
pub const ALG_TYPE_DH = @as(u32, 2560);
pub const ALG_TYPE_SECURECHANNEL = @as(u32, 3072);
pub const ALG_TYPE_ECDH = @as(u32, 3584);
pub const ALG_TYPE_THIRDPARTY = @as(u32, 4096);
pub const ALG_SID_ANY = @as(u32, 0);
pub const ALG_SID_THIRDPARTY_ANY = @as(u32, 0);
pub const ALG_SID_RSA_ANY = @as(u32, 0);
pub const ALG_SID_RSA_PKCS = @as(u32, 1);
pub const ALG_SID_RSA_MSATWORK = @as(u32, 2);
pub const ALG_SID_RSA_ENTRUST = @as(u32, 3);
pub const ALG_SID_RSA_PGP = @as(u32, 4);
pub const ALG_SID_DSS_ANY = @as(u32, 0);
pub const ALG_SID_DSS_PKCS = @as(u32, 1);
pub const ALG_SID_DSS_DMS = @as(u32, 2);
pub const ALG_SID_ECDSA = @as(u32, 3);
pub const ALG_SID_DES = @as(u32, 1);
pub const ALG_SID_3DES = @as(u32, 3);
pub const ALG_SID_DESX = @as(u32, 4);
pub const ALG_SID_IDEA = @as(u32, 5);
pub const ALG_SID_CAST = @as(u32, 6);
pub const ALG_SID_SAFERSK64 = @as(u32, 7);
pub const ALG_SID_SAFERSK128 = @as(u32, 8);
pub const ALG_SID_3DES_112 = @as(u32, 9);
pub const ALG_SID_CYLINK_MEK = @as(u32, 12);
pub const ALG_SID_RC5 = @as(u32, 13);
pub const ALG_SID_AES_128 = @as(u32, 14);
pub const ALG_SID_AES_192 = @as(u32, 15);
pub const ALG_SID_AES_256 = @as(u32, 16);
pub const ALG_SID_AES = @as(u32, 17);
pub const ALG_SID_SKIPJACK = @as(u32, 10);
pub const ALG_SID_TEK = @as(u32, 11);
pub const CRYPT_MODE_CBCI = @as(u32, 6);
pub const CRYPT_MODE_CFBP = @as(u32, 7);
pub const CRYPT_MODE_OFBP = @as(u32, 8);
pub const CRYPT_MODE_CBCOFM = @as(u32, 9);
pub const CRYPT_MODE_CBCOFMI = @as(u32, 10);
pub const ALG_SID_RC2 = @as(u32, 2);
pub const ALG_SID_RC4 = @as(u32, 1);
pub const ALG_SID_SEAL = @as(u32, 2);
pub const ALG_SID_DH_SANDF = @as(u32, 1);
pub const ALG_SID_DH_EPHEM = @as(u32, 2);
pub const ALG_SID_AGREED_KEY_ANY = @as(u32, 3);
pub const ALG_SID_KEA = @as(u32, 4);
pub const ALG_SID_ECDH = @as(u32, 5);
pub const ALG_SID_ECDH_EPHEM = @as(u32, 6);
pub const ALG_SID_MD2 = @as(u32, 1);
pub const ALG_SID_MD4 = @as(u32, 2);
pub const ALG_SID_MD5 = @as(u32, 3);
pub const ALG_SID_SHA = @as(u32, 4);
pub const ALG_SID_SHA1 = @as(u32, 4);
pub const ALG_SID_MAC = @as(u32, 5);
pub const ALG_SID_RIPEMD = @as(u32, 6);
pub const ALG_SID_RIPEMD160 = @as(u32, 7);
pub const ALG_SID_SSL3SHAMD5 = @as(u32, 8);
pub const ALG_SID_HMAC = @as(u32, 9);
pub const ALG_SID_TLS1PRF = @as(u32, 10);
pub const ALG_SID_HASH_REPLACE_OWF = @as(u32, 11);
pub const ALG_SID_SHA_256 = @as(u32, 12);
pub const ALG_SID_SHA_384 = @as(u32, 13);
pub const ALG_SID_SHA_512 = @as(u32, 14);
pub const ALG_SID_SSL3_MASTER = @as(u32, 1);
pub const ALG_SID_SCHANNEL_MASTER_HASH = @as(u32, 2);
pub const ALG_SID_SCHANNEL_MAC_KEY = @as(u32, 3);
pub const ALG_SID_PCT1_MASTER = @as(u32, 4);
pub const ALG_SID_SSL2_MASTER = @as(u32, 5);
pub const ALG_SID_TLS1_MASTER = @as(u32, 6);
pub const ALG_SID_SCHANNEL_ENC_KEY = @as(u32, 7);
pub const ALG_SID_ECMQV = @as(u32, 1);
pub const ALG_SID_EXAMPLE = @as(u32, 80);
pub const SIGNATURE_RESOURCE_NUMBER = @as(u32, 666);
pub const CRYPT_VERIFYCONTEXT = @as(u32, 4026531840);
pub const CRYPT_NEWKEYSET = @as(u32, 8);
pub const CRYPT_DELETEKEYSET = @as(u32, 16);
pub const CRYPT_SILENT = @as(u32, 64);
pub const CRYPT_DEFAULT_CONTAINER_OPTIONAL = @as(u32, 128);
pub const CRYPT_UPDATE_KEY = @as(u32, 8);
pub const CRYPT_USER_PROTECTED_STRONG = @as(u32, 1048576);
pub const RSA1024BIT_KEY = @as(u32, 67108864);
pub const CRYPT_SERVER = @as(u32, 1024);
pub const KEY_LENGTH_MASK = @as(u32, 4294901760);
pub const CRYPT_DECRYPT_RSA_NO_PADDING_CHECK = @as(u32, 32);
pub const CRYPT_SECRETDIGEST = @as(u32, 1);
pub const CRYPT_OWF_REPL_LM_HASH = @as(u32, 1);
pub const CRYPT_LITTLE_ENDIAN = @as(u32, 1);
pub const CRYPT_NOHASHOID = @as(u32, 1);
pub const CRYPT_TYPE2_FORMAT = @as(u32, 2);
pub const CRYPT_X931_FORMAT = @as(u32, 4);
pub const CRYPT_MACHINE_DEFAULT = @as(u32, 1);
pub const CRYPT_USER_DEFAULT = @as(u32, 2);
pub const CRYPT_DELETE_DEFAULT = @as(u32, 4);
pub const SIMPLEBLOB = @as(u32, 1);
pub const PUBLICKEYBLOB = @as(u32, 6);
pub const PRIVATEKEYBLOB = @as(u32, 7);
pub const PLAINTEXTKEYBLOB = @as(u32, 8);
pub const OPAQUEKEYBLOB = @as(u32, 9);
pub const PUBLICKEYBLOBEX = @as(u32, 10);
pub const SYMMETRICWRAPKEYBLOB = @as(u32, 11);
pub const KEYSTATEBLOB = @as(u32, 12);
pub const CRYPT_USERDATA = @as(u32, 1);
pub const KP_IV = @as(u32, 1);
pub const KP_PADDING = @as(u32, 3);
pub const KP_MODE = @as(u32, 4);
pub const KP_MODE_BITS = @as(u32, 5);
pub const KP_P = @as(u32, 11);
pub const KP_G = @as(u32, 12);
pub const KP_Q = @as(u32, 13);
pub const KP_X = @as(u32, 14);
pub const KP_Y = @as(u32, 15);
pub const KP_RA = @as(u32, 16);
pub const KP_RB = @as(u32, 17);
pub const KP_INFO = @as(u32, 18);
pub const KP_EFFECTIVE_KEYLEN = @as(u32, 19);
pub const KP_SCHANNEL_ALG = @as(u32, 20);
pub const KP_CLIENT_RANDOM = @as(u32, 21);
pub const KP_SERVER_RANDOM = @as(u32, 22);
pub const KP_RP = @as(u32, 23);
pub const KP_PRECOMP_MD5 = @as(u32, 24);
pub const KP_PRECOMP_SHA = @as(u32, 25);
pub const KP_CLEAR_KEY = @as(u32, 27);
pub const KP_PUB_EX_LEN = @as(u32, 28);
pub const KP_PUB_EX_VAL = @as(u32, 29);
pub const KP_KEYVAL = @as(u32, 30);
pub const KP_ADMIN_PIN = @as(u32, 31);
pub const KP_KEYEXCHANGE_PIN = @as(u32, 32);
pub const KP_SIGNATURE_PIN = @as(u32, 33);
pub const KP_PREHASH = @as(u32, 34);
pub const KP_ROUNDS = @as(u32, 35);
pub const KP_OAEP_PARAMS = @as(u32, 36);
pub const KP_CMS_KEY_INFO = @as(u32, 37);
pub const KP_CMS_DH_KEY_INFO = @as(u32, 38);
pub const KP_PUB_PARAMS = @as(u32, 39);
pub const KP_VERIFY_PARAMS = @as(u32, 40);
pub const KP_HIGHEST_VERSION = @as(u32, 41);
pub const KP_PIN_ID = @as(u32, 43);
pub const KP_PIN_INFO = @as(u32, 44);
pub const PKCS5_PADDING = @as(u32, 1);
pub const RANDOM_PADDING = @as(u32, 2);
pub const ZERO_PADDING = @as(u32, 3);
pub const CRYPT_MODE_CBC = @as(u32, 1);
pub const CRYPT_MODE_ECB = @as(u32, 2);
pub const CRYPT_MODE_OFB = @as(u32, 3);
pub const CRYPT_MODE_CFB = @as(u32, 4);
pub const CRYPT_MODE_CTS = @as(u32, 5);
pub const CRYPT_ENCRYPT = @as(u32, 1);
pub const CRYPT_DECRYPT = @as(u32, 2);
pub const CRYPT_EXPORT = @as(u32, 4);
pub const CRYPT_READ = @as(u32, 8);
pub const CRYPT_WRITE = @as(u32, 16);
pub const CRYPT_MAC = @as(u32, 32);
pub const CRYPT_EXPORT_KEY = @as(u32, 64);
pub const CRYPT_IMPORT_KEY = @as(u32, 128);
pub const CRYPT_ARCHIVE = @as(u32, 256);
pub const HP_ALGID = @as(u32, 1);
pub const HP_HASHSIZE = @as(u32, 4);
pub const HP_TLS1PRF_LABEL = @as(u32, 6);
pub const HP_TLS1PRF_SEED = @as(u32, 7);
pub const CRYPT_FAILED = @as(u32, 0);
pub const CRYPT_SUCCEED = @as(u32, 1);
pub const PP_ENUMALGS = @as(u32, 1);
pub const PP_ENUMCONTAINERS = @as(u32, 2);
pub const PP_IMPTYPE = @as(u32, 3);
pub const PP_NAME = @as(u32, 4);
pub const PP_VERSION = @as(u32, 5);
pub const PP_CONTAINER = @as(u32, 6);
pub const PP_CHANGE_PASSWORD = @as(u32, 7);
pub const PP_CERTCHAIN = @as(u32, 9);
pub const PP_KEY_TYPE_SUBTYPE = @as(u32, 10);
pub const PP_PROVTYPE = @as(u32, 16);
pub const PP_KEYSTORAGE = @as(u32, 17);
pub const PP_APPLI_CERT = @as(u32, 18);
pub const PP_SYM_KEYSIZE = @as(u32, 19);
pub const PP_SESSION_KEYSIZE = @as(u32, 20);
pub const PP_ENUMALGS_EX = @as(u32, 22);
pub const PP_ENUMMANDROOTS = @as(u32, 25);
pub const PP_ENUMELECTROOTS = @as(u32, 26);
pub const PP_KEYSET_TYPE = @as(u32, 27);
pub const PP_ADMIN_PIN = @as(u32, 31);
pub const PP_SIG_KEYSIZE_INC = @as(u32, 34);
pub const PP_KEYX_KEYSIZE_INC = @as(u32, 35);
pub const PP_UNIQUE_CONTAINER = @as(u32, 36);
pub const PP_SGC_INFO = @as(u32, 37);
pub const PP_KEYSPEC = @as(u32, 39);
pub const PP_ENUMEX_SIGNING_PROT = @as(u32, 40);
pub const PP_CRYPT_COUNT_KEY_USE = @as(u32, 41);
pub const PP_SMARTCARD_GUID = @as(u32, 45);
pub const PP_SMARTCARD_READER_ICON = @as(u32, 47);
pub const CRYPT_FIRST = @as(u32, 1);
pub const CRYPT_NEXT = @as(u32, 2);
pub const CRYPT_SGC_ENUM = @as(u32, 4);
pub const CRYPT_IMPL_HARDWARE = @as(u32, 1);
pub const CRYPT_IMPL_SOFTWARE = @as(u32, 2);
pub const CRYPT_IMPL_MIXED = @as(u32, 3);
pub const CRYPT_IMPL_UNKNOWN = @as(u32, 4);
pub const CRYPT_IMPL_REMOVABLE = @as(u32, 8);
pub const CRYPT_SEC_DESCR = @as(u32, 1);
pub const CRYPT_PSTORE = @as(u32, 2);
pub const CRYPT_UI_PROMPT = @as(u32, 4);
pub const CRYPT_FLAG_PCT1 = @as(u32, 1);
pub const CRYPT_FLAG_SSL2 = @as(u32, 2);
pub const CRYPT_FLAG_SSL3 = @as(u32, 4);
pub const CRYPT_FLAG_TLS1 = @as(u32, 8);
pub const CRYPT_FLAG_IPSEC = @as(u32, 16);
pub const CRYPT_FLAG_SIGNING = @as(u32, 32);
pub const CRYPT_SGC = @as(u32, 1);
pub const CRYPT_FASTSGC = @as(u32, 2);
pub const PP_CONTEXT_INFO = @as(u32, 11);
pub const PP_DISMISS_PIN_UI_SEC = @as(u32, 49);
pub const PROV_RSA_FULL = @as(u32, 1);
pub const PROV_RSA_SIG = @as(u32, 2);
pub const PROV_DSS = @as(u32, 3);
pub const PROV_FORTEZZA = @as(u32, 4);
pub const PROV_MS_EXCHANGE = @as(u32, 5);
pub const PROV_SSL = @as(u32, 6);
pub const PROV_RSA_SCHANNEL = @as(u32, 12);
pub const PROV_DSS_DH = @as(u32, 13);
pub const PROV_EC_ECDSA_SIG = @as(u32, 14);
pub const PROV_EC_ECNRA_SIG = @as(u32, 15);
pub const PROV_EC_ECDSA_FULL = @as(u32, 16);
pub const PROV_EC_ECNRA_FULL = @as(u32, 17);
pub const PROV_DH_SCHANNEL = @as(u32, 18);
pub const PROV_SPYRUS_LYNKS = @as(u32, 20);
pub const PROV_RNG = @as(u32, 21);
pub const PROV_INTEL_SEC = @as(u32, 22);
pub const PROV_REPLACE_OWF = @as(u32, 23);
pub const PROV_RSA_AES = @as(u32, 24);
pub const PROV_STT_MER = @as(u32, 7);
pub const PROV_STT_ACQ = @as(u32, 8);
pub const PROV_STT_BRND = @as(u32, 9);
pub const PROV_STT_ROOT = @as(u32, 10);
pub const PROV_STT_ISS = @as(u32, 11);
pub const MS_DEF_PROV_A = "Microsoft Base Cryptographic Provider v1.0";
pub const MS_DEF_PROV_W = "Microsoft Base Cryptographic Provider v1.0";
pub const MS_DEF_PROV = "Microsoft Base Cryptographic Provider v1.0";
pub const MS_ENHANCED_PROV_A = "Microsoft Enhanced Cryptographic Provider v1.0";
pub const MS_ENHANCED_PROV_W = "Microsoft Enhanced Cryptographic Provider v1.0";
pub const MS_ENHANCED_PROV = "Microsoft Enhanced Cryptographic Provider v1.0";
pub const MS_STRONG_PROV_A = "Microsoft Strong Cryptographic Provider";
pub const MS_STRONG_PROV_W = "Microsoft Strong Cryptographic Provider";
pub const MS_STRONG_PROV = "Microsoft Strong Cryptographic Provider";
pub const MS_DEF_RSA_SIG_PROV_A = "Microsoft RSA Signature Cryptographic Provider";
pub const MS_DEF_RSA_SIG_PROV_W = "Microsoft RSA Signature Cryptographic Provider";
pub const MS_DEF_RSA_SIG_PROV = "Microsoft RSA Signature Cryptographic Provider";
pub const MS_DEF_RSA_SCHANNEL_PROV_A = "Microsoft RSA SChannel Cryptographic Provider";
pub const MS_DEF_RSA_SCHANNEL_PROV_W = "Microsoft RSA SChannel Cryptographic Provider";
pub const MS_DEF_RSA_SCHANNEL_PROV = "Microsoft RSA SChannel Cryptographic Provider";
pub const MS_DEF_DSS_PROV_A = "Microsoft Base DSS Cryptographic Provider";
pub const MS_DEF_DSS_PROV_W = "Microsoft Base DSS Cryptographic Provider";
pub const MS_DEF_DSS_PROV = "Microsoft Base DSS Cryptographic Provider";
pub const MS_DEF_DSS_DH_PROV_A = "Microsoft Base DSS and Diffie-Hellman Cryptographic Provider";
pub const MS_DEF_DSS_DH_PROV_W = "Microsoft Base DSS and Diffie-Hellman Cryptographic Provider";
pub const MS_DEF_DSS_DH_PROV = "Microsoft Base DSS and Diffie-Hellman Cryptographic Provider";
pub const MS_ENH_DSS_DH_PROV_A = "Microsoft Enhanced DSS and Diffie-Hellman Cryptographic Provider";
pub const MS_ENH_DSS_DH_PROV_W = "Microsoft Enhanced DSS and Diffie-Hellman Cryptographic Provider";
pub const MS_ENH_DSS_DH_PROV = "Microsoft Enhanced DSS and Diffie-Hellman Cryptographic Provider";
pub const MS_DEF_DH_SCHANNEL_PROV_A = "Microsoft DH SChannel Cryptographic Provider";
pub const MS_DEF_DH_SCHANNEL_PROV_W = "Microsoft DH SChannel Cryptographic Provider";
pub const MS_DEF_DH_SCHANNEL_PROV = "Microsoft DH SChannel Cryptographic Provider";
pub const MS_SCARD_PROV_A = "Microsoft Base Smart Card Crypto Provider";
pub const MS_SCARD_PROV_W = "Microsoft Base Smart Card Crypto Provider";
pub const MS_SCARD_PROV = "Microsoft Base Smart Card Crypto Provider";
pub const MS_ENH_RSA_AES_PROV_A = "Microsoft Enhanced RSA and AES Cryptographic Provider";
pub const MS_ENH_RSA_AES_PROV_W = "Microsoft Enhanced RSA and AES Cryptographic Provider";
pub const MS_ENH_RSA_AES_PROV_XP_A = "Microsoft Enhanced RSA and AES Cryptographic Provider (Prototype)";
pub const MS_ENH_RSA_AES_PROV_XP_W = "Microsoft Enhanced RSA and AES Cryptographic Provider (Prototype)";
pub const MS_ENH_RSA_AES_PROV_XP = "Microsoft Enhanced RSA and AES Cryptographic Provider (Prototype)";
pub const MS_ENH_RSA_AES_PROV = "Microsoft Enhanced RSA and AES Cryptographic Provider";
pub const MAXUIDLEN = @as(u32, 64);
pub const EXPO_OFFLOAD_REG_VALUE = "ExpoOffload";
pub const EXPO_OFFLOAD_FUNC_NAME = "OffloadModExpo";
pub const szKEY_CRYPTOAPI_PRIVATE_KEY_OPTIONS = "Software\\Policies\\Microsoft\\Cryptography";
pub const szKEY_CACHE_ENABLED = "CachePrivateKeys";
pub const szKEY_CACHE_SECONDS = "PrivateKeyLifetimeSeconds";
pub const szPRIV_KEY_CACHE_MAX_ITEMS = "PrivKeyCacheMaxItems";
pub const cPRIV_KEY_CACHE_MAX_ITEMS_DEFAULT = @as(u32, 20);
pub const szPRIV_KEY_CACHE_PURGE_INTERVAL_SECONDS = "PrivKeyCachePurgeIntervalSeconds";
pub const cPRIV_KEY_CACHE_PURGE_INTERVAL_SECONDS_DEFAULT = @as(u32, 86400);
pub const CUR_BLOB_VERSION = @as(u32, 2);
pub const SCHANNEL_MAC_KEY = @as(u32, 0);
pub const SCHANNEL_ENC_KEY = @as(u32, 1);
pub const INTERNATIONAL_USAGE = @as(u32, 1);
pub const szOID_RSA = "1.2.840.113549";
pub const szOID_PKCS = "1.2.840.113549.1";
pub const szOID_RSA_HASH = "1.2.840.113549.2";
pub const szOID_RSA_ENCRYPT = "1.2.840.113549.3";
pub const szOID_PKCS_1 = "1.2.840.113549.1.1";
pub const szOID_PKCS_2 = "1.2.840.113549.1.2";
pub const szOID_PKCS_3 = "1.2.840.113549.1.3";
pub const szOID_PKCS_4 = "1.2.840.113549.1.4";
pub const szOID_PKCS_5 = "1.2.840.113549.1.5";
pub const szOID_PKCS_6 = "1.2.840.113549.1.6";
pub const szOID_PKCS_7 = "1.2.840.113549.1.7";
pub const szOID_PKCS_8 = "1.2.840.113549.1.8";
pub const szOID_PKCS_9 = "1.2.840.113549.1.9";
pub const szOID_PKCS_10 = "1.2.840.113549.1.10";
pub const szOID_PKCS_12 = "1.2.840.113549.1.12";
pub const szOID_RSA_RSA = "1.2.840.113549.1.1.1";
pub const szOID_RSA_MD2RSA = "1.2.840.113549.1.1.2";
pub const szOID_RSA_MD4RSA = "1.2.840.113549.1.1.3";
pub const szOID_RSA_MD5RSA = "1.2.840.113549.1.1.4";
pub const szOID_RSA_SHA1RSA = "1.2.840.113549.1.1.5";
pub const szOID_RSA_SETOAEP_RSA = "1.2.840.113549.1.1.6";
pub const szOID_RSAES_OAEP = "1.2.840.113549.1.1.7";
pub const szOID_RSA_MGF1 = "1.2.840.113549.1.1.8";
pub const szOID_RSA_PSPECIFIED = "1.2.840.113549.1.1.9";
pub const szOID_RSA_SSA_PSS = "1.2.840.113549.1.1.10";
pub const szOID_RSA_SHA256RSA = "1.2.840.113549.1.1.11";
pub const szOID_RSA_SHA384RSA = "1.2.840.113549.1.1.12";
pub const szOID_RSA_SHA512RSA = "1.2.840.113549.1.1.13";
pub const szOID_RSA_DH = "1.2.840.113549.1.3.1";
pub const szOID_RSA_data = "1.2.840.113549.1.7.1";
pub const szOID_RSA_signedData = "1.2.840.113549.1.7.2";
pub const szOID_RSA_envelopedData = "1.2.840.113549.1.7.3";
pub const szOID_RSA_signEnvData = "1.2.840.113549.1.7.4";
pub const szOID_RSA_digestedData = "1.2.840.113549.1.7.5";
pub const szOID_RSA_hashedData = "1.2.840.113549.1.7.5";
pub const szOID_RSA_encryptedData = "1.2.840.113549.1.7.6";
pub const szOID_RSA_emailAddr = "1.2.840.113549.1.9.1";
pub const szOID_RSA_unstructName = "1.2.840.113549.1.9.2";
pub const szOID_RSA_contentType = "1.2.840.113549.1.9.3";
pub const szOID_RSA_messageDigest = "1.2.840.113549.1.9.4";
pub const szOID_RSA_signingTime = "1.2.840.113549.1.9.5";
pub const szOID_RSA_counterSign = "1.2.840.113549.1.9.6";
pub const szOID_RSA_challengePwd = "1.2.840.113549.1.9.7";
pub const szOID_RSA_unstructAddr = "1.2.840.113549.1.9.8";
pub const szOID_RSA_extCertAttrs = "1.2.840.113549.1.9.9";
pub const szOID_RSA_certExtensions = "1.2.840.113549.1.9.14";
pub const szOID_RSA_SMIMECapabilities = "1.2.840.113549.1.9.15";
pub const szOID_RSA_preferSignedData = "1.2.840.113549.1.9.15.1";
pub const szOID_TIMESTAMP_TOKEN = "1.2.840.113549.1.9.16.1.4";
pub const szOID_RFC3161_counterSign = "1.3.6.1.4.1.311.3.3.1";
pub const szOID_RSA_SMIMEalg = "1.2.840.113549.1.9.16.3";
pub const szOID_RSA_SMIMEalgESDH = "1.2.840.113549.1.9.16.3.5";
pub const szOID_RSA_SMIMEalgCMS3DESwrap = "1.2.840.113549.1.9.16.3.6";
pub const szOID_RSA_SMIMEalgCMSRC2wrap = "1.2.840.113549.1.9.16.3.7";
pub const szOID_RSA_MD2 = "1.2.840.113549.2.2";
pub const szOID_RSA_MD4 = "1.2.840.113549.2.4";
pub const szOID_RSA_MD5 = "1.2.840.113549.2.5";
pub const szOID_RSA_RC2CBC = "1.2.840.113549.3.2";
pub const szOID_RSA_RC4 = "1.2.840.113549.3.4";
pub const szOID_RSA_DES_EDE3_CBC = "1.2.840.113549.3.7";
pub const szOID_RSA_RC5_CBCPad = "1.2.840.113549.3.9";
pub const szOID_ANSI_X942 = "1.2.840.10046";
pub const szOID_ANSI_X942_DH = "1.2.840.10046.2.1";
pub const szOID_X957 = "1.2.840.10040";
pub const szOID_X957_DSA = "1.2.840.10040.4.1";
pub const szOID_X957_SHA1DSA = "1.2.840.10040.4.3";
pub const szOID_ECC_PUBLIC_KEY = "1.2.840.10045.2.1";
pub const szOID_ECC_CURVE_P256 = "1.2.840.10045.3.1.7";
pub const szOID_ECC_CURVE_P384 = "1.3.132.0.34";
pub const szOID_ECC_CURVE_P521 = "1.3.132.0.35";
pub const szOID_ECC_CURVE_BRAINPOOLP160R1 = "1.3.36.3.3.2.8.1.1.1";
pub const szOID_ECC_CURVE_BRAINPOOLP160T1 = "1.3.36.3.3.2.8.1.1.2";
pub const szOID_ECC_CURVE_BRAINPOOLP192R1 = "1.3.36.3.3.2.8.1.1.3";
pub const szOID_ECC_CURVE_BRAINPOOLP192T1 = "1.3.36.3.3.2.8.1.1.4";
pub const szOID_ECC_CURVE_BRAINPOOLP224R1 = "1.3.36.3.3.2.8.1.1.5";
pub const szOID_ECC_CURVE_BRAINPOOLP224T1 = "1.3.36.3.3.2.8.1.1.6";
pub const szOID_ECC_CURVE_BRAINPOOLP256R1 = "1.3.36.3.3.2.8.1.1.7";
pub const szOID_ECC_CURVE_BRAINPOOLP256T1 = "1.3.36.3.3.2.8.1.1.8";
pub const szOID_ECC_CURVE_BRAINPOOLP320R1 = "1.3.36.3.3.2.8.1.1.9";
pub const szOID_ECC_CURVE_BRAINPOOLP320T1 = "1.3.36.3.3.2.8.1.1.10";
pub const szOID_ECC_CURVE_BRAINPOOLP384R1 = "1.3.36.3.3.2.8.1.1.11";
pub const szOID_ECC_CURVE_BRAINPOOLP384T1 = "1.3.36.3.3.2.8.1.1.12";
pub const szOID_ECC_CURVE_BRAINPOOLP512R1 = "1.3.36.3.3.2.8.1.1.13";
pub const szOID_ECC_CURVE_BRAINPOOLP512T1 = "1.3.36.3.3.2.8.1.1.14";
pub const szOID_ECC_CURVE_EC192WAPI = "1.2.156.11235.1.1.2.1";
pub const szOID_CN_ECDSA_SHA256 = "1.2.156.11235.1.1.1";
pub const szOID_ECC_CURVE_NISTP192 = "1.2.840.10045.3.1.1";
pub const szOID_ECC_CURVE_NISTP224 = "1.3.132.0.33";
pub const szOID_ECC_CURVE_NISTP256 = "1.2.840.10045.3.1.7";
pub const szOID_ECC_CURVE_NISTP384 = "1.3.132.0.34";
pub const szOID_ECC_CURVE_NISTP521 = "1.3.132.0.35";
pub const szOID_ECC_CURVE_SECP160K1 = "1.3.132.0.9";
pub const szOID_ECC_CURVE_SECP160R1 = "1.3.132.0.8";
pub const szOID_ECC_CURVE_SECP160R2 = "1.3.132.0.30";
pub const szOID_ECC_CURVE_SECP192K1 = "1.3.132.0.31";
pub const szOID_ECC_CURVE_SECP192R1 = "1.2.840.10045.3.1.1";
pub const szOID_ECC_CURVE_SECP224K1 = "1.3.132.0.32";
pub const szOID_ECC_CURVE_SECP224R1 = "1.3.132.0.33";
pub const szOID_ECC_CURVE_SECP256K1 = "1.3.132.0.10";
pub const szOID_ECC_CURVE_SECP256R1 = "1.2.840.10045.3.1.7";
pub const szOID_ECC_CURVE_SECP384R1 = "1.3.132.0.34";
pub const szOID_ECC_CURVE_SECP521R1 = "1.3.132.0.35";
pub const szOID_ECC_CURVE_WTLS7 = "1.3.132.0.30";
pub const szOID_ECC_CURVE_WTLS9 = "2.23.43.1.4.9";
pub const szOID_ECC_CURVE_WTLS12 = "1.3.132.0.33";
pub const szOID_ECC_CURVE_X962P192V1 = "1.2.840.10045.3.1.1";
pub const szOID_ECC_CURVE_X962P192V2 = "1.2.840.10045.3.1.2";
pub const szOID_ECC_CURVE_X962P192V3 = "1.2.840.10045.3.1.3";
pub const szOID_ECC_CURVE_X962P239V1 = "1.2.840.10045.3.1.4";
pub const szOID_ECC_CURVE_X962P239V2 = "1.2.840.10045.3.1.5";
pub const szOID_ECC_CURVE_X962P239V3 = "1.2.840.10045.3.1.6";
pub const szOID_ECC_CURVE_X962P256V1 = "1.2.840.10045.3.1.7";
pub const szOID_ECDSA_SHA1 = "1.2.840.10045.4.1";
pub const szOID_ECDSA_SPECIFIED = "1.2.840.10045.4.3";
pub const szOID_ECDSA_SHA256 = "1.2.840.10045.4.3.2";
pub const szOID_ECDSA_SHA384 = "1.2.840.10045.4.3.3";
pub const szOID_ECDSA_SHA512 = "1.2.840.10045.4.3.4";
pub const szOID_NIST_AES128_CBC = "2.16.840.1.101.3.4.1.2";
pub const szOID_NIST_AES192_CBC = "2.16.840.1.101.3.4.1.22";
pub const szOID_NIST_AES256_CBC = "2.16.840.1.101.3.4.1.42";
pub const szOID_NIST_AES128_WRAP = "2.16.840.1.101.3.4.1.5";
pub const szOID_NIST_AES192_WRAP = "2.16.840.1.101.3.4.1.25";
pub const szOID_NIST_AES256_WRAP = "2.16.840.1.101.3.4.1.45";
pub const szOID_DH_SINGLE_PASS_STDDH_SHA1_KDF = "1.3.133.16.840.63.0.2";
pub const szOID_DH_SINGLE_PASS_STDDH_SHA256_KDF = "1.3.132.1.11.1";
pub const szOID_DH_SINGLE_PASS_STDDH_SHA384_KDF = "1.3.132.1.11.2";
pub const szOID_DS = "2.5";
pub const szOID_DSALG = "2.5.8";
pub const szOID_DSALG_CRPT = "2.5.8.1";
pub const szOID_DSALG_HASH = "2.5.8.2";
pub const szOID_DSALG_SIGN = "2.5.8.3";
pub const szOID_DSALG_RSA = "2.5.8.1.1";
pub const szOID_OIW = "1.3.14";
pub const szOID_OIWSEC = "1.3.14.3.2";
pub const szOID_OIWSEC_md4RSA = "1.3.14.3.2.2";
pub const szOID_OIWSEC_md5RSA = "1.3.14.3.2.3";
pub const szOID_OIWSEC_md4RSA2 = "1.3.14.3.2.4";
pub const szOID_OIWSEC_desECB = "1.3.14.3.2.6";
pub const szOID_OIWSEC_desCBC = "1.3.14.3.2.7";
pub const szOID_OIWSEC_desOFB = "1.3.14.3.2.8";
pub const szOID_OIWSEC_desCFB = "1.3.14.3.2.9";
pub const szOID_OIWSEC_desMAC = "1.3.14.3.2.10";
pub const szOID_OIWSEC_rsaSign = "1.3.14.3.2.11";
pub const szOID_OIWSEC_dsa = "1.3.14.3.2.12";
pub const szOID_OIWSEC_shaDSA = "1.3.14.3.2.13";
pub const szOID_OIWSEC_mdc2RSA = "1.3.14.3.2.14";
pub const szOID_OIWSEC_shaRSA = "1.3.14.3.2.15";
pub const szOID_OIWSEC_dhCommMod = "1.3.14.3.2.16";
pub const szOID_OIWSEC_desEDE = "1.3.14.3.2.17";
pub const szOID_OIWSEC_sha = "1.3.14.3.2.18";
pub const szOID_OIWSEC_mdc2 = "1.3.14.3.2.19";
pub const szOID_OIWSEC_dsaComm = "1.3.14.3.2.20";
pub const szOID_OIWSEC_dsaCommSHA = "1.3.14.3.2.21";
pub const szOID_OIWSEC_rsaXchg = "1.3.14.3.2.22";
pub const szOID_OIWSEC_keyHashSeal = "1.3.14.3.2.23";
pub const szOID_OIWSEC_md2RSASign = "1.3.14.3.2.24";
pub const szOID_OIWSEC_md5RSASign = "1.3.14.3.2.25";
pub const szOID_OIWSEC_sha1 = "1.3.14.3.2.26";
pub const szOID_OIWSEC_dsaSHA1 = "1.3.14.3.2.27";
pub const szOID_OIWSEC_dsaCommSHA1 = "1.3.14.3.2.28";
pub const szOID_OIWSEC_sha1RSASign = "1.3.14.3.2.29";
pub const szOID_OIWDIR = "1.3.14.7.2";
pub const szOID_OIWDIR_CRPT = "1.3.14.7.2.1";
pub const szOID_OIWDIR_HASH = "1.3.14.7.2.2";
pub const szOID_OIWDIR_SIGN = "1.3.14.7.2.3";
pub const szOID_OIWDIR_md2 = "1.3.14.7.2.2.1";
pub const szOID_OIWDIR_md2RSA = "1.3.14.7.2.3.1";
pub const szOID_INFOSEC = "2.16.840.1.101.2.1";
pub const szOID_INFOSEC_sdnsSignature = "2.16.840.1.101.2.1.1.1";
pub const szOID_INFOSEC_mosaicSignature = "2.16.840.1.101.2.1.1.2";
pub const szOID_INFOSEC_sdnsConfidentiality = "2.16.840.1.101.2.1.1.3";
pub const szOID_INFOSEC_mosaicConfidentiality = "2.16.840.1.101.2.1.1.4";
pub const szOID_INFOSEC_sdnsIntegrity = "2.16.840.1.101.2.1.1.5";
pub const szOID_INFOSEC_mosaicIntegrity = "2.16.840.1.101.2.1.1.6";
pub const szOID_INFOSEC_sdnsTokenProtection = "2.16.840.1.101.2.1.1.7";
pub const szOID_INFOSEC_mosaicTokenProtection = "2.16.840.1.101.2.1.1.8";
pub const szOID_INFOSEC_sdnsKeyManagement = "2.16.840.1.101.2.1.1.9";
pub const szOID_INFOSEC_mosaicKeyManagement = "2.16.840.1.101.2.1.1.10";
pub const szOID_INFOSEC_sdnsKMandSig = "2.16.840.1.101.2.1.1.11";
pub const szOID_INFOSEC_mosaicKMandSig = "2.16.840.1.101.2.1.1.12";
pub const szOID_INFOSEC_SuiteASignature = "2.16.840.1.101.2.1.1.13";
pub const szOID_INFOSEC_SuiteAConfidentiality = "2.16.840.1.101.2.1.1.14";
pub const szOID_INFOSEC_SuiteAIntegrity = "2.16.840.1.101.2.1.1.15";
pub const szOID_INFOSEC_SuiteATokenProtection = "2.16.840.1.101.2.1.1.16";
pub const szOID_INFOSEC_SuiteAKeyManagement = "2.16.840.1.101.2.1.1.17";
pub const szOID_INFOSEC_SuiteAKMandSig = "2.16.840.1.101.2.1.1.18";
pub const szOID_INFOSEC_mosaicUpdatedSig = "2.16.840.1.101.2.1.1.19";
pub const szOID_INFOSEC_mosaicKMandUpdSig = "2.16.840.1.101.2.1.1.20";
pub const szOID_INFOSEC_mosaicUpdatedInteg = "2.16.840.1.101.2.1.1.21";
pub const szOID_NIST_sha256 = "2.16.840.1.101.3.4.2.1";
pub const szOID_NIST_sha384 = "2.16.840.1.101.3.4.2.2";
pub const szOID_NIST_sha512 = "2.16.840.1.101.3.4.2.3";
pub const szOID_COMMON_NAME = "2.5.4.3";
pub const szOID_SUR_NAME = "2.5.4.4";
pub const szOID_DEVICE_SERIAL_NUMBER = "2.5.4.5";
pub const szOID_COUNTRY_NAME = "2.5.4.6";
pub const szOID_LOCALITY_NAME = "2.5.4.7";
pub const szOID_STATE_OR_PROVINCE_NAME = "2.5.4.8";
pub const szOID_STREET_ADDRESS = "2.5.4.9";
pub const szOID_ORGANIZATION_NAME = "2.5.4.10";
pub const szOID_ORGANIZATIONAL_UNIT_NAME = "2.5.4.11";
pub const szOID_TITLE = "2.5.4.12";
pub const szOID_DESCRIPTION = "2.5.4.13";
pub const szOID_SEARCH_GUIDE = "2.5.4.14";
pub const szOID_BUSINESS_CATEGORY = "2.5.4.15";
pub const szOID_POSTAL_ADDRESS = "2.5.4.16";
pub const szOID_POSTAL_CODE = "2.5.4.17";
pub const szOID_POST_OFFICE_BOX = "2.5.4.18";
pub const szOID_PHYSICAL_DELIVERY_OFFICE_NAME = "2.5.4.19";
pub const szOID_TELEPHONE_NUMBER = "2.5.4.20";
pub const szOID_TELEX_NUMBER = "2.5.4.21";
pub const szOID_TELETEXT_TERMINAL_IDENTIFIER = "2.5.4.22";
pub const szOID_FACSIMILE_TELEPHONE_NUMBER = "2.5.4.23";
pub const szOID_X21_ADDRESS = "2.5.4.24";
pub const szOID_INTERNATIONAL_ISDN_NUMBER = "2.5.4.25";
pub const szOID_REGISTERED_ADDRESS = "2.5.4.26";
pub const szOID_DESTINATION_INDICATOR = "2.5.4.27";
pub const szOID_PREFERRED_DELIVERY_METHOD = "2.5.4.28";
pub const szOID_PRESENTATION_ADDRESS = "2.5.4.29";
pub const szOID_SUPPORTED_APPLICATION_CONTEXT = "2.5.4.30";
pub const szOID_MEMBER = "2.5.4.31";
pub const szOID_OWNER = "2.5.4.32";
pub const szOID_ROLE_OCCUPANT = "2.5.4.33";
pub const szOID_SEE_ALSO = "2.5.4.34";
pub const szOID_USER_PASSWORD = "2.5.4.35";
pub const szOID_USER_CERTIFICATE = "2.5.4.36";
pub const szOID_CA_CERTIFICATE = "2.5.4.37";
pub const szOID_AUTHORITY_REVOCATION_LIST = "2.5.4.38";
pub const szOID_CERTIFICATE_REVOCATION_LIST = "2.5.4.39";
pub const szOID_CROSS_CERTIFICATE_PAIR = "2.5.4.40";
pub const szOID_GIVEN_NAME = "2.5.4.42";
pub const szOID_INITIALS = "2.5.4.43";
pub const szOID_DN_QUALIFIER = "2.5.4.46";
pub const szOID_DOMAIN_COMPONENT = "0.9.2342.19200300.100.1.25";
pub const szOID_PKCS_12_FRIENDLY_NAME_ATTR = "1.2.840.113549.1.9.20";
pub const szOID_PKCS_12_LOCAL_KEY_ID = "1.2.840.113549.1.9.21";
pub const szOID_PKCS_12_KEY_PROVIDER_NAME_ATTR = "1.3.6.1.4.1.311.17.1";
pub const szOID_LOCAL_MACHINE_KEYSET = "1.3.6.1.4.1.311.17.2";
pub const szOID_PKCS_12_EXTENDED_ATTRIBUTES = "1.3.6.1.4.1.311.17.3";
pub const szOID_PKCS_12_PROTECTED_PASSWORD_SECRET_BAG_TYPE_ID = "1.3.6.1.4.1.311.17.4";
pub const szOID_KEYID_RDN = "1.3.6.1.4.1.311.10.7.1";
pub const szOID_EV_RDN_LOCALE = "1.3.6.1.4.1.311.60.2.1.1";
pub const szOID_EV_RDN_STATE_OR_PROVINCE = "1.3.6.1.4.1.311.60.2.1.2";
pub const szOID_EV_RDN_COUNTRY = "1.3.6.1.4.1.311.60.2.1.3";
pub const CERT_RDN_TYPE_MASK = @as(u32, 255);
pub const CERT_RDN_FLAGS_MASK = @as(u32, 4278190080);
pub const CERT_RDN_ENABLE_T61_UNICODE_FLAG = @as(u32, 2147483648);
pub const CERT_RDN_ENABLE_UTF8_UNICODE_FLAG = @as(u32, 536870912);
pub const CERT_RDN_FORCE_UTF8_UNICODE_FLAG = @as(u32, 268435456);
pub const CERT_RDN_DISABLE_CHECK_TYPE_FLAG = @as(u32, 1073741824);
pub const CERT_RDN_DISABLE_IE4_UTF8_FLAG = @as(u32, 16777216);
pub const CERT_RDN_ENABLE_PUNYCODE_FLAG = @as(u32, 33554432);
pub const CERT_RSA_PUBLIC_KEY_OBJID = "1.2.840.113549.1.1.1";
pub const CERT_DEFAULT_OID_PUBLIC_KEY_SIGN = "1.2.840.113549.1.1.1";
pub const CERT_DEFAULT_OID_PUBLIC_KEY_XCHG = "1.2.840.113549.1.1.1";
pub const CRYPT_ECC_PRIVATE_KEY_INFO_v1 = @as(u32, 1);
pub const CERT_V1 = @as(u32, 0);
pub const CERT_V2 = @as(u32, 1);
pub const CERT_V3 = @as(u32, 2);
pub const CERT_INFO_VERSION_FLAG = @as(u32, 1);
pub const CERT_INFO_SERIAL_NUMBER_FLAG = @as(u32, 2);
pub const CERT_INFO_SIGNATURE_ALGORITHM_FLAG = @as(u32, 3);
pub const CERT_INFO_ISSUER_FLAG = @as(u32, 4);
pub const CERT_INFO_NOT_BEFORE_FLAG = @as(u32, 5);
pub const CERT_INFO_NOT_AFTER_FLAG = @as(u32, 6);
pub const CERT_INFO_SUBJECT_FLAG = @as(u32, 7);
pub const CERT_INFO_SUBJECT_PUBLIC_KEY_INFO_FLAG = @as(u32, 8);
pub const CERT_INFO_ISSUER_UNIQUE_ID_FLAG = @as(u32, 9);
pub const CERT_INFO_SUBJECT_UNIQUE_ID_FLAG = @as(u32, 10);
pub const CERT_INFO_EXTENSION_FLAG = @as(u32, 11);
pub const CRL_V1 = @as(u32, 0);
pub const CRL_V2 = @as(u32, 1);
pub const CERT_BUNDLE_CERTIFICATE = @as(u32, 0);
pub const CERT_BUNDLE_CRL = @as(u32, 1);
pub const CERT_REQUEST_V1 = @as(u32, 0);
pub const CERT_KEYGEN_REQUEST_V1 = @as(u32, 0);
pub const CTL_V1 = @as(u32, 0);
pub const CERT_ENCODING_TYPE_MASK = @as(u32, 65535);
pub const CMSG_ENCODING_TYPE_MASK = @as(u32, 4294901760);
pub const CRYPT_ASN_ENCODING = @as(u32, 1);
pub const CRYPT_NDR_ENCODING = @as(u32, 2);
pub const X509_NDR_ENCODING = @as(u32, 2);
pub const PKCS_7_NDR_ENCODING = @as(u32, 131072);
pub const CRYPT_FORMAT_STR_MULTI_LINE = @as(u32, 1);
pub const CRYPT_FORMAT_STR_NO_HEX = @as(u32, 16);
pub const CRYPT_FORMAT_SIMPLE = @as(u32, 1);
pub const CRYPT_FORMAT_X509 = @as(u32, 2);
pub const CRYPT_FORMAT_OID = @as(u32, 4);
pub const CRYPT_FORMAT_RDN_SEMICOLON = @as(u32, 256);
pub const CRYPT_FORMAT_RDN_CRLF = @as(u32, 512);
pub const CRYPT_FORMAT_RDN_UNQUOTE = @as(u32, 1024);
pub const CRYPT_FORMAT_RDN_REVERSE = @as(u32, 2048);
pub const CRYPT_FORMAT_COMMA = @as(u32, 4096);
pub const CRYPT_FORMAT_SEMICOLON = @as(u32, 256);
pub const CRYPT_FORMAT_CRLF = @as(u32, 512);
pub const CRYPT_ENCODE_NO_SIGNATURE_BYTE_REVERSAL_FLAG = @as(u32, 8);
pub const CRYPT_UNICODE_NAME_ENCODE_FORCE_UTF8_UNICODE_FLAG = @as(u32, 268435456);
pub const CRYPT_SORTED_CTL_ENCODE_HASHED_SUBJECT_IDENTIFIER_FLAG = @as(u32, 65536);
pub const CRYPT_ENCODE_ENABLE_UTF8PERCENT_FLAG = @as(u32, 262144);
pub const CRYPT_DECODE_NOCOPY_FLAG = @as(u32, 1);
pub const CRYPT_DECODE_TO_BE_SIGNED_FLAG = @as(u32, 2);
pub const CRYPT_DECODE_SHARE_OID_STRING_FLAG = @as(u32, 4);
pub const CRYPT_DECODE_NO_SIGNATURE_BYTE_REVERSAL_FLAG = @as(u32, 8);
pub const CRYPT_DECODE_ALLOC_FLAG = @as(u32, 32768);
pub const CRYPT_UNICODE_NAME_DECODE_DISABLE_IE4_UTF8_FLAG = @as(u32, 16777216);
pub const CRYPT_DECODE_ENABLE_PUNYCODE_FLAG = @as(u32, 33554432);
pub const CRYPT_DECODE_ENABLE_UTF8PERCENT_FLAG = @as(u32, 67108864);
pub const CRYPT_ENCODE_DECODE_NONE = @as(u32, 0);
pub const X509_CERT = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 1));
pub const X509_CERT_TO_BE_SIGNED = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 2));
pub const X509_CERT_CRL_TO_BE_SIGNED = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 3));
pub const X509_CERT_REQUEST_TO_BE_SIGNED = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 4));
pub const X509_EXTENSIONS = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 5));
pub const X509_NAME_VALUE = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 6));
pub const X509_NAME = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 7));
pub const X509_PUBLIC_KEY_INFO = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 8));
pub const X509_AUTHORITY_KEY_ID = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 9));
pub const X509_KEY_ATTRIBUTES = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 10));
pub const X509_KEY_USAGE_RESTRICTION = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 11));
pub const X509_ALTERNATE_NAME = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 12));
pub const X509_BASIC_CONSTRAINTS = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 13));
pub const X509_KEY_USAGE = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 14));
pub const X509_BASIC_CONSTRAINTS2 = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 15));
pub const X509_CERT_POLICIES = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 16));
pub const PKCS_UTC_TIME = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 17));
pub const PKCS_TIME_REQUEST = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 18));
pub const RSA_CSP_PUBLICKEYBLOB = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 19));
pub const X509_UNICODE_NAME = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 20));
pub const X509_KEYGEN_REQUEST_TO_BE_SIGNED = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 21));
pub const PKCS_ATTRIBUTE = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 22));
pub const PKCS_CONTENT_INFO_SEQUENCE_OF_ANY = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 23));
pub const X509_UNICODE_NAME_VALUE = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 24));
pub const X509_ANY_STRING = @as(i32, 6);
pub const X509_UNICODE_ANY_STRING = @as(i32, 24);
pub const X509_OCTET_STRING = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 25));
pub const X509_BITS = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 26));
pub const X509_INTEGER = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 27));
pub const X509_MULTI_BYTE_INTEGER = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 28));
pub const X509_ENUMERATED = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 29));
pub const X509_CHOICE_OF_TIME = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 30));
pub const X509_AUTHORITY_KEY_ID2 = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 31));
pub const X509_AUTHORITY_INFO_ACCESS = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 32));
pub const X509_SUBJECT_INFO_ACCESS = @as(i32, 32);
pub const X509_CRL_REASON_CODE = @as(i32, 29);
pub const PKCS_CONTENT_INFO = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 33));
pub const X509_SEQUENCE_OF_ANY = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 34));
pub const X509_CRL_DIST_POINTS = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 35));
pub const X509_ENHANCED_KEY_USAGE = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 36));
pub const PKCS_CTL = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 37));
pub const X509_MULTI_BYTE_UINT = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 38));
pub const X509_DSS_PUBLICKEY = @as(i32, 38);
pub const X509_DSS_PARAMETERS = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 39));
pub const X509_DSS_SIGNATURE = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 40));
pub const PKCS_RC2_CBC_PARAMETERS = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 41));
pub const PKCS_SMIME_CAPABILITIES = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 42));
pub const X509_QC_STATEMENTS_EXT = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 42));
pub const PKCS_RSA_PRIVATE_KEY = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 43));
pub const PKCS_PRIVATE_KEY_INFO = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 44));
pub const PKCS_ENCRYPTED_PRIVATE_KEY_INFO = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 45));
pub const X509_PKIX_POLICY_QUALIFIER_USERNOTICE = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 46));
pub const X509_DH_PUBLICKEY = @as(i32, 38);
pub const X509_DH_PARAMETERS = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 47));
pub const PKCS_ATTRIBUTES = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 48));
pub const PKCS_SORTED_CTL = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 49));
pub const X509_ECC_SIGNATURE = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 47));
pub const X942_DH_PARAMETERS = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 50));
pub const X509_BITS_WITHOUT_TRAILING_ZEROES = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 51));
pub const X942_OTHER_INFO = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 52));
pub const X509_CERT_PAIR = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 53));
pub const X509_ISSUING_DIST_POINT = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 54));
pub const X509_NAME_CONSTRAINTS = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 55));
pub const X509_POLICY_MAPPINGS = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 56));
pub const X509_POLICY_CONSTRAINTS = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 57));
pub const X509_CROSS_CERT_DIST_POINTS = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 58));
pub const CMC_DATA = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 59));
pub const CMC_RESPONSE = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 60));
pub const CMC_STATUS = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 61));
pub const CMC_ADD_EXTENSIONS = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 62));
pub const CMC_ADD_ATTRIBUTES = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 63));
pub const X509_CERTIFICATE_TEMPLATE = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 64));
pub const OCSP_SIGNED_REQUEST = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 65));
pub const OCSP_REQUEST = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 66));
pub const OCSP_RESPONSE = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 67));
pub const OCSP_BASIC_SIGNED_RESPONSE = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 68));
pub const OCSP_BASIC_RESPONSE = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 69));
pub const X509_LOGOTYPE_EXT = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 70));
pub const X509_BIOMETRIC_EXT = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 71));
pub const CNG_RSA_PUBLIC_KEY_BLOB = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 72));
pub const X509_OBJECT_IDENTIFIER = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 73));
pub const X509_ALGORITHM_IDENTIFIER = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 74));
pub const PKCS_RSA_SSA_PSS_PARAMETERS = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 75));
pub const PKCS_RSAES_OAEP_PARAMETERS = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 76));
pub const ECC_CMS_SHARED_INFO = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 77));
pub const TIMESTAMP_REQUEST = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 78));
pub const TIMESTAMP_RESPONSE = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 79));
pub const TIMESTAMP_INFO = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 80));
pub const X509_CERT_BUNDLE = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 81));
pub const X509_ECC_PRIVATE_KEY = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 82));
pub const CNG_RSA_PRIVATE_KEY_BLOB = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 83));
pub const X509_SUBJECT_DIR_ATTRS = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 84));
pub const X509_ECC_PARAMETERS = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 85));
pub const PKCS7_SIGNER_INFO = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 500));
pub const CMS_SIGNER_INFO = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 501));
pub const szOID_AUTHORITY_KEY_IDENTIFIER = "2.5.29.1";
pub const szOID_KEY_ATTRIBUTES = "2.5.29.2";
pub const szOID_CERT_POLICIES_95 = "2.5.29.3";
pub const szOID_KEY_USAGE_RESTRICTION = "2.5.29.4";
pub const szOID_SUBJECT_ALT_NAME = "2.5.29.7";
pub const szOID_ISSUER_ALT_NAME = "2.5.29.8";
pub const szOID_BASIC_CONSTRAINTS = "2.5.29.10";
pub const szOID_KEY_USAGE = "2.5.29.15";
pub const szOID_PRIVATEKEY_USAGE_PERIOD = "2.5.29.16";
pub const szOID_BASIC_CONSTRAINTS2 = "2.5.29.19";
pub const szOID_CERT_POLICIES = "2.5.29.32";
pub const szOID_ANY_CERT_POLICY = "2.5.29.32.0";
pub const szOID_INHIBIT_ANY_POLICY = "2.5.29.54";
pub const szOID_AUTHORITY_KEY_IDENTIFIER2 = "2.5.29.35";
pub const szOID_SUBJECT_KEY_IDENTIFIER = "2.5.29.14";
pub const szOID_SUBJECT_ALT_NAME2 = "2.5.29.17";
pub const szOID_ISSUER_ALT_NAME2 = "2.5.29.18";
pub const szOID_CRL_REASON_CODE = "2.5.29.21";
pub const szOID_REASON_CODE_HOLD = "2.5.29.23";
pub const szOID_CRL_DIST_POINTS = "2.5.29.31";
pub const szOID_ENHANCED_KEY_USAGE = "2.5.29.37";
pub const szOID_ANY_ENHANCED_KEY_USAGE = "2.5.29.37.0";
pub const szOID_CRL_NUMBER = "2.5.29.20";
pub const szOID_DELTA_CRL_INDICATOR = "2.5.29.27";
pub const szOID_ISSUING_DIST_POINT = "2.5.29.28";
pub const szOID_FRESHEST_CRL = "2.5.29.46";
pub const szOID_NAME_CONSTRAINTS = "2.5.29.30";
pub const szOID_POLICY_MAPPINGS = "2.5.29.33";
pub const szOID_LEGACY_POLICY_MAPPINGS = "2.5.29.5";
pub const szOID_POLICY_CONSTRAINTS = "2.5.29.36";
pub const szOID_RENEWAL_CERTIFICATE = "1.3.6.1.4.1.311.13.1";
pub const szOID_ENROLLMENT_NAME_VALUE_PAIR = "1.3.6.1.4.1.311.13.2.1";
pub const szOID_ENROLLMENT_CSP_PROVIDER = "1.3.6.1.4.1.311.13.2.2";
pub const szOID_OS_VERSION = "1.3.6.1.4.1.311.13.2.3";
pub const szOID_ENROLLMENT_AGENT = "1.3.6.1.4.1.311.20.2.1";
pub const szOID_PKIX = "1.3.6.1.5.5.7";
pub const szOID_PKIX_PE = "1.3.6.1.5.5.7.1";
pub const szOID_AUTHORITY_INFO_ACCESS = "1.3.6.1.5.5.7.1.1";
pub const szOID_SUBJECT_INFO_ACCESS = "1.3.6.1.5.5.7.1.11";
pub const szOID_BIOMETRIC_EXT = "1.3.6.1.5.5.7.1.2";
pub const szOID_QC_STATEMENTS_EXT = "1.3.6.1.5.5.7.1.3";
pub const szOID_LOGOTYPE_EXT = "1.3.6.1.5.5.7.1.12";
pub const szOID_TLS_FEATURES_EXT = "1.3.6.1.5.5.7.1.24";
pub const szOID_CERT_EXTENSIONS = "1.3.6.1.4.1.311.2.1.14";
pub const szOID_NEXT_UPDATE_LOCATION = "1.3.6.1.4.1.311.10.2";
pub const szOID_REMOVE_CERTIFICATE = "1.3.6.1.4.1.311.10.8.1";
pub const szOID_CROSS_CERT_DIST_POINTS = "1.3.6.1.4.1.311.10.9.1";
pub const szOID_CTL = "1.3.6.1.4.1.311.10.1";
pub const szOID_SORTED_CTL = "1.3.6.1.4.1.311.10.1.1";
pub const szOID_SERIALIZED = "1.3.6.1.4.1.311.10.3.3.1";
pub const szOID_NT_PRINCIPAL_NAME = "1.3.6.1.4.1.311.20.2.3";
pub const szOID_INTERNATIONALIZED_EMAIL_ADDRESS = "1.3.6.1.4.1.311.20.2.4";
pub const szOID_PRODUCT_UPDATE = "1.3.6.1.4.1.311.31.1";
pub const szOID_ANY_APPLICATION_POLICY = "1.3.6.1.4.1.311.10.12.1";
pub const szOID_AUTO_ENROLL_CTL_USAGE = "1.3.6.1.4.1.311.20.1";
pub const szOID_ENROLL_CERTTYPE_EXTENSION = "1.3.6.1.4.1.311.20.2";
pub const szOID_CERT_MANIFOLD = "1.3.6.1.4.1.311.20.3";
pub const szOID_CERTSRV_CA_VERSION = "1.3.6.1.4.1.311.21.1";
pub const szOID_CERTSRV_PREVIOUS_CERT_HASH = "1.3.6.1.4.1.311.21.2";
pub const szOID_CRL_VIRTUAL_BASE = "1.3.6.1.4.1.311.21.3";
pub const szOID_CRL_NEXT_PUBLISH = "1.3.6.1.4.1.311.21.4";
pub const szOID_KP_CA_EXCHANGE = "1.3.6.1.4.1.311.21.5";
pub const szOID_KP_PRIVACY_CA = "1.3.6.1.4.1.311.21.36";
pub const szOID_KP_KEY_RECOVERY_AGENT = "1.3.6.1.4.1.311.21.6";
pub const szOID_CERTIFICATE_TEMPLATE = "1.3.6.1.4.1.311.21.7";
pub const szOID_ENTERPRISE_OID_ROOT = "1.3.6.1.4.1.311.21.8";
pub const szOID_RDN_DUMMY_SIGNER = "1.3.6.1.4.1.311.21.9";
pub const szOID_APPLICATION_CERT_POLICIES = "1.3.6.1.4.1.311.21.10";
pub const szOID_APPLICATION_POLICY_MAPPINGS = "1.3.6.1.4.1.311.21.11";
pub const szOID_APPLICATION_POLICY_CONSTRAINTS = "1.3.6.1.4.1.311.21.12";
pub const szOID_ARCHIVED_KEY_ATTR = "1.3.6.1.4.1.311.21.13";
pub const szOID_CRL_SELF_CDP = "1.3.6.1.4.1.311.21.14";
pub const szOID_REQUIRE_CERT_CHAIN_POLICY = "1.3.6.1.4.1.311.21.15";
pub const szOID_ARCHIVED_KEY_CERT_HASH = "1.3.6.1.4.1.311.21.16";
pub const szOID_ISSUED_CERT_HASH = "1.3.6.1.4.1.311.21.17";
pub const szOID_DS_EMAIL_REPLICATION = "1.3.6.1.4.1.311.21.19";
pub const szOID_REQUEST_CLIENT_INFO = "1.3.6.1.4.1.311.21.20";
pub const szOID_ENCRYPTED_KEY_HASH = "1.3.6.1.4.1.311.21.21";
pub const szOID_CERTSRV_CROSSCA_VERSION = "1.3.6.1.4.1.311.21.22";
pub const szOID_NTDS_REPLICATION = "1.3.6.1.4.1.311.25.1";
pub const szOID_SUBJECT_DIR_ATTRS = "2.5.29.9";
pub const szOID_PKIX_KP = "1.3.6.1.5.5.7.3";
pub const szOID_PKIX_KP_SERVER_AUTH = "1.3.6.1.5.5.7.3.1";
pub const szOID_PKIX_KP_CLIENT_AUTH = "1.3.6.1.5.5.7.3.2";
pub const szOID_PKIX_KP_CODE_SIGNING = "1.3.6.1.5.5.7.3.3";
pub const szOID_PKIX_KP_EMAIL_PROTECTION = "1.3.6.1.5.5.7.3.4";
pub const szOID_PKIX_KP_IPSEC_END_SYSTEM = "1.3.6.1.5.5.7.3.5";
pub const szOID_PKIX_KP_IPSEC_TUNNEL = "1.3.6.1.5.5.7.3.6";
pub const szOID_PKIX_KP_IPSEC_USER = "1.3.6.1.5.5.7.3.7";
pub const szOID_PKIX_KP_TIMESTAMP_SIGNING = "1.3.6.1.5.5.7.3.8";
pub const szOID_PKIX_KP_OCSP_SIGNING = "1.3.6.1.5.5.7.3.9";
pub const szOID_PKIX_OCSP_NOCHECK = "1.3.6.1.5.5.7.48.1.5";
pub const szOID_PKIX_OCSP_NONCE = "1.3.6.1.5.5.7.48.1.2";
pub const szOID_IPSEC_KP_IKE_INTERMEDIATE = "1.3.6.1.5.5.8.2.2";
pub const szOID_PKINIT_KP_KDC = "1.3.6.1.5.2.3.5";
pub const szOID_KP_CTL_USAGE_SIGNING = "1.3.6.1.4.1.311.10.3.1";
pub const szOID_KP_TIME_STAMP_SIGNING = "1.3.6.1.4.1.311.10.3.2";
pub const szOID_SERVER_GATED_CRYPTO = "1.3.6.1.4.1.311.10.3.3";
pub const szOID_SGC_NETSCAPE = "2.16.840.1.113730.4.1";
pub const szOID_KP_EFS = "1.3.6.1.4.1.311.10.3.4";
pub const szOID_EFS_RECOVERY = "1.3.6.1.4.1.311.10.3.4.1";
pub const szOID_WHQL_CRYPTO = "1.3.6.1.4.1.311.10.3.5";
pub const szOID_ATTEST_WHQL_CRYPTO = "1.3.6.1.4.1.311.10.3.5.1";
pub const szOID_NT5_CRYPTO = "1.3.6.1.4.1.311.10.3.6";
pub const szOID_OEM_WHQL_CRYPTO = "1.3.6.1.4.1.311.10.3.7";
pub const szOID_EMBEDDED_NT_CRYPTO = "1.3.6.1.4.1.311.10.3.8";
pub const szOID_ROOT_LIST_SIGNER = "1.3.6.1.4.1.311.10.3.9";
pub const szOID_KP_QUALIFIED_SUBORDINATION = "1.3.6.1.4.1.311.10.3.10";
pub const szOID_KP_KEY_RECOVERY = "1.3.6.1.4.1.311.10.3.11";
pub const szOID_KP_DOCUMENT_SIGNING = "1.3.6.1.4.1.311.10.3.12";
pub const szOID_KP_LIFETIME_SIGNING = "1.3.6.1.4.1.311.10.3.13";
pub const szOID_KP_MOBILE_DEVICE_SOFTWARE = "1.3.6.1.4.1.311.10.3.14";
pub const szOID_KP_SMART_DISPLAY = "1.3.6.1.4.1.311.10.3.15";
pub const szOID_KP_CSP_SIGNATURE = "1.3.6.1.4.1.311.10.3.16";
pub const szOID_KP_FLIGHT_SIGNING = "1.3.6.1.4.1.311.10.3.27";
pub const szOID_PLATFORM_MANIFEST_BINARY_ID = "1.3.6.1.4.1.311.10.3.28";
pub const szOID_DRM = "1.3.6.1.4.1.311.10.5.1";
pub const szOID_DRM_INDIVIDUALIZATION = "1.3.6.1.4.1.311.10.5.2";
pub const szOID_LICENSES = "1.3.6.1.4.1.311.10.6.1";
pub const szOID_LICENSE_SERVER = "1.3.6.1.4.1.311.10.6.2";
pub const szOID_KP_SMARTCARD_LOGON = "1.3.6.1.4.1.311.20.2.2";
pub const szOID_KP_KERNEL_MODE_CODE_SIGNING = "1.3.6.1.4.1.311.61.1.1";
pub const szOID_KP_KERNEL_MODE_TRUSTED_BOOT_SIGNING = "1.3.6.1.4.1.311.61.4.1";
pub const szOID_REVOKED_LIST_SIGNER = "1.3.6.1.4.1.311.10.3.19";
pub const szOID_WINDOWS_KITS_SIGNER = "1.3.6.1.4.1.311.10.3.20";
pub const szOID_WINDOWS_RT_SIGNER = "1.3.6.1.4.1.311.10.3.21";
pub const szOID_PROTECTED_PROCESS_LIGHT_SIGNER = "1.3.6.1.4.1.311.10.3.22";
pub const szOID_WINDOWS_TCB_SIGNER = "1.3.6.1.4.1.311.10.3.23";
pub const szOID_PROTECTED_PROCESS_SIGNER = "1.3.6.1.4.1.311.10.3.24";
pub const szOID_WINDOWS_THIRD_PARTY_COMPONENT_SIGNER = "1.3.6.1.4.1.311.10.3.25";
pub const szOID_WINDOWS_SOFTWARE_EXTENSION_SIGNER = "1.3.6.1.4.1.311.10.3.26";
pub const szOID_DISALLOWED_LIST = "1.3.6.1.4.1.311.10.3.30";
pub const szOID_PIN_RULES_SIGNER = "1.3.6.1.4.1.311.10.3.31";
pub const szOID_PIN_RULES_CTL = "1.3.6.1.4.1.311.10.3.32";
pub const szOID_PIN_RULES_EXT = "1.3.6.1.4.1.311.10.3.33";
pub const szOID_PIN_RULES_DOMAIN_NAME = "1.3.6.1.4.1.311.10.3.34";
pub const szOID_PIN_RULES_LOG_END_DATE_EXT = "1.3.6.1.4.1.311.10.3.35";
pub const szOID_IUM_SIGNING = "1.3.6.1.4.1.311.10.3.37";
pub const szOID_EV_WHQL_CRYPTO = "1.3.6.1.4.1.311.10.3.39";
pub const szOID_BIOMETRIC_SIGNING = "1.3.6.1.4.1.311.10.3.41";
pub const szOID_ENCLAVE_SIGNING = "1.3.6.1.4.1.311.10.3.42";
pub const szOID_SYNC_ROOT_CTL_EXT = "1.3.6.1.4.1.311.10.3.50";
pub const szOID_HPKP_DOMAIN_NAME_CTL = "1.3.6.1.4.1.311.10.3.60";
pub const szOID_HPKP_HEADER_VALUE_CTL = "1.3.6.1.4.1.311.10.3.61";
pub const szOID_KP_KERNEL_MODE_HAL_EXTENSION_SIGNING = "1.3.6.1.4.1.311.61.5.1";
pub const szOID_WINDOWS_STORE_SIGNER = "1.3.6.1.4.1.311.76.3.1";
pub const szOID_DYNAMIC_CODE_GEN_SIGNER = "1.3.6.1.4.1.311.76.5.1";
pub const szOID_MICROSOFT_PUBLISHER_SIGNER = "1.3.6.1.4.1.311.76.8.1";
pub const szOID_YESNO_TRUST_ATTR = "1.3.6.1.4.1.311.10.4.1";
pub const szOID_SITE_PIN_RULES_INDEX_ATTR = "1.3.6.1.4.1.311.10.4.2";
pub const szOID_SITE_PIN_RULES_FLAGS_ATTR = "1.3.6.1.4.1.311.10.4.3";
pub const SITE_PIN_RULES_ALL_SUBDOMAINS_FLAG = @as(u32, 1);
pub const szOID_PKIX_POLICY_QUALIFIER_CPS = "1.3.6.1.5.5.7.2.1";
pub const szOID_PKIX_POLICY_QUALIFIER_USERNOTICE = "1.3.6.1.5.5.7.2.2";
pub const szOID_ROOT_PROGRAM_FLAGS = "1.3.6.1.4.1.311.60.1.1";
pub const CERT_ROOT_PROGRAM_FLAG_OU = @as(u32, 16);
pub const CERT_ROOT_PROGRAM_FLAG_ADDRESS = @as(u32, 8);
pub const szOID_CERT_POLICIES_95_QUALIFIER1 = "2.16.840.1.113733.1.7.1.1";
pub const szOID_RDN_TPM_MANUFACTURER = "2.23.133.2.1";
pub const szOID_RDN_TPM_MODEL = "2.23.133.2.2";
pub const szOID_RDN_TPM_VERSION = "2.23.133.2.3";
pub const szOID_RDN_TCG_PLATFORM_MANUFACTURER = "2.23.133.2.4";
pub const szOID_RDN_TCG_PLATFORM_MODEL = "2.23.133.2.5";
pub const szOID_RDN_TCG_PLATFORM_VERSION = "2.23.133.2.6";
pub const szOID_CT_CERT_SCTLIST = "1.3.6.1.4.1.11129.2.4.2";
pub const szOID_ENROLL_EK_INFO = "1.3.6.1.4.1.311.21.23";
pub const szOID_ENROLL_AIK_INFO = "1.3.6.1.4.1.311.21.39";
pub const szOID_ENROLL_ATTESTATION_STATEMENT = "1.3.6.1.4.1.311.21.24";
pub const szOID_ENROLL_KSP_NAME = "1.3.6.1.4.1.311.21.25";
pub const szOID_ENROLL_EKPUB_CHALLENGE = "1.3.6.1.4.1.311.21.26";
pub const szOID_ENROLL_CAXCHGCERT_HASH = "1.3.6.1.4.1.311.21.27";
pub const szOID_ENROLL_ATTESTATION_CHALLENGE = "1.3.6.1.4.1.311.21.28";
pub const szOID_ENROLL_ENCRYPTION_ALGORITHM = "1.3.6.1.4.1.311.21.29";
pub const szOID_KP_TPM_EK_CERTIFICATE = "2.23.133.8.1";
pub const szOID_KP_TPM_PLATFORM_CERTIFICATE = "2.23.133.8.2";
pub const szOID_KP_TPM_AIK_CERTIFICATE = "2.23.133.8.3";
pub const szOID_ENROLL_EKVERIFYKEY = "1.3.6.1.4.1.311.21.30";
pub const szOID_ENROLL_EKVERIFYCERT = "1.3.6.1.4.1.311.21.31";
pub const szOID_ENROLL_EKVERIFYCREDS = "1.3.6.1.4.1.311.21.32";
pub const szOID_ENROLL_SCEP_ERROR = "1.3.6.1.4.1.311.21.33";
pub const szOID_ENROLL_SCEP_SERVER_STATE = "1.3.6.1.4.1.311.21.34";
pub const szOID_ENROLL_SCEP_CHALLENGE_ANSWER = "1.3.6.1.4.1.311.21.35";
pub const szOID_ENROLL_SCEP_CLIENT_REQUEST = "1.3.6.1.4.1.311.21.37";
pub const szOID_ENROLL_SCEP_SERVER_MESSAGE = "1.3.6.1.4.1.311.21.38";
pub const szOID_ENROLL_SCEP_SERVER_SECRET = "1.3.6.1.4.1.311.21.40";
pub const szOID_ENROLL_KEY_AFFINITY = "1.3.6.1.4.1.311.21.41";
pub const szOID_ENROLL_SCEP_SIGNER_HASH = "1.3.6.1.4.1.311.21.42";
pub const szOID_ENROLL_EK_CA_KEYID = "1.3.6.1.4.1.311.21.43";
pub const szOID_ATTR_SUPPORTED_ALGORITHMS = "2.5.4.52";
pub const szOID_ATTR_TPM_SPECIFICATION = "2.23.133.2.16";
pub const szOID_ATTR_PLATFORM_SPECIFICATION = "2.23.133.2.17";
pub const szOID_ATTR_TPM_SECURITY_ASSERTIONS = "2.23.133.2.18";
pub const CERT_UNICODE_RDN_ERR_INDEX_MASK = @as(u32, 1023);
pub const CERT_UNICODE_RDN_ERR_INDEX_SHIFT = @as(u32, 22);
pub const CERT_UNICODE_ATTR_ERR_INDEX_MASK = @as(u32, 63);
pub const CERT_UNICODE_ATTR_ERR_INDEX_SHIFT = @as(u32, 16);
pub const CERT_UNICODE_VALUE_ERR_INDEX_MASK = @as(u32, 65535);
pub const CERT_UNICODE_VALUE_ERR_INDEX_SHIFT = @as(u32, 0);
pub const CERT_DIGITAL_SIGNATURE_KEY_USAGE = @as(u32, 128);
pub const CERT_NON_REPUDIATION_KEY_USAGE = @as(u32, 64);
pub const CERT_KEY_ENCIPHERMENT_KEY_USAGE = @as(u32, 32);
pub const CERT_DATA_ENCIPHERMENT_KEY_USAGE = @as(u32, 16);
pub const CERT_KEY_AGREEMENT_KEY_USAGE = @as(u32, 8);
pub const CERT_KEY_CERT_SIGN_KEY_USAGE = @as(u32, 4);
pub const CERT_OFFLINE_CRL_SIGN_KEY_USAGE = @as(u32, 2);
pub const CERT_CRL_SIGN_KEY_USAGE = @as(u32, 2);
pub const CERT_ENCIPHER_ONLY_KEY_USAGE = @as(u32, 1);
pub const CERT_DECIPHER_ONLY_KEY_USAGE = @as(u32, 128);
pub const CERT_ALT_NAME_X400_ADDRESS = @as(u32, 4);
pub const CERT_ALT_NAME_EDI_PARTY_NAME = @as(u32, 6);
pub const CERT_ALT_NAME_ENTRY_ERR_INDEX_MASK = @as(u32, 255);
pub const CERT_ALT_NAME_ENTRY_ERR_INDEX_SHIFT = @as(u32, 16);
pub const CERT_ALT_NAME_VALUE_ERR_INDEX_MASK = @as(u32, 65535);
pub const CERT_ALT_NAME_VALUE_ERR_INDEX_SHIFT = @as(u32, 0);
pub const CERT_CA_SUBJECT_FLAG = @as(u32, 128);
pub const CERT_END_ENTITY_SUBJECT_FLAG = @as(u32, 64);
pub const szOID_PKIX_ACC_DESCR = "1.3.6.1.5.5.7.48";
pub const szOID_PKIX_OCSP = "1.3.6.1.5.5.7.48.1";
pub const szOID_PKIX_CA_ISSUERS = "1.3.6.1.5.5.7.48.2";
pub const szOID_PKIX_TIME_STAMPING = "1.3.6.1.5.5.7.48.3";
pub const szOID_PKIX_CA_REPOSITORY = "1.3.6.1.5.5.7.48.5";
pub const CRL_REASON_PRIVILEGE_WITHDRAWN = @as(u32, 9);
pub const CRL_REASON_AA_COMPROMISE = @as(u32, 10);
pub const CRL_DIST_POINT_NO_NAME = @as(u32, 0);
pub const CRL_DIST_POINT_FULL_NAME = @as(u32, 1);
pub const CRL_DIST_POINT_ISSUER_RDN_NAME = @as(u32, 2);
pub const CRL_REASON_UNUSED_FLAG = @as(u32, 128);
pub const CRL_REASON_KEY_COMPROMISE_FLAG = @as(u32, 64);
pub const CRL_REASON_CA_COMPROMISE_FLAG = @as(u32, 32);
pub const CRL_REASON_AFFILIATION_CHANGED_FLAG = @as(u32, 16);
pub const CRL_REASON_SUPERSEDED_FLAG = @as(u32, 8);
pub const CRL_REASON_CESSATION_OF_OPERATION_FLAG = @as(u32, 4);
pub const CRL_REASON_CERTIFICATE_HOLD_FLAG = @as(u32, 2);
pub const CRL_REASON_PRIVILEGE_WITHDRAWN_FLAG = @as(u32, 1);
pub const CRL_REASON_AA_COMPROMISE_FLAG = @as(u32, 128);
pub const CRL_DIST_POINT_ERR_INDEX_MASK = @as(u32, 127);
pub const CRL_DIST_POINT_ERR_INDEX_SHIFT = @as(u32, 24);
pub const CRL_DIST_POINT_ERR_CRL_ISSUER_BIT = @as(i32, -2147483648);
pub const CROSS_CERT_DIST_POINT_ERR_INDEX_MASK = @as(u32, 255);
pub const CROSS_CERT_DIST_POINT_ERR_INDEX_SHIFT = @as(u32, 24);
pub const CERT_EXCLUDED_SUBTREE_BIT = @as(i32, -2147483648);
pub const SORTED_CTL_EXT_HASHED_SUBJECT_IDENTIFIER_FLAG = @as(u32, 1);
pub const CERT_DSS_R_LEN = @as(u32, 20);
pub const CERT_DSS_S_LEN = @as(u32, 20);
pub const CRYPT_X942_COUNTER_BYTE_LENGTH = @as(u32, 4);
pub const CRYPT_X942_KEY_LENGTH_BYTE_LENGTH = @as(u32, 4);
pub const CRYPT_ECC_CMS_SHARED_INFO_SUPPPUBINFO_BYTE_LENGTH = @as(u32, 4);
pub const CRYPT_RC2_40BIT_VERSION = @as(u32, 160);
pub const CRYPT_RC2_56BIT_VERSION = @as(u32, 52);
pub const CRYPT_RC2_64BIT_VERSION = @as(u32, 120);
pub const CRYPT_RC2_128BIT_VERSION = @as(u32, 58);
pub const szOID_QC_EU_COMPLIANCE = "0.4.0.1862.1.1";
pub const szOID_QC_SSCD = "0.4.0.1862.1.4";
pub const PKCS_RSA_SSA_PSS_TRAILER_FIELD_BC = @as(u32, 1);
pub const szOID_VERISIGN_PRIVATE_6_9 = "2.16.840.1.113733.1.6.9";
pub const szOID_VERISIGN_ONSITE_JURISDICTION_HASH = "2.16.840.1.113733.1.6.11";
pub const szOID_VERISIGN_BITSTRING_6_13 = "2.16.840.1.113733.1.6.13";
pub const szOID_VERISIGN_ISS_STRONG_CRYPTO = "2.16.840.1.113733.1.8.1";
pub const szOIDVerisign_MessageType = "2.16.840.1.113733.1.9.2";
pub const szOIDVerisign_PkiStatus = "2.16.840.1.113733.1.9.3";
pub const szOIDVerisign_FailInfo = "2.16.840.1.113733.1.9.4";
pub const szOIDVerisign_SenderNonce = "2.16.840.1.113733.1.9.5";
pub const szOIDVerisign_RecipientNonce = "2.16.840.1.113733.1.9.6";
pub const szOIDVerisign_TransactionID = "2.16.840.1.113733.1.9.7";
pub const szOID_NETSCAPE = "2.16.840.1.113730";
pub const szOID_NETSCAPE_CERT_EXTENSION = "2.16.840.1.113730.1";
pub const szOID_NETSCAPE_CERT_TYPE = "2.16.840.1.113730.1.1";
pub const szOID_NETSCAPE_BASE_URL = "2.16.840.1.113730.1.2";
pub const szOID_NETSCAPE_REVOCATION_URL = "2.16.840.1.113730.1.3";
pub const szOID_NETSCAPE_CA_REVOCATION_URL = "2.16.840.1.113730.1.4";
pub const szOID_NETSCAPE_CERT_RENEWAL_URL = "2.16.840.1.113730.1.7";
pub const szOID_NETSCAPE_CA_POLICY_URL = "2.16.840.1.113730.1.8";
pub const szOID_NETSCAPE_SSL_SERVER_NAME = "2.16.840.1.113730.1.12";
pub const szOID_NETSCAPE_COMMENT = "2.16.840.1.113730.1.13";
pub const szOID_NETSCAPE_DATA_TYPE = "2.16.840.1.113730.2";
pub const szOID_NETSCAPE_CERT_SEQUENCE = "2.16.840.1.113730.2.5";
pub const NETSCAPE_SSL_CLIENT_AUTH_CERT_TYPE = @as(u32, 128);
pub const NETSCAPE_SSL_SERVER_AUTH_CERT_TYPE = @as(u32, 64);
pub const NETSCAPE_SMIME_CERT_TYPE = @as(u32, 32);
pub const NETSCAPE_SIGN_CERT_TYPE = @as(u32, 16);
pub const NETSCAPE_SSL_CA_CERT_TYPE = @as(u32, 4);
pub const NETSCAPE_SMIME_CA_CERT_TYPE = @as(u32, 2);
pub const NETSCAPE_SIGN_CA_CERT_TYPE = @as(u32, 1);
pub const szOID_CT_PKI_DATA = "1.3.6.1.5.5.7.12.2";
pub const szOID_CT_PKI_RESPONSE = "1.3.6.1.5.5.7.12.3";
pub const szOID_PKIX_NO_SIGNATURE = "1.3.6.1.5.5.7.6.2";
pub const szOID_CMC = "1.3.6.1.5.5.7.7";
pub const szOID_CMC_STATUS_INFO = "1.3.6.1.5.5.7.7.1";
pub const szOID_CMC_IDENTIFICATION = "1.3.6.1.5.5.7.7.2";
pub const szOID_CMC_IDENTITY_PROOF = "1.3.6.1.5.5.7.7.3";
pub const szOID_CMC_DATA_RETURN = "1.3.6.1.5.5.7.7.4";
pub const szOID_CMC_TRANSACTION_ID = "1.3.6.1.5.5.7.7.5";
pub const szOID_CMC_SENDER_NONCE = "1.3.6.1.5.5.7.7.6";
pub const szOID_CMC_RECIPIENT_NONCE = "1.3.6.1.5.5.7.7.7";
pub const szOID_CMC_ADD_EXTENSIONS = "1.3.6.1.5.5.7.7.8";
pub const szOID_CMC_ENCRYPTED_POP = "1.3.6.1.5.5.7.7.9";
pub const szOID_CMC_DECRYPTED_POP = "1.3.6.1.5.5.7.7.10";
pub const szOID_CMC_LRA_POP_WITNESS = "1.3.6.1.5.5.7.7.11";
pub const szOID_CMC_GET_CERT = "1.3.6.1.5.5.7.7.15";
pub const szOID_CMC_GET_CRL = "1.3.6.1.5.5.7.7.16";
pub const szOID_CMC_REVOKE_REQUEST = "1.3.6.1.5.5.7.7.17";
pub const szOID_CMC_REG_INFO = "1.3.6.1.5.5.7.7.18";
pub const szOID_CMC_RESPONSE_INFO = "1.3.6.1.5.5.7.7.19";
pub const szOID_CMC_QUERY_PENDING = "1.3.6.1.5.5.7.7.21";
pub const szOID_CMC_ID_POP_LINK_RANDOM = "1.3.6.1.5.5.7.7.22";
pub const szOID_CMC_ID_POP_LINK_WITNESS = "1.3.6.1.5.5.7.7.23";
pub const szOID_CMC_ID_CONFIRM_CERT_ACCEPTANCE = "1.3.6.1.5.5.7.7.24";
pub const szOID_CMC_ADD_ATTRIBUTES = "1.3.6.1.4.1.311.10.10.1";
pub const CMC_TAGGED_CERT_REQUEST_CHOICE = @as(u32, 1);
pub const CMC_OTHER_INFO_NO_CHOICE = @as(u32, 0);
pub const CMC_OTHER_INFO_FAIL_CHOICE = @as(u32, 1);
pub const CMC_OTHER_INFO_PEND_CHOICE = @as(u32, 2);
pub const CMC_STATUS_SUCCESS = @as(u32, 0);
pub const CMC_STATUS_FAILED = @as(u32, 2);
pub const CMC_STATUS_PENDING = @as(u32, 3);
pub const CMC_STATUS_NO_SUPPORT = @as(u32, 4);
pub const CMC_STATUS_CONFIRM_REQUIRED = @as(u32, 5);
pub const CMC_FAIL_BAD_ALG = @as(u32, 0);
pub const CMC_FAIL_BAD_MESSAGE_CHECK = @as(u32, 1);
pub const CMC_FAIL_BAD_REQUEST = @as(u32, 2);
pub const CMC_FAIL_BAD_TIME = @as(u32, 3);
pub const CMC_FAIL_BAD_CERT_ID = @as(u32, 4);
pub const CMC_FAIL_UNSUPORTED_EXT = @as(u32, 5);
pub const CMC_FAIL_MUST_ARCHIVE_KEYS = @as(u32, 6);
pub const CMC_FAIL_BAD_IDENTITY = @as(u32, 7);
pub const CMC_FAIL_POP_REQUIRED = @as(u32, 8);
pub const CMC_FAIL_POP_FAILED = @as(u32, 9);
pub const CMC_FAIL_NO_KEY_REUSE = @as(u32, 10);
pub const CMC_FAIL_INTERNAL_CA_ERROR = @as(u32, 11);
pub const CMC_FAIL_TRY_LATER = @as(u32, 12);
pub const szOID_LOYALTY_OTHER_LOGOTYPE = "1.3.6.1.5.5.7.20.1";
pub const szOID_BACKGROUND_OTHER_LOGOTYPE = "1.3.6.1.5.5.7.20.2";
pub const CERT_BIOMETRIC_PICTURE_TYPE = @as(u32, 0);
pub const CERT_BIOMETRIC_SIGNATURE_TYPE = @as(u32, 1);
pub const OCSP_REQUEST_V1 = @as(u32, 0);
pub const OCSP_SUCCESSFUL_RESPONSE = @as(u32, 0);
pub const OCSP_MALFORMED_REQUEST_RESPONSE = @as(u32, 1);
pub const OCSP_INTERNAL_ERROR_RESPONSE = @as(u32, 2);
pub const OCSP_TRY_LATER_RESPONSE = @as(u32, 3);
pub const OCSP_SIG_REQUIRED_RESPONSE = @as(u32, 5);
pub const OCSP_UNAUTHORIZED_RESPONSE = @as(u32, 6);
pub const szOID_PKIX_OCSP_BASIC_SIGNED_RESPONSE = "1.3.6.1.5.5.7.48.1.1";
pub const OCSP_BASIC_GOOD_CERT_STATUS = @as(u32, 0);
pub const OCSP_BASIC_REVOKED_CERT_STATUS = @as(u32, 1);
pub const OCSP_BASIC_UNKNOWN_CERT_STATUS = @as(u32, 2);
pub const OCSP_BASIC_RESPONSE_V1 = @as(u32, 0);
pub const OCSP_BASIC_BY_NAME_RESPONDER_ID = @as(u32, 1);
pub const OCSP_BASIC_BY_KEY_RESPONDER_ID = @as(u32, 2);
pub const CRYPT_OID_ENCODE_OBJECT_FUNC = "CryptDllEncodeObject";
pub const CRYPT_OID_DECODE_OBJECT_FUNC = "CryptDllDecodeObject";
pub const CRYPT_OID_ENCODE_OBJECT_EX_FUNC = "CryptDllEncodeObjectEx";
pub const CRYPT_OID_DECODE_OBJECT_EX_FUNC = "CryptDllDecodeObjectEx";
pub const CRYPT_OID_CREATE_COM_OBJECT_FUNC = "CryptDllCreateCOMObject";
pub const CRYPT_OID_VERIFY_REVOCATION_FUNC = "CertDllVerifyRevocation";
pub const CRYPT_OID_VERIFY_CTL_USAGE_FUNC = "CertDllVerifyCTLUsage";
pub const CRYPT_OID_FORMAT_OBJECT_FUNC = "CryptDllFormatObject";
pub const CRYPT_OID_FIND_OID_INFO_FUNC = "CryptDllFindOIDInfo";
pub const CRYPT_OID_FIND_LOCALIZED_NAME_FUNC = "CryptDllFindLocalizedName";
pub const CRYPT_OID_REGPATH = "Software\\Microsoft\\Cryptography\\OID";
pub const CRYPT_OID_REG_ENCODING_TYPE_PREFIX = "EncodingType ";
pub const CRYPT_OID_REG_DLL_VALUE_NAME = "Dll";
pub const CRYPT_OID_REG_FUNC_NAME_VALUE_NAME = "FuncName";
pub const CRYPT_OID_REG_FUNC_NAME_VALUE_NAME_A = "FuncName";
pub const CRYPT_OID_REG_FLAGS_VALUE_NAME = "CryptFlags";
pub const CRYPT_DEFAULT_OID = "DEFAULT";
pub const CRYPT_INSTALL_OID_FUNC_BEFORE_FLAG = @as(u32, 1);
pub const CRYPT_GET_INSTALLED_OID_FUNC_FLAG = @as(u32, 1);
pub const CRYPT_REGISTER_FIRST_INDEX = @as(u32, 0);
pub const CRYPT_REGISTER_LAST_INDEX = @as(u32, 4294967295);
pub const CRYPT_MATCH_ANY_ENCODING_TYPE = @as(u32, 4294967295);
pub const CALG_OID_INFO_CNG_ONLY = @as(u32, 4294967295);
pub const CALG_OID_INFO_PARAMETERS = @as(u32, 4294967294);
pub const CRYPT_OID_INFO_HASH_PARAMETERS_ALGORITHM = "CryptOIDInfoHashParameters";
pub const CRYPT_OID_INFO_ECC_PARAMETERS_ALGORITHM = "CryptOIDInfoECCParameters";
pub const CRYPT_OID_INFO_MGF1_PARAMETERS_ALGORITHM = "CryptOIDInfoMgf1Parameters";
pub const CRYPT_OID_INFO_NO_SIGN_ALGORITHM = "CryptOIDInfoNoSign";
pub const CRYPT_OID_INFO_OAEP_PARAMETERS_ALGORITHM = "CryptOIDInfoOAEPParameters";
pub const CRYPT_OID_INFO_ECC_WRAP_PARAMETERS_ALGORITHM = "CryptOIDInfoECCWrapParameters";
pub const CRYPT_OID_INFO_NO_PARAMETERS_ALGORITHM = "CryptOIDInfoNoParameters";
pub const CRYPT_HASH_ALG_OID_GROUP_ID = @as(u32, 1);
pub const CRYPT_ENCRYPT_ALG_OID_GROUP_ID = @as(u32, 2);
pub const CRYPT_PUBKEY_ALG_OID_GROUP_ID = @as(u32, 3);
pub const CRYPT_SIGN_ALG_OID_GROUP_ID = @as(u32, 4);
pub const CRYPT_RDN_ATTR_OID_GROUP_ID = @as(u32, 5);
pub const CRYPT_EXT_OR_ATTR_OID_GROUP_ID = @as(u32, 6);
pub const CRYPT_ENHKEY_USAGE_OID_GROUP_ID = @as(u32, 7);
pub const CRYPT_POLICY_OID_GROUP_ID = @as(u32, 8);
pub const CRYPT_TEMPLATE_OID_GROUP_ID = @as(u32, 9);
pub const CRYPT_KDF_OID_GROUP_ID = @as(u32, 10);
pub const CRYPT_LAST_OID_GROUP_ID = @as(u32, 10);
pub const CRYPT_FIRST_ALG_OID_GROUP_ID = @as(u32, 1);
pub const CRYPT_LAST_ALG_OID_GROUP_ID = @as(u32, 4);
pub const CRYPT_OID_INHIBIT_SIGNATURE_FORMAT_FLAG = @as(u32, 1);
pub const CRYPT_OID_USE_PUBKEY_PARA_FOR_PKCS7_FLAG = @as(u32, 2);
pub const CRYPT_OID_NO_NULL_ALGORITHM_PARA_FLAG = @as(u32, 4);
pub const CRYPT_OID_PUBKEY_SIGN_ONLY_FLAG = @as(u32, 2147483648);
pub const CRYPT_OID_PUBKEY_ENCRYPT_ONLY_FLAG = @as(u32, 1073741824);
pub const CRYPT_OID_USE_CURVE_NAME_FOR_ENCODE_FLAG = @as(u32, 536870912);
pub const CRYPT_OID_USE_CURVE_PARAMETERS_FOR_ENCODE_FLAG = @as(u32, 268435456);
pub const CRYPT_OID_INFO_OID_KEY = @as(u32, 1);
pub const CRYPT_OID_INFO_NAME_KEY = @as(u32, 2);
pub const CRYPT_OID_INFO_ALGID_KEY = @as(u32, 3);
pub const CRYPT_OID_INFO_SIGN_KEY = @as(u32, 4);
pub const CRYPT_OID_INFO_CNG_ALGID_KEY = @as(u32, 5);
pub const CRYPT_OID_INFO_CNG_SIGN_KEY = @as(u32, 6);
pub const CRYPT_OID_INFO_OID_KEY_FLAGS_MASK = @as(u32, 4294901760);
pub const CRYPT_OID_DISABLE_SEARCH_DS_FLAG = @as(u32, 2147483648);
pub const CRYPT_OID_PREFER_CNG_ALGID_FLAG = @as(u32, 1073741824);
pub const CRYPT_OID_INFO_OID_GROUP_BIT_LEN_MASK = @as(u32, 268369920);
pub const CRYPT_OID_INFO_OID_GROUP_BIT_LEN_SHIFT = @as(u32, 16);
pub const CRYPT_INSTALL_OID_INFO_BEFORE_FLAG = @as(u32, 1);
pub const CRYPT_LOCALIZED_NAME_ENCODING_TYPE = @as(u32, 0);
pub const CRYPT_LOCALIZED_NAME_OID = "LocalizedNames";
pub const CERT_STRONG_SIGN_ECDSA_ALGORITHM = "ECDSA";
pub const CERT_STRONG_SIGN_SERIALIZED_INFO_CHOICE = @as(u32, 1);
pub const CERT_STRONG_SIGN_OID_INFO_CHOICE = @as(u32, 2);
pub const szOID_CERT_STRONG_SIGN_OS_PREFIX = "1.3.6.1.4.1.311.72.1.";
pub const szOID_CERT_STRONG_SIGN_OS_1 = "1.3.6.1.4.1.311.72.1.1";
pub const szOID_CERT_STRONG_SIGN_OS_CURRENT = "1.3.6.1.4.1.311.72.1.1";
pub const szOID_CERT_STRONG_KEY_OS_PREFIX = "1.3.6.1.4.1.311.72.2.";
pub const szOID_CERT_STRONG_KEY_OS_1 = "1.3.6.1.4.1.311.72.2.1";
pub const szOID_CERT_STRONG_KEY_OS_CURRENT = "1.3.6.1.4.1.311.72.2.1";
pub const szOID_PKCS_7_DATA = "1.2.840.113549.1.7.1";
pub const szOID_PKCS_7_SIGNED = "1.2.840.113549.1.7.2";
pub const szOID_PKCS_7_ENVELOPED = "1.2.840.113549.1.7.3";
pub const szOID_PKCS_7_SIGNEDANDENVELOPED = "1.2.840.113549.1.7.4";
pub const szOID_PKCS_7_DIGESTED = "1.2.840.113549.1.7.5";
pub const szOID_PKCS_7_ENCRYPTED = "1.2.840.113549.1.7.6";
pub const szOID_PKCS_9_CONTENT_TYPE = "1.2.840.113549.1.9.3";
pub const szOID_PKCS_9_MESSAGE_DIGEST = "1.2.840.113549.1.9.4";
pub const CMSG_ENCRYPTED = @as(u32, 6);
pub const CMSG_MAIL_LIST_HANDLE_KEY_CHOICE = @as(u32, 1);
pub const CMSG_KEY_TRANS_RECIPIENT = @as(u32, 1);
pub const CMSG_KEY_AGREE_RECIPIENT = @as(u32, 2);
pub const CMSG_MAIL_LIST_RECIPIENT = @as(u32, 3);
pub const CMSG_SP3_COMPATIBLE_ENCRYPT_FLAG = @as(u32, 2147483648);
pub const CMSG_RC4_NO_SALT_FLAG = @as(u32, 1073741824);
pub const CMSG_INDEFINITE_LENGTH = @as(u32, 4294967295);
pub const CMSG_BARE_CONTENT_FLAG = @as(u32, 1);
pub const CMSG_LENGTH_ONLY_FLAG = @as(u32, 2);
pub const CMSG_DETACHED_FLAG = @as(u32, 4);
pub const CMSG_AUTHENTICATED_ATTRIBUTES_FLAG = @as(u32, 8);
pub const CMSG_CONTENTS_OCTETS_FLAG = @as(u32, 16);
pub const CMSG_MAX_LENGTH_FLAG = @as(u32, 32);
pub const CMSG_CMS_ENCAPSULATED_CONTENT_FLAG = @as(u32, 64);
pub const CMSG_SIGNED_DATA_NO_SIGN_FLAG = @as(u32, 128);
pub const CMSG_CRYPT_RELEASE_CONTEXT_FLAG = @as(u32, 32768);
pub const CMSG_TYPE_PARAM = @as(u32, 1);
pub const CMSG_CONTENT_PARAM = @as(u32, 2);
pub const CMSG_BARE_CONTENT_PARAM = @as(u32, 3);
pub const CMSG_INNER_CONTENT_TYPE_PARAM = @as(u32, 4);
pub const CMSG_SIGNER_COUNT_PARAM = @as(u32, 5);
pub const CMSG_SIGNER_INFO_PARAM = @as(u32, 6);
pub const CMSG_SIGNER_CERT_INFO_PARAM = @as(u32, 7);
pub const CMSG_SIGNER_HASH_ALGORITHM_PARAM = @as(u32, 8);
pub const CMSG_SIGNER_AUTH_ATTR_PARAM = @as(u32, 9);
pub const CMSG_SIGNER_UNAUTH_ATTR_PARAM = @as(u32, 10);
pub const CMSG_CERT_COUNT_PARAM = @as(u32, 11);
pub const CMSG_CERT_PARAM = @as(u32, 12);
pub const CMSG_CRL_COUNT_PARAM = @as(u32, 13);
pub const CMSG_CRL_PARAM = @as(u32, 14);
pub const CMSG_ENVELOPE_ALGORITHM_PARAM = @as(u32, 15);
pub const CMSG_RECIPIENT_COUNT_PARAM = @as(u32, 17);
pub const CMSG_RECIPIENT_INDEX_PARAM = @as(u32, 18);
pub const CMSG_RECIPIENT_INFO_PARAM = @as(u32, 19);
pub const CMSG_HASH_ALGORITHM_PARAM = @as(u32, 20);
pub const CMSG_HASH_DATA_PARAM = @as(u32, 21);
pub const CMSG_COMPUTED_HASH_PARAM = @as(u32, 22);
pub const CMSG_ENCRYPT_PARAM = @as(u32, 26);
pub const CMSG_ENCRYPTED_DIGEST = @as(u32, 27);
pub const CMSG_ENCODED_SIGNER = @as(u32, 28);
pub const CMSG_ENCODED_MESSAGE = @as(u32, 29);
pub const CMSG_VERSION_PARAM = @as(u32, 30);
pub const CMSG_ATTR_CERT_COUNT_PARAM = @as(u32, 31);
pub const CMSG_ATTR_CERT_PARAM = @as(u32, 32);
pub const CMSG_CMS_RECIPIENT_COUNT_PARAM = @as(u32, 33);
pub const CMSG_CMS_RECIPIENT_INDEX_PARAM = @as(u32, 34);
pub const CMSG_CMS_RECIPIENT_ENCRYPTED_KEY_INDEX_PARAM = @as(u32, 35);
pub const CMSG_CMS_RECIPIENT_INFO_PARAM = @as(u32, 36);
pub const CMSG_UNPROTECTED_ATTR_PARAM = @as(u32, 37);
pub const CMSG_SIGNER_CERT_ID_PARAM = @as(u32, 38);
pub const CMSG_CMS_SIGNER_INFO_PARAM = @as(u32, 39);
pub const CMSG_SIGNED_DATA_V1 = @as(u32, 1);
pub const CMSG_SIGNED_DATA_V3 = @as(u32, 3);
pub const CMSG_SIGNED_DATA_PKCS_1_5_VERSION = @as(u32, 1);
pub const CMSG_SIGNED_DATA_CMS_VERSION = @as(u32, 3);
pub const CMSG_SIGNER_INFO_V1 = @as(u32, 1);
pub const CMSG_SIGNER_INFO_V3 = @as(u32, 3);
pub const CMSG_SIGNER_INFO_PKCS_1_5_VERSION = @as(u32, 1);
pub const CMSG_SIGNER_INFO_CMS_VERSION = @as(u32, 3);
pub const CMSG_HASHED_DATA_V0 = @as(u32, 0);
pub const CMSG_HASHED_DATA_V2 = @as(u32, 2);
pub const CMSG_HASHED_DATA_PKCS_1_5_VERSION = @as(u32, 0);
pub const CMSG_HASHED_DATA_CMS_VERSION = @as(u32, 2);
pub const CMSG_ENVELOPED_DATA_V0 = @as(u32, 0);
pub const CMSG_ENVELOPED_DATA_V2 = @as(u32, 2);
pub const CMSG_ENVELOPED_DATA_PKCS_1_5_VERSION = @as(u32, 0);
pub const CMSG_ENVELOPED_DATA_CMS_VERSION = @as(u32, 2);
pub const CMSG_ENVELOPED_RECIPIENT_V0 = @as(u32, 0);
pub const CMSG_ENVELOPED_RECIPIENT_V2 = @as(u32, 2);
pub const CMSG_ENVELOPED_RECIPIENT_V3 = @as(u32, 3);
pub const CMSG_ENVELOPED_RECIPIENT_V4 = @as(u32, 4);
pub const CMSG_KEY_TRANS_PKCS_1_5_VERSION = @as(u32, 0);
pub const CMSG_KEY_TRANS_CMS_VERSION = @as(u32, 2);
pub const CMSG_KEY_AGREE_VERSION = @as(u32, 3);
pub const CMSG_MAIL_LIST_VERSION = @as(u32, 4);
pub const CMSG_CTRL_VERIFY_SIGNATURE = @as(u32, 1);
pub const CMSG_CTRL_DECRYPT = @as(u32, 2);
pub const CMSG_CTRL_VERIFY_HASH = @as(u32, 5);
pub const CMSG_CTRL_ADD_SIGNER = @as(u32, 6);
pub const CMSG_CTRL_DEL_SIGNER = @as(u32, 7);
pub const CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR = @as(u32, 8);
pub const CMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR = @as(u32, 9);
pub const CMSG_CTRL_ADD_CERT = @as(u32, 10);
pub const CMSG_CTRL_DEL_CERT = @as(u32, 11);
pub const CMSG_CTRL_ADD_CRL = @as(u32, 12);
pub const CMSG_CTRL_DEL_CRL = @as(u32, 13);
pub const CMSG_CTRL_ADD_ATTR_CERT = @as(u32, 14);
pub const CMSG_CTRL_DEL_ATTR_CERT = @as(u32, 15);
pub const CMSG_CTRL_KEY_TRANS_DECRYPT = @as(u32, 16);
pub const CMSG_CTRL_KEY_AGREE_DECRYPT = @as(u32, 17);
pub const CMSG_CTRL_MAIL_LIST_DECRYPT = @as(u32, 18);
pub const CMSG_CTRL_VERIFY_SIGNATURE_EX = @as(u32, 19);
pub const CMSG_CTRL_ADD_CMS_SIGNER_INFO = @as(u32, 20);
pub const CMSG_CTRL_ENABLE_STRONG_SIGNATURE = @as(u32, 21);
pub const CMSG_VERIFY_SIGNER_PUBKEY = @as(u32, 1);
pub const CMSG_VERIFY_SIGNER_CERT = @as(u32, 2);
pub const CMSG_VERIFY_SIGNER_CHAIN = @as(u32, 3);
pub const CMSG_VERIFY_SIGNER_NULL = @as(u32, 4);
pub const CMSG_VERIFY_COUNTER_SIGN_ENABLE_STRONG_FLAG = @as(u32, 1);
pub const CMSG_OID_GEN_ENCRYPT_KEY_FUNC = "CryptMsgDllGenEncryptKey";
pub const CMSG_OID_EXPORT_ENCRYPT_KEY_FUNC = "CryptMsgDllExportEncryptKey";
pub const CMSG_OID_IMPORT_ENCRYPT_KEY_FUNC = "CryptMsgDllImportEncryptKey";
pub const CMSG_DEFAULT_INSTALLABLE_FUNC_OID = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 1));
pub const CMSG_CONTENT_ENCRYPT_PAD_ENCODED_LEN_FLAG = @as(u32, 1);
pub const CMSG_CONTENT_ENCRYPT_FREE_PARA_FLAG = @as(u32, 1);
pub const CMSG_CONTENT_ENCRYPT_FREE_OBJID_FLAG = @as(u32, 2);
pub const CMSG_CONTENT_ENCRYPT_RELEASE_CONTEXT_FLAG = @as(u32, 32768);
pub const CMSG_OID_GEN_CONTENT_ENCRYPT_KEY_FUNC = "CryptMsgDllGenContentEncryptKey";
pub const CMSG_OID_CAPI1_GEN_CONTENT_ENCRYPT_KEY_FUNC = "CryptMsgDllGenContentEncryptKey";
pub const CMSG_OID_CNG_GEN_CONTENT_ENCRYPT_KEY_FUNC = "CryptMsgDllCNGGenContentEncryptKey";
pub const CMSG_KEY_TRANS_ENCRYPT_FREE_PARA_FLAG = @as(u32, 1);
pub const CMSG_KEY_TRANS_ENCRYPT_FREE_OBJID_FLAG = @as(u32, 2);
pub const CMSG_OID_EXPORT_KEY_TRANS_FUNC = "CryptMsgDllExportKeyTrans";
pub const CMSG_OID_CAPI1_EXPORT_KEY_TRANS_FUNC = "CryptMsgDllExportKeyTrans";
pub const CMSG_OID_CNG_EXPORT_KEY_TRANS_FUNC = "CryptMsgDllCNGExportKeyTrans";
pub const CMSG_KEY_AGREE_ENCRYPT_FREE_PARA_FLAG = @as(u32, 1);
pub const CMSG_KEY_AGREE_ENCRYPT_FREE_MATERIAL_FLAG = @as(u32, 2);
pub const CMSG_KEY_AGREE_ENCRYPT_FREE_PUBKEY_ALG_FLAG = @as(u32, 4);
pub const CMSG_KEY_AGREE_ENCRYPT_FREE_PUBKEY_PARA_FLAG = @as(u32, 8);
pub const CMSG_KEY_AGREE_ENCRYPT_FREE_PUBKEY_BITS_FLAG = @as(u32, 16);
pub const CMSG_KEY_AGREE_ENCRYPT_FREE_OBJID_FLAG = @as(u32, 32);
pub const CMSG_OID_EXPORT_KEY_AGREE_FUNC = "CryptMsgDllExportKeyAgree";
pub const CMSG_OID_CAPI1_EXPORT_KEY_AGREE_FUNC = "CryptMsgDllExportKeyAgree";
pub const CMSG_OID_CNG_EXPORT_KEY_AGREE_FUNC = "CryptMsgDllCNGExportKeyAgree";
pub const CMSG_MAIL_LIST_ENCRYPT_FREE_PARA_FLAG = @as(u32, 1);
pub const CMSG_MAIL_LIST_ENCRYPT_FREE_OBJID_FLAG = @as(u32, 2);
pub const CMSG_OID_EXPORT_MAIL_LIST_FUNC = "CryptMsgDllExportMailList";
pub const CMSG_OID_CAPI1_EXPORT_MAIL_LIST_FUNC = "CryptMsgDllExportMailList";
pub const CMSG_OID_IMPORT_KEY_TRANS_FUNC = "CryptMsgDllImportKeyTrans";
pub const CMSG_OID_CAPI1_IMPORT_KEY_TRANS_FUNC = "CryptMsgDllImportKeyTrans";
pub const CMSG_OID_IMPORT_KEY_AGREE_FUNC = "CryptMsgDllImportKeyAgree";
pub const CMSG_OID_CAPI1_IMPORT_KEY_AGREE_FUNC = "CryptMsgDllImportKeyAgree";
pub const CMSG_OID_IMPORT_MAIL_LIST_FUNC = "CryptMsgDllImportMailList";
pub const CMSG_OID_CAPI1_IMPORT_MAIL_LIST_FUNC = "CryptMsgDllImportMailList";
pub const CMSG_OID_CNG_IMPORT_KEY_TRANS_FUNC = "CryptMsgDllCNGImportKeyTrans";
pub const CMSG_OID_CNG_IMPORT_KEY_AGREE_FUNC = "CryptMsgDllCNGImportKeyAgree";
pub const CMSG_OID_CNG_IMPORT_CONTENT_ENCRYPT_KEY_FUNC = "CryptMsgDllCNGImportContentEncryptKey";
pub const CERT_KEY_PROV_HANDLE_PROP_ID = @as(u32, 1);
pub const CERT_KEY_PROV_INFO_PROP_ID = @as(u32, 2);
pub const CERT_SHA1_HASH_PROP_ID = @as(u32, 3);
pub const CERT_MD5_HASH_PROP_ID = @as(u32, 4);
pub const CERT_HASH_PROP_ID = @as(u32, 3);
pub const CERT_KEY_CONTEXT_PROP_ID = @as(u32, 5);
pub const CERT_KEY_SPEC_PROP_ID = @as(u32, 6);
pub const CERT_IE30_RESERVED_PROP_ID = @as(u32, 7);
pub const CERT_PUBKEY_HASH_RESERVED_PROP_ID = @as(u32, 8);
pub const CERT_ENHKEY_USAGE_PROP_ID = @as(u32, 9);
pub const CERT_CTL_USAGE_PROP_ID = @as(u32, 9);
pub const CERT_NEXT_UPDATE_LOCATION_PROP_ID = @as(u32, 10);
pub const CERT_FRIENDLY_NAME_PROP_ID = @as(u32, 11);
pub const CERT_PVK_FILE_PROP_ID = @as(u32, 12);
pub const CERT_DESCRIPTION_PROP_ID = @as(u32, 13);
pub const CERT_ACCESS_STATE_PROP_ID = @as(u32, 14);
pub const CERT_SIGNATURE_HASH_PROP_ID = @as(u32, 15);
pub const CERT_SMART_CARD_DATA_PROP_ID = @as(u32, 16);
pub const CERT_EFS_PROP_ID = @as(u32, 17);
pub const CERT_FORTEZZA_DATA_PROP_ID = @as(u32, 18);
pub const CERT_ARCHIVED_PROP_ID = @as(u32, 19);
pub const CERT_KEY_IDENTIFIER_PROP_ID = @as(u32, 20);
pub const CERT_AUTO_ENROLL_PROP_ID = @as(u32, 21);
pub const CERT_PUBKEY_ALG_PARA_PROP_ID = @as(u32, 22);
pub const CERT_CROSS_CERT_DIST_POINTS_PROP_ID = @as(u32, 23);
pub const CERT_ISSUER_PUBLIC_KEY_MD5_HASH_PROP_ID = @as(u32, 24);
pub const CERT_SUBJECT_PUBLIC_KEY_MD5_HASH_PROP_ID = @as(u32, 25);
pub const CERT_ENROLLMENT_PROP_ID = @as(u32, 26);
pub const CERT_DATE_STAMP_PROP_ID = @as(u32, 27);
pub const CERT_ISSUER_SERIAL_NUMBER_MD5_HASH_PROP_ID = @as(u32, 28);
pub const CERT_SUBJECT_NAME_MD5_HASH_PROP_ID = @as(u32, 29);
pub const CERT_EXTENDED_ERROR_INFO_PROP_ID = @as(u32, 30);
pub const CERT_RENEWAL_PROP_ID = @as(u32, 64);
pub const CERT_ARCHIVED_KEY_HASH_PROP_ID = @as(u32, 65);
pub const CERT_AUTO_ENROLL_RETRY_PROP_ID = @as(u32, 66);
pub const CERT_AIA_URL_RETRIEVED_PROP_ID = @as(u32, 67);
pub const CERT_AUTHORITY_INFO_ACCESS_PROP_ID = @as(u32, 68);
pub const CERT_BACKED_UP_PROP_ID = @as(u32, 69);
pub const CERT_OCSP_RESPONSE_PROP_ID = @as(u32, 70);
pub const CERT_REQUEST_ORIGINATOR_PROP_ID = @as(u32, 71);
pub const CERT_SOURCE_LOCATION_PROP_ID = @as(u32, 72);
pub const CERT_SOURCE_URL_PROP_ID = @as(u32, 73);
pub const CERT_NEW_KEY_PROP_ID = @as(u32, 74);
pub const CERT_OCSP_CACHE_PREFIX_PROP_ID = @as(u32, 75);
pub const CERT_SMART_CARD_ROOT_INFO_PROP_ID = @as(u32, 76);
pub const CERT_NO_AUTO_EXPIRE_CHECK_PROP_ID = @as(u32, 77);
pub const CERT_NCRYPT_KEY_HANDLE_PROP_ID = @as(u32, 78);
pub const CERT_HCRYPTPROV_OR_NCRYPT_KEY_HANDLE_PROP_ID = @as(u32, 79);
pub const CERT_SUBJECT_INFO_ACCESS_PROP_ID = @as(u32, 80);
pub const CERT_CA_OCSP_AUTHORITY_INFO_ACCESS_PROP_ID = @as(u32, 81);
pub const CERT_CA_DISABLE_CRL_PROP_ID = @as(u32, 82);
pub const CERT_ROOT_PROGRAM_CERT_POLICIES_PROP_ID = @as(u32, 83);
pub const CERT_ROOT_PROGRAM_NAME_CONSTRAINTS_PROP_ID = @as(u32, 84);
pub const CERT_SUBJECT_OCSP_AUTHORITY_INFO_ACCESS_PROP_ID = @as(u32, 85);
pub const CERT_SUBJECT_DISABLE_CRL_PROP_ID = @as(u32, 86);
pub const CERT_CEP_PROP_ID = @as(u32, 87);
pub const CERT_SIGN_HASH_CNG_ALG_PROP_ID = @as(u32, 89);
pub const CERT_SCARD_PIN_ID_PROP_ID = @as(u32, 90);
pub const CERT_SCARD_PIN_INFO_PROP_ID = @as(u32, 91);
pub const CERT_SUBJECT_PUB_KEY_BIT_LENGTH_PROP_ID = @as(u32, 92);
pub const CERT_PUB_KEY_CNG_ALG_BIT_LENGTH_PROP_ID = @as(u32, 93);
pub const CERT_ISSUER_PUB_KEY_BIT_LENGTH_PROP_ID = @as(u32, 94);
pub const CERT_ISSUER_CHAIN_SIGN_HASH_CNG_ALG_PROP_ID = @as(u32, 95);
pub const CERT_ISSUER_CHAIN_PUB_KEY_CNG_ALG_BIT_LENGTH_PROP_ID = @as(u32, 96);
pub const CERT_NO_EXPIRE_NOTIFICATION_PROP_ID = @as(u32, 97);
pub const CERT_AUTH_ROOT_SHA256_HASH_PROP_ID = @as(u32, 98);
pub const CERT_NCRYPT_KEY_HANDLE_TRANSFER_PROP_ID = @as(u32, 99);
pub const CERT_HCRYPTPROV_TRANSFER_PROP_ID = @as(u32, 100);
pub const CERT_SMART_CARD_READER_PROP_ID = @as(u32, 101);
pub const CERT_SEND_AS_TRUSTED_ISSUER_PROP_ID = @as(u32, 102);
pub const CERT_KEY_REPAIR_ATTEMPTED_PROP_ID = @as(u32, 103);
pub const CERT_DISALLOWED_FILETIME_PROP_ID = @as(u32, 104);
pub const CERT_ROOT_PROGRAM_CHAIN_POLICIES_PROP_ID = @as(u32, 105);
pub const CERT_SMART_CARD_READER_NON_REMOVABLE_PROP_ID = @as(u32, 106);
pub const CERT_SHA256_HASH_PROP_ID = @as(u32, 107);
pub const CERT_SCEP_SERVER_CERTS_PROP_ID = @as(u32, 108);
pub const CERT_SCEP_RA_SIGNATURE_CERT_PROP_ID = @as(u32, 109);
pub const CERT_SCEP_RA_ENCRYPTION_CERT_PROP_ID = @as(u32, 110);
pub const CERT_SCEP_CA_CERT_PROP_ID = @as(u32, 111);
pub const CERT_SCEP_SIGNER_CERT_PROP_ID = @as(u32, 112);
pub const CERT_SCEP_NONCE_PROP_ID = @as(u32, 113);
pub const CERT_SCEP_ENCRYPT_HASH_CNG_ALG_PROP_ID = @as(u32, 114);
pub const CERT_SCEP_FLAGS_PROP_ID = @as(u32, 115);
pub const CERT_SCEP_GUID_PROP_ID = @as(u32, 116);
pub const CERT_SERIALIZABLE_KEY_CONTEXT_PROP_ID = @as(u32, 117);
pub const CERT_ISOLATED_KEY_PROP_ID = @as(u32, 118);
pub const CERT_SERIAL_CHAIN_PROP_ID = @as(u32, 119);
pub const CERT_KEY_CLASSIFICATION_PROP_ID = @as(u32, 120);
pub const CERT_OCSP_MUST_STAPLE_PROP_ID = @as(u32, 121);
pub const CERT_DISALLOWED_ENHKEY_USAGE_PROP_ID = @as(u32, 122);
pub const CERT_NONCOMPLIANT_ROOT_URL_PROP_ID = @as(u32, 123);
pub const CERT_PIN_SHA256_HASH_PROP_ID = @as(u32, 124);
pub const CERT_CLR_DELETE_KEY_PROP_ID = @as(u32, 125);
pub const CERT_NOT_BEFORE_FILETIME_PROP_ID = @as(u32, 126);
pub const CERT_NOT_BEFORE_ENHKEY_USAGE_PROP_ID = @as(u32, 127);
pub const CERT_FIRST_RESERVED_PROP_ID = @as(u32, 128);
pub const CERT_LAST_RESERVED_PROP_ID = @as(u32, 32767);
pub const CERT_FIRST_USER_PROP_ID = @as(u32, 32768);
pub const CERT_LAST_USER_PROP_ID = @as(u32, 65535);
pub const szOID_CERT_PROP_ID_PREFIX = "1.3.6.1.4.1.311.10.11.";
pub const szOID_CERT_KEY_IDENTIFIER_PROP_ID = "1.3.6.1.4.1.311.10.11.20";
pub const szOID_CERT_ISSUER_SERIAL_NUMBER_MD5_HASH_PROP_ID = "1.3.6.1.4.1.311.10.11.28";
pub const szOID_CERT_SUBJECT_NAME_MD5_HASH_PROP_ID = "1.3.6.1.4.1.311.10.11.29";
pub const szOID_CERT_MD5_HASH_PROP_ID = "1.3.6.1.4.1.311.10.11.4";
pub const szOID_CERT_SIGNATURE_HASH_PROP_ID = "1.3.6.1.4.1.311.10.11.15";
pub const szOID_DISALLOWED_HASH = "1.3.6.1.4.1.311.10.11.15";
pub const szOID_CERT_DISALLOWED_FILETIME_PROP_ID = "1.3.6.1.4.1.311.10.11.104";
pub const CERT_ACCESS_STATE_WRITE_PERSIST_FLAG = @as(u32, 1);
pub const CERT_ACCESS_STATE_SYSTEM_STORE_FLAG = @as(u32, 2);
pub const CERT_ACCESS_STATE_LM_SYSTEM_STORE_FLAG = @as(u32, 4);
pub const CERT_ACCESS_STATE_GP_SYSTEM_STORE_FLAG = @as(u32, 8);
pub const CERT_ACCESS_STATE_SHARED_USER_FLAG = @as(u32, 16);
pub const szOID_ROOT_PROGRAM_AUTO_UPDATE_CA_REVOCATION = "1.3.6.1.4.1.311.60.3.1";
pub const szOID_ROOT_PROGRAM_AUTO_UPDATE_END_REVOCATION = "1.3.6.1.4.1.311.60.3.2";
pub const szOID_ROOT_PROGRAM_NO_OCSP_FAILOVER_TO_CRL = "1.3.6.1.4.1.311.60.3.3";
pub const CERT_STORE_PROV_MSG = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 1));
pub const CERT_STORE_PROV_MEMORY = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 2));
pub const CERT_STORE_PROV_FILE = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 3));
pub const CERT_STORE_PROV_REG = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 4));
pub const CERT_STORE_PROV_PKCS7 = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 5));
pub const CERT_STORE_PROV_SERIALIZED = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 6));
pub const CERT_STORE_PROV_FILENAME_A = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 7));
pub const CERT_STORE_PROV_FILENAME_W = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 8));
pub const CERT_STORE_PROV_FILENAME = @as(i32, 8);
pub const CERT_STORE_PROV_SYSTEM_A = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 9));
pub const CERT_STORE_PROV_SYSTEM_W = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 10));
pub const CERT_STORE_PROV_SYSTEM = @as(i32, 10);
pub const CERT_STORE_PROV_COLLECTION = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 11));
pub const CERT_STORE_PROV_SYSTEM_REGISTRY_A = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 12));
pub const CERT_STORE_PROV_SYSTEM_REGISTRY_W = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 13));
pub const CERT_STORE_PROV_SYSTEM_REGISTRY = @as(i32, 13);
pub const CERT_STORE_PROV_PHYSICAL_W = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 14));
pub const CERT_STORE_PROV_PHYSICAL = @as(i32, 14);
pub const CERT_STORE_PROV_SMART_CARD_W = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 15));
pub const CERT_STORE_PROV_SMART_CARD = @as(i32, 15);
pub const CERT_STORE_PROV_LDAP_W = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 16));
pub const CERT_STORE_PROV_LDAP = @as(i32, 16);
pub const CERT_STORE_PROV_PKCS12 = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 17));
pub const sz_CERT_STORE_PROV_MEMORY = "Memory";
pub const sz_CERT_STORE_PROV_FILENAME_W = "File";
pub const sz_CERT_STORE_PROV_FILENAME = "File";
pub const sz_CERT_STORE_PROV_SYSTEM_W = "System";
pub const sz_CERT_STORE_PROV_SYSTEM = "System";
pub const sz_CERT_STORE_PROV_PKCS7 = "PKCS7";
pub const sz_CERT_STORE_PROV_PKCS12 = "PKCS12";
pub const sz_CERT_STORE_PROV_SERIALIZED = "Serialized";
pub const sz_CERT_STORE_PROV_COLLECTION = "Collection";
pub const sz_CERT_STORE_PROV_SYSTEM_REGISTRY_W = "SystemRegistry";
pub const sz_CERT_STORE_PROV_SYSTEM_REGISTRY = "SystemRegistry";
pub const sz_CERT_STORE_PROV_PHYSICAL_W = "Physical";
pub const sz_CERT_STORE_PROV_PHYSICAL = "Physical";
pub const sz_CERT_STORE_PROV_SMART_CARD_W = "SmartCard";
pub const sz_CERT_STORE_PROV_SMART_CARD = "SmartCard";
pub const sz_CERT_STORE_PROV_LDAP_W = "Ldap";
pub const sz_CERT_STORE_PROV_LDAP = "Ldap";
pub const CERT_STORE_SIGNATURE_FLAG = @as(u32, 1);
pub const CERT_STORE_TIME_VALIDITY_FLAG = @as(u32, 2);
pub const CERT_STORE_REVOCATION_FLAG = @as(u32, 4);
pub const CERT_STORE_NO_CRL_FLAG = @as(u32, 65536);
pub const CERT_STORE_NO_ISSUER_FLAG = @as(u32, 131072);
pub const CERT_STORE_BASE_CRL_FLAG = @as(u32, 256);
pub const CERT_STORE_DELTA_CRL_FLAG = @as(u32, 512);
pub const CERT_STORE_UNSAFE_PHYSICAL_FLAG = @as(u32, 32);
pub const CERT_STORE_SHARE_STORE_FLAG = @as(u32, 64);
pub const CERT_STORE_MANIFOLD_FLAG = @as(u32, 256);
pub const CERT_SYSTEM_STORE_MASK = @as(u32, 4294901760);
pub const CERT_SYSTEM_STORE_UNPROTECTED_FLAG = @as(u32, 1073741824);
pub const CERT_SYSTEM_STORE_DEFER_READ_FLAG = @as(u32, 536870912);
pub const CERT_SYSTEM_STORE_LOCATION_SHIFT = @as(u32, 16);
pub const CERT_SYSTEM_STORE_CURRENT_USER_ID = @as(u32, 1);
pub const CERT_SYSTEM_STORE_LOCAL_MACHINE_ID = @as(u32, 2);
pub const CERT_SYSTEM_STORE_CURRENT_SERVICE_ID = @as(u32, 4);
pub const CERT_SYSTEM_STORE_SERVICES_ID = @as(u32, 5);
pub const CERT_SYSTEM_STORE_USERS_ID = @as(u32, 6);
pub const CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY_ID = @as(u32, 7);
pub const CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY_ID = @as(u32, 8);
pub const CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE_ID = @as(u32, 9);
pub const CERT_SYSTEM_STORE_LOCAL_MACHINE_WCOS_ID = @as(u32, 10);
pub const CERT_GROUP_POLICY_SYSTEM_STORE_REGPATH = "Software\\Policies\\Microsoft\\SystemCertificates";
pub const CERT_EFSBLOB_VALUE_NAME = "EFSBlob";
pub const CERT_PROT_ROOT_FLAGS_VALUE_NAME = "Flags";
pub const CERT_PROT_ROOT_DISABLE_CURRENT_USER_FLAG = @as(u32, 1);
pub const CERT_PROT_ROOT_INHIBIT_ADD_AT_INIT_FLAG = @as(u32, 2);
pub const CERT_PROT_ROOT_INHIBIT_PURGE_LM_FLAG = @as(u32, 4);
pub const CERT_PROT_ROOT_DISABLE_LM_AUTH_FLAG = @as(u32, 8);
pub const CERT_PROT_ROOT_ONLY_LM_GPT_FLAG = @as(u32, 8);
pub const CERT_PROT_ROOT_DISABLE_NT_AUTH_REQUIRED_FLAG = @as(u32, 16);
pub const CERT_PROT_ROOT_DISABLE_NOT_DEFINED_NAME_CONSTRAINT_FLAG = @as(u32, 32);
pub const CERT_PROT_ROOT_DISABLE_PEER_TRUST = @as(u32, 65536);
pub const CERT_PROT_ROOT_PEER_USAGES_VALUE_NAME = "PeerUsages";
pub const CERT_PROT_ROOT_PEER_USAGES_VALUE_NAME_A = "PeerUsages";
pub const CERT_LOCAL_MACHINE_SYSTEM_STORE_REGPATH = "Software\\Microsoft\\SystemCertificates";
pub const CERT_TRUST_PUB_AUTHENTICODE_FLAGS_VALUE_NAME = "AuthenticodeFlags";
pub const CERT_TRUST_PUB_ALLOW_TRUST_MASK = @as(u32, 3);
pub const CERT_TRUST_PUB_ALLOW_END_USER_TRUST = @as(u32, 0);
pub const CERT_TRUST_PUB_ALLOW_MACHINE_ADMIN_TRUST = @as(u32, 1);
pub const CERT_TRUST_PUB_ALLOW_ENTERPRISE_ADMIN_TRUST = @as(u32, 2);
pub const CERT_TRUST_PUB_CHECK_PUBLISHER_REV_FLAG = @as(u32, 256);
pub const CERT_TRUST_PUB_CHECK_TIMESTAMP_REV_FLAG = @as(u32, 512);
pub const CERT_OCM_SUBCOMPONENTS_LOCAL_MACHINE_REGPATH = "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup\\OC Manager\\Subcomponents";
pub const CERT_OCM_SUBCOMPONENTS_ROOT_AUTO_UPDATE_VALUE_NAME = "RootAutoUpdate";
pub const CERT_DISABLE_ROOT_AUTO_UPDATE_VALUE_NAME = "DisableRootAutoUpdate";
pub const CERT_ENABLE_DISALLOWED_CERT_AUTO_UPDATE_VALUE_NAME = "EnableDisallowedCertAutoUpdate";
pub const CERT_DISABLE_PIN_RULES_AUTO_UPDATE_VALUE_NAME = "DisablePinRulesAutoUpdate";
pub const CERT_AUTO_UPDATE_ROOT_DIR_URL_VALUE_NAME = "RootDirUrl";
pub const CERT_AUTO_UPDATE_SYNC_FROM_DIR_URL_VALUE_NAME = "SyncFromDirUrl";
pub const CERT_AUTH_ROOT_AUTO_UPDATE_ROOT_DIR_URL_VALUE_NAME = "RootDirUrl";
pub const CERT_AUTH_ROOT_AUTO_UPDATE_SYNC_DELTA_TIME_VALUE_NAME = "SyncDeltaTime";
pub const CERT_AUTH_ROOT_AUTO_UPDATE_FLAGS_VALUE_NAME = "Flags";
pub const CERT_AUTH_ROOT_AUTO_UPDATE_DISABLE_UNTRUSTED_ROOT_LOGGING_FLAG = @as(u32, 1);
pub const CERT_AUTH_ROOT_AUTO_UPDATE_DISABLE_PARTIAL_CHAIN_LOGGING_FLAG = @as(u32, 2);
pub const CERT_AUTO_UPDATE_DISABLE_RANDOM_QUERY_STRING_FLAG = @as(u32, 4);
pub const CERT_AUTH_ROOT_AUTO_UPDATE_LAST_SYNC_TIME_VALUE_NAME = "LastSyncTime";
pub const CERT_AUTH_ROOT_AUTO_UPDATE_ENCODED_CTL_VALUE_NAME = "EncodedCtl";
pub const CERT_AUTH_ROOT_CTL_FILENAME = "authroot.stl";
pub const CERT_AUTH_ROOT_CTL_FILENAME_A = "authroot.stl";
pub const CERT_AUTH_ROOT_CAB_FILENAME = "authrootstl.cab";
pub const CERT_AUTH_ROOT_SEQ_FILENAME = "authrootseq.txt";
pub const CERT_AUTH_ROOT_CERT_EXT = ".crt";
pub const CERT_DISALLOWED_CERT_AUTO_UPDATE_SYNC_DELTA_TIME_VALUE_NAME = "DisallowedCertSyncDeltaTime";
pub const CERT_DISALLOWED_CERT_AUTO_UPDATE_LAST_SYNC_TIME_VALUE_NAME = "DisallowedCertLastSyncTime";
pub const CERT_DISALLOWED_CERT_AUTO_UPDATE_ENCODED_CTL_VALUE_NAME = "DisallowedCertEncodedCtl";
pub const CERT_DISALLOWED_CERT_CTL_FILENAME = "disallowedcert.stl";
pub const CERT_DISALLOWED_CERT_CTL_FILENAME_A = "disallowedcert.stl";
pub const CERT_DISALLOWED_CERT_CAB_FILENAME = "disallowedcertstl.cab";
pub const CERT_DISALLOWED_CERT_AUTO_UPDATE_LIST_IDENTIFIER = "DisallowedCert_AutoUpdate_1";
pub const CERT_PIN_RULES_AUTO_UPDATE_SYNC_DELTA_TIME_VALUE_NAME = "PinRulesSyncDeltaTime";
pub const CERT_PIN_RULES_AUTO_UPDATE_LAST_SYNC_TIME_VALUE_NAME = "PinRulesLastSyncTime";
pub const CERT_PIN_RULES_AUTO_UPDATE_ENCODED_CTL_VALUE_NAME = "PinRulesEncodedCtl";
pub const CERT_PIN_RULES_CTL_FILENAME = "pinrules.stl";
pub const CERT_PIN_RULES_CTL_FILENAME_A = "pinrules.stl";
pub const CERT_PIN_RULES_CAB_FILENAME = "pinrulesstl.cab";
pub const CERT_PIN_RULES_AUTO_UPDATE_LIST_IDENTIFIER = "PinRules_AutoUpdate_1";
pub const CERT_REGISTRY_STORE_REMOTE_FLAG = @as(u32, 65536);
pub const CERT_REGISTRY_STORE_SERIALIZED_FLAG = @as(u32, 131072);
pub const CERT_REGISTRY_STORE_CLIENT_GPT_FLAG = @as(u32, 2147483648);
pub const CERT_REGISTRY_STORE_LM_GPT_FLAG = @as(u32, 16777216);
pub const CERT_REGISTRY_STORE_ROAMING_FLAG = @as(u32, 262144);
pub const CERT_REGISTRY_STORE_MY_IE_DIRTY_FLAG = @as(u32, 524288);
pub const CERT_REGISTRY_STORE_EXTERNAL_FLAG = @as(u32, 1048576);
pub const CERT_IE_DIRTY_FLAGS_REGPATH = "Software\\Microsoft\\Cryptography\\IEDirtyFlags";
pub const CERT_FILE_STORE_COMMIT_ENABLE_FLAG = @as(u32, 65536);
pub const CERT_LDAP_STORE_SIGN_FLAG = @as(u32, 65536);
pub const CERT_LDAP_STORE_AREC_EXCLUSIVE_FLAG = @as(u32, 131072);
pub const CERT_LDAP_STORE_OPENED_FLAG = @as(u32, 262144);
pub const CERT_LDAP_STORE_UNBIND_FLAG = @as(u32, 524288);
pub const CRYPT_OID_OPEN_STORE_PROV_FUNC = "CertDllOpenStoreProv";
pub const CERT_STORE_PROV_GP_SYSTEM_STORE_FLAG = @as(u32, 32);
pub const CERT_STORE_PROV_SHARED_USER_FLAG = @as(u32, 64);
pub const CERT_STORE_PROV_CLOSE_FUNC = @as(u32, 0);
pub const CERT_STORE_PROV_READ_CERT_FUNC = @as(u32, 1);
pub const CERT_STORE_PROV_WRITE_CERT_FUNC = @as(u32, 2);
pub const CERT_STORE_PROV_DELETE_CERT_FUNC = @as(u32, 3);
pub const CERT_STORE_PROV_SET_CERT_PROPERTY_FUNC = @as(u32, 4);
pub const CERT_STORE_PROV_READ_CRL_FUNC = @as(u32, 5);
pub const CERT_STORE_PROV_WRITE_CRL_FUNC = @as(u32, 6);
pub const CERT_STORE_PROV_DELETE_CRL_FUNC = @as(u32, 7);
pub const CERT_STORE_PROV_SET_CRL_PROPERTY_FUNC = @as(u32, 8);
pub const CERT_STORE_PROV_READ_CTL_FUNC = @as(u32, 9);
pub const CERT_STORE_PROV_WRITE_CTL_FUNC = @as(u32, 10);
pub const CERT_STORE_PROV_DELETE_CTL_FUNC = @as(u32, 11);
pub const CERT_STORE_PROV_SET_CTL_PROPERTY_FUNC = @as(u32, 12);
pub const CERT_STORE_PROV_CONTROL_FUNC = @as(u32, 13);
pub const CERT_STORE_PROV_FIND_CERT_FUNC = @as(u32, 14);
pub const CERT_STORE_PROV_FREE_FIND_CERT_FUNC = @as(u32, 15);
pub const CERT_STORE_PROV_GET_CERT_PROPERTY_FUNC = @as(u32, 16);
pub const CERT_STORE_PROV_FIND_CRL_FUNC = @as(u32, 17);
pub const CERT_STORE_PROV_FREE_FIND_CRL_FUNC = @as(u32, 18);
pub const CERT_STORE_PROV_GET_CRL_PROPERTY_FUNC = @as(u32, 19);
pub const CERT_STORE_PROV_FIND_CTL_FUNC = @as(u32, 20);
pub const CERT_STORE_PROV_FREE_FIND_CTL_FUNC = @as(u32, 21);
pub const CERT_STORE_PROV_GET_CTL_PROPERTY_FUNC = @as(u32, 22);
pub const CERT_STORE_PROV_WRITE_ADD_FLAG = @as(u32, 1);
pub const CERT_STORE_SAVE_AS_PKCS12 = @as(u32, 3);
pub const CERT_CLOSE_STORE_FORCE_FLAG = @as(u32, 1);
pub const CERT_CLOSE_STORE_CHECK_FLAG = @as(u32, 2);
pub const CERT_COMPARE_MASK = @as(u32, 65535);
pub const CERT_COMPARE_ANY = @as(u32, 0);
pub const CERT_COMPARE_SHA1_HASH = @as(u32, 1);
pub const CERT_COMPARE_NAME = @as(u32, 2);
pub const CERT_COMPARE_ATTR = @as(u32, 3);
pub const CERT_COMPARE_MD5_HASH = @as(u32, 4);
pub const CERT_COMPARE_PROPERTY = @as(u32, 5);
pub const CERT_COMPARE_PUBLIC_KEY = @as(u32, 6);
pub const CERT_COMPARE_HASH = @as(u32, 1);
pub const CERT_COMPARE_NAME_STR_A = @as(u32, 7);
pub const CERT_COMPARE_NAME_STR_W = @as(u32, 8);
pub const CERT_COMPARE_KEY_SPEC = @as(u32, 9);
pub const CERT_COMPARE_ENHKEY_USAGE = @as(u32, 10);
pub const CERT_COMPARE_CTL_USAGE = @as(u32, 10);
pub const CERT_COMPARE_SUBJECT_CERT = @as(u32, 11);
pub const CERT_COMPARE_ISSUER_OF = @as(u32, 12);
pub const CERT_COMPARE_EXISTING = @as(u32, 13);
pub const CERT_COMPARE_SIGNATURE_HASH = @as(u32, 14);
pub const CERT_COMPARE_KEY_IDENTIFIER = @as(u32, 15);
pub const CERT_COMPARE_CERT_ID = @as(u32, 16);
pub const CERT_COMPARE_CROSS_CERT_DIST_POINTS = @as(u32, 17);
pub const CERT_COMPARE_PUBKEY_MD5_HASH = @as(u32, 18);
pub const CERT_COMPARE_SUBJECT_INFO_ACCESS = @as(u32, 19);
pub const CERT_COMPARE_HASH_STR = @as(u32, 20);
pub const CERT_COMPARE_HAS_PRIVATE_KEY = @as(u32, 21);
pub const CERT_SET_PROPERTY_IGNORE_PERSIST_ERROR_FLAG = @as(u32, 2147483648);
pub const CERT_SET_PROPERTY_INHIBIT_PERSIST_FLAG = @as(u32, 1073741824);
pub const CTL_ENTRY_FROM_PROP_CHAIN_FLAG = @as(u32, 1);
pub const CRL_FIND_ANY = @as(u32, 0);
pub const CRL_FIND_ISSUED_BY = @as(u32, 1);
pub const CRL_FIND_EXISTING = @as(u32, 2);
pub const CRL_FIND_ISSUED_FOR = @as(u32, 3);
pub const CRL_FIND_ISSUED_BY_AKI_FLAG = @as(u32, 1);
pub const CRL_FIND_ISSUED_BY_SIGNATURE_FLAG = @as(u32, 2);
pub const CRL_FIND_ISSUED_BY_DELTA_FLAG = @as(u32, 4);
pub const CRL_FIND_ISSUED_BY_BASE_FLAG = @as(u32, 8);
pub const CRL_FIND_ISSUED_FOR_SET_STRONG_PROPERTIES_FLAG = @as(u32, 16);
pub const CERT_STORE_ADD_NEW = @as(u32, 1);
pub const CERT_STORE_ADD_USE_EXISTING = @as(u32, 2);
pub const CERT_STORE_ADD_REPLACE_EXISTING = @as(u32, 3);
pub const CERT_STORE_ADD_ALWAYS = @as(u32, 4);
pub const CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES = @as(u32, 5);
pub const CERT_STORE_ADD_NEWER = @as(u32, 6);
pub const CERT_STORE_ADD_NEWER_INHERIT_PROPERTIES = @as(u32, 7);
pub const CERT_STORE_CERTIFICATE_CONTEXT = @as(u32, 1);
pub const CERT_STORE_CRL_CONTEXT = @as(u32, 2);
pub const CERT_STORE_CTL_CONTEXT = @as(u32, 3);
pub const CTL_ANY_SUBJECT_TYPE = @as(u32, 1);
pub const CTL_CERT_SUBJECT_TYPE = @as(u32, 2);
pub const CTL_FIND_NO_LIST_ID_CBDATA = @as(u32, 4294967295);
pub const CERT_STORE_CTRL_RESYNC = @as(u32, 1);
pub const CERT_STORE_CTRL_NOTIFY_CHANGE = @as(u32, 2);
pub const CERT_STORE_CTRL_COMMIT = @as(u32, 3);
pub const CERT_STORE_CTRL_AUTO_RESYNC = @as(u32, 4);
pub const CERT_STORE_CTRL_CANCEL_NOTIFY = @as(u32, 5);
pub const CERT_STORE_LOCALIZED_NAME_PROP_ID = @as(u32, 4096);
pub const CERT_CREATE_CONTEXT_NOCOPY_FLAG = @as(u32, 1);
pub const CERT_CREATE_CONTEXT_SORTED_FLAG = @as(u32, 2);
pub const CERT_CREATE_CONTEXT_NO_HCRYPTMSG_FLAG = @as(u32, 4);
pub const CERT_CREATE_CONTEXT_NO_ENTRY_FLAG = @as(u32, 8);
pub const CERT_PHYSICAL_STORE_ADD_ENABLE_FLAG = @as(u32, 1);
pub const CERT_PHYSICAL_STORE_OPEN_DISABLE_FLAG = @as(u32, 2);
pub const CERT_PHYSICAL_STORE_REMOTE_OPEN_DISABLE_FLAG = @as(u32, 4);
pub const CERT_PHYSICAL_STORE_INSERT_COMPUTER_NAME_ENABLE_FLAG = @as(u32, 8);
pub const CERT_PHYSICAL_STORE_PREDEFINED_ENUM_FLAG = @as(u32, 1);
pub const CERT_PHYSICAL_STORE_DEFAULT_NAME = ".Default";
pub const CERT_PHYSICAL_STORE_GROUP_POLICY_NAME = ".GroupPolicy";
pub const CERT_PHYSICAL_STORE_LOCAL_MACHINE_NAME = ".LocalMachine";
pub const CERT_PHYSICAL_STORE_DS_USER_CERTIFICATE_NAME = ".UserCertificate";
pub const CERT_PHYSICAL_STORE_LOCAL_MACHINE_GROUP_POLICY_NAME = ".LocalMachineGroupPolicy";
pub const CERT_PHYSICAL_STORE_ENTERPRISE_NAME = ".Enterprise";
pub const CERT_PHYSICAL_STORE_AUTH_ROOT_NAME = ".AuthRoot";
pub const CERT_PHYSICAL_STORE_SMART_CARD_NAME = ".SmartCard";
pub const CRYPT_OID_OPEN_SYSTEM_STORE_PROV_FUNC = "CertDllOpenSystemStoreProv";
pub const CRYPT_OID_REGISTER_SYSTEM_STORE_FUNC = "CertDllRegisterSystemStore";
pub const CRYPT_OID_UNREGISTER_SYSTEM_STORE_FUNC = "CertDllUnregisterSystemStore";
pub const CRYPT_OID_ENUM_SYSTEM_STORE_FUNC = "CertDllEnumSystemStore";
pub const CRYPT_OID_REGISTER_PHYSICAL_STORE_FUNC = "CertDllRegisterPhysicalStore";
pub const CRYPT_OID_UNREGISTER_PHYSICAL_STORE_FUNC = "CertDllUnregisterPhysicalStore";
pub const CRYPT_OID_ENUM_PHYSICAL_STORE_FUNC = "CertDllEnumPhysicalStore";
pub const CRYPT_OID_SYSTEM_STORE_LOCATION_VALUE_NAME = "SystemStoreLocation";
pub const CMSG_TRUSTED_SIGNER_FLAG = @as(u32, 1);
pub const CMSG_SIGNER_ONLY_FLAG = @as(u32, 2);
pub const CMSG_USE_SIGNER_INDEX_FLAG = @as(u32, 4);
pub const CMSG_CMS_ENCAPSULATED_CTL_FLAG = @as(u32, 32768);
pub const CMSG_ENCODE_SORTED_CTL_FLAG = @as(u32, 1);
pub const CMSG_ENCODE_HASHED_SUBJECT_IDENTIFIER_FLAG = @as(u32, 2);
pub const CERT_VERIFY_INHIBIT_CTL_UPDATE_FLAG = @as(u32, 1);
pub const CERT_VERIFY_TRUSTED_SIGNERS_FLAG = @as(u32, 2);
pub const CERT_VERIFY_NO_TIME_CHECK_FLAG = @as(u32, 4);
pub const CERT_VERIFY_ALLOW_MORE_USAGE_FLAG = @as(u32, 8);
pub const CERT_VERIFY_UPDATED_CTL_FLAG = @as(u32, 1);
pub const CERT_CONTEXT_REVOCATION_TYPE = @as(u32, 1);
pub const CERT_VERIFY_REV_CHAIN_FLAG = @as(u32, 1);
pub const CERT_VERIFY_CACHE_ONLY_BASED_REVOCATION = @as(u32, 2);
pub const CERT_VERIFY_REV_ACCUMULATIVE_TIMEOUT_FLAG = @as(u32, 4);
pub const CERT_VERIFY_REV_SERVER_OCSP_FLAG = @as(u32, 8);
pub const CERT_VERIFY_REV_NO_OCSP_FAILOVER_TO_CRL_FLAG = @as(u32, 16);
pub const CERT_VERIFY_REV_SERVER_OCSP_WIRE_ONLY_FLAG = @as(u32, 32);
pub const CERT_UNICODE_IS_RDN_ATTRS_FLAG = @as(u32, 1);
pub const CERT_CASE_INSENSITIVE_IS_RDN_ATTRS_FLAG = @as(u32, 2);
pub const CRYPT_VERIFY_CERT_SIGN_SUBJECT_BLOB = @as(u32, 1);
pub const CRYPT_VERIFY_CERT_SIGN_SUBJECT_CERT = @as(u32, 2);
pub const CRYPT_VERIFY_CERT_SIGN_SUBJECT_CRL = @as(u32, 3);
pub const CRYPT_VERIFY_CERT_SIGN_SUBJECT_OCSP_BASIC_SIGNED_RESPONSE = @as(u32, 4);
pub const CRYPT_VERIFY_CERT_SIGN_ISSUER_PUBKEY = @as(u32, 1);
pub const CRYPT_VERIFY_CERT_SIGN_ISSUER_CERT = @as(u32, 2);
pub const CRYPT_VERIFY_CERT_SIGN_ISSUER_CHAIN = @as(u32, 3);
pub const CRYPT_VERIFY_CERT_SIGN_ISSUER_NULL = @as(u32, 4);
pub const CRYPT_VERIFY_CERT_SIGN_CHECK_WEAK_HASH_FLAG = @as(u32, 8);
pub const CRYPT_OID_EXTRACT_ENCODED_SIGNATURE_PARAMETERS_FUNC = "CryptDllExtractEncodedSignatureParameters";
pub const CRYPT_OID_SIGN_AND_ENCODE_HASH_FUNC = "CryptDllSignAndEncodeHash";
pub const CRYPT_OID_VERIFY_ENCODED_SIGNATURE_FUNC = "CryptDllVerifyEncodedSignature";
pub const CRYPT_OID_EXPORT_PUBLIC_KEY_INFO_FUNC = "CryptDllExportPublicKeyInfoEx";
pub const CRYPT_OID_EXPORT_PUBLIC_KEY_INFO_EX2_FUNC = "CryptDllExportPublicKeyInfoEx2";
pub const CRYPT_OID_EXPORT_PUBLIC_KEY_INFO_FROM_BCRYPT_HANDLE_FUNC = "CryptDllExportPublicKeyInfoFromBCryptKeyHandle";
pub const CRYPT_OID_IMPORT_PUBLIC_KEY_INFO_FUNC = "CryptDllImportPublicKeyInfoEx";
pub const CRYPT_OID_IMPORT_PUBLIC_KEY_INFO_EX2_FUNC = "CryptDllImportPublicKeyInfoEx2";
pub const CRYPT_ACQUIRE_WINDOW_HANDLE_FLAG = @as(u32, 128);
pub const CRYPT_ACQUIRE_NCRYPT_KEY_FLAGS_MASK = @as(u32, 458752);
pub const CRYPT_ACQUIRE_ALLOW_NCRYPT_KEY_FLAG = @as(u32, 65536);
pub const CRYPT_ACQUIRE_PREFER_NCRYPT_KEY_FLAG = @as(u32, 131072);
pub const CRYPT_ACQUIRE_ONLY_NCRYPT_KEY_FLAG = @as(u32, 262144);
pub const CRYPT_OID_IMPORT_PRIVATE_KEY_INFO_FUNC = "CryptDllImportPrivateKeyInfoEx";
pub const CRYPT_OID_EXPORT_PRIVATE_KEY_INFO_FUNC = "CryptDllExportPrivateKeyInfoEx";
pub const CRYPT_DELETE_KEYSET = @as(u32, 16);
pub const CERT_XML_NAME_STR = @as(u32, 4);
pub const CERT_NAME_STR_SEMICOLON_FLAG = @as(u32, 1073741824);
pub const CERT_NAME_STR_NO_PLUS_FLAG = @as(u32, 536870912);
pub const CERT_NAME_STR_NO_QUOTING_FLAG = @as(u32, 268435456);
pub const CERT_NAME_STR_CRLF_FLAG = @as(u32, 134217728);
pub const CERT_NAME_STR_COMMA_FLAG = @as(u32, 67108864);
pub const CERT_NAME_STR_REVERSE_FLAG = @as(u32, 33554432);
pub const CERT_NAME_STR_FORWARD_FLAG = @as(u32, 16777216);
pub const CERT_NAME_STR_DISABLE_IE4_UTF8_FLAG = @as(u32, 65536);
pub const CERT_NAME_STR_ENABLE_T61_UNICODE_FLAG = @as(u32, 131072);
pub const CERT_NAME_STR_ENABLE_UTF8_UNICODE_FLAG = @as(u32, 262144);
pub const CERT_NAME_STR_FORCE_UTF8_DIR_STR_FLAG = @as(u32, 524288);
pub const CERT_NAME_STR_DISABLE_UTF8_DIR_STR_FLAG = @as(u32, 1048576);
pub const CERT_NAME_STR_ENABLE_PUNYCODE_FLAG = @as(u32, 2097152);
pub const CERT_NAME_EMAIL_TYPE = @as(u32, 1);
pub const CERT_NAME_RDN_TYPE = @as(u32, 2);
pub const CERT_NAME_ATTR_TYPE = @as(u32, 3);
pub const CERT_NAME_SIMPLE_DISPLAY_TYPE = @as(u32, 4);
pub const CERT_NAME_FRIENDLY_DISPLAY_TYPE = @as(u32, 5);
pub const CERT_NAME_DNS_TYPE = @as(u32, 6);
pub const CERT_NAME_URL_TYPE = @as(u32, 7);
pub const CERT_NAME_UPN_TYPE = @as(u32, 8);
pub const CERT_NAME_ISSUER_FLAG = @as(u32, 1);
pub const CERT_NAME_DISABLE_IE4_UTF8_FLAG = @as(u32, 65536);
pub const CERT_NAME_SEARCH_ALL_NAMES_FLAG = @as(u32, 2);
pub const CRYPT_MESSAGE_BARE_CONTENT_OUT_FLAG = @as(u32, 1);
pub const CRYPT_MESSAGE_ENCAPSULATED_CONTENT_OUT_FLAG = @as(u32, 2);
pub const CRYPT_MESSAGE_KEYID_SIGNER_FLAG = @as(u32, 4);
pub const CRYPT_MESSAGE_SILENT_KEYSET_FLAG = @as(u32, 64);
pub const CRYPT_MESSAGE_KEYID_RECIPIENT_FLAG = @as(u32, 4);
pub const CREDENTIAL_OID_PASSWORD_CREDENTIALS_A = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 1));
pub const CREDENTIAL_OID_PASSWORD_CREDENTIALS_W = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 2));
pub const CREDENTIAL_OID_PASSWORD_CREDENTIALS = @as(i32, 2);
pub const SCHEME_OID_RETRIEVE_ENCODED_OBJECT_FUNC = "SchemeDllRetrieveEncodedObject";
pub const SCHEME_OID_RETRIEVE_ENCODED_OBJECTW_FUNC = "SchemeDllRetrieveEncodedObjectW";
pub const CONTEXT_OID_CREATE_OBJECT_CONTEXT_FUNC = "ContextDllCreateObjectContext";
pub const CONTEXT_OID_CERTIFICATE = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 1));
pub const CONTEXT_OID_CRL = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 2));
pub const CONTEXT_OID_CTL = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 3));
pub const CONTEXT_OID_PKCS7 = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 4));
pub const CONTEXT_OID_CAPI2_ANY = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 5));
pub const CONTEXT_OID_OCSP_RESP = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 6));
pub const CRYPT_RETRIEVE_MULTIPLE_OBJECTS = @as(u32, 1);
pub const CRYPT_CACHE_ONLY_RETRIEVAL = @as(u32, 2);
pub const CRYPT_WIRE_ONLY_RETRIEVAL = @as(u32, 4);
pub const CRYPT_DONT_CACHE_RESULT = @as(u32, 8);
pub const CRYPT_ASYNC_RETRIEVAL = @as(u32, 16);
pub const CRYPT_STICKY_CACHE_RETRIEVAL = @as(u32, 4096);
pub const CRYPT_LDAP_SCOPE_BASE_ONLY_RETRIEVAL = @as(u32, 8192);
pub const CRYPT_OFFLINE_CHECK_RETRIEVAL = @as(u32, 16384);
pub const CRYPT_LDAP_INSERT_ENTRY_ATTRIBUTE = @as(u32, 32768);
pub const CRYPT_LDAP_SIGN_RETRIEVAL = @as(u32, 65536);
pub const CRYPT_NO_AUTH_RETRIEVAL = @as(u32, 131072);
pub const CRYPT_LDAP_AREC_EXCLUSIVE_RETRIEVAL = @as(u32, 262144);
pub const CRYPT_AIA_RETRIEVAL = @as(u32, 524288);
pub const CRYPT_HTTP_POST_RETRIEVAL = @as(u32, 1048576);
pub const CRYPT_PROXY_CACHE_RETRIEVAL = @as(u32, 2097152);
pub const CRYPT_NOT_MODIFIED_RETRIEVAL = @as(u32, 4194304);
pub const CRYPT_ENABLE_SSL_REVOCATION_RETRIEVAL = @as(u32, 8388608);
pub const CRYPT_RANDOM_QUERY_STRING_RETRIEVAL = @as(u32, 67108864);
pub const CRYPT_ENABLE_FILE_RETRIEVAL = @as(u32, 134217728);
pub const CRYPT_CREATE_NEW_FLUSH_ENTRY = @as(u32, 268435456);
pub const CRYPT_VERIFY_CONTEXT_SIGNATURE = @as(u32, 32);
pub const CRYPT_VERIFY_DATA_HASH = @as(u32, 64);
pub const CRYPT_KEEP_TIME_VALID = @as(u32, 128);
pub const CRYPT_DONT_VERIFY_SIGNATURE = @as(u32, 256);
pub const CRYPT_DONT_CHECK_TIME_VALIDITY = @as(u32, 512);
pub const CRYPT_CHECK_FRESHNESS_TIME_VALIDITY = @as(u32, 1024);
pub const CRYPT_ACCUMULATIVE_TIMEOUT = @as(u32, 2048);
pub const CRYPT_OCSP_ONLY_RETRIEVAL = @as(u32, 16777216);
pub const CRYPT_NO_OCSP_FAILOVER_TO_CRL_RETRIEVAL = @as(u32, 33554432);
pub const CRYPTNET_URL_CACHE_PRE_FETCH_NONE = @as(u32, 0);
pub const CRYPTNET_URL_CACHE_PRE_FETCH_BLOB = @as(u32, 1);
pub const CRYPTNET_URL_CACHE_PRE_FETCH_CRL = @as(u32, 2);
pub const CRYPTNET_URL_CACHE_PRE_FETCH_OCSP = @as(u32, 3);
pub const CRYPTNET_URL_CACHE_PRE_FETCH_AUTOROOT_CAB = @as(u32, 5);
pub const CRYPTNET_URL_CACHE_PRE_FETCH_DISALLOWED_CERT_CAB = @as(u32, 6);
pub const CRYPTNET_URL_CACHE_PRE_FETCH_PIN_RULES_CAB = @as(u32, 7);
pub const CRYPTNET_URL_CACHE_DEFAULT_FLUSH = @as(u32, 0);
pub const CRYPTNET_URL_CACHE_DISABLE_FLUSH = @as(u32, 4294967295);
pub const CRYPTNET_URL_CACHE_RESPONSE_NONE = @as(u32, 0);
pub const CRYPTNET_URL_CACHE_RESPONSE_HTTP = @as(u32, 1);
pub const CRYPTNET_URL_CACHE_RESPONSE_VALIDATED = @as(u32, 32768);
pub const CRYPT_RETRIEVE_MAX_ERROR_CONTENT_LENGTH = @as(u32, 4096);
pub const CRYPT_PARAM_ASYNC_RETRIEVAL_COMPLETION = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 1));
pub const CRYPT_PARAM_CANCEL_ASYNC_RETRIEVAL = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 2));
pub const URL_OID_GET_OBJECT_URL_FUNC = "UrlDllGetObjectUrl";
pub const URL_OID_CERTIFICATE_ISSUER = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 1));
pub const URL_OID_CERTIFICATE_CRL_DIST_POINT = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 2));
pub const URL_OID_CTL_ISSUER = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 3));
pub const URL_OID_CTL_NEXT_UPDATE = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 4));
pub const URL_OID_CRL_ISSUER = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 5));
pub const URL_OID_CERTIFICATE_FRESHEST_CRL = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 6));
pub const URL_OID_CRL_FRESHEST_CRL = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 7));
pub const URL_OID_CROSS_CERT_DIST_POINT = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 8));
pub const URL_OID_CERTIFICATE_OCSP = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 9));
pub const URL_OID_CERTIFICATE_OCSP_AND_CRL_DIST_POINT = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 10));
pub const URL_OID_CERTIFICATE_CRL_DIST_POINT_AND_OCSP = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 11));
pub const URL_OID_CROSS_CERT_SUBJECT_INFO_ACCESS = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 12));
pub const URL_OID_CERTIFICATE_ONLY_OCSP = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 13));
pub const TIME_VALID_OID_GET_OBJECT_FUNC = "TimeValidDllGetObject";
pub const TIME_VALID_OID_GET_CTL = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 1));
pub const TIME_VALID_OID_GET_CRL = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 2));
pub const TIME_VALID_OID_GET_CRL_FROM_CERT = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 3));
pub const TIME_VALID_OID_GET_FRESHEST_CRL_FROM_CERT = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 4));
pub const TIME_VALID_OID_GET_FRESHEST_CRL_FROM_CRL = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 5));
pub const TIME_VALID_OID_FLUSH_OBJECT_FUNC = "TimeValidDllFlushObject";
pub const TIME_VALID_OID_FLUSH_CTL = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 1));
pub const TIME_VALID_OID_FLUSH_CRL = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 2));
pub const TIME_VALID_OID_FLUSH_CRL_FROM_CERT = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 3));
pub const TIME_VALID_OID_FLUSH_FRESHEST_CRL_FROM_CERT = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 4));
pub const TIME_VALID_OID_FLUSH_FRESHEST_CRL_FROM_CRL = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 5));
pub const CRYPT_KEYID_MACHINE_FLAG = @as(u32, 32);
pub const CRYPT_KEYID_ALLOC_FLAG = @as(u32, 32768);
pub const CRYPT_KEYID_DELETE_FLAG = @as(u32, 16);
pub const CRYPT_KEYID_SET_NEW_FLAG = @as(u32, 8192);
pub const CERT_CHAIN_CONFIG_REGPATH = "Software\\Microsoft\\Cryptography\\OID\\EncodingType 0\\CertDllCreateCertificateChainEngine\\Config";
pub const CERT_CHAIN_MAX_URL_RETRIEVAL_BYTE_COUNT_VALUE_NAME = "MaxUrlRetrievalByteCount";
pub const CERT_CHAIN_CACHE_RESYNC_FILETIME_VALUE_NAME = "ChainCacheResyncFiletime";
pub const CERT_CHAIN_DISABLE_MANDATORY_BASIC_CONSTRAINTS_VALUE_NAME = "DisableMandatoryBasicConstraints";
pub const CERT_CHAIN_DISABLE_CA_NAME_CONSTRAINTS_VALUE_NAME = "DisableCANameConstraints";
pub const CERT_CHAIN_DISABLE_UNSUPPORTED_CRITICAL_EXTENSIONS_VALUE_NAME = "DisableUnsupportedCriticalExtensions";
pub const CERT_CHAIN_MAX_AIA_URL_COUNT_IN_CERT_VALUE_NAME = "MaxAIAUrlCountInCert";
pub const CERT_CHAIN_MAX_AIA_URL_COUNT_IN_CERT_DEFAULT = @as(u32, 5);
pub const CERT_CHAIN_MAX_AIA_URL_RETRIEVAL_COUNT_PER_CHAIN_VALUE_NAME = "MaxAIAUrlRetrievalCountPerChain";
pub const CERT_CHAIN_MAX_AIA_URL_RETRIEVAL_COUNT_PER_CHAIN_DEFAULT = @as(u32, 3);
pub const CERT_CHAIN_MAX_AIA_URL_RETRIEVAL_BYTE_COUNT_VALUE_NAME = "MaxAIAUrlRetrievalByteCount";
pub const CERT_CHAIN_MAX_AIA_URL_RETRIEVAL_BYTE_COUNT_DEFAULT = @as(u32, 100000);
pub const CERT_CHAIN_MAX_AIA_URL_RETRIEVAL_CERT_COUNT_VALUE_NAME = "MaxAIAUrlRetrievalCertCount";
pub const CERT_CHAIN_MAX_AIA_URL_RETRIEVAL_CERT_COUNT_DEFAULT = @as(u32, 10);
pub const CERT_CHAIN_OCSP_VALIDITY_SECONDS_VALUE_NAME = "OcspValiditySeconds";
pub const CERT_CHAIN_DISABLE_SERIAL_CHAIN_VALUE_NAME = "DisableSerialChain";
pub const CERT_CHAIN_SERIAL_CHAIN_LOG_FILE_NAME_VALUE_NAME = "SerialChainLogFileName";
pub const CERT_CHAIN_DISABLE_SYNC_WITH_SSL_TIME_VALUE_NAME = "DisableSyncWithSslTime";
pub const CERT_CHAIN_MAX_SSL_TIME_UPDATED_EVENT_COUNT_VALUE_NAME = "MaxSslTimeUpdatedEventCount";
pub const CERT_CHAIN_MAX_SSL_TIME_UPDATED_EVENT_COUNT_DEFAULT = @as(u32, 5);
pub const CERT_CHAIN_MAX_SSL_TIME_UPDATED_EVENT_COUNT_DISABLE = @as(u32, 4294967295);
pub const CERT_CHAIN_SSL_HANDSHAKE_LOG_FILE_NAME_VALUE_NAME = "SslHandshakeLogFileName";
pub const CERT_CHAIN_ENABLE_WEAK_SIGNATURE_FLAGS_VALUE_NAME = "EnableWeakSignatureFlags";
pub const CERT_CHAIN_ENABLE_MD2_MD4_FLAG = @as(u32, 1);
pub const CERT_CHAIN_ENABLE_WEAK_RSA_ROOT_FLAG = @as(u32, 2);
pub const CERT_CHAIN_ENABLE_WEAK_LOGGING_FLAG = @as(u32, 4);
pub const CERT_CHAIN_ENABLE_ONLY_WEAK_LOGGING_FLAG = @as(u32, 8);
pub const CERT_CHAIN_MIN_RSA_PUB_KEY_BIT_LENGTH_VALUE_NAME = "MinRsaPubKeyBitLength";
pub const CERT_CHAIN_MIN_RSA_PUB_KEY_BIT_LENGTH_DEFAULT = @as(u32, 1023);
pub const CERT_CHAIN_MIN_RSA_PUB_KEY_BIT_LENGTH_DISABLE = @as(u32, 4294967295);
pub const CERT_CHAIN_WEAK_RSA_PUB_KEY_TIME_VALUE_NAME = "WeakRsaPubKeyTime";
pub const CERT_CHAIN_WEAK_SIGNATURE_LOG_DIR_VALUE_NAME = "WeakSignatureLogDir";
pub const CERT_CHAIN_DEFAULT_CONFIG_SUBDIR = "Default";
pub const CERT_CHAIN_WEAK_PREFIX_NAME = "Weak";
pub const CERT_CHAIN_WEAK_THIRD_PARTY_CONFIG_NAME = "ThirdParty";
pub const CERT_CHAIN_WEAK_ALL_CONFIG_NAME = "All";
pub const CERT_CHAIN_WEAK_FLAGS_NAME = "Flags";
pub const CERT_CHAIN_WEAK_HYGIENE_NAME = "Hygiene";
pub const CERT_CHAIN_WEAK_AFTER_TIME_NAME = "AfterTime";
pub const CERT_CHAIN_WEAK_FILE_HASH_AFTER_TIME_NAME = "FileHashAfterTime";
pub const CERT_CHAIN_WEAK_TIMESTAMP_HASH_AFTER_TIME_NAME = "TimestampHashAfterTime";
pub const CERT_CHAIN_WEAK_MIN_BIT_LENGTH_NAME = "MinBitLength";
pub const CERT_CHAIN_WEAK_SHA256_ALLOW_NAME = "Sha256Allow";
pub const CERT_CHAIN_MIN_PUB_KEY_BIT_LENGTH_DISABLE = @as(u32, 4294967295);
pub const CERT_CHAIN_ENABLE_WEAK_SETTINGS_FLAG = @as(u32, 2147483648);
pub const CERT_CHAIN_DISABLE_ECC_PARA_FLAG = @as(u32, 16);
pub const CERT_CHAIN_DISABLE_ALL_EKU_WEAK_FLAG = @as(u32, 65536);
pub const CERT_CHAIN_ENABLE_ALL_EKU_HYGIENE_FLAG = @as(u32, 131072);
pub const CERT_CHAIN_DISABLE_OPT_IN_SERVER_AUTH_WEAK_FLAG = @as(u32, 262144);
pub const CERT_CHAIN_DISABLE_SERVER_AUTH_WEAK_FLAG = @as(u32, 1048576);
pub const CERT_CHAIN_ENABLE_SERVER_AUTH_HYGIENE_FLAG = @as(u32, 2097152);
pub const CERT_CHAIN_DISABLE_CODE_SIGNING_WEAK_FLAG = @as(u32, 4194304);
pub const CERT_CHAIN_DISABLE_MOTW_CODE_SIGNING_WEAK_FLAG = @as(u32, 8388608);
pub const CERT_CHAIN_ENABLE_CODE_SIGNING_HYGIENE_FLAG = @as(u32, 16777216);
pub const CERT_CHAIN_ENABLE_MOTW_CODE_SIGNING_HYGIENE_FLAG = @as(u32, 33554432);
pub const CERT_CHAIN_DISABLE_TIMESTAMP_WEAK_FLAG = @as(u32, 67108864);
pub const CERT_CHAIN_DISABLE_MOTW_TIMESTAMP_WEAK_FLAG = @as(u32, 134217728);
pub const CERT_CHAIN_ENABLE_TIMESTAMP_HYGIENE_FLAG = @as(u32, 268435456);
pub const CERT_CHAIN_ENABLE_MOTW_TIMESTAMP_HYGIENE_FLAG = @as(u32, 536870912);
pub const CERT_CHAIN_MOTW_IGNORE_AFTER_TIME_WEAK_FLAG = @as(u32, 1073741824);
pub const CERT_CHAIN_DISABLE_FILE_HASH_WEAK_FLAG = @as(u32, 4096);
pub const CERT_CHAIN_DISABLE_MOTW_FILE_HASH_WEAK_FLAG = @as(u32, 8192);
pub const CERT_CHAIN_DISABLE_TIMESTAMP_HASH_WEAK_FLAG = @as(u32, 16384);
pub const CERT_CHAIN_DISABLE_MOTW_TIMESTAMP_HASH_WEAK_FLAG = @as(u32, 32768);
pub const CERT_CHAIN_OPT_IN_WEAK_FLAGS = @as(u32, 262144);
pub const CERT_CHAIN_AUTO_CURRENT_USER = @as(u32, 1);
pub const CERT_CHAIN_AUTO_LOCAL_MACHINE = @as(u32, 2);
pub const CERT_CHAIN_AUTO_IMPERSONATED = @as(u32, 3);
pub const CERT_CHAIN_AUTO_PROCESS_INFO = @as(u32, 4);
pub const CERT_CHAIN_AUTO_PINRULE_INFO = @as(u32, 5);
pub const CERT_CHAIN_AUTO_NETWORK_INFO = @as(u32, 6);
pub const CERT_CHAIN_AUTO_SERIAL_LOCAL_MACHINE = @as(u32, 7);
pub const CERT_CHAIN_AUTO_HPKP_RULE_INFO = @as(u32, 8);
pub const CERT_CHAIN_AUTO_FLAGS_VALUE_NAME = "AutoFlags";
pub const CERT_CHAIN_AUTO_FLUSH_DISABLE_FLAG = @as(u32, 1);
pub const CERT_CHAIN_AUTO_LOG_CREATE_FLAG = @as(u32, 2);
pub const CERT_CHAIN_AUTO_LOG_FREE_FLAG = @as(u32, 4);
pub const CERT_CHAIN_AUTO_LOG_FLUSH_FLAG = @as(u32, 8);
pub const CERT_CHAIN_AUTO_FLUSH_FIRST_DELTA_SECONDS_VALUE_NAME = "AutoFlushFirstDeltaSeconds";
pub const CERT_CHAIN_AUTO_FLUSH_NEXT_DELTA_SECONDS_VALUE_NAME = "AutoFlushNextDeltaSeconds";
pub const CERT_CHAIN_AUTO_LOG_FILE_NAME_VALUE_NAME = "AutoLogFileName";
pub const CERT_CHAIN_DISABLE_AUTO_FLUSH_PROCESS_NAME_LIST_VALUE_NAME = "DisableAutoFlushProcessNameList";
pub const CERT_SRV_OCSP_RESP_MIN_VALIDITY_SECONDS_VALUE_NAME = "SrvOcspRespMinValiditySeconds";
pub const CERT_SRV_OCSP_RESP_URL_RETRIEVAL_TIMEOUT_MILLISECONDS_VALUE_NAME = "SrvOcspRespUrlRetrievalTimeoutMilliseconds";
pub const CERT_SRV_OCSP_RESP_MAX_BEFORE_NEXT_UPDATE_SECONDS_VALUE_NAME = "SrvOcspRespMaxBeforeNextUpdateSeconds";
pub const CERT_SRV_OCSP_RESP_MIN_BEFORE_NEXT_UPDATE_SECONDS_VALUE_NAME = "SrvOcspRespMinBeforeNextUpdateSeconds";
pub const CERT_SRV_OCSP_RESP_MIN_AFTER_NEXT_UPDATE_SECONDS_VALUE_NAME = "SrvOcspRespMinAfterNextUpdateSeconds";
pub const CERT_SRV_OCSP_RESP_MIN_SYNC_CERT_FILE_SECONDS_VALUE_NAME = "SrvOcspRespMinSyncCertFileSeconds";
pub const CERT_SRV_OCSP_RESP_MIN_SYNC_CERT_FILE_SECONDS_DEFAULT = @as(u32, 5);
pub const CERT_SRV_OCSP_RESP_MAX_SYNC_CERT_FILE_SECONDS_VALUE_NAME = "SrvOcspRespMaxSyncCertFileSeconds";
pub const CRYPTNET_MAX_CACHED_OCSP_PER_CRL_COUNT_VALUE_NAME = "CryptnetMaxCachedOcspPerCrlCount";
pub const CRYPTNET_MAX_CACHED_OCSP_PER_CRL_COUNT_DEFAULT = @as(u32, 500);
pub const CRYPTNET_OCSP_AFTER_CRL_DISABLE = @as(u32, 4294967295);
pub const CRYPTNET_URL_CACHE_DEFAULT_FLUSH_EXEMPT_SECONDS_VALUE_NAME = "CryptnetDefaultFlushExemptSeconds";
pub const CRYPTNET_PRE_FETCH_MIN_MAX_AGE_SECONDS_VALUE_NAME = "CryptnetPreFetchMinMaxAgeSeconds";
pub const CRYPTNET_PRE_FETCH_MAX_MAX_AGE_SECONDS_VALUE_NAME = "CryptnetPreFetchMaxMaxAgeSeconds";
pub const CRYPTNET_PRE_FETCH_MIN_OCSP_VALIDITY_PERIOD_SECONDS_VALUE_NAME = "CryptnetPreFetchMinOcspValidityPeriodSeconds";
pub const CRYPTNET_PRE_FETCH_AFTER_PUBLISH_PRE_FETCH_DIVISOR_VALUE_NAME = "CryptnetPreFetchAfterPublishPreFetchDivisor";
pub const CRYPTNET_PRE_FETCH_AFTER_PUBLISH_PRE_FETCH_DIVISOR_DEFAULT = @as(u32, 10);
pub const CRYPTNET_PRE_FETCH_BEFORE_NEXT_UPDATE_PRE_FETCH_DIVISOR_VALUE_NAME = "CryptnetPreFetchBeforeNextUpdatePreFetchDivisor";
pub const CRYPTNET_PRE_FETCH_BEFORE_NEXT_UPDATE_PRE_FETCH_DIVISOR_DEFAULT = @as(u32, 20);
pub const CRYPTNET_PRE_FETCH_MIN_BEFORE_NEXT_UPDATE_PRE_FETCH_PERIOD_SECONDS_VALUE_NAME = "CryptnetPreFetchMinBeforeNextUpdatePreFetchSeconds";
pub const CRYPTNET_PRE_FETCH_VALIDITY_PERIOD_AFTER_NEXT_UPDATE_PRE_FETCH_DIVISOR_VALUE_NAME = "CryptnetPreFetchValidityPeriodAfterNextUpdatePreFetchDivisor";
pub const CRYPTNET_PRE_FETCH_VALIDITY_PERIOD_AFTER_NEXT_UPDATE_PRE_FETCH_DIVISOR_DEFAULT = @as(u32, 10);
pub const CRYPTNET_PRE_FETCH_MAX_AFTER_NEXT_UPDATE_PRE_FETCH_PERIOD_SECONDS_VALUE_NAME = "CryptnetPreFetchMaxAfterNextUpdatePreFetchPeriodSeconds";
pub const CRYPTNET_PRE_FETCH_MIN_AFTER_NEXT_UPDATE_PRE_FETCH_PERIOD_SECONDS_VALUE_NAME = "CryptnetPreFetchMinAfterNextUpdatePreFetchPeriodSeconds";
pub const CRYPTNET_PRE_FETCH_AFTER_CURRENT_TIME_PRE_FETCH_PERIOD_SECONDS_VALUE_NAME = "CryptnetPreFetchAfterCurrentTimePreFetchPeriodSeconds";
pub const CRYPTNET_PRE_FETCH_TRIGGER_PERIOD_SECONDS_VALUE_NAME = "CryptnetPreFetchTriggerPeriodSeconds";
pub const CRYPTNET_PRE_FETCH_TRIGGER_DISABLE = @as(u32, 4294967295);
pub const CRYPTNET_PRE_FETCH_SCAN_AFTER_TRIGGER_DELAY_SECONDS_VALUE_NAME = "CryptnetPreFetchScanAfterTriggerDelaySeconds";
pub const CRYPTNET_PRE_FETCH_SCAN_AFTER_TRIGGER_DELAY_SECONDS_DEFAULT = @as(u32, 60);
pub const CRYPTNET_PRE_FETCH_RETRIEVAL_TIMEOUT_SECONDS_VALUE_NAME = "CryptnetPreFetchRetrievalTimeoutSeconds";
pub const CRYPTNET_CRL_PRE_FETCH_PROCESS_NAME_LIST_VALUE_NAME = "ProcessNameList";
pub const CRYPTNET_CRL_PRE_FETCH_URL_LIST_VALUE_NAME = "PreFetchUrlList";
pub const CRYPTNET_CRL_PRE_FETCH_DISABLE_INFORMATION_EVENTS_VALUE_NAME = "DisableInformationEvents";
pub const CRYPTNET_CRL_PRE_FETCH_LOG_FILE_NAME_VALUE_NAME = "LogFileName";
pub const CRYPTNET_CRL_PRE_FETCH_TIMEOUT_SECONDS_VALUE_NAME = "TimeoutSeconds";
pub const CRYPTNET_CRL_PRE_FETCH_MAX_AGE_SECONDS_VALUE_NAME = "MaxAgeSeconds";
pub const CRYPTNET_CRL_PRE_FETCH_PUBLISH_BEFORE_NEXT_UPDATE_SECONDS_VALUE_NAME = "PublishBeforeNextUpdateSeconds";
pub const CRYPTNET_CRL_PRE_FETCH_PUBLISH_RANDOM_INTERVAL_SECONDS_VALUE_NAME = "PublishRandomIntervalSeconds";
pub const CRYPTNET_CRL_PRE_FETCH_MIN_BEFORE_NEXT_UPDATE_SECONDS_VALUE_NAME = "MinBeforeNextUpdateSeconds";
pub const CRYPTNET_CRL_PRE_FETCH_MIN_AFTER_NEXT_UPDATE_SECONDS_VALUE_NAME = "MinAfterNextUpdateSeconds";
pub const CERT_CHAIN_URL_RETRIEVAL_TIMEOUT_MILLISECONDS_VALUE_NAME = "ChainUrlRetrievalTimeoutMilliseconds";
pub const CERT_CHAIN_REV_ACCUMULATIVE_URL_RETRIEVAL_TIMEOUT_MILLISECONDS_VALUE_NAME = "ChainRevAccumulativeUrlRetrievalTimeoutMilliseconds";
pub const CERT_RETR_BEHAVIOR_INET_AUTH_VALUE_NAME = "EnableInetUnknownAuth";
pub const CERT_RETR_BEHAVIOR_INET_STATUS_VALUE_NAME = "EnableInetLocal";
pub const CERT_RETR_BEHAVIOR_FILE_VALUE_NAME = "AllowFileUrlScheme";
pub const CERT_RETR_BEHAVIOR_LDAP_VALUE_NAME = "DisableLDAPSignAndEncrypt";
pub const CRYPTNET_CACHED_OCSP_SWITCH_TO_CRL_COUNT_VALUE_NAME = "CryptnetCachedOcspSwitchToCrlCount";
pub const CRYPTNET_CACHED_OCSP_SWITCH_TO_CRL_COUNT_DEFAULT = @as(u32, 50);
pub const CRYPTNET_CRL_BEFORE_OCSP_ENABLE = @as(u32, 4294967295);
pub const CERT_CHAIN_DISABLE_AIA_URL_RETRIEVAL_VALUE_NAME = "DisableAIAUrlRetrieval";
pub const CERT_CHAIN_OPTIONS_VALUE_NAME = "Options";
pub const CERT_CHAIN_OPTION_DISABLE_AIA_URL_RETRIEVAL = @as(u32, 2);
pub const CERT_CHAIN_OPTION_ENABLE_SIA_URL_RETRIEVAL = @as(u32, 4);
pub const CERT_CHAIN_CROSS_CERT_DOWNLOAD_INTERVAL_HOURS_VALUE_NAME = "CrossCertDownloadIntervalHours";
pub const CERT_CHAIN_CRL_VALIDITY_EXT_PERIOD_HOURS_VALUE_NAME = "CRLValidityExtensionPeriod";
pub const CERT_CHAIN_CRL_VALIDITY_EXT_PERIOD_HOURS_DEFAULT = @as(u32, 12);
pub const CERT_CHAIN_CACHE_END_CERT = @as(u32, 1);
pub const CERT_CHAIN_THREAD_STORE_SYNC = @as(u32, 2);
pub const CERT_CHAIN_CACHE_ONLY_URL_RETRIEVAL = @as(u32, 4);
pub const CERT_CHAIN_USE_LOCAL_MACHINE_STORE = @as(u32, 8);
pub const CERT_CHAIN_ENABLE_CACHE_AUTO_UPDATE = @as(u32, 16);
pub const CERT_CHAIN_ENABLE_SHARE_STORE = @as(u32, 32);
pub const CERT_CHAIN_EXCLUSIVE_ENABLE_CA_FLAG = @as(u32, 1);
pub const CERT_TRUST_NO_ERROR = @as(u32, 0);
pub const CERT_TRUST_IS_NOT_TIME_VALID = @as(u32, 1);
pub const CERT_TRUST_IS_NOT_TIME_NESTED = @as(u32, 2);
pub const CERT_TRUST_IS_REVOKED = @as(u32, 4);
pub const CERT_TRUST_IS_NOT_SIGNATURE_VALID = @as(u32, 8);
pub const CERT_TRUST_IS_NOT_VALID_FOR_USAGE = @as(u32, 16);
pub const CERT_TRUST_IS_UNTRUSTED_ROOT = @as(u32, 32);
pub const CERT_TRUST_REVOCATION_STATUS_UNKNOWN = @as(u32, 64);
pub const CERT_TRUST_IS_CYCLIC = @as(u32, 128);
pub const CERT_TRUST_INVALID_EXTENSION = @as(u32, 256);
pub const CERT_TRUST_INVALID_POLICY_CONSTRAINTS = @as(u32, 512);
pub const CERT_TRUST_INVALID_BASIC_CONSTRAINTS = @as(u32, 1024);
pub const CERT_TRUST_INVALID_NAME_CONSTRAINTS = @as(u32, 2048);
pub const CERT_TRUST_HAS_NOT_SUPPORTED_NAME_CONSTRAINT = @as(u32, 4096);
pub const CERT_TRUST_HAS_NOT_DEFINED_NAME_CONSTRAINT = @as(u32, 8192);
pub const CERT_TRUST_HAS_NOT_PERMITTED_NAME_CONSTRAINT = @as(u32, 16384);
pub const CERT_TRUST_HAS_EXCLUDED_NAME_CONSTRAINT = @as(u32, 32768);
pub const CERT_TRUST_IS_OFFLINE_REVOCATION = @as(u32, 16777216);
pub const CERT_TRUST_NO_ISSUANCE_CHAIN_POLICY = @as(u32, 33554432);
pub const CERT_TRUST_IS_EXPLICIT_DISTRUST = @as(u32, 67108864);
pub const CERT_TRUST_HAS_NOT_SUPPORTED_CRITICAL_EXT = @as(u32, 134217728);
pub const CERT_TRUST_HAS_WEAK_SIGNATURE = @as(u32, 1048576);
pub const CERT_TRUST_HAS_WEAK_HYGIENE = @as(u32, 2097152);
pub const CERT_TRUST_IS_PARTIAL_CHAIN = @as(u32, 65536);
pub const CERT_TRUST_CTL_IS_NOT_TIME_VALID = @as(u32, 131072);
pub const CERT_TRUST_CTL_IS_NOT_SIGNATURE_VALID = @as(u32, 262144);
pub const CERT_TRUST_CTL_IS_NOT_VALID_FOR_USAGE = @as(u32, 524288);
pub const CERT_TRUST_HAS_EXACT_MATCH_ISSUER = @as(u32, 1);
pub const CERT_TRUST_HAS_KEY_MATCH_ISSUER = @as(u32, 2);
pub const CERT_TRUST_HAS_NAME_MATCH_ISSUER = @as(u32, 4);
pub const CERT_TRUST_IS_SELF_SIGNED = @as(u32, 8);
pub const CERT_TRUST_AUTO_UPDATE_CA_REVOCATION = @as(u32, 16);
pub const CERT_TRUST_AUTO_UPDATE_END_REVOCATION = @as(u32, 32);
pub const CERT_TRUST_NO_OCSP_FAILOVER_TO_CRL = @as(u32, 64);
pub const CERT_TRUST_IS_KEY_ROLLOVER = @as(u32, 128);
pub const CERT_TRUST_SSL_HANDSHAKE_OCSP = @as(u32, 262144);
pub const CERT_TRUST_SSL_TIME_VALID_OCSP = @as(u32, 524288);
pub const CERT_TRUST_SSL_RECONNECT_OCSP = @as(u32, 1048576);
pub const CERT_TRUST_HAS_PREFERRED_ISSUER = @as(u32, 256);
pub const CERT_TRUST_HAS_ISSUANCE_CHAIN_POLICY = @as(u32, 512);
pub const CERT_TRUST_HAS_VALID_NAME_CONSTRAINTS = @as(u32, 1024);
pub const CERT_TRUST_IS_PEER_TRUSTED = @as(u32, 2048);
pub const CERT_TRUST_HAS_CRL_VALIDITY_EXTENDED = @as(u32, 4096);
pub const CERT_TRUST_IS_FROM_EXCLUSIVE_TRUST_STORE = @as(u32, 8192);
pub const CERT_TRUST_IS_CA_TRUSTED = @as(u32, 16384);
pub const CERT_TRUST_HAS_AUTO_UPDATE_WEAK_SIGNATURE = @as(u32, 32768);
pub const CERT_TRUST_HAS_ALLOW_WEAK_SIGNATURE = @as(u32, 131072);
pub const CERT_TRUST_IS_COMPLEX_CHAIN = @as(u32, 65536);
pub const CERT_TRUST_SSL_TIME_VALID = @as(u32, 16777216);
pub const CERT_TRUST_NO_TIME_CHECK = @as(u32, 33554432);
pub const USAGE_MATCH_TYPE_AND = @as(u32, 0);
pub const USAGE_MATCH_TYPE_OR = @as(u32, 1);
pub const CERT_CHAIN_STRONG_SIGN_DISABLE_END_CHECK_FLAG = @as(u32, 1);
pub const CERT_CHAIN_REVOCATION_CHECK_END_CERT = @as(u32, 268435456);
pub const CERT_CHAIN_REVOCATION_CHECK_CHAIN = @as(u32, 536870912);
pub const CERT_CHAIN_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT = @as(u32, 1073741824);
pub const CERT_CHAIN_REVOCATION_CHECK_CACHE_ONLY = @as(u32, 2147483648);
pub const CERT_CHAIN_REVOCATION_ACCUMULATIVE_TIMEOUT = @as(u32, 134217728);
pub const CERT_CHAIN_REVOCATION_CHECK_OCSP_CERT = @as(u32, 67108864);
pub const CERT_CHAIN_DISABLE_PASS1_QUALITY_FILTERING = @as(u32, 64);
pub const CERT_CHAIN_RETURN_LOWER_QUALITY_CONTEXTS = @as(u32, 128);
pub const CERT_CHAIN_DISABLE_AUTH_ROOT_AUTO_UPDATE = @as(u32, 256);
pub const CERT_CHAIN_TIMESTAMP_TIME = @as(u32, 512);
pub const CERT_CHAIN_ENABLE_PEER_TRUST = @as(u32, 1024);
pub const CERT_CHAIN_DISABLE_MY_PEER_TRUST = @as(u32, 2048);
pub const CERT_CHAIN_DISABLE_MD2_MD4 = @as(u32, 4096);
pub const CERT_CHAIN_DISABLE_AIA = @as(u32, 8192);
pub const CERT_CHAIN_HAS_MOTW = @as(u32, 16384);
pub const CERT_CHAIN_ONLY_ADDITIONAL_AND_AUTH_ROOT = @as(u32, 32768);
pub const CERT_CHAIN_OPT_IN_WEAK_SIGNATURE = @as(u32, 65536);
pub const REVOCATION_OID_CRL_REVOCATION = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 1));
pub const CERT_CHAIN_FIND_BY_ISSUER = @as(u32, 1);
pub const CERT_CHAIN_POLICY_IGNORE_WEAK_SIGNATURE_FLAG = @as(u32, 134217728);
pub const CRYPT_OID_VERIFY_CERTIFICATE_CHAIN_POLICY_FUNC = "CertDllVerifyCertificateChainPolicy";
pub const CERT_CHAIN_POLICY_BASE = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 1));
pub const CERT_CHAIN_POLICY_AUTHENTICODE = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 2));
pub const CERT_CHAIN_POLICY_AUTHENTICODE_TS = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 3));
pub const CERT_CHAIN_POLICY_SSL = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 4));
pub const CERT_CHAIN_POLICY_BASIC_CONSTRAINTS = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 5));
pub const CERT_CHAIN_POLICY_NT_AUTH = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 6));
pub const CERT_CHAIN_POLICY_MICROSOFT_ROOT = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 7));
pub const CERT_CHAIN_POLICY_EV = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 8));
pub const CERT_CHAIN_POLICY_SSL_F12 = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 9));
pub const CERT_CHAIN_POLICY_SSL_HPKP_HEADER = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 10));
pub const CERT_CHAIN_POLICY_THIRD_PARTY_ROOT = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 11));
pub const CERT_CHAIN_POLICY_SSL_KEY_PIN = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 12));
pub const BASIC_CONSTRAINTS_CERT_CHAIN_POLICY_CA_FLAG = @as(u32, 2147483648);
pub const BASIC_CONSTRAINTS_CERT_CHAIN_POLICY_END_ENTITY_FLAG = @as(u32, 1073741824);
pub const MICROSOFT_ROOT_CERT_CHAIN_POLICY_ENABLE_TEST_ROOT_FLAG = @as(u32, 65536);
pub const MICROSOFT_ROOT_CERT_CHAIN_POLICY_CHECK_APPLICATION_ROOT_FLAG = @as(u32, 131072);
pub const MICROSOFT_ROOT_CERT_CHAIN_POLICY_DISABLE_FLIGHT_ROOT_FLAG = @as(u32, 262144);
pub const SSL_F12_ERROR_TEXT_LENGTH = @as(u32, 256);
pub const CERT_CHAIN_POLICY_SSL_F12_SUCCESS_LEVEL = @as(u32, 0);
pub const CERT_CHAIN_POLICY_SSL_F12_WARNING_LEVEL = @as(u32, 1);
pub const CERT_CHAIN_POLICY_SSL_F12_ERROR_LEVEL = @as(u32, 2);
pub const CERT_CHAIN_POLICY_SSL_F12_NONE_CATEGORY = @as(u32, 0);
pub const CERT_CHAIN_POLICY_SSL_F12_WEAK_CRYPTO_CATEGORY = @as(u32, 1);
pub const CERT_CHAIN_POLICY_SSL_F12_ROOT_PROGRAM_CATEGORY = @as(u32, 2);
pub const SSL_HPKP_PKP_HEADER_INDEX = @as(u32, 0);
pub const SSL_HPKP_PKP_RO_HEADER_INDEX = @as(u32, 1);
pub const SSL_HPKP_HEADER_COUNT = @as(u32, 2);
pub const SSL_KEY_PIN_ERROR_TEXT_LENGTH = @as(u32, 512);
pub const CERT_CHAIN_POLICY_SSL_KEY_PIN_MISMATCH_ERROR = @as(i32, -2);
pub const CERT_CHAIN_POLICY_SSL_KEY_PIN_MITM_ERROR = @as(i32, -1);
pub const CERT_CHAIN_POLICY_SSL_KEY_PIN_SUCCESS = @as(u32, 0);
pub const CERT_CHAIN_POLICY_SSL_KEY_PIN_MITM_WARNING = @as(u32, 1);
pub const CERT_CHAIN_POLICY_SSL_KEY_PIN_MISMATCH_WARNING = @as(u32, 2);
pub const CRYPT_STRING_BASE64URI = @as(u32, 13);
pub const CRYPT_STRING_ENCODEMASK = @as(u32, 255);
pub const CRYPT_STRING_RESERVED100 = @as(u32, 256);
pub const CRYPT_STRING_RESERVED200 = @as(u32, 512);
pub const CRYPT_STRING_PERCENTESCAPE = @as(u32, 134217728);
pub const CRYPT_STRING_HASHDATA = @as(u32, 268435456);
pub const CRYPT_STRING_NOCRLF = @as(u32, 1073741824);
pub const CRYPT_STRING_NOCR = @as(u32, 2147483648);
pub const szOID_PKCS_12_PbeIds = "1.2.840.113549.1.12.1";
pub const szOID_PKCS_12_pbeWithSHA1And128BitRC4 = "1.2.840.113549.1.12.1.1";
pub const szOID_PKCS_12_pbeWithSHA1And40BitRC4 = "1.2.840.113549.1.12.1.2";
pub const szOID_PKCS_12_pbeWithSHA1And3KeyTripleDES = "1.2.840.113549.1.12.1.3";
pub const szOID_PKCS_12_pbeWithSHA1And2KeyTripleDES = "1.2.840.113549.1.12.1.4";
pub const szOID_PKCS_12_pbeWithSHA1And128BitRC2 = "1.2.840.113549.1.12.1.5";
pub const szOID_PKCS_12_pbeWithSHA1And40BitRC2 = "1.2.840.113549.1.12.1.6";
pub const szOID_PKCS_5_PBKDF2 = "1.2.840.113549.1.5.12";
pub const szOID_PKCS_5_PBES2 = "1.2.840.113549.1.5.13";
pub const PKCS12_IMPORT_SILENT = @as(u32, 64);
pub const PKCS12_ONLY_CERTIFICATES = @as(u32, 1024);
pub const PKCS12_ONLY_NOT_ENCRYPTED_CERTIFICATES = @as(u32, 2048);
pub const PKCS12_VIRTUAL_ISOLATION_KEY = @as(u32, 65536);
pub const PKCS12_IMPORT_RESERVED_MASK = @as(u32, 4294901760);
pub const PKCS12_ONLY_CERTIFICATES_PROVIDER_TYPE = @as(u32, 0);
pub const PKCS12_ONLY_CERTIFICATES_PROVIDER_NAME = "PfxProvider";
pub const PKCS12_ONLY_CERTIFICATES_CONTAINER_NAME = "PfxContainer";
pub const REPORT_NO_PRIVATE_KEY = @as(u32, 1);
pub const REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY = @as(u32, 2);
pub const EXPORT_PRIVATE_KEYS = @as(u32, 4);
pub const PKCS12_PROTECT_TO_DOMAIN_SIDS = @as(u32, 32);
pub const PKCS12_EXPORT_SILENT = @as(u32, 64);
pub const PKCS12_EXPORT_PBES2_PARAMS = @as(u32, 128);
pub const PKCS12_DISABLE_ENCRYPT_CERTIFICATES = @as(u32, 256);
pub const PKCS12_ENCRYPT_CERTIFICATES = @as(u32, 512);
pub const PKCS12_EXPORT_ECC_CURVE_PARAMETERS = @as(u32, 4096);
pub const PKCS12_EXPORT_ECC_CURVE_OID = @as(u32, 8192);
pub const PKCS12_EXPORT_RESERVED_MASK = @as(u32, 4294901760);
pub const PKCS12_PBKDF2_ID_HMAC_SHA1 = "1.2.840.113549.2.7";
pub const PKCS12_PBKDF2_ID_HMAC_SHA256 = "1.2.840.113549.2.9";
pub const PKCS12_PBKDF2_ID_HMAC_SHA384 = "1.2.840.113549.2.10";
pub const PKCS12_PBKDF2_ID_HMAC_SHA512 = "1.2.840.113549.2.11";
pub const PKCS12_PBES2_ALG_AES256_SHA256 = "AES256-SHA256";
pub const PKCS12_CONFIG_REGPATH = "Software\\Microsoft\\Windows\\CurrentVersion\\PFX";
pub const PKCS12_ENCRYPT_CERTIFICATES_VALUE_NAME = "EncryptCertificates";
pub const CERT_SERVER_OCSP_RESPONSE_OPEN_PARA_READ_FLAG = @as(u32, 1);
pub const CERT_SERVER_OCSP_RESPONSE_OPEN_PARA_WRITE_FLAG = @as(u32, 2);
pub const CERT_SERVER_OCSP_RESPONSE_ASYNC_FLAG = @as(u32, 1);
pub const CERT_RETRIEVE_ISSUER_LOGO = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 1));
pub const CERT_RETRIEVE_SUBJECT_LOGO = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 2));
pub const CERT_RETRIEVE_COMMUNITY_LOGO = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 3));
pub const CERT_RETRIEVE_BIOMETRIC_PREDEFINED_BASE_TYPE = @import("../zig.zig").typedConst([*:0]const u8, @as(i32, 1000));
pub const CERT_SELECT_MAX_PARA = @as(u32, 500);
pub const CERT_SELECT_BY_ISSUER_DISPLAYNAME = @as(u32, 12);
pub const CERT_SELECT_BY_FRIENDLYNAME = @as(u32, 13);
pub const CERT_SELECT_BY_THUMBPRINT = @as(u32, 14);
pub const CERT_SELECT_ALLOW_EXPIRED = @as(u32, 1);
pub const CERT_SELECT_TRUSTED_ROOT = @as(u32, 2);
pub const CERT_SELECT_DISALLOW_SELFSIGNED = @as(u32, 4);
pub const CERT_SELECT_HAS_PRIVATE_KEY = @as(u32, 8);
pub const CERT_SELECT_HAS_KEY_FOR_SIGNATURE = @as(u32, 16);
pub const CERT_SELECT_HAS_KEY_FOR_KEY_EXCHANGE = @as(u32, 32);
pub const CERT_SELECT_HARDWARE_ONLY = @as(u32, 64);
pub const CERT_SELECT_ALLOW_DUPLICATES = @as(u32, 128);
pub const CERT_SELECT_IGNORE_AUTOSELECT = @as(u32, 256);
pub const TIMESTAMP_FAILURE_BAD_ALG = @as(u32, 0);
pub const TIMESTAMP_FAILURE_BAD_REQUEST = @as(u32, 2);
pub const TIMESTAMP_FAILURE_BAD_FORMAT = @as(u32, 5);
pub const TIMESTAMP_FAILURE_TIME_NOT_AVAILABLE = @as(u32, 14);
pub const TIMESTAMP_FAILURE_POLICY_NOT_SUPPORTED = @as(u32, 15);
pub const TIMESTAMP_FAILURE_EXTENSION_NOT_SUPPORTED = @as(u32, 16);
pub const TIMESTAMP_FAILURE_INFO_NOT_AVAILABLE = @as(u32, 17);
pub const TIMESTAMP_FAILURE_SYSTEM_FAILURE = @as(u32, 25);
pub const TIMESTAMP_DONT_HASH_DATA = @as(u32, 1);
pub const TIMESTAMP_VERIFY_CONTEXT_SIGNATURE = @as(u32, 32);
pub const TIMESTAMP_NO_AUTH_RETRIEVAL = @as(u32, 131072);
pub const CRYPT_OBJECT_LOCATOR_SPN_NAME_TYPE = @as(u32, 1);
pub const CRYPT_OBJECT_LOCATOR_LAST_RESERVED_NAME_TYPE = @as(u32, 32);
pub const CRYPT_OBJECT_LOCATOR_FIRST_RESERVED_USER_NAME_TYPE = @as(u32, 33);
pub const CRYPT_OBJECT_LOCATOR_LAST_RESERVED_USER_NAME_TYPE = @as(u32, 65535);
pub const SSL_OBJECT_LOCATOR_PFX_FUNC = "SslObjectLocatorInitializePfx";
pub const SSL_OBJECT_LOCATOR_ISSUER_LIST_FUNC = "SslObjectLocatorInitializeIssuerList";
pub const SSL_OBJECT_LOCATOR_CERT_VALIDATION_CONFIG_FUNC = "SslObjectLocatorInitializeCertValidationConfig";
pub const CERT_FILE_HASH_USE_TYPE = @as(u32, 1);
pub const CERT_TIMESTAMP_HASH_USE_TYPE = @as(u32, 2);
pub const RECIPIENTPOLICYV1 = @as(u32, 1);
pub const RECIPIENTPOLICYV2 = @as(u32, 2);
pub const E_ICARD_COMMUNICATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073413888));
pub const E_ICARD_DATA_ACCESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073413887));
pub const E_ICARD_EXPORT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073413886));
pub const E_ICARD_IDENTITY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073413885));
pub const E_ICARD_IMPORT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073413884));
pub const E_ICARD_ARGUMENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073413883));
pub const E_ICARD_REQUEST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073413882));
pub const E_ICARD_INFORMATIONCARD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073413881));
pub const E_ICARD_STOREKEY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073413880));
pub const E_ICARD_LOGOVALIDATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073413879));
pub const E_ICARD_PASSWORDVALIDATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073413878));
pub const E_ICARD_POLICY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073413877));
pub const E_ICARD_PROCESSDIED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073413876));
pub const E_ICARD_SERVICEBUSY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073413875));
pub const E_ICARD_SERVICE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073413874));
pub const E_ICARD_SHUTTINGDOWN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073413873));
pub const E_ICARD_TOKENCREATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073413872));
pub const E_ICARD_TRUSTEXCHANGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073413871));
pub const E_ICARD_UNTRUSTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073413870));
pub const E_ICARD_USERCANCELLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073413869));
pub const E_ICARD_STORE_IMPORT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073413868));
pub const E_ICARD_FAIL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073413867));
pub const E_ICARD_UI_INITIALIZATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073413862));
pub const E_ICARD_REFRESH_REQUIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073413760));
pub const E_ICARD_MISSING_APPLIESTO = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073413759));
pub const E_ICARD_INVALID_PROOF_KEY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073413758));
pub const E_ICARD_UNKNOWN_REFERENCE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073413757));
pub const E_ICARD_FAILED_REQUIRED_CLAIMS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073413756));
pub const AUDIT_CARD_WRITTEN = @import("../zig.zig").typedConst(HRESULT, @as(i32, 1074070016));
pub const AUDIT_CARD_DELETE = @import("../zig.zig").typedConst(HRESULT, @as(i32, 1074070017));
pub const AUDIT_CARD_IMPORT = @import("../zig.zig").typedConst(HRESULT, @as(i32, 1074070018));
pub const AUDIT_STORE_IMPORT = @import("../zig.zig").typedConst(HRESULT, @as(i32, 1074070019));
pub const AUDIT_STORE_EXPORT = @import("../zig.zig").typedConst(HRESULT, @as(i32, 1074070020));
pub const AUDIT_STORE_DELETE = @import("../zig.zig").typedConst(HRESULT, @as(i32, 1074070021));
pub const AUDIT_SERVICE_IDLE_STOP = @import("../zig.zig").typedConst(HRESULT, @as(i32, 1074070022));

//--------------------------------------------------------------------------------
// Section: Types (586)
//--------------------------------------------------------------------------------
pub const BCRYPT_OPERATION = packed struct(u32) {
    CIPHER_OPERATION: u1 = 0,
    HASH_OPERATION: u1 = 0,
    ASYMMETRIC_ENCRYPTION_OPERATION: u1 = 0,
    SECRET_AGREEMENT_OPERATION: u1 = 0,
    SIGNATURE_OPERATION: u1 = 0,
    RNG_OPERATION: u1 = 0,
    _6: u1 = 0,
    _7: u1 = 0,
    _8: u1 = 0,
    _9: u1 = 0,
    _10: u1 = 0,
    _11: u1 = 0,
    _12: u1 = 0,
    _13: u1 = 0,
    _14: u1 = 0,
    _15: u1 = 0,
    _16: u1 = 0,
    _17: u1 = 0,
    _18: u1 = 0,
    _19: u1 = 0,
    _20: u1 = 0,
    _21: u1 = 0,
    _22: u1 = 0,
    _23: u1 = 0,
    _24: u1 = 0,
    _25: u1 = 0,
    _26: u1 = 0,
    _27: u1 = 0,
    _28: u1 = 0,
    _29: u1 = 0,
    _30: u1 = 0,
    _31: u1 = 0,
};
pub const BCRYPT_CIPHER_OPERATION = BCRYPT_OPERATION{ .CIPHER_OPERATION = 1 };
pub const BCRYPT_HASH_OPERATION = BCRYPT_OPERATION{ .HASH_OPERATION = 1 };
pub const BCRYPT_ASYMMETRIC_ENCRYPTION_OPERATION = BCRYPT_OPERATION{ .ASYMMETRIC_ENCRYPTION_OPERATION = 1 };
pub const BCRYPT_SECRET_AGREEMENT_OPERATION = BCRYPT_OPERATION{ .SECRET_AGREEMENT_OPERATION = 1 };
pub const BCRYPT_SIGNATURE_OPERATION = BCRYPT_OPERATION{ .SIGNATURE_OPERATION = 1 };
pub const BCRYPT_RNG_OPERATION = BCRYPT_OPERATION{ .RNG_OPERATION = 1 };

pub const NCRYPT_OPERATION = packed struct(u32) {
    CIPHER_OPERATION: u1 = 0,
    HASH_OPERATION: u1 = 0,
    ASYMMETRIC_ENCRYPTION_OPERATION: u1 = 0,
    SECRET_AGREEMENT_OPERATION: u1 = 0,
    SIGNATURE_OPERATION: u1 = 0,
    _5: u1 = 0,
    _6: u1 = 0,
    _7: u1 = 0,
    _8: u1 = 0,
    _9: u1 = 0,
    _10: u1 = 0,
    _11: u1 = 0,
    _12: u1 = 0,
    _13: u1 = 0,
    _14: u1 = 0,
    _15: u1 = 0,
    _16: u1 = 0,
    _17: u1 = 0,
    _18: u1 = 0,
    _19: u1 = 0,
    _20: u1 = 0,
    _21: u1 = 0,
    _22: u1 = 0,
    _23: u1 = 0,
    _24: u1 = 0,
    _25: u1 = 0,
    _26: u1 = 0,
    _27: u1 = 0,
    _28: u1 = 0,
    _29: u1 = 0,
    _30: u1 = 0,
    _31: u1 = 0,
};
pub const NCRYPT_CIPHER_OPERATION = NCRYPT_OPERATION{ .CIPHER_OPERATION = 1 };
pub const NCRYPT_HASH_OPERATION = NCRYPT_OPERATION{ .HASH_OPERATION = 1 };
pub const NCRYPT_ASYMMETRIC_ENCRYPTION_OPERATION = NCRYPT_OPERATION{ .ASYMMETRIC_ENCRYPTION_OPERATION = 1 };
pub const NCRYPT_SECRET_AGREEMENT_OPERATION = NCRYPT_OPERATION{ .SECRET_AGREEMENT_OPERATION = 1 };
pub const NCRYPT_SIGNATURE_OPERATION = NCRYPT_OPERATION{ .SIGNATURE_OPERATION = 1 };

pub const CERT_FIND_FLAGS = packed struct(u32) {
    OPTIONAL_ENHKEY_USAGE_FLAG: u1 = 0,
    EXT_ONLY_ENHKEY_USAGE_FLAG: u1 = 0,
    PROP_ONLY_ENHKEY_USAGE_FLAG: u1 = 0,
    NO_ENHKEY_USAGE_FLAG: u1 = 0,
    OR_ENHKEY_USAGE_FLAG: u1 = 0,
    VALID_ENHKEY_USAGE_FLAG: u1 = 0,
    _6: u1 = 0,
    _7: u1 = 0,
    _8: u1 = 0,
    _9: u1 = 0,
    _10: u1 = 0,
    _11: u1 = 0,
    _12: u1 = 0,
    _13: u1 = 0,
    _14: u1 = 0,
    _15: u1 = 0,
    HASH: u1 = 0,
    _17: u1 = 0,
    MD5_HASH: u1 = 0,
    _19: u1 = 0,
    CERT_ID: u1 = 0,
    _21: u1 = 0,
    _22: u1 = 0,
    _23: u1 = 0,
    _24: u1 = 0,
    _25: u1 = 0,
    _26: u1 = 0,
    _27: u1 = 0,
    _28: u1 = 0,
    _29: u1 = 0,
    _30: u1 = 0,
    _31: u1 = 0,
    // SHA1_HASH (bit index 16) conflicts with HASH
    // OPTIONAL_CTL_USAGE_FLAG (bit index 0) conflicts with OPTIONAL_ENHKEY_USAGE_FLAG
    // EXT_ONLY_CTL_USAGE_FLAG (bit index 1) conflicts with EXT_ONLY_ENHKEY_USAGE_FLAG
    // PROP_ONLY_CTL_USAGE_FLAG (bit index 2) conflicts with PROP_ONLY_ENHKEY_USAGE_FLAG
    // NO_CTL_USAGE_FLAG (bit index 3) conflicts with NO_ENHKEY_USAGE_FLAG
    // OR_CTL_USAGE_FLAG (bit index 4) conflicts with OR_ENHKEY_USAGE_FLAG
    // VALID_CTL_USAGE_FLAG (bit index 5) conflicts with VALID_ENHKEY_USAGE_FLAG
};
pub const CERT_FIND_ANY = CERT_FIND_FLAGS{ };
pub const CERT_FIND_CERT_ID = CERT_FIND_FLAGS{ .CERT_ID = 1 };
pub const CERT_FIND_CTL_USAGE = CERT_FIND_FLAGS{
    ._17 = 1,
    ._19 = 1,
};
pub const CERT_FIND_ENHKEY_USAGE = CERT_FIND_FLAGS{
    ._17 = 1,
    ._19 = 1,
};
pub const CERT_FIND_EXISTING = CERT_FIND_FLAGS{
    .HASH = 1,
    .MD5_HASH = 1,
    ._19 = 1,
};
pub const CERT_FIND_HASH = CERT_FIND_FLAGS{ .HASH = 1 };
pub const CERT_FIND_HAS_PRIVATE_KEY = CERT_FIND_FLAGS{
    .HASH = 1,
    .MD5_HASH = 1,
    .CERT_ID = 1,
};
pub const CERT_FIND_ISSUER_ATTR = CERT_FIND_FLAGS{
    .PROP_ONLY_ENHKEY_USAGE_FLAG = 1,
    .HASH = 1,
    ._17 = 1,
};
pub const CERT_FIND_ISSUER_NAME = CERT_FIND_FLAGS{
    .PROP_ONLY_ENHKEY_USAGE_FLAG = 1,
    ._17 = 1,
};
pub const CERT_FIND_ISSUER_OF = CERT_FIND_FLAGS{
    .MD5_HASH = 1,
    ._19 = 1,
};
pub const CERT_FIND_ISSUER_STR = CERT_FIND_FLAGS{
    .PROP_ONLY_ENHKEY_USAGE_FLAG = 1,
    ._19 = 1,
};
pub const CERT_FIND_KEY_IDENTIFIER = CERT_FIND_FLAGS{
    .HASH = 1,
    ._17 = 1,
    .MD5_HASH = 1,
    ._19 = 1,
};
pub const CERT_FIND_KEY_SPEC = CERT_FIND_FLAGS{
    .HASH = 1,
    ._19 = 1,
};
pub const CERT_FIND_MD5_HASH = CERT_FIND_FLAGS{ .MD5_HASH = 1 };
pub const CERT_FIND_PROPERTY = CERT_FIND_FLAGS{
    .HASH = 1,
    .MD5_HASH = 1,
};
pub const CERT_FIND_PUBLIC_KEY = CERT_FIND_FLAGS{
    ._17 = 1,
    .MD5_HASH = 1,
};
pub const CERT_FIND_SHA1_HASH = CERT_FIND_FLAGS{ .HASH = 1 };
pub const CERT_FIND_SIGNATURE_HASH = CERT_FIND_FLAGS{
    ._17 = 1,
    .MD5_HASH = 1,
    ._19 = 1,
};
pub const CERT_FIND_SUBJECT_ATTR = CERT_FIND_FLAGS{
    .OPTIONAL_ENHKEY_USAGE_FLAG = 1,
    .EXT_ONLY_ENHKEY_USAGE_FLAG = 1,
    .PROP_ONLY_ENHKEY_USAGE_FLAG = 1,
    .HASH = 1,
    ._17 = 1,
};
pub const CERT_FIND_SUBJECT_CERT = CERT_FIND_FLAGS{
    .HASH = 1,
    ._17 = 1,
    ._19 = 1,
};
pub const CERT_FIND_SUBJECT_NAME = CERT_FIND_FLAGS{
    .OPTIONAL_ENHKEY_USAGE_FLAG = 1,
    .EXT_ONLY_ENHKEY_USAGE_FLAG = 1,
    .PROP_ONLY_ENHKEY_USAGE_FLAG = 1,
    ._17 = 1,
};
pub const CERT_FIND_SUBJECT_STR = CERT_FIND_FLAGS{
    .OPTIONAL_ENHKEY_USAGE_FLAG = 1,
    .EXT_ONLY_ENHKEY_USAGE_FLAG = 1,
    .PROP_ONLY_ENHKEY_USAGE_FLAG = 1,
    ._19 = 1,
};
pub const CERT_FIND_CROSS_CERT_DIST_POINTS = CERT_FIND_FLAGS{
    .HASH = 1,
    .CERT_ID = 1,
};
pub const CERT_FIND_PUBKEY_MD5_HASH = CERT_FIND_FLAGS{
    ._17 = 1,
    .CERT_ID = 1,
};
pub const CERT_FIND_SUBJECT_STR_A = CERT_FIND_FLAGS{
    .OPTIONAL_ENHKEY_USAGE_FLAG = 1,
    .EXT_ONLY_ENHKEY_USAGE_FLAG = 1,
    .PROP_ONLY_ENHKEY_USAGE_FLAG = 1,
    .HASH = 1,
    ._17 = 1,
    .MD5_HASH = 1,
};
pub const CERT_FIND_SUBJECT_STR_W = CERT_FIND_FLAGS{
    .OPTIONAL_ENHKEY_USAGE_FLAG = 1,
    .EXT_ONLY_ENHKEY_USAGE_FLAG = 1,
    .PROP_ONLY_ENHKEY_USAGE_FLAG = 1,
    ._19 = 1,
};
pub const CERT_FIND_ISSUER_STR_A = CERT_FIND_FLAGS{
    .PROP_ONLY_ENHKEY_USAGE_FLAG = 1,
    .HASH = 1,
    ._17 = 1,
    .MD5_HASH = 1,
};
pub const CERT_FIND_ISSUER_STR_W = CERT_FIND_FLAGS{
    .PROP_ONLY_ENHKEY_USAGE_FLAG = 1,
    ._19 = 1,
};
pub const CERT_FIND_SUBJECT_INFO_ACCESS = CERT_FIND_FLAGS{
    .HASH = 1,
    ._17 = 1,
    .CERT_ID = 1,
};
pub const CERT_FIND_HASH_STR = CERT_FIND_FLAGS{
    .MD5_HASH = 1,
    .CERT_ID = 1,
};
pub const CERT_FIND_OPTIONAL_ENHKEY_USAGE_FLAG = CERT_FIND_FLAGS{ .OPTIONAL_ENHKEY_USAGE_FLAG = 1 };
pub const CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG = CERT_FIND_FLAGS{ .EXT_ONLY_ENHKEY_USAGE_FLAG = 1 };
pub const CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG = CERT_FIND_FLAGS{ .PROP_ONLY_ENHKEY_USAGE_FLAG = 1 };
pub const CERT_FIND_NO_ENHKEY_USAGE_FLAG = CERT_FIND_FLAGS{ .NO_ENHKEY_USAGE_FLAG = 1 };
pub const CERT_FIND_OR_ENHKEY_USAGE_FLAG = CERT_FIND_FLAGS{ .OR_ENHKEY_USAGE_FLAG = 1 };
pub const CERT_FIND_VALID_ENHKEY_USAGE_FLAG = CERT_FIND_FLAGS{ .VALID_ENHKEY_USAGE_FLAG = 1 };
pub const CERT_FIND_OPTIONAL_CTL_USAGE_FLAG = CERT_FIND_FLAGS{ .OPTIONAL_ENHKEY_USAGE_FLAG = 1 };
pub const CERT_FIND_EXT_ONLY_CTL_USAGE_FLAG = CERT_FIND_FLAGS{ .EXT_ONLY_ENHKEY_USAGE_FLAG = 1 };
pub const CERT_FIND_PROP_ONLY_CTL_USAGE_FLAG = CERT_FIND_FLAGS{ .PROP_ONLY_ENHKEY_USAGE_FLAG = 1 };
pub const CERT_FIND_NO_CTL_USAGE_FLAG = CERT_FIND_FLAGS{ .NO_ENHKEY_USAGE_FLAG = 1 };
pub const CERT_FIND_OR_CTL_USAGE_FLAG = CERT_FIND_FLAGS{ .OR_ENHKEY_USAGE_FLAG = 1 };
pub const CERT_FIND_VALID_CTL_USAGE_FLAG = CERT_FIND_FLAGS{ .VALID_ENHKEY_USAGE_FLAG = 1 };

pub const CERT_QUERY_OBJECT_TYPE = enum(u32) {
    FILE = 1,
    BLOB = 2,
};
pub const CERT_QUERY_OBJECT_FILE = CERT_QUERY_OBJECT_TYPE.FILE;
pub const CERT_QUERY_OBJECT_BLOB = CERT_QUERY_OBJECT_TYPE.BLOB;

pub const CERT_QUERY_CONTENT_TYPE = enum(u32) {
    CERT = 1,
    CTL = 2,
    CRL = 3,
    SERIALIZED_STORE = 4,
    SERIALIZED_CERT = 5,
    SERIALIZED_CTL = 6,
    SERIALIZED_CRL = 7,
    PKCS7_SIGNED = 8,
    PKCS7_UNSIGNED = 9,
    PKCS7_SIGNED_EMBED = 10,
    PKCS10 = 11,
    PFX = 12,
    CERT_PAIR = 13,
    PFX_AND_LOAD = 14,
};
pub const CERT_QUERY_CONTENT_CERT = CERT_QUERY_CONTENT_TYPE.CERT;
pub const CERT_QUERY_CONTENT_CTL = CERT_QUERY_CONTENT_TYPE.CTL;
pub const CERT_QUERY_CONTENT_CRL = CERT_QUERY_CONTENT_TYPE.CRL;
pub const CERT_QUERY_CONTENT_SERIALIZED_STORE = CERT_QUERY_CONTENT_TYPE.SERIALIZED_STORE;
pub const CERT_QUERY_CONTENT_SERIALIZED_CERT = CERT_QUERY_CONTENT_TYPE.SERIALIZED_CERT;
pub const CERT_QUERY_CONTENT_SERIALIZED_CTL = CERT_QUERY_CONTENT_TYPE.SERIALIZED_CTL;
pub const CERT_QUERY_CONTENT_SERIALIZED_CRL = CERT_QUERY_CONTENT_TYPE.SERIALIZED_CRL;
pub const CERT_QUERY_CONTENT_PKCS7_SIGNED = CERT_QUERY_CONTENT_TYPE.PKCS7_SIGNED;
pub const CERT_QUERY_CONTENT_PKCS7_UNSIGNED = CERT_QUERY_CONTENT_TYPE.PKCS7_UNSIGNED;
pub const CERT_QUERY_CONTENT_PKCS7_SIGNED_EMBED = CERT_QUERY_CONTENT_TYPE.PKCS7_SIGNED_EMBED;
pub const CERT_QUERY_CONTENT_PKCS10 = CERT_QUERY_CONTENT_TYPE.PKCS10;
pub const CERT_QUERY_CONTENT_PFX = CERT_QUERY_CONTENT_TYPE.PFX;
pub const CERT_QUERY_CONTENT_CERT_PAIR = CERT_QUERY_CONTENT_TYPE.CERT_PAIR;
pub const CERT_QUERY_CONTENT_PFX_AND_LOAD = CERT_QUERY_CONTENT_TYPE.PFX_AND_LOAD;

pub const CERT_QUERY_CONTENT_TYPE_FLAGS = enum(u32) {
    CERT = 2,
    CTL = 4,
    CRL = 8,
    SERIALIZED_STORE = 16,
    SERIALIZED_CERT = 32,
    SERIALIZED_CTL = 64,
    SERIALIZED_CRL = 128,
    PKCS7_SIGNED = 256,
    PKCS7_UNSIGNED = 512,
    PKCS7_SIGNED_EMBED = 1024,
    PKCS10 = 2048,
    PFX = 4096,
    CERT_PAIR = 8192,
    PFX_AND_LOAD = 16384,
    ALL = 16382,
    ALL_ISSUER_CERT = 818,
};
pub const CERT_QUERY_CONTENT_FLAG_CERT = CERT_QUERY_CONTENT_TYPE_FLAGS.CERT;
pub const CERT_QUERY_CONTENT_FLAG_CTL = CERT_QUERY_CONTENT_TYPE_FLAGS.CTL;
pub const CERT_QUERY_CONTENT_FLAG_CRL = CERT_QUERY_CONTENT_TYPE_FLAGS.CRL;
pub const CERT_QUERY_CONTENT_FLAG_SERIALIZED_STORE = CERT_QUERY_CONTENT_TYPE_FLAGS.SERIALIZED_STORE;
pub const CERT_QUERY_CONTENT_FLAG_SERIALIZED_CERT = CERT_QUERY_CONTENT_TYPE_FLAGS.SERIALIZED_CERT;
pub const CERT_QUERY_CONTENT_FLAG_SERIALIZED_CTL = CERT_QUERY_CONTENT_TYPE_FLAGS.SERIALIZED_CTL;
pub const CERT_QUERY_CONTENT_FLAG_SERIALIZED_CRL = CERT_QUERY_CONTENT_TYPE_FLAGS.SERIALIZED_CRL;
pub const CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED = CERT_QUERY_CONTENT_TYPE_FLAGS.PKCS7_SIGNED;
pub const CERT_QUERY_CONTENT_FLAG_PKCS7_UNSIGNED = CERT_QUERY_CONTENT_TYPE_FLAGS.PKCS7_UNSIGNED;
pub const CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED_EMBED = CERT_QUERY_CONTENT_TYPE_FLAGS.PKCS7_SIGNED_EMBED;
pub const CERT_QUERY_CONTENT_FLAG_PKCS10 = CERT_QUERY_CONTENT_TYPE_FLAGS.PKCS10;
pub const CERT_QUERY_CONTENT_FLAG_PFX = CERT_QUERY_CONTENT_TYPE_FLAGS.PFX;
pub const CERT_QUERY_CONTENT_FLAG_CERT_PAIR = CERT_QUERY_CONTENT_TYPE_FLAGS.CERT_PAIR;
pub const CERT_QUERY_CONTENT_FLAG_PFX_AND_LOAD = CERT_QUERY_CONTENT_TYPE_FLAGS.PFX_AND_LOAD;
pub const CERT_QUERY_CONTENT_FLAG_ALL = CERT_QUERY_CONTENT_TYPE_FLAGS.ALL;
pub const CERT_QUERY_CONTENT_FLAG_ALL_ISSUER_CERT = CERT_QUERY_CONTENT_TYPE_FLAGS.ALL_ISSUER_CERT;

pub const CERT_QUERY_FORMAT_TYPE = enum(u32) {
    BINARY = 1,
    BASE64_ENCODED = 2,
    ASN_ASCII_HEX_ENCODED = 3,
};
pub const CERT_QUERY_FORMAT_BINARY = CERT_QUERY_FORMAT_TYPE.BINARY;
pub const CERT_QUERY_FORMAT_BASE64_ENCODED = CERT_QUERY_FORMAT_TYPE.BASE64_ENCODED;
pub const CERT_QUERY_FORMAT_ASN_ASCII_HEX_ENCODED = CERT_QUERY_FORMAT_TYPE.ASN_ASCII_HEX_ENCODED;

pub const CERT_QUERY_FORMAT_TYPE_FLAGS = enum(u32) {
    BINARY = 2,
    BASE64_ENCODED = 4,
    ASN_ASCII_HEX_ENCODED = 8,
    ALL = 14,
};
pub const CERT_QUERY_FORMAT_FLAG_BINARY = CERT_QUERY_FORMAT_TYPE_FLAGS.BINARY;
pub const CERT_QUERY_FORMAT_FLAG_BASE64_ENCODED = CERT_QUERY_FORMAT_TYPE_FLAGS.BASE64_ENCODED;
pub const CERT_QUERY_FORMAT_FLAG_ASN_ASCII_HEX_ENCODED = CERT_QUERY_FORMAT_TYPE_FLAGS.ASN_ASCII_HEX_ENCODED;
pub const CERT_QUERY_FORMAT_FLAG_ALL = CERT_QUERY_FORMAT_TYPE_FLAGS.ALL;

pub const CERT_QUERY_ENCODING_TYPE = enum(u32) {
    X509_ASN_ENCODING = 1,
    PKCS_7_ASN_ENCODING = 65536,
};
pub const X509_ASN_ENCODING = CERT_QUERY_ENCODING_TYPE.X509_ASN_ENCODING;
pub const PKCS_7_ASN_ENCODING = CERT_QUERY_ENCODING_TYPE.PKCS_7_ASN_ENCODING;

pub const CERT_RDN_ATTR_VALUE_TYPE = enum(u32) {
    ANY_TYPE = 0,
    NUMERIC_STRING = 3,
    PRINTABLE_STRING = 4,
    T61_STRING = 5,
    VIDEOTEX_STRING = 6,
    IA5_STRING = 7,
    GRAPHIC_STRING = 8,
    ISO646_STRING = 9,
    GENERAL_STRING = 10,
    INT4_STRING = 11,
    UNICODE_STRING = 12,
    ENCODED_BLOB = 1,
    OCTET_STRING = 2,
    UTF8_STRING = 13,
    pub const BMP_STRING = .UNICODE_STRING;
    pub const TELETEX_STRING = .T61_STRING;
    pub const UNIVERSAL_STRING = .INT4_STRING;
    pub const VISIBLE_STRING = .ISO646_STRING;
};
pub const CERT_RDN_ANY_TYPE = CERT_RDN_ATTR_VALUE_TYPE.ANY_TYPE;
pub const CERT_RDN_NUMERIC_STRING = CERT_RDN_ATTR_VALUE_TYPE.NUMERIC_STRING;
pub const CERT_RDN_PRINTABLE_STRING = CERT_RDN_ATTR_VALUE_TYPE.PRINTABLE_STRING;
pub const CERT_RDN_T61_STRING = CERT_RDN_ATTR_VALUE_TYPE.T61_STRING;
pub const CERT_RDN_VIDEOTEX_STRING = CERT_RDN_ATTR_VALUE_TYPE.VIDEOTEX_STRING;
pub const CERT_RDN_IA5_STRING = CERT_RDN_ATTR_VALUE_TYPE.IA5_STRING;
pub const CERT_RDN_GRAPHIC_STRING = CERT_RDN_ATTR_VALUE_TYPE.GRAPHIC_STRING;
pub const CERT_RDN_ISO646_STRING = CERT_RDN_ATTR_VALUE_TYPE.ISO646_STRING;
pub const CERT_RDN_GENERAL_STRING = CERT_RDN_ATTR_VALUE_TYPE.GENERAL_STRING;
pub const CERT_RDN_INT4_STRING = CERT_RDN_ATTR_VALUE_TYPE.INT4_STRING;
pub const CERT_RDN_UNICODE_STRING = CERT_RDN_ATTR_VALUE_TYPE.UNICODE_STRING;
pub const CERT_RDN_BMP_STRING = CERT_RDN_ATTR_VALUE_TYPE.UNICODE_STRING;
pub const CERT_RDN_ENCODED_BLOB = CERT_RDN_ATTR_VALUE_TYPE.ENCODED_BLOB;
pub const CERT_RDN_OCTET_STRING = CERT_RDN_ATTR_VALUE_TYPE.OCTET_STRING;
pub const CERT_RDN_TELETEX_STRING = CERT_RDN_ATTR_VALUE_TYPE.T61_STRING;
pub const CERT_RDN_UNIVERSAL_STRING = CERT_RDN_ATTR_VALUE_TYPE.INT4_STRING;
pub const CERT_RDN_UTF8_STRING = CERT_RDN_ATTR_VALUE_TYPE.UTF8_STRING;
pub const CERT_RDN_VISIBLE_STRING = CERT_RDN_ATTR_VALUE_TYPE.ISO646_STRING;

pub const CERT_STRING_TYPE = enum(u32) {
    SIMPLE_NAME_STR = 1,
    OID_NAME_STR = 2,
    X500_NAME_STR = 3,
};
pub const CERT_SIMPLE_NAME_STR = CERT_STRING_TYPE.SIMPLE_NAME_STR;
pub const CERT_OID_NAME_STR = CERT_STRING_TYPE.OID_NAME_STR;
pub const CERT_X500_NAME_STR = CERT_STRING_TYPE.X500_NAME_STR;

pub const BCRYPT_TABLE = enum(u32) {
    LOCAL = 1,
    DOMAIN = 2,
};
pub const CRYPT_LOCAL = BCRYPT_TABLE.LOCAL;
pub const CRYPT_DOMAIN = BCRYPT_TABLE.DOMAIN;

pub const CERT_KEY_SPEC = enum(u32) {
    AT_KEYEXCHANGE = 1,
    AT_SIGNATURE = 2,
    CERT_NCRYPT_KEY_SPEC = 4294967295,
};
pub const AT_KEYEXCHANGE = CERT_KEY_SPEC.AT_KEYEXCHANGE;
pub const AT_SIGNATURE = CERT_KEY_SPEC.AT_SIGNATURE;
pub const CERT_NCRYPT_KEY_SPEC = CERT_KEY_SPEC.CERT_NCRYPT_KEY_SPEC;

pub const BCRYPT_INTERFACE = enum(u32) {
    BCRYPT_ASYMMETRIC_ENCRYPTION_INTERFACE = 3,
    BCRYPT_CIPHER_INTERFACE = 1,
    BCRYPT_HASH_INTERFACE = 2,
    BCRYPT_RNG_INTERFACE = 6,
    BCRYPT_SECRET_AGREEMENT_INTERFACE = 4,
    BCRYPT_SIGNATURE_INTERFACE = 5,
    NCRYPT_KEY_STORAGE_INTERFACE = 65537,
    NCRYPT_SCHANNEL_INTERFACE = 65538,
    NCRYPT_SCHANNEL_SIGNATURE_INTERFACE = 65539,
};
pub const BCRYPT_ASYMMETRIC_ENCRYPTION_INTERFACE = BCRYPT_INTERFACE.BCRYPT_ASYMMETRIC_ENCRYPTION_INTERFACE;
pub const BCRYPT_CIPHER_INTERFACE = BCRYPT_INTERFACE.BCRYPT_CIPHER_INTERFACE;
pub const BCRYPT_HASH_INTERFACE = BCRYPT_INTERFACE.BCRYPT_HASH_INTERFACE;
pub const BCRYPT_RNG_INTERFACE = BCRYPT_INTERFACE.BCRYPT_RNG_INTERFACE;
pub const BCRYPT_SECRET_AGREEMENT_INTERFACE = BCRYPT_INTERFACE.BCRYPT_SECRET_AGREEMENT_INTERFACE;
pub const BCRYPT_SIGNATURE_INTERFACE = BCRYPT_INTERFACE.BCRYPT_SIGNATURE_INTERFACE;
pub const NCRYPT_KEY_STORAGE_INTERFACE = BCRYPT_INTERFACE.NCRYPT_KEY_STORAGE_INTERFACE;
pub const NCRYPT_SCHANNEL_INTERFACE = BCRYPT_INTERFACE.NCRYPT_SCHANNEL_INTERFACE;
pub const NCRYPT_SCHANNEL_SIGNATURE_INTERFACE = BCRYPT_INTERFACE.NCRYPT_SCHANNEL_SIGNATURE_INTERFACE;

pub const NCRYPT_FLAGS = packed struct(u32) {
    BCRYPT_PAD_NONE: u1 = 0,
    BCRYPT_PAD_PKCS1: u1 = 0,
    BCRYPT_PAD_OAEP: u1 = 0,
    BCRYPT_PAD_PSS: u1 = 0,
    _4: u1 = 0,
    NCRYPT_MACHINE_KEY_FLAG: u1 = 0,
    NCRYPT_SILENT_FLAG: u1 = 0,
    NCRYPT_OVERWRITE_KEY_FLAG: u1 = 0,
    _8: u1 = 0,
    NCRYPT_WRITE_KEY_TO_LEGACY_STORE_FLAG: u1 = 0,
    _10: u1 = 0,
    _11: u1 = 0,
    _12: u1 = 0,
    _13: u1 = 0,
    _14: u1 = 0,
    _15: u1 = 0,
    _16: u1 = 0,
    _17: u1 = 0,
    _18: u1 = 0,
    _19: u1 = 0,
    _20: u1 = 0,
    _21: u1 = 0,
    _22: u1 = 0,
    _23: u1 = 0,
    _24: u1 = 0,
    _25: u1 = 0,
    _26: u1 = 0,
    _27: u1 = 0,
    _28: u1 = 0,
    _29: u1 = 0,
    NCRYPT_PERSIST_ONLY_FLAG: u1 = 0,
    NCRYPT_PERSIST_FLAG: u1 = 0,
    // NCRYPT_NO_PADDING_FLAG (bit index 0) conflicts with BCRYPT_PAD_NONE
    // NCRYPT_PAD_OAEP_FLAG (bit index 2) conflicts with BCRYPT_PAD_OAEP
    // NCRYPT_PAD_PKCS1_FLAG (bit index 1) conflicts with BCRYPT_PAD_PKCS1
    // NCRYPT_REGISTER_NOTIFY_FLAG (bit index 0) conflicts with BCRYPT_PAD_NONE
    // NCRYPT_UNREGISTER_NOTIFY_FLAG (bit index 1) conflicts with BCRYPT_PAD_PKCS1
    // NCRYPT_UNPROTECT_NO_DECRYPT (bit index 0) conflicts with BCRYPT_PAD_NONE
    // NCRYPT_NO_KEY_VALIDATION (bit index 3) conflicts with BCRYPT_PAD_PSS
    // NCRYPT_PAD_PSS_FLAG (bit index 3) conflicts with BCRYPT_PAD_PSS
};
pub const BCRYPT_PAD_NONE = NCRYPT_FLAGS{ .BCRYPT_PAD_NONE = 1 };
pub const BCRYPT_PAD_OAEP = NCRYPT_FLAGS{ .BCRYPT_PAD_OAEP = 1 };
pub const BCRYPT_PAD_PKCS1 = NCRYPT_FLAGS{ .BCRYPT_PAD_PKCS1 = 1 };
pub const BCRYPT_PAD_PSS = NCRYPT_FLAGS{ .BCRYPT_PAD_PSS = 1 };
pub const NCRYPT_SILENT_FLAG = NCRYPT_FLAGS{ .NCRYPT_SILENT_FLAG = 1 };
pub const NCRYPT_NO_PADDING_FLAG = NCRYPT_FLAGS{ .BCRYPT_PAD_NONE = 1 };
pub const NCRYPT_PAD_OAEP_FLAG = NCRYPT_FLAGS{ .BCRYPT_PAD_OAEP = 1 };
pub const NCRYPT_PAD_PKCS1_FLAG = NCRYPT_FLAGS{ .BCRYPT_PAD_PKCS1 = 1 };
pub const NCRYPT_REGISTER_NOTIFY_FLAG = NCRYPT_FLAGS{ .BCRYPT_PAD_NONE = 1 };
pub const NCRYPT_UNREGISTER_NOTIFY_FLAG = NCRYPT_FLAGS{ .BCRYPT_PAD_PKCS1 = 1 };
pub const NCRYPT_MACHINE_KEY_FLAG = NCRYPT_FLAGS{ .NCRYPT_MACHINE_KEY_FLAG = 1 };
pub const NCRYPT_UNPROTECT_NO_DECRYPT = NCRYPT_FLAGS{ .BCRYPT_PAD_NONE = 1 };
pub const NCRYPT_OVERWRITE_KEY_FLAG = NCRYPT_FLAGS{ .NCRYPT_OVERWRITE_KEY_FLAG = 1 };
pub const NCRYPT_NO_KEY_VALIDATION = NCRYPT_FLAGS{ .BCRYPT_PAD_PSS = 1 };
pub const NCRYPT_WRITE_KEY_TO_LEGACY_STORE_FLAG = NCRYPT_FLAGS{ .NCRYPT_WRITE_KEY_TO_LEGACY_STORE_FLAG = 1 };
pub const NCRYPT_PAD_PSS_FLAG = NCRYPT_FLAGS{ .BCRYPT_PAD_PSS = 1 };
pub const NCRYPT_PERSIST_FLAG = NCRYPT_FLAGS{ .NCRYPT_PERSIST_FLAG = 1 };
pub const NCRYPT_PERSIST_ONLY_FLAG = NCRYPT_FLAGS{ .NCRYPT_PERSIST_ONLY_FLAG = 1 };

pub const CRYPT_STRING = enum(u32) {
    BASE64HEADER = 0,
    BASE64 = 1,
    BINARY = 2,
    BASE64REQUESTHEADER = 3,
    HEX = 4,
    HEXASCII = 5,
    BASE64X509CRLHEADER = 9,
    HEXADDR = 10,
    HEXASCIIADDR = 11,
    HEXRAW = 12,
    STRICT = 536870912,
    BASE64_ANY = 6,
    ANY = 7,
    HEX_ANY = 8,
};
pub const CRYPT_STRING_BASE64HEADER = CRYPT_STRING.BASE64HEADER;
pub const CRYPT_STRING_BASE64 = CRYPT_STRING.BASE64;
pub const CRYPT_STRING_BINARY = CRYPT_STRING.BINARY;
pub const CRYPT_STRING_BASE64REQUESTHEADER = CRYPT_STRING.BASE64REQUESTHEADER;
pub const CRYPT_STRING_HEX = CRYPT_STRING.HEX;
pub const CRYPT_STRING_HEXASCII = CRYPT_STRING.HEXASCII;
pub const CRYPT_STRING_BASE64X509CRLHEADER = CRYPT_STRING.BASE64X509CRLHEADER;
pub const CRYPT_STRING_HEXADDR = CRYPT_STRING.HEXADDR;
pub const CRYPT_STRING_HEXASCIIADDR = CRYPT_STRING.HEXASCIIADDR;
pub const CRYPT_STRING_HEXRAW = CRYPT_STRING.HEXRAW;
pub const CRYPT_STRING_STRICT = CRYPT_STRING.STRICT;
pub const CRYPT_STRING_BASE64_ANY = CRYPT_STRING.BASE64_ANY;
pub const CRYPT_STRING_ANY = CRYPT_STRING.ANY;
pub const CRYPT_STRING_HEX_ANY = CRYPT_STRING.HEX_ANY;

pub const CRYPT_IMPORT_PUBLIC_KEY_FLAGS = packed struct(u32) {
    _0: u1 = 0,
    _1: u1 = 0,
    _2: u1 = 0,
    _3: u1 = 0,
    _4: u1 = 0,
    _5: u1 = 0,
    _6: u1 = 0,
    _7: u1 = 0,
    _8: u1 = 0,
    _9: u1 = 0,
    _10: u1 = 0,
    _11: u1 = 0,
    _12: u1 = 0,
    _13: u1 = 0,
    _14: u1 = 0,
    _15: u1 = 0,
    _16: u1 = 0,
    _17: u1 = 0,
    _18: u1 = 0,
    _19: u1 = 0,
    _20: u1 = 0,
    _21: u1 = 0,
    _22: u1 = 0,
    _23: u1 = 0,
    _24: u1 = 0,
    _25: u1 = 0,
    _26: u1 = 0,
    _27: u1 = 0,
    _28: u1 = 0,
    _29: u1 = 0,
    ENCRYPT_KEY_FLAG: u1 = 0,
    SIGN_KEY_FLAG: u1 = 0,
};
pub const CRYPT_OID_INFO_PUBKEY_SIGN_KEY_FLAG = CRYPT_IMPORT_PUBLIC_KEY_FLAGS{ .SIGN_KEY_FLAG = 1 };
pub const CRYPT_OID_INFO_PUBKEY_ENCRYPT_KEY_FLAG = CRYPT_IMPORT_PUBLIC_KEY_FLAGS{ .ENCRYPT_KEY_FLAG = 1 };

pub const CRYPT_XML_FLAGS = enum(u32) {
    FLAG_DISABLE_EXTENSIONS = 268435456,
    FLAG_NO_SERIALIZE = 2147483648,
    SIGN_ADD_KEYVALUE = 1,
};
pub const CRYPT_XML_FLAG_DISABLE_EXTENSIONS = CRYPT_XML_FLAGS.FLAG_DISABLE_EXTENSIONS;
pub const CRYPT_XML_FLAG_NO_SERIALIZE = CRYPT_XML_FLAGS.FLAG_NO_SERIALIZE;
pub const CRYPT_XML_SIGN_ADD_KEYVALUE = CRYPT_XML_FLAGS.SIGN_ADD_KEYVALUE;

pub const CRYPT_ENCODE_OBJECT_FLAGS = packed struct(u32) {
    _0: u1 = 0,
    _1: u1 = 0,
    _2: u1 = 0,
    _3: u1 = 0,
    _4: u1 = 0,
    _5: u1 = 0,
    _6: u1 = 0,
    _7: u1 = 0,
    _8: u1 = 0,
    _9: u1 = 0,
    _10: u1 = 0,
    _11: u1 = 0,
    _12: u1 = 0,
    _13: u1 = 0,
    _14: u1 = 0,
    ENCODE_ALLOC_FLAG: u1 = 0,
    _16: u1 = 0,
    ENCODE_ENABLE_PUNYCODE_FLAG: u1 = 0,
    _18: u1 = 0,
    _19: u1 = 0,
    _20: u1 = 0,
    _21: u1 = 0,
    _22: u1 = 0,
    _23: u1 = 0,
    _24: u1 = 0,
    _25: u1 = 0,
    _26: u1 = 0,
    _27: u1 = 0,
    _28: u1 = 0,
    UNICODE_NAME_ENCODE_ENABLE_UTF8_UNICODE_FLAG: u1 = 0,
    UNICODE_NAME_ENCODE_DISABLE_CHECK_TYPE_FLAG: u1 = 0,
    UNICODE_NAME_ENCODE_ENABLE_T61_UNICODE_FLAG: u1 = 0,
};
pub const CRYPT_ENCODE_ALLOC_FLAG = CRYPT_ENCODE_OBJECT_FLAGS{ .ENCODE_ALLOC_FLAG = 1 };
pub const CRYPT_ENCODE_ENABLE_PUNYCODE_FLAG = CRYPT_ENCODE_OBJECT_FLAGS{ .ENCODE_ENABLE_PUNYCODE_FLAG = 1 };
pub const CRYPT_UNICODE_NAME_ENCODE_DISABLE_CHECK_TYPE_FLAG = CRYPT_ENCODE_OBJECT_FLAGS{ .UNICODE_NAME_ENCODE_DISABLE_CHECK_TYPE_FLAG = 1 };
pub const CRYPT_UNICODE_NAME_ENCODE_ENABLE_T61_UNICODE_FLAG = CRYPT_ENCODE_OBJECT_FLAGS{ .UNICODE_NAME_ENCODE_ENABLE_T61_UNICODE_FLAG = 1 };
pub const CRYPT_UNICODE_NAME_ENCODE_ENABLE_UTF8_UNICODE_FLAG = CRYPT_ENCODE_OBJECT_FLAGS{ .UNICODE_NAME_ENCODE_ENABLE_UTF8_UNICODE_FLAG = 1 };

pub const CRYPT_OBJECT_LOCATOR_RELEASE_REASON = enum(u32) {
    SYSTEM_SHUTDOWN = 1,
    SERVICE_STOP = 2,
    PROCESS_EXIT = 3,
    DLL_UNLOAD = 4,
};
pub const CRYPT_OBJECT_LOCATOR_RELEASE_SYSTEM_SHUTDOWN = CRYPT_OBJECT_LOCATOR_RELEASE_REASON.SYSTEM_SHUTDOWN;
pub const CRYPT_OBJECT_LOCATOR_RELEASE_SERVICE_STOP = CRYPT_OBJECT_LOCATOR_RELEASE_REASON.SERVICE_STOP;
pub const CRYPT_OBJECT_LOCATOR_RELEASE_PROCESS_EXIT = CRYPT_OBJECT_LOCATOR_RELEASE_REASON.PROCESS_EXIT;
pub const CRYPT_OBJECT_LOCATOR_RELEASE_DLL_UNLOAD = CRYPT_OBJECT_LOCATOR_RELEASE_REASON.DLL_UNLOAD;

pub const CRYPT_ACQUIRE_FLAGS = packed struct(u32) {
    CACHE_FLAG: u1 = 0,
    USE_PROV_INFO_FLAG: u1 = 0,
    COMPARE_KEY_FLAG: u1 = 0,
    NO_HEALING: u1 = 0,
    _4: u1 = 0,
    _5: u1 = 0,
    SILENT_FLAG: u1 = 0,
    _7: u1 = 0,
    _8: u1 = 0,
    _9: u1 = 0,
    _10: u1 = 0,
    _11: u1 = 0,
    _12: u1 = 0,
    _13: u1 = 0,
    _14: u1 = 0,
    _15: u1 = 0,
    _16: u1 = 0,
    _17: u1 = 0,
    _18: u1 = 0,
    _19: u1 = 0,
    _20: u1 = 0,
    _21: u1 = 0,
    _22: u1 = 0,
    _23: u1 = 0,
    _24: u1 = 0,
    _25: u1 = 0,
    _26: u1 = 0,
    _27: u1 = 0,
    _28: u1 = 0,
    _29: u1 = 0,
    _30: u1 = 0,
    _31: u1 = 0,
};
pub const CRYPT_ACQUIRE_CACHE_FLAG = CRYPT_ACQUIRE_FLAGS{ .CACHE_FLAG = 1 };
pub const CRYPT_ACQUIRE_COMPARE_KEY_FLAG = CRYPT_ACQUIRE_FLAGS{ .COMPARE_KEY_FLAG = 1 };
pub const CRYPT_ACQUIRE_NO_HEALING = CRYPT_ACQUIRE_FLAGS{ .NO_HEALING = 1 };
pub const CRYPT_ACQUIRE_SILENT_FLAG = CRYPT_ACQUIRE_FLAGS{ .SILENT_FLAG = 1 };
pub const CRYPT_ACQUIRE_USE_PROV_INFO_FLAG = CRYPT_ACQUIRE_FLAGS{ .USE_PROV_INFO_FLAG = 1 };

pub const CRYPT_GET_URL_FLAGS = packed struct(u32) {
    PROPERTY: u1 = 0,
    EXTENSION: u1 = 0,
    UNAUTH_ATTRIBUTE: u1 = 0,
    AUTH_ATTRIBUTE: u1 = 0,
    _4: u1 = 0,
    _5: u1 = 0,
    _6: u1 = 0,
    _7: u1 = 0,
    _8: u1 = 0,
    _9: u1 = 0,
    _10: u1 = 0,
    _11: u1 = 0,
    _12: u1 = 0,
    _13: u1 = 0,
    _14: u1 = 0,
    _15: u1 = 0,
    _16: u1 = 0,
    _17: u1 = 0,
    _18: u1 = 0,
    _19: u1 = 0,
    _20: u1 = 0,
    _21: u1 = 0,
    _22: u1 = 0,
    _23: u1 = 0,
    _24: u1 = 0,
    _25: u1 = 0,
    _26: u1 = 0,
    _27: u1 = 0,
    _28: u1 = 0,
    _29: u1 = 0,
    _30: u1 = 0,
    _31: u1 = 0,
};
pub const CRYPT_GET_URL_FROM_PROPERTY = CRYPT_GET_URL_FLAGS{ .PROPERTY = 1 };
pub const CRYPT_GET_URL_FROM_EXTENSION = CRYPT_GET_URL_FLAGS{ .EXTENSION = 1 };
pub const CRYPT_GET_URL_FROM_UNAUTH_ATTRIBUTE = CRYPT_GET_URL_FLAGS{ .UNAUTH_ATTRIBUTE = 1 };
pub const CRYPT_GET_URL_FROM_AUTH_ATTRIBUTE = CRYPT_GET_URL_FLAGS{ .AUTH_ATTRIBUTE = 1 };

pub const CERT_STORE_SAVE_AS = enum(u32) {
    PKCS7 = 2,
    STORE = 1,
};
pub const CERT_STORE_SAVE_AS_PKCS7 = CERT_STORE_SAVE_AS.PKCS7;
pub const CERT_STORE_SAVE_AS_STORE = CERT_STORE_SAVE_AS.STORE;

pub const BCRYPT_QUERY_PROVIDER_MODE = enum(u32) {
    ANY = 4,
    UM = 1,
    KM = 2,
    MM = 3,
};
pub const CRYPT_ANY = BCRYPT_QUERY_PROVIDER_MODE.ANY;
pub const CRYPT_UM = BCRYPT_QUERY_PROVIDER_MODE.UM;
pub const CRYPT_KM = BCRYPT_QUERY_PROVIDER_MODE.KM;
pub const CRYPT_MM = BCRYPT_QUERY_PROVIDER_MODE.MM;

pub const CERT_FIND_CHAIN_IN_STORE_FLAGS = packed struct(u32) {
    COMPARE_KEY_FLAG: u1 = 0,
    COMPLEX_CHAIN_FLAG: u1 = 0,
    CACHE_ONLY_URL_FLAG: u1 = 0,
    LOCAL_MACHINE_FLAG: u1 = 0,
    _4: u1 = 0,
    _5: u1 = 0,
    _6: u1 = 0,
    _7: u1 = 0,
    _8: u1 = 0,
    _9: u1 = 0,
    _10: u1 = 0,
    _11: u1 = 0,
    _12: u1 = 0,
    _13: u1 = 0,
    NO_KEY_FLAG: u1 = 0,
    CACHE_ONLY_FLAG: u1 = 0,
    _16: u1 = 0,
    _17: u1 = 0,
    _18: u1 = 0,
    _19: u1 = 0,
    _20: u1 = 0,
    _21: u1 = 0,
    _22: u1 = 0,
    _23: u1 = 0,
    _24: u1 = 0,
    _25: u1 = 0,
    _26: u1 = 0,
    _27: u1 = 0,
    _28: u1 = 0,
    _29: u1 = 0,
    _30: u1 = 0,
    _31: u1 = 0,
};
pub const CERT_CHAIN_FIND_BY_ISSUER_COMPARE_KEY_FLAG = CERT_FIND_CHAIN_IN_STORE_FLAGS{ .COMPARE_KEY_FLAG = 1 };
pub const CERT_CHAIN_FIND_BY_ISSUER_COMPLEX_CHAIN_FLAG = CERT_FIND_CHAIN_IN_STORE_FLAGS{ .COMPLEX_CHAIN_FLAG = 1 };
pub const CERT_CHAIN_FIND_BY_ISSUER_CACHE_ONLY_FLAG = CERT_FIND_CHAIN_IN_STORE_FLAGS{ .CACHE_ONLY_FLAG = 1 };
pub const CERT_CHAIN_FIND_BY_ISSUER_CACHE_ONLY_URL_FLAG = CERT_FIND_CHAIN_IN_STORE_FLAGS{ .CACHE_ONLY_URL_FLAG = 1 };
pub const CERT_CHAIN_FIND_BY_ISSUER_LOCAL_MACHINE_FLAG = CERT_FIND_CHAIN_IN_STORE_FLAGS{ .LOCAL_MACHINE_FLAG = 1 };
pub const CERT_CHAIN_FIND_BY_ISSUER_NO_KEY_FLAG = CERT_FIND_CHAIN_IN_STORE_FLAGS{ .NO_KEY_FLAG = 1 };

pub const CERT_CONTROL_STORE_FLAGS = enum(u32) {
    COMMIT_FORCE_FLAG = 1,
    COMMIT_CLEAR_FLAG = 2,
    pub const INHIBIT_DUPLICATE_HANDLE_FLAG = .COMMIT_FORCE_FLAG;
};
pub const CERT_STORE_CTRL_COMMIT_FORCE_FLAG = CERT_CONTROL_STORE_FLAGS.COMMIT_FORCE_FLAG;
pub const CERT_STORE_CTRL_COMMIT_CLEAR_FLAG = CERT_CONTROL_STORE_FLAGS.COMMIT_CLEAR_FLAG;
pub const CERT_STORE_CTRL_INHIBIT_DUPLICATE_HANDLE_FLAG = CERT_CONTROL_STORE_FLAGS.COMMIT_FORCE_FLAG;

pub const BCRYPT_OPEN_ALGORITHM_PROVIDER_FLAGS = packed struct(u32) {
    PROV_DISPATCH: u1 = 0,
    _1: u1 = 0,
    _2: u1 = 0,
    ALG_HANDLE_HMAC_FLAG: u1 = 0,
    _4: u1 = 0,
    HASH_REUSABLE_FLAG: u1 = 0,
    _6: u1 = 0,
    _7: u1 = 0,
    _8: u1 = 0,
    _9: u1 = 0,
    _10: u1 = 0,
    _11: u1 = 0,
    _12: u1 = 0,
    _13: u1 = 0,
    _14: u1 = 0,
    _15: u1 = 0,
    _16: u1 = 0,
    _17: u1 = 0,
    _18: u1 = 0,
    _19: u1 = 0,
    _20: u1 = 0,
    _21: u1 = 0,
    _22: u1 = 0,
    _23: u1 = 0,
    _24: u1 = 0,
    _25: u1 = 0,
    _26: u1 = 0,
    _27: u1 = 0,
    _28: u1 = 0,
    _29: u1 = 0,
    _30: u1 = 0,
    _31: u1 = 0,
};
pub const BCRYPT_ALG_HANDLE_HMAC_FLAG = BCRYPT_OPEN_ALGORITHM_PROVIDER_FLAGS{ .ALG_HANDLE_HMAC_FLAG = 1 };
pub const BCRYPT_PROV_DISPATCH = BCRYPT_OPEN_ALGORITHM_PROVIDER_FLAGS{ .PROV_DISPATCH = 1 };
pub const BCRYPT_HASH_REUSABLE_FLAG = BCRYPT_OPEN_ALGORITHM_PROVIDER_FLAGS{ .HASH_REUSABLE_FLAG = 1 };

pub const CERT_STORE_SAVE_TO = enum(u32) {
    FILE = 1,
    FILENAME = 4,
    FILENAME_A = 3,
    MEMORY = 2,
    pub const FILENAME_W = .FILENAME;
};
pub const CERT_STORE_SAVE_TO_FILE = CERT_STORE_SAVE_TO.FILE;
pub const CERT_STORE_SAVE_TO_FILENAME = CERT_STORE_SAVE_TO.FILENAME;
pub const CERT_STORE_SAVE_TO_FILENAME_A = CERT_STORE_SAVE_TO.FILENAME_A;
pub const CERT_STORE_SAVE_TO_FILENAME_W = CERT_STORE_SAVE_TO.FILENAME;
pub const CERT_STORE_SAVE_TO_MEMORY = CERT_STORE_SAVE_TO.MEMORY;

pub const CRYPT_SET_PROV_PARAM_ID = enum(u32) {
    CLIENT_HWND = 1,
    DELETEKEY = 24,
    KEYEXCHANGE_ALG = 14,
    KEYEXCHANGE_PIN = 32,
    KEYEXCHANGE_KEYSIZE = 12,
    KEYSET_SEC_DESCR = 8,
    PIN_PROMPT_STRING = 44,
    ROOT_CERTSTORE = 46,
    SIGNATURE_ALG = 15,
    SIGNATURE_PIN = 33,
    SIGNATURE_KEYSIZE = 13,
    UI_PROMPT = 21,
    USE_HARDWARE_RNG = 38,
    USER_CERTSTORE = 42,
    SECURE_KEYEXCHANGE_PIN = 47,
    SECURE_SIGNATURE_PIN = 48,
    SMARTCARD_READER = 43,
};
pub const PP_CLIENT_HWND = CRYPT_SET_PROV_PARAM_ID.CLIENT_HWND;
pub const PP_DELETEKEY = CRYPT_SET_PROV_PARAM_ID.DELETEKEY;
pub const PP_KEYEXCHANGE_ALG = CRYPT_SET_PROV_PARAM_ID.KEYEXCHANGE_ALG;
pub const PP_KEYEXCHANGE_PIN = CRYPT_SET_PROV_PARAM_ID.KEYEXCHANGE_PIN;
pub const PP_KEYEXCHANGE_KEYSIZE = CRYPT_SET_PROV_PARAM_ID.KEYEXCHANGE_KEYSIZE;
pub const PP_KEYSET_SEC_DESCR = CRYPT_SET_PROV_PARAM_ID.KEYSET_SEC_DESCR;
pub const PP_PIN_PROMPT_STRING = CRYPT_SET_PROV_PARAM_ID.PIN_PROMPT_STRING;
pub const PP_ROOT_CERTSTORE = CRYPT_SET_PROV_PARAM_ID.ROOT_CERTSTORE;
pub const PP_SIGNATURE_ALG = CRYPT_SET_PROV_PARAM_ID.SIGNATURE_ALG;
pub const PP_SIGNATURE_PIN = CRYPT_SET_PROV_PARAM_ID.SIGNATURE_PIN;
pub const PP_SIGNATURE_KEYSIZE = CRYPT_SET_PROV_PARAM_ID.SIGNATURE_KEYSIZE;
pub const PP_UI_PROMPT = CRYPT_SET_PROV_PARAM_ID.UI_PROMPT;
pub const PP_USE_HARDWARE_RNG = CRYPT_SET_PROV_PARAM_ID.USE_HARDWARE_RNG;
pub const PP_USER_CERTSTORE = CRYPT_SET_PROV_PARAM_ID.USER_CERTSTORE;
pub const PP_SECURE_KEYEXCHANGE_PIN = CRYPT_SET_PROV_PARAM_ID.SECURE_KEYEXCHANGE_PIN;
pub const PP_SECURE_SIGNATURE_PIN = CRYPT_SET_PROV_PARAM_ID.SECURE_SIGNATURE_PIN;
pub const PP_SMARTCARD_READER = CRYPT_SET_PROV_PARAM_ID.SMARTCARD_READER;

pub const CRYPT_KEY_PARAM_ID = enum(u32) {
    ALGID = 7,
    CERTIFICATE = 26,
    PERMISSIONS = 6,
    SALT = 2,
    SALT_EX = 10,
    BLOCKLEN = 8,
    GET_USE_COUNT = 42,
    KEYLEN = 9,
};
pub const KP_ALGID = CRYPT_KEY_PARAM_ID.ALGID;
pub const KP_CERTIFICATE = CRYPT_KEY_PARAM_ID.CERTIFICATE;
pub const KP_PERMISSIONS = CRYPT_KEY_PARAM_ID.PERMISSIONS;
pub const KP_SALT = CRYPT_KEY_PARAM_ID.SALT;
pub const KP_SALT_EX = CRYPT_KEY_PARAM_ID.SALT_EX;
pub const KP_BLOCKLEN = CRYPT_KEY_PARAM_ID.BLOCKLEN;
pub const KP_GET_USE_COUNT = CRYPT_KEY_PARAM_ID.GET_USE_COUNT;
pub const KP_KEYLEN = CRYPT_KEY_PARAM_ID.KEYLEN;

pub const CRYPT_KEY_FLAGS = packed struct(u32) {
    CRYPT_EXPORTABLE: u1 = 0,
    CRYPT_USER_PROTECTED: u1 = 0,
    CRYPT_CREATE_SALT: u1 = 0,
    _3: u1 = 0,
    CRYPT_NO_SALT: u1 = 0,
    CRYPT_MACHINE_KEYSET: u1 = 0,
    CRYPT_INITIATOR: u1 = 0,
    CRYPT_ONLINE: u1 = 0,
    CRYPT_SF: u1 = 0,
    CRYPT_CREATE_IV: u1 = 0,
    CRYPT_KEK: u1 = 0,
    CRYPT_DATA_KEY: u1 = 0,
    CRYPT_VOLATILE: u1 = 0,
    CRYPT_SGCKEY: u1 = 0,
    CRYPT_ARCHIVABLE: u1 = 0,
    CRYPT_FORCE_KEY_PROTECTION_HIGH: u1 = 0,
    _16: u1 = 0,
    _17: u1 = 0,
    _18: u1 = 0,
    _19: u1 = 0,
    _20: u1 = 0,
    _21: u1 = 0,
    _22: u1 = 0,
    _23: u1 = 0,
    _24: u1 = 0,
    _25: u1 = 0,
    _26: u1 = 0,
    _27: u1 = 0,
    _28: u1 = 0,
    _29: u1 = 0,
    _30: u1 = 0,
    _31: u1 = 0,
    // CRYPT_PREGEN (bit index 6) conflicts with CRYPT_INITIATOR
    // CRYPT_RECIPIENT (bit index 4) conflicts with CRYPT_NO_SALT
    // CRYPT_USER_KEYSET (bit index 12) conflicts with CRYPT_VOLATILE
    // PKCS12_PREFER_CNG_KSP (bit index 8) conflicts with CRYPT_SF
    // PKCS12_ALWAYS_CNG_KSP (bit index 9) conflicts with CRYPT_CREATE_IV
    // PKCS12_ALLOW_OVERWRITE_KEY (bit index 14) conflicts with CRYPT_ARCHIVABLE
    // PKCS12_NO_PERSIST_KEY (bit index 15) conflicts with CRYPT_FORCE_KEY_PROTECTION_HIGH
    // PKCS12_INCLUDE_EXTENDED_PROPERTIES (bit index 4) conflicts with CRYPT_NO_SALT
    // CRYPT_OAEP (bit index 6) conflicts with CRYPT_INITIATOR
    // CRYPT_BLOB_VER3 (bit index 7) conflicts with CRYPT_ONLINE
    // CRYPT_DESTROYKEY (bit index 2) conflicts with CRYPT_CREATE_SALT
    // CRYPT_SSL2_FALLBACK (bit index 1) conflicts with CRYPT_USER_PROTECTED
    // CRYPT_Y_ONLY (bit index 0) conflicts with CRYPT_EXPORTABLE
    // CRYPT_IPSEC_HMAC_KEY (bit index 8) conflicts with CRYPT_SF
    // CERT_SET_KEY_PROV_HANDLE_PROP_ID (bit index 0) conflicts with CRYPT_EXPORTABLE
    // CERT_SET_KEY_CONTEXT_PROP_ID (bit index 0) conflicts with CRYPT_EXPORTABLE
};
pub const CRYPT_EXPORTABLE = CRYPT_KEY_FLAGS{ .CRYPT_EXPORTABLE = 1 };
pub const CRYPT_USER_PROTECTED = CRYPT_KEY_FLAGS{ .CRYPT_USER_PROTECTED = 1 };
pub const CRYPT_ARCHIVABLE = CRYPT_KEY_FLAGS{ .CRYPT_ARCHIVABLE = 1 };
pub const CRYPT_CREATE_IV = CRYPT_KEY_FLAGS{ .CRYPT_CREATE_IV = 1 };
pub const CRYPT_CREATE_SALT = CRYPT_KEY_FLAGS{ .CRYPT_CREATE_SALT = 1 };
pub const CRYPT_DATA_KEY = CRYPT_KEY_FLAGS{ .CRYPT_DATA_KEY = 1 };
pub const CRYPT_FORCE_KEY_PROTECTION_HIGH = CRYPT_KEY_FLAGS{ .CRYPT_FORCE_KEY_PROTECTION_HIGH = 1 };
pub const CRYPT_KEK = CRYPT_KEY_FLAGS{ .CRYPT_KEK = 1 };
pub const CRYPT_INITIATOR = CRYPT_KEY_FLAGS{ .CRYPT_INITIATOR = 1 };
pub const CRYPT_NO_SALT = CRYPT_KEY_FLAGS{ .CRYPT_NO_SALT = 1 };
pub const CRYPT_ONLINE = CRYPT_KEY_FLAGS{ .CRYPT_ONLINE = 1 };
pub const CRYPT_PREGEN = CRYPT_KEY_FLAGS{ .CRYPT_INITIATOR = 1 };
pub const CRYPT_RECIPIENT = CRYPT_KEY_FLAGS{ .CRYPT_NO_SALT = 1 };
pub const CRYPT_SF = CRYPT_KEY_FLAGS{ .CRYPT_SF = 1 };
pub const CRYPT_SGCKEY = CRYPT_KEY_FLAGS{ .CRYPT_SGCKEY = 1 };
pub const CRYPT_VOLATILE = CRYPT_KEY_FLAGS{ .CRYPT_VOLATILE = 1 };
pub const CRYPT_MACHINE_KEYSET = CRYPT_KEY_FLAGS{ .CRYPT_MACHINE_KEYSET = 1 };
pub const CRYPT_USER_KEYSET = CRYPT_KEY_FLAGS{ .CRYPT_VOLATILE = 1 };
pub const PKCS12_PREFER_CNG_KSP = CRYPT_KEY_FLAGS{ .CRYPT_SF = 1 };
pub const PKCS12_ALWAYS_CNG_KSP = CRYPT_KEY_FLAGS{ .CRYPT_CREATE_IV = 1 };
pub const PKCS12_ALLOW_OVERWRITE_KEY = CRYPT_KEY_FLAGS{ .CRYPT_ARCHIVABLE = 1 };
pub const PKCS12_NO_PERSIST_KEY = CRYPT_KEY_FLAGS{ .CRYPT_FORCE_KEY_PROTECTION_HIGH = 1 };
pub const PKCS12_INCLUDE_EXTENDED_PROPERTIES = CRYPT_KEY_FLAGS{ .CRYPT_NO_SALT = 1 };
pub const CRYPT_OAEP = CRYPT_KEY_FLAGS{ .CRYPT_INITIATOR = 1 };
pub const CRYPT_BLOB_VER3 = CRYPT_KEY_FLAGS{ .CRYPT_ONLINE = 1 };
pub const CRYPT_DESTROYKEY = CRYPT_KEY_FLAGS{ .CRYPT_CREATE_SALT = 1 };
pub const CRYPT_SSL2_FALLBACK = CRYPT_KEY_FLAGS{ .CRYPT_USER_PROTECTED = 1 };
pub const CRYPT_Y_ONLY = CRYPT_KEY_FLAGS{ .CRYPT_EXPORTABLE = 1 };
pub const CRYPT_IPSEC_HMAC_KEY = CRYPT_KEY_FLAGS{ .CRYPT_SF = 1 };
pub const CERT_SET_KEY_PROV_HANDLE_PROP_ID = CRYPT_KEY_FLAGS{ .CRYPT_EXPORTABLE = 1 };
pub const CERT_SET_KEY_CONTEXT_PROP_ID = CRYPT_KEY_FLAGS{ .CRYPT_EXPORTABLE = 1 };

pub const CRYPT_MSG_TYPE = enum(u32) {
    DATA = 1,
    SIGNED = 2,
    ENVELOPED = 3,
    SIGNED_AND_ENVELOPED = 4,
    HASHED = 5,
};
pub const CMSG_DATA = CRYPT_MSG_TYPE.DATA;
pub const CMSG_SIGNED = CRYPT_MSG_TYPE.SIGNED;
pub const CMSG_ENVELOPED = CRYPT_MSG_TYPE.ENVELOPED;
pub const CMSG_SIGNED_AND_ENVELOPED = CRYPT_MSG_TYPE.SIGNED_AND_ENVELOPED;
pub const CMSG_HASHED = CRYPT_MSG_TYPE.HASHED;

pub const CERT_OPEN_STORE_FLAGS = enum(u32) {
    BACKUP_RESTORE_FLAG = 2048,
    CREATE_NEW_FLAG = 8192,
    DEFER_CLOSE_UNTIL_LAST_FREE_FLAG = 4,
    DELETE_FLAG = 16,
    ENUM_ARCHIVED_FLAG = 512,
    MAXIMUM_ALLOWED_FLAG = 4096,
    NO_CRYPT_RELEASE_FLAG = 1,
    OPEN_EXISTING_FLAG = 16384,
    READONLY_FLAG = 32768,
    SET_LOCALIZED_NAME_FLAG = 2,
    SHARE_CONTEXT_FLAG = 128,
    UPDATE_KEYID_FLAG = 1024,
};
pub const CERT_STORE_BACKUP_RESTORE_FLAG = CERT_OPEN_STORE_FLAGS.BACKUP_RESTORE_FLAG;
pub const CERT_STORE_CREATE_NEW_FLAG = CERT_OPEN_STORE_FLAGS.CREATE_NEW_FLAG;
pub const CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG = CERT_OPEN_STORE_FLAGS.DEFER_CLOSE_UNTIL_LAST_FREE_FLAG;
pub const CERT_STORE_DELETE_FLAG = CERT_OPEN_STORE_FLAGS.DELETE_FLAG;
pub const CERT_STORE_ENUM_ARCHIVED_FLAG = CERT_OPEN_STORE_FLAGS.ENUM_ARCHIVED_FLAG;
pub const CERT_STORE_MAXIMUM_ALLOWED_FLAG = CERT_OPEN_STORE_FLAGS.MAXIMUM_ALLOWED_FLAG;
pub const CERT_STORE_NO_CRYPT_RELEASE_FLAG = CERT_OPEN_STORE_FLAGS.NO_CRYPT_RELEASE_FLAG;
pub const CERT_STORE_OPEN_EXISTING_FLAG = CERT_OPEN_STORE_FLAGS.OPEN_EXISTING_FLAG;
pub const CERT_STORE_READONLY_FLAG = CERT_OPEN_STORE_FLAGS.READONLY_FLAG;
pub const CERT_STORE_SET_LOCALIZED_NAME_FLAG = CERT_OPEN_STORE_FLAGS.SET_LOCALIZED_NAME_FLAG;
pub const CERT_STORE_SHARE_CONTEXT_FLAG = CERT_OPEN_STORE_FLAGS.SHARE_CONTEXT_FLAG;
pub const CERT_STORE_UPDATE_KEYID_FLAG = CERT_OPEN_STORE_FLAGS.UPDATE_KEYID_FLAG;

pub const CRYPT_DEFAULT_CONTEXT_FLAGS = packed struct(u32) {
    AUTO_RELEASE_FLAG: u1 = 0,
    PROCESS_FLAG: u1 = 0,
    _2: u1 = 0,
    _3: u1 = 0,
    _4: u1 = 0,
    _5: u1 = 0,
    _6: u1 = 0,
    _7: u1 = 0,
    _8: u1 = 0,
    _9: u1 = 0,
    _10: u1 = 0,
    _11: u1 = 0,
    _12: u1 = 0,
    _13: u1 = 0,
    _14: u1 = 0,
    _15: u1 = 0,
    _16: u1 = 0,
    _17: u1 = 0,
    _18: u1 = 0,
    _19: u1 = 0,
    _20: u1 = 0,
    _21: u1 = 0,
    _22: u1 = 0,
    _23: u1 = 0,
    _24: u1 = 0,
    _25: u1 = 0,
    _26: u1 = 0,
    _27: u1 = 0,
    _28: u1 = 0,
    _29: u1 = 0,
    _30: u1 = 0,
    _31: u1 = 0,
};
pub const CRYPT_DEFAULT_CONTEXT_AUTO_RELEASE_FLAG = CRYPT_DEFAULT_CONTEXT_FLAGS{ .AUTO_RELEASE_FLAG = 1 };
pub const CRYPT_DEFAULT_CONTEXT_PROCESS_FLAG = CRYPT_DEFAULT_CONTEXT_FLAGS{ .PROCESS_FLAG = 1 };

pub const CRYPT_VERIFY_CERT_FLAGS = enum(u32) {
    DISABLE_MD2_MD4_FLAG = 1,
    SET_STRONG_PROPERTIES_FLAG = 2,
    RETURN_STRONG_PROPERTIES_FLAG = 4,
};
pub const CRYPT_VERIFY_CERT_SIGN_DISABLE_MD2_MD4_FLAG = CRYPT_VERIFY_CERT_FLAGS.DISABLE_MD2_MD4_FLAG;
pub const CRYPT_VERIFY_CERT_SIGN_SET_STRONG_PROPERTIES_FLAG = CRYPT_VERIFY_CERT_FLAGS.SET_STRONG_PROPERTIES_FLAG;
pub const CRYPT_VERIFY_CERT_SIGN_RETURN_STRONG_PROPERTIES_FLAG = CRYPT_VERIFY_CERT_FLAGS.RETURN_STRONG_PROPERTIES_FLAG;

pub const CRYPT_SET_HASH_PARAM = enum(u32) {
    MAC_INFO = 5,
    ASHVAL = 2,
};
pub const HP_HMAC_INFO = CRYPT_SET_HASH_PARAM.MAC_INFO;
pub const HP_HASHVAL = CRYPT_SET_HASH_PARAM.ASHVAL;

pub const CERT_SYSTEM_STORE_FLAGS = enum(u32) {
    LOCATION_MASK = 16711680,
    RELOCATE_FLAG = 2147483648,
};
pub const CERT_SYSTEM_STORE_LOCATION_MASK = CERT_SYSTEM_STORE_FLAGS.LOCATION_MASK;
pub const CERT_SYSTEM_STORE_RELOCATE_FLAG = CERT_SYSTEM_STORE_FLAGS.RELOCATE_FLAG;

pub const CERT_CREATE_SELFSIGN_FLAGS = packed struct(u32) {
    SIGN: u1 = 0,
    KEY_INFO: u1 = 0,
    _2: u1 = 0,
    _3: u1 = 0,
    _4: u1 = 0,
    _5: u1 = 0,
    _6: u1 = 0,
    _7: u1 = 0,
    _8: u1 = 0,
    _9: u1 = 0,
    _10: u1 = 0,
    _11: u1 = 0,
    _12: u1 = 0,
    _13: u1 = 0,
    _14: u1 = 0,
    _15: u1 = 0,
    _16: u1 = 0,
    _17: u1 = 0,
    _18: u1 = 0,
    _19: u1 = 0,
    _20: u1 = 0,
    _21: u1 = 0,
    _22: u1 = 0,
    _23: u1 = 0,
    _24: u1 = 0,
    _25: u1 = 0,
    _26: u1 = 0,
    _27: u1 = 0,
    _28: u1 = 0,
    _29: u1 = 0,
    _30: u1 = 0,
    _31: u1 = 0,
};
pub const CERT_CREATE_SELFSIGN_NO_KEY_INFO = CERT_CREATE_SELFSIGN_FLAGS{ .KEY_INFO = 1 };
pub const CERT_CREATE_SELFSIGN_NO_SIGN = CERT_CREATE_SELFSIGN_FLAGS{ .SIGN = 1 };

pub const CRYPT_DEFAULT_CONTEXT_TYPE = enum(u32) {
    CERT_SIGN_OID = 1,
    MULTI_CERT_SIGN_OID = 2,
};
pub const CRYPT_DEFAULT_CONTEXT_CERT_SIGN_OID = CRYPT_DEFAULT_CONTEXT_TYPE.CERT_SIGN_OID;
pub const CRYPT_DEFAULT_CONTEXT_MULTI_CERT_SIGN_OID = CRYPT_DEFAULT_CONTEXT_TYPE.MULTI_CERT_SIGN_OID;

pub const BCRYPT_RESOLVE_PROVIDERS_FLAGS = packed struct(u32) {
    FUNCTIONS: u1 = 0,
    PROVIDERS: u1 = 0,
    _2: u1 = 0,
    _3: u1 = 0,
    _4: u1 = 0,
    _5: u1 = 0,
    _6: u1 = 0,
    _7: u1 = 0,
    _8: u1 = 0,
    _9: u1 = 0,
    _10: u1 = 0,
    _11: u1 = 0,
    _12: u1 = 0,
    _13: u1 = 0,
    _14: u1 = 0,
    _15: u1 = 0,
    _16: u1 = 0,
    _17: u1 = 0,
    _18: u1 = 0,
    _19: u1 = 0,
    _20: u1 = 0,
    _21: u1 = 0,
    _22: u1 = 0,
    _23: u1 = 0,
    _24: u1 = 0,
    _25: u1 = 0,
    _26: u1 = 0,
    _27: u1 = 0,
    _28: u1 = 0,
    _29: u1 = 0,
    _30: u1 = 0,
    _31: u1 = 0,
};
pub const CRYPT_ALL_FUNCTIONS = BCRYPT_RESOLVE_PROVIDERS_FLAGS{ .FUNCTIONS = 1 };
pub const CRYPT_ALL_PROVIDERS = BCRYPT_RESOLVE_PROVIDERS_FLAGS{ .PROVIDERS = 1 };

pub const CERT_FIND_TYPE = enum(u32) {
    ANY = 0,
    SHA1_HASH = 1,
    MD5_HASH = 2,
    USAGE = 3,
    EXISTING = 5,
    SUBJECT = 4,
    pub const SAME_USAGE_FLAG = .SHA1_HASH;
};
pub const CTL_FIND_ANY = CERT_FIND_TYPE.ANY;
pub const CTL_FIND_SHA1_HASH = CERT_FIND_TYPE.SHA1_HASH;
pub const CTL_FIND_MD5_HASH = CERT_FIND_TYPE.MD5_HASH;
pub const CTL_FIND_USAGE = CERT_FIND_TYPE.USAGE;
pub const CTL_FIND_SAME_USAGE_FLAG = CERT_FIND_TYPE.SHA1_HASH;
pub const CTL_FIND_EXISTING = CERT_FIND_TYPE.EXISTING;
pub const CTL_FIND_SUBJECT = CERT_FIND_TYPE.SUBJECT;

pub const CRYPT_FIND_FLAGS = enum(u32) {
    USER_KEYSET_FLAG = 1,
    MACHINE_KEYSET_FLAG = 2,
    SILENT_KEYSET_FLAG = 64,
};
pub const CRYPT_FIND_USER_KEYSET_FLAG = CRYPT_FIND_FLAGS.USER_KEYSET_FLAG;
pub const CRYPT_FIND_MACHINE_KEYSET_FLAG = CRYPT_FIND_FLAGS.MACHINE_KEYSET_FLAG;
pub const CRYPT_FIND_SILENT_KEYSET_FLAG = CRYPT_FIND_FLAGS.SILENT_KEYSET_FLAG;

pub const CRYPT_IMAGE_REF_FLAGS = packed struct(u32) {
    MIN_DEPENDENCIES: u1 = 0,
    _1: u1 = 0,
    _2: u1 = 0,
    _3: u1 = 0,
    _4: u1 = 0,
    _5: u1 = 0,
    _6: u1 = 0,
    _7: u1 = 0,
    _8: u1 = 0,
    _9: u1 = 0,
    _10: u1 = 0,
    _11: u1 = 0,
    _12: u1 = 0,
    _13: u1 = 0,
    _14: u1 = 0,
    _15: u1 = 0,
    PROCESS_ISOLATE: u1 = 0,
    _17: u1 = 0,
    _18: u1 = 0,
    _19: u1 = 0,
    _20: u1 = 0,
    _21: u1 = 0,
    _22: u1 = 0,
    _23: u1 = 0,
    _24: u1 = 0,
    _25: u1 = 0,
    _26: u1 = 0,
    _27: u1 = 0,
    _28: u1 = 0,
    _29: u1 = 0,
    _30: u1 = 0,
    _31: u1 = 0,
};
pub const CRYPT_MIN_DEPENDENCIES = CRYPT_IMAGE_REF_FLAGS{ .MIN_DEPENDENCIES = 1 };
pub const CRYPT_PROCESS_ISOLATE = CRYPT_IMAGE_REF_FLAGS{ .PROCESS_ISOLATE = 1 };

pub const CERT_REVOCATION_STATUS_REASON = enum(u32) {
    UNSPECIFIED = 0,
    KEY_COMPROMISE = 1,
    CA_COMPROMISE = 2,
    AFFILIATION_CHANGED = 3,
    SUPERSEDED = 4,
    CESSATION_OF_OPERATION = 5,
    CERTIFICATE_HOLD = 6,
    REMOVE_FROM_CRL = 8,
};
pub const CRL_REASON_UNSPECIFIED = CERT_REVOCATION_STATUS_REASON.UNSPECIFIED;
pub const CRL_REASON_KEY_COMPROMISE = CERT_REVOCATION_STATUS_REASON.KEY_COMPROMISE;
pub const CRL_REASON_CA_COMPROMISE = CERT_REVOCATION_STATUS_REASON.CA_COMPROMISE;
pub const CRL_REASON_AFFILIATION_CHANGED = CERT_REVOCATION_STATUS_REASON.AFFILIATION_CHANGED;
pub const CRL_REASON_SUPERSEDED = CERT_REVOCATION_STATUS_REASON.SUPERSEDED;
pub const CRL_REASON_CESSATION_OF_OPERATION = CERT_REVOCATION_STATUS_REASON.CESSATION_OF_OPERATION;
pub const CRL_REASON_CERTIFICATE_HOLD = CERT_REVOCATION_STATUS_REASON.CERTIFICATE_HOLD;
pub const CRL_REASON_REMOVE_FROM_CRL = CERT_REVOCATION_STATUS_REASON.REMOVE_FROM_CRL;

pub const CERT_ROOT_PROGRAM_FLAGS = packed struct(u32) {
    _0: u1 = 0,
    _1: u1 = 0,
    _2: u1 = 0,
    _3: u1 = 0,
    _4: u1 = 0,
    SUBJECT_LOGO: u1 = 0,
    LSC: u1 = 0,
    ORG: u1 = 0,
    _8: u1 = 0,
    _9: u1 = 0,
    _10: u1 = 0,
    _11: u1 = 0,
    _12: u1 = 0,
    _13: u1 = 0,
    _14: u1 = 0,
    _15: u1 = 0,
    _16: u1 = 0,
    _17: u1 = 0,
    _18: u1 = 0,
    _19: u1 = 0,
    _20: u1 = 0,
    _21: u1 = 0,
    _22: u1 = 0,
    _23: u1 = 0,
    _24: u1 = 0,
    _25: u1 = 0,
    _26: u1 = 0,
    _27: u1 = 0,
    _28: u1 = 0,
    _29: u1 = 0,
    _30: u1 = 0,
    _31: u1 = 0,
};
pub const CERT_ROOT_PROGRAM_FLAG_LSC = CERT_ROOT_PROGRAM_FLAGS{ .LSC = 1 };
pub const CERT_ROOT_PROGRAM_FLAG_ORG = CERT_ROOT_PROGRAM_FLAGS{ .ORG = 1 };
pub const CERT_ROOT_PROGRAM_FLAG_SUBJECT_LOGO = CERT_ROOT_PROGRAM_FLAGS{ .SUBJECT_LOGO = 1 };

pub const CRYPT_XML_KEY_VALUE_TYPE = enum(u32) {
    DSA = 1,
    RSA = 2,
    ECDSA = 3,
    CUSTOM = 4,
};
pub const CRYPT_XML_KEY_VALUE_TYPE_DSA = CRYPT_XML_KEY_VALUE_TYPE.DSA;
pub const CRYPT_XML_KEY_VALUE_TYPE_RSA = CRYPT_XML_KEY_VALUE_TYPE.RSA;
pub const CRYPT_XML_KEY_VALUE_TYPE_ECDSA = CRYPT_XML_KEY_VALUE_TYPE.ECDSA;
pub const CRYPT_XML_KEY_VALUE_TYPE_CUSTOM = CRYPT_XML_KEY_VALUE_TYPE.CUSTOM;

pub const CERT_LOGOTYPE_CHOICE = enum(u32) {
    NO_IMAGE_RESOLUTION_CHOICE = 0,
    BITS_IMAGE_RESOLUTION_CHOICE = 1,
    TABLE_SIZE_IMAGE_RESOLUTION_CHOICE = 2,
};
pub const CERT_LOGOTYPE_NO_IMAGE_RESOLUTION_CHOICE = CERT_LOGOTYPE_CHOICE.NO_IMAGE_RESOLUTION_CHOICE;
pub const CERT_LOGOTYPE_BITS_IMAGE_RESOLUTION_CHOICE = CERT_LOGOTYPE_CHOICE.BITS_IMAGE_RESOLUTION_CHOICE;
pub const CERT_LOGOTYPE_TABLE_SIZE_IMAGE_RESOLUTION_CHOICE = CERT_LOGOTYPE_CHOICE.TABLE_SIZE_IMAGE_RESOLUTION_CHOICE;

pub const CMSG_KEY_AGREE_OPTION = enum(u32) {
    EPHEMERAL_KEY_CHOICE = 1,
    STATIC_KEY_CHOICE = 2,
};
pub const CMSG_KEY_AGREE_EPHEMERAL_KEY_CHOICE = CMSG_KEY_AGREE_OPTION.EPHEMERAL_KEY_CHOICE;
pub const CMSG_KEY_AGREE_STATIC_KEY_CHOICE = CMSG_KEY_AGREE_OPTION.STATIC_KEY_CHOICE;

pub const CERT_LOGOTYPE_OPTION = enum(u32) {
    DIRECT_INFO_CHOICE = 1,
    INDIRECT_INFO_CHOICE = 2,
};
pub const CERT_LOGOTYPE_DIRECT_INFO_CHOICE = CERT_LOGOTYPE_OPTION.DIRECT_INFO_CHOICE;
pub const CERT_LOGOTYPE_INDIRECT_INFO_CHOICE = CERT_LOGOTYPE_OPTION.INDIRECT_INFO_CHOICE;

pub const CERT_STORE_PROV_FLAGS = packed struct(u32) {
    EXTERNAL_FLAG: u1 = 0,
    DELETED_FLAG: u1 = 0,
    NO_PERSIST_FLAG: u1 = 0,
    SYSTEM_STORE_FLAG: u1 = 0,
    LM_SYSTEM_STORE_FLAG: u1 = 0,
    _5: u1 = 0,
    _6: u1 = 0,
    _7: u1 = 0,
    _8: u1 = 0,
    _9: u1 = 0,
    _10: u1 = 0,
    _11: u1 = 0,
    _12: u1 = 0,
    _13: u1 = 0,
    _14: u1 = 0,
    _15: u1 = 0,
    _16: u1 = 0,
    _17: u1 = 0,
    _18: u1 = 0,
    _19: u1 = 0,
    _20: u1 = 0,
    _21: u1 = 0,
    _22: u1 = 0,
    _23: u1 = 0,
    _24: u1 = 0,
    _25: u1 = 0,
    _26: u1 = 0,
    _27: u1 = 0,
    _28: u1 = 0,
    _29: u1 = 0,
    _30: u1 = 0,
    _31: u1 = 0,
};
pub const CERT_STORE_PROV_EXTERNAL_FLAG = CERT_STORE_PROV_FLAGS{ .EXTERNAL_FLAG = 1 };
pub const CERT_STORE_PROV_DELETED_FLAG = CERT_STORE_PROV_FLAGS{ .DELETED_FLAG = 1 };
pub const CERT_STORE_PROV_NO_PERSIST_FLAG = CERT_STORE_PROV_FLAGS{ .NO_PERSIST_FLAG = 1 };
pub const CERT_STORE_PROV_SYSTEM_STORE_FLAG = CERT_STORE_PROV_FLAGS{ .SYSTEM_STORE_FLAG = 1 };
pub const CERT_STORE_PROV_LM_SYSTEM_STORE_FLAG = CERT_STORE_PROV_FLAGS{ .LM_SYSTEM_STORE_FLAG = 1 };

pub const CMSG_KEY_AGREE_ORIGINATOR = enum(u32) {
    CERT = 1,
    PUBLIC_KEY = 2,
};
pub const CMSG_KEY_AGREE_ORIGINATOR_CERT = CMSG_KEY_AGREE_ORIGINATOR.CERT;
pub const CMSG_KEY_AGREE_ORIGINATOR_PUBLIC_KEY = CMSG_KEY_AGREE_ORIGINATOR.PUBLIC_KEY;

pub const CRYPT_CONTEXT_CONFIG_FLAGS = packed struct(u32) {
    EXCLUSIVE: u1 = 0,
    _1: u1 = 0,
    _2: u1 = 0,
    _3: u1 = 0,
    _4: u1 = 0,
    _5: u1 = 0,
    _6: u1 = 0,
    _7: u1 = 0,
    _8: u1 = 0,
    _9: u1 = 0,
    _10: u1 = 0,
    _11: u1 = 0,
    _12: u1 = 0,
    _13: u1 = 0,
    _14: u1 = 0,
    _15: u1 = 0,
    OVERRIDE: u1 = 0,
    _17: u1 = 0,
    _18: u1 = 0,
    _19: u1 = 0,
    _20: u1 = 0,
    _21: u1 = 0,
    _22: u1 = 0,
    _23: u1 = 0,
    _24: u1 = 0,
    _25: u1 = 0,
    _26: u1 = 0,
    _27: u1 = 0,
    _28: u1 = 0,
    _29: u1 = 0,
    _30: u1 = 0,
    _31: u1 = 0,
};
pub const CRYPT_EXCLUSIVE = CRYPT_CONTEXT_CONFIG_FLAGS{ .EXCLUSIVE = 1 };
pub const CRYPT_OVERRIDE = CRYPT_CONTEXT_CONFIG_FLAGS{ .OVERRIDE = 1 };

pub const BCRYPT_DSA_MAGIC = enum(u32) {
    UBLIC_MAGIC = 1112560452,
    RIVATE_MAGIC = 1448104772,
};
pub const BCRYPT_DSA_PUBLIC_MAGIC = BCRYPT_DSA_MAGIC.UBLIC_MAGIC;
pub const BCRYPT_DSA_PRIVATE_MAGIC = BCRYPT_DSA_MAGIC.RIVATE_MAGIC;

pub const CRYPT_XML_X509DATA_TYPE = enum(u32) {
    ISSUER_SERIAL = 1,
    SKI = 2,
    SUBJECT_NAME = 3,
    CERTIFICATE = 4,
    CRL = 5,
    CUSTOM = 6,
};
pub const CRYPT_XML_X509DATA_TYPE_ISSUER_SERIAL = CRYPT_XML_X509DATA_TYPE.ISSUER_SERIAL;
pub const CRYPT_XML_X509DATA_TYPE_SKI = CRYPT_XML_X509DATA_TYPE.SKI;
pub const CRYPT_XML_X509DATA_TYPE_SUBJECT_NAME = CRYPT_XML_X509DATA_TYPE.SUBJECT_NAME;
pub const CRYPT_XML_X509DATA_TYPE_CERTIFICATE = CRYPT_XML_X509DATA_TYPE.CERTIFICATE;
pub const CRYPT_XML_X509DATA_TYPE_CRL = CRYPT_XML_X509DATA_TYPE.CRL;
pub const CRYPT_XML_X509DATA_TYPE_CUSTOM = CRYPT_XML_X509DATA_TYPE.CUSTOM;

pub const CERT_BIOMETRIC_DATA_TYPE = enum(u32) {
    PREDEFINED_DATA_CHOICE = 1,
    OID_DATA_CHOICE = 2,
};
pub const CERT_BIOMETRIC_PREDEFINED_DATA_CHOICE = CERT_BIOMETRIC_DATA_TYPE.PREDEFINED_DATA_CHOICE;
pub const CERT_BIOMETRIC_OID_DATA_CHOICE = CERT_BIOMETRIC_DATA_TYPE.OID_DATA_CHOICE;

pub const CERT_CHAIN_POLICY_FLAGS = enum(u32) {
    IGNORE_NOT_TIME_VALID_FLAG = 1,
    IGNORE_CTL_NOT_TIME_VALID_FLAG = 2,
    IGNORE_NOT_TIME_NESTED_FLAG = 4,
    IGNORE_ALL_NOT_TIME_VALID_FLAGS = 7,
    IGNORE_INVALID_BASIC_CONSTRAINTS_FLAG = 8,
    ALLOW_UNKNOWN_CA_FLAG = 16,
    IGNORE_WRONG_USAGE_FLAG = 32,
    IGNORE_INVALID_NAME_FLAG = 64,
    IGNORE_INVALID_POLICY_FLAG = 128,
    IGNORE_END_REV_UNKNOWN_FLAG = 256,
    IGNORE_CTL_SIGNER_REV_UNKNOWN_FLAG = 512,
    IGNORE_CA_REV_UNKNOWN_FLAG = 1024,
    IGNORE_ROOT_REV_UNKNOWN_FLAG = 2048,
    IGNORE_ALL_REV_UNKNOWN_FLAGS = 3840,
    ALLOW_TESTROOT_FLAG = 32768,
    TRUST_TESTROOT_FLAG = 16384,
    IGNORE_NOT_SUPPORTED_CRITICAL_EXT_FLAG = 8192,
    IGNORE_PEER_TRUST_FLAG = 4096,
};
pub const CERT_CHAIN_POLICY_IGNORE_NOT_TIME_VALID_FLAG = CERT_CHAIN_POLICY_FLAGS.IGNORE_NOT_TIME_VALID_FLAG;
pub const CERT_CHAIN_POLICY_IGNORE_CTL_NOT_TIME_VALID_FLAG = CERT_CHAIN_POLICY_FLAGS.IGNORE_CTL_NOT_TIME_VALID_FLAG;
pub const CERT_CHAIN_POLICY_IGNORE_NOT_TIME_NESTED_FLAG = CERT_CHAIN_POLICY_FLAGS.IGNORE_NOT_TIME_NESTED_FLAG;
pub const CERT_CHAIN_POLICY_IGNORE_ALL_NOT_TIME_VALID_FLAGS = CERT_CHAIN_POLICY_FLAGS.IGNORE_ALL_NOT_TIME_VALID_FLAGS;
pub const CERT_CHAIN_POLICY_IGNORE_INVALID_BASIC_CONSTRAINTS_FLAG = CERT_CHAIN_POLICY_FLAGS.IGNORE_INVALID_BASIC_CONSTRAINTS_FLAG;
pub const CERT_CHAIN_POLICY_ALLOW_UNKNOWN_CA_FLAG = CERT_CHAIN_POLICY_FLAGS.ALLOW_UNKNOWN_CA_FLAG;
pub const CERT_CHAIN_POLICY_IGNORE_WRONG_USAGE_FLAG = CERT_CHAIN_POLICY_FLAGS.IGNORE_WRONG_USAGE_FLAG;
pub const CERT_CHAIN_POLICY_IGNORE_INVALID_NAME_FLAG = CERT_CHAIN_POLICY_FLAGS.IGNORE_INVALID_NAME_FLAG;
pub const CERT_CHAIN_POLICY_IGNORE_INVALID_POLICY_FLAG = CERT_CHAIN_POLICY_FLAGS.IGNORE_INVALID_POLICY_FLAG;
pub const CERT_CHAIN_POLICY_IGNORE_END_REV_UNKNOWN_FLAG = CERT_CHAIN_POLICY_FLAGS.IGNORE_END_REV_UNKNOWN_FLAG;
pub const CERT_CHAIN_POLICY_IGNORE_CTL_SIGNER_REV_UNKNOWN_FLAG = CERT_CHAIN_POLICY_FLAGS.IGNORE_CTL_SIGNER_REV_UNKNOWN_FLAG;
pub const CERT_CHAIN_POLICY_IGNORE_CA_REV_UNKNOWN_FLAG = CERT_CHAIN_POLICY_FLAGS.IGNORE_CA_REV_UNKNOWN_FLAG;
pub const CERT_CHAIN_POLICY_IGNORE_ROOT_REV_UNKNOWN_FLAG = CERT_CHAIN_POLICY_FLAGS.IGNORE_ROOT_REV_UNKNOWN_FLAG;
pub const CERT_CHAIN_POLICY_IGNORE_ALL_REV_UNKNOWN_FLAGS = CERT_CHAIN_POLICY_FLAGS.IGNORE_ALL_REV_UNKNOWN_FLAGS;
pub const CERT_CHAIN_POLICY_ALLOW_TESTROOT_FLAG = CERT_CHAIN_POLICY_FLAGS.ALLOW_TESTROOT_FLAG;
pub const CERT_CHAIN_POLICY_TRUST_TESTROOT_FLAG = CERT_CHAIN_POLICY_FLAGS.TRUST_TESTROOT_FLAG;
pub const CERT_CHAIN_POLICY_IGNORE_NOT_SUPPORTED_CRITICAL_EXT_FLAG = CERT_CHAIN_POLICY_FLAGS.IGNORE_NOT_SUPPORTED_CRITICAL_EXT_FLAG;
pub const CERT_CHAIN_POLICY_IGNORE_PEER_TRUST_FLAG = CERT_CHAIN_POLICY_FLAGS.IGNORE_PEER_TRUST_FLAG;

pub const CERT_STRONG_SIGN_FLAGS = packed struct(u32) {
    CRL_CHECK: u1 = 0,
    OCSP_CHECK: u1 = 0,
    _2: u1 = 0,
    _3: u1 = 0,
    _4: u1 = 0,
    _5: u1 = 0,
    _6: u1 = 0,
    _7: u1 = 0,
    _8: u1 = 0,
    _9: u1 = 0,
    _10: u1 = 0,
    _11: u1 = 0,
    _12: u1 = 0,
    _13: u1 = 0,
    _14: u1 = 0,
    _15: u1 = 0,
    _16: u1 = 0,
    _17: u1 = 0,
    _18: u1 = 0,
    _19: u1 = 0,
    _20: u1 = 0,
    _21: u1 = 0,
    _22: u1 = 0,
    _23: u1 = 0,
    _24: u1 = 0,
    _25: u1 = 0,
    _26: u1 = 0,
    _27: u1 = 0,
    _28: u1 = 0,
    _29: u1 = 0,
    _30: u1 = 0,
    _31: u1 = 0,
};
pub const CERT_STRONG_SIGN_ENABLE_CRL_CHECK = CERT_STRONG_SIGN_FLAGS{ .CRL_CHECK = 1 };
pub const CERT_STRONG_SIGN_ENABLE_OCSP_CHECK = CERT_STRONG_SIGN_FLAGS{ .OCSP_CHECK = 1 };

pub const CERT_LOGOTYPE_IMAGE_INFO_TYPE = enum(u32) {
    GRAY_SCALE_IMAGE_INFO_CHOICE = 1,
    COLOR_IMAGE_INFO_CHOICE = 2,
};
pub const CERT_LOGOTYPE_GRAY_SCALE_IMAGE_INFO_CHOICE = CERT_LOGOTYPE_IMAGE_INFO_TYPE.GRAY_SCALE_IMAGE_INFO_CHOICE;
pub const CERT_LOGOTYPE_COLOR_IMAGE_INFO_CHOICE = CERT_LOGOTYPE_IMAGE_INFO_TYPE.COLOR_IMAGE_INFO_CHOICE;

pub const CRYPT_XML_STATUS_INFO_STATUS = enum(u32) {
    INTERNAL_REFERENCE = 1,
    KEY_AVAILABLE = 2,
    DIGESTING = 4,
    DIGEST_VALID = 8,
    SIGNATURE_VALID = 65536,
    OPENED_TO_ENCODE = 2147483648,
};
pub const CRYPT_XML_STATUS_INTERNAL_REFERENCE = CRYPT_XML_STATUS_INFO_STATUS.INTERNAL_REFERENCE;
pub const CRYPT_XML_STATUS_KEY_AVAILABLE = CRYPT_XML_STATUS_INFO_STATUS.KEY_AVAILABLE;
pub const CRYPT_XML_STATUS_DIGESTING = CRYPT_XML_STATUS_INFO_STATUS.DIGESTING;
pub const CRYPT_XML_STATUS_DIGEST_VALID = CRYPT_XML_STATUS_INFO_STATUS.DIGEST_VALID;
pub const CRYPT_XML_STATUS_SIGNATURE_VALID = CRYPT_XML_STATUS_INFO_STATUS.SIGNATURE_VALID;
pub const CRYPT_XML_STATUS_OPENED_TO_ENCODE = CRYPT_XML_STATUS_INFO_STATUS.OPENED_TO_ENCODE;

pub const CRYPT_XML_TRANSFORM_FLAGS = packed struct(u32) {
    ON_STREAM: u1 = 0,
    ON_NODESET: u1 = 0,
    _2: u1 = 0,
    _3: u1 = 0,
    _4: u1 = 0,
    _5: u1 = 0,
    _6: u1 = 0,
    _7: u1 = 0,
    _8: u1 = 0,
    _9: u1 = 0,
    _10: u1 = 0,
    _11: u1 = 0,
    _12: u1 = 0,
    _13: u1 = 0,
    _14: u1 = 0,
    _15: u1 = 0,
    _16: u1 = 0,
    _17: u1 = 0,
    _18: u1 = 0,
    _19: u1 = 0,
    _20: u1 = 0,
    _21: u1 = 0,
    _22: u1 = 0,
    _23: u1 = 0,
    _24: u1 = 0,
    _25: u1 = 0,
    _26: u1 = 0,
    _27: u1 = 0,
    _28: u1 = 0,
    _29: u1 = 0,
    _30: u1 = 0,
    _31: u1 = 0,
};
pub const CRYPT_XML_TRANSFORM_ON_STREAM = CRYPT_XML_TRANSFORM_FLAGS{ .ON_STREAM = 1 };
pub const CRYPT_XML_TRANSFORM_ON_NODESET = CRYPT_XML_TRANSFORM_FLAGS{ .ON_NODESET = 1 };
pub const CRYPT_XML_TRANSFORM_URI_QUERY_STRING = CRYPT_XML_TRANSFORM_FLAGS{
    .ON_STREAM = 1,
    .ON_NODESET = 1,
};

pub const CRYPT_XML_GROUP_ID = enum(u32) {
    HASH = 1,
    SIGN = 2,
};
pub const CRYPT_XML_GROUP_ID_HASH = CRYPT_XML_GROUP_ID.HASH;
pub const CRYPT_XML_GROUP_ID_SIGN = CRYPT_XML_GROUP_ID.SIGN;

pub const CERT_SELECT_CRITERIA_TYPE = enum(u32) {
    ENHKEY_USAGE = 1,
    KEY_USAGE = 2,
    POLICY_OID = 3,
    PROV_NAME = 4,
    EXTENSION = 5,
    SUBJECT_HOST_NAME = 6,
    ISSUER_ATTR = 7,
    SUBJECT_ATTR = 8,
    ISSUER_NAME = 9,
    PUBLIC_KEY = 10,
    TLS_SIGNATURES = 11,
};
pub const CERT_SELECT_BY_ENHKEY_USAGE = CERT_SELECT_CRITERIA_TYPE.ENHKEY_USAGE;
pub const CERT_SELECT_BY_KEY_USAGE = CERT_SELECT_CRITERIA_TYPE.KEY_USAGE;
pub const CERT_SELECT_BY_POLICY_OID = CERT_SELECT_CRITERIA_TYPE.POLICY_OID;
pub const CERT_SELECT_BY_PROV_NAME = CERT_SELECT_CRITERIA_TYPE.PROV_NAME;
pub const CERT_SELECT_BY_EXTENSION = CERT_SELECT_CRITERIA_TYPE.EXTENSION;
pub const CERT_SELECT_BY_SUBJECT_HOST_NAME = CERT_SELECT_CRITERIA_TYPE.SUBJECT_HOST_NAME;
pub const CERT_SELECT_BY_ISSUER_ATTR = CERT_SELECT_CRITERIA_TYPE.ISSUER_ATTR;
pub const CERT_SELECT_BY_SUBJECT_ATTR = CERT_SELECT_CRITERIA_TYPE.SUBJECT_ATTR;
pub const CERT_SELECT_BY_ISSUER_NAME = CERT_SELECT_CRITERIA_TYPE.ISSUER_NAME;
pub const CERT_SELECT_BY_PUBLIC_KEY = CERT_SELECT_CRITERIA_TYPE.PUBLIC_KEY;
pub const CERT_SELECT_BY_TLS_SIGNATURES = CERT_SELECT_CRITERIA_TYPE.TLS_SIGNATURES;

pub const BCRYPT_RSAKEY_BLOB_MAGIC = enum(u32) {
    PUBLIC_MAGIC = 826364754,
    PRIVATE_MAGIC = 843141970,
    FULLPRIVATE_MAGIC = 859919186,
};
pub const BCRYPT_RSAPUBLIC_MAGIC = BCRYPT_RSAKEY_BLOB_MAGIC.PUBLIC_MAGIC;
pub const BCRYPT_RSAPRIVATE_MAGIC = BCRYPT_RSAKEY_BLOB_MAGIC.PRIVATE_MAGIC;
pub const BCRYPT_RSAFULLPRIVATE_MAGIC = BCRYPT_RSAKEY_BLOB_MAGIC.FULLPRIVATE_MAGIC;

pub const CRYPT_XML_KEYINFO_TYPE = enum(u32) {
    KEYNAME = 1,
    KEYVALUE = 2,
    RETRIEVAL = 3,
    X509DATA = 4,
    CUSTOM = 5,
};
pub const CRYPT_XML_KEYINFO_TYPE_KEYNAME = CRYPT_XML_KEYINFO_TYPE.KEYNAME;
pub const CRYPT_XML_KEYINFO_TYPE_KEYVALUE = CRYPT_XML_KEYINFO_TYPE.KEYVALUE;
pub const CRYPT_XML_KEYINFO_TYPE_RETRIEVAL = CRYPT_XML_KEYINFO_TYPE.RETRIEVAL;
pub const CRYPT_XML_KEYINFO_TYPE_X509DATA = CRYPT_XML_KEYINFO_TYPE.X509DATA;
pub const CRYPT_XML_KEYINFO_TYPE_CUSTOM = CRYPT_XML_KEYINFO_TYPE.CUSTOM;

pub const CRYPT_TIMESTAMP_VERSION = enum(u32) {
    N = 1,
};
pub const TIMESTAMP_VERSION = CRYPT_TIMESTAMP_VERSION.N;

pub const CERT_ID_OPTION = enum(u32) {
    ISSUER_SERIAL_NUMBER = 1,
    KEY_IDENTIFIER = 2,
    SHA1_HASH = 3,
};
pub const CERT_ID_ISSUER_SERIAL_NUMBER = CERT_ID_OPTION.ISSUER_SERIAL_NUMBER;
pub const CERT_ID_KEY_IDENTIFIER = CERT_ID_OPTION.KEY_IDENTIFIER;
pub const CERT_ID_SHA1_HASH = CERT_ID_OPTION.SHA1_HASH;

pub const HTTPSPOLICY_CALLBACK_DATA_AUTH_TYPE = enum(u32) {
    CLIENT = 1,
    SERVER = 2,
};
pub const AUTHTYPE_CLIENT = HTTPSPOLICY_CALLBACK_DATA_AUTH_TYPE.CLIENT;
pub const AUTHTYPE_SERVER = HTTPSPOLICY_CALLBACK_DATA_AUTH_TYPE.SERVER;

pub const BCRYPT_DH_KEY_BLOB_MAGIC = enum(u32) {
    UBLIC_MAGIC = 1112557636,
    RIVATE_MAGIC = 1448101956,
};
pub const BCRYPT_DH_PUBLIC_MAGIC = BCRYPT_DH_KEY_BLOB_MAGIC.UBLIC_MAGIC;
pub const BCRYPT_DH_PRIVATE_MAGIC = BCRYPT_DH_KEY_BLOB_MAGIC.RIVATE_MAGIC;

pub const CRYPT_XML_STATUS_ERROR_STATUS = enum(u32) {
    NOT_RESOLVED = 1,
    DIGEST_INVALID = 2,
    NOT_SUPPORTED_ALGORITHM = 5,
    NOT_SUPPORTED_TRANSFORM = 8,
    SIGNATURE_INVALID = 65536,
    KEYINFO_NOT_PARSED = 131072,
};
pub const CRYPT_XML_STATUS_ERROR_NOT_RESOLVED = CRYPT_XML_STATUS_ERROR_STATUS.NOT_RESOLVED;
pub const CRYPT_XML_STATUS_ERROR_DIGEST_INVALID = CRYPT_XML_STATUS_ERROR_STATUS.DIGEST_INVALID;
pub const CRYPT_XML_STATUS_ERROR_NOT_SUPPORTED_ALGORITHM = CRYPT_XML_STATUS_ERROR_STATUS.NOT_SUPPORTED_ALGORITHM;
pub const CRYPT_XML_STATUS_ERROR_NOT_SUPPORTED_TRANSFORM = CRYPT_XML_STATUS_ERROR_STATUS.NOT_SUPPORTED_TRANSFORM;
pub const CRYPT_XML_STATUS_ERROR_SIGNATURE_INVALID = CRYPT_XML_STATUS_ERROR_STATUS.SIGNATURE_INVALID;
pub const CRYPT_XML_STATUS_ERROR_KEYINFO_NOT_PARSED = CRYPT_XML_STATUS_ERROR_STATUS.KEYINFO_NOT_PARSED;

pub const CRYPT_TIMESTAMP_RESPONSE_STATUS = enum(u32) {
    GRANTED = 0,
    GRANTED_WITH_MODS = 1,
    REJECTED = 2,
    WAITING = 3,
    REVOCATION_WARNING = 4,
    REVOKED = 5,
};
pub const TIMESTAMP_STATUS_GRANTED = CRYPT_TIMESTAMP_RESPONSE_STATUS.GRANTED;
pub const TIMESTAMP_STATUS_GRANTED_WITH_MODS = CRYPT_TIMESTAMP_RESPONSE_STATUS.GRANTED_WITH_MODS;
pub const TIMESTAMP_STATUS_REJECTED = CRYPT_TIMESTAMP_RESPONSE_STATUS.REJECTED;
pub const TIMESTAMP_STATUS_WAITING = CRYPT_TIMESTAMP_RESPONSE_STATUS.WAITING;
pub const TIMESTAMP_STATUS_REVOCATION_WARNING = CRYPT_TIMESTAMP_RESPONSE_STATUS.REVOCATION_WARNING;
pub const TIMESTAMP_STATUS_REVOKED = CRYPT_TIMESTAMP_RESPONSE_STATUS.REVOKED;

pub const NCRYPT_ALGORITHM_NAME_CLASS = enum(u32) {
    ASYMMETRIC_ENCRYPTION_INTERFACE = 3,
    SECRET_AGREEMENT_INTERFACE = 4,
    SIGNATURE_INTERFACE = 5,
};
pub const NCRYPT_ASYMMETRIC_ENCRYPTION_INTERFACE = NCRYPT_ALGORITHM_NAME_CLASS.ASYMMETRIC_ENCRYPTION_INTERFACE;
pub const NCRYPT_SECRET_AGREEMENT_INTERFACE = NCRYPT_ALGORITHM_NAME_CLASS.SECRET_AGREEMENT_INTERFACE;
pub const NCRYPT_SIGNATURE_INTERFACE = NCRYPT_ALGORITHM_NAME_CLASS.SIGNATURE_INTERFACE;

// TODO: this type has a FreeFunc 'CryptCloseAsyncHandle', what can Zig do with this information?
// TODO: this type has an InvalidHandleValue of '0', what can Zig do with this information?
pub const HCRYPTASYNC = *opaque{};

// TODO: this type has a FreeFunc 'CertFreeCertificateChainEngine', what can Zig do with this information?
// TODO: this type has an InvalidHandleValue of '0', what can Zig do with this information?
pub const HCERTCHAINENGINE = *opaque{};

// TODO: this type has a FreeFunc 'BCryptCloseAlgorithmProvider', what can Zig do with this information?
// TODO: this type has an InvalidHandleValue of '0', what can Zig do with this information?
//TODO: type 'BCRYPT_ALG_HANDLE' is "AlsoUsableFor" 'BCRYPT_HANDLE' which means this type is implicitly
//      convertible to 'BCRYPT_HANDLE' but not the other way around.  I don't know how to do this
//      in Zig so for now I'm just defining it as an alias
pub const BCRYPT_ALG_HANDLE = BCRYPT_HANDLE;

// TODO: this type has a FreeFunc 'BCryptDestroyKey', what can Zig do with this information?
// TODO: this type has an InvalidHandleValue of '0', what can Zig do with this information?
//TODO: type 'BCRYPT_KEY_HANDLE' is "AlsoUsableFor" 'BCRYPT_HANDLE' which means this type is implicitly
//      convertible to 'BCRYPT_HANDLE' but not the other way around.  I don't know how to do this
//      in Zig so for now I'm just defining it as an alias
pub const BCRYPT_KEY_HANDLE = BCRYPT_HANDLE;

// TODO: this type has a FreeFunc 'BCryptDestroyHash', what can Zig do with this information?
// TODO: this type has an InvalidHandleValue of '0', what can Zig do with this information?
//TODO: type 'BCRYPT_HASH_HANDLE' is "AlsoUsableFor" 'BCRYPT_HANDLE' which means this type is implicitly
//      convertible to 'BCRYPT_HANDLE' but not the other way around.  I don't know how to do this
//      in Zig so for now I'm just defining it as an alias
pub const BCRYPT_HASH_HANDLE = BCRYPT_HANDLE;

// TODO: this type has a FreeFunc 'BCryptDestroySecret', what can Zig do with this information?
// TODO: this type has an InvalidHandleValue of '0', what can Zig do with this information?
//TODO: type 'BCRYPT_SECRET_HANDLE' is "AlsoUsableFor" 'BCRYPT_HANDLE' which means this type is implicitly
//      convertible to 'BCRYPT_HANDLE' but not the other way around.  I don't know how to do this
//      in Zig so for now I'm just defining it as an alias
pub const BCRYPT_SECRET_HANDLE = BCRYPT_HANDLE;

// TODO: this type has an InvalidHandleValue of '0', what can Zig do with this information?
pub const BCRYPT_HANDLE = isize;

// TODO: this type has an InvalidHandleValue of '0', what can Zig do with this information?
pub const NCRYPT_HANDLE = usize;

// TODO: this type has a FreeFunc 'NCryptFreeObject', what can Zig do with this information?
// TODO: this type has an InvalidHandleValue of '0', what can Zig do with this information?
pub const NCRYPT_PROV_HANDLE = usize;

// TODO: this type has a FreeFunc 'NCryptFreeObject', what can Zig do with this information?
// TODO: this type has an InvalidHandleValue of '0', what can Zig do with this information?
pub const NCRYPT_KEY_HANDLE = usize;

// TODO: this type has an InvalidHandleValue of '0', what can Zig do with this information?
pub const NCRYPT_HASH_HANDLE = usize;

// TODO: this type has an InvalidHandleValue of '0', what can Zig do with this information?
pub const NCRYPT_SECRET_HANDLE = usize;

// TODO: this type has an InvalidHandleValue of '0', what can Zig do with this information?
pub const HCRYPTPROV_LEGACY = usize;

// TODO: this type has an InvalidHandleValue of '0', what can Zig do with this information?
pub const HCRYPTPROV_OR_NCRYPT_KEY_HANDLE = usize;

// TODO: this type has an InvalidHandleValue of '0', what can Zig do with this information?
pub const HCERTSTORE = *anyopaque;

// TODO: this type has an InvalidHandleValue of '0', what can Zig do with this information?
pub const HCERTSTOREPROV = *anyopaque;

pub const CMS_KEY_INFO = extern struct {
    dwVersion: u32,
    Algid: u32,
    pbOID: ?*u8,
    cbOID: u32,
};

pub const HMAC_Info = extern struct {
    HashAlgid: u32,
    pbInnerString: ?*u8,
    cbInnerString: u32,
    pbOuterString: ?*u8,
    cbOuterString: u32,
};

pub const SCHANNEL_ALG = extern struct {
    dwUse: u32,
    Algid: u32,
    cBits: u32,
    dwFlags: u32,
    dwReserved: u32,
};

pub const PROV_ENUMALGS = extern struct {
    aiAlgid: u32,
    dwBitLen: u32,
    dwNameLen: u32,
    szName: [20]CHAR,
};

pub const PROV_ENUMALGS_EX = extern struct {
    aiAlgid: u32,
    dwDefaultLen: u32,
    dwMinLen: u32,
    dwMaxLen: u32,
    dwProtocols: u32,
    dwNameLen: u32,
    szName: [20]CHAR,
    dwLongNameLen: u32,
    szLongName: [40]CHAR,
};

pub const PUBLICKEYSTRUC = extern struct {
    bType: u8,
    bVersion: u8,
    reserved: u16,
    aiKeyAlg: u32,
};

pub const RSAPUBKEY = extern struct {
    magic: u32,
    bitlen: u32,
    pubexp: u32,
};

pub const PUBKEY = extern struct {
    magic: u32,
    bitlen: u32,
};

pub const DSSSEED = extern struct {
    counter: u32,
    seed: [20]u8,
};

pub const PUBKEYVER3 = extern struct {
    magic: u32,
    bitlenP: u32,
    bitlenQ: u32,
    bitlenJ: u32,
    DSSSeed: DSSSEED,
};

pub const PRIVKEYVER3 = extern struct {
    magic: u32,
    bitlenP: u32,
    bitlenQ: u32,
    bitlenJ: u32,
    bitlenX: u32,
    DSSSeed: DSSSEED,
};

pub const KEY_TYPE_SUBTYPE = extern struct {
    dwKeySpec: u32,
    Type: Guid,
    Subtype: Guid,
};

pub const CERT_FORTEZZA_DATA_PROP = extern struct {
    SerialNumber: [8]u8,
    CertIndex: i32,
    CertLabel: [36]u8,
};

pub const CRYPT_RC4_KEY_STATE = extern struct {
    Key: [16]u8,
    SBox: [256]u8,
    i: u8,
    j: u8,
};

pub const CRYPT_DES_KEY_STATE = extern struct {
    Key: [8]u8,
    IV: [8]u8,
    Feedback: [8]u8,
};

pub const CRYPT_3DES_KEY_STATE = extern struct {
    Key: [24]u8,
    IV: [8]u8,
    Feedback: [8]u8,
};

pub const CRYPT_AES_128_KEY_STATE = extern struct {
    Key: [16]u8,
    IV: [16]u8,
    EncryptionState: [176]u8,
    DecryptionState: [176]u8,
    Feedback: [16]u8,
};

pub const CRYPT_AES_256_KEY_STATE = extern struct {
    Key: [32]u8,
    IV: [16]u8,
    EncryptionState: [240]u8,
    DecryptionState: [240]u8,
    Feedback: [16]u8,
};

pub const CRYPTOAPI_BLOB = extern struct {
    cbData: u32,
    pbData: ?*u8,
};

pub const CMS_DH_KEY_INFO = extern struct {
    dwVersion: u32,
    Algid: u32,
    pszContentEncObjId: ?PSTR,
    PubInfo: CRYPTOAPI_BLOB,
    pReserved: ?*anyopaque,
};

pub const BCRYPT_KEY_LENGTHS_STRUCT = extern struct {
    dwMinLength: u32,
    dwMaxLength: u32,
    dwIncrement: u32,
};

pub const BCRYPT_OID = extern struct {
    cbOID: u32,
    pbOID: ?*u8,
};

pub const BCRYPT_OID_LIST = extern struct {
    dwOIDCount: u32,
    pOIDs: ?*BCRYPT_OID,
};

pub const BCRYPT_PKCS1_PADDING_INFO = extern struct {
    pszAlgId: ?[*:0]const u16,
};

pub const BCRYPT_PSS_PADDING_INFO = extern struct {
    pszAlgId: ?[*:0]const u16,
    cbSalt: u32,
};

pub const BCRYPT_OAEP_PADDING_INFO = extern struct {
    pszAlgId: ?[*:0]const u16,
    pbLabel: ?*u8,
    cbLabel: u32,
};

pub const BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO = extern struct {
    cbSize: u32,
    dwInfoVersion: u32,
    pbNonce: ?*u8,
    cbNonce: u32,
    pbAuthData: ?*u8,
    cbAuthData: u32,
    pbTag: ?*u8,
    cbTag: u32,
    pbMacContext: ?*u8,
    cbMacContext: u32,
    cbAAD: u32,
    cbData: u64,
    dwFlags: u32,
};

pub const BCryptBuffer = extern struct {
    cbBuffer: u32,
    BufferType: u32,
    pvBuffer: ?*anyopaque,
};

pub const BCryptBufferDesc = extern struct {
    ulVersion: u32,
    cBuffers: u32,
    pBuffers: ?*BCryptBuffer,
};

pub const BCRYPT_KEY_BLOB = extern struct {
    Magic: u32,
};

pub const BCRYPT_RSAKEY_BLOB = extern struct {
    Magic: BCRYPT_RSAKEY_BLOB_MAGIC,
    BitLength: u32,
    cbPublicExp: u32,
    cbModulus: u32,
    cbPrime1: u32,
    cbPrime2: u32,
};

pub const BCRYPT_ECCKEY_BLOB = extern struct {
    dwMagic: u32,
    cbKey: u32,
};

pub const SSL_ECCKEY_BLOB = extern struct {
    dwCurveType: u32,
    cbKey: u32,
};

pub const ECC_CURVE_TYPE_ENUM = enum(i32) {
    SHORT_WEIERSTRASS_CURVE = 1,
    TWISTED_EDWARDS_CURVE = 2,
    MONTGOMERY_CURVE = 3,
};
pub const BCRYPT_ECC_PRIME_SHORT_WEIERSTRASS_CURVE = ECC_CURVE_TYPE_ENUM.SHORT_WEIERSTRASS_CURVE;
pub const BCRYPT_ECC_PRIME_TWISTED_EDWARDS_CURVE = ECC_CURVE_TYPE_ENUM.TWISTED_EDWARDS_CURVE;
pub const BCRYPT_ECC_PRIME_MONTGOMERY_CURVE = ECC_CURVE_TYPE_ENUM.MONTGOMERY_CURVE;

pub const ECC_CURVE_ALG_ID_ENUM = enum(i32) {
    D = 0,
};
pub const BCRYPT_NO_CURVE_GENERATION_ALG_ID = ECC_CURVE_ALG_ID_ENUM.D;

pub const BCRYPT_ECCFULLKEY_BLOB = extern struct {
    dwMagic: u32,
    dwVersion: u32,
    dwCurveType: ECC_CURVE_TYPE_ENUM,
    dwCurveGenerationAlgId: ECC_CURVE_ALG_ID_ENUM,
    cbFieldLength: u32,
    cbSubgroupOrder: u32,
    cbCofactor: u32,
    cbSeed: u32,
};

pub const BCRYPT_DH_KEY_BLOB = extern struct {
    dwMagic: BCRYPT_DH_KEY_BLOB_MAGIC,
    cbKey: u32,
};

pub const BCRYPT_DH_PARAMETER_HEADER = extern struct {
    cbLength: u32,
    dwMagic: u32,
    cbKeyLength: u32,
};

pub const BCRYPT_DSA_KEY_BLOB = extern struct {
    dwMagic: BCRYPT_DSA_MAGIC,
    cbKey: u32,
    Count: [4]u8,
    Seed: [20]u8,
    q: [20]u8,
};

pub const HASHALGORITHM_ENUM = enum(i32) {
    @"1" = 0,
    @"256" = 1,
    @"512" = 2,
};
pub const DSA_HASH_ALGORITHM_SHA1 = HASHALGORITHM_ENUM.@"1";
pub const DSA_HASH_ALGORITHM_SHA256 = HASHALGORITHM_ENUM.@"256";
pub const DSA_HASH_ALGORITHM_SHA512 = HASHALGORITHM_ENUM.@"512";

pub const DSAFIPSVERSION_ENUM = enum(i32) {
    @"2" = 0,
    @"3" = 1,
};
pub const DSA_FIPS186_2 = DSAFIPSVERSION_ENUM.@"2";
pub const DSA_FIPS186_3 = DSAFIPSVERSION_ENUM.@"3";

pub const BCRYPT_DSA_KEY_BLOB_V2 = extern struct {
    dwMagic: BCRYPT_DSA_MAGIC,
    cbKey: u32,
    hashAlgorithm: HASHALGORITHM_ENUM,
    standardVersion: DSAFIPSVERSION_ENUM,
    cbSeedLength: u32,
    cbGroupSize: u32,
    Count: [4]u8,
};

pub const BCRYPT_KEY_DATA_BLOB_HEADER = extern struct {
    dwMagic: u32,
    dwVersion: u32,
    cbKeyData: u32,
};

pub const BCRYPT_DSA_PARAMETER_HEADER = extern struct {
    cbLength: u32,
    dwMagic: u32,
    cbKeyLength: u32,
    Count: [4]u8,
    Seed: [20]u8,
    q: [20]u8,
};

pub const BCRYPT_DSA_PARAMETER_HEADER_V2 = extern struct {
    cbLength: u32,
    dwMagic: u32,
    cbKeyLength: u32,
    hashAlgorithm: HASHALGORITHM_ENUM,
    standardVersion: DSAFIPSVERSION_ENUM,
    cbSeedLength: u32,
    cbGroupSize: u32,
    Count: [4]u8,
};

pub const BCRYPT_ECC_CURVE_NAMES = extern struct {
    dwEccCurveNames: u32,
    pEccCurveNames: ?*?PWSTR,
};

pub const BCRYPT_HASH_OPERATION_TYPE = enum(i32) {
    HASH_DATA = 1,
    FINISH_HASH = 2,
};
pub const BCRYPT_HASH_OPERATION_HASH_DATA = BCRYPT_HASH_OPERATION_TYPE.HASH_DATA;
pub const BCRYPT_HASH_OPERATION_FINISH_HASH = BCRYPT_HASH_OPERATION_TYPE.FINISH_HASH;

pub const BCRYPT_MULTI_HASH_OPERATION = extern struct {
    iHash: u32,
    hashOperation: BCRYPT_HASH_OPERATION_TYPE,
    pbBuffer: ?*u8,
    cbBuffer: u32,
};

pub const BCRYPT_MULTI_OPERATION_TYPE = enum(i32) {
    H = 1,
};
pub const BCRYPT_OPERATION_TYPE_HASH = BCRYPT_MULTI_OPERATION_TYPE.H;

pub const BCRYPT_MULTI_OBJECT_LENGTH_STRUCT = extern struct {
    cbPerObject: u32,
    cbPerElement: u32,
};

pub const BCRYPT_ALGORITHM_IDENTIFIER = extern struct {
    pszName: ?PWSTR,
    dwClass: u32,
    dwFlags: u32,
};

pub const BCRYPT_PROVIDER_NAME = extern struct {
    pszProviderName: ?PWSTR,
};

pub const BCRYPT_INTERFACE_VERSION = extern struct {
    MajorVersion: u16,
    MinorVersion: u16,
};

pub const CRYPT_INTERFACE_REG = extern struct {
    dwInterface: BCRYPT_INTERFACE,
    dwFlags: BCRYPT_TABLE,
    cFunctions: u32,
    rgpszFunctions: ?*?PWSTR,
};

pub const CRYPT_IMAGE_REG = extern struct {
    pszImage: ?PWSTR,
    cInterfaces: u32,
    rgpInterfaces: ?*?*CRYPT_INTERFACE_REG,
};

pub const CRYPT_PROVIDER_REG = extern struct {
    cAliases: u32,
    rgpszAliases: ?*?PWSTR,
    pUM: ?*CRYPT_IMAGE_REG,
    pKM: ?*CRYPT_IMAGE_REG,
};

pub const CRYPT_PROVIDERS = extern struct {
    cProviders: u32,
    rgpszProviders: ?*?PWSTR,
};

pub const CRYPT_CONTEXT_CONFIG = extern struct {
    dwFlags: CRYPT_CONTEXT_CONFIG_FLAGS,
    dwReserved: u32,
};

pub const CRYPT_CONTEXT_FUNCTION_CONFIG = extern struct {
    dwFlags: u32,
    dwReserved: u32,
};

pub const CRYPT_CONTEXTS = extern struct {
    cContexts: u32,
    rgpszContexts: ?*?PWSTR,
};

pub const CRYPT_CONTEXT_FUNCTIONS = extern struct {
    cFunctions: u32,
    rgpszFunctions: ?*?PWSTR,
};

pub const CRYPT_CONTEXT_FUNCTION_PROVIDERS = extern struct {
    cProviders: u32,
    rgpszProviders: ?*?PWSTR,
};

pub const CRYPT_PROPERTY_REF = extern struct {
    pszProperty: ?PWSTR,
    cbValue: u32,
    pbValue: ?*u8,
};

pub const CRYPT_IMAGE_REF = extern struct {
    pszImage: ?PWSTR,
    dwFlags: CRYPT_IMAGE_REF_FLAGS,
};

pub const CRYPT_PROVIDER_REF = extern struct {
    dwInterface: u32,
    pszFunction: ?PWSTR,
    pszProvider: ?PWSTR,
    cProperties: u32,
    rgpProperties: ?*?*CRYPT_PROPERTY_REF,
    pUM: ?*CRYPT_IMAGE_REF,
    pKM: ?*CRYPT_IMAGE_REF,
};

pub const CRYPT_PROVIDER_REFS = extern struct {
    cProviders: u32,
    rgpProviders: ?*?*CRYPT_PROVIDER_REF,
};

pub const PFN_NCRYPT_ALLOC = *const fn(
    cbSize: usize,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

pub const PFN_NCRYPT_FREE = *const fn(
    pv: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

pub const NCRYPT_ALLOC_PARA = extern struct {
    cbSize: u32,
    pfnAlloc: ?PFN_NCRYPT_ALLOC,
    pfnFree: ?PFN_NCRYPT_FREE,
};

pub const NCRYPT_CIPHER_PADDING_INFO = extern struct {
    cbSize: u32,
    dwFlags: u32,
    pbIV: ?*u8,
    cbIV: u32,
    pbOtherInfo: ?*u8,
    cbOtherInfo: u32,
};

pub const NCRYPT_PLATFORM_ATTEST_PADDING_INFO = extern struct {
    magic: u32,
    pcrMask: u32,
};

pub const NCRYPT_KEY_ATTEST_PADDING_INFO = extern struct {
    magic: u32,
    pbKeyBlob: ?*u8,
    cbKeyBlob: u32,
    pbKeyAuth: ?*u8,
    cbKeyAuth: u32,
};

pub const NCRYPT_ISOLATED_KEY_ATTESTED_ATTRIBUTES = extern struct {
    Version: u32,
    Flags: u32,
    cbPublicKeyBlob: u32,
};

pub const NCRYPT_VSM_KEY_ATTESTATION_STATEMENT = extern struct {
    Magic: u32,
    Version: u32,
    cbSignature: u32,
    cbReport: u32,
    cbAttributes: u32,
};

pub const NCRYPT_VSM_KEY_ATTESTATION_CLAIM_RESTRICTIONS = extern struct {
    Version: u32,
    TrustletId: u64,
    MinSvn: u32,
    FlagsMask: u32,
    FlagsExpected: u32,
    _bitfield: u32,
};

pub const NCRYPT_EXPORTED_ISOLATED_KEY_HEADER = extern struct {
    Version: u32,
    KeyUsage: u32,
    _bitfield: u32,
    cbAlgName: u32,
    cbNonce: u32,
    cbAuthTag: u32,
    cbWrappingKey: u32,
    cbIsolatedKey: u32,
};

pub const NCRYPT_EXPORTED_ISOLATED_KEY_ENVELOPE = extern struct {
    Header: NCRYPT_EXPORTED_ISOLATED_KEY_HEADER,
};

pub const NCRYPT_PCP_TPM_WEB_AUTHN_ATTESTATION_STATEMENT = extern struct {
    Magic: u32,
    Version: u32,
    HeaderSize: u32,
    cbCertifyInfo: u32,
    cbSignature: u32,
    cbTpmPublic: u32,
};

pub const NCRYPT_TPM_PLATFORM_ATTESTATION_STATEMENT = extern struct {
    Magic: u32,
    Version: u32,
    pcrAlg: u32,
    cbSignature: u32,
    cbQuote: u32,
    cbPcrs: u32,
};

pub const NCryptAlgorithmName = extern struct {
    pszName: ?PWSTR,
    dwClass: NCRYPT_ALGORITHM_NAME_CLASS,
    dwAlgOperations: NCRYPT_OPERATION,
    dwFlags: u32,
};

pub const NCryptKeyName = extern struct {
    pszName: ?PWSTR,
    pszAlgid: ?PWSTR,
    dwLegacyKeySpec: CERT_KEY_SPEC,
    dwFlags: u32,
};

pub const NCryptProviderName = extern struct {
    pszName: ?PWSTR,
    pszComment: ?PWSTR,
};

pub const NCRYPT_UI_POLICY = extern struct {
    dwVersion: u32,
    dwFlags: u32,
    pszCreationTitle: ?[*:0]const u16,
    pszFriendlyName: ?[*:0]const u16,
    pszDescription: ?[*:0]const u16,
};

pub const NCRYPT_KEY_ACCESS_POLICY_BLOB = extern struct {
    dwVersion: u32,
    dwPolicyFlags: u32,
    cbUserSid: u32,
    cbApplicationSid: u32,
};

pub const NCRYPT_SUPPORTED_LENGTHS = extern struct {
    dwMinLength: u32,
    dwMaxLength: u32,
    dwIncrement: u32,
    dwDefaultLength: u32,
};

pub const NCRYPT_PCP_HMAC_AUTH_SIGNATURE_INFO = extern struct {
    dwVersion: u32,
    iExpiration: i32,
    pabNonce: [32]u8,
    pabPolicyRef: [32]u8,
    pabHMAC: [32]u8,
};

pub const NCRYPT_PCP_TPM_FW_VERSION_INFO = extern struct {
    major1: u16,
    major2: u16,
    minor1: u16,
    minor2: u16,
};

pub const NCRYPT_PCP_RAW_POLICYDIGEST = extern struct {
    dwVersion: u32,
    cbDigest: u32,
};

pub const NCRYPT_KEY_BLOB_HEADER = extern struct {
    cbSize: u32,
    dwMagic: u32,
    cbAlgName: u32,
    cbKeyData: u32,
};

pub const NCRYPT_TPM_LOADABLE_KEY_BLOB_HEADER = extern struct {
    magic: u32,
    cbHeader: u32,
    cbPublic: u32,
    cbPrivate: u32,
    cbName: u32,
};

pub const CRYPT_BIT_BLOB = extern struct {
    cbData: u32,
    pbData: ?*u8,
    cUnusedBits: u32,
};

pub const CRYPT_ALGORITHM_IDENTIFIER = extern struct {
    pszObjId: ?PSTR,
    Parameters: CRYPTOAPI_BLOB,
};

pub const CRYPT_OBJID_TABLE = extern struct {
    dwAlgId: u32,
    pszObjId: ?[*:0]const u8,
};

pub const CRYPT_HASH_INFO = extern struct {
    HashAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    Hash: CRYPTOAPI_BLOB,
};

pub const CERT_EXTENSION = extern struct {
    pszObjId: ?PSTR,
    fCritical: BOOL,
    Value: CRYPTOAPI_BLOB,
};

pub const CRYPT_ATTRIBUTE_TYPE_VALUE = extern struct {
    pszObjId: ?PSTR,
    Value: CRYPTOAPI_BLOB,
};

pub const CRYPT_ATTRIBUTE = extern struct {
    pszObjId: ?PSTR,
    cValue: u32,
    rgValue: ?*CRYPTOAPI_BLOB,
};

pub const CRYPT_ATTRIBUTES = extern struct {
    cAttr: u32,
    rgAttr: ?*CRYPT_ATTRIBUTE,
};

pub const CERT_RDN_ATTR = extern struct {
    pszObjId: ?PSTR,
    dwValueType: CERT_RDN_ATTR_VALUE_TYPE,
    Value: CRYPTOAPI_BLOB,
};

pub const CERT_RDN = extern struct {
    cRDNAttr: u32,
    rgRDNAttr: ?*CERT_RDN_ATTR,
};

pub const CERT_NAME_INFO = extern struct {
    cRDN: u32,
    rgRDN: ?*CERT_RDN,
};

pub const CERT_NAME_VALUE = extern struct {
    dwValueType: u32,
    Value: CRYPTOAPI_BLOB,
};

pub const CERT_PUBLIC_KEY_INFO = extern struct {
    Algorithm: CRYPT_ALGORITHM_IDENTIFIER,
    PublicKey: CRYPT_BIT_BLOB,
};

pub const CRYPT_ECC_PRIVATE_KEY_INFO = extern struct {
    dwVersion: u32,
    PrivateKey: CRYPTOAPI_BLOB,
    szCurveOid: ?PSTR,
    PublicKey: CRYPT_BIT_BLOB,
};

pub const CRYPT_PRIVATE_KEY_INFO = extern struct {
    Version: u32,
    Algorithm: CRYPT_ALGORITHM_IDENTIFIER,
    PrivateKey: CRYPTOAPI_BLOB,
    pAttributes: ?*CRYPT_ATTRIBUTES,
};

pub const CRYPT_ENCRYPTED_PRIVATE_KEY_INFO = extern struct {
    EncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    EncryptedPrivateKey: CRYPTOAPI_BLOB,
};

pub const PCRYPT_DECRYPT_PRIVATE_KEY_FUNC = *const fn(
    Algorithm: CRYPT_ALGORITHM_IDENTIFIER,
    EncryptedPrivateKey: CRYPTOAPI_BLOB,
    // TODO: what to do with BytesParamIndex 3?
    pbClearTextKey: ?*u8,
    pcbClearTextKey: ?*u32,
    pVoidDecryptFunc: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PCRYPT_ENCRYPT_PRIVATE_KEY_FUNC = *const fn(
    pAlgorithm: ?*CRYPT_ALGORITHM_IDENTIFIER,
    pClearTextPrivateKey: ?*CRYPTOAPI_BLOB,
    // TODO: what to do with BytesParamIndex 3?
    pbEncryptedKey: ?*u8,
    pcbEncryptedKey: ?*u32,
    pVoidEncryptFunc: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PCRYPT_RESOLVE_HCRYPTPROV_FUNC = *const fn(
    pPrivateKeyInfo: ?*CRYPT_PRIVATE_KEY_INFO,
    phCryptProv: ?*usize,
    pVoidResolveFunc: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CRYPT_PKCS8_IMPORT_PARAMS = extern struct {
    PrivateKey: CRYPTOAPI_BLOB,
    pResolvehCryptProvFunc: ?PCRYPT_RESOLVE_HCRYPTPROV_FUNC,
    pVoidResolveFunc: ?*anyopaque,
    pDecryptPrivateKeyFunc: ?PCRYPT_DECRYPT_PRIVATE_KEY_FUNC,
    pVoidDecryptFunc: ?*anyopaque,
};

pub const CRYPT_PKCS8_EXPORT_PARAMS = extern struct {
    hCryptProv: usize,
    dwKeySpec: u32,
    pszPrivateKeyObjId: ?PSTR,
    pEncryptPrivateKeyFunc: ?PCRYPT_ENCRYPT_PRIVATE_KEY_FUNC,
    pVoidEncryptFunc: ?*anyopaque,
};

pub const CERT_INFO = extern struct {
    dwVersion: u32,
    SerialNumber: CRYPTOAPI_BLOB,
    SignatureAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    Issuer: CRYPTOAPI_BLOB,
    NotBefore: FILETIME,
    NotAfter: FILETIME,
    Subject: CRYPTOAPI_BLOB,
    SubjectPublicKeyInfo: CERT_PUBLIC_KEY_INFO,
    IssuerUniqueId: CRYPT_BIT_BLOB,
    SubjectUniqueId: CRYPT_BIT_BLOB,
    cExtension: u32,
    rgExtension: ?*CERT_EXTENSION,
};

pub const CRL_ENTRY = extern struct {
    SerialNumber: CRYPTOAPI_BLOB,
    RevocationDate: FILETIME,
    cExtension: u32,
    rgExtension: ?*CERT_EXTENSION,
};

pub const CRL_INFO = extern struct {
    dwVersion: u32,
    SignatureAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    Issuer: CRYPTOAPI_BLOB,
    ThisUpdate: FILETIME,
    NextUpdate: FILETIME,
    cCRLEntry: u32,
    rgCRLEntry: ?*CRL_ENTRY,
    cExtension: u32,
    rgExtension: ?*CERT_EXTENSION,
};

pub const CERT_OR_CRL_BLOB = extern struct {
    dwChoice: u32,
    cbEncoded: u32,
    pbEncoded: ?*u8,
};

pub const CERT_OR_CRL_BUNDLE = extern struct {
    cItem: u32,
    rgItem: ?*CERT_OR_CRL_BLOB,
};

pub const CERT_REQUEST_INFO = extern struct {
    dwVersion: u32,
    Subject: CRYPTOAPI_BLOB,
    SubjectPublicKeyInfo: CERT_PUBLIC_KEY_INFO,
    cAttribute: u32,
    rgAttribute: ?*CRYPT_ATTRIBUTE,
};

pub const CERT_KEYGEN_REQUEST_INFO = extern struct {
    dwVersion: u32,
    SubjectPublicKeyInfo: CERT_PUBLIC_KEY_INFO,
    pwszChallengeString: ?PWSTR,
};

pub const CERT_SIGNED_CONTENT_INFO = extern struct {
    ToBeSigned: CRYPTOAPI_BLOB,
    SignatureAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    Signature: CRYPT_BIT_BLOB,
};

pub const CTL_USAGE = extern struct {
    cUsageIdentifier: u32,
    rgpszUsageIdentifier: ?*?PSTR,
};

pub const CTL_ENTRY = extern struct {
    SubjectIdentifier: CRYPTOAPI_BLOB,
    cAttribute: u32,
    rgAttribute: ?*CRYPT_ATTRIBUTE,
};

pub const CTL_INFO = extern struct {
    dwVersion: u32,
    SubjectUsage: CTL_USAGE,
    ListIdentifier: CRYPTOAPI_BLOB,
    SequenceNumber: CRYPTOAPI_BLOB,
    ThisUpdate: FILETIME,
    NextUpdate: FILETIME,
    SubjectAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    cCTLEntry: u32,
    rgCTLEntry: ?*CTL_ENTRY,
    cExtension: u32,
    rgExtension: ?*CERT_EXTENSION,
};

pub const CRYPT_TIME_STAMP_REQUEST_INFO = extern struct {
    pszTimeStampAlgorithm: ?PSTR,
    pszContentType: ?PSTR,
    Content: CRYPTOAPI_BLOB,
    cAttribute: u32,
    rgAttribute: ?*CRYPT_ATTRIBUTE,
};

pub const CRYPT_ENROLLMENT_NAME_VALUE_PAIR = extern struct {
    pwszName: ?PWSTR,
    pwszValue: ?PWSTR,
};

pub const CRYPT_CSP_PROVIDER = extern struct {
    dwKeySpec: u32,
    pwszProviderName: ?PWSTR,
    Signature: CRYPT_BIT_BLOB,
};

pub const PFN_CRYPT_ALLOC = *const fn(
    cbSize: usize,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

pub const PFN_CRYPT_FREE = *const fn(
    pv: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

pub const CRYPT_ENCODE_PARA = extern struct {
    cbSize: u32,
    pfnAlloc: ?PFN_CRYPT_ALLOC,
    pfnFree: ?PFN_CRYPT_FREE,
};

pub const CRYPT_DECODE_PARA = extern struct {
    cbSize: u32,
    pfnAlloc: ?PFN_CRYPT_ALLOC,
    pfnFree: ?PFN_CRYPT_FREE,
};

pub const CERT_EXTENSIONS = extern struct {
    cExtension: u32,
    rgExtension: ?*CERT_EXTENSION,
};

pub const CERT_AUTHORITY_KEY_ID_INFO = extern struct {
    KeyId: CRYPTOAPI_BLOB,
    CertIssuer: CRYPTOAPI_BLOB,
    CertSerialNumber: CRYPTOAPI_BLOB,
};

pub const CERT_PRIVATE_KEY_VALIDITY = extern struct {
    NotBefore: FILETIME,
    NotAfter: FILETIME,
};

pub const CERT_KEY_ATTRIBUTES_INFO = extern struct {
    KeyId: CRYPTOAPI_BLOB,
    IntendedKeyUsage: CRYPT_BIT_BLOB,
    pPrivateKeyUsagePeriod: ?*CERT_PRIVATE_KEY_VALIDITY,
};

pub const CERT_POLICY_ID = extern struct {
    cCertPolicyElementId: u32,
    rgpszCertPolicyElementId: ?*?PSTR,
};

pub const CERT_KEY_USAGE_RESTRICTION_INFO = extern struct {
    cCertPolicyId: u32,
    rgCertPolicyId: ?*CERT_POLICY_ID,
    RestrictedKeyUsage: CRYPT_BIT_BLOB,
};

pub const CERT_OTHER_NAME = extern struct {
    pszObjId: ?PSTR,
    Value: CRYPTOAPI_BLOB,
};

pub const CERT_ALT_NAME_ENTRY = extern struct {
    dwAltNameChoice: u32,
    Anonymous: extern union {
        pOtherName: ?*CERT_OTHER_NAME,
        pwszRfc822Name: ?PWSTR,
        pwszDNSName: ?PWSTR,
        DirectoryName: CRYPTOAPI_BLOB,
        pwszURL: ?PWSTR,
        IPAddress: CRYPTOAPI_BLOB,
        pszRegisteredID: ?PSTR,
    },
};

pub const CERT_ALT_NAME_INFO = extern struct {
    cAltEntry: u32,
    rgAltEntry: ?*CERT_ALT_NAME_ENTRY,
};

pub const CERT_BASIC_CONSTRAINTS_INFO = extern struct {
    SubjectType: CRYPT_BIT_BLOB,
    fPathLenConstraint: BOOL,
    dwPathLenConstraint: u32,
    cSubtreesConstraint: u32,
    rgSubtreesConstraint: ?*CRYPTOAPI_BLOB,
};

pub const CERT_BASIC_CONSTRAINTS2_INFO = extern struct {
    fCA: BOOL,
    fPathLenConstraint: BOOL,
    dwPathLenConstraint: u32,
};

pub const CERT_POLICY_QUALIFIER_INFO = extern struct {
    pszPolicyQualifierId: ?PSTR,
    Qualifier: CRYPTOAPI_BLOB,
};

pub const CERT_POLICY_INFO = extern struct {
    pszPolicyIdentifier: ?PSTR,
    cPolicyQualifier: u32,
    rgPolicyQualifier: ?*CERT_POLICY_QUALIFIER_INFO,
};

pub const CERT_POLICIES_INFO = extern struct {
    cPolicyInfo: u32,
    rgPolicyInfo: ?*CERT_POLICY_INFO,
};

pub const CERT_POLICY_QUALIFIER_NOTICE_REFERENCE = extern struct {
    pszOrganization: ?PSTR,
    cNoticeNumbers: u32,
    rgNoticeNumbers: ?*i32,
};

pub const CERT_POLICY_QUALIFIER_USER_NOTICE = extern struct {
    pNoticeReference: ?*CERT_POLICY_QUALIFIER_NOTICE_REFERENCE,
    pszDisplayText: ?PWSTR,
};

pub const CPS_URLS = extern struct {
    pszURL: ?PWSTR,
    pAlgorithm: ?*CRYPT_ALGORITHM_IDENTIFIER,
    pDigest: ?*CRYPTOAPI_BLOB,
};

pub const CERT_POLICY95_QUALIFIER1 = extern struct {
    pszPracticesReference: ?PWSTR,
    pszNoticeIdentifier: ?PSTR,
    pszNSINoticeIdentifier: ?PSTR,
    cCPSURLs: u32,
    rgCPSURLs: ?*CPS_URLS,
};

pub const CERT_POLICY_MAPPING = extern struct {
    pszIssuerDomainPolicy: ?PSTR,
    pszSubjectDomainPolicy: ?PSTR,
};

pub const CERT_POLICY_MAPPINGS_INFO = extern struct {
    cPolicyMapping: u32,
    rgPolicyMapping: ?*CERT_POLICY_MAPPING,
};

pub const CERT_POLICY_CONSTRAINTS_INFO = extern struct {
    fRequireExplicitPolicy: BOOL,
    dwRequireExplicitPolicySkipCerts: u32,
    fInhibitPolicyMapping: BOOL,
    dwInhibitPolicyMappingSkipCerts: u32,
};

pub const CRYPT_CONTENT_INFO_SEQUENCE_OF_ANY = extern struct {
    pszObjId: ?PSTR,
    cValue: u32,
    rgValue: ?*CRYPTOAPI_BLOB,
};

pub const CRYPT_CONTENT_INFO = extern struct {
    pszObjId: ?PSTR,
    Content: CRYPTOAPI_BLOB,
};

pub const CRYPT_SEQUENCE_OF_ANY = extern struct {
    cValue: u32,
    rgValue: ?*CRYPTOAPI_BLOB,
};

pub const CERT_AUTHORITY_KEY_ID2_INFO = extern struct {
    KeyId: CRYPTOAPI_BLOB,
    AuthorityCertIssuer: CERT_ALT_NAME_INFO,
    AuthorityCertSerialNumber: CRYPTOAPI_BLOB,
};

pub const CERT_ACCESS_DESCRIPTION = extern struct {
    pszAccessMethod: ?PSTR,
    AccessLocation: CERT_ALT_NAME_ENTRY,
};

pub const CERT_AUTHORITY_INFO_ACCESS = extern struct {
    cAccDescr: u32,
    rgAccDescr: ?*CERT_ACCESS_DESCRIPTION,
};

pub const CRL_DIST_POINT_NAME = extern struct {
    dwDistPointNameChoice: u32,
    Anonymous: extern union {
        FullName: CERT_ALT_NAME_INFO,
    },
};

pub const CRL_DIST_POINT = extern struct {
    DistPointName: CRL_DIST_POINT_NAME,
    ReasonFlags: CRYPT_BIT_BLOB,
    CRLIssuer: CERT_ALT_NAME_INFO,
};

pub const CRL_DIST_POINTS_INFO = extern struct {
    cDistPoint: u32,
    rgDistPoint: ?*CRL_DIST_POINT,
};

pub const CROSS_CERT_DIST_POINTS_INFO = extern struct {
    dwSyncDeltaTime: u32,
    cDistPoint: u32,
    rgDistPoint: ?*CERT_ALT_NAME_INFO,
};

pub const CERT_PAIR = extern struct {
    Forward: CRYPTOAPI_BLOB,
    Reverse: CRYPTOAPI_BLOB,
};

pub const CRL_ISSUING_DIST_POINT = extern struct {
    DistPointName: CRL_DIST_POINT_NAME,
    fOnlyContainsUserCerts: BOOL,
    fOnlyContainsCACerts: BOOL,
    OnlySomeReasonFlags: CRYPT_BIT_BLOB,
    fIndirectCRL: BOOL,
};

pub const CERT_GENERAL_SUBTREE = extern struct {
    Base: CERT_ALT_NAME_ENTRY,
    dwMinimum: u32,
    fMaximum: BOOL,
    dwMaximum: u32,
};

pub const CERT_NAME_CONSTRAINTS_INFO = extern struct {
    cPermittedSubtree: u32,
    rgPermittedSubtree: ?*CERT_GENERAL_SUBTREE,
    cExcludedSubtree: u32,
    rgExcludedSubtree: ?*CERT_GENERAL_SUBTREE,
};

pub const CERT_DSS_PARAMETERS = extern struct {
    p: CRYPTOAPI_BLOB,
    q: CRYPTOAPI_BLOB,
    g: CRYPTOAPI_BLOB,
};

pub const CERT_DH_PARAMETERS = extern struct {
    p: CRYPTOAPI_BLOB,
    g: CRYPTOAPI_BLOB,
};

pub const CERT_ECC_SIGNATURE = extern struct {
    r: CRYPTOAPI_BLOB,
    s: CRYPTOAPI_BLOB,
};

pub const CERT_X942_DH_VALIDATION_PARAMS = extern struct {
    seed: CRYPT_BIT_BLOB,
    pgenCounter: u32,
};

pub const CERT_X942_DH_PARAMETERS = extern struct {
    p: CRYPTOAPI_BLOB,
    g: CRYPTOAPI_BLOB,
    q: CRYPTOAPI_BLOB,
    j: CRYPTOAPI_BLOB,
    pValidationParams: ?*CERT_X942_DH_VALIDATION_PARAMS,
};

pub const CRYPT_X942_OTHER_INFO = extern struct {
    pszContentEncryptionObjId: ?PSTR,
    rgbCounter: [4]u8,
    rgbKeyLength: [4]u8,
    PubInfo: CRYPTOAPI_BLOB,
};

pub const CRYPT_ECC_CMS_SHARED_INFO = extern struct {
    Algorithm: CRYPT_ALGORITHM_IDENTIFIER,
    EntityUInfo: CRYPTOAPI_BLOB,
    rgbSuppPubInfo: [4]u8,
};

pub const CRYPT_RC2_CBC_PARAMETERS = extern struct {
    dwVersion: u32,
    fIV: BOOL,
    rgbIV: [8]u8,
};

pub const CRYPT_SMIME_CAPABILITY = extern struct {
    pszObjId: ?PSTR,
    Parameters: CRYPTOAPI_BLOB,
};

pub const CRYPT_SMIME_CAPABILITIES = extern struct {
    cCapability: u32,
    rgCapability: ?*CRYPT_SMIME_CAPABILITY,
};

pub const CERT_QC_STATEMENT = extern struct {
    pszStatementId: ?PSTR,
    StatementInfo: CRYPTOAPI_BLOB,
};

pub const CERT_QC_STATEMENTS_EXT_INFO = extern struct {
    cStatement: u32,
    rgStatement: ?*CERT_QC_STATEMENT,
};

pub const CRYPT_MASK_GEN_ALGORITHM = extern struct {
    pszObjId: ?PSTR,
    HashAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
};

pub const CRYPT_RSA_SSA_PSS_PARAMETERS = extern struct {
    HashAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    MaskGenAlgorithm: CRYPT_MASK_GEN_ALGORITHM,
    dwSaltLength: u32,
    dwTrailerField: u32,
};

pub const CRYPT_PSOURCE_ALGORITHM = extern struct {
    pszObjId: ?PSTR,
    EncodingParameters: CRYPTOAPI_BLOB,
};

pub const CRYPT_RSAES_OAEP_PARAMETERS = extern struct {
    HashAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    MaskGenAlgorithm: CRYPT_MASK_GEN_ALGORITHM,
    PSourceAlgorithm: CRYPT_PSOURCE_ALGORITHM,
};

pub const CMC_TAGGED_ATTRIBUTE = extern struct {
    dwBodyPartID: u32,
    Attribute: CRYPT_ATTRIBUTE,
};

pub const CMC_TAGGED_CERT_REQUEST = extern struct {
    dwBodyPartID: u32,
    SignedCertRequest: CRYPTOAPI_BLOB,
};

pub const CMC_TAGGED_REQUEST = extern struct {
    dwTaggedRequestChoice: u32,
    Anonymous: extern union {
        pTaggedCertRequest: ?*CMC_TAGGED_CERT_REQUEST,
    },
};

pub const CMC_TAGGED_CONTENT_INFO = extern struct {
    dwBodyPartID: u32,
    EncodedContentInfo: CRYPTOAPI_BLOB,
};

pub const CMC_TAGGED_OTHER_MSG = extern struct {
    dwBodyPartID: u32,
    pszObjId: ?PSTR,
    Value: CRYPTOAPI_BLOB,
};

pub const CMC_DATA_INFO = extern struct {
    cTaggedAttribute: u32,
    rgTaggedAttribute: ?*CMC_TAGGED_ATTRIBUTE,
    cTaggedRequest: u32,
    rgTaggedRequest: ?*CMC_TAGGED_REQUEST,
    cTaggedContentInfo: u32,
    rgTaggedContentInfo: ?*CMC_TAGGED_CONTENT_INFO,
    cTaggedOtherMsg: u32,
    rgTaggedOtherMsg: ?*CMC_TAGGED_OTHER_MSG,
};

pub const CMC_RESPONSE_INFO = extern struct {
    cTaggedAttribute: u32,
    rgTaggedAttribute: ?*CMC_TAGGED_ATTRIBUTE,
    cTaggedContentInfo: u32,
    rgTaggedContentInfo: ?*CMC_TAGGED_CONTENT_INFO,
    cTaggedOtherMsg: u32,
    rgTaggedOtherMsg: ?*CMC_TAGGED_OTHER_MSG,
};

pub const CMC_PEND_INFO = extern struct {
    PendToken: CRYPTOAPI_BLOB,
    PendTime: FILETIME,
};

pub const CMC_STATUS_INFO = extern struct {
    dwStatus: u32,
    cBodyList: u32,
    rgdwBodyList: ?*u32,
    pwszStatusString: ?PWSTR,
    dwOtherInfoChoice: u32,
    Anonymous: extern union {
        dwFailInfo: u32,
        pPendInfo: ?*CMC_PEND_INFO,
    },
};

pub const CMC_ADD_EXTENSIONS_INFO = extern struct {
    dwCmcDataReference: u32,
    cCertReference: u32,
    rgdwCertReference: ?*u32,
    cExtension: u32,
    rgExtension: ?*CERT_EXTENSION,
};

pub const CMC_ADD_ATTRIBUTES_INFO = extern struct {
    dwCmcDataReference: u32,
    cCertReference: u32,
    rgdwCertReference: ?*u32,
    cAttribute: u32,
    rgAttribute: ?*CRYPT_ATTRIBUTE,
};

pub const CERT_TEMPLATE_EXT = extern struct {
    pszObjId: ?PSTR,
    dwMajorVersion: u32,
    fMinorVersion: BOOL,
    dwMinorVersion: u32,
};

pub const CERT_HASHED_URL = extern struct {
    HashAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    Hash: CRYPTOAPI_BLOB,
    pwszUrl: ?PWSTR,
};

pub const CERT_LOGOTYPE_DETAILS = extern struct {
    pwszMimeType: ?PWSTR,
    cHashedUrl: u32,
    rgHashedUrl: ?*CERT_HASHED_URL,
};

pub const CERT_LOGOTYPE_REFERENCE = extern struct {
    cHashedUrl: u32,
    rgHashedUrl: ?*CERT_HASHED_URL,
};

pub const CERT_LOGOTYPE_IMAGE_INFO = extern struct {
    dwLogotypeImageInfoChoice: CERT_LOGOTYPE_IMAGE_INFO_TYPE,
    dwFileSize: u32,
    dwXSize: u32,
    dwYSize: u32,
    dwLogotypeImageResolutionChoice: CERT_LOGOTYPE_CHOICE,
    Anonymous: extern union {
        dwNumBits: u32,
        dwTableSize: u32,
    },
    pwszLanguage: ?PWSTR,
};

pub const CERT_LOGOTYPE_IMAGE = extern struct {
    LogotypeDetails: CERT_LOGOTYPE_DETAILS,
    pLogotypeImageInfo: ?*CERT_LOGOTYPE_IMAGE_INFO,
};

pub const CERT_LOGOTYPE_AUDIO_INFO = extern struct {
    dwFileSize: u32,
    dwPlayTime: u32,
    dwChannels: u32,
    dwSampleRate: u32,
    pwszLanguage: ?PWSTR,
};

pub const CERT_LOGOTYPE_AUDIO = extern struct {
    LogotypeDetails: CERT_LOGOTYPE_DETAILS,
    pLogotypeAudioInfo: ?*CERT_LOGOTYPE_AUDIO_INFO,
};

pub const CERT_LOGOTYPE_DATA = extern struct {
    cLogotypeImage: u32,
    rgLogotypeImage: ?*CERT_LOGOTYPE_IMAGE,
    cLogotypeAudio: u32,
    rgLogotypeAudio: ?*CERT_LOGOTYPE_AUDIO,
};

pub const CERT_LOGOTYPE_INFO = extern struct {
    dwLogotypeInfoChoice: CERT_LOGOTYPE_OPTION,
    Anonymous: extern union {
        pLogotypeDirectInfo: ?*CERT_LOGOTYPE_DATA,
        pLogotypeIndirectInfo: ?*CERT_LOGOTYPE_REFERENCE,
    },
};

pub const CERT_OTHER_LOGOTYPE_INFO = extern struct {
    pszObjId: ?PSTR,
    LogotypeInfo: CERT_LOGOTYPE_INFO,
};

pub const CERT_LOGOTYPE_EXT_INFO = extern struct {
    cCommunityLogo: u32,
    rgCommunityLogo: ?*CERT_LOGOTYPE_INFO,
    pIssuerLogo: ?*CERT_LOGOTYPE_INFO,
    pSubjectLogo: ?*CERT_LOGOTYPE_INFO,
    cOtherLogo: u32,
    rgOtherLogo: ?*CERT_OTHER_LOGOTYPE_INFO,
};

pub const CERT_BIOMETRIC_DATA = extern struct {
    dwTypeOfBiometricDataChoice: CERT_BIOMETRIC_DATA_TYPE,
    Anonymous: extern union {
        dwPredefined: u32,
        pszObjId: ?PSTR,
    },
    HashedUrl: CERT_HASHED_URL,
};

pub const CERT_BIOMETRIC_EXT_INFO = extern struct {
    cBiometricData: u32,
    rgBiometricData: ?*CERT_BIOMETRIC_DATA,
};

pub const OCSP_SIGNATURE_INFO = extern struct {
    SignatureAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    Signature: CRYPT_BIT_BLOB,
    cCertEncoded: u32,
    rgCertEncoded: ?*CRYPTOAPI_BLOB,
};

pub const OCSP_SIGNED_REQUEST_INFO = extern struct {
    ToBeSigned: CRYPTOAPI_BLOB,
    pOptionalSignatureInfo: ?*OCSP_SIGNATURE_INFO,
};

pub const OCSP_CERT_ID = extern struct {
    HashAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    IssuerNameHash: CRYPTOAPI_BLOB,
    IssuerKeyHash: CRYPTOAPI_BLOB,
    SerialNumber: CRYPTOAPI_BLOB,
};

pub const OCSP_REQUEST_ENTRY = extern struct {
    CertId: OCSP_CERT_ID,
    cExtension: u32,
    rgExtension: ?*CERT_EXTENSION,
};

pub const OCSP_REQUEST_INFO = extern struct {
    dwVersion: u32,
    pRequestorName: ?*CERT_ALT_NAME_ENTRY,
    cRequestEntry: u32,
    rgRequestEntry: ?*OCSP_REQUEST_ENTRY,
    cExtension: u32,
    rgExtension: ?*CERT_EXTENSION,
};

pub const OCSP_RESPONSE_INFO = extern struct {
    dwStatus: u32,
    pszObjId: ?PSTR,
    Value: CRYPTOAPI_BLOB,
};

pub const OCSP_BASIC_SIGNED_RESPONSE_INFO = extern struct {
    ToBeSigned: CRYPTOAPI_BLOB,
    SignatureInfo: OCSP_SIGNATURE_INFO,
};

pub const OCSP_BASIC_REVOKED_INFO = extern struct {
    RevocationDate: FILETIME,
    dwCrlReasonCode: CERT_REVOCATION_STATUS_REASON,
};

pub const OCSP_BASIC_RESPONSE_ENTRY = extern struct {
    CertId: OCSP_CERT_ID,
    dwCertStatus: u32,
    Anonymous: extern union {
        pRevokedInfo: ?*OCSP_BASIC_REVOKED_INFO,
    },
    ThisUpdate: FILETIME,
    NextUpdate: FILETIME,
    cExtension: u32,
    rgExtension: ?*CERT_EXTENSION,
};

pub const OCSP_BASIC_RESPONSE_INFO = extern struct {
    dwVersion: u32,
    dwResponderIdChoice: u32,
    Anonymous: extern union {
        ByNameResponderId: CRYPTOAPI_BLOB,
        ByKeyResponderId: CRYPTOAPI_BLOB,
    },
    ProducedAt: FILETIME,
    cResponseEntry: u32,
    rgResponseEntry: ?*OCSP_BASIC_RESPONSE_ENTRY,
    cExtension: u32,
    rgExtension: ?*CERT_EXTENSION,
};

pub const CERT_SUPPORTED_ALGORITHM_INFO = extern struct {
    Algorithm: CRYPT_ALGORITHM_IDENTIFIER,
    IntendedKeyUsage: CRYPT_BIT_BLOB,
    IntendedCertPolicies: CERT_POLICIES_INFO,
};

pub const CERT_TPM_SPECIFICATION_INFO = extern struct {
    pwszFamily: ?PWSTR,
    dwLevel: u32,
    dwRevision: u32,
};

pub const CRYPT_OID_FUNC_ENTRY = extern struct {
    pszOID: ?[*:0]const u8,
    pvFuncAddr: ?*anyopaque,
};

pub const PFN_CRYPT_ENUM_OID_FUNC = *const fn(
    dwEncodingType: u32,
    pszFuncName: ?[*:0]const u8,
    pszOID: ?[*:0]const u8,
    cValue: u32,
    rgdwValueType: [*]const u32,
    rgpwszValueName: [*]const ?[*:0]const u16,
    rgpbValueData: [*]const ?*const u8,
    rgcbValueData: [*]const u32,
    pvArg: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CRYPT_OID_INFO = extern struct {
    cbSize: u32,
    pszOID: ?[*:0]const u8,
    pwszName: ?[*:0]const u16,
    dwGroupId: u32,
    Anonymous: extern union {
        dwValue: u32,
        Algid: u32,
        dwLength: u32,
    },
    ExtraInfo: CRYPTOAPI_BLOB,
};

pub const PFN_CRYPT_ENUM_OID_INFO = *const fn(
    pInfo: ?*CRYPT_OID_INFO,
    pvArg: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CERT_STRONG_SIGN_SERIALIZED_INFO = extern struct {
    dwFlags: CERT_STRONG_SIGN_FLAGS,
    pwszCNGSignHashAlgids: ?PWSTR,
    pwszCNGPubKeyMinBitLengths: ?PWSTR,
};

pub const CERT_STRONG_SIGN_PARA = extern struct {
    cbSize: u32,
    dwInfoChoice: u32,
    Anonymous: extern union {
        pvInfo: ?*anyopaque,
        pSerializedInfo: ?*CERT_STRONG_SIGN_SERIALIZED_INFO,
        pszOID: ?PSTR,
    },
};

pub const CERT_ISSUER_SERIAL_NUMBER = extern struct {
    Issuer: CRYPTOAPI_BLOB,
    SerialNumber: CRYPTOAPI_BLOB,
};

pub const CERT_ID = extern struct {
    dwIdChoice: CERT_ID_OPTION,
    Anonymous: extern union {
        IssuerSerialNumber: CERT_ISSUER_SERIAL_NUMBER,
        KeyId: CRYPTOAPI_BLOB,
        HashId: CRYPTOAPI_BLOB,
    },
};

pub const CMSG_SIGNER_ENCODE_INFO = extern struct {
    cbSize: u32,
    pCertInfo: ?*CERT_INFO,
    Anonymous: extern union {
        hCryptProv: usize,
        hNCryptKey: NCRYPT_KEY_HANDLE,
    },
    dwKeySpec: u32,
    HashAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pvHashAuxInfo: ?*anyopaque,
    cAuthAttr: u32,
    rgAuthAttr: ?*CRYPT_ATTRIBUTE,
    cUnauthAttr: u32,
    rgUnauthAttr: ?*CRYPT_ATTRIBUTE,
};

pub const CMSG_SIGNED_ENCODE_INFO = extern struct {
    cbSize: u32,
    cSigners: u32,
    rgSigners: ?*CMSG_SIGNER_ENCODE_INFO,
    cCertEncoded: u32,
    rgCertEncoded: ?*CRYPTOAPI_BLOB,
    cCrlEncoded: u32,
    rgCrlEncoded: ?*CRYPTOAPI_BLOB,
};

pub const CMSG_ENVELOPED_ENCODE_INFO = extern struct {
    cbSize: u32,
    hCryptProv: HCRYPTPROV_LEGACY,
    ContentEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pvEncryptionAuxInfo: ?*anyopaque,
    cRecipients: u32,
    rgpRecipients: ?*?*CERT_INFO,
};

pub const CMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO = extern struct {
    cbSize: u32,
    KeyEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pvKeyEncryptionAuxInfo: ?*anyopaque,
    hCryptProv: HCRYPTPROV_LEGACY,
    RecipientPublicKey: CRYPT_BIT_BLOB,
    RecipientId: CERT_ID,
};

pub const CMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO = extern struct {
    cbSize: u32,
    RecipientPublicKey: CRYPT_BIT_BLOB,
    RecipientId: CERT_ID,
    Date: FILETIME,
    pOtherAttr: ?*CRYPT_ATTRIBUTE_TYPE_VALUE,
};

pub const CMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO = extern struct {
    cbSize: u32,
    KeyEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pvKeyEncryptionAuxInfo: ?*anyopaque,
    KeyWrapAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pvKeyWrapAuxInfo: ?*anyopaque,
    hCryptProv: HCRYPTPROV_LEGACY,
    dwKeySpec: u32,
    dwKeyChoice: CMSG_KEY_AGREE_OPTION,
    Anonymous: extern union {
        pEphemeralAlgorithm: ?*CRYPT_ALGORITHM_IDENTIFIER,
        pSenderId: ?*CERT_ID,
    },
    UserKeyingMaterial: CRYPTOAPI_BLOB,
    cRecipientEncryptedKeys: u32,
    rgpRecipientEncryptedKeys: ?*?*CMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO,
};

pub const CMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO = extern struct {
    cbSize: u32,
    KeyEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pvKeyEncryptionAuxInfo: ?*anyopaque,
    hCryptProv: usize,
    dwKeyChoice: u32,
    Anonymous: extern union {
        hKeyEncryptionKey: usize,
        pvKeyEncryptionKey: ?*anyopaque,
    },
    KeyId: CRYPTOAPI_BLOB,
    Date: FILETIME,
    pOtherAttr: ?*CRYPT_ATTRIBUTE_TYPE_VALUE,
};

pub const CMSG_RECIPIENT_ENCODE_INFO = extern struct {
    dwRecipientChoice: u32,
    Anonymous: extern union {
        pKeyTrans: ?*CMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO,
        pKeyAgree: ?*CMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO,
        pMailList: ?*CMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO,
    },
};

pub const CMSG_RC2_AUX_INFO = extern struct {
    cbSize: u32,
    dwBitLen: u32,
};

pub const CMSG_SP3_COMPATIBLE_AUX_INFO = extern struct {
    cbSize: u32,
    dwFlags: u32,
};

pub const CMSG_RC4_AUX_INFO = extern struct {
    cbSize: u32,
    dwBitLen: u32,
};

pub const CMSG_SIGNED_AND_ENVELOPED_ENCODE_INFO = extern struct {
    cbSize: u32,
    SignedInfo: CMSG_SIGNED_ENCODE_INFO,
    EnvelopedInfo: CMSG_ENVELOPED_ENCODE_INFO,
};

pub const CMSG_HASHED_ENCODE_INFO = extern struct {
    cbSize: u32,
    hCryptProv: HCRYPTPROV_LEGACY,
    HashAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pvHashAuxInfo: ?*anyopaque,
};

pub const CMSG_ENCRYPTED_ENCODE_INFO = extern struct {
    cbSize: u32,
    ContentEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pvEncryptionAuxInfo: ?*anyopaque,
};

pub const PFN_CMSG_STREAM_OUTPUT = *const fn(
    pvArg: ?*const anyopaque,
    // TODO: what to do with BytesParamIndex 2?
    pbData: ?*u8,
    cbData: u32,
    fFinal: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CMSG_STREAM_INFO = extern struct {
    cbContent: u32,
    pfnStreamOutput: ?PFN_CMSG_STREAM_OUTPUT,
    pvArg: ?*anyopaque,
};

pub const CMSG_SIGNER_INFO = extern struct {
    dwVersion: u32,
    Issuer: CRYPTOAPI_BLOB,
    SerialNumber: CRYPTOAPI_BLOB,
    HashAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    HashEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    EncryptedHash: CRYPTOAPI_BLOB,
    AuthAttrs: CRYPT_ATTRIBUTES,
    UnauthAttrs: CRYPT_ATTRIBUTES,
};

pub const CMSG_CMS_SIGNER_INFO = extern struct {
    dwVersion: u32,
    SignerId: CERT_ID,
    HashAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    HashEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    EncryptedHash: CRYPTOAPI_BLOB,
    AuthAttrs: CRYPT_ATTRIBUTES,
    UnauthAttrs: CRYPT_ATTRIBUTES,
};

pub const CMSG_KEY_TRANS_RECIPIENT_INFO = extern struct {
    dwVersion: u32,
    RecipientId: CERT_ID,
    KeyEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    EncryptedKey: CRYPTOAPI_BLOB,
};

pub const CMSG_RECIPIENT_ENCRYPTED_KEY_INFO = extern struct {
    RecipientId: CERT_ID,
    EncryptedKey: CRYPTOAPI_BLOB,
    Date: FILETIME,
    pOtherAttr: ?*CRYPT_ATTRIBUTE_TYPE_VALUE,
};

pub const CMSG_KEY_AGREE_RECIPIENT_INFO = extern struct {
    dwVersion: u32,
    dwOriginatorChoice: CMSG_KEY_AGREE_ORIGINATOR,
    Anonymous: extern union {
        OriginatorCertId: CERT_ID,
        OriginatorPublicKeyInfo: CERT_PUBLIC_KEY_INFO,
    },
    UserKeyingMaterial: CRYPTOAPI_BLOB,
    KeyEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    cRecipientEncryptedKeys: u32,
    rgpRecipientEncryptedKeys: ?*?*CMSG_RECIPIENT_ENCRYPTED_KEY_INFO,
};

pub const CMSG_MAIL_LIST_RECIPIENT_INFO = extern struct {
    dwVersion: u32,
    KeyId: CRYPTOAPI_BLOB,
    KeyEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    EncryptedKey: CRYPTOAPI_BLOB,
    Date: FILETIME,
    pOtherAttr: ?*CRYPT_ATTRIBUTE_TYPE_VALUE,
};

pub const CMSG_CMS_RECIPIENT_INFO = extern struct {
    dwRecipientChoice: u32,
    Anonymous: extern union {
        pKeyTrans: ?*CMSG_KEY_TRANS_RECIPIENT_INFO,
        pKeyAgree: ?*CMSG_KEY_AGREE_RECIPIENT_INFO,
        pMailList: ?*CMSG_MAIL_LIST_RECIPIENT_INFO,
    },
};

pub const CMSG_CTRL_VERIFY_SIGNATURE_EX_PARA = extern struct {
    cbSize: u32,
    hCryptProv: HCRYPTPROV_LEGACY,
    dwSignerIndex: u32,
    dwSignerType: u32,
    pvSigner: ?*anyopaque,
};

pub const CMSG_CTRL_DECRYPT_PARA = extern struct {
    cbSize: u32,
    Anonymous: extern union {
        hCryptProv: usize,
        hNCryptKey: NCRYPT_KEY_HANDLE,
    },
    dwKeySpec: u32,
    dwRecipientIndex: u32,
};

pub const CMSG_CTRL_KEY_TRANS_DECRYPT_PARA = extern struct {
    cbSize: u32,
    Anonymous: extern union {
        hCryptProv: usize,
        hNCryptKey: NCRYPT_KEY_HANDLE,
    },
    dwKeySpec: u32,
    pKeyTrans: ?*CMSG_KEY_TRANS_RECIPIENT_INFO,
    dwRecipientIndex: u32,
};

pub const CMSG_CTRL_KEY_AGREE_DECRYPT_PARA = extern struct {
    cbSize: u32,
    Anonymous: extern union {
        hCryptProv: usize,
        hNCryptKey: NCRYPT_KEY_HANDLE,
    },
    dwKeySpec: u32,
    pKeyAgree: ?*CMSG_KEY_AGREE_RECIPIENT_INFO,
    dwRecipientIndex: u32,
    dwRecipientEncryptedKeyIndex: u32,
    OriginatorPublicKey: CRYPT_BIT_BLOB,
};

pub const CMSG_CTRL_MAIL_LIST_DECRYPT_PARA = extern struct {
    cbSize: u32,
    hCryptProv: usize,
    pMailList: ?*CMSG_MAIL_LIST_RECIPIENT_INFO,
    dwRecipientIndex: u32,
    dwKeyChoice: u32,
    Anonymous: extern union {
        hKeyEncryptionKey: usize,
        pvKeyEncryptionKey: ?*anyopaque,
    },
};

pub const CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA = extern struct {
    cbSize: u32,
    dwSignerIndex: u32,
    blob: CRYPTOAPI_BLOB,
};

pub const CMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR_PARA = extern struct {
    cbSize: u32,
    dwSignerIndex: u32,
    dwUnauthAttrIndex: u32,
};

pub const PFN_CMSG_ALLOC = *const fn(
    cb: usize,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

pub const PFN_CMSG_FREE = *const fn(
    pv: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PFN_CMSG_GEN_ENCRYPT_KEY = *const fn(
    phCryptProv: ?*usize,
    paiEncrypt: ?*CRYPT_ALGORITHM_IDENTIFIER,
    pvEncryptAuxInfo: ?*anyopaque,
    pPublicKeyInfo: ?*CERT_PUBLIC_KEY_INFO,
    pfnAlloc: ?PFN_CMSG_ALLOC,
    phEncryptKey: ?*usize,
    ppbEncryptParameters: ?*?*u8,
    pcbEncryptParameters: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CMSG_EXPORT_ENCRYPT_KEY = *const fn(
    hCryptProv: usize,
    hEncryptKey: usize,
    pPublicKeyInfo: ?*CERT_PUBLIC_KEY_INFO,
    // TODO: what to do with BytesParamIndex 4?
    pbData: ?*u8,
    pcbData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CMSG_IMPORT_ENCRYPT_KEY = *const fn(
    hCryptProv: usize,
    dwKeySpec: u32,
    paiEncrypt: ?*CRYPT_ALGORITHM_IDENTIFIER,
    paiPubKey: ?*CRYPT_ALGORITHM_IDENTIFIER,
    // TODO: what to do with BytesParamIndex 5?
    pbEncodedKey: ?*u8,
    cbEncodedKey: u32,
    phEncryptKey: ?*usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CMSG_CONTENT_ENCRYPT_INFO = extern struct {
    cbSize: u32,
    hCryptProv: HCRYPTPROV_LEGACY,
    ContentEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pvEncryptionAuxInfo: ?*anyopaque,
    cRecipients: u32,
    rgCmsRecipients: ?*CMSG_RECIPIENT_ENCODE_INFO,
    pfnAlloc: ?PFN_CMSG_ALLOC,
    pfnFree: ?PFN_CMSG_FREE,
    dwEncryptFlags: u32,
    Anonymous: extern union {
        hContentEncryptKey: usize,
        hCNGContentEncryptKey: BCRYPT_KEY_HANDLE,
    },
    dwFlags: u32,
    fCNG: BOOL,
    pbCNGContentEncryptKeyObject: ?*u8,
    pbContentEncryptKey: ?*u8,
    cbContentEncryptKey: u32,
};

pub const PFN_CMSG_GEN_CONTENT_ENCRYPT_KEY = *const fn(
    pContentEncryptInfo: ?*CMSG_CONTENT_ENCRYPT_INFO,
    dwFlags: u32,
    pvReserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CMSG_KEY_TRANS_ENCRYPT_INFO = extern struct {
    cbSize: u32,
    dwRecipientIndex: u32,
    KeyEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    EncryptedKey: CRYPTOAPI_BLOB,
    dwFlags: u32,
};

pub const PFN_CMSG_EXPORT_KEY_TRANS = *const fn(
    pContentEncryptInfo: ?*CMSG_CONTENT_ENCRYPT_INFO,
    pKeyTransEncodeInfo: ?*CMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO,
    pKeyTransEncryptInfo: ?*CMSG_KEY_TRANS_ENCRYPT_INFO,
    dwFlags: u32,
    pvReserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CMSG_KEY_AGREE_KEY_ENCRYPT_INFO = extern struct {
    cbSize: u32,
    EncryptedKey: CRYPTOAPI_BLOB,
};

pub const CMSG_KEY_AGREE_ENCRYPT_INFO = extern struct {
    cbSize: u32,
    dwRecipientIndex: u32,
    KeyEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    UserKeyingMaterial: CRYPTOAPI_BLOB,
    dwOriginatorChoice: CMSG_KEY_AGREE_ORIGINATOR,
    Anonymous: extern union {
        OriginatorCertId: CERT_ID,
        OriginatorPublicKeyInfo: CERT_PUBLIC_KEY_INFO,
    },
    cKeyAgreeKeyEncryptInfo: u32,
    rgpKeyAgreeKeyEncryptInfo: ?*?*CMSG_KEY_AGREE_KEY_ENCRYPT_INFO,
    dwFlags: u32,
};

pub const PFN_CMSG_EXPORT_KEY_AGREE = *const fn(
    pContentEncryptInfo: ?*CMSG_CONTENT_ENCRYPT_INFO,
    pKeyAgreeEncodeInfo: ?*CMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO,
    pKeyAgreeEncryptInfo: ?*CMSG_KEY_AGREE_ENCRYPT_INFO,
    dwFlags: u32,
    pvReserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CMSG_MAIL_LIST_ENCRYPT_INFO = extern struct {
    cbSize: u32,
    dwRecipientIndex: u32,
    KeyEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    EncryptedKey: CRYPTOAPI_BLOB,
    dwFlags: u32,
};

pub const PFN_CMSG_EXPORT_MAIL_LIST = *const fn(
    pContentEncryptInfo: ?*CMSG_CONTENT_ENCRYPT_INFO,
    pMailListEncodeInfo: ?*CMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO,
    pMailListEncryptInfo: ?*CMSG_MAIL_LIST_ENCRYPT_INFO,
    dwFlags: u32,
    pvReserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CMSG_IMPORT_KEY_TRANS = *const fn(
    pContentEncryptionAlgorithm: ?*CRYPT_ALGORITHM_IDENTIFIER,
    pKeyTransDecryptPara: ?*CMSG_CTRL_KEY_TRANS_DECRYPT_PARA,
    dwFlags: u32,
    pvReserved: ?*anyopaque,
    phContentEncryptKey: ?*usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CMSG_IMPORT_KEY_AGREE = *const fn(
    pContentEncryptionAlgorithm: ?*CRYPT_ALGORITHM_IDENTIFIER,
    pKeyAgreeDecryptPara: ?*CMSG_CTRL_KEY_AGREE_DECRYPT_PARA,
    dwFlags: u32,
    pvReserved: ?*anyopaque,
    phContentEncryptKey: ?*usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CMSG_IMPORT_MAIL_LIST = *const fn(
    pContentEncryptionAlgorithm: ?*CRYPT_ALGORITHM_IDENTIFIER,
    pMailListDecryptPara: ?*CMSG_CTRL_MAIL_LIST_DECRYPT_PARA,
    dwFlags: u32,
    pvReserved: ?*anyopaque,
    phContentEncryptKey: ?*usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CMSG_CNG_CONTENT_DECRYPT_INFO = extern struct {
    cbSize: u32,
    ContentEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pfnAlloc: ?PFN_CMSG_ALLOC,
    pfnFree: ?PFN_CMSG_FREE,
    hNCryptKey: NCRYPT_KEY_HANDLE,
    pbContentEncryptKey: ?*u8,
    cbContentEncryptKey: u32,
    hCNGContentEncryptKey: BCRYPT_KEY_HANDLE,
    pbCNGContentEncryptKeyObject: ?*u8,
};

pub const PFN_CMSG_CNG_IMPORT_KEY_TRANS = *const fn(
    pCNGContentDecryptInfo: ?*CMSG_CNG_CONTENT_DECRYPT_INFO,
    pKeyTransDecryptPara: ?*CMSG_CTRL_KEY_TRANS_DECRYPT_PARA,
    dwFlags: u32,
    pvReserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CMSG_CNG_IMPORT_KEY_AGREE = *const fn(
    pCNGContentDecryptInfo: ?*CMSG_CNG_CONTENT_DECRYPT_INFO,
    pKeyAgreeDecryptPara: ?*CMSG_CTRL_KEY_AGREE_DECRYPT_PARA,
    dwFlags: u32,
    pvReserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CMSG_CNG_IMPORT_CONTENT_ENCRYPT_KEY = *const fn(
    pCNGContentDecryptInfo: ?*CMSG_CNG_CONTENT_DECRYPT_INFO,
    dwFlags: u32,
    pvReserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CERT_CONTEXT = extern struct {
    dwCertEncodingType: u32,
    pbCertEncoded: ?*u8,
    cbCertEncoded: u32,
    pCertInfo: ?*CERT_INFO,
    hCertStore: ?HCERTSTORE,
};

pub const CRL_CONTEXT = extern struct {
    dwCertEncodingType: u32,
    pbCrlEncoded: ?*u8,
    cbCrlEncoded: u32,
    pCrlInfo: ?*CRL_INFO,
    hCertStore: ?HCERTSTORE,
};

pub const CTL_CONTEXT = extern struct {
    dwMsgAndCertEncodingType: u32,
    pbCtlEncoded: ?*u8,
    cbCtlEncoded: u32,
    pCtlInfo: ?*CTL_INFO,
    hCertStore: ?HCERTSTORE,
    hCryptMsg: ?*anyopaque,
    pbCtlContent: ?*u8,
    cbCtlContent: u32,
};

pub const CertKeyType = enum(u32) {
    Other = 0,
    VirtualSmartCard = 1,
    PhysicalSmartCard = 2,
    Passport = 3,
    PassportRemote = 4,
    PassportSmartCard = 5,
    Hardware = 6,
    Software = 7,
    SelfSigned = 8,
};
pub const KeyTypeOther = CertKeyType.Other;
pub const KeyTypeVirtualSmartCard = CertKeyType.VirtualSmartCard;
pub const KeyTypePhysicalSmartCard = CertKeyType.PhysicalSmartCard;
pub const KeyTypePassport = CertKeyType.Passport;
pub const KeyTypePassportRemote = CertKeyType.PassportRemote;
pub const KeyTypePassportSmartCard = CertKeyType.PassportSmartCard;
pub const KeyTypeHardware = CertKeyType.Hardware;
pub const KeyTypeSoftware = CertKeyType.Software;
pub const KeyTypeSelfSigned = CertKeyType.SelfSigned;

pub const CRYPT_KEY_PROV_PARAM = extern struct {
    dwParam: u32,
    pbData: ?*u8,
    cbData: u32,
    dwFlags: u32,
};

pub const CRYPT_KEY_PROV_INFO = extern struct {
    pwszContainerName: ?PWSTR,
    pwszProvName: ?PWSTR,
    dwProvType: u32,
    dwFlags: CRYPT_KEY_FLAGS,
    cProvParam: u32,
    rgProvParam: ?*CRYPT_KEY_PROV_PARAM,
    dwKeySpec: u32,
};

pub const CERT_KEY_CONTEXT = extern struct {
    cbSize: u32,
    Anonymous: extern union {
        hCryptProv: usize,
        hNCryptKey: NCRYPT_KEY_HANDLE,
    },
    dwKeySpec: u32,
};

pub const ROOT_INFO_LUID = extern struct {
    LowPart: u32,
    HighPart: i32,
};

pub const CRYPT_SMART_CARD_ROOT_INFO = extern struct {
    rgbCardID: [16]u8,
    luid: ROOT_INFO_LUID,
};

pub const CERT_SYSTEM_STORE_RELOCATE_PARA = extern struct {
    Anonymous1: extern union {
        hKeyBase: ?HKEY,
        pvBase: ?*anyopaque,
    },
    Anonymous2: extern union {
        pvSystemStore: ?*anyopaque,
        pszSystemStore: ?[*:0]const u8,
        pwszSystemStore: ?[*:0]const u16,
    },
};

pub const CERT_REGISTRY_STORE_CLIENT_GPT_PARA = extern struct {
    hKeyBase: ?HKEY,
    pwszRegPath: ?PWSTR,
};

pub const CERT_REGISTRY_STORE_ROAMING_PARA = extern struct {
    hKey: ?HKEY,
    pwszStoreDirectory: ?PWSTR,
};

pub const CERT_LDAP_STORE_OPENED_PARA = extern struct {
    pvLdapSessionHandle: ?*anyopaque,
    pwszLdapUrl: ?[*:0]const u16,
};

pub const CERT_STORE_PROV_INFO = extern struct {
    cbSize: u32,
    cStoreProvFunc: u32,
    rgpvStoreProvFunc: ?*?*anyopaque,
    hStoreProv: ?HCERTSTOREPROV,
    dwStoreProvFlags: CERT_STORE_PROV_FLAGS,
    hStoreProvFuncAddr2: ?*anyopaque,
};

pub const PFN_CERT_DLL_OPEN_STORE_PROV_FUNC = *const fn(
    lpszStoreProvider: ?[*:0]const u8,
    dwEncodingType: CERT_QUERY_ENCODING_TYPE,
    hCryptProv: HCRYPTPROV_LEGACY,
    dwFlags: CERT_OPEN_STORE_FLAGS,
    pvPara: ?*const anyopaque,
    hCertStore: ?HCERTSTORE,
    pStoreProvInfo: ?*CERT_STORE_PROV_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_STORE_PROV_CLOSE = *const fn(
    hStoreProv: ?HCERTSTOREPROV,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PFN_CERT_STORE_PROV_READ_CERT = *const fn(
    hStoreProv: ?HCERTSTOREPROV,
    pStoreCertContext: ?*const CERT_CONTEXT,
    dwFlags: u32,
    ppProvCertContext: ?*?*CERT_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_STORE_PROV_WRITE_CERT = *const fn(
    hStoreProv: ?HCERTSTOREPROV,
    pCertContext: ?*const CERT_CONTEXT,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_STORE_PROV_DELETE_CERT = *const fn(
    hStoreProv: ?HCERTSTOREPROV,
    pCertContext: ?*const CERT_CONTEXT,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_STORE_PROV_SET_CERT_PROPERTY = *const fn(
    hStoreProv: ?HCERTSTOREPROV,
    pCertContext: ?*const CERT_CONTEXT,
    dwPropId: u32,
    dwFlags: u32,
    pvData: ?*const anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_STORE_PROV_READ_CRL = *const fn(
    hStoreProv: ?HCERTSTOREPROV,
    pStoreCrlContext: ?*CRL_CONTEXT,
    dwFlags: u32,
    ppProvCrlContext: ?*?*CRL_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_STORE_PROV_WRITE_CRL = *const fn(
    hStoreProv: ?HCERTSTOREPROV,
    pCrlContext: ?*CRL_CONTEXT,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_STORE_PROV_DELETE_CRL = *const fn(
    hStoreProv: ?HCERTSTOREPROV,
    pCrlContext: ?*CRL_CONTEXT,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_STORE_PROV_SET_CRL_PROPERTY = *const fn(
    hStoreProv: ?HCERTSTOREPROV,
    pCrlContext: ?*CRL_CONTEXT,
    dwPropId: u32,
    dwFlags: u32,
    pvData: ?*const anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_STORE_PROV_READ_CTL = *const fn(
    hStoreProv: ?HCERTSTOREPROV,
    pStoreCtlContext: ?*CTL_CONTEXT,
    dwFlags: u32,
    ppProvCtlContext: ?*?*CTL_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_STORE_PROV_WRITE_CTL = *const fn(
    hStoreProv: ?HCERTSTOREPROV,
    pCtlContext: ?*CTL_CONTEXT,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_STORE_PROV_DELETE_CTL = *const fn(
    hStoreProv: ?HCERTSTOREPROV,
    pCtlContext: ?*CTL_CONTEXT,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_STORE_PROV_SET_CTL_PROPERTY = *const fn(
    hStoreProv: ?HCERTSTOREPROV,
    pCtlContext: ?*CTL_CONTEXT,
    dwPropId: u32,
    dwFlags: u32,
    pvData: ?*const anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_STORE_PROV_CONTROL = *const fn(
    hStoreProv: ?HCERTSTOREPROV,
    dwFlags: u32,
    dwCtrlType: u32,
    pvCtrlPara: ?*const anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CERT_STORE_PROV_FIND_INFO = extern struct {
    cbSize: u32,
    dwMsgAndCertEncodingType: u32,
    dwFindFlags: u32,
    dwFindType: u32,
    pvFindPara: ?*const anyopaque,
};

pub const PFN_CERT_STORE_PROV_FIND_CERT = *const fn(
    hStoreProv: ?HCERTSTOREPROV,
    pFindInfo: ?*CERT_STORE_PROV_FIND_INFO,
    pPrevCertContext: ?*const CERT_CONTEXT,
    dwFlags: u32,
    ppvStoreProvFindInfo: ?*?*anyopaque,
    ppProvCertContext: ?*?*CERT_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_STORE_PROV_FREE_FIND_CERT = *const fn(
    hStoreProv: ?HCERTSTOREPROV,
    pCertContext: ?*const CERT_CONTEXT,
    pvStoreProvFindInfo: ?*anyopaque,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_STORE_PROV_GET_CERT_PROPERTY = *const fn(
    hStoreProv: ?HCERTSTOREPROV,
    pCertContext: ?*const CERT_CONTEXT,
    dwPropId: u32,
    dwFlags: u32,
    // TODO: what to do with BytesParamIndex 5?
    pvData: ?*anyopaque,
    pcbData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_STORE_PROV_FIND_CRL = *const fn(
    hStoreProv: ?HCERTSTOREPROV,
    pFindInfo: ?*CERT_STORE_PROV_FIND_INFO,
    pPrevCrlContext: ?*CRL_CONTEXT,
    dwFlags: u32,
    ppvStoreProvFindInfo: ?*?*anyopaque,
    ppProvCrlContext: ?*?*CRL_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_STORE_PROV_FREE_FIND_CRL = *const fn(
    hStoreProv: ?HCERTSTOREPROV,
    pCrlContext: ?*CRL_CONTEXT,
    pvStoreProvFindInfo: ?*anyopaque,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_STORE_PROV_GET_CRL_PROPERTY = *const fn(
    hStoreProv: ?HCERTSTOREPROV,
    pCrlContext: ?*CRL_CONTEXT,
    dwPropId: u32,
    dwFlags: u32,
    // TODO: what to do with BytesParamIndex 5?
    pvData: ?*anyopaque,
    pcbData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_STORE_PROV_FIND_CTL = *const fn(
    hStoreProv: ?HCERTSTOREPROV,
    pFindInfo: ?*CERT_STORE_PROV_FIND_INFO,
    pPrevCtlContext: ?*CTL_CONTEXT,
    dwFlags: u32,
    ppvStoreProvFindInfo: ?*?*anyopaque,
    ppProvCtlContext: ?*?*CTL_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_STORE_PROV_FREE_FIND_CTL = *const fn(
    hStoreProv: ?HCERTSTOREPROV,
    pCtlContext: ?*CTL_CONTEXT,
    pvStoreProvFindInfo: ?*anyopaque,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_STORE_PROV_GET_CTL_PROPERTY = *const fn(
    hStoreProv: ?HCERTSTOREPROV,
    pCtlContext: ?*CTL_CONTEXT,
    dwPropId: u32,
    dwFlags: u32,
    // TODO: what to do with BytesParamIndex 5?
    pvData: ?*anyopaque,
    pcbData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CRL_FIND_ISSUED_FOR_PARA = extern struct {
    pSubjectCert: ?*const CERT_CONTEXT,
    pIssuerCert: ?*const CERT_CONTEXT,
};

pub const CTL_ANY_SUBJECT_INFO = extern struct {
    SubjectAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    SubjectIdentifier: CRYPTOAPI_BLOB,
};

pub const CTL_FIND_USAGE_PARA = extern struct {
    cbSize: u32,
    SubjectUsage: CTL_USAGE,
    ListIdentifier: CRYPTOAPI_BLOB,
    pSigner: ?*CERT_INFO,
};

pub const CTL_FIND_SUBJECT_PARA = extern struct {
    cbSize: u32,
    pUsagePara: ?*CTL_FIND_USAGE_PARA,
    dwSubjectType: u32,
    pvSubject: ?*anyopaque,
};

pub const PFN_CERT_CREATE_CONTEXT_SORT_FUNC = *const fn(
    cbTotalEncoded: u32,
    cbRemainEncoded: u32,
    cEntry: u32,
    pvSort: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CERT_CREATE_CONTEXT_PARA = extern struct {
    cbSize: u32,
    pfnFree: ?PFN_CRYPT_FREE,
    pvFree: ?*anyopaque,
    pfnSort: ?PFN_CERT_CREATE_CONTEXT_SORT_FUNC,
    pvSort: ?*anyopaque,
};

pub const CERT_SYSTEM_STORE_INFO = extern struct {
    cbSize: u32,
};

pub const CERT_PHYSICAL_STORE_INFO = extern struct {
    cbSize: u32,
    pszOpenStoreProvider: ?PSTR,
    dwOpenEncodingType: u32,
    dwOpenFlags: u32,
    OpenParameters: CRYPTOAPI_BLOB,
    dwFlags: u32,
    dwPriority: u32,
};

pub const PFN_CERT_ENUM_SYSTEM_STORE_LOCATION = *const fn(
    pwszStoreLocation: ?[*:0]const u16,
    dwFlags: u32,
    pvReserved: ?*anyopaque,
    pvArg: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_ENUM_SYSTEM_STORE = *const fn(
    pvSystemStore: ?*const anyopaque,
    dwFlags: CERT_SYSTEM_STORE_FLAGS,
    pStoreInfo: ?*CERT_SYSTEM_STORE_INFO,
    pvReserved: ?*anyopaque,
    pvArg: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_ENUM_PHYSICAL_STORE = *const fn(
    pvSystemStore: ?*const anyopaque,
    dwFlags: u32,
    pwszStoreName: ?[*:0]const u16,
    pStoreInfo: ?*CERT_PHYSICAL_STORE_INFO,
    pvReserved: ?*anyopaque,
    pvArg: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CTL_VERIFY_USAGE_PARA = extern struct {
    cbSize: u32,
    ListIdentifier: CRYPTOAPI_BLOB,
    cCtlStore: u32,
    rghCtlStore: ?*?HCERTSTORE,
    cSignerStore: u32,
    rghSignerStore: ?*?HCERTSTORE,
};

pub const CTL_VERIFY_USAGE_STATUS = extern struct {
    cbSize: u32,
    dwError: u32,
    dwFlags: u32,
    ppCtl: ?*?*CTL_CONTEXT,
    dwCtlEntryIndex: u32,
    ppSigner: ?*?*CERT_CONTEXT,
    dwSignerIndex: u32,
};

pub const CERT_REVOCATION_CRL_INFO = extern struct {
    cbSize: u32,
    pBaseCrlContext: ?*CRL_CONTEXT,
    pDeltaCrlContext: ?*CRL_CONTEXT,
    pCrlEntry: ?*CRL_ENTRY,
    fDeltaCrlEntry: BOOL,
};

pub const CERT_REVOCATION_PARA = extern struct {
    cbSize: u32,
    pIssuerCert: ?*const CERT_CONTEXT,
    cCertStore: u32,
    rgCertStore: ?*?HCERTSTORE,
    hCrlStore: ?HCERTSTORE,
    pftTimeToUse: ?*FILETIME,
};

pub const CERT_REVOCATION_STATUS = extern struct {
    cbSize: u32,
    dwIndex: u32,
    dwError: u32,
    dwReason: CERT_REVOCATION_STATUS_REASON,
    fHasFreshnessTime: BOOL,
    dwFreshnessTime: u32,
};

pub const CRYPT_VERIFY_CERT_SIGN_STRONG_PROPERTIES_INFO = extern struct {
    CertSignHashCNGAlgPropData: CRYPTOAPI_BLOB,
    CertIssuerPubKeyBitLengthPropData: CRYPTOAPI_BLOB,
};

pub const CRYPT_VERIFY_CERT_SIGN_WEAK_HASH_INFO = extern struct {
    cCNGHashAlgid: u32,
    rgpwszCNGHashAlgid: ?*?PWSTR,
    dwWeakIndex: u32,
};

pub const PFN_CRYPT_EXTRACT_ENCODED_SIGNATURE_PARAMETERS_FUNC = *const fn(
    dwCertEncodingType: u32,
    pSignatureAlgorithm: ?*CRYPT_ALGORITHM_IDENTIFIER,
    ppvDecodedSignPara: ?*?*anyopaque,
    ppwszCNGHashAlgid: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CRYPT_SIGN_AND_ENCODE_HASH_FUNC = *const fn(
    hKey: NCRYPT_KEY_HANDLE,
    dwCertEncodingType: u32,
    pSignatureAlgorithm: ?*CRYPT_ALGORITHM_IDENTIFIER,
    pvDecodedSignPara: ?*anyopaque,
    pwszCNGPubKeyAlgid: ?[*:0]const u16,
    pwszCNGHashAlgid: ?[*:0]const u16,
    // TODO: what to do with BytesParamIndex 7?
    pbComputedHash: ?*u8,
    cbComputedHash: u32,
    // TODO: what to do with BytesParamIndex 9?
    pbSignature: ?*u8,
    pcbSignature: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CRYPT_VERIFY_ENCODED_SIGNATURE_FUNC = *const fn(
    dwCertEncodingType: u32,
    pPubKeyInfo: ?*CERT_PUBLIC_KEY_INFO,
    pSignatureAlgorithm: ?*CRYPT_ALGORITHM_IDENTIFIER,
    pvDecodedSignPara: ?*anyopaque,
    pwszCNGPubKeyAlgid: ?[*:0]const u16,
    pwszCNGHashAlgid: ?[*:0]const u16,
    // TODO: what to do with BytesParamIndex 7?
    pbComputedHash: ?*u8,
    cbComputedHash: u32,
    // TODO: what to do with BytesParamIndex 9?
    pbSignature: ?*u8,
    cbSignature: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CRYPT_DEFAULT_CONTEXT_MULTI_OID_PARA = extern struct {
    cOID: u32,
    rgpszOID: ?*?PSTR,
};

pub const PFN_CRYPT_EXPORT_PUBLIC_KEY_INFO_EX2_FUNC = *const fn(
    hNCryptKey: NCRYPT_KEY_HANDLE,
    dwCertEncodingType: u32,
    pszPublicKeyObjId: ?PSTR,
    dwFlags: u32,
    pvAuxInfo: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 6?
    pInfo: ?*CERT_PUBLIC_KEY_INFO,
    pcbInfo: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CRYPT_EXPORT_PUBLIC_KEY_INFO_FROM_BCRYPT_HANDLE_FUNC = *const fn(
    hBCryptKey: BCRYPT_KEY_HANDLE,
    dwCertEncodingType: u32,
    pszPublicKeyObjId: ?PSTR,
    dwFlags: u32,
    pvAuxInfo: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 6?
    pInfo: ?*CERT_PUBLIC_KEY_INFO,
    pcbInfo: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_IMPORT_PUBLIC_KEY_INFO_EX2_FUNC = *const fn(
    dwCertEncodingType: u32,
    pInfo: ?*CERT_PUBLIC_KEY_INFO,
    dwFlags: u32,
    pvAuxInfo: ?*anyopaque,
    phKey: ?*BCRYPT_KEY_HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_IMPORT_PRIV_KEY_FUNC = *const fn(
    hCryptProv: usize,
    pPrivateKeyInfo: ?*CRYPT_PRIVATE_KEY_INFO,
    dwFlags: u32,
    pvAuxInfo: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_EXPORT_PRIV_KEY_FUNC = *const fn(
    hCryptProv: usize,
    dwKeySpec: u32,
    pszPrivateKeyObjId: ?PSTR,
    dwFlags: u32,
    pvAuxInfo: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 6?
    pPrivateKeyInfo: ?*CRYPT_PRIVATE_KEY_INFO,
    pcbPrivateKeyInfo: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CRYPT_GET_SIGNER_CERTIFICATE = *const fn(
    pvGetArg: ?*anyopaque,
    dwCertEncodingType: u32,
    pSignerId: ?*CERT_INFO,
    hMsgCertStore: ?HCERTSTORE,
) callconv(@import("std").os.windows.WINAPI) ?*CERT_CONTEXT;

pub const CRYPT_SIGN_MESSAGE_PARA = extern struct {
    cbSize: u32,
    dwMsgEncodingType: u32,
    pSigningCert: ?*const CERT_CONTEXT,
    HashAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pvHashAuxInfo: ?*anyopaque,
    cMsgCert: u32,
    rgpMsgCert: ?*?*CERT_CONTEXT,
    cMsgCrl: u32,
    rgpMsgCrl: ?*?*CRL_CONTEXT,
    cAuthAttr: u32,
    rgAuthAttr: ?*CRYPT_ATTRIBUTE,
    cUnauthAttr: u32,
    rgUnauthAttr: ?*CRYPT_ATTRIBUTE,
    dwFlags: u32,
    dwInnerContentType: u32,
};

pub const CRYPT_VERIFY_MESSAGE_PARA = extern struct {
    cbSize: u32,
    dwMsgAndCertEncodingType: u32,
    hCryptProv: HCRYPTPROV_LEGACY,
    pfnGetSignerCertificate: ?PFN_CRYPT_GET_SIGNER_CERTIFICATE,
    pvGetArg: ?*anyopaque,
};

pub const CRYPT_ENCRYPT_MESSAGE_PARA = extern struct {
    cbSize: u32,
    dwMsgEncodingType: u32,
    hCryptProv: HCRYPTPROV_LEGACY,
    ContentEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pvEncryptionAuxInfo: ?*anyopaque,
    dwFlags: u32,
    dwInnerContentType: u32,
};

pub const CRYPT_DECRYPT_MESSAGE_PARA = extern struct {
    cbSize: u32,
    dwMsgAndCertEncodingType: u32,
    cCertStore: u32,
    rghCertStore: ?*?HCERTSTORE,
};

pub const CRYPT_HASH_MESSAGE_PARA = extern struct {
    cbSize: u32,
    dwMsgEncodingType: u32,
    hCryptProv: HCRYPTPROV_LEGACY,
    HashAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pvHashAuxInfo: ?*anyopaque,
};

pub const CRYPT_KEY_SIGN_MESSAGE_PARA = extern struct {
    cbSize: u32,
    dwMsgAndCertEncodingType: CERT_QUERY_ENCODING_TYPE,
    Anonymous: extern union {
        hCryptProv: usize,
        hNCryptKey: NCRYPT_KEY_HANDLE,
    },
    dwKeySpec: CERT_KEY_SPEC,
    HashAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pvHashAuxInfo: ?*anyopaque,
    PubKeyAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
};

pub const CRYPT_KEY_VERIFY_MESSAGE_PARA = extern struct {
    cbSize: u32,
    dwMsgEncodingType: u32,
    hCryptProv: HCRYPTPROV_LEGACY,
};

pub const CERT_CHAIN = extern struct {
    cCerts: u32,
    certs: ?*CRYPTOAPI_BLOB,
    keyLocatorInfo: CRYPT_KEY_PROV_INFO,
};

pub const PFN_CRYPT_ASYNC_PARAM_FREE_FUNC = *const fn(
    pszParamOid: ?PSTR,
    pvParam: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

pub const CRYPT_BLOB_ARRAY = extern struct {
    cBlob: u32,
    rgBlob: ?*CRYPTOAPI_BLOB,
};

pub const CRYPT_CREDENTIALS = extern struct {
    cbSize: u32,
    pszCredentialsOid: ?[*:0]const u8,
    pvCredentials: ?*anyopaque,
};

pub const CRYPT_PASSWORD_CREDENTIALSA = extern struct {
    cbSize: u32,
    pszUsername: ?PSTR,
    pszPassword: ?PSTR,
};

pub const CRYPT_PASSWORD_CREDENTIALSW = extern struct {
    cbSize: u32,
    pszUsername: ?PWSTR,
    pszPassword: ?PWSTR,
};

pub const PFN_FREE_ENCODED_OBJECT_FUNC = *const fn(
    pszObjectOid: ?[*:0]const u8,
    pObject: ?*CRYPT_BLOB_ARRAY,
    pvFreeContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

pub const CRYPTNET_URL_CACHE_PRE_FETCH_INFO = extern struct {
    cbSize: u32,
    dwObjectType: u32,
    dwError: u32,
    dwReserved: u32,
    ThisUpdateTime: FILETIME,
    NextUpdateTime: FILETIME,
    PublishTime: FILETIME,
};

pub const CRYPTNET_URL_CACHE_FLUSH_INFO = extern struct {
    cbSize: u32,
    dwExemptSeconds: u32,
    ExpireTime: FILETIME,
};

pub const CRYPTNET_URL_CACHE_RESPONSE_INFO = extern struct {
    cbSize: u32,
    wResponseType: u16,
    wResponseFlags: u16,
    LastModifiedTime: FILETIME,
    dwMaxAge: u32,
    pwszETag: ?[*:0]const u16,
    dwProxyId: u32,
};

pub const CRYPT_RETRIEVE_AUX_INFO = extern struct {
    cbSize: u32,
    pLastSyncTime: ?*FILETIME,
    dwMaxUrlRetrievalByteCount: u32,
    pPreFetchInfo: ?*CRYPTNET_URL_CACHE_PRE_FETCH_INFO,
    pFlushInfo: ?*CRYPTNET_URL_CACHE_FLUSH_INFO,
    ppResponseInfo: ?*?*CRYPTNET_URL_CACHE_RESPONSE_INFO,
    pwszCacheFileNamePrefix: ?PWSTR,
    pftCacheResync: ?*FILETIME,
    fProxyCacheRetrieval: BOOL,
    dwHttpStatusCode: u32,
    ppwszErrorResponseHeaders: ?*?PWSTR,
    ppErrorContentBlob: ?*?*CRYPTOAPI_BLOB,
};

pub const PFN_CRYPT_CANCEL_RETRIEVAL = *const fn(
    dwFlags: u32,
    pvArg: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CRYPT_ASYNC_RETRIEVAL_COMPLETION_FUNC = *const fn(
    pvCompletion: ?*anyopaque,
    dwCompletionCode: u32,
    pszUrl: ?[*:0]const u8,
    pszObjectOid: ?PSTR,
    pvObject: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

pub const CRYPT_ASYNC_RETRIEVAL_COMPLETION = extern struct {
    pfnCompletion: ?PFN_CRYPT_ASYNC_RETRIEVAL_COMPLETION_FUNC,
    pvCompletion: ?*anyopaque,
};

pub const PFN_CANCEL_ASYNC_RETRIEVAL_FUNC = *const fn(
    hAsyncRetrieve: ?HCRYPTASYNC,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CRYPT_URL_ARRAY = extern struct {
    cUrl: u32,
    rgwszUrl: ?*?PWSTR,
};

pub const CRYPT_URL_INFO = extern struct {
    cbSize: u32,
    dwSyncDeltaTime: u32,
    cGroup: u32,
    rgcGroupEntry: ?*u32,
};

pub const CERT_CRL_CONTEXT_PAIR = extern struct {
    pCertContext: ?*const CERT_CONTEXT,
    pCrlContext: ?*CRL_CONTEXT,
};

pub const CRYPT_GET_TIME_VALID_OBJECT_EXTRA_INFO = extern struct {
    cbSize: u32,
    iDeltaCrlIndicator: i32,
    pftCacheResync: ?*FILETIME,
    pLastSyncTime: ?*FILETIME,
    pMaxAgeTime: ?*FILETIME,
    pChainPara: ?*CERT_REVOCATION_CHAIN_PARA,
    pDeltaCrlIndicator: ?*CRYPTOAPI_BLOB,
};

pub const PFN_CRYPT_ENUM_KEYID_PROP = *const fn(
    pKeyIdentifier: ?*const CRYPTOAPI_BLOB,
    dwFlags: u32,
    pvReserved: ?*anyopaque,
    pvArg: ?*anyopaque,
    cProp: u32,
    rgdwPropId: [*]u32,
    rgpvData: [*]?*anyopaque,
    rgcbData: [*]u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CERT_CHAIN_ENGINE_CONFIG = extern struct {
    cbSize: u32,
    hRestrictedRoot: ?HCERTSTORE,
    hRestrictedTrust: ?HCERTSTORE,
    hRestrictedOther: ?HCERTSTORE,
    cAdditionalStore: u32,
    rghAdditionalStore: ?*?HCERTSTORE,
    dwFlags: u32,
    dwUrlRetrievalTimeout: u32,
    MaximumCachedCertificates: u32,
    CycleDetectionModulus: u32,
    hExclusiveRoot: ?HCERTSTORE,
    hExclusiveTrustedPeople: ?HCERTSTORE,
    dwExclusiveFlags: u32,
};

pub const CERT_TRUST_STATUS = extern struct {
    dwErrorStatus: u32,
    dwInfoStatus: u32,
};

pub const CERT_REVOCATION_INFO = extern struct {
    cbSize: u32,
    dwRevocationResult: u32,
    pszRevocationOid: ?[*:0]const u8,
    pvOidSpecificInfo: ?*anyopaque,
    fHasFreshnessTime: BOOL,
    dwFreshnessTime: u32,
    pCrlInfo: ?*CERT_REVOCATION_CRL_INFO,
};

pub const CERT_TRUST_LIST_INFO = extern struct {
    cbSize: u32,
    pCtlEntry: ?*CTL_ENTRY,
    pCtlContext: ?*CTL_CONTEXT,
};

pub const CERT_CHAIN_ELEMENT = extern struct {
    cbSize: u32,
    pCertContext: ?*const CERT_CONTEXT,
    TrustStatus: CERT_TRUST_STATUS,
    pRevocationInfo: ?*CERT_REVOCATION_INFO,
    pIssuanceUsage: ?*CTL_USAGE,
    pApplicationUsage: ?*CTL_USAGE,
    pwszExtendedErrorInfo: ?[*:0]const u16,
};

pub const CERT_SIMPLE_CHAIN = extern struct {
    cbSize: u32,
    TrustStatus: CERT_TRUST_STATUS,
    cElement: u32,
    rgpElement: ?*?*CERT_CHAIN_ELEMENT,
    pTrustListInfo: ?*CERT_TRUST_LIST_INFO,
    fHasRevocationFreshnessTime: BOOL,
    dwRevocationFreshnessTime: u32,
};

pub const CERT_CHAIN_CONTEXT = extern struct {
    cbSize: u32,
    TrustStatus: CERT_TRUST_STATUS,
    cChain: u32,
    rgpChain: ?*?*CERT_SIMPLE_CHAIN,
    cLowerQualityChainContext: u32,
    rgpLowerQualityChainContext: ?*?*CERT_CHAIN_CONTEXT,
    fHasRevocationFreshnessTime: BOOL,
    dwRevocationFreshnessTime: u32,
    dwCreateFlags: u32,
    ChainId: Guid,
};

pub const CERT_USAGE_MATCH = extern struct {
    dwType: u32,
    Usage: CTL_USAGE,
};

pub const CTL_USAGE_MATCH = extern struct {
    dwType: u32,
    Usage: CTL_USAGE,
};

pub const CERT_CHAIN_PARA = extern struct {
    cbSize: u32,
    RequestedUsage: CERT_USAGE_MATCH,
};

pub const CERT_REVOCATION_CHAIN_PARA = extern struct {
    cbSize: u32,
    hChainEngine: ?HCERTCHAINENGINE,
    hAdditionalStore: ?HCERTSTORE,
    dwChainFlags: u32,
    dwUrlRetrievalTimeout: u32,
    pftCurrentTime: ?*FILETIME,
    pftCacheResync: ?*FILETIME,
    cbMaxUrlRetrievalByteCount: u32,
};

pub const CRL_REVOCATION_INFO = extern struct {
    pCrlEntry: ?*CRL_ENTRY,
    pCrlContext: ?*CRL_CONTEXT,
    pCrlIssuerChain: ?*CERT_CHAIN_CONTEXT,
};

pub const PFN_CERT_CHAIN_FIND_BY_ISSUER_CALLBACK = *const fn(
    pCert: ?*const CERT_CONTEXT,
    pvFindArg: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CERT_CHAIN_FIND_BY_ISSUER_PARA = extern struct {
    cbSize: u32,
    pszUsageIdentifier: ?[*:0]const u8,
    dwKeySpec: u32,
    dwAcquirePrivateKeyFlags: u32,
    cIssuer: u32,
    rgIssuer: ?*CRYPTOAPI_BLOB,
    pfnFindCallback: ?PFN_CERT_CHAIN_FIND_BY_ISSUER_CALLBACK,
    pvFindArg: ?*anyopaque,
};

pub const CERT_CHAIN_POLICY_PARA = extern struct {
    cbSize: u32,
    dwFlags: CERT_CHAIN_POLICY_FLAGS,
    pvExtraPolicyPara: ?*anyopaque,
};

pub const CERT_CHAIN_POLICY_STATUS = extern struct {
    cbSize: u32,
    dwError: u32,
    lChainIndex: i32,
    lElementIndex: i32,
    pvExtraPolicyStatus: ?*anyopaque,
};

pub const AUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_PARA = extern struct {
    cbSize: u32,
    dwRegPolicySettings: u32,
    pSignerInfo: ?*CMSG_SIGNER_INFO,
};

pub const AUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_STATUS = extern struct {
    cbSize: u32,
    fCommercial: BOOL,
};

pub const AUTHENTICODE_TS_EXTRA_CERT_CHAIN_POLICY_PARA = extern struct {
    cbSize: u32,
    dwRegPolicySettings: u32,
    fCommercial: BOOL,
};

pub const HTTPSPolicyCallbackData = extern struct {
    Anonymous: extern union {
        cbStruct: u32,
        cbSize: u32,
    },
    dwAuthType: HTTPSPOLICY_CALLBACK_DATA_AUTH_TYPE,
    fdwChecks: u32,
    pwszServerName: ?PWSTR,
};

pub const EV_EXTRA_CERT_CHAIN_POLICY_PARA = extern struct {
    cbSize: u32,
    dwRootProgramQualifierFlags: CERT_ROOT_PROGRAM_FLAGS,
};

pub const EV_EXTRA_CERT_CHAIN_POLICY_STATUS = extern struct {
    cbSize: u32,
    dwQualifiers: u32,
    dwIssuanceUsageIndex: u32,
};

pub const SSL_F12_EXTRA_CERT_CHAIN_POLICY_STATUS = extern struct {
    cbSize: u32,
    dwErrorLevel: u32,
    dwErrorCategory: u32,
    dwReserved: u32,
    wszErrorText: [256]u16,
};

pub const SSL_HPKP_HEADER_EXTRA_CERT_CHAIN_POLICY_PARA = extern struct {
    cbSize: u32,
    dwReserved: u32,
    pwszServerName: ?PWSTR,
    rgpszHpkpValue: [2]?PSTR,
};

pub const SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_PARA = extern struct {
    cbSize: u32,
    dwReserved: u32,
    pwszServerName: ?[*:0]const u16,
};

pub const SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_STATUS = extern struct {
    cbSize: u32,
    lError: i32,
    wszErrorText: [512]u16,
};

pub const CRYPT_PKCS12_PBE_PARAMS = extern struct {
    iIterations: i32,
    cbSalt: u32,
};

pub const PKCS12_PBES2_EXPORT_PARAMS = extern struct {
    dwSize: u32,
    hNcryptDescriptor: ?*anyopaque,
    pwszPbes2Alg: ?PWSTR,
};

pub const CERT_SERVER_OCSP_RESPONSE_CONTEXT = extern struct {
    cbSize: u32,
    pbEncodedOcspResponse: ?*u8,
    cbEncodedOcspResponse: u32,
};

pub const PFN_CERT_SERVER_OCSP_RESPONSE_UPDATE_CALLBACK = *const fn(
    pChainContext: ?*CERT_CHAIN_CONTEXT,
    pServerOcspResponseContext: ?*CERT_SERVER_OCSP_RESPONSE_CONTEXT,
    pNewCrlContext: ?*CRL_CONTEXT,
    pPrevCrlContext: ?*CRL_CONTEXT,
    pvArg: ?*anyopaque,
    dwWriteOcspFileError: u32,
) callconv(@import("std").os.windows.WINAPI) void;

pub const CERT_SERVER_OCSP_RESPONSE_OPEN_PARA = extern struct {
    cbSize: u32,
    dwFlags: u32,
    pcbUsedSize: ?*u32,
    pwszOcspDirectory: ?PWSTR,
    pfnUpdateCallback: ?PFN_CERT_SERVER_OCSP_RESPONSE_UPDATE_CALLBACK,
    pvUpdateCallbackArg: ?*anyopaque,
};

pub const CERT_SELECT_CHAIN_PARA = extern struct {
    hChainEngine: ?HCERTCHAINENGINE,
    pTime: ?*FILETIME,
    hAdditionalStore: ?HCERTSTORE,
    pChainPara: ?*CERT_CHAIN_PARA,
    dwFlags: u32,
};

pub const CERT_SELECT_CRITERIA = extern struct {
    dwType: CERT_SELECT_CRITERIA_TYPE,
    cPara: u32,
    ppPara: ?*?*anyopaque,
};

pub const CRYPT_TIMESTAMP_REQUEST = extern struct {
    dwVersion: CRYPT_TIMESTAMP_VERSION,
    HashAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    HashedMessage: CRYPTOAPI_BLOB,
    pszTSAPolicyId: ?PSTR,
    Nonce: CRYPTOAPI_BLOB,
    fCertReq: BOOL,
    cExtension: u32,
    rgExtension: ?*CERT_EXTENSION,
};

pub const CRYPT_TIMESTAMP_RESPONSE = extern struct {
    dwStatus: CRYPT_TIMESTAMP_RESPONSE_STATUS,
    cFreeText: u32,
    rgFreeText: ?*?PWSTR,
    FailureInfo: CRYPT_BIT_BLOB,
    ContentInfo: CRYPTOAPI_BLOB,
};

pub const CRYPT_TIMESTAMP_ACCURACY = extern struct {
    dwSeconds: u32,
    dwMillis: u32,
    dwMicros: u32,
};

pub const CRYPT_TIMESTAMP_INFO = extern struct {
    dwVersion: u32,
    pszTSAPolicyId: ?PSTR,
    HashAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    HashedMessage: CRYPTOAPI_BLOB,
    SerialNumber: CRYPTOAPI_BLOB,
    ftTime: FILETIME,
    pvAccuracy: ?*CRYPT_TIMESTAMP_ACCURACY,
    fOrdering: BOOL,
    Nonce: CRYPTOAPI_BLOB,
    Tsa: CRYPTOAPI_BLOB,
    cExtension: u32,
    rgExtension: ?*CERT_EXTENSION,
};

pub const CRYPT_TIMESTAMP_CONTEXT = extern struct {
    cbEncoded: u32,
    pbEncoded: ?*u8,
    pTimeStamp: ?*CRYPT_TIMESTAMP_INFO,
};

pub const CRYPT_TIMESTAMP_PARA = extern struct {
    pszTSAPolicyId: ?[*:0]const u8,
    fRequestCerts: BOOL,
    Nonce: CRYPTOAPI_BLOB,
    cExtension: u32,
    rgExtension: ?*CERT_EXTENSION,
};

pub const PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FLUSH = *const fn(
    pContext: ?*anyopaque,
    rgIdentifierOrNameList: [*]?*CRYPTOAPI_BLOB,
    dwIdentifierOrNameListCount: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_GET = *const fn(
    pPluginContext: ?*anyopaque,
    pIdentifier: ?*CRYPTOAPI_BLOB,
    dwNameType: u32,
    pNameBlob: ?*CRYPTOAPI_BLOB,
    ppbContent: ?*?*u8,
    pcbContent: ?*u32,
    ppwszPassword: ?*?PWSTR,
    ppIdentifier: ?*?*CRYPTOAPI_BLOB,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_RELEASE = *const fn(
    dwReason: CRYPT_OBJECT_LOCATOR_RELEASE_REASON,
    pPluginContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FREE_PASSWORD = *const fn(
    pPluginContext: ?*anyopaque,
    pwszPassword: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FREE = *const fn(
    pPluginContext: ?*anyopaque,
    pbData: ?*u8,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FREE_IDENTIFIER = *const fn(
    pPluginContext: ?*anyopaque,
    pIdentifier: ?*CRYPTOAPI_BLOB,
) callconv(@import("std").os.windows.WINAPI) void;

pub const CRYPT_OBJECT_LOCATOR_PROVIDER_TABLE = extern struct {
    cbSize: u32,
    pfnGet: ?PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_GET,
    pfnRelease: ?PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_RELEASE,
    pfnFreePassword: ?PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FREE_PASSWORD,
    pfnFree: ?PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FREE,
    pfnFreeIdentifier: ?PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FREE_IDENTIFIER,
};

pub const PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_INITIALIZE = *const fn(
    pfnFlush: ?PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FLUSH,
    pContext: ?*anyopaque,
    pdwExpectedObjectCount: ?*u32,
    ppFuncTable: ?*?*CRYPT_OBJECT_LOCATOR_PROVIDER_TABLE,
    ppPluginContext: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_IS_WEAK_HASH = *const fn(
    dwHashUseType: u32,
    pwszCNGHashAlgid: ?[*:0]const u16,
    dwChainFlags: u32,
    pSignerChainContext: ?*CERT_CHAIN_CONTEXT,
    pTimeStamp: ?*FILETIME,
    pwszFileName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CRYPTPROTECT_PROMPTSTRUCT = extern struct {
    cbSize: u32,
    dwPromptFlags: u32,
    hwndApp: ?HWND,
    szPrompt: ?[*:0]const u16,
};

pub const PFNCryptStreamOutputCallback = *const fn(
    pvCallbackCtxt: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 2?
    pbData: ?*const u8,
    cbData: usize,
    fFinal: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const NCRYPT_PROTECT_STREAM_INFO = extern struct {
    pfnStreamOutput: ?PFNCryptStreamOutputCallback,
    pvCallbackCtxt: ?*anyopaque,
};

pub const PFNCryptStreamOutputCallbackEx = *const fn(
    pvCallbackCtxt: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 2?
    pbData: ?*const u8,
    cbData: usize,
    hDescriptor: NCRYPT_DESCRIPTOR_HANDLE,
    fFinal: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const NCRYPT_PROTECT_STREAM_INFO_EX = extern struct {
    pfnStreamOutput: ?PFNCryptStreamOutputCallbackEx,
    pvCallbackCtxt: ?*anyopaque,
};

pub const CRYPT_XML_CHARSET = enum(i32) {
    AUTO = 0,
    UTF8 = 1,
    UTF16LE = 2,
    UTF16BE = 3,
};
pub const CRYPT_XML_CHARSET_AUTO = CRYPT_XML_CHARSET.AUTO;
pub const CRYPT_XML_CHARSET_UTF8 = CRYPT_XML_CHARSET.UTF8;
pub const CRYPT_XML_CHARSET_UTF16LE = CRYPT_XML_CHARSET.UTF16LE;
pub const CRYPT_XML_CHARSET_UTF16BE = CRYPT_XML_CHARSET.UTF16BE;

pub const CRYPT_XML_BLOB = extern struct {
    dwCharset: CRYPT_XML_CHARSET,
    cbData: u32,
    pbData: ?*u8,
};

pub const CRYPT_XML_DATA_BLOB = extern struct {
    cbData: u32,
    pbData: ?*u8,
};

pub const CRYPT_XML_PROPERTY_ID = enum(i32) {
    MAX_HEAP_SIZE = 1,
    SIGNATURE_LOCATION = 2,
    MAX_SIGNATURES = 3,
    DOC_DECLARATION = 4,
    XML_OUTPUT_CHARSET = 5,
};
pub const CRYPT_XML_PROPERTY_MAX_HEAP_SIZE = CRYPT_XML_PROPERTY_ID.MAX_HEAP_SIZE;
pub const CRYPT_XML_PROPERTY_SIGNATURE_LOCATION = CRYPT_XML_PROPERTY_ID.SIGNATURE_LOCATION;
pub const CRYPT_XML_PROPERTY_MAX_SIGNATURES = CRYPT_XML_PROPERTY_ID.MAX_SIGNATURES;
pub const CRYPT_XML_PROPERTY_DOC_DECLARATION = CRYPT_XML_PROPERTY_ID.DOC_DECLARATION;
pub const CRYPT_XML_PROPERTY_XML_OUTPUT_CHARSET = CRYPT_XML_PROPERTY_ID.XML_OUTPUT_CHARSET;

pub const CRYPT_XML_PROPERTY = extern struct {
    dwPropId: CRYPT_XML_PROPERTY_ID,
    pvValue: ?*const anyopaque,
    cbValue: u32,
};

pub const PFN_CRYPT_XML_WRITE_CALLBACK = *const fn(
    pvCallbackState: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 2?
    pbData: ?*const u8,
    cbData: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PFN_CRYPT_XML_DATA_PROVIDER_READ = *const fn(
    pvCallbackState: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 2?
    pbData: ?*u8,
    cbData: u32,
    pcbRead: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PFN_CRYPT_XML_DATA_PROVIDER_CLOSE = *const fn(
    pvCallbackState: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const CRYPT_XML_DATA_PROVIDER = extern struct {
    pvCallbackState: ?*anyopaque,
    cbBufferSize: u32,
    pfnRead: ?PFN_CRYPT_XML_DATA_PROVIDER_READ,
    pfnClose: ?PFN_CRYPT_XML_DATA_PROVIDER_CLOSE,
};

pub const PFN_CRYPT_XML_CREATE_TRANSFORM = *const fn(
    pTransform: ?*const CRYPT_XML_ALGORITHM,
    pProviderIn: ?*CRYPT_XML_DATA_PROVIDER,
    pProviderOut: ?*CRYPT_XML_DATA_PROVIDER,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const CRYPT_XML_STATUS = extern struct {
    cbSize: u32,
    dwErrorStatus: CRYPT_XML_STATUS_ERROR_STATUS,
    dwInfoStatus: CRYPT_XML_STATUS_INFO_STATUS,
};

pub const CRYPT_XML_ALGORITHM = extern struct {
    cbSize: u32,
    wszAlgorithm: ?[*:0]const u16,
    Encoded: CRYPT_XML_BLOB,
};

pub const CRYPT_XML_TRANSFORM_INFO = extern struct {
    cbSize: u32,
    wszAlgorithm: ?[*:0]const u16,
    cbBufferSize: u32,
    dwFlags: CRYPT_XML_TRANSFORM_FLAGS,
    pfnCreateTransform: ?PFN_CRYPT_XML_CREATE_TRANSFORM,
};

pub const CRYPT_XML_TRANSFORM_CHAIN_CONFIG = extern struct {
    cbSize: u32,
    cTransformInfo: u32,
    rgpTransformInfo: ?*?*CRYPT_XML_TRANSFORM_INFO,
};

pub const CRYPT_XML_KEY_DSA_KEY_VALUE = extern struct {
    P: CRYPT_XML_DATA_BLOB,
    Q: CRYPT_XML_DATA_BLOB,
    G: CRYPT_XML_DATA_BLOB,
    Y: CRYPT_XML_DATA_BLOB,
    J: CRYPT_XML_DATA_BLOB,
    Seed: CRYPT_XML_DATA_BLOB,
    Counter: CRYPT_XML_DATA_BLOB,
};

pub const CRYPT_XML_KEY_ECDSA_KEY_VALUE = extern struct {
    wszNamedCurve: ?[*:0]const u16,
    X: CRYPT_XML_DATA_BLOB,
    Y: CRYPT_XML_DATA_BLOB,
    ExplicitPara: CRYPT_XML_BLOB,
};

pub const CRYPT_XML_KEY_RSA_KEY_VALUE = extern struct {
    Modulus: CRYPT_XML_DATA_BLOB,
    Exponent: CRYPT_XML_DATA_BLOB,
};

pub const CRYPT_XML_KEY_VALUE = extern struct {
    dwType: CRYPT_XML_KEY_VALUE_TYPE,
    Anonymous: extern union {
        DSAKeyValue: CRYPT_XML_KEY_DSA_KEY_VALUE,
        RSAKeyValue: CRYPT_XML_KEY_RSA_KEY_VALUE,
        ECDSAKeyValue: CRYPT_XML_KEY_ECDSA_KEY_VALUE,
        Custom: CRYPT_XML_BLOB,
    },
};

pub const CRYPT_XML_ISSUER_SERIAL = extern struct {
    wszIssuer: ?[*:0]const u16,
    wszSerial: ?[*:0]const u16,
};

pub const CRYPT_XML_X509DATA_ITEM = extern struct {
    dwType: CRYPT_XML_X509DATA_TYPE,
    Anonymous: extern union {
        IssuerSerial: CRYPT_XML_ISSUER_SERIAL,
        SKI: CRYPT_XML_DATA_BLOB,
        wszSubjectName: ?[*:0]const u16,
        Certificate: CRYPT_XML_DATA_BLOB,
        CRL: CRYPT_XML_DATA_BLOB,
        Custom: CRYPT_XML_BLOB,
    },
};

pub const CRYPT_XML_X509DATA = extern struct {
    cX509Data: u32,
    rgX509Data: ?*CRYPT_XML_X509DATA_ITEM,
};

pub const CRYPT_XML_KEY_INFO_ITEM = extern struct {
    dwType: CRYPT_XML_KEYINFO_TYPE,
    Anonymous: extern union {
        wszKeyName: ?[*:0]const u16,
        KeyValue: CRYPT_XML_KEY_VALUE,
        RetrievalMethod: CRYPT_XML_BLOB,
        X509Data: CRYPT_XML_X509DATA,
        Custom: CRYPT_XML_BLOB,
    },
};

pub const CRYPT_XML_KEY_INFO = extern struct {
    cbSize: u32,
    wszId: ?[*:0]const u16,
    cKeyInfo: u32,
    rgKeyInfo: ?*CRYPT_XML_KEY_INFO_ITEM,
    hVerifyKey: BCRYPT_KEY_HANDLE,
};

pub const CRYPT_XML_REFERENCE = extern struct {
    cbSize: u32,
    hReference: ?*anyopaque,
    wszId: ?[*:0]const u16,
    wszUri: ?[*:0]const u16,
    wszType: ?[*:0]const u16,
    DigestMethod: CRYPT_XML_ALGORITHM,
    DigestValue: CRYPTOAPI_BLOB,
    cTransform: u32,
    rgTransform: ?*CRYPT_XML_ALGORITHM,
};

pub const CRYPT_XML_REFERENCES = extern struct {
    cReference: u32,
    rgpReference: ?*?*CRYPT_XML_REFERENCE,
};

pub const CRYPT_XML_SIGNED_INFO = extern struct {
    cbSize: u32,
    wszId: ?[*:0]const u16,
    Canonicalization: CRYPT_XML_ALGORITHM,
    SignatureMethod: CRYPT_XML_ALGORITHM,
    cReference: u32,
    rgpReference: ?*?*CRYPT_XML_REFERENCE,
    Encoded: CRYPT_XML_BLOB,
};

pub const CRYPT_XML_OBJECT = extern struct {
    cbSize: u32,
    hObject: ?*anyopaque,
    wszId: ?[*:0]const u16,
    wszMimeType: ?[*:0]const u16,
    wszEncoding: ?[*:0]const u16,
    Manifest: CRYPT_XML_REFERENCES,
    Encoded: CRYPT_XML_BLOB,
};

pub const CRYPT_XML_SIGNATURE = extern struct {
    cbSize: u32,
    hSignature: ?*anyopaque,
    wszId: ?[*:0]const u16,
    SignedInfo: CRYPT_XML_SIGNED_INFO,
    SignatureValue: CRYPTOAPI_BLOB,
    pKeyInfo: ?*CRYPT_XML_KEY_INFO,
    cObject: u32,
    rgpObject: ?*?*CRYPT_XML_OBJECT,
};

pub const CRYPT_XML_DOC_CTXT = extern struct {
    cbSize: u32,
    hDocCtxt: ?*anyopaque,
    pTransformsConfig: ?*CRYPT_XML_TRANSFORM_CHAIN_CONFIG,
    cSignature: u32,
    rgpSignature: ?*?*CRYPT_XML_SIGNATURE,
};

pub const CRYPT_XML_KEYINFO_PARAM = extern struct {
    wszId: ?[*:0]const u16,
    wszKeyName: ?[*:0]const u16,
    SKI: CRYPTOAPI_BLOB,
    wszSubjectName: ?[*:0]const u16,
    cCertificate: u32,
    rgCertificate: ?*CRYPTOAPI_BLOB,
    cCRL: u32,
    rgCRL: ?*CRYPTOAPI_BLOB,
};

pub const CRYPT_XML_KEYINFO_SPEC = enum(i32) {
    NONE = 0,
    ENCODED = 1,
    PARAM = 2,
};
pub const CRYPT_XML_KEYINFO_SPEC_NONE = CRYPT_XML_KEYINFO_SPEC.NONE;
pub const CRYPT_XML_KEYINFO_SPEC_ENCODED = CRYPT_XML_KEYINFO_SPEC.ENCODED;
pub const CRYPT_XML_KEYINFO_SPEC_PARAM = CRYPT_XML_KEYINFO_SPEC.PARAM;

pub const CRYPT_XML_ALGORITHM_INFO = extern struct {
    cbSize: u32,
    wszAlgorithmURI: ?PWSTR,
    wszName: ?PWSTR,
    dwGroupId: CRYPT_XML_GROUP_ID,
    wszCNGAlgid: ?PWSTR,
    wszCNGExtraAlgid: ?PWSTR,
    dwSignFlags: u32,
    dwVerifyFlags: u32,
    pvPaddingInfo: ?*anyopaque,
    pvExtraInfo: ?*anyopaque,
};

pub const PFN_CRYPT_XML_ENUM_ALG_INFO = *const fn(
    pInfo: ?*const CRYPT_XML_ALGORITHM_INFO,
    pvArg: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CryptXmlDllGetInterface = *const fn(
    dwFlags: u32,
    pMethod: ?*const CRYPT_XML_ALGORITHM_INFO,
    pInterface: ?*CRYPT_XML_CRYPTOGRAPHIC_INTERFACE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const CryptXmlDllEncodeAlgorithm = *const fn(
    pAlgInfo: ?*const CRYPT_XML_ALGORITHM_INFO,
    dwCharset: CRYPT_XML_CHARSET,
    pvCallbackState: ?*anyopaque,
    pfnWrite: ?PFN_CRYPT_XML_WRITE_CALLBACK,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const CryptXmlDllCreateDigest = *const fn(
    pDigestMethod: ?*const CRYPT_XML_ALGORITHM,
    pcbSize: ?*u32,
    phDigest: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const CryptXmlDllDigestData = *const fn(
    hDigest: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 2?
    pbData: ?*const u8,
    cbData: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const CryptXmlDllFinalizeDigest = *const fn(
    hDigest: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 2?
    pbDigest: ?*u8,
    cbDigest: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const CryptXmlDllCloseDigest = *const fn(
    hDigest: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const CryptXmlDllSignData = *const fn(
    pSignatureMethod: ?*const CRYPT_XML_ALGORITHM,
    hCryptProvOrNCryptKey: HCRYPTPROV_OR_NCRYPT_KEY_HANDLE,
    dwKeySpec: u32,
    // TODO: what to do with BytesParamIndex 4?
    pbInput: ?*const u8,
    cbInput: u32,
    // TODO: what to do with BytesParamIndex 6?
    pbOutput: ?*u8,
    cbOutput: u32,
    pcbResult: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const CryptXmlDllVerifySignature = *const fn(
    pSignatureMethod: ?*const CRYPT_XML_ALGORITHM,
    hKey: BCRYPT_KEY_HANDLE,
    // TODO: what to do with BytesParamIndex 3?
    pbInput: ?*const u8,
    cbInput: u32,
    // TODO: what to do with BytesParamIndex 5?
    pbSignature: ?*const u8,
    cbSignature: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const CryptXmlDllGetAlgorithmInfo = *const fn(
    pXmlAlgorithm: ?*const CRYPT_XML_ALGORITHM,
    ppAlgInfo: ?*?*CRYPT_XML_ALGORITHM_INFO,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const CRYPT_XML_CRYPTOGRAPHIC_INTERFACE = extern struct {
    cbSize: u32,
    fpCryptXmlEncodeAlgorithm: ?CryptXmlDllEncodeAlgorithm,
    fpCryptXmlCreateDigest: ?CryptXmlDllCreateDigest,
    fpCryptXmlDigestData: ?CryptXmlDllDigestData,
    fpCryptXmlFinalizeDigest: ?CryptXmlDllFinalizeDigest,
    fpCryptXmlCloseDigest: ?CryptXmlDllCloseDigest,
    fpCryptXmlSignData: ?CryptXmlDllSignData,
    fpCryptXmlVerifySignature: ?CryptXmlDllVerifySignature,
    fpCryptXmlGetAlgorithmInfo: ?CryptXmlDllGetAlgorithmInfo,
};

pub const CryptXmlDllEncodeKeyValue = *const fn(
    hKey: NCRYPT_KEY_HANDLE,
    dwCharset: CRYPT_XML_CHARSET,
    pvCallbackState: ?*anyopaque,
    pfnWrite: ?PFN_CRYPT_XML_WRITE_CALLBACK,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const CryptXmlDllCreateKey = *const fn(
    pEncoded: ?*const CRYPT_XML_BLOB,
    phKey: ?*BCRYPT_KEY_HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const HandleType = enum(i32) {
    Asymmetric = 1,
    Symmetric = 2,
    Transform = 3,
    Hash = 4,
};
// NOTE: not creating aliases because this enum is 'Scoped'

pub const PaddingMode = enum(i32) {
    None = 1,
    PKCS7 = 2,
    Zeros = 3,
    ANSIX923 = 4,
    ISO10126 = 5,
};
// NOTE: not creating aliases because this enum is 'Scoped'

pub const Direction = enum(i32) {
    Encrypt = 1,
    Decrypt = 2,
};
pub const DirectionEncrypt = Direction.Encrypt;
pub const DirectionDecrypt = Direction.Decrypt;

pub const INFORMATIONCARD_ASYMMETRIC_CRYPTO_PARAMETERS = extern struct {
    keySize: i32,
    keyExchangeAlgorithm: ?PWSTR,
    signatureAlgorithm: ?PWSTR,
};

pub const INFORMATIONCARD_SYMMETRIC_CRYPTO_PARAMETERS = extern struct {
    keySize: i32,
    blockSize: i32,
    feedbackSize: i32,
};

pub const INFORMATIONCARD_TRANSFORM_CRYPTO_PARAMETERS = extern struct {
    inputBlockSize: i32,
    outputBlockSize: i32,
    canTransformMultipleBlocks: BOOL,
    canReuseTransform: BOOL,
};

pub const INFORMATIONCARD_HASH_CRYPTO_PARAMETERS = extern struct {
    hashSize: i32,
    transform: INFORMATIONCARD_TRANSFORM_CRYPTO_PARAMETERS,
};

pub const INFORMATIONCARD_CRYPTO_HANDLE = extern struct {
    type: HandleType,
    expiration: i64,
    cryptoParameters: ?*anyopaque,
};

pub const GENERIC_XML_TOKEN = extern struct {
    createDate: FILETIME align(1),
    expiryDate: FILETIME align(1),
    xmlToken: ?PWSTR align(1),
    internalTokenReference: ?PWSTR align(1),
    externalTokenReference: ?PWSTR align(1),
};

pub const POLICY_ELEMENT = extern struct {
    targetEndpointAddress: ?[*:0]const u16,
    issuerEndpointAddress: ?[*:0]const u16,
    issuedTokenParameters: ?[*:0]const u16,
    privacyNoticeLink: ?[*:0]const u16,
    privacyNoticeVersion: u32,
    useManagedPresentation: BOOL,
};

pub const ENDPOINTADDRESS = extern struct {
    serviceUrl: ?[*:0]const u16,
    policyUrl: ?[*:0]const u16,
    rawCertificate: CRYPTOAPI_BLOB,
};

pub const ENDPOINTADDRESS2 = extern struct {
    serviceUrl: ?[*:0]const u16,
    policyUrl: ?[*:0]const u16,
    identityType: u32,
    identityBytes: ?*anyopaque,
};

pub const CERTIFICATE_CHAIN_BLOB = extern struct {
    certCount: u32,
    rawCertificates: ?*CRYPTOAPI_BLOB,
};

pub const CLAIMLIST = extern struct {
    count: u32,
    claims: ?*?PWSTR,
};

pub const RECIPIENTPOLICY = extern struct {
    recipient: ENDPOINTADDRESS,
    issuer: ENDPOINTADDRESS,
    tokenType: ?[*:0]const u16,
    requiredClaims: CLAIMLIST,
    optionalClaims: CLAIMLIST,
    privacyUrl: ?[*:0]const u16,
    privacyVersion: u32,
};

pub const RECIPIENTPOLICY2 = extern struct {
    recipient: ENDPOINTADDRESS2,
    issuer: ENDPOINTADDRESS2,
    tokenType: ?[*:0]const u16,
    requiredClaims: CLAIMLIST,
    optionalClaims: CLAIMLIST,
    privacyUrl: ?[*:0]const u16,
    privacyVersion: u32,
};

const CLSID_CCertSrvSetupKeyInformation_Value = Guid.initString("38373906-5433-4633-b0fb-29b7e78262e1");
pub const CLSID_CCertSrvSetupKeyInformation = &CLSID_CCertSrvSetupKeyInformation_Value;

const CLSID_CCertSrvSetup_Value = Guid.initString("961f180f-f55c-413d-a9b3-7d2af4d8e42f");
pub const CLSID_CCertSrvSetup = &CLSID_CCertSrvSetup_Value;

const CLSID_CMSCEPSetup_Value = Guid.initString("aa4f5c02-8e7c-49c4-94fa-67a5cc5eadb4");
pub const CLSID_CMSCEPSetup = &CLSID_CMSCEPSetup_Value;

const CLSID_CCertificateEnrollmentServerSetup_Value = Guid.initString("9902f3bc-88af-4cf8-ae62-7140531552b6");
pub const CLSID_CCertificateEnrollmentServerSetup = &CLSID_CCertificateEnrollmentServerSetup_Value;

const CLSID_CCertificateEnrollmentPolicyServerSetup_Value = Guid.initString("afe2fa32-41b1-459d-a5de-49add8a72182");
pub const CLSID_CCertificateEnrollmentPolicyServerSetup = &CLSID_CCertificateEnrollmentPolicyServerSetup_Value;

// TODO: this type is limited to platform 'windowsServer2008'
const IID_ICertSrvSetupKeyInformation_Value = Guid.initString("6ba73778-36da-4c39-8a85-bcfa7d000793");
pub const IID_ICertSrvSetupKeyInformation = &IID_ICertSrvSetupKeyInformation_Value;
pub const ICertSrvSetupKeyInformation = extern union {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ProviderName: *const fn(
            self: *const ICertSrvSetupKeyInformation,
            pVal: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ProviderName: *const fn(
            self: *const ICertSrvSetupKeyInformation,
            bstrVal: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Length: *const fn(
            self: *const ICertSrvSetupKeyInformation,
            pVal: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Length: *const fn(
            self: *const ICertSrvSetupKeyInformation,
            lVal: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Existing: *const fn(
            self: *const ICertSrvSetupKeyInformation,
            pVal: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Existing: *const fn(
            self: *const ICertSrvSetupKeyInformation,
            bVal: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ContainerName: *const fn(
            self: *const ICertSrvSetupKeyInformation,
            pVal: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ContainerName: *const fn(
            self: *const ICertSrvSetupKeyInformation,
            bstrVal: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HashAlgorithm: *const fn(
            self: *const ICertSrvSetupKeyInformation,
            pVal: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_HashAlgorithm: *const fn(
            self: *const ICertSrvSetupKeyInformation,
            bstrVal: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ExistingCACertificate: *const fn(
            self: *const ICertSrvSetupKeyInformation,
            pVal: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ExistingCACertificate: *const fn(
            self: *const ICertSrvSetupKeyInformation,
            varVal: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IDispatch: IDispatch,
    IUnknown: IUnknown,
    pub fn get_ProviderName(self: *const ICertSrvSetupKeyInformation, pVal: ?*?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.get_ProviderName(self, pVal);
    }
    pub fn put_ProviderName(self: *const ICertSrvSetupKeyInformation, bstrVal: ?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.put_ProviderName(self, bstrVal);
    }
    pub fn get_Length(self: *const ICertSrvSetupKeyInformation, pVal: ?*i32) callconv(.Inline) HRESULT {
        return self.vtable.get_Length(self, pVal);
    }
    pub fn put_Length(self: *const ICertSrvSetupKeyInformation, lVal: i32) callconv(.Inline) HRESULT {
        return self.vtable.put_Length(self, lVal);
    }
    pub fn get_Existing(self: *const ICertSrvSetupKeyInformation, pVal: ?*i16) callconv(.Inline) HRESULT {
        return self.vtable.get_Existing(self, pVal);
    }
    pub fn put_Existing(self: *const ICertSrvSetupKeyInformation, bVal: i16) callconv(.Inline) HRESULT {
        return self.vtable.put_Existing(self, bVal);
    }
    pub fn get_ContainerName(self: *const ICertSrvSetupKeyInformation, pVal: ?*?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.get_ContainerName(self, pVal);
    }
    pub fn put_ContainerName(self: *const ICertSrvSetupKeyInformation, bstrVal: ?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.put_ContainerName(self, bstrVal);
    }
    pub fn get_HashAlgorithm(self: *const ICertSrvSetupKeyInformation, pVal: ?*?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.get_HashAlgorithm(self, pVal);
    }
    pub fn put_HashAlgorithm(self: *const ICertSrvSetupKeyInformation, bstrVal: ?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.put_HashAlgorithm(self, bstrVal);
    }
    pub fn get_ExistingCACertificate(self: *const ICertSrvSetupKeyInformation, pVal: ?*VARIANT) callconv(.Inline) HRESULT {
        return self.vtable.get_ExistingCACertificate(self, pVal);
    }
    pub fn put_ExistingCACertificate(self: *const ICertSrvSetupKeyInformation, varVal: VARIANT) callconv(.Inline) HRESULT {
        return self.vtable.put_ExistingCACertificate(self, varVal);
    }
};

// TODO: this type is limited to platform 'windowsServer2008'
const IID_ICertSrvSetupKeyInformationCollection_Value = Guid.initString("e65c8b00-e58f-41f9-a9ec-a28d7427c844");
pub const IID_ICertSrvSetupKeyInformationCollection = &IID_ICertSrvSetupKeyInformationCollection_Value;
pub const ICertSrvSetupKeyInformationCollection = extern union {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: *const fn(
            self: *const ICertSrvSetupKeyInformationCollection,
            ppVal: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_Item: *const fn(
            self: *const ICertSrvSetupKeyInformationCollection,
            Index: i32,
            pVal: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: *const fn(
            self: *const ICertSrvSetupKeyInformationCollection,
            pVal: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Add: *const fn(
            self: *const ICertSrvSetupKeyInformationCollection,
            pIKeyInformation: ?*ICertSrvSetupKeyInformation,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IDispatch: IDispatch,
    IUnknown: IUnknown,
    pub fn get__NewEnum(self: *const ICertSrvSetupKeyInformationCollection, ppVal: ?*?*IUnknown) callconv(.Inline) HRESULT {
        return self.vtable.get__NewEnum(self, ppVal);
    }
    pub fn get_Item(self: *const ICertSrvSetupKeyInformationCollection, Index: i32, pVal: ?*VARIANT) callconv(.Inline) HRESULT {
        return self.vtable.get_Item(self, Index, pVal);
    }
    pub fn get_Count(self: *const ICertSrvSetupKeyInformationCollection, pVal: ?*i32) callconv(.Inline) HRESULT {
        return self.vtable.get_Count(self, pVal);
    }
    pub fn Add(self: *const ICertSrvSetupKeyInformationCollection, pIKeyInformation: ?*ICertSrvSetupKeyInformation) callconv(.Inline) HRESULT {
        return self.vtable.Add(self, pIKeyInformation);
    }
};

pub const CASetupProperty = enum(i32) {
    INVALID = -1,
    CATYPE = 0,
    CAKEYINFORMATION = 1,
    INTERACTIVE = 2,
    CANAME = 3,
    CADSSUFFIX = 4,
    VALIDITYPERIOD = 5,
    VALIDITYPERIODUNIT = 6,
    EXPIRATIONDATE = 7,
    PRESERVEDATABASE = 8,
    DATABASEDIRECTORY = 9,
    LOGDIRECTORY = 10,
    SHAREDFOLDER = 11,
    PARENTCAMACHINE = 12,
    PARENTCANAME = 13,
    REQUESTFILE = 14,
    WEBCAMACHINE = 15,
    WEBCANAME = 16,
};
pub const ENUM_SETUPPROP_INVALID = CASetupProperty.INVALID;
pub const ENUM_SETUPPROP_CATYPE = CASetupProperty.CATYPE;
pub const ENUM_SETUPPROP_CAKEYINFORMATION = CASetupProperty.CAKEYINFORMATION;
pub const ENUM_SETUPPROP_INTERACTIVE = CASetupProperty.INTERACTIVE;
pub const ENUM_SETUPPROP_CANAME = CASetupProperty.CANAME;
pub const ENUM_SETUPPROP_CADSSUFFIX = CASetupProperty.CADSSUFFIX;
pub const ENUM_SETUPPROP_VALIDITYPERIOD = CASetupProperty.VALIDITYPERIOD;
pub const ENUM_SETUPPROP_VALIDITYPERIODUNIT = CASetupProperty.VALIDITYPERIODUNIT;
pub const ENUM_SETUPPROP_EXPIRATIONDATE = CASetupProperty.EXPIRATIONDATE;
pub const ENUM_SETUPPROP_PRESERVEDATABASE = CASetupProperty.PRESERVEDATABASE;
pub const ENUM_SETUPPROP_DATABASEDIRECTORY = CASetupProperty.DATABASEDIRECTORY;
pub const ENUM_SETUPPROP_LOGDIRECTORY = CASetupProperty.LOGDIRECTORY;
pub const ENUM_SETUPPROP_SHAREDFOLDER = CASetupProperty.SHAREDFOLDER;
pub const ENUM_SETUPPROP_PARENTCAMACHINE = CASetupProperty.PARENTCAMACHINE;
pub const ENUM_SETUPPROP_PARENTCANAME = CASetupProperty.PARENTCANAME;
pub const ENUM_SETUPPROP_REQUESTFILE = CASetupProperty.REQUESTFILE;
pub const ENUM_SETUPPROP_WEBCAMACHINE = CASetupProperty.WEBCAMACHINE;
pub const ENUM_SETUPPROP_WEBCANAME = CASetupProperty.WEBCANAME;

// TODO: this type is limited to platform 'windowsServer2008'
const IID_ICertSrvSetup_Value = Guid.initString("b760a1bb-4784-44c0-8f12-555f0780ff25");
pub const IID_ICertSrvSetup = &IID_ICertSrvSetup_Value;
pub const ICertSrvSetup = extern union {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CAErrorId: *const fn(
            self: *const ICertSrvSetup,
            pVal: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CAErrorString: *const fn(
            self: *const ICertSrvSetup,
            pVal: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitializeDefaults: *const fn(
            self: *const ICertSrvSetup,
            bServer: i16,
            bClient: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCASetupProperty: *const fn(
            self: *const ICertSrvSetup,
            propertyId: CASetupProperty,
            pPropertyValue: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCASetupProperty: *const fn(
            self: *const ICertSrvSetup,
            propertyId: CASetupProperty,
            pPropertyValue: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsPropertyEditable: *const fn(
            self: *const ICertSrvSetup,
            propertyId: CASetupProperty,
            pbEditable: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSupportedCATypes: *const fn(
            self: *const ICertSrvSetup,
            pCATypes: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProviderNameList: *const fn(
            self: *const ICertSrvSetup,
            pVal: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetKeyLengthList: *const fn(
            self: *const ICertSrvSetup,
            bstrProviderName: ?BSTR,
            pVal: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHashAlgorithmList: *const fn(
            self: *const ICertSrvSetup,
            bstrProviderName: ?BSTR,
            pVal: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPrivateKeyContainerList: *const fn(
            self: *const ICertSrvSetup,
            bstrProviderName: ?BSTR,
            pVal: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExistingCACertificates: *const fn(
            self: *const ICertSrvSetup,
            ppVal: ?*?*ICertSrvSetupKeyInformationCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CAImportPFX: *const fn(
            self: *const ICertSrvSetup,
            bstrFileName: ?BSTR,
            bstrPasswd: ?BSTR,
            bOverwriteExistingKey: i16,
            ppVal: ?*?*ICertSrvSetupKeyInformation,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCADistinguishedName: *const fn(
            self: *const ICertSrvSetup,
            bstrCADN: ?BSTR,
            bIgnoreUnicode: i16,
            bOverwriteExistingKey: i16,
            bOverwriteExistingCAInDS: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDatabaseInformation: *const fn(
            self: *const ICertSrvSetup,
            bstrDBDirectory: ?BSTR,
            bstrLogDirectory: ?BSTR,
            bstrSharedFolder: ?BSTR,
            bForceOverwrite: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetParentCAInformation: *const fn(
            self: *const ICertSrvSetup,
            bstrCAConfiguration: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetWebCAInformation: *const fn(
            self: *const ICertSrvSetup,
            bstrCAConfiguration: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Install: *const fn(
            self: *const ICertSrvSetup,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PreUnInstall: *const fn(
            self: *const ICertSrvSetup,
            bClientOnly: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PostUnInstall: *const fn(
            self: *const ICertSrvSetup,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IDispatch: IDispatch,
    IUnknown: IUnknown,
    pub fn get_CAErrorId(self: *const ICertSrvSetup, pVal: ?*i32) callconv(.Inline) HRESULT {
        return self.vtable.get_CAErrorId(self, pVal);
    }
    pub fn get_CAErrorString(self: *const ICertSrvSetup, pVal: ?*?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.get_CAErrorString(self, pVal);
    }
    pub fn InitializeDefaults(self: *const ICertSrvSetup, bServer: i16, bClient: i16) callconv(.Inline) HRESULT {
        return self.vtable.InitializeDefaults(self, bServer, bClient);
    }
    pub fn GetCASetupProperty(self: *const ICertSrvSetup, propertyId: CASetupProperty, pPropertyValue: ?*VARIANT) callconv(.Inline) HRESULT {
        return self.vtable.GetCASetupProperty(self, propertyId, pPropertyValue);
    }
    pub fn SetCASetupProperty(self: *const ICertSrvSetup, propertyId: CASetupProperty, pPropertyValue: ?*VARIANT) callconv(.Inline) HRESULT {
        return self.vtable.SetCASetupProperty(self, propertyId, pPropertyValue);
    }
    pub fn IsPropertyEditable(self: *const ICertSrvSetup, propertyId: CASetupProperty, pbEditable: ?*i16) callconv(.Inline) HRESULT {
        return self.vtable.IsPropertyEditable(self, propertyId, pbEditable);
    }
    pub fn GetSupportedCATypes(self: *const ICertSrvSetup, pCATypes: ?*VARIANT) callconv(.Inline) HRESULT {
        return self.vtable.GetSupportedCATypes(self, pCATypes);
    }
    pub fn GetProviderNameList(self: *const ICertSrvSetup, pVal: ?*VARIANT) callconv(.Inline) HRESULT {
        return self.vtable.GetProviderNameList(self, pVal);
    }
    pub fn GetKeyLengthList(self: *const ICertSrvSetup, bstrProviderName: ?BSTR, pVal: ?*VARIANT) callconv(.Inline) HRESULT {
        return self.vtable.GetKeyLengthList(self, bstrProviderName, pVal);
    }
    pub fn GetHashAlgorithmList(self: *const ICertSrvSetup, bstrProviderName: ?BSTR, pVal: ?*VARIANT) callconv(.Inline) HRESULT {
        return self.vtable.GetHashAlgorithmList(self, bstrProviderName, pVal);
    }
    pub fn GetPrivateKeyContainerList(self: *const ICertSrvSetup, bstrProviderName: ?BSTR, pVal: ?*VARIANT) callconv(.Inline) HRESULT {
        return self.vtable.GetPrivateKeyContainerList(self, bstrProviderName, pVal);
    }
    pub fn GetExistingCACertificates(self: *const ICertSrvSetup, ppVal: ?*?*ICertSrvSetupKeyInformationCollection) callconv(.Inline) HRESULT {
        return self.vtable.GetExistingCACertificates(self, ppVal);
    }
    pub fn CAImportPFX(self: *const ICertSrvSetup, bstrFileName: ?BSTR, bstrPasswd: ?BSTR, bOverwriteExistingKey: i16, ppVal: ?*?*ICertSrvSetupKeyInformation) callconv(.Inline) HRESULT {
        return self.vtable.CAImportPFX(self, bstrFileName, bstrPasswd, bOverwriteExistingKey, ppVal);
    }
    pub fn SetCADistinguishedName(self: *const ICertSrvSetup, bstrCADN: ?BSTR, bIgnoreUnicode: i16, bOverwriteExistingKey: i16, bOverwriteExistingCAInDS: i16) callconv(.Inline) HRESULT {
        return self.vtable.SetCADistinguishedName(self, bstrCADN, bIgnoreUnicode, bOverwriteExistingKey, bOverwriteExistingCAInDS);
    }
    pub fn SetDatabaseInformation(self: *const ICertSrvSetup, bstrDBDirectory: ?BSTR, bstrLogDirectory: ?BSTR, bstrSharedFolder: ?BSTR, bForceOverwrite: i16) callconv(.Inline) HRESULT {
        return self.vtable.SetDatabaseInformation(self, bstrDBDirectory, bstrLogDirectory, bstrSharedFolder, bForceOverwrite);
    }
    pub fn SetParentCAInformation(self: *const ICertSrvSetup, bstrCAConfiguration: ?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.SetParentCAInformation(self, bstrCAConfiguration);
    }
    pub fn SetWebCAInformation(self: *const ICertSrvSetup, bstrCAConfiguration: ?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.SetWebCAInformation(self, bstrCAConfiguration);
    }
    pub fn Install(self: *const ICertSrvSetup) callconv(.Inline) HRESULT {
        return self.vtable.Install(self);
    }
    pub fn PreUnInstall(self: *const ICertSrvSetup, bClientOnly: i16) callconv(.Inline) HRESULT {
        return self.vtable.PreUnInstall(self, bClientOnly);
    }
    pub fn PostUnInstall(self: *const ICertSrvSetup) callconv(.Inline) HRESULT {
        return self.vtable.PostUnInstall(self);
    }
};

pub const MSCEPSetupProperty = enum(i32) {
    USELOCALSYSTEM = 0,
    USECHALLENGE = 1,
    RANAME_CN = 2,
    RANAME_EMAIL = 3,
    RANAME_COMPANY = 4,
    RANAME_DEPT = 5,
    RANAME_CITY = 6,
    RANAME_STATE = 7,
    RANAME_COUNTRY = 8,
    SIGNINGKEYINFORMATION = 9,
    EXCHANGEKEYINFORMATION = 10,
    CAINFORMATION = 11,
    MSCEPURL = 12,
    CHALLENGEURL = 13,
};
pub const ENUM_CEPSETUPPROP_USELOCALSYSTEM = MSCEPSetupProperty.USELOCALSYSTEM;
pub const ENUM_CEPSETUPPROP_USECHALLENGE = MSCEPSetupProperty.USECHALLENGE;
pub const ENUM_CEPSETUPPROP_RANAME_CN = MSCEPSetupProperty.RANAME_CN;
pub const ENUM_CEPSETUPPROP_RANAME_EMAIL = MSCEPSetupProperty.RANAME_EMAIL;
pub const ENUM_CEPSETUPPROP_RANAME_COMPANY = MSCEPSetupProperty.RANAME_COMPANY;
pub const ENUM_CEPSETUPPROP_RANAME_DEPT = MSCEPSetupProperty.RANAME_DEPT;
pub const ENUM_CEPSETUPPROP_RANAME_CITY = MSCEPSetupProperty.RANAME_CITY;
pub const ENUM_CEPSETUPPROP_RANAME_STATE = MSCEPSetupProperty.RANAME_STATE;
pub const ENUM_CEPSETUPPROP_RANAME_COUNTRY = MSCEPSetupProperty.RANAME_COUNTRY;
pub const ENUM_CEPSETUPPROP_SIGNINGKEYINFORMATION = MSCEPSetupProperty.SIGNINGKEYINFORMATION;
pub const ENUM_CEPSETUPPROP_EXCHANGEKEYINFORMATION = MSCEPSetupProperty.EXCHANGEKEYINFORMATION;
pub const ENUM_CEPSETUPPROP_CAINFORMATION = MSCEPSetupProperty.CAINFORMATION;
pub const ENUM_CEPSETUPPROP_MSCEPURL = MSCEPSetupProperty.MSCEPURL;
pub const ENUM_CEPSETUPPROP_CHALLENGEURL = MSCEPSetupProperty.CHALLENGEURL;

// TODO: this type is limited to platform 'windowsServer2008'
const IID_IMSCEPSetup_Value = Guid.initString("4f7761bb-9f3b-4592-9ee0-9a73259c313e");
pub const IID_IMSCEPSetup = &IID_IMSCEPSetup_Value;
pub const IMSCEPSetup = extern union {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MSCEPErrorId: *const fn(
            self: *const IMSCEPSetup,
            pVal: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MSCEPErrorString: *const fn(
            self: *const IMSCEPSetup,
            pVal: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitializeDefaults: *const fn(
            self: *const IMSCEPSetup,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMSCEPSetupProperty: *const fn(
            self: *const IMSCEPSetup,
            propertyId: MSCEPSetupProperty,
            pVal: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetMSCEPSetupProperty: *const fn(
            self: *const IMSCEPSetup,
            propertyId: MSCEPSetupProperty,
            pPropertyValue: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAccountInformation: *const fn(
            self: *const IMSCEPSetup,
            bstrUserName: ?BSTR,
            bstrPassword: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsMSCEPStoreEmpty: *const fn(
            self: *const IMSCEPSetup,
            pbEmpty: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProviderNameList: *const fn(
            self: *const IMSCEPSetup,
            bExchange: i16,
            pVal: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetKeyLengthList: *const fn(
            self: *const IMSCEPSetup,
            bExchange: i16,
            bstrProviderName: ?BSTR,
            pVal: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Install: *const fn(
            self: *const IMSCEPSetup,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PreUnInstall: *const fn(
            self: *const IMSCEPSetup,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PostUnInstall: *const fn(
            self: *const IMSCEPSetup,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IDispatch: IDispatch,
    IUnknown: IUnknown,
    pub fn get_MSCEPErrorId(self: *const IMSCEPSetup, pVal: ?*i32) callconv(.Inline) HRESULT {
        return self.vtable.get_MSCEPErrorId(self, pVal);
    }
    pub fn get_MSCEPErrorString(self: *const IMSCEPSetup, pVal: ?*?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.get_MSCEPErrorString(self, pVal);
    }
    pub fn InitializeDefaults(self: *const IMSCEPSetup) callconv(.Inline) HRESULT {
        return self.vtable.InitializeDefaults(self);
    }
    pub fn GetMSCEPSetupProperty(self: *const IMSCEPSetup, propertyId: MSCEPSetupProperty, pVal: ?*VARIANT) callconv(.Inline) HRESULT {
        return self.vtable.GetMSCEPSetupProperty(self, propertyId, pVal);
    }
    pub fn SetMSCEPSetupProperty(self: *const IMSCEPSetup, propertyId: MSCEPSetupProperty, pPropertyValue: ?*VARIANT) callconv(.Inline) HRESULT {
        return self.vtable.SetMSCEPSetupProperty(self, propertyId, pPropertyValue);
    }
    pub fn SetAccountInformation(self: *const IMSCEPSetup, bstrUserName: ?BSTR, bstrPassword: ?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.SetAccountInformation(self, bstrUserName, bstrPassword);
    }
    pub fn IsMSCEPStoreEmpty(self: *const IMSCEPSetup, pbEmpty: ?*i16) callconv(.Inline) HRESULT {
        return self.vtable.IsMSCEPStoreEmpty(self, pbEmpty);
    }
    pub fn GetProviderNameList(self: *const IMSCEPSetup, bExchange: i16, pVal: ?*VARIANT) callconv(.Inline) HRESULT {
        return self.vtable.GetProviderNameList(self, bExchange, pVal);
    }
    pub fn GetKeyLengthList(self: *const IMSCEPSetup, bExchange: i16, bstrProviderName: ?BSTR, pVal: ?*VARIANT) callconv(.Inline) HRESULT {
        return self.vtable.GetKeyLengthList(self, bExchange, bstrProviderName, pVal);
    }
    pub fn Install(self: *const IMSCEPSetup) callconv(.Inline) HRESULT {
        return self.vtable.Install(self);
    }
    pub fn PreUnInstall(self: *const IMSCEPSetup) callconv(.Inline) HRESULT {
        return self.vtable.PreUnInstall(self);
    }
    pub fn PostUnInstall(self: *const IMSCEPSetup) callconv(.Inline) HRESULT {
        return self.vtable.PostUnInstall(self);
    }
};

pub const CESSetupProperty = enum(i32) {
    USE_IISAPPPOOLIDENTITY = 0,
    CACONFIG = 1,
    AUTHENTICATION = 2,
    SSLCERTHASH = 3,
    URL = 4,
    RENEWALONLY = 5,
    ALLOW_KEYBASED_RENEWAL = 6,
};
pub const ENUM_CESSETUPPROP_USE_IISAPPPOOLIDENTITY = CESSetupProperty.USE_IISAPPPOOLIDENTITY;
pub const ENUM_CESSETUPPROP_CACONFIG = CESSetupProperty.CACONFIG;
pub const ENUM_CESSETUPPROP_AUTHENTICATION = CESSetupProperty.AUTHENTICATION;
pub const ENUM_CESSETUPPROP_SSLCERTHASH = CESSetupProperty.SSLCERTHASH;
pub const ENUM_CESSETUPPROP_URL = CESSetupProperty.URL;
pub const ENUM_CESSETUPPROP_RENEWALONLY = CESSetupProperty.RENEWALONLY;
pub const ENUM_CESSETUPPROP_ALLOW_KEYBASED_RENEWAL = CESSetupProperty.ALLOW_KEYBASED_RENEWAL;

// TODO: this type is limited to platform 'windows6.1'
const IID_ICertificateEnrollmentServerSetup_Value = Guid.initString("70027fdb-9dd9-4921-8944-b35cb31bd2ec");
pub const IID_ICertificateEnrollmentServerSetup = &IID_ICertificateEnrollmentServerSetup_Value;
pub const ICertificateEnrollmentServerSetup = extern union {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ErrorString: *const fn(
            self: *const ICertificateEnrollmentServerSetup,
            pVal: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitializeInstallDefaults: *const fn(
            self: *const ICertificateEnrollmentServerSetup,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperty: *const fn(
            self: *const ICertificateEnrollmentServerSetup,
            propertyId: CESSetupProperty,
            pPropertyValue: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProperty: *const fn(
            self: *const ICertificateEnrollmentServerSetup,
            propertyId: CESSetupProperty,
            pPropertyValue: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetApplicationPoolCredentials: *const fn(
            self: *const ICertificateEnrollmentServerSetup,
            bstrUsername: ?BSTR,
            bstrPassword: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Install: *const fn(
            self: *const ICertificateEnrollmentServerSetup,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnInstall: *const fn(
            self: *const ICertificateEnrollmentServerSetup,
            pCAConfig: ?*VARIANT,
            pAuthentication: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IDispatch: IDispatch,
    IUnknown: IUnknown,
    pub fn get_ErrorString(self: *const ICertificateEnrollmentServerSetup, pVal: ?*?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.get_ErrorString(self, pVal);
    }
    pub fn InitializeInstallDefaults(self: *const ICertificateEnrollmentServerSetup) callconv(.Inline) HRESULT {
        return self.vtable.InitializeInstallDefaults(self);
    }
    pub fn GetProperty(self: *const ICertificateEnrollmentServerSetup, propertyId: CESSetupProperty, pPropertyValue: ?*VARIANT) callconv(.Inline) HRESULT {
        return self.vtable.GetProperty(self, propertyId, pPropertyValue);
    }
    pub fn SetProperty(self: *const ICertificateEnrollmentServerSetup, propertyId: CESSetupProperty, pPropertyValue: ?*VARIANT) callconv(.Inline) HRESULT {
        return self.vtable.SetProperty(self, propertyId, pPropertyValue);
    }
    pub fn SetApplicationPoolCredentials(self: *const ICertificateEnrollmentServerSetup, bstrUsername: ?BSTR, bstrPassword: ?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.SetApplicationPoolCredentials(self, bstrUsername, bstrPassword);
    }
    pub fn Install(self: *const ICertificateEnrollmentServerSetup) callconv(.Inline) HRESULT {
        return self.vtable.Install(self);
    }
    pub fn UnInstall(self: *const ICertificateEnrollmentServerSetup, pCAConfig: ?*VARIANT, pAuthentication: ?*VARIANT) callconv(.Inline) HRESULT {
        return self.vtable.UnInstall(self, pCAConfig, pAuthentication);
    }
};

pub const CEPSetupProperty = enum(i32) {
    AUTHENTICATION = 0,
    SSLCERTHASH = 1,
    URL = 2,
    KEYBASED_RENEWAL = 3,
};
pub const ENUM_CEPSETUPPROP_AUTHENTICATION = CEPSetupProperty.AUTHENTICATION;
pub const ENUM_CEPSETUPPROP_SSLCERTHASH = CEPSetupProperty.SSLCERTHASH;
pub const ENUM_CEPSETUPPROP_URL = CEPSetupProperty.URL;
pub const ENUM_CEPSETUPPROP_KEYBASED_RENEWAL = CEPSetupProperty.KEYBASED_RENEWAL;

// TODO: this type is limited to platform 'windows6.1'
const IID_ICertificateEnrollmentPolicyServerSetup_Value = Guid.initString("859252cc-238c-4a88-b8fd-a37e7d04e68b");
pub const IID_ICertificateEnrollmentPolicyServerSetup = &IID_ICertificateEnrollmentPolicyServerSetup_Value;
pub const ICertificateEnrollmentPolicyServerSetup = extern union {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ErrorString: *const fn(
            self: *const ICertificateEnrollmentPolicyServerSetup,
            pVal: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitializeInstallDefaults: *const fn(
            self: *const ICertificateEnrollmentPolicyServerSetup,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperty: *const fn(
            self: *const ICertificateEnrollmentPolicyServerSetup,
            propertyId: CEPSetupProperty,
            pPropertyValue: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProperty: *const fn(
            self: *const ICertificateEnrollmentPolicyServerSetup,
            propertyId: CEPSetupProperty,
            pPropertyValue: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Install: *const fn(
            self: *const ICertificateEnrollmentPolicyServerSetup,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnInstall: *const fn(
            self: *const ICertificateEnrollmentPolicyServerSetup,
            pAuthKeyBasedRenewal: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IDispatch: IDispatch,
    IUnknown: IUnknown,
    pub fn get_ErrorString(self: *const ICertificateEnrollmentPolicyServerSetup, pVal: ?*?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.get_ErrorString(self, pVal);
    }
    pub fn InitializeInstallDefaults(self: *const ICertificateEnrollmentPolicyServerSetup) callconv(.Inline) HRESULT {
        return self.vtable.InitializeInstallDefaults(self);
    }
    pub fn GetProperty(self: *const ICertificateEnrollmentPolicyServerSetup, propertyId: CEPSetupProperty, pPropertyValue: ?*VARIANT) callconv(.Inline) HRESULT {
        return self.vtable.GetProperty(self, propertyId, pPropertyValue);
    }
    pub fn SetProperty(self: *const ICertificateEnrollmentPolicyServerSetup, propertyId: CEPSetupProperty, pPropertyValue: ?*VARIANT) callconv(.Inline) HRESULT {
        return self.vtable.SetProperty(self, propertyId, pPropertyValue);
    }
    pub fn Install(self: *const ICertificateEnrollmentPolicyServerSetup) callconv(.Inline) HRESULT {
        return self.vtable.Install(self);
    }
    pub fn UnInstall(self: *const ICertificateEnrollmentPolicyServerSetup, pAuthKeyBasedRenewal: ?*VARIANT) callconv(.Inline) HRESULT {
        return self.vtable.UnInstall(self, pAuthKeyBasedRenewal);
    }
};


//--------------------------------------------------------------------------------
// Section: Functions (397)
//--------------------------------------------------------------------------------
// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn CryptAcquireContextA(
    phProv: ?*usize,
    szContainer: ?[*:0]const u8,
    szProvider: ?[*:0]const u8,
    dwProvType: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn CryptAcquireContextW(
    phProv: ?*usize,
    szContainer: ?[*:0]const u16,
    szProvider: ?[*:0]const u16,
    dwProvType: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn CryptReleaseContext(
    hProv: usize,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn CryptGenKey(
    hProv: usize,
    Algid: u32,
    dwFlags: CRYPT_KEY_FLAGS,
    phKey: ?*usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn CryptDeriveKey(
    hProv: usize,
    Algid: u32,
    hBaseData: usize,
    dwFlags: u32,
    phKey: ?*usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn CryptDestroyKey(
    hKey: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn CryptSetKeyParam(
    hKey: usize,
    dwParam: CRYPT_KEY_PARAM_ID,
    pbData: ?*const u8,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn CryptGetKeyParam(
    hKey: usize,
    dwParam: CRYPT_KEY_PARAM_ID,
    // TODO: what to do with BytesParamIndex 3?
    pbData: ?*u8,
    pdwDataLen: ?*u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn CryptSetHashParam(
    hHash: usize,
    dwParam: CRYPT_SET_HASH_PARAM,
    pbData: ?*const u8,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn CryptGetHashParam(
    hHash: usize,
    dwParam: u32,
    // TODO: what to do with BytesParamIndex 3?
    pbData: ?*u8,
    pdwDataLen: ?*u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn CryptSetProvParam(
    hProv: usize,
    dwParam: CRYPT_SET_PROV_PARAM_ID,
    pbData: ?*const u8,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn CryptGetProvParam(
    hProv: usize,
    dwParam: u32,
    // TODO: what to do with BytesParamIndex 3?
    pbData: ?*u8,
    pdwDataLen: ?*u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn CryptGenRandom(
    hProv: usize,
    dwLen: u32,
    // TODO: what to do with BytesParamIndex 1?
    pbBuffer: ?*u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn CryptGetUserKey(
    hProv: usize,
    dwKeySpec: u32,
    phUserKey: ?*usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn CryptExportKey(
    hKey: usize,
    hExpKey: usize,
    dwBlobType: u32,
    dwFlags: CRYPT_KEY_FLAGS,
    // TODO: what to do with BytesParamIndex 5?
    pbData: ?*u8,
    pdwDataLen: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn CryptImportKey(
    hProv: usize,
    // TODO: what to do with BytesParamIndex 2?
    pbData: ?*const u8,
    dwDataLen: u32,
    hPubKey: usize,
    dwFlags: CRYPT_KEY_FLAGS,
    phKey: ?*usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn CryptEncrypt(
    hKey: usize,
    hHash: usize,
    Final: BOOL,
    dwFlags: u32,
    // TODO: what to do with BytesParamIndex 6?
    pbData: ?*u8,
    pdwDataLen: ?*u32,
    dwBufLen: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn CryptDecrypt(
    hKey: usize,
    hHash: usize,
    Final: BOOL,
    dwFlags: u32,
    // TODO: what to do with BytesParamIndex 5?
    pbData: ?*u8,
    pdwDataLen: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn CryptCreateHash(
    hProv: usize,
    Algid: u32,
    hKey: usize,
    dwFlags: u32,
    phHash: ?*usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn CryptHashData(
    hHash: usize,
    // TODO: what to do with BytesParamIndex 2?
    pbData: ?*const u8,
    dwDataLen: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn CryptHashSessionKey(
    hHash: usize,
    hKey: usize,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn CryptDestroyHash(
    hHash: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn CryptSignHashA(
    hHash: usize,
    dwKeySpec: u32,
    szDescription: ?[*:0]const u8,
    dwFlags: u32,
    // TODO: what to do with BytesParamIndex 5?
    pbSignature: ?*u8,
    pdwSigLen: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn CryptSignHashW(
    hHash: usize,
    dwKeySpec: u32,
    szDescription: ?[*:0]const u16,
    dwFlags: u32,
    // TODO: what to do with BytesParamIndex 5?
    pbSignature: ?*u8,
    pdwSigLen: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn CryptVerifySignatureA(
    hHash: usize,
    // TODO: what to do with BytesParamIndex 2?
    pbSignature: ?*const u8,
    dwSigLen: u32,
    hPubKey: usize,
    szDescription: ?[*:0]const u8,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn CryptVerifySignatureW(
    hHash: usize,
    // TODO: what to do with BytesParamIndex 2?
    pbSignature: ?*const u8,
    dwSigLen: u32,
    hPubKey: usize,
    szDescription: ?[*:0]const u16,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn CryptSetProviderA(
    pszProvName: ?[*:0]const u8,
    dwProvType: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn CryptSetProviderW(
    pszProvName: ?[*:0]const u16,
    dwProvType: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn CryptSetProviderExA(
    pszProvName: ?[*:0]const u8,
    dwProvType: u32,
    pdwReserved: ?*u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn CryptSetProviderExW(
    pszProvName: ?[*:0]const u16,
    dwProvType: u32,
    pdwReserved: ?*u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn CryptGetDefaultProviderA(
    dwProvType: u32,
    pdwReserved: ?*u32,
    dwFlags: u32,
    // TODO: what to do with BytesParamIndex 4?
    pszProvName: ?PSTR,
    pcbProvName: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn CryptGetDefaultProviderW(
    dwProvType: u32,
    pdwReserved: ?*u32,
    dwFlags: u32,
    // TODO: what to do with BytesParamIndex 4?
    pszProvName: ?PWSTR,
    pcbProvName: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn CryptEnumProviderTypesA(
    dwIndex: u32,
    pdwReserved: ?*u32,
    dwFlags: u32,
    pdwProvType: ?*u32,
    // TODO: what to do with BytesParamIndex 5?
    szTypeName: ?PSTR,
    pcbTypeName: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn CryptEnumProviderTypesW(
    dwIndex: u32,
    pdwReserved: ?*u32,
    dwFlags: u32,
    pdwProvType: ?*u32,
    // TODO: what to do with BytesParamIndex 5?
    szTypeName: ?PWSTR,
    pcbTypeName: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn CryptEnumProvidersA(
    dwIndex: u32,
    pdwReserved: ?*u32,
    dwFlags: u32,
    pdwProvType: ?*u32,
    // TODO: what to do with BytesParamIndex 5?
    szProvName: ?PSTR,
    pcbProvName: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn CryptEnumProvidersW(
    dwIndex: u32,
    pdwReserved: ?*u32,
    dwFlags: u32,
    pdwProvType: ?*u32,
    // TODO: what to do with BytesParamIndex 5?
    szProvName: ?PWSTR,
    pcbProvName: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn CryptContextAddRef(
    hProv: usize,
    pdwReserved: ?*u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn CryptDuplicateKey(
    hKey: usize,
    pdwReserved: ?*u32,
    dwFlags: u32,
    phKey: ?*usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "advapi32" fn CryptDuplicateHash(
    hHash: usize,
    pdwReserved: ?*u32,
    dwFlags: u32,
    phHash: ?*usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptOpenAlgorithmProvider(
    phAlgorithm: ?*BCRYPT_ALG_HANDLE,
    pszAlgId: ?[*:0]const u16,
    pszImplementation: ?[*:0]const u16,
    dwFlags: BCRYPT_OPEN_ALGORITHM_PROVIDER_FLAGS,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptEnumAlgorithms(
    dwAlgOperations: BCRYPT_OPERATION,
    pAlgCount: ?*u32,
    ppAlgList: ?*?*BCRYPT_ALGORITHM_IDENTIFIER,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptEnumProviders(
    pszAlgId: ?[*:0]const u16,
    pImplCount: ?*u32,
    ppImplList: ?*?*BCRYPT_PROVIDER_NAME,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptGetProperty(
    hObject: BCRYPT_HANDLE,
    pszProperty: ?[*:0]const u16,
    // TODO: what to do with BytesParamIndex 3?
    pbOutput: ?*u8,
    cbOutput: u32,
    pcbResult: ?*u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptSetProperty(
    hObject: BCRYPT_HANDLE,
    pszProperty: ?[*:0]const u16,
    // TODO: what to do with BytesParamIndex 3?
    pbInput: ?*u8,
    cbInput: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptCloseAlgorithmProvider(
    hAlgorithm: BCRYPT_ALG_HANDLE,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptFreeBuffer(
    pvBuffer: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptGenerateSymmetricKey(
    hAlgorithm: BCRYPT_ALG_HANDLE,
    phKey: ?*BCRYPT_KEY_HANDLE,
    // TODO: what to do with BytesParamIndex 3?
    pbKeyObject: ?*u8,
    cbKeyObject: u32,
    // TODO: what to do with BytesParamIndex 5?
    pbSecret: ?*u8,
    cbSecret: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptGenerateKeyPair(
    hAlgorithm: BCRYPT_ALG_HANDLE,
    phKey: ?*BCRYPT_KEY_HANDLE,
    dwLength: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptEncrypt(
    hKey: BCRYPT_KEY_HANDLE,
    // TODO: what to do with BytesParamIndex 2?
    pbInput: ?*u8,
    cbInput: u32,
    pPaddingInfo: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 5?
    pbIV: ?*u8,
    cbIV: u32,
    // TODO: what to do with BytesParamIndex 7?
    pbOutput: ?*u8,
    cbOutput: u32,
    pcbResult: ?*u32,
    dwFlags: NCRYPT_FLAGS,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptDecrypt(
    hKey: BCRYPT_KEY_HANDLE,
    // TODO: what to do with BytesParamIndex 2?
    pbInput: ?*u8,
    cbInput: u32,
    pPaddingInfo: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 5?
    pbIV: ?*u8,
    cbIV: u32,
    // TODO: what to do with BytesParamIndex 7?
    pbOutput: ?*u8,
    cbOutput: u32,
    pcbResult: ?*u32,
    dwFlags: NCRYPT_FLAGS,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptExportKey(
    hKey: BCRYPT_KEY_HANDLE,
    hExportKey: BCRYPT_KEY_HANDLE,
    pszBlobType: ?[*:0]const u16,
    // TODO: what to do with BytesParamIndex 4?
    pbOutput: ?*u8,
    cbOutput: u32,
    pcbResult: ?*u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptImportKey(
    hAlgorithm: BCRYPT_ALG_HANDLE,
    hImportKey: BCRYPT_KEY_HANDLE,
    pszBlobType: ?[*:0]const u16,
    phKey: ?*BCRYPT_KEY_HANDLE,
    // TODO: what to do with BytesParamIndex 5?
    pbKeyObject: ?*u8,
    cbKeyObject: u32,
    // TODO: what to do with BytesParamIndex 7?
    pbInput: ?*u8,
    cbInput: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptImportKeyPair(
    hAlgorithm: BCRYPT_ALG_HANDLE,
    hImportKey: BCRYPT_KEY_HANDLE,
    pszBlobType: ?[*:0]const u16,
    phKey: ?*BCRYPT_KEY_HANDLE,
    // TODO: what to do with BytesParamIndex 5?
    pbInput: ?*u8,
    cbInput: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptDuplicateKey(
    hKey: BCRYPT_KEY_HANDLE,
    phNewKey: ?*BCRYPT_KEY_HANDLE,
    // TODO: what to do with BytesParamIndex 3?
    pbKeyObject: ?*u8,
    cbKeyObject: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptFinalizeKeyPair(
    hKey: BCRYPT_KEY_HANDLE,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptDestroyKey(
    hKey: BCRYPT_KEY_HANDLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptDestroySecret(
    hSecret: BCRYPT_SECRET_HANDLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptSignHash(
    hKey: BCRYPT_KEY_HANDLE,
    pPaddingInfo: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 3?
    pbInput: ?*u8,
    cbInput: u32,
    // TODO: what to do with BytesParamIndex 5?
    pbOutput: ?*u8,
    cbOutput: u32,
    pcbResult: ?*u32,
    dwFlags: NCRYPT_FLAGS,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptVerifySignature(
    hKey: BCRYPT_KEY_HANDLE,
    pPaddingInfo: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 3?
    pbHash: ?*u8,
    cbHash: u32,
    // TODO: what to do with BytesParamIndex 5?
    pbSignature: ?*u8,
    cbSignature: u32,
    dwFlags: NCRYPT_FLAGS,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptSecretAgreement(
    hPrivKey: BCRYPT_KEY_HANDLE,
    hPubKey: BCRYPT_KEY_HANDLE,
    phAgreedSecret: ?*BCRYPT_SECRET_HANDLE,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptDeriveKey(
    hSharedSecret: BCRYPT_SECRET_HANDLE,
    pwszKDF: ?[*:0]const u16,
    pParameterList: ?*BCryptBufferDesc,
    // TODO: what to do with BytesParamIndex 4?
    pbDerivedKey: ?*u8,
    cbDerivedKey: u32,
    pcbResult: ?*u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows8.0'
pub extern "bcrypt" fn BCryptKeyDerivation(
    hKey: BCRYPT_KEY_HANDLE,
    pParameterList: ?*BCryptBufferDesc,
    // TODO: what to do with BytesParamIndex 3?
    pbDerivedKey: ?*u8,
    cbDerivedKey: u32,
    pcbResult: ?*u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptCreateHash(
    hAlgorithm: BCRYPT_ALG_HANDLE,
    phHash: ?*BCRYPT_HASH_HANDLE,
    // TODO: what to do with BytesParamIndex 3?
    pbHashObject: ?*u8,
    cbHashObject: u32,
    // TODO: what to do with BytesParamIndex 5?
    pbSecret: ?*u8,
    cbSecret: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptHashData(
    hHash: BCRYPT_HASH_HANDLE,
    // TODO: what to do with BytesParamIndex 2?
    pbInput: ?*u8,
    cbInput: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptFinishHash(
    hHash: BCRYPT_HASH_HANDLE,
    // TODO: what to do with BytesParamIndex 2?
    pbOutput: ?*u8,
    cbOutput: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows8.1'
pub extern "bcrypt" fn BCryptCreateMultiHash(
    hAlgorithm: BCRYPT_ALG_HANDLE,
    phHash: ?*BCRYPT_HASH_HANDLE,
    nHashes: u32,
    // TODO: what to do with BytesParamIndex 4?
    pbHashObject: ?*u8,
    cbHashObject: u32,
    // TODO: what to do with BytesParamIndex 6?
    pbSecret: ?*u8,
    cbSecret: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows8.1'
pub extern "bcrypt" fn BCryptProcessMultiOperations(
    hObject: BCRYPT_HANDLE,
    operationType: BCRYPT_MULTI_OPERATION_TYPE,
    // TODO: what to do with BytesParamIndex 3?
    pOperations: ?*anyopaque,
    cbOperations: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptDuplicateHash(
    hHash: BCRYPT_HASH_HANDLE,
    phNewHash: ?*BCRYPT_HASH_HANDLE,
    // TODO: what to do with BytesParamIndex 3?
    pbHashObject: ?*u8,
    cbHashObject: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptDestroyHash(
    hHash: BCRYPT_HASH_HANDLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "bcrypt" fn BCryptHash(
    hAlgorithm: BCRYPT_ALG_HANDLE,
    // TODO: what to do with BytesParamIndex 2?
    pbSecret: ?*u8,
    cbSecret: u32,
    // TODO: what to do with BytesParamIndex 4?
    pbInput: ?*u8,
    cbInput: u32,
    // TODO: what to do with BytesParamIndex 6?
    pbOutput: ?*u8,
    cbOutput: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptGenRandom(
    hAlgorithm: BCRYPT_ALG_HANDLE,
    // TODO: what to do with BytesParamIndex 2?
    pbBuffer: ?*u8,
    cbBuffer: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.1'
pub extern "bcrypt" fn BCryptDeriveKeyCapi(
    hHash: BCRYPT_HASH_HANDLE,
    hTargetAlg: BCRYPT_ALG_HANDLE,
    // TODO: what to do with BytesParamIndex 3?
    pbDerivedKey: ?*u8,
    cbDerivedKey: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.1'
pub extern "bcrypt" fn BCryptDeriveKeyPBKDF2(
    hPrf: BCRYPT_ALG_HANDLE,
    // TODO: what to do with BytesParamIndex 2?
    pbPassword: ?*u8,
    cbPassword: u32,
    // TODO: what to do with BytesParamIndex 4?
    pbSalt: ?*u8,
    cbSalt: u32,
    cIterations: u64,
    // TODO: what to do with BytesParamIndex 7?
    pbDerivedKey: ?*u8,
    cbDerivedKey: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptQueryProviderRegistration(
    pszProvider: ?[*:0]const u16,
    dwMode: BCRYPT_QUERY_PROVIDER_MODE,
    dwInterface: BCRYPT_INTERFACE,
    pcbBuffer: ?*u32,
    // TODO: what to do with BytesParamIndex 3?
    ppBuffer: ?*?*CRYPT_PROVIDER_REG,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptEnumRegisteredProviders(
    pcbBuffer: ?*u32,
    // TODO: what to do with BytesParamIndex 0?
    ppBuffer: ?*?*CRYPT_PROVIDERS,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptCreateContext(
    dwTable: BCRYPT_TABLE,
    pszContext: ?[*:0]const u16,
    pConfig: ?*CRYPT_CONTEXT_CONFIG,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptDeleteContext(
    dwTable: BCRYPT_TABLE,
    pszContext: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptEnumContexts(
    dwTable: BCRYPT_TABLE,
    pcbBuffer: ?*u32,
    // TODO: what to do with BytesParamIndex 1?
    ppBuffer: ?*?*CRYPT_CONTEXTS,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptConfigureContext(
    dwTable: BCRYPT_TABLE,
    pszContext: ?[*:0]const u16,
    pConfig: ?*CRYPT_CONTEXT_CONFIG,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptQueryContextConfiguration(
    dwTable: BCRYPT_TABLE,
    pszContext: ?[*:0]const u16,
    pcbBuffer: ?*u32,
    // TODO: what to do with BytesParamIndex 2?
    ppBuffer: ?*?*CRYPT_CONTEXT_CONFIG,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptAddContextFunction(
    dwTable: BCRYPT_TABLE,
    pszContext: ?[*:0]const u16,
    dwInterface: BCRYPT_INTERFACE,
    pszFunction: ?[*:0]const u16,
    dwPosition: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptRemoveContextFunction(
    dwTable: BCRYPT_TABLE,
    pszContext: ?[*:0]const u16,
    dwInterface: BCRYPT_INTERFACE,
    pszFunction: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptEnumContextFunctions(
    dwTable: BCRYPT_TABLE,
    pszContext: ?[*:0]const u16,
    dwInterface: BCRYPT_INTERFACE,
    pcbBuffer: ?*u32,
    // TODO: what to do with BytesParamIndex 3?
    ppBuffer: ?*?*CRYPT_CONTEXT_FUNCTIONS,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptConfigureContextFunction(
    dwTable: BCRYPT_TABLE,
    pszContext: ?[*:0]const u16,
    dwInterface: BCRYPT_INTERFACE,
    pszFunction: ?[*:0]const u16,
    pConfig: ?*CRYPT_CONTEXT_FUNCTION_CONFIG,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptQueryContextFunctionConfiguration(
    dwTable: BCRYPT_TABLE,
    pszContext: ?[*:0]const u16,
    dwInterface: BCRYPT_INTERFACE,
    pszFunction: ?[*:0]const u16,
    pcbBuffer: ?*u32,
    // TODO: what to do with BytesParamIndex 4?
    ppBuffer: ?*?*CRYPT_CONTEXT_FUNCTION_CONFIG,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptEnumContextFunctionProviders(
    dwTable: BCRYPT_TABLE,
    pszContext: ?[*:0]const u16,
    dwInterface: BCRYPT_INTERFACE,
    pszFunction: ?[*:0]const u16,
    pcbBuffer: ?*u32,
    // TODO: what to do with BytesParamIndex 4?
    ppBuffer: ?*?*CRYPT_CONTEXT_FUNCTION_PROVIDERS,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptSetContextFunctionProperty(
    dwTable: BCRYPT_TABLE,
    pszContext: ?[*:0]const u16,
    dwInterface: BCRYPT_INTERFACE,
    pszFunction: ?[*:0]const u16,
    pszProperty: ?[*:0]const u16,
    cbValue: u32,
    // TODO: what to do with BytesParamIndex 5?
    pbValue: ?*u8,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptQueryContextFunctionProperty(
    dwTable: BCRYPT_TABLE,
    pszContext: ?[*:0]const u16,
    dwInterface: BCRYPT_INTERFACE,
    pszFunction: ?[*:0]const u16,
    pszProperty: ?[*:0]const u16,
    pcbValue: ?*u32,
    // TODO: what to do with BytesParamIndex 5?
    ppbValue: ?*?*u8,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptRegisterConfigChangeNotify(
    phEvent: ?*?HANDLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptUnregisterConfigChangeNotify(
    hEvent: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptResolveProviders(
    pszContext: ?[*:0]const u16,
    dwInterface: u32,
    pszFunction: ?[*:0]const u16,
    pszProvider: ?[*:0]const u16,
    dwMode: BCRYPT_QUERY_PROVIDER_MODE,
    dwFlags: BCRYPT_RESOLVE_PROVIDERS_FLAGS,
    pcbBuffer: ?*u32,
    // TODO: what to do with BytesParamIndex 6?
    ppBuffer: ?*?*CRYPT_PROVIDER_REFS,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptGetFipsAlgorithmMode(
    pfEnabled: ?*u8,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ncrypt" fn NCryptOpenStorageProvider(
    phProvider: ?*NCRYPT_PROV_HANDLE,
    pszProviderName: ?[*:0]const u16,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ncrypt" fn NCryptEnumAlgorithms(
    hProvider: NCRYPT_PROV_HANDLE,
    dwAlgOperations: NCRYPT_OPERATION,
    pdwAlgCount: ?*u32,
    ppAlgList: ?*?*NCryptAlgorithmName,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ncrypt" fn NCryptIsAlgSupported(
    hProvider: NCRYPT_PROV_HANDLE,
    pszAlgId: ?[*:0]const u16,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ncrypt" fn NCryptEnumKeys(
    hProvider: NCRYPT_PROV_HANDLE,
    pszScope: ?[*:0]const u16,
    ppKeyName: ?*?*NCryptKeyName,
    ppEnumState: ?*?*anyopaque,
    dwFlags: NCRYPT_FLAGS,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ncrypt" fn NCryptEnumStorageProviders(
    pdwProviderCount: ?*u32,
    ppProviderList: ?*?*NCryptProviderName,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ncrypt" fn NCryptFreeBuffer(
    pvInput: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
// This function from dll 'ncrypt' is being skipped because it has some sort of issue
pub fn NCryptOpenKey() void { @panic("this function is not working"); }

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ncrypt" fn NCryptCreatePersistedKey(
    hProvider: NCRYPT_PROV_HANDLE,
    phKey: ?*NCRYPT_KEY_HANDLE,
    pszAlgId: ?[*:0]const u16,
    pszKeyName: ?[*:0]const u16,
    dwLegacyKeySpec: CERT_KEY_SPEC,
    dwFlags: NCRYPT_FLAGS,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ncrypt" fn NCryptGetProperty(
    hObject: NCRYPT_HANDLE,
    pszProperty: ?[*:0]const u16,
    // TODO: what to do with BytesParamIndex 3?
    pbOutput: ?*u8,
    cbOutput: u32,
    pcbResult: ?*u32,
    dwFlags: OBJECT_SECURITY_INFORMATION,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ncrypt" fn NCryptSetProperty(
    hObject: NCRYPT_HANDLE,
    pszProperty: ?[*:0]const u16,
    // TODO: what to do with BytesParamIndex 3?
    pbInput: ?*u8,
    cbInput: u32,
    dwFlags: NCRYPT_FLAGS,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ncrypt" fn NCryptFinalizeKey(
    hKey: NCRYPT_KEY_HANDLE,
    dwFlags: NCRYPT_FLAGS,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ncrypt" fn NCryptEncrypt(
    hKey: NCRYPT_KEY_HANDLE,
    // TODO: what to do with BytesParamIndex 2?
    pbInput: ?*u8,
    cbInput: u32,
    pPaddingInfo: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 5?
    pbOutput: ?*u8,
    cbOutput: u32,
    pcbResult: ?*u32,
    dwFlags: NCRYPT_FLAGS,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ncrypt" fn NCryptDecrypt(
    hKey: NCRYPT_KEY_HANDLE,
    // TODO: what to do with BytesParamIndex 2?
    pbInput: ?*u8,
    cbInput: u32,
    pPaddingInfo: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 5?
    pbOutput: ?*u8,
    cbOutput: u32,
    pcbResult: ?*u32,
    dwFlags: NCRYPT_FLAGS,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ncrypt" fn NCryptImportKey(
    hProvider: NCRYPT_PROV_HANDLE,
    hImportKey: NCRYPT_KEY_HANDLE,
    pszBlobType: ?[*:0]const u16,
    pParameterList: ?*BCryptBufferDesc,
    phKey: ?*NCRYPT_KEY_HANDLE,
    // TODO: what to do with BytesParamIndex 6?
    pbData: ?*u8,
    cbData: u32,
    dwFlags: NCRYPT_FLAGS,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ncrypt" fn NCryptExportKey(
    hKey: NCRYPT_KEY_HANDLE,
    hExportKey: NCRYPT_KEY_HANDLE,
    pszBlobType: ?[*:0]const u16,
    pParameterList: ?*BCryptBufferDesc,
    // TODO: what to do with BytesParamIndex 5?
    pbOutput: ?*u8,
    cbOutput: u32,
    pcbResult: ?*u32,
    dwFlags: NCRYPT_FLAGS,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ncrypt" fn NCryptSignHash(
    hKey: NCRYPT_KEY_HANDLE,
    pPaddingInfo: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 3?
    pbHashValue: ?*u8,
    cbHashValue: u32,
    // TODO: what to do with BytesParamIndex 5?
    pbSignature: ?*u8,
    cbSignature: u32,
    pcbResult: ?*u32,
    dwFlags: NCRYPT_FLAGS,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ncrypt" fn NCryptVerifySignature(
    hKey: NCRYPT_KEY_HANDLE,
    pPaddingInfo: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 3?
    pbHashValue: ?*u8,
    cbHashValue: u32,
    // TODO: what to do with BytesParamIndex 5?
    pbSignature: ?*u8,
    cbSignature: u32,
    dwFlags: NCRYPT_FLAGS,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ncrypt" fn NCryptDeleteKey(
    hKey: NCRYPT_KEY_HANDLE,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ncrypt" fn NCryptFreeObject(
    hObject: NCRYPT_HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ncrypt" fn NCryptIsKeyHandle(
    hKey: NCRYPT_KEY_HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
// This function from dll 'ncrypt' is being skipped because it has some sort of issue
pub fn NCryptTranslateHandle() void { @panic("this function is not working"); }

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ncrypt" fn NCryptNotifyChangeKey(
    hProvider: NCRYPT_PROV_HANDLE,
    phEvent: ?*?HANDLE,
    dwFlags: NCRYPT_FLAGS,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ncrypt" fn NCryptSecretAgreement(
    hPrivKey: NCRYPT_KEY_HANDLE,
    hPubKey: NCRYPT_KEY_HANDLE,
    phAgreedSecret: ?*NCRYPT_SECRET_HANDLE,
    dwFlags: NCRYPT_FLAGS,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ncrypt" fn NCryptDeriveKey(
    hSharedSecret: NCRYPT_SECRET_HANDLE,
    pwszKDF: ?[*:0]const u16,
    pParameterList: ?*BCryptBufferDesc,
    // TODO: what to do with BytesParamIndex 4?
    pbDerivedKey: ?*u8,
    cbDerivedKey: u32,
    pcbResult: ?*u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "ncrypt" fn NCryptKeyDerivation(
    hKey: NCRYPT_KEY_HANDLE,
    pParameterList: ?*BCryptBufferDesc,
    // TODO: what to do with BytesParamIndex 3?
    pbDerivedKey: ?*u8,
    cbDerivedKey: u32,
    pcbResult: ?*u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "ncrypt" fn NCryptCreateClaim(
    hSubjectKey: NCRYPT_KEY_HANDLE,
    hAuthorityKey: NCRYPT_KEY_HANDLE,
    dwClaimType: u32,
    pParameterList: ?*BCryptBufferDesc,
    // TODO: what to do with BytesParamIndex 5?
    pbClaimBlob: ?*u8,
    cbClaimBlob: u32,
    pcbResult: ?*u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "ncrypt" fn NCryptVerifyClaim(
    hSubjectKey: NCRYPT_KEY_HANDLE,
    hAuthorityKey: NCRYPT_KEY_HANDLE,
    dwClaimType: u32,
    pParameterList: ?*BCryptBufferDesc,
    // TODO: what to do with BytesParamIndex 5?
    pbClaimBlob: ?*u8,
    cbClaimBlob: u32,
    pOutput: ?*BCryptBufferDesc,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptFormatObject(
    dwCertEncodingType: u32,
    dwFormatType: u32,
    dwFormatStrType: u32,
    pFormatStruct: ?*anyopaque,
    lpszStructType: ?[*:0]const u8,
    // TODO: what to do with BytesParamIndex 6?
    pbEncoded: ?*const u8,
    cbEncoded: u32,
    // TODO: what to do with BytesParamIndex 8?
    pbFormat: ?*anyopaque,
    pcbFormat: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptEncodeObjectEx(
    dwCertEncodingType: CERT_QUERY_ENCODING_TYPE,
    lpszStructType: ?[*:0]const u8,
    pvStructInfo: ?*const anyopaque,
    dwFlags: CRYPT_ENCODE_OBJECT_FLAGS,
    pEncodePara: ?*CRYPT_ENCODE_PARA,
    pvEncoded: ?*anyopaque,
    pcbEncoded: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptEncodeObject(
    dwCertEncodingType: u32,
    lpszStructType: ?[*:0]const u8,
    pvStructInfo: ?*const anyopaque,
    // TODO: what to do with BytesParamIndex 4?
    pbEncoded: ?*u8,
    pcbEncoded: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptDecodeObjectEx(
    dwCertEncodingType: u32,
    lpszStructType: ?[*:0]const u8,
    // TODO: what to do with BytesParamIndex 3?
    pbEncoded: ?*const u8,
    cbEncoded: u32,
    dwFlags: u32,
    pDecodePara: ?*CRYPT_DECODE_PARA,
    pvStructInfo: ?*anyopaque,
    pcbStructInfo: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptDecodeObject(
    dwCertEncodingType: u32,
    lpszStructType: ?[*:0]const u8,
    // TODO: what to do with BytesParamIndex 3?
    pbEncoded: ?*const u8,
    cbEncoded: u32,
    dwFlags: u32,
    // TODO: what to do with BytesParamIndex 6?
    pvStructInfo: ?*anyopaque,
    pcbStructInfo: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptInstallOIDFunctionAddress(
    hModule: ?HINSTANCE,
    dwEncodingType: u32,
    pszFuncName: ?[*:0]const u8,
    cFuncEntry: u32,
    rgFuncEntry: [*]const CRYPT_OID_FUNC_ENTRY,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptInitOIDFunctionSet(
    pszFuncName: ?[*:0]const u8,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptGetOIDFunctionAddress(
    hFuncSet: ?*anyopaque,
    dwEncodingType: u32,
    pszOID: ?[*:0]const u8,
    dwFlags: u32,
    ppvFuncAddr: ?*?*anyopaque,
    phFuncAddr: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptGetDefaultOIDDllList(
    hFuncSet: ?*anyopaque,
    dwEncodingType: u32,
    pwszDllList: ?[*:0]u16,
    pcchDllList: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptGetDefaultOIDFunctionAddress(
    hFuncSet: ?*anyopaque,
    dwEncodingType: u32,
    pwszDll: ?[*:0]const u16,
    dwFlags: u32,
    ppvFuncAddr: ?*?*anyopaque,
    phFuncAddr: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptFreeOIDFunctionAddress(
    hFuncAddr: ?*anyopaque,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptRegisterOIDFunction(
    dwEncodingType: u32,
    pszFuncName: ?[*:0]const u8,
    pszOID: ?[*:0]const u8,
    pwszDll: ?[*:0]const u16,
    pszOverrideFuncName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptUnregisterOIDFunction(
    dwEncodingType: u32,
    pszFuncName: ?[*:0]const u8,
    pszOID: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptRegisterDefaultOIDFunction(
    dwEncodingType: u32,
    pszFuncName: ?[*:0]const u8,
    dwIndex: u32,
    pwszDll: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptUnregisterDefaultOIDFunction(
    dwEncodingType: u32,
    pszFuncName: ?[*:0]const u8,
    pwszDll: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptSetOIDFunctionValue(
    dwEncodingType: u32,
    pszFuncName: ?[*:0]const u8,
    pszOID: ?[*:0]const u8,
    pwszValueName: ?[*:0]const u16,
    dwValueType: REG_VALUE_TYPE,
    // TODO: what to do with BytesParamIndex 6?
    pbValueData: ?*const u8,
    cbValueData: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptGetOIDFunctionValue(
    dwEncodingType: u32,
    pszFuncName: ?[*:0]const u8,
    pszOID: ?[*:0]const u8,
    pwszValueName: ?[*:0]const u16,
    pdwValueType: ?*u32,
    // TODO: what to do with BytesParamIndex 6?
    pbValueData: ?*u8,
    pcbValueData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptEnumOIDFunction(
    dwEncodingType: u32,
    pszFuncName: ?[*:0]const u8,
    pszOID: ?[*:0]const u8,
    dwFlags: u32,
    pvArg: ?*anyopaque,
    pfnEnumOIDFunc: ?PFN_CRYPT_ENUM_OID_FUNC,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptFindOIDInfo(
    dwKeyType: u32,
    pvKey: ?*anyopaque,
    dwGroupId: u32,
) callconv(@import("std").os.windows.WINAPI) ?*CRYPT_OID_INFO;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptRegisterOIDInfo(
    pInfo: ?*CRYPT_OID_INFO,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptUnregisterOIDInfo(
    pInfo: ?*CRYPT_OID_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptEnumOIDInfo(
    dwGroupId: u32,
    dwFlags: u32,
    pvArg: ?*anyopaque,
    pfnEnumOIDInfo: ?PFN_CRYPT_ENUM_OID_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptFindLocalizedName(
    pwszCryptName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptMsgOpenToEncode(
    dwMsgEncodingType: u32,
    dwFlags: u32,
    dwMsgType: CRYPT_MSG_TYPE,
    pvMsgEncodeInfo: ?*const anyopaque,
    pszInnerContentObjID: ?PSTR,
    pStreamInfo: ?*CMSG_STREAM_INFO,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptMsgCalculateEncodedLength(
    dwMsgEncodingType: u32,
    dwFlags: u32,
    dwMsgType: u32,
    pvMsgEncodeInfo: ?*const anyopaque,
    pszInnerContentObjID: ?PSTR,
    cbData: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptMsgOpenToDecode(
    dwMsgEncodingType: u32,
    dwFlags: u32,
    dwMsgType: u32,
    hCryptProv: HCRYPTPROV_LEGACY,
    pRecipientInfo: ?*CERT_INFO,
    pStreamInfo: ?*CMSG_STREAM_INFO,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptMsgDuplicate(
    hCryptMsg: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptMsgClose(
    hCryptMsg: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptMsgUpdate(
    hCryptMsg: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 2?
    pbData: ?*const u8,
    cbData: u32,
    fFinal: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptMsgGetParam(
    hCryptMsg: ?*anyopaque,
    dwParamType: u32,
    dwIndex: u32,
    // TODO: what to do with BytesParamIndex 4?
    pvData: ?*anyopaque,
    pcbData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptMsgControl(
    hCryptMsg: ?*anyopaque,
    dwFlags: u32,
    dwCtrlType: u32,
    pvCtrlPara: ?*const anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptMsgVerifyCountersignatureEncoded(
    hCryptProv: HCRYPTPROV_LEGACY,
    dwEncodingType: u32,
    // TODO: what to do with BytesParamIndex 3?
    pbSignerInfo: ?*u8,
    cbSignerInfo: u32,
    // TODO: what to do with BytesParamIndex 5?
    pbSignerInfoCountersignature: ?*u8,
    cbSignerInfoCountersignature: u32,
    pciCountersigner: ?*CERT_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptMsgVerifyCountersignatureEncodedEx(
    hCryptProv: HCRYPTPROV_LEGACY,
    dwEncodingType: u32,
    // TODO: what to do with BytesParamIndex 3?
    pbSignerInfo: ?*u8,
    cbSignerInfo: u32,
    // TODO: what to do with BytesParamIndex 5?
    pbSignerInfoCountersignature: ?*u8,
    cbSignerInfoCountersignature: u32,
    dwSignerType: u32,
    pvSigner: ?*anyopaque,
    dwFlags: u32,
    pvExtra: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptMsgCountersign(
    hCryptMsg: ?*anyopaque,
    dwIndex: u32,
    cCountersigners: u32,
    rgCountersigners: [*]CMSG_SIGNER_ENCODE_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptMsgCountersignEncoded(
    dwEncodingType: u32,
    // TODO: what to do with BytesParamIndex 2?
    pbSignerInfo: ?*u8,
    cbSignerInfo: u32,
    cCountersigners: u32,
    rgCountersigners: [*]CMSG_SIGNER_ENCODE_INFO,
    // TODO: what to do with BytesParamIndex 6?
    pbCountersignature: ?*u8,
    pcbCountersignature: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertOpenStore(
    lpszStoreProvider: ?[*:0]const u8,
    dwEncodingType: CERT_QUERY_ENCODING_TYPE,
    hCryptProv: HCRYPTPROV_LEGACY,
    dwFlags: CERT_OPEN_STORE_FLAGS,
    pvPara: ?*const anyopaque,
) callconv(@import("std").os.windows.WINAPI) ?HCERTSTORE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertDuplicateStore(
    hCertStore: ?HCERTSTORE,
) callconv(@import("std").os.windows.WINAPI) ?HCERTSTORE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertSaveStore(
    hCertStore: ?HCERTSTORE,
    dwEncodingType: CERT_QUERY_ENCODING_TYPE,
    dwSaveAs: CERT_STORE_SAVE_AS,
    dwSaveTo: CERT_STORE_SAVE_TO,
    pvSaveToPara: ?*anyopaque,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertCloseStore(
    hCertStore: ?HCERTSTORE,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertGetSubjectCertificateFromStore(
    hCertStore: ?HCERTSTORE,
    dwCertEncodingType: u32,
    pCertId: ?*CERT_INFO,
) callconv(@import("std").os.windows.WINAPI) ?*CERT_CONTEXT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertEnumCertificatesInStore(
    hCertStore: ?HCERTSTORE,
    pPrevCertContext: ?*const CERT_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) ?*CERT_CONTEXT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertFindCertificateInStore(
    hCertStore: ?HCERTSTORE,
    dwCertEncodingType: u32,
    dwFindFlags: u32,
    dwFindType: CERT_FIND_FLAGS,
    pvFindPara: ?*const anyopaque,
    pPrevCertContext: ?*const CERT_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) ?*CERT_CONTEXT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertGetIssuerCertificateFromStore(
    hCertStore: ?HCERTSTORE,
    pSubjectContext: ?*const CERT_CONTEXT,
    pPrevIssuerContext: ?*const CERT_CONTEXT,
    pdwFlags: ?*u32,
) callconv(@import("std").os.windows.WINAPI) ?*CERT_CONTEXT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertVerifySubjectCertificateContext(
    pSubject: ?*const CERT_CONTEXT,
    pIssuer: ?*const CERT_CONTEXT,
    pdwFlags: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertDuplicateCertificateContext(
    pCertContext: ?*const CERT_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) ?*CERT_CONTEXT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertCreateCertificateContext(
    dwCertEncodingType: u32,
    // TODO: what to do with BytesParamIndex 2?
    pbCertEncoded: ?*const u8,
    cbCertEncoded: u32,
) callconv(@import("std").os.windows.WINAPI) ?*CERT_CONTEXT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertFreeCertificateContext(
    pCertContext: ?*const CERT_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertSetCertificateContextProperty(
    pCertContext: ?*const CERT_CONTEXT,
    dwPropId: u32,
    dwFlags: u32,
    pvData: ?*const anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertGetCertificateContextProperty(
    pCertContext: ?*const CERT_CONTEXT,
    dwPropId: u32,
    // TODO: what to do with BytesParamIndex 3?
    pvData: ?*anyopaque,
    pcbData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertEnumCertificateContextProperties(
    pCertContext: ?*const CERT_CONTEXT,
    dwPropId: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertCreateCTLEntryFromCertificateContextProperties(
    pCertContext: ?*const CERT_CONTEXT,
    cOptAttr: u32,
    rgOptAttr: ?[*]CRYPT_ATTRIBUTE,
    dwFlags: u32,
    pvReserved: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 6?
    pCtlEntry: ?*CTL_ENTRY,
    pcbCtlEntry: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertSetCertificateContextPropertiesFromCTLEntry(
    pCertContext: ?*const CERT_CONTEXT,
    pCtlEntry: ?*CTL_ENTRY,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertGetCRLFromStore(
    hCertStore: ?HCERTSTORE,
    pIssuerContext: ?*const CERT_CONTEXT,
    pPrevCrlContext: ?*CRL_CONTEXT,
    pdwFlags: ?*u32,
) callconv(@import("std").os.windows.WINAPI) ?*CRL_CONTEXT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertEnumCRLsInStore(
    hCertStore: ?HCERTSTORE,
    pPrevCrlContext: ?*CRL_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) ?*CRL_CONTEXT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertFindCRLInStore(
    hCertStore: ?HCERTSTORE,
    dwCertEncodingType: u32,
    dwFindFlags: u32,
    dwFindType: u32,
    pvFindPara: ?*const anyopaque,
    pPrevCrlContext: ?*CRL_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) ?*CRL_CONTEXT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertDuplicateCRLContext(
    pCrlContext: ?*CRL_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) ?*CRL_CONTEXT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertCreateCRLContext(
    dwCertEncodingType: u32,
    // TODO: what to do with BytesParamIndex 2?
    pbCrlEncoded: ?*const u8,
    cbCrlEncoded: u32,
) callconv(@import("std").os.windows.WINAPI) ?*CRL_CONTEXT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertFreeCRLContext(
    pCrlContext: ?*CRL_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertSetCRLContextProperty(
    pCrlContext: ?*CRL_CONTEXT,
    dwPropId: u32,
    dwFlags: u32,
    pvData: ?*const anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertGetCRLContextProperty(
    pCrlContext: ?*CRL_CONTEXT,
    dwPropId: u32,
    // TODO: what to do with BytesParamIndex 3?
    pvData: ?*anyopaque,
    pcbData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertEnumCRLContextProperties(
    pCrlContext: ?*CRL_CONTEXT,
    dwPropId: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertFindCertificateInCRL(
    pCert: ?*const CERT_CONTEXT,
    pCrlContext: ?*CRL_CONTEXT,
    dwFlags: u32,
    pvReserved: ?*anyopaque,
    ppCrlEntry: ?*?*CRL_ENTRY,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertIsValidCRLForCertificate(
    pCert: ?*const CERT_CONTEXT,
    pCrl: ?*CRL_CONTEXT,
    dwFlags: u32,
    pvReserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertAddEncodedCertificateToStore(
    hCertStore: ?HCERTSTORE,
    dwCertEncodingType: u32,
    // TODO: what to do with BytesParamIndex 3?
    pbCertEncoded: ?*const u8,
    cbCertEncoded: u32,
    dwAddDisposition: u32,
    ppCertContext: ?*?*CERT_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertAddCertificateContextToStore(
    hCertStore: ?HCERTSTORE,
    pCertContext: ?*const CERT_CONTEXT,
    dwAddDisposition: u32,
    ppStoreContext: ?*?*CERT_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertAddSerializedElementToStore(
    hCertStore: ?HCERTSTORE,
    // TODO: what to do with BytesParamIndex 2?
    pbElement: ?*const u8,
    cbElement: u32,
    dwAddDisposition: u32,
    dwFlags: u32,
    dwContextTypeFlags: u32,
    pdwContextType: ?*u32,
    ppvContext: ?*const ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertDeleteCertificateFromStore(
    pCertContext: ?*const CERT_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertAddEncodedCRLToStore(
    hCertStore: ?HCERTSTORE,
    dwCertEncodingType: u32,
    // TODO: what to do with BytesParamIndex 3?
    pbCrlEncoded: ?*const u8,
    cbCrlEncoded: u32,
    dwAddDisposition: u32,
    ppCrlContext: ?*?*CRL_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertAddCRLContextToStore(
    hCertStore: ?HCERTSTORE,
    pCrlContext: ?*CRL_CONTEXT,
    dwAddDisposition: u32,
    ppStoreContext: ?*?*CRL_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertDeleteCRLFromStore(
    pCrlContext: ?*CRL_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertSerializeCertificateStoreElement(
    pCertContext: ?*const CERT_CONTEXT,
    dwFlags: u32,
    // TODO: what to do with BytesParamIndex 3?
    pbElement: ?*u8,
    pcbElement: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertSerializeCRLStoreElement(
    pCrlContext: ?*CRL_CONTEXT,
    dwFlags: u32,
    // TODO: what to do with BytesParamIndex 3?
    pbElement: ?*u8,
    pcbElement: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertDuplicateCTLContext(
    pCtlContext: ?*CTL_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) ?*CTL_CONTEXT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertCreateCTLContext(
    dwMsgAndCertEncodingType: u32,
    // TODO: what to do with BytesParamIndex 2?
    pbCtlEncoded: ?*const u8,
    cbCtlEncoded: u32,
) callconv(@import("std").os.windows.WINAPI) ?*CTL_CONTEXT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertFreeCTLContext(
    pCtlContext: ?*CTL_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertSetCTLContextProperty(
    pCtlContext: ?*CTL_CONTEXT,
    dwPropId: u32,
    dwFlags: u32,
    pvData: ?*const anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertGetCTLContextProperty(
    pCtlContext: ?*CTL_CONTEXT,
    dwPropId: u32,
    // TODO: what to do with BytesParamIndex 3?
    pvData: ?*anyopaque,
    pcbData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertEnumCTLContextProperties(
    pCtlContext: ?*CTL_CONTEXT,
    dwPropId: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertEnumCTLsInStore(
    hCertStore: ?HCERTSTORE,
    pPrevCtlContext: ?*CTL_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) ?*CTL_CONTEXT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertFindSubjectInCTL(
    dwEncodingType: u32,
    dwSubjectType: u32,
    pvSubject: ?*anyopaque,
    pCtlContext: ?*CTL_CONTEXT,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) ?*CTL_ENTRY;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertFindCTLInStore(
    hCertStore: ?HCERTSTORE,
    dwMsgAndCertEncodingType: u32,
    dwFindFlags: u32,
    dwFindType: CERT_FIND_TYPE,
    pvFindPara: ?*const anyopaque,
    pPrevCtlContext: ?*CTL_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) ?*CTL_CONTEXT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertAddEncodedCTLToStore(
    hCertStore: ?HCERTSTORE,
    dwMsgAndCertEncodingType: u32,
    // TODO: what to do with BytesParamIndex 3?
    pbCtlEncoded: ?*const u8,
    cbCtlEncoded: u32,
    dwAddDisposition: u32,
    ppCtlContext: ?*?*CTL_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertAddCTLContextToStore(
    hCertStore: ?HCERTSTORE,
    pCtlContext: ?*CTL_CONTEXT,
    dwAddDisposition: u32,
    ppStoreContext: ?*?*CTL_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertSerializeCTLStoreElement(
    pCtlContext: ?*CTL_CONTEXT,
    dwFlags: u32,
    // TODO: what to do with BytesParamIndex 3?
    pbElement: ?*u8,
    pcbElement: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertDeleteCTLFromStore(
    pCtlContext: ?*CTL_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertAddCertificateLinkToStore(
    hCertStore: ?HCERTSTORE,
    pCertContext: ?*const CERT_CONTEXT,
    dwAddDisposition: u32,
    ppStoreContext: ?*?*CERT_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertAddCRLLinkToStore(
    hCertStore: ?HCERTSTORE,
    pCrlContext: ?*CRL_CONTEXT,
    dwAddDisposition: u32,
    ppStoreContext: ?*?*CRL_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertAddCTLLinkToStore(
    hCertStore: ?HCERTSTORE,
    pCtlContext: ?*CTL_CONTEXT,
    dwAddDisposition: u32,
    ppStoreContext: ?*?*CTL_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertAddStoreToCollection(
    hCollectionStore: ?HCERTSTORE,
    hSiblingStore: ?HCERTSTORE,
    dwUpdateFlags: u32,
    dwPriority: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertRemoveStoreFromCollection(
    hCollectionStore: ?HCERTSTORE,
    hSiblingStore: ?HCERTSTORE,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertControlStore(
    hCertStore: ?HCERTSTORE,
    dwFlags: CERT_CONTROL_STORE_FLAGS,
    dwCtrlType: u32,
    pvCtrlPara: ?*const anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertSetStoreProperty(
    hCertStore: ?HCERTSTORE,
    dwPropId: u32,
    dwFlags: u32,
    pvData: ?*const anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertGetStoreProperty(
    hCertStore: ?HCERTSTORE,
    dwPropId: u32,
    // TODO: what to do with BytesParamIndex 3?
    pvData: ?*anyopaque,
    pcbData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertCreateContext(
    dwContextType: u32,
    dwEncodingType: u32,
    // TODO: what to do with BytesParamIndex 3?
    pbEncoded: ?*const u8,
    cbEncoded: u32,
    dwFlags: u32,
    pCreatePara: ?*CERT_CREATE_CONTEXT_PARA,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertRegisterSystemStore(
    pvSystemStore: ?*const anyopaque,
    dwFlags: u32,
    pStoreInfo: ?*CERT_SYSTEM_STORE_INFO,
    pvReserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertRegisterPhysicalStore(
    pvSystemStore: ?*const anyopaque,
    dwFlags: u32,
    pwszStoreName: ?[*:0]const u16,
    pStoreInfo: ?*CERT_PHYSICAL_STORE_INFO,
    pvReserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertUnregisterSystemStore(
    pvSystemStore: ?*const anyopaque,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertUnregisterPhysicalStore(
    pvSystemStore: ?*const anyopaque,
    dwFlags: u32,
    pwszStoreName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertEnumSystemStoreLocation(
    dwFlags: u32,
    pvArg: ?*anyopaque,
    pfnEnum: ?PFN_CERT_ENUM_SYSTEM_STORE_LOCATION,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertEnumSystemStore(
    dwFlags: u32,
    pvSystemStoreLocationPara: ?*anyopaque,
    pvArg: ?*anyopaque,
    pfnEnum: ?PFN_CERT_ENUM_SYSTEM_STORE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertEnumPhysicalStore(
    pvSystemStore: ?*const anyopaque,
    dwFlags: u32,
    pvArg: ?*anyopaque,
    pfnEnum: ?PFN_CERT_ENUM_PHYSICAL_STORE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertGetEnhancedKeyUsage(
    pCertContext: ?*const CERT_CONTEXT,
    dwFlags: u32,
    // TODO: what to do with BytesParamIndex 3?
    pUsage: ?*CTL_USAGE,
    pcbUsage: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertSetEnhancedKeyUsage(
    pCertContext: ?*const CERT_CONTEXT,
    pUsage: ?*CTL_USAGE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertAddEnhancedKeyUsageIdentifier(
    pCertContext: ?*const CERT_CONTEXT,
    pszUsageIdentifier: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertRemoveEnhancedKeyUsageIdentifier(
    pCertContext: ?*const CERT_CONTEXT,
    pszUsageIdentifier: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertGetValidUsages(
    cCerts: u32,
    rghCerts: [*]?*CERT_CONTEXT,
    cNumOIDs: ?*i32,
    // TODO: what to do with BytesParamIndex 4?
    rghOIDs: ?*?PSTR,
    pcbOIDs: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptMsgGetAndVerifySigner(
    hCryptMsg: ?*anyopaque,
    cSignerStore: u32,
    rghSignerStore: ?[*]?HCERTSTORE,
    dwFlags: u32,
    ppSigner: ?*?*CERT_CONTEXT,
    pdwSignerIndex: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptMsgSignCTL(
    dwMsgEncodingType: u32,
    // TODO: what to do with BytesParamIndex 2?
    pbCtlContent: ?*u8,
    cbCtlContent: u32,
    pSignInfo: ?*CMSG_SIGNED_ENCODE_INFO,
    dwFlags: u32,
    // TODO: what to do with BytesParamIndex 6?
    pbEncoded: ?*u8,
    pcbEncoded: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptMsgEncodeAndSignCTL(
    dwMsgEncodingType: u32,
    pCtlInfo: ?*CTL_INFO,
    pSignInfo: ?*CMSG_SIGNED_ENCODE_INFO,
    dwFlags: u32,
    // TODO: what to do with BytesParamIndex 5?
    pbEncoded: ?*u8,
    pcbEncoded: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertFindSubjectInSortedCTL(
    pSubjectIdentifier: ?*CRYPTOAPI_BLOB,
    pCtlContext: ?*CTL_CONTEXT,
    dwFlags: u32,
    pvReserved: ?*anyopaque,
    pEncodedAttributes: ?*CRYPTOAPI_BLOB,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertEnumSubjectInSortedCTL(
    pCtlContext: ?*CTL_CONTEXT,
    ppvNextSubject: ?*?*anyopaque,
    pSubjectIdentifier: ?*CRYPTOAPI_BLOB,
    pEncodedAttributes: ?*CRYPTOAPI_BLOB,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertVerifyCTLUsage(
    dwEncodingType: u32,
    dwSubjectType: u32,
    pvSubject: ?*anyopaque,
    pSubjectUsage: ?*CTL_USAGE,
    dwFlags: u32,
    pVerifyUsagePara: ?*CTL_VERIFY_USAGE_PARA,
    pVerifyUsageStatus: ?*CTL_VERIFY_USAGE_STATUS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertVerifyRevocation(
    dwEncodingType: u32,
    dwRevType: u32,
    cContext: u32,
    rgpvContext: [*]?*anyopaque,
    dwFlags: u32,
    pRevPara: ?*CERT_REVOCATION_PARA,
    pRevStatus: ?*CERT_REVOCATION_STATUS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertCompareIntegerBlob(
    pInt1: ?*CRYPTOAPI_BLOB,
    pInt2: ?*CRYPTOAPI_BLOB,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertCompareCertificate(
    dwCertEncodingType: u32,
    pCertId1: ?*CERT_INFO,
    pCertId2: ?*CERT_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertCompareCertificateName(
    dwCertEncodingType: u32,
    pCertName1: ?*CRYPTOAPI_BLOB,
    pCertName2: ?*CRYPTOAPI_BLOB,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertIsRDNAttrsInCertificateName(
    dwCertEncodingType: u32,
    dwFlags: u32,
    pCertName: ?*CRYPTOAPI_BLOB,
    pRDN: ?*CERT_RDN,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertComparePublicKeyInfo(
    dwCertEncodingType: u32,
    pPublicKey1: ?*CERT_PUBLIC_KEY_INFO,
    pPublicKey2: ?*CERT_PUBLIC_KEY_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertGetPublicKeyLength(
    dwCertEncodingType: u32,
    pPublicKey: ?*CERT_PUBLIC_KEY_INFO,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptVerifyCertificateSignature(
    hCryptProv: HCRYPTPROV_LEGACY,
    dwCertEncodingType: u32,
    // TODO: what to do with BytesParamIndex 3?
    pbEncoded: ?*const u8,
    cbEncoded: u32,
    pPublicKey: ?*CERT_PUBLIC_KEY_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptVerifyCertificateSignatureEx(
    hCryptProv: HCRYPTPROV_LEGACY,
    dwCertEncodingType: u32,
    dwSubjectType: u32,
    pvSubject: ?*anyopaque,
    dwIssuerType: u32,
    pvIssuer: ?*anyopaque,
    dwFlags: CRYPT_VERIFY_CERT_FLAGS,
    pvExtra: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "crypt32" fn CertIsStrongHashToSign(
    pStrongSignPara: ?*CERT_STRONG_SIGN_PARA,
    pwszCNGHashAlgid: ?[*:0]const u16,
    pSigningCert: ?*const CERT_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptHashToBeSigned(
    hCryptProv: HCRYPTPROV_LEGACY,
    dwCertEncodingType: u32,
    // TODO: what to do with BytesParamIndex 3?
    pbEncoded: ?*const u8,
    cbEncoded: u32,
    // TODO: what to do with BytesParamIndex 5?
    pbComputedHash: ?*u8,
    pcbComputedHash: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptHashCertificate(
    hCryptProv: HCRYPTPROV_LEGACY,
    Algid: u32,
    dwFlags: u32,
    // TODO: what to do with BytesParamIndex 4?
    pbEncoded: ?*const u8,
    cbEncoded: u32,
    // TODO: what to do with BytesParamIndex 6?
    pbComputedHash: ?*u8,
    pcbComputedHash: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "crypt32" fn CryptHashCertificate2(
    pwszCNGHashAlgid: ?[*:0]const u16,
    dwFlags: u32,
    pvReserved: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 4?
    pbEncoded: ?*const u8,
    cbEncoded: u32,
    // TODO: what to do with BytesParamIndex 6?
    pbComputedHash: ?*u8,
    pcbComputedHash: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptSignCertificate(
    hCryptProvOrNCryptKey: HCRYPTPROV_OR_NCRYPT_KEY_HANDLE,
    dwKeySpec: u32,
    dwCertEncodingType: u32,
    // TODO: what to do with BytesParamIndex 4?
    pbEncodedToBeSigned: ?*const u8,
    cbEncodedToBeSigned: u32,
    pSignatureAlgorithm: ?*CRYPT_ALGORITHM_IDENTIFIER,
    pvHashAuxInfo: ?*const anyopaque,
    // TODO: what to do with BytesParamIndex 8?
    pbSignature: ?*u8,
    pcbSignature: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
// This function from dll 'CRYPT32' is being skipped because it has some sort of issue
pub fn CryptSignAndEncodeCertificate() void { @panic("this function is not working"); }

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertVerifyTimeValidity(
    pTimeToVerify: ?*FILETIME,
    pCertInfo: ?*CERT_INFO,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertVerifyCRLTimeValidity(
    pTimeToVerify: ?*FILETIME,
    pCrlInfo: ?*CRL_INFO,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertVerifyValidityNesting(
    pSubjectInfo: ?*CERT_INFO,
    pIssuerInfo: ?*CERT_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertVerifyCRLRevocation(
    dwCertEncodingType: u32,
    pCertId: ?*CERT_INFO,
    cCrlInfo: u32,
    rgpCrlInfo: [*]?*CRL_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertAlgIdToOID(
    dwAlgId: u32,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertOIDToAlgId(
    pszObjId: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertFindExtension(
    pszObjId: ?[*:0]const u8,
    cExtensions: u32,
    rgExtensions: [*]CERT_EXTENSION,
) callconv(@import("std").os.windows.WINAPI) ?*CERT_EXTENSION;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertFindAttribute(
    pszObjId: ?[*:0]const u8,
    cAttr: u32,
    rgAttr: [*]CRYPT_ATTRIBUTE,
) callconv(@import("std").os.windows.WINAPI) ?*CRYPT_ATTRIBUTE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertFindRDNAttr(
    pszObjId: ?[*:0]const u8,
    pName: ?*CERT_NAME_INFO,
) callconv(@import("std").os.windows.WINAPI) ?*CERT_RDN_ATTR;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertGetIntendedKeyUsage(
    dwCertEncodingType: u32,
    pCertInfo: ?*CERT_INFO,
    // TODO: what to do with BytesParamIndex 3?
    pbKeyUsage: ?*u8,
    cbKeyUsage: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptInstallDefaultContext(
    hCryptProv: usize,
    dwDefaultType: CRYPT_DEFAULT_CONTEXT_TYPE,
    pvDefaultPara: ?*const anyopaque,
    dwFlags: CRYPT_DEFAULT_CONTEXT_FLAGS,
    pvReserved: ?*anyopaque,
    phDefaultContext: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptUninstallDefaultContext(
    hDefaultContext: ?*anyopaque,
    dwFlags: u32,
    pvReserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptExportPublicKeyInfo(
    hCryptProvOrNCryptKey: HCRYPTPROV_OR_NCRYPT_KEY_HANDLE,
    dwKeySpec: u32,
    dwCertEncodingType: u32,
    // TODO: what to do with BytesParamIndex 4?
    pInfo: ?*CERT_PUBLIC_KEY_INFO,
    pcbInfo: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptExportPublicKeyInfoEx(
    hCryptProvOrNCryptKey: HCRYPTPROV_OR_NCRYPT_KEY_HANDLE,
    dwKeySpec: u32,
    dwCertEncodingType: u32,
    pszPublicKeyObjId: ?PSTR,
    dwFlags: u32,
    pvAuxInfo: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 7?
    pInfo: ?*CERT_PUBLIC_KEY_INFO,
    pcbInfo: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "crypt32" fn CryptExportPublicKeyInfoFromBCryptKeyHandle(
    hBCryptKey: BCRYPT_KEY_HANDLE,
    dwCertEncodingType: u32,
    pszPublicKeyObjId: ?PSTR,
    dwFlags: u32,
    pvAuxInfo: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 6?
    pInfo: ?*CERT_PUBLIC_KEY_INFO,
    pcbInfo: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptImportPublicKeyInfo(
    hCryptProv: usize,
    dwCertEncodingType: u32,
    pInfo: ?*CERT_PUBLIC_KEY_INFO,
    phKey: ?*usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptImportPublicKeyInfoEx(
    hCryptProv: usize,
    dwCertEncodingType: u32,
    pInfo: ?*CERT_PUBLIC_KEY_INFO,
    aiKeyAlg: u32,
    dwFlags: u32,
    pvAuxInfo: ?*anyopaque,
    phKey: ?*usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "crypt32" fn CryptImportPublicKeyInfoEx2(
    dwCertEncodingType: u32,
    pInfo: ?*CERT_PUBLIC_KEY_INFO,
    dwFlags: CRYPT_IMPORT_PUBLIC_KEY_FLAGS,
    pvAuxInfo: ?*anyopaque,
    phKey: ?*BCRYPT_KEY_HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptAcquireCertificatePrivateKey(
    pCert: ?*const CERT_CONTEXT,
    dwFlags: CRYPT_ACQUIRE_FLAGS,
    pvParameters: ?*anyopaque,
    phCryptProvOrNCryptKey: ?*HCRYPTPROV_OR_NCRYPT_KEY_HANDLE,
    pdwKeySpec: ?*CERT_KEY_SPEC,
    pfCallerFreeProvOrNCryptKey: ?*BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptFindCertificateKeyProvInfo(
    pCert: ?*const CERT_CONTEXT,
    dwFlags: CRYPT_FIND_FLAGS,
    pvReserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptImportPKCS8(
    sPrivateKeyAndParams: CRYPT_PKCS8_IMPORT_PARAMS,
    dwFlags: CRYPT_KEY_FLAGS,
    phCryptProv: ?*usize,
    pvAuxInfo: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptExportPKCS8(
    hCryptProv: usize,
    dwKeySpec: u32,
    pszPrivateKeyObjId: ?PSTR,
    dwFlags: u32,
    pvAuxInfo: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 6?
    pbPrivateKeyBlob: ?*u8,
    pcbPrivateKeyBlob: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptHashPublicKeyInfo(
    hCryptProv: HCRYPTPROV_LEGACY,
    Algid: u32,
    dwFlags: u32,
    dwCertEncodingType: u32,
    pInfo: ?*CERT_PUBLIC_KEY_INFO,
    // TODO: what to do with BytesParamIndex 6?
    pbComputedHash: ?*u8,
    pcbComputedHash: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertRDNValueToStrA(
    dwValueType: u32,
    pValue: ?*CRYPTOAPI_BLOB,
    psz: ?[*:0]u8,
    csz: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertRDNValueToStrW(
    dwValueType: u32,
    pValue: ?*CRYPTOAPI_BLOB,
    psz: ?[*:0]u16,
    csz: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertNameToStrA(
    dwCertEncodingType: u32,
    pName: ?*CRYPTOAPI_BLOB,
    dwStrType: CERT_STRING_TYPE,
    psz: ?[*:0]u8,
    csz: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertNameToStrW(
    dwCertEncodingType: u32,
    pName: ?*CRYPTOAPI_BLOB,
    dwStrType: CERT_STRING_TYPE,
    psz: ?[*:0]u16,
    csz: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertStrToNameA(
    dwCertEncodingType: u32,
    pszX500: ?[*:0]const u8,
    dwStrType: CERT_STRING_TYPE,
    pvReserved: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 5?
    pbEncoded: ?*u8,
    pcbEncoded: ?*u32,
    ppszError: ?*?PSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertStrToNameW(
    dwCertEncodingType: u32,
    pszX500: ?[*:0]const u16,
    dwStrType: CERT_STRING_TYPE,
    pvReserved: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 5?
    pbEncoded: ?*u8,
    pcbEncoded: ?*u32,
    ppszError: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertGetNameStringA(
    pCertContext: ?*const CERT_CONTEXT,
    dwType: u32,
    dwFlags: u32,
    pvTypePara: ?*anyopaque,
    pszNameString: ?[*:0]u8,
    cchNameString: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertGetNameStringW(
    pCertContext: ?*const CERT_CONTEXT,
    dwType: u32,
    dwFlags: u32,
    pvTypePara: ?*anyopaque,
    pszNameString: ?[*:0]u16,
    cchNameString: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptSignMessage(
    pSignPara: ?*CRYPT_SIGN_MESSAGE_PARA,
    fDetachedSignature: BOOL,
    cToBeSigned: u32,
    rgpbToBeSigned: ?[*]const ?*const u8,
    rgcbToBeSigned: [*]u32,
    // TODO: what to do with BytesParamIndex 6?
    pbSignedBlob: ?*u8,
    pcbSignedBlob: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptVerifyMessageSignature(
    pVerifyPara: ?*CRYPT_VERIFY_MESSAGE_PARA,
    dwSignerIndex: u32,
    // TODO: what to do with BytesParamIndex 3?
    pbSignedBlob: ?*const u8,
    cbSignedBlob: u32,
    // TODO: what to do with BytesParamIndex 5?
    pbDecoded: ?*u8,
    pcbDecoded: ?*u32,
    ppSignerCert: ?*?*CERT_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptGetMessageSignerCount(
    dwMsgEncodingType: u32,
    // TODO: what to do with BytesParamIndex 2?
    pbSignedBlob: ?*const u8,
    cbSignedBlob: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptGetMessageCertificates(
    dwMsgAndCertEncodingType: u32,
    hCryptProv: HCRYPTPROV_LEGACY,
    dwFlags: u32,
    // TODO: what to do with BytesParamIndex 4?
    pbSignedBlob: ?*const u8,
    cbSignedBlob: u32,
) callconv(@import("std").os.windows.WINAPI) ?HCERTSTORE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptVerifyDetachedMessageSignature(
    pVerifyPara: ?*CRYPT_VERIFY_MESSAGE_PARA,
    dwSignerIndex: u32,
    // TODO: what to do with BytesParamIndex 3?
    pbDetachedSignBlob: ?*const u8,
    cbDetachedSignBlob: u32,
    cToBeSigned: u32,
    rgpbToBeSigned: [*]const ?*const u8,
    rgcbToBeSigned: [*]u32,
    ppSignerCert: ?*?*CERT_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptEncryptMessage(
    pEncryptPara: ?*CRYPT_ENCRYPT_MESSAGE_PARA,
    cRecipientCert: u32,
    rgpRecipientCert: [*]?*CERT_CONTEXT,
    // TODO: what to do with BytesParamIndex 4?
    pbToBeEncrypted: ?*const u8,
    cbToBeEncrypted: u32,
    // TODO: what to do with BytesParamIndex 6?
    pbEncryptedBlob: ?*u8,
    pcbEncryptedBlob: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptDecryptMessage(
    pDecryptPara: ?*CRYPT_DECRYPT_MESSAGE_PARA,
    // TODO: what to do with BytesParamIndex 2?
    pbEncryptedBlob: ?*const u8,
    cbEncryptedBlob: u32,
    // TODO: what to do with BytesParamIndex 4?
    pbDecrypted: ?*u8,
    pcbDecrypted: ?*u32,
    ppXchgCert: ?*?*CERT_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptSignAndEncryptMessage(
    pSignPara: ?*CRYPT_SIGN_MESSAGE_PARA,
    pEncryptPara: ?*CRYPT_ENCRYPT_MESSAGE_PARA,
    cRecipientCert: u32,
    rgpRecipientCert: [*]?*CERT_CONTEXT,
    // TODO: what to do with BytesParamIndex 5?
    pbToBeSignedAndEncrypted: ?*const u8,
    cbToBeSignedAndEncrypted: u32,
    // TODO: what to do with BytesParamIndex 7?
    pbSignedAndEncryptedBlob: ?*u8,
    pcbSignedAndEncryptedBlob: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptDecryptAndVerifyMessageSignature(
    pDecryptPara: ?*CRYPT_DECRYPT_MESSAGE_PARA,
    pVerifyPara: ?*CRYPT_VERIFY_MESSAGE_PARA,
    dwSignerIndex: u32,
    // TODO: what to do with BytesParamIndex 4?
    pbEncryptedBlob: ?*const u8,
    cbEncryptedBlob: u32,
    // TODO: what to do with BytesParamIndex 6?
    pbDecrypted: ?*u8,
    pcbDecrypted: ?*u32,
    ppXchgCert: ?*?*CERT_CONTEXT,
    ppSignerCert: ?*?*CERT_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptDecodeMessage(
    dwMsgTypeFlags: u32,
    pDecryptPara: ?*CRYPT_DECRYPT_MESSAGE_PARA,
    pVerifyPara: ?*CRYPT_VERIFY_MESSAGE_PARA,
    dwSignerIndex: u32,
    // TODO: what to do with BytesParamIndex 5?
    pbEncodedBlob: ?*const u8,
    cbEncodedBlob: u32,
    dwPrevInnerContentType: u32,
    pdwMsgType: ?*u32,
    pdwInnerContentType: ?*u32,
    // TODO: what to do with BytesParamIndex 10?
    pbDecoded: ?*u8,
    pcbDecoded: ?*u32,
    ppXchgCert: ?*?*CERT_CONTEXT,
    ppSignerCert: ?*?*CERT_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptHashMessage(
    pHashPara: ?*CRYPT_HASH_MESSAGE_PARA,
    fDetachedHash: BOOL,
    cToBeHashed: u32,
    rgpbToBeHashed: [*]const ?*const u8,
    rgcbToBeHashed: [*]u32,
    // TODO: what to do with BytesParamIndex 6?
    pbHashedBlob: ?*u8,
    pcbHashedBlob: ?*u32,
    // TODO: what to do with BytesParamIndex 8?
    pbComputedHash: ?*u8,
    pcbComputedHash: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptVerifyMessageHash(
    pHashPara: ?*CRYPT_HASH_MESSAGE_PARA,
    // TODO: what to do with BytesParamIndex 2?
    pbHashedBlob: ?*u8,
    cbHashedBlob: u32,
    // TODO: what to do with BytesParamIndex 4?
    pbToBeHashed: ?*u8,
    pcbToBeHashed: ?*u32,
    // TODO: what to do with BytesParamIndex 6?
    pbComputedHash: ?*u8,
    pcbComputedHash: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptVerifyDetachedMessageHash(
    pHashPara: ?*CRYPT_HASH_MESSAGE_PARA,
    // TODO: what to do with BytesParamIndex 2?
    pbDetachedHashBlob: ?*u8,
    cbDetachedHashBlob: u32,
    cToBeHashed: u32,
    rgpbToBeHashed: [*]const ?*const u8,
    rgcbToBeHashed: [*]u32,
    // TODO: what to do with BytesParamIndex 7?
    pbComputedHash: ?*u8,
    pcbComputedHash: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptSignMessageWithKey(
    pSignPara: ?*CRYPT_KEY_SIGN_MESSAGE_PARA,
    // TODO: what to do with BytesParamIndex 2?
    pbToBeSigned: ?*const u8,
    cbToBeSigned: u32,
    // TODO: what to do with BytesParamIndex 4?
    pbSignedBlob: ?*u8,
    pcbSignedBlob: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptVerifyMessageSignatureWithKey(
    pVerifyPara: ?*CRYPT_KEY_VERIFY_MESSAGE_PARA,
    pPublicKeyInfo: ?*CERT_PUBLIC_KEY_INFO,
    // TODO: what to do with BytesParamIndex 3?
    pbSignedBlob: ?*const u8,
    cbSignedBlob: u32,
    // TODO: what to do with BytesParamIndex 5?
    pbDecoded: ?*u8,
    pcbDecoded: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertOpenSystemStoreA(
    hProv: HCRYPTPROV_LEGACY,
    szSubsystemProtocol: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) ?HCERTSTORE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertOpenSystemStoreW(
    hProv: HCRYPTPROV_LEGACY,
    szSubsystemProtocol: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) ?HCERTSTORE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertAddEncodedCertificateToSystemStoreA(
    szCertStoreName: ?[*:0]const u8,
    // TODO: what to do with BytesParamIndex 2?
    pbCertEncoded: ?*const u8,
    cbCertEncoded: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertAddEncodedCertificateToSystemStoreW(
    szCertStoreName: ?[*:0]const u16,
    // TODO: what to do with BytesParamIndex 2?
    pbCertEncoded: ?*const u8,
    cbCertEncoded: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "wintrust" fn FindCertsByIssuer(
    // TODO: what to do with BytesParamIndex 1?
    pCertChains: ?*CERT_CHAIN,
    pcbCertChains: ?*u32,
    pcCertChains: ?*u32,
    // TODO: what to do with BytesParamIndex 4?
    pbEncodedIssuerName: ?*u8,
    cbEncodedIssuerName: u32,
    pwszPurpose: ?[*:0]const u16,
    dwKeySpec: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptQueryObject(
    dwObjectType: CERT_QUERY_OBJECT_TYPE,
    pvObject: ?*const anyopaque,
    dwExpectedContentTypeFlags: CERT_QUERY_CONTENT_TYPE_FLAGS,
    dwExpectedFormatTypeFlags: CERT_QUERY_FORMAT_TYPE_FLAGS,
    dwFlags: u32,
    pdwMsgAndCertEncodingType: ?*CERT_QUERY_ENCODING_TYPE,
    pdwContentType: ?*CERT_QUERY_CONTENT_TYPE,
    pdwFormatType: ?*CERT_QUERY_FORMAT_TYPE,
    phCertStore: ?*?HCERTSTORE,
    phMsg: ?*?*anyopaque,
    ppvContext: ?*const ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptMemAlloc(
    cbSize: u32,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptMemRealloc(
    pv: ?*anyopaque,
    cbSize: u32,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptMemFree(
    pv: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "crypt32" fn CryptCreateAsyncHandle(
    dwFlags: u32,
    phAsync: ?*?HCRYPTASYNC,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "crypt32" fn CryptSetAsyncParam(
    hAsync: ?HCRYPTASYNC,
    pszParamOid: ?PSTR,
    pvParam: ?*anyopaque,
    pfnFree: ?PFN_CRYPT_ASYNC_PARAM_FREE_FUNC,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "crypt32" fn CryptGetAsyncParam(
    hAsync: ?HCRYPTASYNC,
    pszParamOid: ?PSTR,
    ppvParam: ?*?*anyopaque,
    ppfnFree: ?*?PFN_CRYPT_ASYNC_PARAM_FREE_FUNC,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "crypt32" fn CryptCloseAsyncHandle(
    hAsync: ?HCRYPTASYNC,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "cryptnet" fn CryptRetrieveObjectByUrlA(
    pszUrl: ?[*:0]const u8,
    pszObjectOid: ?[*:0]const u8,
    dwRetrievalFlags: u32,
    dwTimeout: u32,
    ppvObject: ?*?*anyopaque,
    hAsyncRetrieve: ?HCRYPTASYNC,
    pCredentials: ?*CRYPT_CREDENTIALS,
    pvVerify: ?*anyopaque,
    pAuxInfo: ?*CRYPT_RETRIEVE_AUX_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "cryptnet" fn CryptRetrieveObjectByUrlW(
    pszUrl: ?[*:0]const u16,
    pszObjectOid: ?[*:0]const u8,
    dwRetrievalFlags: u32,
    dwTimeout: u32,
    ppvObject: ?*?*anyopaque,
    hAsyncRetrieve: ?HCRYPTASYNC,
    pCredentials: ?*CRYPT_CREDENTIALS,
    pvVerify: ?*anyopaque,
    pAuxInfo: ?*CRYPT_RETRIEVE_AUX_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "cryptnet" fn CryptInstallCancelRetrieval(
    pfnCancel: ?PFN_CRYPT_CANCEL_RETRIEVAL,
    pvArg: ?*const anyopaque,
    dwFlags: u32,
    pvReserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "cryptnet" fn CryptUninstallCancelRetrieval(
    dwFlags: u32,
    pvReserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "cryptnet" fn CryptGetObjectUrl(
    pszUrlOid: ?[*:0]const u8,
    pvPara: ?*anyopaque,
    dwFlags: CRYPT_GET_URL_FLAGS,
    // TODO: what to do with BytesParamIndex 4?
    pUrlArray: ?*CRYPT_URL_ARRAY,
    pcbUrlArray: ?*u32,
    // TODO: what to do with BytesParamIndex 6?
    pUrlInfo: ?*CRYPT_URL_INFO,
    pcbUrlInfo: ?*u32,
    pvReserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertCreateSelfSignCertificate(
    hCryptProvOrNCryptKey: HCRYPTPROV_OR_NCRYPT_KEY_HANDLE,
    pSubjectIssuerBlob: ?*CRYPTOAPI_BLOB,
    dwFlags: CERT_CREATE_SELFSIGN_FLAGS,
    pKeyProvInfo: ?*CRYPT_KEY_PROV_INFO,
    pSignatureAlgorithm: ?*CRYPT_ALGORITHM_IDENTIFIER,
    pStartTime: ?*SYSTEMTIME,
    pEndTime: ?*SYSTEMTIME,
    pExtensions: ?*CERT_EXTENSIONS,
) callconv(@import("std").os.windows.WINAPI) ?*CERT_CONTEXT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptGetKeyIdentifierProperty(
    pKeyIdentifier: ?*const CRYPTOAPI_BLOB,
    dwPropId: u32,
    dwFlags: u32,
    pwszComputerName: ?[*:0]const u16,
    pvReserved: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 6?
    pvData: ?*anyopaque,
    pcbData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptSetKeyIdentifierProperty(
    pKeyIdentifier: ?*const CRYPTOAPI_BLOB,
    dwPropId: u32,
    dwFlags: u32,
    pwszComputerName: ?[*:0]const u16,
    pvReserved: ?*anyopaque,
    pvData: ?*const anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptEnumKeyIdentifierProperties(
    pKeyIdentifier: ?*const CRYPTOAPI_BLOB,
    dwPropId: u32,
    dwFlags: u32,
    pwszComputerName: ?[*:0]const u16,
    pvReserved: ?*anyopaque,
    pvArg: ?*anyopaque,
    pfnEnum: ?PFN_CRYPT_ENUM_KEYID_PROP,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptCreateKeyIdentifierFromCSP(
    dwCertEncodingType: u32,
    pszPubKeyOID: ?[*:0]const u8,
    // TODO: what to do with BytesParamIndex 3?
    pPubKeyStruc: ?*const PUBLICKEYSTRUC,
    cbPubKeyStruc: u32,
    dwFlags: u32,
    pvReserved: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 7?
    pbHash: ?*u8,
    pcbHash: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertCreateCertificateChainEngine(
    pConfig: ?*CERT_CHAIN_ENGINE_CONFIG,
    phChainEngine: ?*?HCERTCHAINENGINE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertFreeCertificateChainEngine(
    hChainEngine: ?HCERTCHAINENGINE,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "crypt32" fn CertResyncCertificateChainEngine(
    hChainEngine: ?HCERTCHAINENGINE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertGetCertificateChain(
    hChainEngine: ?HCERTCHAINENGINE,
    pCertContext: ?*const CERT_CONTEXT,
    pTime: ?*FILETIME,
    hAdditionalStore: ?HCERTSTORE,
    pChainPara: ?*CERT_CHAIN_PARA,
    dwFlags: u32,
    pvReserved: ?*anyopaque,
    ppChainContext: ?*?*CERT_CHAIN_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertFreeCertificateChain(
    pChainContext: ?*CERT_CHAIN_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertDuplicateCertificateChain(
    pChainContext: ?*CERT_CHAIN_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) ?*CERT_CHAIN_CONTEXT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertFindChainInStore(
    hCertStore: ?HCERTSTORE,
    dwCertEncodingType: u32,
    dwFindFlags: CERT_FIND_CHAIN_IN_STORE_FLAGS,
    dwFindType: u32,
    pvFindPara: ?*const anyopaque,
    pPrevChainContext: ?*CERT_CHAIN_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) ?*CERT_CHAIN_CONTEXT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CertVerifyCertificateChainPolicy(
    pszPolicyOID: ?[*:0]const u8,
    pChainContext: ?*CERT_CHAIN_CONTEXT,
    pPolicyPara: ?*CERT_CHAIN_POLICY_PARA,
    pPolicyStatus: ?*CERT_CHAIN_POLICY_STATUS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptStringToBinaryA(
    pszString: [*:0]const u8,
    cchString: u32,
    dwFlags: CRYPT_STRING,
    // TODO: what to do with BytesParamIndex 4?
    pbBinary: ?*u8,
    pcbBinary: ?*u32,
    pdwSkip: ?*u32,
    pdwFlags: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptStringToBinaryW(
    pszString: [*:0]const u16,
    cchString: u32,
    dwFlags: CRYPT_STRING,
    // TODO: what to do with BytesParamIndex 4?
    pbBinary: ?*u8,
    pcbBinary: ?*u32,
    pdwSkip: ?*u32,
    pdwFlags: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptBinaryToStringA(
    // TODO: what to do with BytesParamIndex 1?
    pbBinary: ?*const u8,
    cbBinary: u32,
    dwFlags: CRYPT_STRING,
    pszString: ?[*:0]u8,
    pcchString: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptBinaryToStringW(
    // TODO: what to do with BytesParamIndex 1?
    pbBinary: ?*const u8,
    cbBinary: u32,
    dwFlags: CRYPT_STRING,
    pszString: ?[*:0]u16,
    pcchString: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn PFXImportCertStore(
    pPFX: ?*CRYPTOAPI_BLOB,
    szPassword: ?[*:0]const u16,
    dwFlags: CRYPT_KEY_FLAGS,
) callconv(@import("std").os.windows.WINAPI) ?HCERTSTORE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn PFXIsPFXBlob(
    pPFX: ?*CRYPTOAPI_BLOB,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn PFXVerifyPassword(
    pPFX: ?*CRYPTOAPI_BLOB,
    szPassword: ?[*:0]const u16,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn PFXExportCertStoreEx(
    hStore: ?HCERTSTORE,
    pPFX: ?*CRYPTOAPI_BLOB,
    szPassword: ?[*:0]const u16,
    pvPara: ?*anyopaque,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn PFXExportCertStore(
    hStore: ?HCERTSTORE,
    pPFX: ?*CRYPTOAPI_BLOB,
    szPassword: ?[*:0]const u16,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "crypt32" fn CertOpenServerOcspResponse(
    pChainContext: ?*CERT_CHAIN_CONTEXT,
    dwFlags: u32,
    pOpenPara: ?*CERT_SERVER_OCSP_RESPONSE_OPEN_PARA,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "crypt32" fn CertAddRefServerOcspResponse(
    hServerOcspResponse: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "crypt32" fn CertCloseServerOcspResponse(
    hServerOcspResponse: ?*anyopaque,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "crypt32" fn CertGetServerOcspResponseContext(
    hServerOcspResponse: ?*anyopaque,
    dwFlags: u32,
    pvReserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) ?*CERT_SERVER_OCSP_RESPONSE_CONTEXT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "crypt32" fn CertAddRefServerOcspResponseContext(
    pServerOcspResponseContext: ?*CERT_SERVER_OCSP_RESPONSE_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "crypt32" fn CertFreeServerOcspResponseContext(
    pServerOcspResponseContext: ?*CERT_SERVER_OCSP_RESPONSE_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "crypt32" fn CertRetrieveLogoOrBiometricInfo(
    pCertContext: ?*const CERT_CONTEXT,
    lpszLogoOrBiometricType: ?[*:0]const u8,
    dwRetrievalFlags: u32,
    dwTimeout: u32,
    dwFlags: u32,
    pvReserved: ?*anyopaque,
    ppbData: ?*?*u8,
    pcbData: ?*u32,
    ppwszMimeType: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "crypt32" fn CertSelectCertificateChains(
    pSelectionContext: ?*const Guid,
    dwFlags: u32,
    pChainParameters: ?*CERT_SELECT_CHAIN_PARA,
    cCriteria: u32,
    rgpCriteria: ?[*]CERT_SELECT_CRITERIA,
    hStore: ?HCERTSTORE,
    pcSelection: ?*u32,
    pprgpSelection: ?*?*?*CERT_CHAIN_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "crypt32" fn CertFreeCertificateChainList(
    prgpSelection: ?*?*CERT_CHAIN_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.1'
pub extern "crypt32" fn CryptRetrieveTimeStamp(
    wszUrl: ?[*:0]const u16,
    dwRetrievalFlags: u32,
    dwTimeout: u32,
    pszHashId: ?[*:0]const u8,
    pPara: ?*const CRYPT_TIMESTAMP_PARA,
    // TODO: what to do with BytesParamIndex 6?
    pbData: ?*const u8,
    cbData: u32,
    ppTsContext: ?*?*CRYPT_TIMESTAMP_CONTEXT,
    ppTsSigner: ?*?*CERT_CONTEXT,
    phStore: ?*?HCERTSTORE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "crypt32" fn CryptVerifyTimeStampSignature(
    // TODO: what to do with BytesParamIndex 1?
    pbTSContentInfo: ?*const u8,
    cbTSContentInfo: u32,
    // TODO: what to do with BytesParamIndex 3?
    pbData: ?*const u8,
    cbData: u32,
    hAdditionalStore: ?HCERTSTORE,
    ppTsContext: ?*?*CRYPT_TIMESTAMP_CONTEXT,
    ppTsSigner: ?*?*CERT_CONTEXT,
    phStore: ?*?HCERTSTORE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "crypt32" fn CertIsWeakHash(
    dwHashUseType: u32,
    pwszCNGHashAlgid: ?[*:0]const u16,
    dwChainFlags: u32,
    pSignerChainContext: ?*CERT_CHAIN_CONTEXT,
    pTimeStamp: ?*FILETIME,
    pwszFileName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptProtectData(
    pDataIn: ?*CRYPTOAPI_BLOB,
    szDataDescr: ?[*:0]const u16,
    pOptionalEntropy: ?*CRYPTOAPI_BLOB,
    pvReserved: ?*anyopaque,
    pPromptStruct: ?*CRYPTPROTECT_PROMPTSTRUCT,
    dwFlags: u32,
    pDataOut: ?*CRYPTOAPI_BLOB,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "crypt32" fn CryptUnprotectData(
    pDataIn: ?*CRYPTOAPI_BLOB,
    ppszDataDescr: ?*?PWSTR,
    pOptionalEntropy: ?*CRYPTOAPI_BLOB,
    pvReserved: ?*anyopaque,
    pPromptStruct: ?*CRYPTPROTECT_PROMPTSTRUCT,
    dwFlags: u32,
    pDataOut: ?*CRYPTOAPI_BLOB,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "crypt32" fn CryptUpdateProtectedState(
    pOldSid: ?PSID,
    pwszOldPassword: ?[*:0]const u16,
    dwFlags: u32,
    pdwSuccessCount: ?*u32,
    pdwFailureCount: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "crypt32" fn CryptProtectMemory(
    pDataIn: ?*anyopaque,
    cbDataIn: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "crypt32" fn CryptUnprotectMemory(
    pDataIn: ?*anyopaque,
    cbDataIn: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "ncrypt" fn NCryptRegisterProtectionDescriptorName(
    pwszName: ?[*:0]const u16,
    pwszDescriptorString: ?[*:0]const u16,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "ncrypt" fn NCryptQueryProtectionDescriptorName(
    pwszName: ?[*:0]const u16,
    pwszDescriptorString: ?[*:0]u16,
    pcDescriptorString: ?*usize,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "ncrypt" fn NCryptCreateProtectionDescriptor(
    pwszDescriptorString: ?[*:0]const u16,
    dwFlags: u32,
    phDescriptor: ?*NCRYPT_DESCRIPTOR_HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "ncrypt" fn NCryptCloseProtectionDescriptor(
    hDescriptor: NCRYPT_DESCRIPTOR_HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "ncrypt" fn NCryptGetProtectionDescriptorInfo(
    hDescriptor: NCRYPT_DESCRIPTOR_HANDLE,
    pMemPara: ?*const NCRYPT_ALLOC_PARA,
    dwInfoType: u32,
    ppvInfo: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "ncrypt" fn NCryptProtectSecret(
    hDescriptor: NCRYPT_DESCRIPTOR_HANDLE,
    dwFlags: u32,
    // TODO: what to do with BytesParamIndex 3?
    pbData: ?*const u8,
    cbData: u32,
    pMemPara: ?*const NCRYPT_ALLOC_PARA,
    hWnd: ?HWND,
    ppbProtectedBlob: ?*?*u8,
    pcbProtectedBlob: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "ncrypt" fn NCryptUnprotectSecret(
    phDescriptor: ?*NCRYPT_DESCRIPTOR_HANDLE,
    dwFlags: NCRYPT_FLAGS,
    // TODO: what to do with BytesParamIndex 3?
    pbProtectedBlob: ?*const u8,
    cbProtectedBlob: u32,
    pMemPara: ?*const NCRYPT_ALLOC_PARA,
    hWnd: ?HWND,
    ppbData: ?*?*u8,
    pcbData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "ncrypt" fn NCryptStreamOpenToProtect(
    hDescriptor: NCRYPT_DESCRIPTOR_HANDLE,
    dwFlags: u32,
    hWnd: ?HWND,
    pStreamInfo: ?*NCRYPT_PROTECT_STREAM_INFO,
    phStream: ?*NCRYPT_STREAM_HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "ncrypt" fn NCryptStreamOpenToUnprotect(
    pStreamInfo: ?*NCRYPT_PROTECT_STREAM_INFO,
    dwFlags: u32,
    hWnd: ?HWND,
    phStream: ?*NCRYPT_STREAM_HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ncrypt" fn NCryptStreamOpenToUnprotectEx(
    pStreamInfo: ?*NCRYPT_PROTECT_STREAM_INFO_EX,
    dwFlags: u32,
    hWnd: ?HWND,
    phStream: ?*NCRYPT_STREAM_HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "ncrypt" fn NCryptStreamUpdate(
    hStream: NCRYPT_STREAM_HANDLE,
    // TODO: what to do with BytesParamIndex 2?
    pbData: ?*const u8,
    cbData: usize,
    fFinal: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "ncrypt" fn NCryptStreamClose(
    hStream: NCRYPT_STREAM_HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "cryptxml" fn CryptXmlClose(
    hCryptXml: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "cryptxml" fn CryptXmlGetTransforms(
    ppConfig: ?*const ?*CRYPT_XML_TRANSFORM_CHAIN_CONFIG,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "cryptxml" fn CryptXmlOpenToEncode(
    pConfig: ?*const CRYPT_XML_TRANSFORM_CHAIN_CONFIG,
    dwFlags: CRYPT_XML_FLAGS,
    wszId: ?[*:0]const u16,
    rgProperty: ?[*]const CRYPT_XML_PROPERTY,
    cProperty: u32,
    pEncoded: ?*const CRYPT_XML_BLOB,
    phSignature: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "cryptxml" fn CryptXmlOpenToDecode(
    pConfig: ?*const CRYPT_XML_TRANSFORM_CHAIN_CONFIG,
    dwFlags: CRYPT_XML_FLAGS,
    rgProperty: ?[*]const CRYPT_XML_PROPERTY,
    cProperty: u32,
    pEncoded: ?*const CRYPT_XML_BLOB,
    phCryptXml: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "cryptxml" fn CryptXmlAddObject(
    hSignatureOrObject: ?*anyopaque,
    dwFlags: u32,
    rgProperty: ?[*]const CRYPT_XML_PROPERTY,
    cProperty: u32,
    pEncoded: ?*const CRYPT_XML_BLOB,
    ppObject: ?*const ?*CRYPT_XML_OBJECT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "cryptxml" fn CryptXmlCreateReference(
    hCryptXml: ?*anyopaque,
    dwFlags: u32,
    wszId: ?[*:0]const u16,
    wszURI: ?[*:0]const u16,
    wszType: ?[*:0]const u16,
    pDigestMethod: ?*const CRYPT_XML_ALGORITHM,
    cTransform: u32,
    rgTransform: ?[*]const CRYPT_XML_ALGORITHM,
    phReference: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "cryptxml" fn CryptXmlDigestReference(
    hReference: ?*anyopaque,
    dwFlags: u32,
    pDataProviderIn: ?*CRYPT_XML_DATA_PROVIDER,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "cryptxml" fn CryptXmlSetHMACSecret(
    hSignature: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 2?
    pbSecret: ?*const u8,
    cbSecret: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "cryptxml" fn CryptXmlSign(
    hSignature: ?*anyopaque,
    hKey: HCRYPTPROV_OR_NCRYPT_KEY_HANDLE,
    dwKeySpec: CERT_KEY_SPEC,
    dwFlags: CRYPT_XML_FLAGS,
    dwKeyInfoSpec: CRYPT_XML_KEYINFO_SPEC,
    pvKeyInfoSpec: ?*const anyopaque,
    pSignatureMethod: ?*const CRYPT_XML_ALGORITHM,
    pCanonicalization: ?*const CRYPT_XML_ALGORITHM,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "cryptxml" fn CryptXmlImportPublicKey(
    dwFlags: CRYPT_XML_FLAGS,
    pKeyValue: ?*const CRYPT_XML_KEY_VALUE,
    phKey: ?*BCRYPT_KEY_HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "cryptxml" fn CryptXmlVerifySignature(
    hSignature: ?*anyopaque,
    hKey: BCRYPT_KEY_HANDLE,
    dwFlags: CRYPT_XML_FLAGS,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "cryptxml" fn CryptXmlGetDocContext(
    hCryptXml: ?*anyopaque,
    ppStruct: ?*const ?*CRYPT_XML_DOC_CTXT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "cryptxml" fn CryptXmlGetSignature(
    hCryptXml: ?*anyopaque,
    ppStruct: ?*const ?*CRYPT_XML_SIGNATURE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "cryptxml" fn CryptXmlGetReference(
    hCryptXml: ?*anyopaque,
    ppStruct: ?*const ?*CRYPT_XML_REFERENCE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "cryptxml" fn CryptXmlGetStatus(
    hCryptXml: ?*anyopaque,
    pStatus: ?*CRYPT_XML_STATUS,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "cryptxml" fn CryptXmlEncode(
    hCryptXml: ?*anyopaque,
    dwCharset: CRYPT_XML_CHARSET,
    rgProperty: ?[*]const CRYPT_XML_PROPERTY,
    cProperty: u32,
    pvCallbackState: ?*anyopaque,
    pfnWrite: ?PFN_CRYPT_XML_WRITE_CALLBACK,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "cryptxml" fn CryptXmlGetAlgorithmInfo(
    pXmlAlgorithm: ?*const CRYPT_XML_ALGORITHM,
    dwFlags: CRYPT_XML_FLAGS,
    ppAlgInfo: ?*?*CRYPT_XML_ALGORITHM_INFO,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "cryptxml" fn CryptXmlFindAlgorithmInfo(
    dwFindByType: u32,
    pvFindBy: ?*const anyopaque,
    dwGroupId: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) ?*CRYPT_XML_ALGORITHM_INFO;

pub extern "cryptxml" fn CryptXmlEnumAlgorithmInfo(
    dwGroupId: u32,
    dwFlags: u32,
    pvArg: ?*anyopaque,
    pfnEnumAlgInfo: ?PFN_CRYPT_XML_ENUM_ALG_INFO,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "infocardapi" fn GetToken(
    cPolicyChain: u32,
    pPolicyChain: [*]POLICY_ELEMENT,
    securityToken: ?*?*GENERIC_XML_TOKEN,
    phProofTokenCrypto: ?*?*INFORMATIONCARD_CRYPTO_HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "infocardapi" fn ManageCardSpace(
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "infocardapi" fn ImportInformationCard(
    fileName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "infocardapi" fn Encrypt(
    hCrypto: ?*INFORMATIONCARD_CRYPTO_HANDLE,
    fOAEP: BOOL,
    cbInData: u32,
    // TODO: what to do with BytesParamIndex 2?
    pInData: ?*u8,
    pcbOutData: ?*u32,
    // TODO: what to do with BytesParamIndex 4?
    ppOutData: ?*?*u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "infocardapi" fn Decrypt(
    hCrypto: ?*INFORMATIONCARD_CRYPTO_HANDLE,
    fOAEP: BOOL,
    cbInData: u32,
    // TODO: what to do with BytesParamIndex 2?
    pInData: ?*u8,
    pcbOutData: ?*u32,
    // TODO: what to do with BytesParamIndex 4?
    ppOutData: ?*?*u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "infocardapi" fn SignHash(
    hCrypto: ?*INFORMATIONCARD_CRYPTO_HANDLE,
    cbHash: u32,
    // TODO: what to do with BytesParamIndex 1?
    pHash: ?*u8,
    hashAlgOid: ?[*:0]const u16,
    pcbSig: ?*u32,
    // TODO: what to do with BytesParamIndex 4?
    ppSig: ?*?*u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "infocardapi" fn VerifyHash(
    hCrypto: ?*INFORMATIONCARD_CRYPTO_HANDLE,
    cbHash: u32,
    // TODO: what to do with BytesParamIndex 1?
    pHash: ?*u8,
    hashAlgOid: ?[*:0]const u16,
    cbSig: u32,
    // TODO: what to do with BytesParamIndex 4?
    pSig: ?*u8,
    pfVerified: ?*BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "infocardapi" fn GetCryptoTransform(
    hSymmetricCrypto: ?*INFORMATIONCARD_CRYPTO_HANDLE,
    mode: u32,
    padding: PaddingMode,
    feedbackSize: u32,
    direction: Direction,
    cbIV: u32,
    // TODO: what to do with BytesParamIndex 5?
    pIV: ?*u8,
    pphTransform: ?*?*INFORMATIONCARD_CRYPTO_HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "infocardapi" fn GetKeyedHash(
    hSymmetricCrypto: ?*INFORMATIONCARD_CRYPTO_HANDLE,
    pphHash: ?*?*INFORMATIONCARD_CRYPTO_HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "infocardapi" fn TransformBlock(
    hCrypto: ?*INFORMATIONCARD_CRYPTO_HANDLE,
    cbInData: u32,
    // TODO: what to do with BytesParamIndex 1?
    pInData: ?*u8,
    pcbOutData: ?*u32,
    // TODO: what to do with BytesParamIndex 3?
    ppOutData: ?*?*u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "infocardapi" fn TransformFinalBlock(
    hCrypto: ?*INFORMATIONCARD_CRYPTO_HANDLE,
    cbInData: u32,
    // TODO: what to do with BytesParamIndex 1?
    pInData: ?*u8,
    pcbOutData: ?*u32,
    // TODO: what to do with BytesParamIndex 3?
    ppOutData: ?*?*u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "infocardapi" fn HashCore(
    hCrypto: ?*INFORMATIONCARD_CRYPTO_HANDLE,
    cbInData: u32,
    // TODO: what to do with BytesParamIndex 1?
    pInData: ?*u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "infocardapi" fn HashFinal(
    hCrypto: ?*INFORMATIONCARD_CRYPTO_HANDLE,
    cbInData: u32,
    // TODO: what to do with BytesParamIndex 1?
    pInData: ?*u8,
    pcbOutData: ?*u32,
    // TODO: what to do with BytesParamIndex 3?
    ppOutData: ?*?*u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "infocardapi" fn FreeToken(
    pAllocMemory: ?*GENERIC_XML_TOKEN,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "infocardapi" fn CloseCryptoHandle(
    hCrypto: ?*INFORMATIONCARD_CRYPTO_HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "infocardapi" fn GenerateDerivedKey(
    hCrypto: ?*INFORMATIONCARD_CRYPTO_HANDLE,
    cbLabel: u32,
    // TODO: what to do with BytesParamIndex 1?
    pLabel: ?*u8,
    cbNonce: u32,
    // TODO: what to do with BytesParamIndex 3?
    pNonce: ?*u8,
    derivedKeyLength: u32,
    offset: u32,
    algId: ?[*:0]const u16,
    pcbKey: ?*u32,
    // TODO: what to do with BytesParamIndex 8?
    ppKey: ?*?*u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "infocardapi" fn GetBrowserToken(
    dwParamType: u32,
    pParam: ?*anyopaque,
    pcbToken: ?*u32,
    // TODO: what to do with BytesParamIndex 2?
    ppToken: ?*?*u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;


//--------------------------------------------------------------------------------
// Section: Unicode Aliases (18)
//--------------------------------------------------------------------------------
pub const CRYPT_PASSWORD_CREDENTIALS = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().CRYPT_PASSWORD_CREDENTIALSA,
    .wide => @This().CRYPT_PASSWORD_CREDENTIALSW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'CRYPT_PASSWORD_CREDENTIALS' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const CryptAcquireContext = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().CryptAcquireContextA,
    .wide => @This().CryptAcquireContextW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'CryptAcquireContext' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const CryptSignHash = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().CryptSignHashA,
    .wide => @This().CryptSignHashW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'CryptSignHash' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const CryptVerifySignature = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().CryptVerifySignatureA,
    .wide => @This().CryptVerifySignatureW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'CryptVerifySignature' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const CryptSetProvider = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().CryptSetProviderA,
    .wide => @This().CryptSetProviderW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'CryptSetProvider' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const CryptSetProviderEx = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().CryptSetProviderExA,
    .wide => @This().CryptSetProviderExW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'CryptSetProviderEx' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const CryptGetDefaultProvider = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().CryptGetDefaultProviderA,
    .wide => @This().CryptGetDefaultProviderW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'CryptGetDefaultProvider' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const CryptEnumProviderTypes = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().CryptEnumProviderTypesA,
    .wide => @This().CryptEnumProviderTypesW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'CryptEnumProviderTypes' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const CryptEnumProviders = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().CryptEnumProvidersA,
    .wide => @This().CryptEnumProvidersW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'CryptEnumProviders' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const CertRDNValueToStr = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().CertRDNValueToStrA,
    .wide => @This().CertRDNValueToStrW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'CertRDNValueToStr' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const CertNameToStr = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().CertNameToStrA,
    .wide => @This().CertNameToStrW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'CertNameToStr' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const CertStrToName = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().CertStrToNameA,
    .wide => @This().CertStrToNameW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'CertStrToName' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const CertGetNameString = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().CertGetNameStringA,
    .wide => @This().CertGetNameStringW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'CertGetNameString' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const CertOpenSystemStore = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().CertOpenSystemStoreA,
    .wide => @This().CertOpenSystemStoreW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'CertOpenSystemStore' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const CertAddEncodedCertificateToSystemStore = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().CertAddEncodedCertificateToSystemStoreA,
    .wide => @This().CertAddEncodedCertificateToSystemStoreW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'CertAddEncodedCertificateToSystemStore' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const CryptRetrieveObjectByUrl = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().CryptRetrieveObjectByUrlA,
    .wide => @This().CryptRetrieveObjectByUrlW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'CryptRetrieveObjectByUrl' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const CryptStringToBinary = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().CryptStringToBinaryA,
    .wide => @This().CryptStringToBinaryW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'CryptStringToBinary' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const CryptBinaryToString = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().CryptBinaryToStringA,
    .wide => @This().CryptBinaryToStringW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'CryptBinaryToString' requires that UNICODE be set to true or false in the root module",
    ),
};
//--------------------------------------------------------------------------------
// Section: Imports (22)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const BOOL = @import("../foundation.zig").BOOL;
const BSTR = @import("../foundation.zig").BSTR;
const CHAR = @import("../foundation.zig").CHAR;
const FILETIME = @import("../foundation.zig").FILETIME;
const HANDLE = @import("../foundation.zig").HANDLE;
const HINSTANCE = @import("../foundation.zig").HINSTANCE;
const HKEY = @import("../system/registry.zig").HKEY;
const HRESULT = @import("../foundation.zig").HRESULT;
const HWND = @import("../foundation.zig").HWND;
const IDispatch = @import("../system/com.zig").IDispatch;
const IUnknown = @import("../system/com.zig").IUnknown;
const NCRYPT_DESCRIPTOR_HANDLE = @import("../security.zig").NCRYPT_DESCRIPTOR_HANDLE;
const NCRYPT_STREAM_HANDLE = @import("../security.zig").NCRYPT_STREAM_HANDLE;
const NTSTATUS = @import("../foundation.zig").NTSTATUS;
const OBJECT_SECURITY_INFORMATION = @import("../security.zig").OBJECT_SECURITY_INFORMATION;
const PSID = @import("../foundation.zig").PSID;
const PSTR = @import("../foundation.zig").PSTR;
const PWSTR = @import("../foundation.zig").PWSTR;
const REG_VALUE_TYPE = @import("../system/registry.zig").REG_VALUE_TYPE;
const SYSTEMTIME = @import("../foundation.zig").SYSTEMTIME;
const VARIANT = @import("../system/com.zig").VARIANT;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "PFN_NCRYPT_ALLOC")) { _ = PFN_NCRYPT_ALLOC; }
    if (@hasDecl(@This(), "PFN_NCRYPT_FREE")) { _ = PFN_NCRYPT_FREE; }
    if (@hasDecl(@This(), "PCRYPT_DECRYPT_PRIVATE_KEY_FUNC")) { _ = PCRYPT_DECRYPT_PRIVATE_KEY_FUNC; }
    if (@hasDecl(@This(), "PCRYPT_ENCRYPT_PRIVATE_KEY_FUNC")) { _ = PCRYPT_ENCRYPT_PRIVATE_KEY_FUNC; }
    if (@hasDecl(@This(), "PCRYPT_RESOLVE_HCRYPTPROV_FUNC")) { _ = PCRYPT_RESOLVE_HCRYPTPROV_FUNC; }
    if (@hasDecl(@This(), "PFN_CRYPT_ALLOC")) { _ = PFN_CRYPT_ALLOC; }
    if (@hasDecl(@This(), "PFN_CRYPT_FREE")) { _ = PFN_CRYPT_FREE; }
    if (@hasDecl(@This(), "PFN_CRYPT_ENUM_OID_FUNC")) { _ = PFN_CRYPT_ENUM_OID_FUNC; }
    if (@hasDecl(@This(), "PFN_CRYPT_ENUM_OID_INFO")) { _ = PFN_CRYPT_ENUM_OID_INFO; }
    if (@hasDecl(@This(), "PFN_CMSG_STREAM_OUTPUT")) { _ = PFN_CMSG_STREAM_OUTPUT; }
    if (@hasDecl(@This(), "PFN_CMSG_ALLOC")) { _ = PFN_CMSG_ALLOC; }
    if (@hasDecl(@This(), "PFN_CMSG_FREE")) { _ = PFN_CMSG_FREE; }
    if (@hasDecl(@This(), "PFN_CMSG_GEN_ENCRYPT_KEY")) { _ = PFN_CMSG_GEN_ENCRYPT_KEY; }
    if (@hasDecl(@This(), "PFN_CMSG_EXPORT_ENCRYPT_KEY")) { _ = PFN_CMSG_EXPORT_ENCRYPT_KEY; }
    if (@hasDecl(@This(), "PFN_CMSG_IMPORT_ENCRYPT_KEY")) { _ = PFN_CMSG_IMPORT_ENCRYPT_KEY; }
    if (@hasDecl(@This(), "PFN_CMSG_GEN_CONTENT_ENCRYPT_KEY")) { _ = PFN_CMSG_GEN_CONTENT_ENCRYPT_KEY; }
    if (@hasDecl(@This(), "PFN_CMSG_EXPORT_KEY_TRANS")) { _ = PFN_CMSG_EXPORT_KEY_TRANS; }
    if (@hasDecl(@This(), "PFN_CMSG_EXPORT_KEY_AGREE")) { _ = PFN_CMSG_EXPORT_KEY_AGREE; }
    if (@hasDecl(@This(), "PFN_CMSG_EXPORT_MAIL_LIST")) { _ = PFN_CMSG_EXPORT_MAIL_LIST; }
    if (@hasDecl(@This(), "PFN_CMSG_IMPORT_KEY_TRANS")) { _ = PFN_CMSG_IMPORT_KEY_TRANS; }
    if (@hasDecl(@This(), "PFN_CMSG_IMPORT_KEY_AGREE")) { _ = PFN_CMSG_IMPORT_KEY_AGREE; }
    if (@hasDecl(@This(), "PFN_CMSG_IMPORT_MAIL_LIST")) { _ = PFN_CMSG_IMPORT_MAIL_LIST; }
    if (@hasDecl(@This(), "PFN_CMSG_CNG_IMPORT_KEY_TRANS")) { _ = PFN_CMSG_CNG_IMPORT_KEY_TRANS; }
    if (@hasDecl(@This(), "PFN_CMSG_CNG_IMPORT_KEY_AGREE")) { _ = PFN_CMSG_CNG_IMPORT_KEY_AGREE; }
    if (@hasDecl(@This(), "PFN_CMSG_CNG_IMPORT_CONTENT_ENCRYPT_KEY")) { _ = PFN_CMSG_CNG_IMPORT_CONTENT_ENCRYPT_KEY; }
    if (@hasDecl(@This(), "PFN_CERT_DLL_OPEN_STORE_PROV_FUNC")) { _ = PFN_CERT_DLL_OPEN_STORE_PROV_FUNC; }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_CLOSE")) { _ = PFN_CERT_STORE_PROV_CLOSE; }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_READ_CERT")) { _ = PFN_CERT_STORE_PROV_READ_CERT; }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_WRITE_CERT")) { _ = PFN_CERT_STORE_PROV_WRITE_CERT; }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_DELETE_CERT")) { _ = PFN_CERT_STORE_PROV_DELETE_CERT; }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_SET_CERT_PROPERTY")) { _ = PFN_CERT_STORE_PROV_SET_CERT_PROPERTY; }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_READ_CRL")) { _ = PFN_CERT_STORE_PROV_READ_CRL; }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_WRITE_CRL")) { _ = PFN_CERT_STORE_PROV_WRITE_CRL; }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_DELETE_CRL")) { _ = PFN_CERT_STORE_PROV_DELETE_CRL; }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_SET_CRL_PROPERTY")) { _ = PFN_CERT_STORE_PROV_SET_CRL_PROPERTY; }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_READ_CTL")) { _ = PFN_CERT_STORE_PROV_READ_CTL; }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_WRITE_CTL")) { _ = PFN_CERT_STORE_PROV_WRITE_CTL; }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_DELETE_CTL")) { _ = PFN_CERT_STORE_PROV_DELETE_CTL; }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_SET_CTL_PROPERTY")) { _ = PFN_CERT_STORE_PROV_SET_CTL_PROPERTY; }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_CONTROL")) { _ = PFN_CERT_STORE_PROV_CONTROL; }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_FIND_CERT")) { _ = PFN_CERT_STORE_PROV_FIND_CERT; }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_FREE_FIND_CERT")) { _ = PFN_CERT_STORE_PROV_FREE_FIND_CERT; }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_GET_CERT_PROPERTY")) { _ = PFN_CERT_STORE_PROV_GET_CERT_PROPERTY; }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_FIND_CRL")) { _ = PFN_CERT_STORE_PROV_FIND_CRL; }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_FREE_FIND_CRL")) { _ = PFN_CERT_STORE_PROV_FREE_FIND_CRL; }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_GET_CRL_PROPERTY")) { _ = PFN_CERT_STORE_PROV_GET_CRL_PROPERTY; }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_FIND_CTL")) { _ = PFN_CERT_STORE_PROV_FIND_CTL; }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_FREE_FIND_CTL")) { _ = PFN_CERT_STORE_PROV_FREE_FIND_CTL; }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_GET_CTL_PROPERTY")) { _ = PFN_CERT_STORE_PROV_GET_CTL_PROPERTY; }
    if (@hasDecl(@This(), "PFN_CERT_CREATE_CONTEXT_SORT_FUNC")) { _ = PFN_CERT_CREATE_CONTEXT_SORT_FUNC; }
    if (@hasDecl(@This(), "PFN_CERT_ENUM_SYSTEM_STORE_LOCATION")) { _ = PFN_CERT_ENUM_SYSTEM_STORE_LOCATION; }
    if (@hasDecl(@This(), "PFN_CERT_ENUM_SYSTEM_STORE")) { _ = PFN_CERT_ENUM_SYSTEM_STORE; }
    if (@hasDecl(@This(), "PFN_CERT_ENUM_PHYSICAL_STORE")) { _ = PFN_CERT_ENUM_PHYSICAL_STORE; }
    if (@hasDecl(@This(), "PFN_CRYPT_EXTRACT_ENCODED_SIGNATURE_PARAMETERS_FUNC")) { _ = PFN_CRYPT_EXTRACT_ENCODED_SIGNATURE_PARAMETERS_FUNC; }
    if (@hasDecl(@This(), "PFN_CRYPT_SIGN_AND_ENCODE_HASH_FUNC")) { _ = PFN_CRYPT_SIGN_AND_ENCODE_HASH_FUNC; }
    if (@hasDecl(@This(), "PFN_CRYPT_VERIFY_ENCODED_SIGNATURE_FUNC")) { _ = PFN_CRYPT_VERIFY_ENCODED_SIGNATURE_FUNC; }
    if (@hasDecl(@This(), "PFN_CRYPT_EXPORT_PUBLIC_KEY_INFO_EX2_FUNC")) { _ = PFN_CRYPT_EXPORT_PUBLIC_KEY_INFO_EX2_FUNC; }
    if (@hasDecl(@This(), "PFN_CRYPT_EXPORT_PUBLIC_KEY_INFO_FROM_BCRYPT_HANDLE_FUNC")) { _ = PFN_CRYPT_EXPORT_PUBLIC_KEY_INFO_FROM_BCRYPT_HANDLE_FUNC; }
    if (@hasDecl(@This(), "PFN_IMPORT_PUBLIC_KEY_INFO_EX2_FUNC")) { _ = PFN_IMPORT_PUBLIC_KEY_INFO_EX2_FUNC; }
    if (@hasDecl(@This(), "PFN_IMPORT_PRIV_KEY_FUNC")) { _ = PFN_IMPORT_PRIV_KEY_FUNC; }
    if (@hasDecl(@This(), "PFN_EXPORT_PRIV_KEY_FUNC")) { _ = PFN_EXPORT_PRIV_KEY_FUNC; }
    if (@hasDecl(@This(), "PFN_CRYPT_GET_SIGNER_CERTIFICATE")) { _ = PFN_CRYPT_GET_SIGNER_CERTIFICATE; }
    if (@hasDecl(@This(), "PFN_CRYPT_ASYNC_PARAM_FREE_FUNC")) { _ = PFN_CRYPT_ASYNC_PARAM_FREE_FUNC; }
    if (@hasDecl(@This(), "PFN_FREE_ENCODED_OBJECT_FUNC")) { _ = PFN_FREE_ENCODED_OBJECT_FUNC; }
    if (@hasDecl(@This(), "PFN_CRYPT_CANCEL_RETRIEVAL")) { _ = PFN_CRYPT_CANCEL_RETRIEVAL; }
    if (@hasDecl(@This(), "PFN_CRYPT_ASYNC_RETRIEVAL_COMPLETION_FUNC")) { _ = PFN_CRYPT_ASYNC_RETRIEVAL_COMPLETION_FUNC; }
    if (@hasDecl(@This(), "PFN_CANCEL_ASYNC_RETRIEVAL_FUNC")) { _ = PFN_CANCEL_ASYNC_RETRIEVAL_FUNC; }
    if (@hasDecl(@This(), "PFN_CRYPT_ENUM_KEYID_PROP")) { _ = PFN_CRYPT_ENUM_KEYID_PROP; }
    if (@hasDecl(@This(), "PFN_CERT_CHAIN_FIND_BY_ISSUER_CALLBACK")) { _ = PFN_CERT_CHAIN_FIND_BY_ISSUER_CALLBACK; }
    if (@hasDecl(@This(), "PFN_CERT_SERVER_OCSP_RESPONSE_UPDATE_CALLBACK")) { _ = PFN_CERT_SERVER_OCSP_RESPONSE_UPDATE_CALLBACK; }
    if (@hasDecl(@This(), "PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FLUSH")) { _ = PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FLUSH; }
    if (@hasDecl(@This(), "PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_GET")) { _ = PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_GET; }
    if (@hasDecl(@This(), "PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_RELEASE")) { _ = PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_RELEASE; }
    if (@hasDecl(@This(), "PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FREE_PASSWORD")) { _ = PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FREE_PASSWORD; }
    if (@hasDecl(@This(), "PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FREE")) { _ = PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FREE; }
    if (@hasDecl(@This(), "PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FREE_IDENTIFIER")) { _ = PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FREE_IDENTIFIER; }
    if (@hasDecl(@This(), "PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_INITIALIZE")) { _ = PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_INITIALIZE; }
    if (@hasDecl(@This(), "PFN_CERT_IS_WEAK_HASH")) { _ = PFN_CERT_IS_WEAK_HASH; }
    if (@hasDecl(@This(), "PFNCryptStreamOutputCallback")) { _ = PFNCryptStreamOutputCallback; }
    if (@hasDecl(@This(), "PFNCryptStreamOutputCallbackEx")) { _ = PFNCryptStreamOutputCallbackEx; }
    if (@hasDecl(@This(), "PFN_CRYPT_XML_WRITE_CALLBACK")) { _ = PFN_CRYPT_XML_WRITE_CALLBACK; }
    if (@hasDecl(@This(), "PFN_CRYPT_XML_DATA_PROVIDER_READ")) { _ = PFN_CRYPT_XML_DATA_PROVIDER_READ; }
    if (@hasDecl(@This(), "PFN_CRYPT_XML_DATA_PROVIDER_CLOSE")) { _ = PFN_CRYPT_XML_DATA_PROVIDER_CLOSE; }
    if (@hasDecl(@This(), "PFN_CRYPT_XML_CREATE_TRANSFORM")) { _ = PFN_CRYPT_XML_CREATE_TRANSFORM; }
    if (@hasDecl(@This(), "PFN_CRYPT_XML_ENUM_ALG_INFO")) { _ = PFN_CRYPT_XML_ENUM_ALG_INFO; }
    if (@hasDecl(@This(), "CryptXmlDllGetInterface")) { _ = CryptXmlDllGetInterface; }
    if (@hasDecl(@This(), "CryptXmlDllEncodeAlgorithm")) { _ = CryptXmlDllEncodeAlgorithm; }
    if (@hasDecl(@This(), "CryptXmlDllCreateDigest")) { _ = CryptXmlDllCreateDigest; }
    if (@hasDecl(@This(), "CryptXmlDllDigestData")) { _ = CryptXmlDllDigestData; }
    if (@hasDecl(@This(), "CryptXmlDllFinalizeDigest")) { _ = CryptXmlDllFinalizeDigest; }
    if (@hasDecl(@This(), "CryptXmlDllCloseDigest")) { _ = CryptXmlDllCloseDigest; }
    if (@hasDecl(@This(), "CryptXmlDllSignData")) { _ = CryptXmlDllSignData; }
    if (@hasDecl(@This(), "CryptXmlDllVerifySignature")) { _ = CryptXmlDllVerifySignature; }
    if (@hasDecl(@This(), "CryptXmlDllGetAlgorithmInfo")) { _ = CryptXmlDllGetAlgorithmInfo; }
    if (@hasDecl(@This(), "CryptXmlDllEncodeKeyValue")) { _ = CryptXmlDllEncodeKeyValue; }
    if (@hasDecl(@This(), "CryptXmlDllCreateKey")) { _ = CryptXmlDllCreateKey; }

    @setEvalBranchQuota(
        comptime @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        _ = @field(@This(), decl.name);
    }
}
//--------------------------------------------------------------------------------
// Section: SubModules (4)
//--------------------------------------------------------------------------------
pub const catalog = @import("cryptography/catalog.zig");
pub const certificates = @import("cryptography/certificates.zig");
pub const sip = @import("cryptography/sip.zig");
pub const ui = @import("cryptography/ui.zig");
