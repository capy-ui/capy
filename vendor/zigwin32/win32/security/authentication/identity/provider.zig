//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (1)
//--------------------------------------------------------------------------------
pub const OID_OAssociatedIdentityProviderObject = Guid.initString("98c5a3dd-db68-4f1a-8d2b-9079cdfeaf61");

//--------------------------------------------------------------------------------
// Section: Types (20)
//--------------------------------------------------------------------------------
pub const IDENTITY_TYPE = enum(i32) {
    ALL = 0,
    ME_ONLY = 1,
};
pub const IDENTITIES_ALL = IDENTITY_TYPE.ALL;
pub const IDENTITIES_ME_ONLY = IDENTITY_TYPE.ME_ONLY;

pub const IdentityUpdateEvent = enum(u32) {
    ASSOCIATED = 1,
    DISASSOCIATED = 2,
    CREATED = 4,
    IMPORTED = 8,
    DELETED = 16,
    PROPCHANGED = 32,
    CONNECTED = 64,
    DISCONNECTED = 128,
    _,
    pub fn initFlags(o: struct {
        ASSOCIATED: u1 = 0,
        DISASSOCIATED: u1 = 0,
        CREATED: u1 = 0,
        IMPORTED: u1 = 0,
        DELETED: u1 = 0,
        PROPCHANGED: u1 = 0,
        CONNECTED: u1 = 0,
        DISCONNECTED: u1 = 0,
    }) IdentityUpdateEvent {
        return @intToEnum(IdentityUpdateEvent,
              (if (o.ASSOCIATED == 1) @enumToInt(IdentityUpdateEvent.ASSOCIATED) else 0)
            | (if (o.DISASSOCIATED == 1) @enumToInt(IdentityUpdateEvent.DISASSOCIATED) else 0)
            | (if (o.CREATED == 1) @enumToInt(IdentityUpdateEvent.CREATED) else 0)
            | (if (o.IMPORTED == 1) @enumToInt(IdentityUpdateEvent.IMPORTED) else 0)
            | (if (o.DELETED == 1) @enumToInt(IdentityUpdateEvent.DELETED) else 0)
            | (if (o.PROPCHANGED == 1) @enumToInt(IdentityUpdateEvent.PROPCHANGED) else 0)
            | (if (o.CONNECTED == 1) @enumToInt(IdentityUpdateEvent.CONNECTED) else 0)
            | (if (o.DISCONNECTED == 1) @enumToInt(IdentityUpdateEvent.DISCONNECTED) else 0)
        );
    }
};
pub const IDENTITY_ASSOCIATED = IdentityUpdateEvent.ASSOCIATED;
pub const IDENTITY_DISASSOCIATED = IdentityUpdateEvent.DISASSOCIATED;
pub const IDENTITY_CREATED = IdentityUpdateEvent.CREATED;
pub const IDENTITY_IMPORTED = IdentityUpdateEvent.IMPORTED;
pub const IDENTITY_DELETED = IdentityUpdateEvent.DELETED;
pub const IDENTITY_PROPCHANGED = IdentityUpdateEvent.PROPCHANGED;
pub const IDENTITY_CONNECTED = IdentityUpdateEvent.CONNECTED;
pub const IDENTITY_DISCONNECTED = IdentityUpdateEvent.DISCONNECTED;

// TODO: this type is limited to platform 'windows6.1'
const IID_IIdentityAdvise_Value = Guid.initString("4e982fed-d14b-440c-b8d6-bb386453d386");
pub const IID_IIdentityAdvise = &IID_IIdentityAdvise_Value;
pub const IIdentityAdvise = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IdentityUpdated: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIdentityAdvise,
                dwIdentityUpdateEvents: IdentityUpdateEvent,
                lpszUniqueID: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIdentityAdvise,
                dwIdentityUpdateEvents: IdentityUpdateEvent,
                lpszUniqueID: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIdentityAdvise_IdentityUpdated(self: *const T, dwIdentityUpdateEvents: IdentityUpdateEvent, lpszUniqueID: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIdentityAdvise.VTable, self.vtable).IdentityUpdated(@ptrCast(*const IIdentityAdvise, self), dwIdentityUpdateEvents, lpszUniqueID);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_AsyncIIdentityAdvise_Value = Guid.initString("3ab4c8da-d038-4830-8dd9-3253c55a127f");
pub const IID_AsyncIIdentityAdvise = &IID_AsyncIIdentityAdvise_Value;
pub const AsyncIIdentityAdvise = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Begin_IdentityUpdated: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const AsyncIIdentityAdvise,
                dwIdentityUpdateEvents: u32,
                lpszUniqueID: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const AsyncIIdentityAdvise,
                dwIdentityUpdateEvents: u32,
                lpszUniqueID: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Finish_IdentityUpdated: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const AsyncIIdentityAdvise,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const AsyncIIdentityAdvise,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIIdentityAdvise_Begin_IdentityUpdated(self: *const T, dwIdentityUpdateEvents: u32, lpszUniqueID: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIIdentityAdvise.VTable, self.vtable).Begin_IdentityUpdated(@ptrCast(*const AsyncIIdentityAdvise, self), dwIdentityUpdateEvents, lpszUniqueID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIIdentityAdvise_Finish_IdentityUpdated(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIIdentityAdvise.VTable, self.vtable).Finish_IdentityUpdated(@ptrCast(*const AsyncIIdentityAdvise, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IIdentityProvider_Value = Guid.initString("0d1b9e0c-e8ba-4f55-a81b-bce934b948f5");
pub const IID_IIdentityProvider = &IID_IIdentityProvider_Value;
pub const IIdentityProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetIdentityEnum: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIdentityProvider,
                eIdentityType: IDENTITY_TYPE,
                pFilterkey: ?*const PROPERTYKEY,
                pFilterPropVarValue: ?*const PROPVARIANT,
                ppIdentityEnum: ?*?*IEnumUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIdentityProvider,
                eIdentityType: IDENTITY_TYPE,
                pFilterkey: ?*const PROPERTYKEY,
                pFilterPropVarValue: ?*const PROPVARIANT,
                ppIdentityEnum: ?*?*IEnumUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Create: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIdentityProvider,
                lpszUserName: ?[*:0]const u16,
                ppPropertyStore: ?*?*IPropertyStore,
                pKeywordsToAdd: ?*const PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIdentityProvider,
                lpszUserName: ?[*:0]const u16,
                ppPropertyStore: ?*?*IPropertyStore,
                pKeywordsToAdd: ?*const PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Import: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIdentityProvider,
                pPropertyStore: ?*IPropertyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIdentityProvider,
                pPropertyStore: ?*IPropertyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Delete: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIdentityProvider,
                lpszUniqueID: ?[*:0]const u16,
                pKeywordsToDelete: ?*const PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIdentityProvider,
                lpszUniqueID: ?[*:0]const u16,
                pKeywordsToDelete: ?*const PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindByUniqueID: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIdentityProvider,
                lpszUniqueID: ?[*:0]const u16,
                ppPropertyStore: ?*?*IPropertyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIdentityProvider,
                lpszUniqueID: ?[*:0]const u16,
                ppPropertyStore: ?*?*IPropertyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProviderPropertyStore: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIdentityProvider,
                ppPropertyStore: ?*?*IPropertyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIdentityProvider,
                ppPropertyStore: ?*?*IPropertyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Advise: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIdentityProvider,
                pIdentityAdvise: ?*IIdentityAdvise,
                dwIdentityUpdateEvents: IdentityUpdateEvent,
                pdwCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIdentityProvider,
                pIdentityAdvise: ?*IIdentityAdvise,
                dwIdentityUpdateEvents: IdentityUpdateEvent,
                pdwCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnAdvise: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIdentityProvider,
                dwCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIdentityProvider,
                dwCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIdentityProvider_GetIdentityEnum(self: *const T, eIdentityType: IDENTITY_TYPE, pFilterkey: ?*const PROPERTYKEY, pFilterPropVarValue: ?*const PROPVARIANT, ppIdentityEnum: ?*?*IEnumUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIdentityProvider.VTable, self.vtable).GetIdentityEnum(@ptrCast(*const IIdentityProvider, self), eIdentityType, pFilterkey, pFilterPropVarValue, ppIdentityEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIdentityProvider_Create(self: *const T, lpszUserName: ?[*:0]const u16, ppPropertyStore: ?*?*IPropertyStore, pKeywordsToAdd: ?*const PROPVARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIdentityProvider.VTable, self.vtable).Create(@ptrCast(*const IIdentityProvider, self), lpszUserName, ppPropertyStore, pKeywordsToAdd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIdentityProvider_Import(self: *const T, pPropertyStore: ?*IPropertyStore) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIdentityProvider.VTable, self.vtable).Import(@ptrCast(*const IIdentityProvider, self), pPropertyStore);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIdentityProvider_Delete(self: *const T, lpszUniqueID: ?[*:0]const u16, pKeywordsToDelete: ?*const PROPVARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIdentityProvider.VTable, self.vtable).Delete(@ptrCast(*const IIdentityProvider, self), lpszUniqueID, pKeywordsToDelete);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIdentityProvider_FindByUniqueID(self: *const T, lpszUniqueID: ?[*:0]const u16, ppPropertyStore: ?*?*IPropertyStore) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIdentityProvider.VTable, self.vtable).FindByUniqueID(@ptrCast(*const IIdentityProvider, self), lpszUniqueID, ppPropertyStore);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIdentityProvider_GetProviderPropertyStore(self: *const T, ppPropertyStore: ?*?*IPropertyStore) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIdentityProvider.VTable, self.vtable).GetProviderPropertyStore(@ptrCast(*const IIdentityProvider, self), ppPropertyStore);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIdentityProvider_Advise(self: *const T, pIdentityAdvise: ?*IIdentityAdvise, dwIdentityUpdateEvents: IdentityUpdateEvent, pdwCookie: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIdentityProvider.VTable, self.vtable).Advise(@ptrCast(*const IIdentityProvider, self), pIdentityAdvise, dwIdentityUpdateEvents, pdwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIdentityProvider_UnAdvise(self: *const T, dwCookie: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIdentityProvider.VTable, self.vtable).UnAdvise(@ptrCast(*const IIdentityProvider, self), dwCookie);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_AsyncIIdentityProvider_Value = Guid.initString("c6fc9901-c433-4646-8f48-4e4687aae2a0");
pub const IID_AsyncIIdentityProvider = &IID_AsyncIIdentityProvider_Value;
pub const AsyncIIdentityProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Begin_GetIdentityEnum: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const AsyncIIdentityProvider,
                eIdentityType: IDENTITY_TYPE,
                pFilterkey: ?*const PROPERTYKEY,
                pFilterPropVarValue: ?*const PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const AsyncIIdentityProvider,
                eIdentityType: IDENTITY_TYPE,
                pFilterkey: ?*const PROPERTYKEY,
                pFilterPropVarValue: ?*const PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Finish_GetIdentityEnum: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const AsyncIIdentityProvider,
                ppIdentityEnum: ?*?*IEnumUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const AsyncIIdentityProvider,
                ppIdentityEnum: ?*?*IEnumUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Begin_Create: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const AsyncIIdentityProvider,
                lpszUserName: ?[*:0]const u16,
                pKeywordsToAdd: ?*const PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const AsyncIIdentityProvider,
                lpszUserName: ?[*:0]const u16,
                pKeywordsToAdd: ?*const PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Finish_Create: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const AsyncIIdentityProvider,
                ppPropertyStore: ?*?*IPropertyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const AsyncIIdentityProvider,
                ppPropertyStore: ?*?*IPropertyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Begin_Import: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const AsyncIIdentityProvider,
                pPropertyStore: ?*IPropertyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const AsyncIIdentityProvider,
                pPropertyStore: ?*IPropertyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Finish_Import: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const AsyncIIdentityProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const AsyncIIdentityProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Begin_Delete: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const AsyncIIdentityProvider,
                lpszUniqueID: ?[*:0]const u16,
                pKeywordsToDelete: ?*const PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const AsyncIIdentityProvider,
                lpszUniqueID: ?[*:0]const u16,
                pKeywordsToDelete: ?*const PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Finish_Delete: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const AsyncIIdentityProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const AsyncIIdentityProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Begin_FindByUniqueID: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const AsyncIIdentityProvider,
                lpszUniqueID: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const AsyncIIdentityProvider,
                lpszUniqueID: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Finish_FindByUniqueID: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const AsyncIIdentityProvider,
                ppPropertyStore: ?*?*IPropertyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const AsyncIIdentityProvider,
                ppPropertyStore: ?*?*IPropertyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Begin_GetProviderPropertyStore: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const AsyncIIdentityProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const AsyncIIdentityProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Finish_GetProviderPropertyStore: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const AsyncIIdentityProvider,
                ppPropertyStore: ?*?*IPropertyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const AsyncIIdentityProvider,
                ppPropertyStore: ?*?*IPropertyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Begin_Advise: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const AsyncIIdentityProvider,
                pIdentityAdvise: ?*IIdentityAdvise,
                dwIdentityUpdateEvents: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const AsyncIIdentityProvider,
                pIdentityAdvise: ?*IIdentityAdvise,
                dwIdentityUpdateEvents: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Finish_Advise: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const AsyncIIdentityProvider,
                pdwCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const AsyncIIdentityProvider,
                pdwCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Begin_UnAdvise: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const AsyncIIdentityProvider,
                dwCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const AsyncIIdentityProvider,
                dwCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Finish_UnAdvise: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const AsyncIIdentityProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const AsyncIIdentityProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIIdentityProvider_Begin_GetIdentityEnum(self: *const T, eIdentityType: IDENTITY_TYPE, pFilterkey: ?*const PROPERTYKEY, pFilterPropVarValue: ?*const PROPVARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIIdentityProvider.VTable, self.vtable).Begin_GetIdentityEnum(@ptrCast(*const AsyncIIdentityProvider, self), eIdentityType, pFilterkey, pFilterPropVarValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIIdentityProvider_Finish_GetIdentityEnum(self: *const T, ppIdentityEnum: ?*?*IEnumUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIIdentityProvider.VTable, self.vtable).Finish_GetIdentityEnum(@ptrCast(*const AsyncIIdentityProvider, self), ppIdentityEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIIdentityProvider_Begin_Create(self: *const T, lpszUserName: ?[*:0]const u16, pKeywordsToAdd: ?*const PROPVARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIIdentityProvider.VTable, self.vtable).Begin_Create(@ptrCast(*const AsyncIIdentityProvider, self), lpszUserName, pKeywordsToAdd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIIdentityProvider_Finish_Create(self: *const T, ppPropertyStore: ?*?*IPropertyStore) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIIdentityProvider.VTable, self.vtable).Finish_Create(@ptrCast(*const AsyncIIdentityProvider, self), ppPropertyStore);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIIdentityProvider_Begin_Import(self: *const T, pPropertyStore: ?*IPropertyStore) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIIdentityProvider.VTable, self.vtable).Begin_Import(@ptrCast(*const AsyncIIdentityProvider, self), pPropertyStore);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIIdentityProvider_Finish_Import(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIIdentityProvider.VTable, self.vtable).Finish_Import(@ptrCast(*const AsyncIIdentityProvider, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIIdentityProvider_Begin_Delete(self: *const T, lpszUniqueID: ?[*:0]const u16, pKeywordsToDelete: ?*const PROPVARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIIdentityProvider.VTable, self.vtable).Begin_Delete(@ptrCast(*const AsyncIIdentityProvider, self), lpszUniqueID, pKeywordsToDelete);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIIdentityProvider_Finish_Delete(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIIdentityProvider.VTable, self.vtable).Finish_Delete(@ptrCast(*const AsyncIIdentityProvider, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIIdentityProvider_Begin_FindByUniqueID(self: *const T, lpszUniqueID: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIIdentityProvider.VTable, self.vtable).Begin_FindByUniqueID(@ptrCast(*const AsyncIIdentityProvider, self), lpszUniqueID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIIdentityProvider_Finish_FindByUniqueID(self: *const T, ppPropertyStore: ?*?*IPropertyStore) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIIdentityProvider.VTable, self.vtable).Finish_FindByUniqueID(@ptrCast(*const AsyncIIdentityProvider, self), ppPropertyStore);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIIdentityProvider_Begin_GetProviderPropertyStore(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIIdentityProvider.VTable, self.vtable).Begin_GetProviderPropertyStore(@ptrCast(*const AsyncIIdentityProvider, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIIdentityProvider_Finish_GetProviderPropertyStore(self: *const T, ppPropertyStore: ?*?*IPropertyStore) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIIdentityProvider.VTable, self.vtable).Finish_GetProviderPropertyStore(@ptrCast(*const AsyncIIdentityProvider, self), ppPropertyStore);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIIdentityProvider_Begin_Advise(self: *const T, pIdentityAdvise: ?*IIdentityAdvise, dwIdentityUpdateEvents: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIIdentityProvider.VTable, self.vtable).Begin_Advise(@ptrCast(*const AsyncIIdentityProvider, self), pIdentityAdvise, dwIdentityUpdateEvents);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIIdentityProvider_Finish_Advise(self: *const T, pdwCookie: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIIdentityProvider.VTable, self.vtable).Finish_Advise(@ptrCast(*const AsyncIIdentityProvider, self), pdwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIIdentityProvider_Begin_UnAdvise(self: *const T, dwCookie: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIIdentityProvider.VTable, self.vtable).Begin_UnAdvise(@ptrCast(*const AsyncIIdentityProvider, self), dwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIIdentityProvider_Finish_UnAdvise(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIIdentityProvider.VTable, self.vtable).Finish_UnAdvise(@ptrCast(*const AsyncIIdentityProvider, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IAssociatedIdentityProvider_Value = Guid.initString("2af066b3-4cbb-4cba-a798-204b6af68cc0");
pub const IID_IAssociatedIdentityProvider = &IID_IAssociatedIdentityProvider_Value;
pub const IAssociatedIdentityProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AssociateIdentity: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAssociatedIdentityProvider,
                hwndParent: ?HWND,
                ppPropertyStore: ?*?*IPropertyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAssociatedIdentityProvider,
                hwndParent: ?HWND,
                ppPropertyStore: ?*?*IPropertyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DisassociateIdentity: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAssociatedIdentityProvider,
                hwndParent: ?HWND,
                lpszUniqueID: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAssociatedIdentityProvider,
                hwndParent: ?HWND,
                lpszUniqueID: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ChangeCredential: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAssociatedIdentityProvider,
                hwndParent: ?HWND,
                lpszUniqueID: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAssociatedIdentityProvider,
                hwndParent: ?HWND,
                lpszUniqueID: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAssociatedIdentityProvider_AssociateIdentity(self: *const T, hwndParent: ?HWND, ppPropertyStore: ?*?*IPropertyStore) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAssociatedIdentityProvider.VTable, self.vtable).AssociateIdentity(@ptrCast(*const IAssociatedIdentityProvider, self), hwndParent, ppPropertyStore);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAssociatedIdentityProvider_DisassociateIdentity(self: *const T, hwndParent: ?HWND, lpszUniqueID: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAssociatedIdentityProvider.VTable, self.vtable).DisassociateIdentity(@ptrCast(*const IAssociatedIdentityProvider, self), hwndParent, lpszUniqueID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAssociatedIdentityProvider_ChangeCredential(self: *const T, hwndParent: ?HWND, lpszUniqueID: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAssociatedIdentityProvider.VTable, self.vtable).ChangeCredential(@ptrCast(*const IAssociatedIdentityProvider, self), hwndParent, lpszUniqueID);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_AsyncIAssociatedIdentityProvider_Value = Guid.initString("2834d6ed-297e-4e72-8a51-961e86f05152");
pub const IID_AsyncIAssociatedIdentityProvider = &IID_AsyncIAssociatedIdentityProvider_Value;
pub const AsyncIAssociatedIdentityProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Begin_AssociateIdentity: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const AsyncIAssociatedIdentityProvider,
                hwndParent: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const AsyncIAssociatedIdentityProvider,
                hwndParent: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Finish_AssociateIdentity: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const AsyncIAssociatedIdentityProvider,
                ppPropertyStore: ?*?*IPropertyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const AsyncIAssociatedIdentityProvider,
                ppPropertyStore: ?*?*IPropertyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Begin_DisassociateIdentity: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const AsyncIAssociatedIdentityProvider,
                hwndParent: ?HWND,
                lpszUniqueID: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const AsyncIAssociatedIdentityProvider,
                hwndParent: ?HWND,
                lpszUniqueID: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Finish_DisassociateIdentity: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const AsyncIAssociatedIdentityProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const AsyncIAssociatedIdentityProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Begin_ChangeCredential: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const AsyncIAssociatedIdentityProvider,
                hwndParent: ?HWND,
                lpszUniqueID: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const AsyncIAssociatedIdentityProvider,
                hwndParent: ?HWND,
                lpszUniqueID: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Finish_ChangeCredential: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const AsyncIAssociatedIdentityProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const AsyncIAssociatedIdentityProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIAssociatedIdentityProvider_Begin_AssociateIdentity(self: *const T, hwndParent: ?HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIAssociatedIdentityProvider.VTable, self.vtable).Begin_AssociateIdentity(@ptrCast(*const AsyncIAssociatedIdentityProvider, self), hwndParent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIAssociatedIdentityProvider_Finish_AssociateIdentity(self: *const T, ppPropertyStore: ?*?*IPropertyStore) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIAssociatedIdentityProvider.VTable, self.vtable).Finish_AssociateIdentity(@ptrCast(*const AsyncIAssociatedIdentityProvider, self), ppPropertyStore);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIAssociatedIdentityProvider_Begin_DisassociateIdentity(self: *const T, hwndParent: ?HWND, lpszUniqueID: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIAssociatedIdentityProvider.VTable, self.vtable).Begin_DisassociateIdentity(@ptrCast(*const AsyncIAssociatedIdentityProvider, self), hwndParent, lpszUniqueID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIAssociatedIdentityProvider_Finish_DisassociateIdentity(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIAssociatedIdentityProvider.VTable, self.vtable).Finish_DisassociateIdentity(@ptrCast(*const AsyncIAssociatedIdentityProvider, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIAssociatedIdentityProvider_Begin_ChangeCredential(self: *const T, hwndParent: ?HWND, lpszUniqueID: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIAssociatedIdentityProvider.VTable, self.vtable).Begin_ChangeCredential(@ptrCast(*const AsyncIAssociatedIdentityProvider, self), hwndParent, lpszUniqueID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIAssociatedIdentityProvider_Finish_ChangeCredential(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIAssociatedIdentityProvider.VTable, self.vtable).Finish_ChangeCredential(@ptrCast(*const AsyncIAssociatedIdentityProvider, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const IDENTITY_URL = enum(i32) {
    CREATE_ACCOUNT_WIZARD = 0,
    SIGN_IN_WIZARD = 1,
    CHANGE_PASSWORD_WIZARD = 2,
    IFEXISTS_WIZARD = 3,
    ACCOUNT_SETTINGS = 4,
    RESTORE_WIZARD = 5,
    CONNECT_WIZARD = 6,
};
pub const IDENTITY_URL_CREATE_ACCOUNT_WIZARD = IDENTITY_URL.CREATE_ACCOUNT_WIZARD;
pub const IDENTITY_URL_SIGN_IN_WIZARD = IDENTITY_URL.SIGN_IN_WIZARD;
pub const IDENTITY_URL_CHANGE_PASSWORD_WIZARD = IDENTITY_URL.CHANGE_PASSWORD_WIZARD;
pub const IDENTITY_URL_IFEXISTS_WIZARD = IDENTITY_URL.IFEXISTS_WIZARD;
pub const IDENTITY_URL_ACCOUNT_SETTINGS = IDENTITY_URL.ACCOUNT_SETTINGS;
pub const IDENTITY_URL_RESTORE_WIZARD = IDENTITY_URL.RESTORE_WIZARD;
pub const IDENTITY_URL_CONNECT_WIZARD = IDENTITY_URL.CONNECT_WIZARD;

pub const ACCOUNT_STATE = enum(i32) {
    NOT_CONNECTED = 0,
    CONNECTING = 1,
    CONNECT_COMPLETED = 2,
};
pub const NOT_CONNECTED = ACCOUNT_STATE.NOT_CONNECTED;
pub const CONNECTING = ACCOUNT_STATE.CONNECTING;
pub const CONNECT_COMPLETED = ACCOUNT_STATE.CONNECT_COMPLETED;

// TODO: this type is limited to platform 'windows8.0'
const IID_IConnectedIdentityProvider_Value = Guid.initString("b7417b54-e08c-429b-96c8-678d1369ecb1");
pub const IID_IConnectedIdentityProvider = &IID_IConnectedIdentityProvider_Value;
pub const IConnectedIdentityProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ConnectIdentity: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IConnectedIdentityProvider,
                AuthBuffer: [*:0]u8,
                AuthBufferSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IConnectedIdentityProvider,
                AuthBuffer: [*:0]u8,
                AuthBufferSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DisconnectIdentity: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IConnectedIdentityProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IConnectedIdentityProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsConnected: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IConnectedIdentityProvider,
                Connected: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IConnectedIdentityProvider,
                Connected: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetUrl: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IConnectedIdentityProvider,
                Identifier: IDENTITY_URL,
                Context: ?*IBindCtx,
                PostData: ?*VARIANT,
                Url: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IConnectedIdentityProvider,
                Identifier: IDENTITY_URL,
                Context: ?*IBindCtx,
                PostData: ?*VARIANT,
                Url: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAccountState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IConnectedIdentityProvider,
                pState: ?*ACCOUNT_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IConnectedIdentityProvider,
                pState: ?*ACCOUNT_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConnectedIdentityProvider_ConnectIdentity(self: *const T, AuthBuffer: [*:0]u8, AuthBufferSize: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConnectedIdentityProvider.VTable, self.vtable).ConnectIdentity(@ptrCast(*const IConnectedIdentityProvider, self), AuthBuffer, AuthBufferSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConnectedIdentityProvider_DisconnectIdentity(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConnectedIdentityProvider.VTable, self.vtable).DisconnectIdentity(@ptrCast(*const IConnectedIdentityProvider, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConnectedIdentityProvider_IsConnected(self: *const T, Connected: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConnectedIdentityProvider.VTable, self.vtable).IsConnected(@ptrCast(*const IConnectedIdentityProvider, self), Connected);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConnectedIdentityProvider_GetUrl(self: *const T, Identifier: IDENTITY_URL, Context: ?*IBindCtx, PostData: ?*VARIANT, Url: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConnectedIdentityProvider.VTable, self.vtable).GetUrl(@ptrCast(*const IConnectedIdentityProvider, self), Identifier, Context, PostData, Url);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConnectedIdentityProvider_GetAccountState(self: *const T, pState: ?*ACCOUNT_STATE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConnectedIdentityProvider.VTable, self.vtable).GetAccountState(@ptrCast(*const IConnectedIdentityProvider, self), pState);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_AsyncIConnectedIdentityProvider_Value = Guid.initString("9ce55141-bce9-4e15-824d-43d79f512f93");
pub const IID_AsyncIConnectedIdentityProvider = &IID_AsyncIConnectedIdentityProvider_Value;
pub const AsyncIConnectedIdentityProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Begin_ConnectIdentity: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const AsyncIConnectedIdentityProvider,
                AuthBuffer: [*:0]u8,
                AuthBufferSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const AsyncIConnectedIdentityProvider,
                AuthBuffer: [*:0]u8,
                AuthBufferSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Finish_ConnectIdentity: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const AsyncIConnectedIdentityProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const AsyncIConnectedIdentityProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Begin_DisconnectIdentity: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const AsyncIConnectedIdentityProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const AsyncIConnectedIdentityProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Finish_DisconnectIdentity: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const AsyncIConnectedIdentityProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const AsyncIConnectedIdentityProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Begin_IsConnected: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const AsyncIConnectedIdentityProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const AsyncIConnectedIdentityProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Finish_IsConnected: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const AsyncIConnectedIdentityProvider,
                Connected: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const AsyncIConnectedIdentityProvider,
                Connected: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Begin_GetUrl: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const AsyncIConnectedIdentityProvider,
                Identifier: IDENTITY_URL,
                Context: ?*IBindCtx,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const AsyncIConnectedIdentityProvider,
                Identifier: IDENTITY_URL,
                Context: ?*IBindCtx,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Finish_GetUrl: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const AsyncIConnectedIdentityProvider,
                PostData: ?*VARIANT,
                Url: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const AsyncIConnectedIdentityProvider,
                PostData: ?*VARIANT,
                Url: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Begin_GetAccountState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const AsyncIConnectedIdentityProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const AsyncIConnectedIdentityProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Finish_GetAccountState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const AsyncIConnectedIdentityProvider,
                pState: ?*ACCOUNT_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const AsyncIConnectedIdentityProvider,
                pState: ?*ACCOUNT_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIConnectedIdentityProvider_Begin_ConnectIdentity(self: *const T, AuthBuffer: [*:0]u8, AuthBufferSize: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIConnectedIdentityProvider.VTable, self.vtable).Begin_ConnectIdentity(@ptrCast(*const AsyncIConnectedIdentityProvider, self), AuthBuffer, AuthBufferSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIConnectedIdentityProvider_Finish_ConnectIdentity(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIConnectedIdentityProvider.VTable, self.vtable).Finish_ConnectIdentity(@ptrCast(*const AsyncIConnectedIdentityProvider, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIConnectedIdentityProvider_Begin_DisconnectIdentity(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIConnectedIdentityProvider.VTable, self.vtable).Begin_DisconnectIdentity(@ptrCast(*const AsyncIConnectedIdentityProvider, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIConnectedIdentityProvider_Finish_DisconnectIdentity(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIConnectedIdentityProvider.VTable, self.vtable).Finish_DisconnectIdentity(@ptrCast(*const AsyncIConnectedIdentityProvider, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIConnectedIdentityProvider_Begin_IsConnected(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIConnectedIdentityProvider.VTable, self.vtable).Begin_IsConnected(@ptrCast(*const AsyncIConnectedIdentityProvider, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIConnectedIdentityProvider_Finish_IsConnected(self: *const T, Connected: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIConnectedIdentityProvider.VTable, self.vtable).Finish_IsConnected(@ptrCast(*const AsyncIConnectedIdentityProvider, self), Connected);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIConnectedIdentityProvider_Begin_GetUrl(self: *const T, Identifier: IDENTITY_URL, Context: ?*IBindCtx) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIConnectedIdentityProvider.VTable, self.vtable).Begin_GetUrl(@ptrCast(*const AsyncIConnectedIdentityProvider, self), Identifier, Context);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIConnectedIdentityProvider_Finish_GetUrl(self: *const T, PostData: ?*VARIANT, Url: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIConnectedIdentityProvider.VTable, self.vtable).Finish_GetUrl(@ptrCast(*const AsyncIConnectedIdentityProvider, self), PostData, Url);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIConnectedIdentityProvider_Begin_GetAccountState(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIConnectedIdentityProvider.VTable, self.vtable).Begin_GetAccountState(@ptrCast(*const AsyncIConnectedIdentityProvider, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIConnectedIdentityProvider_Finish_GetAccountState(self: *const T, pState: ?*ACCOUNT_STATE) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIConnectedIdentityProvider.VTable, self.vtable).Finish_GetAccountState(@ptrCast(*const AsyncIConnectedIdentityProvider, self), pState);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IIdentityAuthentication_Value = Guid.initString("5e7ef254-979f-43b5-b74e-06e4eb7df0f9");
pub const IID_IIdentityAuthentication = &IID_IIdentityAuthentication_Value;
pub const IIdentityAuthentication = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetIdentityCredential: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIdentityAuthentication,
                CredBuffer: ?[*:0]u8,
                CredBufferLength: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIdentityAuthentication,
                CredBuffer: ?[*:0]u8,
                CredBufferLength: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ValidateIdentityCredential: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIdentityAuthentication,
                CredBuffer: [*:0]u8,
                CredBufferLength: u32,
                ppIdentityProperties: ?*?*IPropertyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIdentityAuthentication,
                CredBuffer: [*:0]u8,
                CredBufferLength: u32,
                ppIdentityProperties: ?*?*IPropertyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIdentityAuthentication_SetIdentityCredential(self: *const T, CredBuffer: ?[*:0]u8, CredBufferLength: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIdentityAuthentication.VTable, self.vtable).SetIdentityCredential(@ptrCast(*const IIdentityAuthentication, self), CredBuffer, CredBufferLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIdentityAuthentication_ValidateIdentityCredential(self: *const T, CredBuffer: [*:0]u8, CredBufferLength: u32, ppIdentityProperties: ?*?*IPropertyStore) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIdentityAuthentication.VTable, self.vtable).ValidateIdentityCredential(@ptrCast(*const IIdentityAuthentication, self), CredBuffer, CredBufferLength, ppIdentityProperties);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_AsyncIIdentityAuthentication_Value = Guid.initString("f9a2f918-feca-4e9c-9633-61cbf13ed34d");
pub const IID_AsyncIIdentityAuthentication = &IID_AsyncIIdentityAuthentication_Value;
pub const AsyncIIdentityAuthentication = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Begin_SetIdentityCredential: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const AsyncIIdentityAuthentication,
                CredBuffer: ?[*:0]u8,
                CredBufferLength: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const AsyncIIdentityAuthentication,
                CredBuffer: ?[*:0]u8,
                CredBufferLength: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Finish_SetIdentityCredential: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const AsyncIIdentityAuthentication,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const AsyncIIdentityAuthentication,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Begin_ValidateIdentityCredential: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const AsyncIIdentityAuthentication,
                CredBuffer: [*:0]u8,
                CredBufferLength: u32,
                ppIdentityProperties: ?*?*IPropertyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const AsyncIIdentityAuthentication,
                CredBuffer: [*:0]u8,
                CredBufferLength: u32,
                ppIdentityProperties: ?*?*IPropertyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Finish_ValidateIdentityCredential: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const AsyncIIdentityAuthentication,
                ppIdentityProperties: ?*?*IPropertyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const AsyncIIdentityAuthentication,
                ppIdentityProperties: ?*?*IPropertyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIIdentityAuthentication_Begin_SetIdentityCredential(self: *const T, CredBuffer: ?[*:0]u8, CredBufferLength: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIIdentityAuthentication.VTable, self.vtable).Begin_SetIdentityCredential(@ptrCast(*const AsyncIIdentityAuthentication, self), CredBuffer, CredBufferLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIIdentityAuthentication_Finish_SetIdentityCredential(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIIdentityAuthentication.VTable, self.vtable).Finish_SetIdentityCredential(@ptrCast(*const AsyncIIdentityAuthentication, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIIdentityAuthentication_Begin_ValidateIdentityCredential(self: *const T, CredBuffer: [*:0]u8, CredBufferLength: u32, ppIdentityProperties: ?*?*IPropertyStore) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIIdentityAuthentication.VTable, self.vtable).Begin_ValidateIdentityCredential(@ptrCast(*const AsyncIIdentityAuthentication, self), CredBuffer, CredBufferLength, ppIdentityProperties);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIIdentityAuthentication_Finish_ValidateIdentityCredential(self: *const T, ppIdentityProperties: ?*?*IPropertyStore) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIIdentityAuthentication.VTable, self.vtable).Finish_ValidateIdentityCredential(@ptrCast(*const AsyncIIdentityAuthentication, self), ppIdentityProperties);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const CLSID_CoClassIdentityStore_Value = Guid.initString("30d49246-d217-465f-b00b-ac9ddd652eb7");
pub const CLSID_CoClassIdentityStore = &CLSID_CoClassIdentityStore_Value;

const CLSID_CIdentityProfileHandler_Value = Guid.initString("ecf5bf46-e3b6-449a-b56b-43f58f867814");
pub const CLSID_CIdentityProfileHandler = &CLSID_CIdentityProfileHandler_Value;

// TODO: this type is limited to platform 'windows6.1'
const IID_IIdentityStore_Value = Guid.initString("df586fa5-6f35-44f1-b209-b38e169772eb");
pub const IID_IIdentityStore = &IID_IIdentityStore_Value;
pub const IIdentityStore = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIdentityStore,
                pdwProviders: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIdentityStore,
                pdwProviders: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAt: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIdentityStore,
                dwProvider: u32,
                pProvGuid: ?*Guid,
                ppIdentityProvider: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIdentityStore,
                dwProvider: u32,
                pProvGuid: ?*Guid,
                ppIdentityProvider: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddToCache: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIdentityStore,
                lpszUniqueID: ?[*:0]const u16,
                ProviderGUID: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIdentityStore,
                lpszUniqueID: ?[*:0]const u16,
                ProviderGUID: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ConvertToSid: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIdentityStore,
                lpszUniqueID: ?[*:0]const u16,
                ProviderGUID: ?*const Guid,
                cbSid: u16,
                pSid: ?[*:0]u8,
                pcbRequiredSid: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIdentityStore,
                lpszUniqueID: ?[*:0]const u16,
                ProviderGUID: ?*const Guid,
                cbSid: u16,
                pSid: ?[*:0]u8,
                pcbRequiredSid: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumerateIdentities: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIdentityStore,
                eIdentityType: IDENTITY_TYPE,
                pFilterkey: ?*const PROPERTYKEY,
                pFilterPropVarValue: ?*const PROPVARIANT,
                ppIdentityEnum: ?*?*IEnumUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIdentityStore,
                eIdentityType: IDENTITY_TYPE,
                pFilterkey: ?*const PROPERTYKEY,
                pFilterPropVarValue: ?*const PROPVARIANT,
                ppIdentityEnum: ?*?*IEnumUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIdentityStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIdentityStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIdentityStore_GetCount(self: *const T, pdwProviders: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIdentityStore.VTable, self.vtable).GetCount(@ptrCast(*const IIdentityStore, self), pdwProviders);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIdentityStore_GetAt(self: *const T, dwProvider: u32, pProvGuid: ?*Guid, ppIdentityProvider: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIdentityStore.VTable, self.vtable).GetAt(@ptrCast(*const IIdentityStore, self), dwProvider, pProvGuid, ppIdentityProvider);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIdentityStore_AddToCache(self: *const T, lpszUniqueID: ?[*:0]const u16, ProviderGUID: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIdentityStore.VTable, self.vtable).AddToCache(@ptrCast(*const IIdentityStore, self), lpszUniqueID, ProviderGUID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIdentityStore_ConvertToSid(self: *const T, lpszUniqueID: ?[*:0]const u16, ProviderGUID: ?*const Guid, cbSid: u16, pSid: ?[*:0]u8, pcbRequiredSid: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIdentityStore.VTable, self.vtable).ConvertToSid(@ptrCast(*const IIdentityStore, self), lpszUniqueID, ProviderGUID, cbSid, pSid, pcbRequiredSid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIdentityStore_EnumerateIdentities(self: *const T, eIdentityType: IDENTITY_TYPE, pFilterkey: ?*const PROPERTYKEY, pFilterPropVarValue: ?*const PROPVARIANT, ppIdentityEnum: ?*?*IEnumUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIdentityStore.VTable, self.vtable).EnumerateIdentities(@ptrCast(*const IIdentityStore, self), eIdentityType, pFilterkey, pFilterPropVarValue, ppIdentityEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIdentityStore_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIdentityStore.VTable, self.vtable).Reset(@ptrCast(*const IIdentityStore, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_AsyncIIdentityStore_Value = Guid.initString("eefa1616-48de-4872-aa64-6e6206535a51");
pub const IID_AsyncIIdentityStore = &IID_AsyncIIdentityStore_Value;
pub const AsyncIIdentityStore = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Begin_GetCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const AsyncIIdentityStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const AsyncIIdentityStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Finish_GetCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const AsyncIIdentityStore,
                pdwProviders: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const AsyncIIdentityStore,
                pdwProviders: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Begin_GetAt: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const AsyncIIdentityStore,
                dwProvider: u32,
                pProvGuid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const AsyncIIdentityStore,
                dwProvider: u32,
                pProvGuid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Finish_GetAt: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const AsyncIIdentityStore,
                pProvGuid: ?*Guid,
                ppIdentityProvider: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const AsyncIIdentityStore,
                pProvGuid: ?*Guid,
                ppIdentityProvider: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Begin_AddToCache: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const AsyncIIdentityStore,
                lpszUniqueID: ?[*:0]const u16,
                ProviderGUID: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const AsyncIIdentityStore,
                lpszUniqueID: ?[*:0]const u16,
                ProviderGUID: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Finish_AddToCache: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const AsyncIIdentityStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const AsyncIIdentityStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Begin_ConvertToSid: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const AsyncIIdentityStore,
                lpszUniqueID: ?[*:0]const u16,
                ProviderGUID: ?*const Guid,
                cbSid: u16,
                pSid: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const AsyncIIdentityStore,
                lpszUniqueID: ?[*:0]const u16,
                ProviderGUID: ?*const Guid,
                cbSid: u16,
                pSid: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Finish_ConvertToSid: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const AsyncIIdentityStore,
                pSid: ?*u8,
                pcbRequiredSid: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const AsyncIIdentityStore,
                pSid: ?*u8,
                pcbRequiredSid: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Begin_EnumerateIdentities: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const AsyncIIdentityStore,
                eIdentityType: IDENTITY_TYPE,
                pFilterkey: ?*const PROPERTYKEY,
                pFilterPropVarValue: ?*const PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const AsyncIIdentityStore,
                eIdentityType: IDENTITY_TYPE,
                pFilterkey: ?*const PROPERTYKEY,
                pFilterPropVarValue: ?*const PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Finish_EnumerateIdentities: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const AsyncIIdentityStore,
                ppIdentityEnum: ?*?*IEnumUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const AsyncIIdentityStore,
                ppIdentityEnum: ?*?*IEnumUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Begin_Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const AsyncIIdentityStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const AsyncIIdentityStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Finish_Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const AsyncIIdentityStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const AsyncIIdentityStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIIdentityStore_Begin_GetCount(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIIdentityStore.VTable, self.vtable).Begin_GetCount(@ptrCast(*const AsyncIIdentityStore, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIIdentityStore_Finish_GetCount(self: *const T, pdwProviders: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIIdentityStore.VTable, self.vtable).Finish_GetCount(@ptrCast(*const AsyncIIdentityStore, self), pdwProviders);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIIdentityStore_Begin_GetAt(self: *const T, dwProvider: u32, pProvGuid: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIIdentityStore.VTable, self.vtable).Begin_GetAt(@ptrCast(*const AsyncIIdentityStore, self), dwProvider, pProvGuid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIIdentityStore_Finish_GetAt(self: *const T, pProvGuid: ?*Guid, ppIdentityProvider: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIIdentityStore.VTable, self.vtable).Finish_GetAt(@ptrCast(*const AsyncIIdentityStore, self), pProvGuid, ppIdentityProvider);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIIdentityStore_Begin_AddToCache(self: *const T, lpszUniqueID: ?[*:0]const u16, ProviderGUID: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIIdentityStore.VTable, self.vtable).Begin_AddToCache(@ptrCast(*const AsyncIIdentityStore, self), lpszUniqueID, ProviderGUID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIIdentityStore_Finish_AddToCache(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIIdentityStore.VTable, self.vtable).Finish_AddToCache(@ptrCast(*const AsyncIIdentityStore, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIIdentityStore_Begin_ConvertToSid(self: *const T, lpszUniqueID: ?[*:0]const u16, ProviderGUID: ?*const Guid, cbSid: u16, pSid: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIIdentityStore.VTable, self.vtable).Begin_ConvertToSid(@ptrCast(*const AsyncIIdentityStore, self), lpszUniqueID, ProviderGUID, cbSid, pSid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIIdentityStore_Finish_ConvertToSid(self: *const T, pSid: ?*u8, pcbRequiredSid: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIIdentityStore.VTable, self.vtable).Finish_ConvertToSid(@ptrCast(*const AsyncIIdentityStore, self), pSid, pcbRequiredSid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIIdentityStore_Begin_EnumerateIdentities(self: *const T, eIdentityType: IDENTITY_TYPE, pFilterkey: ?*const PROPERTYKEY, pFilterPropVarValue: ?*const PROPVARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIIdentityStore.VTable, self.vtable).Begin_EnumerateIdentities(@ptrCast(*const AsyncIIdentityStore, self), eIdentityType, pFilterkey, pFilterPropVarValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIIdentityStore_Finish_EnumerateIdentities(self: *const T, ppIdentityEnum: ?*?*IEnumUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIIdentityStore.VTable, self.vtable).Finish_EnumerateIdentities(@ptrCast(*const AsyncIIdentityStore, self), ppIdentityEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIIdentityStore_Begin_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIIdentityStore.VTable, self.vtable).Begin_Reset(@ptrCast(*const AsyncIIdentityStore, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIIdentityStore_Finish_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIIdentityStore.VTable, self.vtable).Finish_Reset(@ptrCast(*const AsyncIIdentityStore, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IIdentityStoreEx_Value = Guid.initString("f9f9eb98-8f7f-4e38-9577-6980114ce32b");
pub const IID_IIdentityStoreEx = &IID_IIdentityStoreEx_Value;
pub const IIdentityStoreEx = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateConnectedIdentity: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIdentityStoreEx,
                LocalName: ?[*:0]const u16,
                ConnectedName: ?[*:0]const u16,
                ProviderGUID: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIdentityStoreEx,
                LocalName: ?[*:0]const u16,
                ConnectedName: ?[*:0]const u16,
                ProviderGUID: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeleteConnectedIdentity: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIdentityStoreEx,
                ConnectedName: ?[*:0]const u16,
                ProviderGUID: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIdentityStoreEx,
                ConnectedName: ?[*:0]const u16,
                ProviderGUID: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIdentityStoreEx_CreateConnectedIdentity(self: *const T, LocalName: ?[*:0]const u16, ConnectedName: ?[*:0]const u16, ProviderGUID: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIdentityStoreEx.VTable, self.vtable).CreateConnectedIdentity(@ptrCast(*const IIdentityStoreEx, self), LocalName, ConnectedName, ProviderGUID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIdentityStoreEx_DeleteConnectedIdentity(self: *const T, ConnectedName: ?[*:0]const u16, ProviderGUID: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIdentityStoreEx.VTable, self.vtable).DeleteConnectedIdentity(@ptrCast(*const IIdentityStoreEx, self), ConnectedName, ProviderGUID);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_AsyncIIdentityStoreEx_Value = Guid.initString("fca3af9a-8a07-4eae-8632-ec3de658a36a");
pub const IID_AsyncIIdentityStoreEx = &IID_AsyncIIdentityStoreEx_Value;
pub const AsyncIIdentityStoreEx = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Begin_CreateConnectedIdentity: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const AsyncIIdentityStoreEx,
                LocalName: ?[*:0]const u16,
                ConnectedName: ?[*:0]const u16,
                ProviderGUID: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const AsyncIIdentityStoreEx,
                LocalName: ?[*:0]const u16,
                ConnectedName: ?[*:0]const u16,
                ProviderGUID: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Finish_CreateConnectedIdentity: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const AsyncIIdentityStoreEx,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const AsyncIIdentityStoreEx,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Begin_DeleteConnectedIdentity: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const AsyncIIdentityStoreEx,
                ConnectedName: ?[*:0]const u16,
                ProviderGUID: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const AsyncIIdentityStoreEx,
                ConnectedName: ?[*:0]const u16,
                ProviderGUID: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Finish_DeleteConnectedIdentity: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const AsyncIIdentityStoreEx,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const AsyncIIdentityStoreEx,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIIdentityStoreEx_Begin_CreateConnectedIdentity(self: *const T, LocalName: ?[*:0]const u16, ConnectedName: ?[*:0]const u16, ProviderGUID: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIIdentityStoreEx.VTable, self.vtable).Begin_CreateConnectedIdentity(@ptrCast(*const AsyncIIdentityStoreEx, self), LocalName, ConnectedName, ProviderGUID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIIdentityStoreEx_Finish_CreateConnectedIdentity(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIIdentityStoreEx.VTable, self.vtable).Finish_CreateConnectedIdentity(@ptrCast(*const AsyncIIdentityStoreEx, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIIdentityStoreEx_Begin_DeleteConnectedIdentity(self: *const T, ConnectedName: ?[*:0]const u16, ProviderGUID: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIIdentityStoreEx.VTable, self.vtable).Begin_DeleteConnectedIdentity(@ptrCast(*const AsyncIIdentityStoreEx, self), ConnectedName, ProviderGUID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIIdentityStoreEx_Finish_DeleteConnectedIdentity(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIIdentityStoreEx.VTable, self.vtable).Finish_DeleteConnectedIdentity(@ptrCast(*const AsyncIIdentityStoreEx, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};


//--------------------------------------------------------------------------------
// Section: Functions (0)
//--------------------------------------------------------------------------------

//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../../../zig.zig").unicode_mode) {
    .ansi => struct {
    },
    .wide => struct {
    },
    .unspecified => if (@import("builtin").is_test) struct {
    } else struct {
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (12)
//--------------------------------------------------------------------------------
const Guid = @import("../../../zig.zig").Guid;
const BOOL = @import("../../../foundation.zig").BOOL;
const HRESULT = @import("../../../foundation.zig").HRESULT;
const HWND = @import("../../../foundation.zig").HWND;
const IBindCtx = @import("../../../system/com.zig").IBindCtx;
const IEnumUnknown = @import("../../../system/com.zig").IEnumUnknown;
const IPropertyStore = @import("../../../ui/shell/properties_system.zig").IPropertyStore;
const IUnknown = @import("../../../system/com.zig").IUnknown;
const PROPERTYKEY = @import("../../../ui/shell/properties_system.zig").PROPERTYKEY;
const PROPVARIANT = @import("../../../system/com/structured_storage.zig").PROPVARIANT;
const PWSTR = @import("../../../foundation.zig").PWSTR;
const VARIANT = @import("../../../system/com.zig").VARIANT;

test {
    @setEvalBranchQuota(
        comptime @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        if (decl.is_pub) {
            _ = @field(@This(), decl.name);
        }
    }
}
