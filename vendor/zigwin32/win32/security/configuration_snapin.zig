//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (24)
//--------------------------------------------------------------------------------
pub const cNodetypeSceTemplateServices = Guid.initString("24a7f717-1f0c-11d1-affb-00c04fb984f9");
pub const cNodetypeSceAnalysisServices = Guid.initString("678050c7-1ff8-11d1-affb-00c04fb984f9");
pub const cNodetypeSceEventLog = Guid.initString("2ce06698-4bf3-11d1-8c30-00c04fb984f9");
pub const SCESTATUS_SUCCESS = @as(i32, 0);
pub const SCESTATUS_INVALID_PARAMETER = @as(i32, 1);
pub const SCESTATUS_RECORD_NOT_FOUND = @as(i32, 2);
pub const SCESTATUS_INVALID_DATA = @as(i32, 3);
pub const SCESTATUS_OBJECT_EXIST = @as(i32, 4);
pub const SCESTATUS_BUFFER_TOO_SMALL = @as(i32, 5);
pub const SCESTATUS_PROFILE_NOT_FOUND = @as(i32, 6);
pub const SCESTATUS_BAD_FORMAT = @as(i32, 7);
pub const SCESTATUS_NOT_ENOUGH_RESOURCE = @as(i32, 8);
pub const SCESTATUS_ACCESS_DENIED = @as(i32, 9);
pub const SCESTATUS_CANT_DELETE = @as(i32, 10);
pub const SCESTATUS_PREFIX_OVERFLOW = @as(i32, 11);
pub const SCESTATUS_OTHER_ERROR = @as(i32, 12);
pub const SCESTATUS_ALREADY_RUNNING = @as(i32, 13);
pub const SCESTATUS_SERVICE_NOT_SUPPORT = @as(i32, 14);
pub const SCESTATUS_MOD_NOT_FOUND = @as(i32, 15);
pub const SCESTATUS_EXCEPTION_IN_SERVER = @as(i32, 16);
pub const SCESTATUS_NO_TEMPLATE_GIVEN = @as(i32, 17);
pub const SCESTATUS_NO_MAPPING = @as(i32, 18);
pub const SCESTATUS_TRUST_FAIL = @as(i32, 19);
pub const SCESVC_ENUMERATION_MAX = @as(i32, 100);

//--------------------------------------------------------------------------------
// Section: Types (15)
//--------------------------------------------------------------------------------
pub const SCE_LOG_ERR_LEVEL = enum(u32) {
    ALWAYS = 0,
    ERROR = 1,
    DETAIL = 2,
    DEBUG = 3,
};
pub const SCE_LOG_LEVEL_ALWAYS = SCE_LOG_ERR_LEVEL.ALWAYS;
pub const SCE_LOG_LEVEL_ERROR = SCE_LOG_ERR_LEVEL.ERROR;
pub const SCE_LOG_LEVEL_DETAIL = SCE_LOG_ERR_LEVEL.DETAIL;
pub const SCE_LOG_LEVEL_DEBUG = SCE_LOG_ERR_LEVEL.DEBUG;

pub const SCESVC_CONFIGURATION_LINE = extern struct {
    Key: ?*i8,
    Value: ?*i8,
    ValueLen: u32,
};

pub const SCESVC_CONFIGURATION_INFO = extern struct {
    Count: u32,
    Lines: ?*SCESVC_CONFIGURATION_LINE,
};

pub const SCESVC_INFO_TYPE = enum(i32) {
    ConfigurationInfo = 0,
    MergedPolicyInfo = 1,
    AnalysisInfo = 2,
    InternalUse = 3,
};
pub const SceSvcConfigurationInfo = SCESVC_INFO_TYPE.ConfigurationInfo;
pub const SceSvcMergedPolicyInfo = SCESVC_INFO_TYPE.MergedPolicyInfo;
pub const SceSvcAnalysisInfo = SCESVC_INFO_TYPE.AnalysisInfo;
pub const SceSvcInternalUse = SCESVC_INFO_TYPE.InternalUse;

pub const SCESVC_ANALYSIS_LINE = extern struct {
    Key: ?*i8,
    Value: ?*u8,
    ValueLen: u32,
};

pub const SCESVC_ANALYSIS_INFO = extern struct {
    Count: u32,
    Lines: ?*SCESVC_ANALYSIS_LINE,
};

pub const PFSCE_QUERY_INFO = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        sceHandle: ?*anyopaque,
        sceType: SCESVC_INFO_TYPE,
        lpPrefix: ?*i8,
        bExact: BOOL,
        ppvInfo: ?*?*anyopaque,
        psceEnumHandle: ?*u32,
    ) callconv(@import("std").os.windows.WINAPI) u32,
    else => *const fn(
        sceHandle: ?*anyopaque,
        sceType: SCESVC_INFO_TYPE,
        lpPrefix: ?*i8,
        bExact: BOOL,
        ppvInfo: ?*?*anyopaque,
        psceEnumHandle: ?*u32,
    ) callconv(@import("std").os.windows.WINAPI) u32,
} ;

pub const PFSCE_SET_INFO = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        sceHandle: ?*anyopaque,
        sceType: SCESVC_INFO_TYPE,
        lpPrefix: ?*i8,
        bExact: BOOL,
        pvInfo: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) u32,
    else => *const fn(
        sceHandle: ?*anyopaque,
        sceType: SCESVC_INFO_TYPE,
        lpPrefix: ?*i8,
        bExact: BOOL,
        pvInfo: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) u32,
} ;

pub const PFSCE_FREE_INFO = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        pvServiceInfo: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) u32,
    else => *const fn(
        pvServiceInfo: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) u32,
} ;

pub const PFSCE_LOG_INFO = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        ErrLevel: SCE_LOG_ERR_LEVEL,
        Win32rc: u32,
        pErrFmt: ?*i8,
    ) callconv(@import("std").os.windows.WINAPI) u32,
    else => *const fn(
        ErrLevel: SCE_LOG_ERR_LEVEL,
        Win32rc: u32,
        pErrFmt: ?*i8,
    ) callconv(@import("std").os.windows.WINAPI) u32,
} ;

pub const SCESVC_CALLBACK_INFO = extern struct {
    sceHandle: ?*anyopaque,
    pfQueryInfo: ?PFSCE_QUERY_INFO,
    pfSetInfo: ?PFSCE_SET_INFO,
    pfFreeInfo: ?PFSCE_FREE_INFO,
    pfLogInfo: ?PFSCE_LOG_INFO,
};

pub const PF_ConfigAnalyzeService = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        pSceCbInfo: ?*SCESVC_CALLBACK_INFO,
    ) callconv(@import("std").os.windows.WINAPI) u32,
    else => *const fn(
        pSceCbInfo: ?*SCESVC_CALLBACK_INFO,
    ) callconv(@import("std").os.windows.WINAPI) u32,
} ;

pub const PF_UpdateService = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        pSceCbInfo: ?*SCESVC_CALLBACK_INFO,
        ServiceInfo: ?*SCESVC_CONFIGURATION_INFO,
    ) callconv(@import("std").os.windows.WINAPI) u32,
    else => *const fn(
        pSceCbInfo: ?*SCESVC_CALLBACK_INFO,
        ServiceInfo: ?*SCESVC_CONFIGURATION_INFO,
    ) callconv(@import("std").os.windows.WINAPI) u32,
} ;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ISceSvcAttachmentPersistInfo_Value = Guid.initString("6d90e0d0-200d-11d1-affb-00c04fb984f9");
pub const IID_ISceSvcAttachmentPersistInfo = &IID_ISceSvcAttachmentPersistInfo_Value;
pub const ISceSvcAttachmentPersistInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Save: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISceSvcAttachmentPersistInfo,
                lpTemplateName: ?*i8,
                scesvcHandle: ?*?*anyopaque,
                ppvData: ?*?*anyopaque,
                pbOverwriteAll: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISceSvcAttachmentPersistInfo,
                lpTemplateName: ?*i8,
                scesvcHandle: ?*?*anyopaque,
                ppvData: ?*?*anyopaque,
                pbOverwriteAll: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsDirty: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISceSvcAttachmentPersistInfo,
                lpTemplateName: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISceSvcAttachmentPersistInfo,
                lpTemplateName: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FreeBuffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISceSvcAttachmentPersistInfo,
                pvData: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISceSvcAttachmentPersistInfo,
                pvData: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISceSvcAttachmentPersistInfo_Save(self: *const T, lpTemplateName: ?*i8, scesvcHandle: ?*?*anyopaque, ppvData: ?*?*anyopaque, pbOverwriteAll: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISceSvcAttachmentPersistInfo.VTable, self.vtable).Save(@ptrCast(*const ISceSvcAttachmentPersistInfo, self), lpTemplateName, scesvcHandle, ppvData, pbOverwriteAll);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISceSvcAttachmentPersistInfo_IsDirty(self: *const T, lpTemplateName: ?*i8) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISceSvcAttachmentPersistInfo.VTable, self.vtable).IsDirty(@ptrCast(*const ISceSvcAttachmentPersistInfo, self), lpTemplateName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISceSvcAttachmentPersistInfo_FreeBuffer(self: *const T, pvData: ?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISceSvcAttachmentPersistInfo.VTable, self.vtable).FreeBuffer(@ptrCast(*const ISceSvcAttachmentPersistInfo, self), pvData);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ISceSvcAttachmentData_Value = Guid.initString("17c35fde-200d-11d1-affb-00c04fb984f9");
pub const IID_ISceSvcAttachmentData = &IID_ISceSvcAttachmentData_Value;
pub const ISceSvcAttachmentData = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISceSvcAttachmentData,
                scesvcHandle: ?*anyopaque,
                sceType: SCESVC_INFO_TYPE,
                ppvData: ?*?*anyopaque,
                psceEnumHandle: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISceSvcAttachmentData,
                scesvcHandle: ?*anyopaque,
                sceType: SCESVC_INFO_TYPE,
                ppvData: ?*?*anyopaque,
                psceEnumHandle: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISceSvcAttachmentData,
                lpServiceName: ?*i8,
                lpTemplateName: ?*i8,
                lpSceSvcPersistInfo: ?*ISceSvcAttachmentPersistInfo,
                pscesvcHandle: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISceSvcAttachmentData,
                lpServiceName: ?*i8,
                lpTemplateName: ?*i8,
                lpSceSvcPersistInfo: ?*ISceSvcAttachmentPersistInfo,
                pscesvcHandle: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FreeBuffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISceSvcAttachmentData,
                pvData: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISceSvcAttachmentData,
                pvData: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CloseHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISceSvcAttachmentData,
                scesvcHandle: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISceSvcAttachmentData,
                scesvcHandle: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISceSvcAttachmentData_GetData(self: *const T, scesvcHandle: ?*anyopaque, sceType: SCESVC_INFO_TYPE, ppvData: ?*?*anyopaque, psceEnumHandle: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISceSvcAttachmentData.VTable, self.vtable).GetData(@ptrCast(*const ISceSvcAttachmentData, self), scesvcHandle, sceType, ppvData, psceEnumHandle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISceSvcAttachmentData_Initialize(self: *const T, lpServiceName: ?*i8, lpTemplateName: ?*i8, lpSceSvcPersistInfo: ?*ISceSvcAttachmentPersistInfo, pscesvcHandle: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISceSvcAttachmentData.VTable, self.vtable).Initialize(@ptrCast(*const ISceSvcAttachmentData, self), lpServiceName, lpTemplateName, lpSceSvcPersistInfo, pscesvcHandle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISceSvcAttachmentData_FreeBuffer(self: *const T, pvData: ?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISceSvcAttachmentData.VTable, self.vtable).FreeBuffer(@ptrCast(*const ISceSvcAttachmentData, self), pvData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISceSvcAttachmentData_CloseHandle(self: *const T, scesvcHandle: ?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISceSvcAttachmentData.VTable, self.vtable).CloseHandle(@ptrCast(*const ISceSvcAttachmentData, self), scesvcHandle);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};


//--------------------------------------------------------------------------------
// Section: Functions (0)
//--------------------------------------------------------------------------------

//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
    },
    .wide => struct {
    },
    .unspecified => if (@import("builtin").is_test) struct {
    } else struct {
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (4)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const BOOL = @import("../foundation.zig").BOOL;
const HRESULT = @import("../foundation.zig").HRESULT;
const IUnknown = @import("../system/com.zig").IUnknown;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "PFSCE_QUERY_INFO")) { _ = PFSCE_QUERY_INFO; }
    if (@hasDecl(@This(), "PFSCE_SET_INFO")) { _ = PFSCE_SET_INFO; }
    if (@hasDecl(@This(), "PFSCE_FREE_INFO")) { _ = PFSCE_FREE_INFO; }
    if (@hasDecl(@This(), "PFSCE_LOG_INFO")) { _ = PFSCE_LOG_INFO; }
    if (@hasDecl(@This(), "PF_ConfigAnalyzeService")) { _ = PF_ConfigAnalyzeService; }
    if (@hasDecl(@This(), "PF_UpdateService")) { _ = PF_UpdateService; }

    @setEvalBranchQuota(
        comptime @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        if (decl.is_pub) {
            _ = @field(@This(), decl.name);
        }
    }
}
