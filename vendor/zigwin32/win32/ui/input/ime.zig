//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (635)
//--------------------------------------------------------------------------------
pub const CLSID_VERSION_DEPENDENT_MSIME_JAPANESE = Guid.initString("6a91029e-aa49-471b-aee7-7d332785660d");
pub const IFEC_S_ALREADY_DEFAULT = @import("../../zig.zig").typedConst(HRESULT, @as(i32, 291840));
pub const FELANG_REQ_CONV = @as(u32, 65536);
pub const FELANG_REQ_RECONV = @as(u32, 131072);
pub const FELANG_REQ_REV = @as(u32, 196608);
pub const FELANG_CMODE_MONORUBY = @as(u32, 2);
pub const FELANG_CMODE_NOPRUNING = @as(u32, 4);
pub const FELANG_CMODE_KATAKANAOUT = @as(u32, 8);
pub const FELANG_CMODE_HIRAGANAOUT = @as(u32, 0);
pub const FELANG_CMODE_HALFWIDTHOUT = @as(u32, 16);
pub const FELANG_CMODE_FULLWIDTHOUT = @as(u32, 32);
pub const FELANG_CMODE_BOPOMOFO = @as(u32, 64);
pub const FELANG_CMODE_HANGUL = @as(u32, 128);
pub const FELANG_CMODE_PINYIN = @as(u32, 256);
pub const FELANG_CMODE_PRECONV = @as(u32, 512);
pub const FELANG_CMODE_RADICAL = @as(u32, 1024);
pub const FELANG_CMODE_UNKNOWNREADING = @as(u32, 2048);
pub const FELANG_CMODE_MERGECAND = @as(u32, 4096);
pub const FELANG_CMODE_ROMAN = @as(u32, 8192);
pub const FELANG_CMODE_BESTFIRST = @as(u32, 16384);
pub const FELANG_CMODE_USENOREVWORDS = @as(u32, 32768);
pub const FELANG_CMODE_NONE = @as(u32, 16777216);
pub const FELANG_CMODE_PLAURALCLAUSE = @as(u32, 33554432);
pub const FELANG_CMODE_SINGLECONVERT = @as(u32, 67108864);
pub const FELANG_CMODE_AUTOMATIC = @as(u32, 134217728);
pub const FELANG_CMODE_PHRASEPREDICT = @as(u32, 268435456);
pub const FELANG_CMODE_CONVERSATION = @as(u32, 536870912);
pub const FELANG_CMODE_NAME = @as(u32, 268435456);
pub const FELANG_CMODE_NOINVISIBLECHAR = @as(u32, 1073741824);
pub const E_NOCAND = @as(u32, 48);
pub const E_NOTENOUGH_BUFFER = @as(u32, 49);
pub const E_NOTENOUGH_WDD = @as(u32, 50);
pub const E_LARGEINPUT = @as(u32, 51);
pub const FELANG_CLMN_WBREAK = @as(u32, 1);
pub const FELANG_CLMN_NOWBREAK = @as(u32, 2);
pub const FELANG_CLMN_PBREAK = @as(u32, 4);
pub const FELANG_CLMN_NOPBREAK = @as(u32, 8);
pub const FELANG_CLMN_FIXR = @as(u32, 16);
pub const FELANG_CLMN_FIXD = @as(u32, 32);
pub const FELANG_INVALD_PO = @as(u32, 65535);
pub const IFED_POS_NONE = @as(u32, 0);
pub const IFED_POS_NOUN = @as(u32, 1);
pub const IFED_POS_VERB = @as(u32, 2);
pub const IFED_POS_ADJECTIVE = @as(u32, 4);
pub const IFED_POS_ADJECTIVE_VERB = @as(u32, 8);
pub const IFED_POS_ADVERB = @as(u32, 16);
pub const IFED_POS_ADNOUN = @as(u32, 32);
pub const IFED_POS_CONJUNCTION = @as(u32, 64);
pub const IFED_POS_INTERJECTION = @as(u32, 128);
pub const IFED_POS_INDEPENDENT = @as(u32, 255);
pub const IFED_POS_INFLECTIONALSUFFIX = @as(u32, 256);
pub const IFED_POS_PREFIX = @as(u32, 512);
pub const IFED_POS_SUFFIX = @as(u32, 1024);
pub const IFED_POS_AFFIX = @as(u32, 1536);
pub const IFED_POS_TANKANJI = @as(u32, 2048);
pub const IFED_POS_IDIOMS = @as(u32, 4096);
pub const IFED_POS_SYMBOLS = @as(u32, 8192);
pub const IFED_POS_PARTICLE = @as(u32, 16384);
pub const IFED_POS_AUXILIARY_VERB = @as(u32, 32768);
pub const IFED_POS_SUB_VERB = @as(u32, 65536);
pub const IFED_POS_DEPENDENT = @as(u32, 114688);
pub const IFED_POS_ALL = @as(u32, 131071);
pub const IFED_SELECT_NONE = @as(u32, 0);
pub const IFED_SELECT_READING = @as(u32, 1);
pub const IFED_SELECT_DISPLAY = @as(u32, 2);
pub const IFED_SELECT_POS = @as(u32, 4);
pub const IFED_SELECT_COMMENT = @as(u32, 8);
pub const IFED_SELECT_ALL = @as(u32, 15);
pub const IFED_REG_NONE = @as(u32, 0);
pub const IFED_REG_USER = @as(u32, 1);
pub const IFED_REG_AUTO = @as(u32, 2);
pub const IFED_REG_GRAMMAR = @as(u32, 4);
pub const IFED_REG_ALL = @as(u32, 7);
pub const IFED_TYPE_NONE = @as(u32, 0);
pub const IFED_TYPE_GENERAL = @as(u32, 1);
pub const IFED_TYPE_NAMEPLACE = @as(u32, 2);
pub const IFED_TYPE_SPEECH = @as(u32, 4);
pub const IFED_TYPE_REVERSE = @as(u32, 8);
pub const IFED_TYPE_ENGLISH = @as(u32, 16);
pub const IFED_TYPE_ALL = @as(u32, 31);
pub const IFED_S_MORE_ENTRIES = @import("../../zig.zig").typedConst(HRESULT, @as(i32, 291328));
pub const IFED_S_EMPTY_DICTIONARY = @import("../../zig.zig").typedConst(HRESULT, @as(i32, 291329));
pub const IFED_S_WORD_EXISTS = @import("../../zig.zig").typedConst(HRESULT, @as(i32, 291330));
pub const IFED_S_COMMENT_CHANGED = @import("../../zig.zig").typedConst(HRESULT, @as(i32, 291331));
pub const IFED_E_NOT_FOUND = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2147192064));
pub const IFED_E_INVALID_FORMAT = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2147192063));
pub const IFED_E_OPEN_FAILED = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2147192062));
pub const IFED_E_WRITE_FAILED = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2147192061));
pub const IFED_E_NO_ENTRY = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2147192060));
pub const IFED_E_REGISTER_FAILED = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2147192059));
pub const IFED_E_NOT_USER_DIC = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2147192058));
pub const IFED_E_NOT_SUPPORTED = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2147192057));
pub const IFED_E_USER_COMMENT = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2147192056));
pub const IFED_E_REGISTER_ILLEGAL_POS = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2147192055));
pub const IFED_E_REGISTER_IMPROPER_WORD = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2147192054));
pub const IFED_E_REGISTER_DISCONNECTED = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2147192053));
pub const POS_UNDEFINED = @as(u32, 0);
pub const JPOS_UNDEFINED = @as(u32, 0);
pub const JPOS_MEISHI_FUTSU = @as(u32, 100);
pub const JPOS_MEISHI_SAHEN = @as(u32, 101);
pub const JPOS_MEISHI_ZAHEN = @as(u32, 102);
pub const JPOS_MEISHI_KEIYOUDOUSHI = @as(u32, 103);
pub const JPOS_HUKUSIMEISHI = @as(u32, 104);
pub const JPOS_MEISA_KEIDOU = @as(u32, 105);
pub const JPOS_JINMEI = @as(u32, 106);
pub const JPOS_JINMEI_SEI = @as(u32, 107);
pub const JPOS_JINMEI_MEI = @as(u32, 108);
pub const JPOS_CHIMEI = @as(u32, 109);
pub const JPOS_CHIMEI_KUNI = @as(u32, 110);
pub const JPOS_CHIMEI_KEN = @as(u32, 111);
pub const JPOS_CHIMEI_GUN = @as(u32, 112);
pub const JPOS_CHIMEI_KU = @as(u32, 113);
pub const JPOS_CHIMEI_SHI = @as(u32, 114);
pub const JPOS_CHIMEI_MACHI = @as(u32, 115);
pub const JPOS_CHIMEI_MURA = @as(u32, 116);
pub const JPOS_CHIMEI_EKI = @as(u32, 117);
pub const JPOS_SONOTA = @as(u32, 118);
pub const JPOS_SHAMEI = @as(u32, 119);
pub const JPOS_SOSHIKI = @as(u32, 120);
pub const JPOS_KENCHIKU = @as(u32, 121);
pub const JPOS_BUPPIN = @as(u32, 122);
pub const JPOS_DAIMEISHI = @as(u32, 123);
pub const JPOS_DAIMEISHI_NINSHOU = @as(u32, 124);
pub const JPOS_DAIMEISHI_SHIJI = @as(u32, 125);
pub const JPOS_KAZU = @as(u32, 126);
pub const JPOS_KAZU_SURYOU = @as(u32, 127);
pub const JPOS_KAZU_SUSHI = @as(u32, 128);
pub const JPOS_5DAN_AWA = @as(u32, 200);
pub const JPOS_5DAN_KA = @as(u32, 201);
pub const JPOS_5DAN_GA = @as(u32, 202);
pub const JPOS_5DAN_SA = @as(u32, 203);
pub const JPOS_5DAN_TA = @as(u32, 204);
pub const JPOS_5DAN_NA = @as(u32, 205);
pub const JPOS_5DAN_BA = @as(u32, 206);
pub const JPOS_5DAN_MA = @as(u32, 207);
pub const JPOS_5DAN_RA = @as(u32, 208);
pub const JPOS_5DAN_AWAUON = @as(u32, 209);
pub const JPOS_5DAN_KASOKUON = @as(u32, 210);
pub const JPOS_5DAN_RAHEN = @as(u32, 211);
pub const JPOS_4DAN_HA = @as(u32, 212);
pub const JPOS_1DAN = @as(u32, 213);
pub const JPOS_TOKUSHU_KAHEN = @as(u32, 214);
pub const JPOS_TOKUSHU_SAHENSURU = @as(u32, 215);
pub const JPOS_TOKUSHU_SAHEN = @as(u32, 216);
pub const JPOS_TOKUSHU_ZAHEN = @as(u32, 217);
pub const JPOS_TOKUSHU_NAHEN = @as(u32, 218);
pub const JPOS_KURU_KI = @as(u32, 219);
pub const JPOS_KURU_KITA = @as(u32, 220);
pub const JPOS_KURU_KITARA = @as(u32, 221);
pub const JPOS_KURU_KITARI = @as(u32, 222);
pub const JPOS_KURU_KITAROU = @as(u32, 223);
pub const JPOS_KURU_KITE = @as(u32, 224);
pub const JPOS_KURU_KUREBA = @as(u32, 225);
pub const JPOS_KURU_KO = @as(u32, 226);
pub const JPOS_KURU_KOI = @as(u32, 227);
pub const JPOS_KURU_KOYOU = @as(u32, 228);
pub const JPOS_SURU_SA = @as(u32, 229);
pub const JPOS_SURU_SI = @as(u32, 230);
pub const JPOS_SURU_SITA = @as(u32, 231);
pub const JPOS_SURU_SITARA = @as(u32, 232);
pub const JPOS_SURU_SIATRI = @as(u32, 233);
pub const JPOS_SURU_SITAROU = @as(u32, 234);
pub const JPOS_SURU_SITE = @as(u32, 235);
pub const JPOS_SURU_SIYOU = @as(u32, 236);
pub const JPOS_SURU_SUREBA = @as(u32, 237);
pub const JPOS_SURU_SE = @as(u32, 238);
pub const JPOS_SURU_SEYO = @as(u32, 239);
pub const JPOS_KEIYOU = @as(u32, 300);
pub const JPOS_KEIYOU_GARU = @as(u32, 301);
pub const JPOS_KEIYOU_GE = @as(u32, 302);
pub const JPOS_KEIYOU_ME = @as(u32, 303);
pub const JPOS_KEIYOU_YUU = @as(u32, 304);
pub const JPOS_KEIYOU_U = @as(u32, 305);
pub const JPOS_KEIDOU = @as(u32, 400);
pub const JPOS_KEIDOU_NO = @as(u32, 401);
pub const JPOS_KEIDOU_TARU = @as(u32, 402);
pub const JPOS_KEIDOU_GARU = @as(u32, 403);
pub const JPOS_FUKUSHI = @as(u32, 500);
pub const JPOS_FUKUSHI_SAHEN = @as(u32, 501);
pub const JPOS_FUKUSHI_NI = @as(u32, 502);
pub const JPOS_FUKUSHI_NANO = @as(u32, 503);
pub const JPOS_FUKUSHI_DA = @as(u32, 504);
pub const JPOS_FUKUSHI_TO = @as(u32, 505);
pub const JPOS_FUKUSHI_TOSURU = @as(u32, 506);
pub const JPOS_RENTAISHI = @as(u32, 600);
pub const JPOS_RENTAISHI_SHIJI = @as(u32, 601);
pub const JPOS_SETSUZOKUSHI = @as(u32, 650);
pub const JPOS_KANDOUSHI = @as(u32, 670);
pub const JPOS_SETTOU = @as(u32, 700);
pub const JPOS_SETTOU_KAKU = @as(u32, 701);
pub const JPOS_SETTOU_SAI = @as(u32, 702);
pub const JPOS_SETTOU_FUKU = @as(u32, 703);
pub const JPOS_SETTOU_MI = @as(u32, 704);
pub const JPOS_SETTOU_DAISHOU = @as(u32, 705);
pub const JPOS_SETTOU_KOUTEI = @as(u32, 706);
pub const JPOS_SETTOU_CHOUTAN = @as(u32, 707);
pub const JPOS_SETTOU_SHINKYU = @as(u32, 708);
pub const JPOS_SETTOU_JINMEI = @as(u32, 709);
pub const JPOS_SETTOU_CHIMEI = @as(u32, 710);
pub const JPOS_SETTOU_SONOTA = @as(u32, 711);
pub const JPOS_SETTOU_JOSUSHI = @as(u32, 712);
pub const JPOS_SETTOU_TEINEI_O = @as(u32, 713);
pub const JPOS_SETTOU_TEINEI_GO = @as(u32, 714);
pub const JPOS_SETTOU_TEINEI_ON = @as(u32, 715);
pub const JPOS_SETSUBI = @as(u32, 800);
pub const JPOS_SETSUBI_TEKI = @as(u32, 801);
pub const JPOS_SETSUBI_SEI = @as(u32, 802);
pub const JPOS_SETSUBI_KA = @as(u32, 803);
pub const JPOS_SETSUBI_CHU = @as(u32, 804);
pub const JPOS_SETSUBI_FU = @as(u32, 805);
pub const JPOS_SETSUBI_RYU = @as(u32, 806);
pub const JPOS_SETSUBI_YOU = @as(u32, 807);
pub const JPOS_SETSUBI_KATA = @as(u32, 808);
pub const JPOS_SETSUBI_MEISHIRENDAKU = @as(u32, 809);
pub const JPOS_SETSUBI_JINMEI = @as(u32, 810);
pub const JPOS_SETSUBI_CHIMEI = @as(u32, 811);
pub const JPOS_SETSUBI_KUNI = @as(u32, 812);
pub const JPOS_SETSUBI_KEN = @as(u32, 813);
pub const JPOS_SETSUBI_GUN = @as(u32, 814);
pub const JPOS_SETSUBI_KU = @as(u32, 815);
pub const JPOS_SETSUBI_SHI = @as(u32, 816);
pub const JPOS_SETSUBI_MACHI = @as(u32, 817);
pub const JPOS_SETSUBI_CHOU = @as(u32, 818);
pub const JPOS_SETSUBI_MURA = @as(u32, 819);
pub const JPOS_SETSUBI_SON = @as(u32, 820);
pub const JPOS_SETSUBI_EKI = @as(u32, 821);
pub const JPOS_SETSUBI_SONOTA = @as(u32, 822);
pub const JPOS_SETSUBI_SHAMEI = @as(u32, 823);
pub const JPOS_SETSUBI_SOSHIKI = @as(u32, 824);
pub const JPOS_SETSUBI_KENCHIKU = @as(u32, 825);
pub const JPOS_RENYOU_SETSUBI = @as(u32, 826);
pub const JPOS_SETSUBI_JOSUSHI = @as(u32, 827);
pub const JPOS_SETSUBI_JOSUSHIPLUS = @as(u32, 828);
pub const JPOS_SETSUBI_JIKAN = @as(u32, 829);
pub const JPOS_SETSUBI_JIKANPLUS = @as(u32, 830);
pub const JPOS_SETSUBI_TEINEI = @as(u32, 831);
pub const JPOS_SETSUBI_SAN = @as(u32, 832);
pub const JPOS_SETSUBI_KUN = @as(u32, 833);
pub const JPOS_SETSUBI_SAMA = @as(u32, 834);
pub const JPOS_SETSUBI_DONO = @as(u32, 835);
pub const JPOS_SETSUBI_FUKUSU = @as(u32, 836);
pub const JPOS_SETSUBI_TACHI = @as(u32, 837);
pub const JPOS_SETSUBI_RA = @as(u32, 838);
pub const JPOS_TANKANJI = @as(u32, 900);
pub const JPOS_TANKANJI_KAO = @as(u32, 901);
pub const JPOS_KANYOUKU = @as(u32, 902);
pub const JPOS_DOKURITSUGO = @as(u32, 903);
pub const JPOS_FUTEIGO = @as(u32, 904);
pub const JPOS_KIGOU = @as(u32, 905);
pub const JPOS_EIJI = @as(u32, 906);
pub const JPOS_KUTEN = @as(u32, 907);
pub const JPOS_TOUTEN = @as(u32, 908);
pub const JPOS_KANJI = @as(u32, 909);
pub const JPOS_OPENBRACE = @as(u32, 910);
pub const JPOS_CLOSEBRACE = @as(u32, 911);
pub const JPOS_YOKUSEI = @as(u32, 912);
pub const JPOS_TANSHUKU = @as(u32, 913);
pub const VERSION_ID_JAPANESE = @as(u32, 16777216);
pub const VERSION_ID_KOREAN = @as(u32, 33554432);
pub const VERSION_ID_CHINESE_TRADITIONAL = @as(u32, 67108864);
pub const VERSION_ID_CHINESE_SIMPLIFIED = @as(u32, 134217728);
pub const FID_MSIME_VERSION = @as(u32, 0);
pub const VERSION_MOUSE_OPERATION = @as(u32, 1);
pub const IMEMOUSERET_NOTHANDLED = @as(i32, -1);
pub const IMEMOUSE_VERSION = @as(u32, 255);
pub const IMEMOUSE_NONE = @as(u32, 0);
pub const IMEMOUSE_LDOWN = @as(u32, 1);
pub const IMEMOUSE_RDOWN = @as(u32, 2);
pub const IMEMOUSE_MDOWN = @as(u32, 4);
pub const IMEMOUSE_WUP = @as(u32, 16);
pub const IMEMOUSE_WDOWN = @as(u32, 32);
pub const FID_RECONVERT_VERSION = @as(u32, 268435456);
pub const VERSION_RECONVERSION = @as(u32, 1);
pub const VERSION_DOCUMENTFEED = @as(u32, 1);
pub const VERSION_QUERYPOSITION = @as(u32, 1);
pub const VERSION_MODEBIAS = @as(u32, 1);
pub const MODEBIAS_GETVERSION = @as(u32, 0);
pub const MODEBIAS_SETVALUE = @as(u32, 1);
pub const MODEBIAS_GETVALUE = @as(u32, 2);
pub const MODEBIASMODE_DEFAULT = @as(u32, 0);
pub const MODEBIASMODE_FILENAME = @as(u32, 1);
pub const MODEBIASMODE_READING = @as(u32, 2);
pub const MODEBIASMODE_DIGIT = @as(u32, 4);
pub const SHOWIMEPAD_DEFAULT = @as(u32, 0);
pub const SHOWIMEPAD_CATEGORY = @as(u32, 1);
pub const SHOWIMEPAD_GUID = @as(u32, 2);
pub const FID_MSIME_KMS_VERSION = @as(u32, 1);
pub const FID_MSIME_KMS_INIT = @as(u32, 2);
pub const FID_MSIME_KMS_TERM = @as(u32, 3);
pub const FID_MSIME_KMS_DEL_KEYLIST = @as(u32, 4);
pub const FID_MSIME_KMS_NOTIFY = @as(u32, 5);
pub const FID_MSIME_KMS_GETMAP = @as(u32, 6);
pub const FID_MSIME_KMS_INVOKE = @as(u32, 7);
pub const FID_MSIME_KMS_SETMAP = @as(u32, 8);
pub const FID_MSIME_KMS_FUNCDESC = @as(u32, 9);
pub const FID_MSIME_KMS_GETMAPSEAMLESS = @as(u32, 10);
pub const FID_MSIME_KMS_GETMAPFAST = @as(u32, 11);
pub const IMEKMS_NOCOMPOSITION = @as(u32, 0);
pub const IMEKMS_COMPOSITION = @as(u32, 1);
pub const IMEKMS_SELECTION = @as(u32, 2);
pub const IMEKMS_IMEOFF = @as(u32, 3);
pub const IMEKMS_2NDLEVEL = @as(u32, 4);
pub const IMEKMS_INPTGL = @as(u32, 5);
pub const IMEKMS_CANDIDATE = @as(u32, 6);
pub const IMEKMS_TYPECAND = @as(u32, 7);
pub const RECONVOPT_NONE = @as(u32, 0);
pub const RECONVOPT_USECANCELNOTIFY = @as(u32, 1);
pub const GCSEX_CANCELRECONVERT = @as(u32, 268435456);
pub const STYLE_DESCRIPTION_SIZE = @as(u32, 32);
pub const IMEMENUITEM_STRING_SIZE = @as(u32, 80);
pub const IMC_GETCANDIDATEPOS = @as(u32, 7);
pub const IMC_SETCANDIDATEPOS = @as(u32, 8);
pub const IMC_GETCOMPOSITIONFONT = @as(u32, 9);
pub const IMC_SETCOMPOSITIONFONT = @as(u32, 10);
pub const IMC_GETCOMPOSITIONWINDOW = @as(u32, 11);
pub const IMC_SETCOMPOSITIONWINDOW = @as(u32, 12);
pub const IMC_GETSTATUSWINDOWPOS = @as(u32, 15);
pub const IMC_SETSTATUSWINDOWPOS = @as(u32, 16);
pub const IMC_CLOSESTATUSWINDOW = @as(u32, 33);
pub const IMC_OPENSTATUSWINDOW = @as(u32, 34);
pub const NI_FINALIZECONVERSIONRESULT = @as(u32, 20);
pub const ISC_SHOWUICANDIDATEWINDOW = @as(u32, 1);
pub const ISC_SHOWUICOMPOSITIONWINDOW = @as(u32, 2147483648);
pub const ISC_SHOWUIGUIDELINE = @as(u32, 1073741824);
pub const ISC_SHOWUIALLCANDIDATEWINDOW = @as(u32, 15);
pub const ISC_SHOWUIALL = @as(u32, 3221225487);
pub const MOD_LEFT = @as(u32, 32768);
pub const MOD_RIGHT = @as(u32, 16384);
pub const MOD_ON_KEYUP = @as(u32, 2048);
pub const MOD_IGNORE_ALL_MODIFIER = @as(u32, 1024);
pub const IME_CHOTKEY_IME_NONIME_TOGGLE = @as(u32, 16);
pub const IME_CHOTKEY_SHAPE_TOGGLE = @as(u32, 17);
pub const IME_CHOTKEY_SYMBOL_TOGGLE = @as(u32, 18);
pub const IME_JHOTKEY_CLOSE_OPEN = @as(u32, 48);
pub const IME_KHOTKEY_SHAPE_TOGGLE = @as(u32, 80);
pub const IME_KHOTKEY_HANJACONVERT = @as(u32, 81);
pub const IME_KHOTKEY_ENGLISH = @as(u32, 82);
pub const IME_THOTKEY_IME_NONIME_TOGGLE = @as(u32, 112);
pub const IME_THOTKEY_SHAPE_TOGGLE = @as(u32, 113);
pub const IME_THOTKEY_SYMBOL_TOGGLE = @as(u32, 114);
pub const IME_HOTKEY_DSWITCH_FIRST = @as(u32, 256);
pub const IME_HOTKEY_DSWITCH_LAST = @as(u32, 287);
pub const IME_HOTKEY_PRIVATE_FIRST = @as(u32, 512);
pub const IME_ITHOTKEY_RESEND_RESULTSTR = @as(u32, 512);
pub const IME_ITHOTKEY_PREVIOUS_COMPOSITION = @as(u32, 513);
pub const IME_ITHOTKEY_UISTYLE_TOGGLE = @as(u32, 514);
pub const IME_ITHOTKEY_RECONVERTSTRING = @as(u32, 515);
pub const IME_HOTKEY_PRIVATE_LAST = @as(u32, 543);
pub const GCS_COMPREADSTR = @as(u32, 1);
pub const GCS_COMPREADATTR = @as(u32, 2);
pub const GCS_COMPREADCLAUSE = @as(u32, 4);
pub const GCS_COMPSTR = @as(u32, 8);
pub const GCS_COMPATTR = @as(u32, 16);
pub const GCS_COMPCLAUSE = @as(u32, 32);
pub const GCS_CURSORPOS = @as(u32, 128);
pub const GCS_DELTASTART = @as(u32, 256);
pub const GCS_RESULTREADSTR = @as(u32, 512);
pub const GCS_RESULTREADCLAUSE = @as(u32, 1024);
pub const GCS_RESULTSTR = @as(u32, 2048);
pub const GCS_RESULTCLAUSE = @as(u32, 4096);
pub const CS_INSERTCHAR = @as(u32, 8192);
pub const CS_NOMOVECARET = @as(u32, 16384);
pub const IMEVER_0310 = @as(u32, 196618);
pub const IMEVER_0400 = @as(u32, 262144);
pub const IME_PROP_AT_CARET = @as(u32, 65536);
pub const IME_PROP_SPECIAL_UI = @as(u32, 131072);
pub const IME_PROP_CANDLIST_START_FROM_1 = @as(u32, 262144);
pub const IME_PROP_UNICODE = @as(u32, 524288);
pub const IME_PROP_COMPLETE_ON_UNSELECT = @as(u32, 1048576);
pub const UI_CAP_2700 = @as(u32, 1);
pub const UI_CAP_ROT90 = @as(u32, 2);
pub const UI_CAP_ROTANY = @as(u32, 4);
pub const SCS_CAP_COMPSTR = @as(u32, 1);
pub const SCS_CAP_MAKEREAD = @as(u32, 2);
pub const SCS_CAP_SETRECONVERTSTRING = @as(u32, 4);
pub const SELECT_CAP_CONVERSION = @as(u32, 1);
pub const SELECT_CAP_SENTENCE = @as(u32, 2);
pub const GL_LEVEL_NOGUIDELINE = @as(u32, 0);
pub const GL_LEVEL_FATAL = @as(u32, 1);
pub const GL_LEVEL_ERROR = @as(u32, 2);
pub const GL_LEVEL_WARNING = @as(u32, 3);
pub const GL_LEVEL_INFORMATION = @as(u32, 4);
pub const GL_ID_UNKNOWN = @as(u32, 0);
pub const GL_ID_NOMODULE = @as(u32, 1);
pub const GL_ID_NODICTIONARY = @as(u32, 16);
pub const GL_ID_CANNOTSAVE = @as(u32, 17);
pub const GL_ID_NOCONVERT = @as(u32, 32);
pub const GL_ID_TYPINGERROR = @as(u32, 33);
pub const GL_ID_TOOMANYSTROKE = @as(u32, 34);
pub const GL_ID_READINGCONFLICT = @as(u32, 35);
pub const GL_ID_INPUTREADING = @as(u32, 36);
pub const GL_ID_INPUTRADICAL = @as(u32, 37);
pub const GL_ID_INPUTCODE = @as(u32, 38);
pub const GL_ID_INPUTSYMBOL = @as(u32, 39);
pub const GL_ID_CHOOSECANDIDATE = @as(u32, 40);
pub const GL_ID_REVERSECONVERSION = @as(u32, 41);
pub const GL_ID_PRIVATE_FIRST = @as(u32, 32768);
pub const GL_ID_PRIVATE_LAST = @as(u32, 65535);
pub const ATTR_INPUT = @as(u32, 0);
pub const ATTR_TARGET_CONVERTED = @as(u32, 1);
pub const ATTR_CONVERTED = @as(u32, 2);
pub const ATTR_TARGET_NOTCONVERTED = @as(u32, 3);
pub const ATTR_INPUT_ERROR = @as(u32, 4);
pub const ATTR_FIXEDCONVERTED = @as(u32, 5);
pub const CFS_DEFAULT = @as(u32, 0);
pub const CFS_RECT = @as(u32, 1);
pub const CFS_POINT = @as(u32, 2);
pub const CFS_FORCE_POSITION = @as(u32, 32);
pub const CFS_CANDIDATEPOS = @as(u32, 64);
pub const CFS_EXCLUDE = @as(u32, 128);
pub const IME_CMODE_SOFTKBD = @as(u32, 128);
pub const IME_CMODE_NOCONVERSION = @as(u32, 256);
pub const IME_CMODE_EUDC = @as(u32, 512);
pub const IME_CMODE_SYMBOL = @as(u32, 1024);
pub const IME_CMODE_FIXED = @as(u32, 2048);
pub const IME_CMODE_RESERVED = @as(u32, 4026531840);
pub const IME_SMODE_NONE = @as(u32, 0);
pub const IME_SMODE_PLAURALCLAUSE = @as(u32, 1);
pub const IME_SMODE_SINGLECONVERT = @as(u32, 2);
pub const IME_SMODE_AUTOMATIC = @as(u32, 4);
pub const IME_SMODE_PHRASEPREDICT = @as(u32, 8);
pub const IME_SMODE_CONVERSATION = @as(u32, 16);
pub const IME_SMODE_RESERVED = @as(u32, 61440);
pub const IME_CAND_UNKNOWN = @as(u32, 0);
pub const IME_CAND_READ = @as(u32, 1);
pub const IME_CAND_CODE = @as(u32, 2);
pub const IME_CAND_MEANING = @as(u32, 3);
pub const IME_CAND_RADICAL = @as(u32, 4);
pub const IME_CAND_STROKE = @as(u32, 5);
pub const IMN_CLOSESTATUSWINDOW = @as(u32, 1);
pub const IMN_OPENSTATUSWINDOW = @as(u32, 2);
pub const IMN_CHANGECANDIDATE = @as(u32, 3);
pub const IMN_CLOSECANDIDATE = @as(u32, 4);
pub const IMN_OPENCANDIDATE = @as(u32, 5);
pub const IMN_SETCONVERSIONMODE = @as(u32, 6);
pub const IMN_SETSENTENCEMODE = @as(u32, 7);
pub const IMN_SETOPENSTATUS = @as(u32, 8);
pub const IMN_SETCANDIDATEPOS = @as(u32, 9);
pub const IMN_SETCOMPOSITIONFONT = @as(u32, 10);
pub const IMN_SETCOMPOSITIONWINDOW = @as(u32, 11);
pub const IMN_SETSTATUSWINDOWPOS = @as(u32, 12);
pub const IMN_GUIDELINE = @as(u32, 13);
pub const IMN_PRIVATE = @as(u32, 14);
pub const IMR_COMPOSITIONWINDOW = @as(u32, 1);
pub const IMR_CANDIDATEWINDOW = @as(u32, 2);
pub const IMR_COMPOSITIONFONT = @as(u32, 3);
pub const IMR_RECONVERTSTRING = @as(u32, 4);
pub const IMR_CONFIRMRECONVERTSTRING = @as(u32, 5);
pub const IMR_QUERYCHARPOSITION = @as(u32, 6);
pub const IMR_DOCUMENTFEED = @as(u32, 7);
pub const IMM_ERROR_NODATA = @as(i32, -1);
pub const IMM_ERROR_GENERAL = @as(i32, -2);
pub const IME_CONFIG_GENERAL = @as(u32, 1);
pub const IME_CONFIG_REGISTERWORD = @as(u32, 2);
pub const IME_CONFIG_SELECTDICTIONARY = @as(u32, 3);
pub const IME_ESC_QUERY_SUPPORT = @as(u32, 3);
pub const IME_ESC_RESERVED_FIRST = @as(u32, 4);
pub const IME_ESC_RESERVED_LAST = @as(u32, 2047);
pub const IME_ESC_PRIVATE_FIRST = @as(u32, 2048);
pub const IME_ESC_PRIVATE_LAST = @as(u32, 4095);
pub const IME_ESC_SEQUENCE_TO_INTERNAL = @as(u32, 4097);
pub const IME_ESC_GET_EUDC_DICTIONARY = @as(u32, 4099);
pub const IME_ESC_SET_EUDC_DICTIONARY = @as(u32, 4100);
pub const IME_ESC_MAX_KEY = @as(u32, 4101);
pub const IME_ESC_IME_NAME = @as(u32, 4102);
pub const IME_ESC_SYNC_HOTKEY = @as(u32, 4103);
pub const IME_ESC_HANJA_MODE = @as(u32, 4104);
pub const IME_ESC_AUTOMATA = @as(u32, 4105);
pub const IME_ESC_PRIVATE_HOTKEY = @as(u32, 4106);
pub const IME_ESC_GETHELPFILENAME = @as(u32, 4107);
pub const IME_REGWORD_STYLE_EUDC = @as(u32, 1);
pub const IME_REGWORD_STYLE_USER_FIRST = @as(u32, 2147483648);
pub const IME_REGWORD_STYLE_USER_LAST = @as(u32, 4294967295);
pub const IACE_CHILDREN = @as(u32, 1);
pub const IACE_DEFAULT = @as(u32, 16);
pub const IACE_IGNORENOCONTEXT = @as(u32, 32);
pub const IGIMIF_RIGHTMENU = @as(u32, 1);
pub const IGIMII_CMODE = @as(u32, 1);
pub const IGIMII_SMODE = @as(u32, 2);
pub const IGIMII_CONFIGURE = @as(u32, 4);
pub const IGIMII_TOOLS = @as(u32, 8);
pub const IGIMII_HELP = @as(u32, 16);
pub const IGIMII_OTHER = @as(u32, 32);
pub const IGIMII_INPUTTOOLS = @as(u32, 64);
pub const IMFT_RADIOCHECK = @as(u32, 1);
pub const IMFT_SEPARATOR = @as(u32, 2);
pub const IMFT_SUBMENU = @as(u32, 4);
pub const SOFTKEYBOARD_TYPE_T1 = @as(u32, 1);
pub const SOFTKEYBOARD_TYPE_C1 = @as(u32, 2);
pub const IMMGWL_IMC = @as(u32, 0);
pub const IMMGWLP_IMC = @as(u32, 0);
pub const IMC_SETCONVERSIONMODE = @as(u32, 2);
pub const IMC_SETSENTENCEMODE = @as(u32, 4);
pub const IMC_SETOPENSTATUS = @as(u32, 6);
pub const IMC_GETSOFTKBDFONT = @as(u32, 17);
pub const IMC_SETSOFTKBDFONT = @as(u32, 18);
pub const IMC_GETSOFTKBDPOS = @as(u32, 19);
pub const IMC_SETSOFTKBDPOS = @as(u32, 20);
pub const IMC_GETSOFTKBDSUBTYPE = @as(u32, 21);
pub const IMC_SETSOFTKBDSUBTYPE = @as(u32, 22);
pub const IMC_SETSOFTKBDDATA = @as(u32, 24);
pub const NI_CONTEXTUPDATED = @as(u32, 3);
pub const IME_SYSINFO_WINLOGON = @as(u32, 1);
pub const IME_SYSINFO_WOW16 = @as(u32, 2);
pub const INIT_STATUSWNDPOS = @as(u32, 1);
pub const INIT_CONVERSION = @as(u32, 2);
pub const INIT_SENTENCE = @as(u32, 4);
pub const INIT_LOGFONT = @as(u32, 8);
pub const INIT_COMPFORM = @as(u32, 16);
pub const INIT_SOFTKBDPOS = @as(u32, 32);
pub const IME_PROP_END_UNLOAD = @as(u32, 1);
pub const IME_PROP_KBD_CHAR_FIRST = @as(u32, 2);
pub const IME_PROP_IGNORE_UPKEYS = @as(u32, 4);
pub const IME_PROP_NEED_ALTKEY = @as(u32, 8);
pub const IME_PROP_NO_KEYS_ON_CLOSE = @as(u32, 16);
pub const IME_PROP_ACCEPT_WIDE_VKEY = @as(u32, 32);
pub const UI_CAP_SOFTKBD = @as(u32, 65536);
pub const IMN_SOFTKBDDESTROYED = @as(u32, 17);
pub const IME_UI_CLASS_NAME_SIZE = @as(u32, 16);
pub const IME_ESC_STRING_BUFFER_SIZE = @as(u32, 80);
pub const CATID_MSIME_IImePadApplet_VER7 = Guid.initString("4a0f8e31-c3ee-11d1-afef-00805f0c8b6d");
pub const CATID_MSIME_IImePadApplet_VER80 = Guid.initString("56f7a792-fef1-11d3-8463-00c04f7a06e5");
pub const CATID_MSIME_IImePadApplet_VER81 = Guid.initString("656520b0-bb88-11d4-84c0-00c04f7a06e5");
pub const CATID_MSIME_IImePadApplet900 = Guid.initString("faae51bf-5e5b-4a1d-8de1-17c1d9e1728d");
pub const CATID_MSIME_IImePadApplet1000 = Guid.initString("e081e1d6-2389-43cb-b66f-609f823d9f9c");
pub const CATID_MSIME_IImePadApplet1200 = Guid.initString("a47fb5fc-7d15-4223-a789-b781bf9ae667");
pub const CATID_MSIME_IImePadApplet = Guid.initString("7566cad1-4ec9-4478-9fe9-8ed766619edf");
pub const FEID_NONE = @as(u32, 0);
pub const FEID_CHINESE_TRADITIONAL = @as(u32, 1);
pub const FEID_CHINESE_SIMPLIFIED = @as(u32, 2);
pub const FEID_CHINESE_HONGKONG = @as(u32, 3);
pub const FEID_CHINESE_SINGAPORE = @as(u32, 4);
pub const FEID_JAPANESE = @as(u32, 5);
pub const FEID_KOREAN = @as(u32, 6);
pub const FEID_KOREAN_JOHAB = @as(u32, 7);
pub const INFOMASK_NONE = @as(u32, 0);
pub const INFOMASK_QUERY_CAND = @as(u32, 1);
pub const INFOMASK_APPLY_CAND = @as(u32, 2);
pub const INFOMASK_APPLY_CAND_EX = @as(u32, 4);
pub const INFOMASK_STRING_FIX = @as(u32, 65536);
pub const INFOMASK_HIDE_CAND = @as(u32, 131072);
pub const INFOMASK_BLOCK_CAND = @as(u32, 262144);
pub const IMEFAREASTINFO_TYPE_DEFAULT = @as(u32, 0);
pub const IMEFAREASTINFO_TYPE_READING = @as(u32, 1);
pub const IMEFAREASTINFO_TYPE_COMMENT = @as(u32, 2);
pub const IMEFAREASTINFO_TYPE_COSTTIME = @as(u32, 3);
pub const CHARINFO_APPLETID_MASK = @as(u32, 4278190080);
pub const CHARINFO_FEID_MASK = @as(u32, 15728640);
pub const CHARINFO_CHARID_MASK = @as(u32, 65535);
pub const MAX_APPLETTITLE = @as(u32, 64);
pub const MAX_FONTFACE = @as(u32, 32);
pub const IPACFG_NONE = @as(i32, 0);
pub const IPACFG_PROPERTY = @as(i32, 1);
pub const IPACFG_HELP = @as(i32, 2);
pub const IPACFG_TITLE = @as(i32, 65536);
pub const IPACFG_TITLEFONTFACE = @as(i32, 131072);
pub const IPACFG_CATEGORY = @as(i32, 262144);
pub const IPACFG_LANG = @as(i32, 16);
pub const IPACID_NONE = @as(u32, 0);
pub const IPACID_SOFTKEY = @as(u32, 1);
pub const IPACID_HANDWRITING = @as(u32, 2);
pub const IPACID_STROKESEARCH = @as(u32, 3);
pub const IPACID_RADICALSEARCH = @as(u32, 4);
pub const IPACID_SYMBOLSEARCH = @as(u32, 5);
pub const IPACID_VOICE = @as(u32, 6);
pub const IPACID_EPWING = @as(u32, 7);
pub const IPACID_OCR = @as(u32, 8);
pub const IPACID_CHARLIST = @as(u32, 9);
pub const IPACID_USER = @as(u32, 256);
pub const IMEPADREQ_FIRST = @as(u32, 4096);
pub const IMEPADREQ_INSERTSTRINGCANDIDATE = @as(u32, 4098);
pub const IMEPADREQ_INSERTITEMCANDIDATE = @as(u32, 4099);
pub const IMEPADREQ_SENDKEYCONTROL = @as(u32, 4101);
pub const IMEPADREQ_GETSELECTEDSTRING = @as(u32, 4103);
pub const IMEPADREQ_SETAPPLETDATA = @as(u32, 4105);
pub const IMEPADREQ_GETAPPLETDATA = @as(u32, 4106);
pub const IMEPADREQ_SETTITLEFONT = @as(u32, 4107);
pub const IMEPADREQ_GETCOMPOSITIONSTRINGID = @as(u32, 4109);
pub const IMEPADREQ_INSERTSTRINGCANDIDATEINFO = @as(u32, 4110);
pub const IMEPADREQ_CHANGESTRINGCANDIDATEINFO = @as(u32, 4111);
pub const IMEPADREQ_INSERTSTRINGINFO = @as(u32, 4114);
pub const IMEPADREQ_CHANGESTRINGINFO = @as(u32, 4115);
pub const IMEPADREQ_GETCURRENTUILANGID = @as(u32, 4120);
pub const IMEPADCTRL_CONVERTALL = @as(u32, 1);
pub const IMEPADCTRL_DETERMINALL = @as(u32, 2);
pub const IMEPADCTRL_DETERMINCHAR = @as(u32, 3);
pub const IMEPADCTRL_CLEARALL = @as(u32, 4);
pub const IMEPADCTRL_CARETSET = @as(u32, 5);
pub const IMEPADCTRL_CARETLEFT = @as(u32, 6);
pub const IMEPADCTRL_CARETRIGHT = @as(u32, 7);
pub const IMEPADCTRL_CARETTOP = @as(u32, 8);
pub const IMEPADCTRL_CARETBOTTOM = @as(u32, 9);
pub const IMEPADCTRL_CARETBACKSPACE = @as(u32, 10);
pub const IMEPADCTRL_CARETDELETE = @as(u32, 11);
pub const IMEPADCTRL_PHRASEDELETE = @as(u32, 12);
pub const IMEPADCTRL_INSERTSPACE = @as(u32, 13);
pub const IMEPADCTRL_INSERTFULLSPACE = @as(u32, 14);
pub const IMEPADCTRL_INSERTHALFSPACE = @as(u32, 15);
pub const IMEPADCTRL_ONIME = @as(u32, 16);
pub const IMEPADCTRL_OFFIME = @as(u32, 17);
pub const IMEPADCTRL_ONPRECONVERSION = @as(u32, 18);
pub const IMEPADCTRL_OFFPRECONVERSION = @as(u32, 19);
pub const IMEPADCTRL_PHONETICCANDIDATE = @as(u32, 20);
pub const IMEKEYCTRLMASK_ALT = @as(u32, 1);
pub const IMEKEYCTRLMASK_CTRL = @as(u32, 2);
pub const IMEKEYCTRLMASK_SHIFT = @as(u32, 4);
pub const IMEKEYCTRL_UP = @as(u32, 1);
pub const IMEKEYCTRL_DOWN = @as(u32, 0);
pub const IMEPN_FIRST = @as(u32, 256);
pub const IMEPN_ACTIVATE = @as(u32, 257);
pub const IMEPN_INACTIVATE = @as(u32, 258);
pub const IMEPN_SHOW = @as(u32, 260);
pub const IMEPN_HIDE = @as(u32, 261);
pub const IMEPN_SIZECHANGING = @as(u32, 262);
pub const IMEPN_SIZECHANGED = @as(u32, 263);
pub const IMEPN_CONFIG = @as(u32, 264);
pub const IMEPN_HELP = @as(u32, 265);
pub const IMEPN_QUERYCAND = @as(u32, 266);
pub const IMEPN_APPLYCAND = @as(u32, 267);
pub const IMEPN_APPLYCANDEX = @as(u32, 268);
pub const IMEPN_SETTINGCHANGED = @as(u32, 269);
pub const IMEPN_USER = @as(u32, 356);
pub const IPAWS_ENABLED = @as(i32, 1);
pub const IPAWS_SIZINGNOTIFY = @as(i32, 4);
pub const IPAWS_VERTICALFIXED = @as(i32, 256);
pub const IPAWS_HORIZONTALFIXED = @as(i32, 512);
pub const IPAWS_SIZEFIXED = @as(i32, 768);
pub const IPAWS_MAXWIDTHFIXED = @as(i32, 4096);
pub const IPAWS_MAXHEIGHTFIXED = @as(i32, 8192);
pub const IPAWS_MAXSIZEFIXED = @as(i32, 12288);
pub const IPAWS_MINWIDTHFIXED = @as(i32, 65536);
pub const IPAWS_MINHEIGHTFIXED = @as(i32, 131072);
pub const IPAWS_MINSIZEFIXED = @as(i32, 196608);
pub const CLSID_ImePlugInDictDictionaryList_CHS = Guid.initString("7bf0129b-5bef-4de4-9b0b-5edb66ac2fa6");
pub const CLSID_ImePlugInDictDictionaryList_JPN = Guid.initString("4fe2776b-b0f9-4396-b5fc-e9d4cf1ec195");

//--------------------------------------------------------------------------------
// Section: Types (80)
//--------------------------------------------------------------------------------
pub const SET_COMPOSITION_STRING_TYPE = enum(u32) {
    SETSTR = 9,
    CHANGEATTR = 18,
    CHANGECLAUSE = 36,
    SETRECONVERTSTRING = 65536,
    QUERYRECONVERTSTRING = 131072,
};
pub const SCS_SETSTR = SET_COMPOSITION_STRING_TYPE.SETSTR;
pub const SCS_CHANGEATTR = SET_COMPOSITION_STRING_TYPE.CHANGEATTR;
pub const SCS_CHANGECLAUSE = SET_COMPOSITION_STRING_TYPE.CHANGECLAUSE;
pub const SCS_SETRECONVERTSTRING = SET_COMPOSITION_STRING_TYPE.SETRECONVERTSTRING;
pub const SCS_QUERYRECONVERTSTRING = SET_COMPOSITION_STRING_TYPE.QUERYRECONVERTSTRING;

pub const GET_GUIDE_LINE_TYPE = enum(u32) {
    LEVEL = 1,
    INDEX = 2,
    STRING = 3,
    PRIVATE = 4,
};
pub const GGL_LEVEL = GET_GUIDE_LINE_TYPE.LEVEL;
pub const GGL_INDEX = GET_GUIDE_LINE_TYPE.INDEX;
pub const GGL_STRING = GET_GUIDE_LINE_TYPE.STRING;
pub const GGL_PRIVATE = GET_GUIDE_LINE_TYPE.PRIVATE;

pub const NOTIFY_IME_INDEX = enum(u32) {
    CANCEL = 4,
    COMPLETE = 1,
    CONVERT = 2,
    REVERT = 3,
};
pub const CPS_CANCEL = NOTIFY_IME_INDEX.CANCEL;
pub const CPS_COMPLETE = NOTIFY_IME_INDEX.COMPLETE;
pub const CPS_CONVERT = NOTIFY_IME_INDEX.CONVERT;
pub const CPS_REVERT = NOTIFY_IME_INDEX.REVERT;

pub const NOTIFY_IME_ACTION = enum(u32) {
    CHANGECANDIDATELIST = 19,
    CLOSECANDIDATE = 17,
    COMPOSITIONSTR = 21,
    IMEMENUSELECTED = 24,
    OPENCANDIDATE = 16,
    SELECTCANDIDATESTR = 18,
    SETCANDIDATE_PAGESIZE = 23,
    SETCANDIDATE_PAGESTART = 22,
};
pub const NI_CHANGECANDIDATELIST = NOTIFY_IME_ACTION.CHANGECANDIDATELIST;
pub const NI_CLOSECANDIDATE = NOTIFY_IME_ACTION.CLOSECANDIDATE;
pub const NI_COMPOSITIONSTR = NOTIFY_IME_ACTION.COMPOSITIONSTR;
pub const NI_IMEMENUSELECTED = NOTIFY_IME_ACTION.IMEMENUSELECTED;
pub const NI_OPENCANDIDATE = NOTIFY_IME_ACTION.OPENCANDIDATE;
pub const NI_SELECTCANDIDATESTR = NOTIFY_IME_ACTION.SELECTCANDIDATESTR;
pub const NI_SETCANDIDATE_PAGESIZE = NOTIFY_IME_ACTION.SETCANDIDATE_PAGESIZE;
pub const NI_SETCANDIDATE_PAGESTART = NOTIFY_IME_ACTION.SETCANDIDATE_PAGESTART;

pub const GET_CONVERSION_LIST_FLAG = enum(u32) {
    CONVERSION = 1,
    REVERSECONVERSION = 2,
    REVERSE_LENGTH = 3,
};
pub const GCL_CONVERSION = GET_CONVERSION_LIST_FLAG.CONVERSION;
pub const GCL_REVERSECONVERSION = GET_CONVERSION_LIST_FLAG.REVERSECONVERSION;
pub const GCL_REVERSE_LENGTH = GET_CONVERSION_LIST_FLAG.REVERSE_LENGTH;

pub const IME_PAD_REQUEST_FLAGS = enum(u32) {
    INSERTSTRING = 4097,
    SENDCONTROL = 4100,
    SETAPPLETSIZE = 4104,
    GETCOMPOSITIONSTRING = 4102,
    GETCOMPOSITIONSTRINGINFO = 4108,
    DELETESTRING = 4112,
    CHANGESTRING = 4113,
    GETAPPLHWND = 4116,
    FORCEIMEPADWINDOWSHOW = 4117,
    POSTMODALNOTIFY = 4118,
    GETDEFAULTUILANGID = 4119,
    GETAPPLETUISTYLE = 4121,
    SETAPPLETUISTYLE = 4122,
    ISAPPLETACTIVE = 4123,
    ISIMEPADWINDOWVISIBLE = 4124,
    SETAPPLETMINMAXSIZE = 4125,
    GETCONVERSIONSTATUS = 4126,
    GETVERSION = 4127,
    GETCURRENTIMEINFO = 4128,
};
pub const IMEPADREQ_INSERTSTRING = IME_PAD_REQUEST_FLAGS.INSERTSTRING;
pub const IMEPADREQ_SENDCONTROL = IME_PAD_REQUEST_FLAGS.SENDCONTROL;
pub const IMEPADREQ_SETAPPLETSIZE = IME_PAD_REQUEST_FLAGS.SETAPPLETSIZE;
pub const IMEPADREQ_GETCOMPOSITIONSTRING = IME_PAD_REQUEST_FLAGS.GETCOMPOSITIONSTRING;
pub const IMEPADREQ_GETCOMPOSITIONSTRINGINFO = IME_PAD_REQUEST_FLAGS.GETCOMPOSITIONSTRINGINFO;
pub const IMEPADREQ_DELETESTRING = IME_PAD_REQUEST_FLAGS.DELETESTRING;
pub const IMEPADREQ_CHANGESTRING = IME_PAD_REQUEST_FLAGS.CHANGESTRING;
pub const IMEPADREQ_GETAPPLHWND = IME_PAD_REQUEST_FLAGS.GETAPPLHWND;
pub const IMEPADREQ_FORCEIMEPADWINDOWSHOW = IME_PAD_REQUEST_FLAGS.FORCEIMEPADWINDOWSHOW;
pub const IMEPADREQ_POSTMODALNOTIFY = IME_PAD_REQUEST_FLAGS.POSTMODALNOTIFY;
pub const IMEPADREQ_GETDEFAULTUILANGID = IME_PAD_REQUEST_FLAGS.GETDEFAULTUILANGID;
pub const IMEPADREQ_GETAPPLETUISTYLE = IME_PAD_REQUEST_FLAGS.GETAPPLETUISTYLE;
pub const IMEPADREQ_SETAPPLETUISTYLE = IME_PAD_REQUEST_FLAGS.SETAPPLETUISTYLE;
pub const IMEPADREQ_ISAPPLETACTIVE = IME_PAD_REQUEST_FLAGS.ISAPPLETACTIVE;
pub const IMEPADREQ_ISIMEPADWINDOWVISIBLE = IME_PAD_REQUEST_FLAGS.ISIMEPADWINDOWVISIBLE;
pub const IMEPADREQ_SETAPPLETMINMAXSIZE = IME_PAD_REQUEST_FLAGS.SETAPPLETMINMAXSIZE;
pub const IMEPADREQ_GETCONVERSIONSTATUS = IME_PAD_REQUEST_FLAGS.GETCONVERSIONSTATUS;
pub const IMEPADREQ_GETVERSION = IME_PAD_REQUEST_FLAGS.GETVERSION;
pub const IMEPADREQ_GETCURRENTIMEINFO = IME_PAD_REQUEST_FLAGS.GETCURRENTIMEINFO;

pub const COMPOSITIONFORM = extern struct {
    dwStyle: u32,
    ptCurrentPos: POINT,
    rcArea: RECT,
};

pub const CANDIDATEFORM = extern struct {
    dwIndex: u32,
    dwStyle: u32,
    ptCurrentPos: POINT,
    rcArea: RECT,
};

pub const CANDIDATELIST = extern struct {
    dwSize: u32,
    dwStyle: u32,
    dwCount: u32,
    dwSelection: u32,
    dwPageStart: u32,
    dwPageSize: u32,
    dwOffset: [1]u32,
};

pub const REGISTERWORDA = extern struct {
    lpReading: ?PSTR,
    lpWord: ?PSTR,
};

pub const REGISTERWORDW = extern struct {
    lpReading: ?PWSTR,
    lpWord: ?PWSTR,
};

pub const RECONVERTSTRING = extern struct {
    dwSize: u32,
    dwVersion: u32,
    dwStrLen: u32,
    dwStrOffset: u32,
    dwCompStrLen: u32,
    dwCompStrOffset: u32,
    dwTargetStrLen: u32,
    dwTargetStrOffset: u32,
};

pub const STYLEBUFA = extern struct {
    dwStyle: u32,
    szDescription: [32]CHAR,
};

pub const STYLEBUFW = extern struct {
    dwStyle: u32,
    szDescription: [32]u16,
};

pub const IMEMENUITEMINFOA = extern struct {
    cbSize: u32,
    fType: u32,
    fState: u32,
    wID: u32,
    hbmpChecked: ?HBITMAP,
    hbmpUnchecked: ?HBITMAP,
    dwItemData: u32,
    szString: [80]CHAR,
    hbmpItem: ?HBITMAP,
};

pub const IMEMENUITEMINFOW = extern struct {
    cbSize: u32,
    fType: u32,
    fState: u32,
    wID: u32,
    hbmpChecked: ?HBITMAP,
    hbmpUnchecked: ?HBITMAP,
    dwItemData: u32,
    szString: [80]u16,
    hbmpItem: ?HBITMAP,
};

pub const IMECHARPOSITION = extern struct {
    dwSize: u32,
    dwCharPos: u32,
    pt: POINT,
    cLineHeight: u32,
    rcDocument: RECT,
};

pub const IMCENUMPROC = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        param0: ?HIMC,
        param1: LPARAM,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn (
        param0: ?HIMC,
        param1: LPARAM,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
};

pub const REGISTERWORDENUMPROCA = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        lpszReading: ?[*:0]const u8,
        param1: u32,
        lpszString: ?[*:0]const u8,
        param3: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) i32,
    else => *const fn (
        lpszReading: ?[*:0]const u8,
        param1: u32,
        lpszString: ?[*:0]const u8,
        param3: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) i32,
};

pub const REGISTERWORDENUMPROCW = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        lpszReading: ?[*:0]const u16,
        param1: u32,
        lpszString: ?[*:0]const u16,
        param3: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) i32,
    else => *const fn (
        lpszReading: ?[*:0]const u16,
        param1: u32,
        lpszString: ?[*:0]const u16,
        param3: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) i32,
};

pub const IFEClassFactory = extern struct {
    pub const VTable = extern struct {
        base: IClassFactory.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IClassFactory.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const IMEDLG = extern struct {
    cbIMEDLG: i32 align(1),
    hwnd: ?HWND align(1),
    lpwstrWord: ?PWSTR align(1),
    nTabId: i32 align(1),
};

const IID_IFECommon_Value = Guid.initString("019f7151-e6db-11d0-83c3-00c04fddb82e");
pub const IID_IFECommon = &IID_IFECommon_Value;
pub const IFECommon = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IsDefaultIME: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFECommon,
                szName: [*:0]const u8,
                cszName: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFECommon,
                szName: [*:0]const u8,
                cszName: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDefaultIME: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFECommon,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFECommon,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InvokeWordRegDialog: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFECommon,
                pimedlg: ?*IMEDLG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFECommon,
                pimedlg: ?*IMEDLG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InvokeDictToolDialog: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFECommon,
                pimedlg: ?*IMEDLG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFECommon,
                pimedlg: ?*IMEDLG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFECommon_IsDefaultIME(self: *const T, szName: [*:0]const u8, cszName: i32) HRESULT {
                return @as(*const IFECommon.VTable, @ptrCast(self.vtable)).IsDefaultIME(@as(*const IFECommon, @ptrCast(self)), szName, cszName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFECommon_SetDefaultIME(self: *const T) HRESULT {
                return @as(*const IFECommon.VTable, @ptrCast(self.vtable)).SetDefaultIME(@as(*const IFECommon, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFECommon_InvokeWordRegDialog(self: *const T, pimedlg: ?*IMEDLG) HRESULT {
                return @as(*const IFECommon.VTable, @ptrCast(self.vtable)).InvokeWordRegDialog(@as(*const IFECommon, @ptrCast(self)), pimedlg);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFECommon_InvokeDictToolDialog(self: *const T, pimedlg: ?*IMEDLG) HRESULT {
                return @as(*const IFECommon.VTable, @ptrCast(self.vtable)).InvokeDictToolDialog(@as(*const IFECommon, @ptrCast(self)), pimedlg);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const WDD = extern struct {
    wDispPos: u16 align(1),
    Anonymous1: extern union {
        wReadPos: u16 align(1),
        wCompPos: u16 align(1),
    } align(1),
    cchDisp: u16 align(1),
    Anonymous2: extern union {
        cchRead: u16 align(1),
        cchComp: u16 align(1),
    } align(1),
    WDD_nReserve1: u32 align(1),
    nPos: u16 align(1),
    _bitfield: u16 align(1),
    pReserved: ?*anyopaque align(1),
};

pub const MORRSLT = extern struct {
    dwSize: u32 align(1),
    pwchOutput: ?PWSTR align(1),
    cchOutput: u16 align(1),
    Anonymous1: extern union {
        pwchRead: ?PWSTR align(1),
        pwchComp: ?PWSTR align(1),
    } align(1),
    Anonymous2: extern union {
        cchRead: u16 align(1),
        cchComp: u16 align(1),
    } align(1),
    pchInputPos: ?*u16 align(1),
    pchOutputIdxWDD: ?*u16 align(1),
    Anonymous3: extern union {
        pchReadIdxWDD: ?*u16 align(1),
        pchCompIdxWDD: ?*u16 align(1),
    } align(1),
    paMonoRubyPos: ?*u16 align(1),
    pWDD: ?*WDD align(1),
    cWDD: i32 align(1),
    pPrivate: ?*anyopaque align(1),
    BLKBuff: [1]u16 align(1),
};

const IID_IFELanguage_Value = Guid.initString("019f7152-e6db-11d0-83c3-00c04fddb82e");
pub const IID_IFELanguage = &IID_IFELanguage_Value;
pub const IFELanguage = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Open: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFELanguage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFELanguage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Close: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFELanguage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFELanguage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetJMorphResult: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFELanguage,
                dwRequest: u32,
                dwCMode: u32,
                cwchInput: i32,
                pwchInput: ?[*:0]const u16,
                pfCInfo: ?*u32,
                ppResult: ?*?*MORRSLT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFELanguage,
                dwRequest: u32,
                dwCMode: u32,
                cwchInput: i32,
                pwchInput: ?[*:0]const u16,
                pfCInfo: ?*u32,
                ppResult: ?*?*MORRSLT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetConversionModeCaps: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFELanguage,
                pdwCaps: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFELanguage,
                pdwCaps: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPhonetic: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFELanguage,
                string: ?BSTR,
                start: i32,
                length: i32,
                phonetic: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFELanguage,
                string: ?BSTR,
                start: i32,
                length: i32,
                phonetic: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetConversion: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFELanguage,
                string: ?BSTR,
                start: i32,
                length: i32,
                result: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFELanguage,
                string: ?BSTR,
                start: i32,
                length: i32,
                result: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFELanguage_Open(self: *const T) HRESULT {
                return @as(*const IFELanguage.VTable, @ptrCast(self.vtable)).Open(@as(*const IFELanguage, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFELanguage_Close(self: *const T) HRESULT {
                return @as(*const IFELanguage.VTable, @ptrCast(self.vtable)).Close(@as(*const IFELanguage, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFELanguage_GetJMorphResult(self: *const T, dwRequest: u32, dwCMode: u32, cwchInput: i32, pwchInput: ?[*:0]const u16, pfCInfo: ?*u32, ppResult: ?*?*MORRSLT) HRESULT {
                return @as(*const IFELanguage.VTable, @ptrCast(self.vtable)).GetJMorphResult(@as(*const IFELanguage, @ptrCast(self)), dwRequest, dwCMode, cwchInput, pwchInput, pfCInfo, ppResult);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFELanguage_GetConversionModeCaps(self: *const T, pdwCaps: ?*u32) HRESULT {
                return @as(*const IFELanguage.VTable, @ptrCast(self.vtable)).GetConversionModeCaps(@as(*const IFELanguage, @ptrCast(self)), pdwCaps);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFELanguage_GetPhonetic(self: *const T, string: ?BSTR, start: i32, length: i32, phonetic: ?*?BSTR) HRESULT {
                return @as(*const IFELanguage.VTable, @ptrCast(self.vtable)).GetPhonetic(@as(*const IFELanguage, @ptrCast(self)), string, start, length, phonetic);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFELanguage_GetConversion(self: *const T, string: ?BSTR, start: i32, length: i32, result: ?*?BSTR) HRESULT {
                return @as(*const IFELanguage.VTable, @ptrCast(self.vtable)).GetConversion(@as(*const IFELanguage, @ptrCast(self)), string, start, length, result);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const IMEREG = enum(i32) {
    HEAD = 0,
    TAIL = 1,
    DEL = 2,
};
pub const IFED_REG_HEAD = IMEREG.HEAD;
pub const IFED_REG_TAIL = IMEREG.TAIL;
pub const IFED_REG_DEL = IMEREG.DEL;

pub const IMEFMT = enum(i32) {
    UNKNOWN = 0,
    MSIME2_BIN_SYSTEM = 1,
    MSIME2_BIN_USER = 2,
    MSIME2_TEXT_USER = 3,
    MSIME95_BIN_SYSTEM = 4,
    MSIME95_BIN_USER = 5,
    MSIME95_TEXT_USER = 6,
    MSIME97_BIN_SYSTEM = 7,
    MSIME97_BIN_USER = 8,
    MSIME97_TEXT_USER = 9,
    MSIME98_BIN_SYSTEM = 10,
    MSIME98_BIN_USER = 11,
    MSIME98_TEXT_USER = 12,
    ACTIVE_DICT = 13,
    ATOK9 = 14,
    ATOK10 = 15,
    NEC_AI_ = 16,
    WX_II = 17,
    WX_III = 18,
    VJE_20 = 19,
    MSIME98_SYSTEM_CE = 20,
    MSIME_BIN_SYSTEM = 21,
    MSIME_BIN_USER = 22,
    MSIME_TEXT_USER = 23,
    PIME2_BIN_USER = 24,
    PIME2_BIN_SYSTEM = 25,
    PIME2_BIN_STANDARD_SYSTEM = 26,
};
pub const IFED_UNKNOWN = IMEFMT.UNKNOWN;
pub const IFED_MSIME2_BIN_SYSTEM = IMEFMT.MSIME2_BIN_SYSTEM;
pub const IFED_MSIME2_BIN_USER = IMEFMT.MSIME2_BIN_USER;
pub const IFED_MSIME2_TEXT_USER = IMEFMT.MSIME2_TEXT_USER;
pub const IFED_MSIME95_BIN_SYSTEM = IMEFMT.MSIME95_BIN_SYSTEM;
pub const IFED_MSIME95_BIN_USER = IMEFMT.MSIME95_BIN_USER;
pub const IFED_MSIME95_TEXT_USER = IMEFMT.MSIME95_TEXT_USER;
pub const IFED_MSIME97_BIN_SYSTEM = IMEFMT.MSIME97_BIN_SYSTEM;
pub const IFED_MSIME97_BIN_USER = IMEFMT.MSIME97_BIN_USER;
pub const IFED_MSIME97_TEXT_USER = IMEFMT.MSIME97_TEXT_USER;
pub const IFED_MSIME98_BIN_SYSTEM = IMEFMT.MSIME98_BIN_SYSTEM;
pub const IFED_MSIME98_BIN_USER = IMEFMT.MSIME98_BIN_USER;
pub const IFED_MSIME98_TEXT_USER = IMEFMT.MSIME98_TEXT_USER;
pub const IFED_ACTIVE_DICT = IMEFMT.ACTIVE_DICT;
pub const IFED_ATOK9 = IMEFMT.ATOK9;
pub const IFED_ATOK10 = IMEFMT.ATOK10;
pub const IFED_NEC_AI_ = IMEFMT.NEC_AI_;
pub const IFED_WX_II = IMEFMT.WX_II;
pub const IFED_WX_III = IMEFMT.WX_III;
pub const IFED_VJE_20 = IMEFMT.VJE_20;
pub const IFED_MSIME98_SYSTEM_CE = IMEFMT.MSIME98_SYSTEM_CE;
pub const IFED_MSIME_BIN_SYSTEM = IMEFMT.MSIME_BIN_SYSTEM;
pub const IFED_MSIME_BIN_USER = IMEFMT.MSIME_BIN_USER;
pub const IFED_MSIME_TEXT_USER = IMEFMT.MSIME_TEXT_USER;
pub const IFED_PIME2_BIN_USER = IMEFMT.PIME2_BIN_USER;
pub const IFED_PIME2_BIN_SYSTEM = IMEFMT.PIME2_BIN_SYSTEM;
pub const IFED_PIME2_BIN_STANDARD_SYSTEM = IMEFMT.PIME2_BIN_STANDARD_SYSTEM;

pub const IMEUCT = enum(i32) {
    NONE = 0,
    STRING_SJIS = 1,
    STRING_UNICODE = 2,
    USER_DEFINED = 3,
    MAX = 4,
};
pub const IFED_UCT_NONE = IMEUCT.NONE;
pub const IFED_UCT_STRING_SJIS = IMEUCT.STRING_SJIS;
pub const IFED_UCT_STRING_UNICODE = IMEUCT.STRING_UNICODE;
pub const IFED_UCT_USER_DEFINED = IMEUCT.USER_DEFINED;
pub const IFED_UCT_MAX = IMEUCT.MAX;

pub const IMEWRD = extern struct {
    pwchReading: ?PWSTR align(1),
    pwchDisplay: ?PWSTR align(1),
    Anonymous: extern union {
        ulPos: u32 align(1),
        Anonymous: extern struct {
            nPos1: u16 align(1),
            nPos2: u16 align(1),
        } align(1),
    } align(1),
    rgulAttrs: [2]u32 align(1),
    cbComment: i32 align(1),
    uct: IMEUCT align(1),
    pvComment: ?*anyopaque align(1),
};

pub const IMESHF = extern struct {
    cbShf: u16 align(1),
    verDic: u16 align(1),
    szTitle: [48]CHAR align(1),
    szDescription: [256]CHAR align(1),
    szCopyright: [128]CHAR align(1),
};

pub const POSTBL = extern struct {
    nPos: u16 align(1),
    szName: ?*u8 align(1),
};

pub const IMEREL = enum(i32) {
    NONE = 0,
    NO = 1,
    GA = 2,
    WO = 3,
    NI = 4,
    DE = 5,
    YORI = 6,
    KARA = 7,
    MADE = 8,
    HE = 9,
    TO = 10,
    IDEOM = 11,
    FUKU_YOUGEN = 12,
    KEIYOU_YOUGEN = 13,
    KEIDOU1_YOUGEN = 14,
    KEIDOU2_YOUGEN = 15,
    TAIGEN = 16,
    YOUGEN = 17,
    RENTAI_MEI = 18,
    RENSOU = 19,
    KEIYOU_TO_YOUGEN = 20,
    KEIYOU_TARU_YOUGEN = 21,
    UNKNOWN1 = 22,
    UNKNOWN2 = 23,
    ALL = 24,
};
pub const IFED_REL_NONE = IMEREL.NONE;
pub const IFED_REL_NO = IMEREL.NO;
pub const IFED_REL_GA = IMEREL.GA;
pub const IFED_REL_WO = IMEREL.WO;
pub const IFED_REL_NI = IMEREL.NI;
pub const IFED_REL_DE = IMEREL.DE;
pub const IFED_REL_YORI = IMEREL.YORI;
pub const IFED_REL_KARA = IMEREL.KARA;
pub const IFED_REL_MADE = IMEREL.MADE;
pub const IFED_REL_HE = IMEREL.HE;
pub const IFED_REL_TO = IMEREL.TO;
pub const IFED_REL_IDEOM = IMEREL.IDEOM;
pub const IFED_REL_FUKU_YOUGEN = IMEREL.FUKU_YOUGEN;
pub const IFED_REL_KEIYOU_YOUGEN = IMEREL.KEIYOU_YOUGEN;
pub const IFED_REL_KEIDOU1_YOUGEN = IMEREL.KEIDOU1_YOUGEN;
pub const IFED_REL_KEIDOU2_YOUGEN = IMEREL.KEIDOU2_YOUGEN;
pub const IFED_REL_TAIGEN = IMEREL.TAIGEN;
pub const IFED_REL_YOUGEN = IMEREL.YOUGEN;
pub const IFED_REL_RENTAI_MEI = IMEREL.RENTAI_MEI;
pub const IFED_REL_RENSOU = IMEREL.RENSOU;
pub const IFED_REL_KEIYOU_TO_YOUGEN = IMEREL.KEIYOU_TO_YOUGEN;
pub const IFED_REL_KEIYOU_TARU_YOUGEN = IMEREL.KEIYOU_TARU_YOUGEN;
pub const IFED_REL_UNKNOWN1 = IMEREL.UNKNOWN1;
pub const IFED_REL_UNKNOWN2 = IMEREL.UNKNOWN2;
pub const IFED_REL_ALL = IMEREL.ALL;

pub const IMEDP = extern struct {
    wrdModifier: IMEWRD align(1),
    wrdModifiee: IMEWRD align(1),
    relID: IMEREL align(1),
};

pub const PFNLOG = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        param0: ?*IMEDP,
        param1: HRESULT,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn (
        param0: ?*IMEDP,
        param1: HRESULT,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
};

const IID_IFEDictionary_Value = Guid.initString("019f7153-e6db-11d0-83c3-00c04fddb82e");
pub const IID_IFEDictionary = &IID_IFEDictionary_Value;
pub const IFEDictionary = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Open: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFEDictionary,
                pchDictPath: ?*[260]u8,
                pshf: ?*IMESHF,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFEDictionary,
                pchDictPath: ?*[260]u8,
                pshf: ?*IMESHF,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Close: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFEDictionary,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFEDictionary,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetHeader: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFEDictionary,
                pchDictPath: ?*[260]u8,
                pshf: ?*IMESHF,
                pjfmt: ?*IMEFMT,
                pulType: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFEDictionary,
                pchDictPath: ?*[260]u8,
                pshf: ?*IMESHF,
                pjfmt: ?*IMEFMT,
                pulType: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DisplayProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFEDictionary,
                hwnd: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFEDictionary,
                hwnd: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPosTable: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFEDictionary,
                prgPosTbl: ?*?*POSTBL,
                pcPosTbl: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFEDictionary,
                prgPosTbl: ?*?*POSTBL,
                pcPosTbl: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetWords: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFEDictionary,
                pwchFirst: ?[*:0]const u16,
                pwchLast: ?[*:0]const u16,
                pwchDisplay: ?[*:0]const u16,
                ulPos: u32,
                ulSelect: u32,
                ulWordSrc: u32,
                pchBuffer: ?*u8,
                cbBuffer: u32,
                pcWrd: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFEDictionary,
                pwchFirst: ?[*:0]const u16,
                pwchLast: ?[*:0]const u16,
                pwchDisplay: ?[*:0]const u16,
                ulPos: u32,
                ulSelect: u32,
                ulWordSrc: u32,
                pchBuffer: ?*u8,
                cbBuffer: u32,
                pcWrd: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NextWords: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFEDictionary,
                pchBuffer: ?*u8,
                cbBuffer: u32,
                pcWrd: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFEDictionary,
                pchBuffer: ?*u8,
                cbBuffer: u32,
                pcWrd: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Create: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFEDictionary,
                pchDictPath: ?[*:0]const u8,
                pshf: ?*IMESHF,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFEDictionary,
                pchDictPath: ?[*:0]const u8,
                pshf: ?*IMESHF,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetHeader: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFEDictionary,
                pshf: ?*IMESHF,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFEDictionary,
                pshf: ?*IMESHF,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExistWord: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFEDictionary,
                pwrd: ?*IMEWRD,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFEDictionary,
                pwrd: ?*IMEWRD,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExistDependency: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFEDictionary,
                pdp: ?*IMEDP,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFEDictionary,
                pdp: ?*IMEDP,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RegisterWord: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFEDictionary,
                reg: IMEREG,
                pwrd: ?*IMEWRD,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFEDictionary,
                reg: IMEREG,
                pwrd: ?*IMEWRD,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RegisterDependency: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFEDictionary,
                reg: IMEREG,
                pdp: ?*IMEDP,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFEDictionary,
                reg: IMEREG,
                pdp: ?*IMEDP,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDependencies: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFEDictionary,
                pwchKakariReading: ?[*:0]const u16,
                pwchKakariDisplay: ?[*:0]const u16,
                ulKakariPos: u32,
                pwchUkeReading: ?[*:0]const u16,
                pwchUkeDisplay: ?[*:0]const u16,
                ulUkePos: u32,
                jrel: IMEREL,
                ulWordSrc: u32,
                pchBuffer: ?*u8,
                cbBuffer: u32,
                pcdp: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFEDictionary,
                pwchKakariReading: ?[*:0]const u16,
                pwchKakariDisplay: ?[*:0]const u16,
                ulKakariPos: u32,
                pwchUkeReading: ?[*:0]const u16,
                pwchUkeDisplay: ?[*:0]const u16,
                ulUkePos: u32,
                jrel: IMEREL,
                ulWordSrc: u32,
                pchBuffer: ?*u8,
                cbBuffer: u32,
                pcdp: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NextDependencies: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFEDictionary,
                pchBuffer: ?*u8,
                cbBuffer: u32,
                pcDp: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFEDictionary,
                pchBuffer: ?*u8,
                cbBuffer: u32,
                pcDp: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ConvertFromOldMSIME: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFEDictionary,
                pchDic: ?[*:0]const u8,
                pfnLog: ?PFNLOG,
                reg: IMEREG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFEDictionary,
                pchDic: ?[*:0]const u8,
                pfnLog: ?PFNLOG,
                reg: IMEREG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ConvertFromUserToSys: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFEDictionary,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFEDictionary,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFEDictionary_Open(self: *const T, pchDictPath: ?*[260]u8, pshf: ?*IMESHF) HRESULT {
                return @as(*const IFEDictionary.VTable, @ptrCast(self.vtable)).Open(@as(*const IFEDictionary, @ptrCast(self)), pchDictPath, pshf);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFEDictionary_Close(self: *const T) HRESULT {
                return @as(*const IFEDictionary.VTable, @ptrCast(self.vtable)).Close(@as(*const IFEDictionary, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFEDictionary_GetHeader(self: *const T, pchDictPath: ?*[260]u8, pshf: ?*IMESHF, pjfmt: ?*IMEFMT, pulType: ?*u32) HRESULT {
                return @as(*const IFEDictionary.VTable, @ptrCast(self.vtable)).GetHeader(@as(*const IFEDictionary, @ptrCast(self)), pchDictPath, pshf, pjfmt, pulType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFEDictionary_DisplayProperty(self: *const T, hwnd: ?HWND) HRESULT {
                return @as(*const IFEDictionary.VTable, @ptrCast(self.vtable)).DisplayProperty(@as(*const IFEDictionary, @ptrCast(self)), hwnd);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFEDictionary_GetPosTable(self: *const T, prgPosTbl: ?*?*POSTBL, pcPosTbl: ?*i32) HRESULT {
                return @as(*const IFEDictionary.VTable, @ptrCast(self.vtable)).GetPosTable(@as(*const IFEDictionary, @ptrCast(self)), prgPosTbl, pcPosTbl);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFEDictionary_GetWords(self: *const T, pwchFirst: ?[*:0]const u16, pwchLast: ?[*:0]const u16, pwchDisplay: ?[*:0]const u16, ulPos: u32, ulSelect: u32, ulWordSrc: u32, pchBuffer: ?*u8, cbBuffer: u32, pcWrd: ?*u32) HRESULT {
                return @as(*const IFEDictionary.VTable, @ptrCast(self.vtable)).GetWords(@as(*const IFEDictionary, @ptrCast(self)), pwchFirst, pwchLast, pwchDisplay, ulPos, ulSelect, ulWordSrc, pchBuffer, cbBuffer, pcWrd);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFEDictionary_NextWords(self: *const T, pchBuffer: ?*u8, cbBuffer: u32, pcWrd: ?*u32) HRESULT {
                return @as(*const IFEDictionary.VTable, @ptrCast(self.vtable)).NextWords(@as(*const IFEDictionary, @ptrCast(self)), pchBuffer, cbBuffer, pcWrd);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFEDictionary_Create(self: *const T, pchDictPath: ?[*:0]const u8, pshf: ?*IMESHF) HRESULT {
                return @as(*const IFEDictionary.VTable, @ptrCast(self.vtable)).Create(@as(*const IFEDictionary, @ptrCast(self)), pchDictPath, pshf);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFEDictionary_SetHeader(self: *const T, pshf: ?*IMESHF) HRESULT {
                return @as(*const IFEDictionary.VTable, @ptrCast(self.vtable)).SetHeader(@as(*const IFEDictionary, @ptrCast(self)), pshf);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFEDictionary_ExistWord(self: *const T, pwrd: ?*IMEWRD) HRESULT {
                return @as(*const IFEDictionary.VTable, @ptrCast(self.vtable)).ExistWord(@as(*const IFEDictionary, @ptrCast(self)), pwrd);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFEDictionary_ExistDependency(self: *const T, pdp: ?*IMEDP) HRESULT {
                return @as(*const IFEDictionary.VTable, @ptrCast(self.vtable)).ExistDependency(@as(*const IFEDictionary, @ptrCast(self)), pdp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFEDictionary_RegisterWord(self: *const T, reg: IMEREG, pwrd: ?*IMEWRD) HRESULT {
                return @as(*const IFEDictionary.VTable, @ptrCast(self.vtable)).RegisterWord(@as(*const IFEDictionary, @ptrCast(self)), reg, pwrd);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFEDictionary_RegisterDependency(self: *const T, reg: IMEREG, pdp: ?*IMEDP) HRESULT {
                return @as(*const IFEDictionary.VTable, @ptrCast(self.vtable)).RegisterDependency(@as(*const IFEDictionary, @ptrCast(self)), reg, pdp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFEDictionary_GetDependencies(self: *const T, pwchKakariReading: ?[*:0]const u16, pwchKakariDisplay: ?[*:0]const u16, ulKakariPos: u32, pwchUkeReading: ?[*:0]const u16, pwchUkeDisplay: ?[*:0]const u16, ulUkePos: u32, jrel: IMEREL, ulWordSrc: u32, pchBuffer: ?*u8, cbBuffer: u32, pcdp: ?*u32) HRESULT {
                return @as(*const IFEDictionary.VTable, @ptrCast(self.vtable)).GetDependencies(@as(*const IFEDictionary, @ptrCast(self)), pwchKakariReading, pwchKakariDisplay, ulKakariPos, pwchUkeReading, pwchUkeDisplay, ulUkePos, jrel, ulWordSrc, pchBuffer, cbBuffer, pcdp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFEDictionary_NextDependencies(self: *const T, pchBuffer: ?*u8, cbBuffer: u32, pcDp: ?*u32) HRESULT {
                return @as(*const IFEDictionary.VTable, @ptrCast(self.vtable)).NextDependencies(@as(*const IFEDictionary, @ptrCast(self)), pchBuffer, cbBuffer, pcDp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFEDictionary_ConvertFromOldMSIME(self: *const T, pchDic: ?[*:0]const u8, pfnLog: ?PFNLOG, reg: IMEREG) HRESULT {
                return @as(*const IFEDictionary.VTable, @ptrCast(self.vtable)).ConvertFromOldMSIME(@as(*const IFEDictionary, @ptrCast(self)), pchDic, pfnLog, reg);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFEDictionary_ConvertFromUserToSys(self: *const T) HRESULT {
                return @as(*const IFEDictionary.VTable, @ptrCast(self.vtable)).ConvertFromUserToSys(@as(*const IFEDictionary, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const IMEKMSINIT = extern struct {
    cbSize: i32 align(1),
    hWnd: ?HWND align(1),
};

pub const IMEKMSKEY = extern struct {
    dwStatus: u32 align(1),
    dwCompStatus: u32 align(1),
    dwVKEY: u32 align(1),
    Anonymous1: extern union {
        dwControl: u32 align(1),
        dwNotUsed: u32 align(1),
    } align(1),
    Anonymous2: extern union {
        pwszDscr: [31]u16 align(1),
        pwszNoUse: [31]u16 align(1),
    } align(1),
};

pub const IMEKMS = extern struct {
    cbSize: i32 align(1),
    hIMC: ?HIMC align(1),
    cKeyList: u32 align(1),
    pKeyList: ?*IMEKMSKEY align(1),
};

pub const IMEKMSNTFY = extern struct {
    cbSize: i32 align(1),
    hIMC: ?HIMC align(1),
    fSelect: BOOL align(1),
};

pub const IMEKMSKMP = extern struct {
    cbSize: i32 align(1),
    hIMC: ?HIMC align(1),
    idLang: u16 align(1),
    wVKStart: u16 align(1),
    wVKEnd: u16 align(1),
    cKeyList: i32 align(1),
    pKeyList: ?*IMEKMSKEY align(1),
};

pub const IMEKMSINVK = extern struct {
    cbSize: i32 align(1),
    hIMC: ?HIMC align(1),
    dwControl: u32 align(1),
};

pub const IMEKMSFUNCDESC = extern struct {
    cbSize: i32 align(1),
    idLang: u16 align(1),
    dwControl: u32 align(1),
    pwszDescription: [128]u16 align(1),
};

pub const fpCreateIFECommonInstanceType = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        ppvObj: ?*?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn (
        ppvObj: ?*?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
};

pub const fpCreateIFELanguageInstanceType = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        clsid: ?*const Guid,
        ppvObj: ?*?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn (
        clsid: ?*const Guid,
        ppvObj: ?*?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
};

pub const fpCreateIFEDictionaryInstanceType = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        ppvObj: ?*?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn (
        ppvObj: ?*?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
};

pub const COMPOSITIONSTRING = extern struct {
    dwSize: u32,
    dwCompReadAttrLen: u32,
    dwCompReadAttrOffset: u32,
    dwCompReadClauseLen: u32,
    dwCompReadClauseOffset: u32,
    dwCompReadStrLen: u32,
    dwCompReadStrOffset: u32,
    dwCompAttrLen: u32,
    dwCompAttrOffset: u32,
    dwCompClauseLen: u32,
    dwCompClauseOffset: u32,
    dwCompStrLen: u32,
    dwCompStrOffset: u32,
    dwCursorPos: u32,
    dwDeltaStart: u32,
    dwResultReadClauseLen: u32,
    dwResultReadClauseOffset: u32,
    dwResultReadStrLen: u32,
    dwResultReadStrOffset: u32,
    dwResultClauseLen: u32,
    dwResultClauseOffset: u32,
    dwResultStrLen: u32,
    dwResultStrOffset: u32,
    dwPrivateSize: u32,
    dwPrivateOffset: u32,
};

pub const GUIDELINE = extern struct {
    dwSize: u32,
    dwLevel: u32,
    dwIndex: u32,
    dwStrLen: u32,
    dwStrOffset: u32,
    dwPrivateSize: u32,
    dwPrivateOffset: u32,
};

pub const TRANSMSG = extern struct {
    message: u32,
    wParam: WPARAM,
    lParam: LPARAM,
};

pub const TRANSMSGLIST = extern struct {
    uMsgCount: u32,
    TransMsg: [1]TRANSMSG,
};

pub const CANDIDATEINFO = extern struct {
    dwSize: u32,
    dwCount: u32,
    dwOffset: [32]u32,
    dwPrivateSize: u32,
    dwPrivateOffset: u32,
};

pub const INPUTCONTEXT = extern struct {
    hWnd: ?HWND,
    fOpen: BOOL,
    ptStatusWndPos: POINT,
    ptSoftKbdPos: POINT,
    fdwConversion: u32,
    fdwSentence: u32,
    lfFont: extern union {
        A: LOGFONTA,
        W: LOGFONTW,
    },
    cfCompForm: COMPOSITIONFORM,
    cfCandForm: [4]CANDIDATEFORM,
    hCompStr: ?HIMCC,
    hCandInfo: ?HIMCC,
    hGuideLine: ?HIMCC,
    hPrivate: ?HIMCC,
    dwNumMsgBuf: u32,
    hMsgBuf: ?HIMCC,
    fdwInit: u32,
    dwReserve: [3]u32,
};

pub const IMEINFO = extern struct {
    dwPrivateDataSize: u32,
    fdwProperty: u32,
    fdwConversionCaps: u32,
    fdwSentenceCaps: u32,
    fdwUICaps: u32,
    fdwSCSCaps: u32,
    fdwSelectCaps: u32,
};

pub const SOFTKBDDATA = extern struct {
    uCount: u32,
    wCode: [256]u16,
};

pub const APPLETIDLIST = extern struct {
    count: i32,
    pIIDList: ?*Guid,
};

pub const IMESTRINGCANDIDATE = extern struct {
    uCount: u32,
    lpwstr: [1]?PWSTR,
};

pub const IMEITEM = extern struct {
    cbSize: i32,
    iType: i32,
    lpItemData: ?*anyopaque,
};

pub const IMEITEMCANDIDATE = extern struct {
    uCount: u32,
    imeItem: [1]IMEITEM,
};

pub const tabIMESTRINGINFO = extern struct {
    dwFarEastId: u32,
    lpwstr: ?PWSTR,
};

pub const tabIMEFAREASTINFO = extern struct {
    dwSize: u32,
    dwType: u32,
    dwData: [1]u32,
};

pub const IMESTRINGCANDIDATEINFO = extern struct {
    dwFarEastId: u32,
    lpFarEastInfo: ?*tabIMEFAREASTINFO,
    fInfoMask: u32,
    iSelIndex: i32,
    uCount: u32,
    lpwstr: [1]?PWSTR,
};

pub const IMECOMPOSITIONSTRINGINFO = extern struct {
    iCompStrLen: i32,
    iCaretPos: i32,
    iEditStart: i32,
    iEditLen: i32,
    iTargetStart: i32,
    iTargetLen: i32,
};

pub const IMECHARINFO = extern struct {
    wch: u16,
    dwCharInfo: u32,
};

pub const IMEAPPLETCFG = extern struct {
    dwConfig: u32,
    wchTitle: [64]u16,
    wchTitleFontFace: [32]u16,
    dwCharSet: u32,
    iCategory: i32,
    hIcon: ?HICON,
    langID: u16,
    dummy: u16,
    lReserved1: LPARAM,
};

pub const IMEAPPLETUI = extern struct {
    hwnd: ?HWND,
    dwStyle: u32,
    width: i32,
    height: i32,
    minWidth: i32,
    minHeight: i32,
    maxWidth: i32,
    maxHeight: i32,
    lReserved1: LPARAM,
    lReserved2: LPARAM,
};

pub const APPLYCANDEXPARAM = extern struct {
    dwSize: u32,
    lpwstrDisplay: ?PWSTR,
    lpwstrReading: ?PWSTR,
    dwReserved: u32,
};

const IID_IImeSpecifyApplets_Value = Guid.initString("5d8e643c-c3a9-11d1-afef-00805f0c8b6d");
pub const IID_IImeSpecifyApplets = &IID_IImeSpecifyApplets_Value;
pub const IImeSpecifyApplets = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetAppletIIDList: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IImeSpecifyApplets,
                refiid: ?*const Guid,
                lpIIDList: ?*APPLETIDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IImeSpecifyApplets,
                refiid: ?*const Guid,
                lpIIDList: ?*APPLETIDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IImeSpecifyApplets_GetAppletIIDList(self: *const T, refiid: ?*const Guid, lpIIDList: ?*APPLETIDLIST) HRESULT {
                return @as(*const IImeSpecifyApplets.VTable, @ptrCast(self.vtable)).GetAppletIIDList(@as(*const IImeSpecifyApplets, @ptrCast(self)), refiid, lpIIDList);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IImePadApplet_Value = Guid.initString("5d8e643b-c3a9-11d1-afef-00805f0c8b6d");
pub const IID_IImePadApplet = &IID_IImePadApplet_Value;
pub const IImePadApplet = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IImePadApplet,
                lpIImePad: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IImePadApplet,
                lpIImePad: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Terminate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IImePadApplet,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IImePadApplet,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAppletConfig: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IImePadApplet,
                lpAppletCfg: ?*IMEAPPLETCFG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IImePadApplet,
                lpAppletCfg: ?*IMEAPPLETCFG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateUI: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IImePadApplet,
                hwndParent: ?HWND,
                lpImeAppletUI: ?*IMEAPPLETUI,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IImePadApplet,
                hwndParent: ?HWND,
                lpImeAppletUI: ?*IMEAPPLETUI,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Notify: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IImePadApplet,
                lpImePad: ?*IUnknown,
                notify: i32,
                wParam: WPARAM,
                lParam: LPARAM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IImePadApplet,
                lpImePad: ?*IUnknown,
                notify: i32,
                wParam: WPARAM,
                lParam: LPARAM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IImePadApplet_Initialize(self: *const T, lpIImePad: ?*IUnknown) HRESULT {
                return @as(*const IImePadApplet.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IImePadApplet, @ptrCast(self)), lpIImePad);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IImePadApplet_Terminate(self: *const T) HRESULT {
                return @as(*const IImePadApplet.VTable, @ptrCast(self.vtable)).Terminate(@as(*const IImePadApplet, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IImePadApplet_GetAppletConfig(self: *const T, lpAppletCfg: ?*IMEAPPLETCFG) HRESULT {
                return @as(*const IImePadApplet.VTable, @ptrCast(self.vtable)).GetAppletConfig(@as(*const IImePadApplet, @ptrCast(self)), lpAppletCfg);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IImePadApplet_CreateUI(self: *const T, hwndParent: ?HWND, lpImeAppletUI: ?*IMEAPPLETUI) HRESULT {
                return @as(*const IImePadApplet.VTable, @ptrCast(self.vtable)).CreateUI(@as(*const IImePadApplet, @ptrCast(self)), hwndParent, lpImeAppletUI);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IImePadApplet_Notify(self: *const T, lpImePad: ?*IUnknown, notify: i32, wParam: WPARAM, lParam: LPARAM) HRESULT {
                return @as(*const IImePadApplet.VTable, @ptrCast(self.vtable)).Notify(@as(*const IImePadApplet, @ptrCast(self)), lpImePad, notify, wParam, lParam);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IImePad_Value = Guid.initString("5d8e643a-c3a9-11d1-afef-00805f0c8b6d");
pub const IID_IImePad = &IID_IImePad_Value;
pub const IImePad = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Request: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IImePad,
                pIImePadApplet: ?*IImePadApplet,
                reqId: IME_PAD_REQUEST_FLAGS,
                wParam: WPARAM,
                lParam: LPARAM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IImePad,
                pIImePadApplet: ?*IImePadApplet,
                reqId: IME_PAD_REQUEST_FLAGS,
                wParam: WPARAM,
                lParam: LPARAM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IImePad_Request(self: *const T, pIImePadApplet: ?*IImePadApplet, reqId: IME_PAD_REQUEST_FLAGS, wParam: WPARAM, lParam: LPARAM) HRESULT {
                return @as(*const IImePad.VTable, @ptrCast(self.vtable)).Request(@as(*const IImePad, @ptrCast(self)), pIImePadApplet, reqId, wParam, lParam);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IImePlugInDictDictionaryList_Value = Guid.initString("98752974-b0a6-489b-8f6f-bff3769c8eeb");
pub const IID_IImePlugInDictDictionaryList = &IID_IImePlugInDictDictionaryList_Value;
pub const IImePlugInDictDictionaryList = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDictionariesInUse: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IImePlugInDictDictionaryList,
                prgDictionaryGUID: ?*?*SAFEARRAY,
                prgDateCreated: ?*?*SAFEARRAY,
                prgfEncrypted: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IImePlugInDictDictionaryList,
                prgDictionaryGUID: ?*?*SAFEARRAY,
                prgDateCreated: ?*?*SAFEARRAY,
                prgfEncrypted: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeleteDictionary: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IImePlugInDictDictionaryList,
                bstrDictionaryGUID: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IImePlugInDictDictionaryList,
                bstrDictionaryGUID: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IImePlugInDictDictionaryList_GetDictionariesInUse(self: *const T, prgDictionaryGUID: ?*?*SAFEARRAY, prgDateCreated: ?*?*SAFEARRAY, prgfEncrypted: ?*?*SAFEARRAY) HRESULT {
                return @as(*const IImePlugInDictDictionaryList.VTable, @ptrCast(self.vtable)).GetDictionariesInUse(@as(*const IImePlugInDictDictionaryList, @ptrCast(self)), prgDictionaryGUID, prgDateCreated, prgfEncrypted);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IImePlugInDictDictionaryList_DeleteDictionary(self: *const T, bstrDictionaryGUID: ?BSTR) HRESULT {
                return @as(*const IImePlugInDictDictionaryList.VTable, @ptrCast(self.vtable)).DeleteDictionary(@as(*const IImePlugInDictDictionaryList, @ptrCast(self)), bstrDictionaryGUID);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const CLSID_CActiveIMM_Value = Guid.initString("4955dd33-b159-11d0-8fcf-00aa006bcc59");
pub const CLSID_CActiveIMM = &CLSID_CActiveIMM_Value;

const IID_IEnumRegisterWordA_Value = Guid.initString("08c03412-f96b-11d0-a475-00aa006bcc59");
pub const IID_IEnumRegisterWordA = &IID_IEnumRegisterWordA_Value;
pub const IEnumRegisterWordA = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumRegisterWordA,
                ppEnum: ?*?*IEnumRegisterWordA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumRegisterWordA,
                ppEnum: ?*?*IEnumRegisterWordA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumRegisterWordA,
                ulCount: u32,
                rgRegisterWord: ?*REGISTERWORDA,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumRegisterWordA,
                ulCount: u32,
                rgRegisterWord: ?*REGISTERWORDA,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumRegisterWordA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumRegisterWordA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumRegisterWordA,
                ulCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumRegisterWordA,
                ulCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumRegisterWordA_Clone(self: *const T, ppEnum: ?*?*IEnumRegisterWordA) HRESULT {
                return @as(*const IEnumRegisterWordA.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumRegisterWordA, @ptrCast(self)), ppEnum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumRegisterWordA_Next(self: *const T, ulCount: u32, rgRegisterWord: ?*REGISTERWORDA, pcFetched: ?*u32) HRESULT {
                return @as(*const IEnumRegisterWordA.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumRegisterWordA, @ptrCast(self)), ulCount, rgRegisterWord, pcFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumRegisterWordA_Reset(self: *const T) HRESULT {
                return @as(*const IEnumRegisterWordA.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumRegisterWordA, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumRegisterWordA_Skip(self: *const T, ulCount: u32) HRESULT {
                return @as(*const IEnumRegisterWordA.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumRegisterWordA, @ptrCast(self)), ulCount);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumRegisterWordW_Value = Guid.initString("4955dd31-b159-11d0-8fcf-00aa006bcc59");
pub const IID_IEnumRegisterWordW = &IID_IEnumRegisterWordW_Value;
pub const IEnumRegisterWordW = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumRegisterWordW,
                ppEnum: ?*?*IEnumRegisterWordW,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumRegisterWordW,
                ppEnum: ?*?*IEnumRegisterWordW,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumRegisterWordW,
                ulCount: u32,
                rgRegisterWord: ?*REGISTERWORDW,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumRegisterWordW,
                ulCount: u32,
                rgRegisterWord: ?*REGISTERWORDW,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumRegisterWordW,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumRegisterWordW,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumRegisterWordW,
                ulCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumRegisterWordW,
                ulCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumRegisterWordW_Clone(self: *const T, ppEnum: ?*?*IEnumRegisterWordW) HRESULT {
                return @as(*const IEnumRegisterWordW.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumRegisterWordW, @ptrCast(self)), ppEnum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumRegisterWordW_Next(self: *const T, ulCount: u32, rgRegisterWord: ?*REGISTERWORDW, pcFetched: ?*u32) HRESULT {
                return @as(*const IEnumRegisterWordW.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumRegisterWordW, @ptrCast(self)), ulCount, rgRegisterWord, pcFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumRegisterWordW_Reset(self: *const T) HRESULT {
                return @as(*const IEnumRegisterWordW.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumRegisterWordW, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumRegisterWordW_Skip(self: *const T, ulCount: u32) HRESULT {
                return @as(*const IEnumRegisterWordW.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumRegisterWordW, @ptrCast(self)), ulCount);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumInputContext_Value = Guid.initString("09b5eab0-f997-11d1-93d4-0060b067b86e");
pub const IID_IEnumInputContext = &IID_IEnumInputContext_Value;
pub const IEnumInputContext = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumInputContext,
                ppEnum: ?*?*IEnumInputContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumInputContext,
                ppEnum: ?*?*IEnumInputContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumInputContext,
                ulCount: u32,
                rgInputContext: ?*?HIMC,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumInputContext,
                ulCount: u32,
                rgInputContext: ?*?HIMC,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumInputContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumInputContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumInputContext,
                ulCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumInputContext,
                ulCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumInputContext_Clone(self: *const T, ppEnum: ?*?*IEnumInputContext) HRESULT {
                return @as(*const IEnumInputContext.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumInputContext, @ptrCast(self)), ppEnum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumInputContext_Next(self: *const T, ulCount: u32, rgInputContext: ?*?HIMC, pcFetched: ?*u32) HRESULT {
                return @as(*const IEnumInputContext.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumInputContext, @ptrCast(self)), ulCount, rgInputContext, pcFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumInputContext_Reset(self: *const T) HRESULT {
                return @as(*const IEnumInputContext.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumInputContext, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumInputContext_Skip(self: *const T, ulCount: u32) HRESULT {
                return @as(*const IEnumInputContext.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumInputContext, @ptrCast(self)), ulCount);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveIMMRegistrar_Value = Guid.initString("b3458082-bd00-11d1-939b-0060b067b86e");
pub const IID_IActiveIMMRegistrar = &IID_IActiveIMMRegistrar_Value;
pub const IActiveIMMRegistrar = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RegisterIME: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMRegistrar,
                rclsid: ?*const Guid,
                lgid: u16,
                pszIconFile: ?[*:0]const u16,
                pszDesc: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMRegistrar,
                rclsid: ?*const Guid,
                lgid: u16,
                pszIconFile: ?[*:0]const u16,
                pszDesc: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnregisterIME: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMRegistrar,
                rclsid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMRegistrar,
                rclsid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMRegistrar_RegisterIME(self: *const T, rclsid: ?*const Guid, lgid: u16, pszIconFile: ?[*:0]const u16, pszDesc: ?[*:0]const u16) HRESULT {
                return @as(*const IActiveIMMRegistrar.VTable, @ptrCast(self.vtable)).RegisterIME(@as(*const IActiveIMMRegistrar, @ptrCast(self)), rclsid, lgid, pszIconFile, pszDesc);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMRegistrar_UnregisterIME(self: *const T, rclsid: ?*const Guid) HRESULT {
                return @as(*const IActiveIMMRegistrar.VTable, @ptrCast(self.vtable)).UnregisterIME(@as(*const IActiveIMMRegistrar, @ptrCast(self)), rclsid);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveIMMMessagePumpOwner_Value = Guid.initString("b5cf2cfa-8aeb-11d1-9364-0060b067b86e");
pub const IID_IActiveIMMMessagePumpOwner = &IID_IActiveIMMMessagePumpOwner_Value;
pub const IActiveIMMMessagePumpOwner = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Start: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMMessagePumpOwner,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMMessagePumpOwner,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        End: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMMessagePumpOwner,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMMessagePumpOwner,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnTranslateMessage: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMMessagePumpOwner,
                pMsg: ?*const MSG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMMessagePumpOwner,
                pMsg: ?*const MSG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Pause: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMMessagePumpOwner,
                pdwCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMMessagePumpOwner,
                pdwCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Resume: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMMessagePumpOwner,
                dwCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMMessagePumpOwner,
                dwCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMMessagePumpOwner_Start(self: *const T) HRESULT {
                return @as(*const IActiveIMMMessagePumpOwner.VTable, @ptrCast(self.vtable)).Start(@as(*const IActiveIMMMessagePumpOwner, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMMessagePumpOwner_End(self: *const T) HRESULT {
                return @as(*const IActiveIMMMessagePumpOwner.VTable, @ptrCast(self.vtable)).End(@as(*const IActiveIMMMessagePumpOwner, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMMessagePumpOwner_OnTranslateMessage(self: *const T, pMsg: ?*const MSG) HRESULT {
                return @as(*const IActiveIMMMessagePumpOwner.VTable, @ptrCast(self.vtable)).OnTranslateMessage(@as(*const IActiveIMMMessagePumpOwner, @ptrCast(self)), pMsg);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMMessagePumpOwner_Pause(self: *const T, pdwCookie: ?*u32) HRESULT {
                return @as(*const IActiveIMMMessagePumpOwner.VTable, @ptrCast(self.vtable)).Pause(@as(*const IActiveIMMMessagePumpOwner, @ptrCast(self)), pdwCookie);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMMessagePumpOwner_Resume(self: *const T, dwCookie: u32) HRESULT {
                return @as(*const IActiveIMMMessagePumpOwner.VTable, @ptrCast(self.vtable)).Resume(@as(*const IActiveIMMMessagePumpOwner, @ptrCast(self)), dwCookie);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveIMMApp_Value = Guid.initString("08c0e040-62d1-11d1-9326-0060b067b86e");
pub const IID_IActiveIMMApp = &IID_IActiveIMMApp_Value;
pub const IActiveIMMApp = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AssociateContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMApp,
                hWnd: ?HWND,
                hIME: ?HIMC,
                phPrev: ?*?HIMC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMApp,
                hWnd: ?HWND,
                hIME: ?HIMC,
                phPrev: ?*?HIMC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ConfigureIMEA: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMApp,
                hKL: ?HKL,
                hWnd: ?HWND,
                dwMode: u32,
                pData: ?*REGISTERWORDA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMApp,
                hKL: ?HKL,
                hWnd: ?HWND,
                dwMode: u32,
                pData: ?*REGISTERWORDA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ConfigureIMEW: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMApp,
                hKL: ?HKL,
                hWnd: ?HWND,
                dwMode: u32,
                pData: ?*REGISTERWORDW,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMApp,
                hKL: ?HKL,
                hWnd: ?HWND,
                dwMode: u32,
                pData: ?*REGISTERWORDW,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMApp,
                phIMC: ?*?HIMC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMApp,
                phIMC: ?*?HIMC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DestroyContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMApp,
                hIME: ?HIMC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMApp,
                hIME: ?HIMC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumRegisterWordA: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMApp,
                hKL: ?HKL,
                szReading: ?PSTR,
                dwStyle: u32,
                szRegister: ?PSTR,
                pData: ?*anyopaque,
                pEnum: ?*?*IEnumRegisterWordA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMApp,
                hKL: ?HKL,
                szReading: ?PSTR,
                dwStyle: u32,
                szRegister: ?PSTR,
                pData: ?*anyopaque,
                pEnum: ?*?*IEnumRegisterWordA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumRegisterWordW: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMApp,
                hKL: ?HKL,
                szReading: ?PWSTR,
                dwStyle: u32,
                szRegister: ?PWSTR,
                pData: ?*anyopaque,
                pEnum: ?*?*IEnumRegisterWordW,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMApp,
                hKL: ?HKL,
                szReading: ?PWSTR,
                dwStyle: u32,
                szRegister: ?PWSTR,
                pData: ?*anyopaque,
                pEnum: ?*?*IEnumRegisterWordW,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EscapeA: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMApp,
                hKL: ?HKL,
                hIMC: ?HIMC,
                uEscape: u32,
                pData: ?*anyopaque,
                plResult: ?*LRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMApp,
                hKL: ?HKL,
                hIMC: ?HIMC,
                uEscape: u32,
                pData: ?*anyopaque,
                plResult: ?*LRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EscapeW: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMApp,
                hKL: ?HKL,
                hIMC: ?HIMC,
                uEscape: u32,
                pData: ?*anyopaque,
                plResult: ?*LRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMApp,
                hKL: ?HKL,
                hIMC: ?HIMC,
                uEscape: u32,
                pData: ?*anyopaque,
                plResult: ?*LRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCandidateListA: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMApp,
                hIMC: ?HIMC,
                dwIndex: u32,
                uBufLen: u32,
                pCandList: ?*CANDIDATELIST,
                puCopied: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMApp,
                hIMC: ?HIMC,
                dwIndex: u32,
                uBufLen: u32,
                pCandList: ?*CANDIDATELIST,
                puCopied: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCandidateListW: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMApp,
                hIMC: ?HIMC,
                dwIndex: u32,
                uBufLen: u32,
                pCandList: ?*CANDIDATELIST,
                puCopied: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMApp,
                hIMC: ?HIMC,
                dwIndex: u32,
                uBufLen: u32,
                pCandList: ?*CANDIDATELIST,
                puCopied: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCandidateListCountA: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMApp,
                hIMC: ?HIMC,
                pdwListSize: ?*u32,
                pdwBufLen: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMApp,
                hIMC: ?HIMC,
                pdwListSize: ?*u32,
                pdwBufLen: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCandidateListCountW: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMApp,
                hIMC: ?HIMC,
                pdwListSize: ?*u32,
                pdwBufLen: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMApp,
                hIMC: ?HIMC,
                pdwListSize: ?*u32,
                pdwBufLen: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCandidateWindow: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMApp,
                hIMC: ?HIMC,
                dwIndex: u32,
                pCandidate: ?*CANDIDATEFORM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMApp,
                hIMC: ?HIMC,
                dwIndex: u32,
                pCandidate: ?*CANDIDATEFORM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCompositionFontA: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMApp,
                hIMC: ?HIMC,
                plf: ?*LOGFONTA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMApp,
                hIMC: ?HIMC,
                plf: ?*LOGFONTA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCompositionFontW: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMApp,
                hIMC: ?HIMC,
                plf: ?*LOGFONTW,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMApp,
                hIMC: ?HIMC,
                plf: ?*LOGFONTW,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCompositionStringA: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMApp,
                hIMC: ?HIMC,
                dwIndex: u32,
                dwBufLen: u32,
                plCopied: ?*i32,
                pBuf: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMApp,
                hIMC: ?HIMC,
                dwIndex: u32,
                dwBufLen: u32,
                plCopied: ?*i32,
                pBuf: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCompositionStringW: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMApp,
                hIMC: ?HIMC,
                dwIndex: u32,
                dwBufLen: u32,
                plCopied: ?*i32,
                pBuf: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMApp,
                hIMC: ?HIMC,
                dwIndex: u32,
                dwBufLen: u32,
                plCopied: ?*i32,
                pBuf: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCompositionWindow: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMApp,
                hIMC: ?HIMC,
                pCompForm: ?*COMPOSITIONFORM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMApp,
                hIMC: ?HIMC,
                pCompForm: ?*COMPOSITIONFORM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMApp,
                hWnd: ?HWND,
                phIMC: ?*?HIMC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMApp,
                hWnd: ?HWND,
                phIMC: ?*?HIMC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetConversionListA: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMApp,
                hKL: ?HKL,
                hIMC: ?HIMC,
                pSrc: ?PSTR,
                uBufLen: u32,
                uFlag: u32,
                pDst: ?*CANDIDATELIST,
                puCopied: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMApp,
                hKL: ?HKL,
                hIMC: ?HIMC,
                pSrc: ?PSTR,
                uBufLen: u32,
                uFlag: u32,
                pDst: ?*CANDIDATELIST,
                puCopied: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetConversionListW: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMApp,
                hKL: ?HKL,
                hIMC: ?HIMC,
                pSrc: ?PWSTR,
                uBufLen: u32,
                uFlag: u32,
                pDst: ?*CANDIDATELIST,
                puCopied: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMApp,
                hKL: ?HKL,
                hIMC: ?HIMC,
                pSrc: ?PWSTR,
                uBufLen: u32,
                uFlag: u32,
                pDst: ?*CANDIDATELIST,
                puCopied: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetConversionStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMApp,
                hIMC: ?HIMC,
                pfdwConversion: ?*u32,
                pfdwSentence: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMApp,
                hIMC: ?HIMC,
                pfdwConversion: ?*u32,
                pfdwSentence: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDefaultIMEWnd: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMApp,
                hWnd: ?HWND,
                phDefWnd: ?*?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMApp,
                hWnd: ?HWND,
                phDefWnd: ?*?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDescriptionA: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMApp,
                hKL: ?HKL,
                uBufLen: u32,
                szDescription: ?PSTR,
                puCopied: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMApp,
                hKL: ?HKL,
                uBufLen: u32,
                szDescription: ?PSTR,
                puCopied: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDescriptionW: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMApp,
                hKL: ?HKL,
                uBufLen: u32,
                szDescription: ?PWSTR,
                puCopied: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMApp,
                hKL: ?HKL,
                uBufLen: u32,
                szDescription: ?PWSTR,
                puCopied: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetGuideLineA: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMApp,
                hIMC: ?HIMC,
                dwIndex: u32,
                dwBufLen: u32,
                pBuf: ?PSTR,
                pdwResult: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMApp,
                hIMC: ?HIMC,
                dwIndex: u32,
                dwBufLen: u32,
                pBuf: ?PSTR,
                pdwResult: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetGuideLineW: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMApp,
                hIMC: ?HIMC,
                dwIndex: u32,
                dwBufLen: u32,
                pBuf: ?PWSTR,
                pdwResult: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMApp,
                hIMC: ?HIMC,
                dwIndex: u32,
                dwBufLen: u32,
                pBuf: ?PWSTR,
                pdwResult: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIMEFileNameA: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMApp,
                hKL: ?HKL,
                uBufLen: u32,
                szFileName: ?PSTR,
                puCopied: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMApp,
                hKL: ?HKL,
                uBufLen: u32,
                szFileName: ?PSTR,
                puCopied: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIMEFileNameW: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMApp,
                hKL: ?HKL,
                uBufLen: u32,
                szFileName: ?PWSTR,
                puCopied: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMApp,
                hKL: ?HKL,
                uBufLen: u32,
                szFileName: ?PWSTR,
                puCopied: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOpenStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMApp,
                hIMC: ?HIMC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMApp,
                hIMC: ?HIMC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMApp,
                hKL: ?HKL,
                fdwIndex: u32,
                pdwProperty: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMApp,
                hKL: ?HKL,
                fdwIndex: u32,
                pdwProperty: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRegisterWordStyleA: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMApp,
                hKL: ?HKL,
                nItem: u32,
                pStyleBuf: ?*STYLEBUFA,
                puCopied: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMApp,
                hKL: ?HKL,
                nItem: u32,
                pStyleBuf: ?*STYLEBUFA,
                puCopied: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRegisterWordStyleW: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMApp,
                hKL: ?HKL,
                nItem: u32,
                pStyleBuf: ?*STYLEBUFW,
                puCopied: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMApp,
                hKL: ?HKL,
                nItem: u32,
                pStyleBuf: ?*STYLEBUFW,
                puCopied: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStatusWindowPos: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMApp,
                hIMC: ?HIMC,
                pptPos: ?*POINT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMApp,
                hIMC: ?HIMC,
                pptPos: ?*POINT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVirtualKey: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMApp,
                hWnd: ?HWND,
                puVirtualKey: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMApp,
                hWnd: ?HWND,
                puVirtualKey: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InstallIMEA: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMApp,
                szIMEFileName: ?PSTR,
                szLayoutText: ?PSTR,
                phKL: ?*?HKL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMApp,
                szIMEFileName: ?PSTR,
                szLayoutText: ?PSTR,
                phKL: ?*?HKL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InstallIMEW: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMApp,
                szIMEFileName: ?PWSTR,
                szLayoutText: ?PWSTR,
                phKL: ?*?HKL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMApp,
                szIMEFileName: ?PWSTR,
                szLayoutText: ?PWSTR,
                phKL: ?*?HKL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsIME: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMApp,
                hKL: ?HKL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMApp,
                hKL: ?HKL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsUIMessageA: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMApp,
                hWndIME: ?HWND,
                msg: u32,
                wParam: WPARAM,
                lParam: LPARAM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMApp,
                hWndIME: ?HWND,
                msg: u32,
                wParam: WPARAM,
                lParam: LPARAM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsUIMessageW: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMApp,
                hWndIME: ?HWND,
                msg: u32,
                wParam: WPARAM,
                lParam: LPARAM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMApp,
                hWndIME: ?HWND,
                msg: u32,
                wParam: WPARAM,
                lParam: LPARAM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NotifyIME: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMApp,
                hIMC: ?HIMC,
                dwAction: u32,
                dwIndex: u32,
                dwValue: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMApp,
                hIMC: ?HIMC,
                dwAction: u32,
                dwIndex: u32,
                dwValue: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RegisterWordA: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMApp,
                hKL: ?HKL,
                szReading: ?PSTR,
                dwStyle: u32,
                szRegister: ?PSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMApp,
                hKL: ?HKL,
                szReading: ?PSTR,
                dwStyle: u32,
                szRegister: ?PSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RegisterWordW: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMApp,
                hKL: ?HKL,
                szReading: ?PWSTR,
                dwStyle: u32,
                szRegister: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMApp,
                hKL: ?HKL,
                szReading: ?PWSTR,
                dwStyle: u32,
                szRegister: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReleaseContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMApp,
                hWnd: ?HWND,
                hIMC: ?HIMC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMApp,
                hWnd: ?HWND,
                hIMC: ?HIMC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCandidateWindow: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMApp,
                hIMC: ?HIMC,
                pCandidate: ?*CANDIDATEFORM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMApp,
                hIMC: ?HIMC,
                pCandidate: ?*CANDIDATEFORM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCompositionFontA: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMApp,
                hIMC: ?HIMC,
                plf: ?*LOGFONTA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMApp,
                hIMC: ?HIMC,
                plf: ?*LOGFONTA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCompositionFontW: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMApp,
                hIMC: ?HIMC,
                plf: ?*LOGFONTW,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMApp,
                hIMC: ?HIMC,
                plf: ?*LOGFONTW,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCompositionStringA: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMApp,
                hIMC: ?HIMC,
                dwIndex: u32,
                pComp: ?*anyopaque,
                dwCompLen: u32,
                pRead: ?*anyopaque,
                dwReadLen: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMApp,
                hIMC: ?HIMC,
                dwIndex: u32,
                pComp: ?*anyopaque,
                dwCompLen: u32,
                pRead: ?*anyopaque,
                dwReadLen: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCompositionStringW: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMApp,
                hIMC: ?HIMC,
                dwIndex: u32,
                pComp: ?*anyopaque,
                dwCompLen: u32,
                pRead: ?*anyopaque,
                dwReadLen: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMApp,
                hIMC: ?HIMC,
                dwIndex: u32,
                pComp: ?*anyopaque,
                dwCompLen: u32,
                pRead: ?*anyopaque,
                dwReadLen: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCompositionWindow: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMApp,
                hIMC: ?HIMC,
                pCompForm: ?*COMPOSITIONFORM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMApp,
                hIMC: ?HIMC,
                pCompForm: ?*COMPOSITIONFORM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetConversionStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMApp,
                hIMC: ?HIMC,
                fdwConversion: u32,
                fdwSentence: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMApp,
                hIMC: ?HIMC,
                fdwConversion: u32,
                fdwSentence: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOpenStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMApp,
                hIMC: ?HIMC,
                fOpen: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMApp,
                hIMC: ?HIMC,
                fOpen: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetStatusWindowPos: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMApp,
                hIMC: ?HIMC,
                pptPos: ?*POINT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMApp,
                hIMC: ?HIMC,
                pptPos: ?*POINT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SimulateHotKey: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMApp,
                hWnd: ?HWND,
                dwHotKeyID: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMApp,
                hWnd: ?HWND,
                dwHotKeyID: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnregisterWordA: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMApp,
                hKL: ?HKL,
                szReading: ?PSTR,
                dwStyle: u32,
                szUnregister: ?PSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMApp,
                hKL: ?HKL,
                szReading: ?PSTR,
                dwStyle: u32,
                szUnregister: ?PSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnregisterWordW: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMApp,
                hKL: ?HKL,
                szReading: ?PWSTR,
                dwStyle: u32,
                szUnregister: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMApp,
                hKL: ?HKL,
                szReading: ?PWSTR,
                dwStyle: u32,
                szUnregister: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Activate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMApp,
                fRestoreLayout: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMApp,
                fRestoreLayout: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Deactivate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMApp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMApp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnDefWindowProc: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMApp,
                hWnd: ?HWND,
                Msg: u32,
                wParam: WPARAM,
                lParam: LPARAM,
                plResult: ?*LRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMApp,
                hWnd: ?HWND,
                Msg: u32,
                wParam: WPARAM,
                lParam: LPARAM,
                plResult: ?*LRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FilterClientWindows: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMApp,
                aaClassList: ?*u16,
                uSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMApp,
                aaClassList: ?*u16,
                uSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCodePageA: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMApp,
                hKL: ?HKL,
                uCodePage: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMApp,
                hKL: ?HKL,
                uCodePage: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLangId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMApp,
                hKL: ?HKL,
                plid: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMApp,
                hKL: ?HKL,
                plid: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AssociateContextEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMApp,
                hWnd: ?HWND,
                hIMC: ?HIMC,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMApp,
                hWnd: ?HWND,
                hIMC: ?HIMC,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DisableIME: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMApp,
                idThread: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMApp,
                idThread: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetImeMenuItemsA: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMApp,
                hIMC: ?HIMC,
                dwFlags: u32,
                dwType: u32,
                pImeParentMenu: ?*IMEMENUITEMINFOA,
                pImeMenu: ?*IMEMENUITEMINFOA,
                dwSize: u32,
                pdwResult: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMApp,
                hIMC: ?HIMC,
                dwFlags: u32,
                dwType: u32,
                pImeParentMenu: ?*IMEMENUITEMINFOA,
                pImeMenu: ?*IMEMENUITEMINFOA,
                dwSize: u32,
                pdwResult: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetImeMenuItemsW: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMApp,
                hIMC: ?HIMC,
                dwFlags: u32,
                dwType: u32,
                pImeParentMenu: ?*IMEMENUITEMINFOW,
                pImeMenu: ?*IMEMENUITEMINFOW,
                dwSize: u32,
                pdwResult: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMApp,
                hIMC: ?HIMC,
                dwFlags: u32,
                dwType: u32,
                pImeParentMenu: ?*IMEMENUITEMINFOW,
                pImeMenu: ?*IMEMENUITEMINFOW,
                dwSize: u32,
                pdwResult: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumInputContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMApp,
                idThread: u32,
                ppEnum: ?*?*IEnumInputContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMApp,
                idThread: u32,
                ppEnum: ?*?*IEnumInputContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMApp_AssociateContext(self: *const T, hWnd: ?HWND, hIME: ?HIMC, phPrev: ?*?HIMC) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).AssociateContext(@as(*const IActiveIMMApp, @ptrCast(self)), hWnd, hIME, phPrev);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMApp_ConfigureIMEA(self: *const T, hKL: ?HKL, hWnd: ?HWND, dwMode: u32, pData: ?*REGISTERWORDA) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).ConfigureIMEA(@as(*const IActiveIMMApp, @ptrCast(self)), hKL, hWnd, dwMode, pData);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMApp_ConfigureIMEW(self: *const T, hKL: ?HKL, hWnd: ?HWND, dwMode: u32, pData: ?*REGISTERWORDW) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).ConfigureIMEW(@as(*const IActiveIMMApp, @ptrCast(self)), hKL, hWnd, dwMode, pData);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMApp_CreateContext(self: *const T, phIMC: ?*?HIMC) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).CreateContext(@as(*const IActiveIMMApp, @ptrCast(self)), phIMC);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMApp_DestroyContext(self: *const T, hIME: ?HIMC) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).DestroyContext(@as(*const IActiveIMMApp, @ptrCast(self)), hIME);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMApp_EnumRegisterWordA(self: *const T, hKL: ?HKL, szReading: ?PSTR, dwStyle: u32, szRegister: ?PSTR, pData: ?*anyopaque, pEnum: ?*?*IEnumRegisterWordA) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).EnumRegisterWordA(@as(*const IActiveIMMApp, @ptrCast(self)), hKL, szReading, dwStyle, szRegister, pData, pEnum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMApp_EnumRegisterWordW(self: *const T, hKL: ?HKL, szReading: ?PWSTR, dwStyle: u32, szRegister: ?PWSTR, pData: ?*anyopaque, pEnum: ?*?*IEnumRegisterWordW) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).EnumRegisterWordW(@as(*const IActiveIMMApp, @ptrCast(self)), hKL, szReading, dwStyle, szRegister, pData, pEnum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMApp_EscapeA(self: *const T, hKL: ?HKL, hIMC: ?HIMC, uEscape: u32, pData: ?*anyopaque, plResult: ?*LRESULT) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).EscapeA(@as(*const IActiveIMMApp, @ptrCast(self)), hKL, hIMC, uEscape, pData, plResult);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMApp_EscapeW(self: *const T, hKL: ?HKL, hIMC: ?HIMC, uEscape: u32, pData: ?*anyopaque, plResult: ?*LRESULT) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).EscapeW(@as(*const IActiveIMMApp, @ptrCast(self)), hKL, hIMC, uEscape, pData, plResult);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMApp_GetCandidateListA(self: *const T, hIMC: ?HIMC, dwIndex: u32, uBufLen: u32, pCandList: ?*CANDIDATELIST, puCopied: ?*u32) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).GetCandidateListA(@as(*const IActiveIMMApp, @ptrCast(self)), hIMC, dwIndex, uBufLen, pCandList, puCopied);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMApp_GetCandidateListW(self: *const T, hIMC: ?HIMC, dwIndex: u32, uBufLen: u32, pCandList: ?*CANDIDATELIST, puCopied: ?*u32) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).GetCandidateListW(@as(*const IActiveIMMApp, @ptrCast(self)), hIMC, dwIndex, uBufLen, pCandList, puCopied);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMApp_GetCandidateListCountA(self: *const T, hIMC: ?HIMC, pdwListSize: ?*u32, pdwBufLen: ?*u32) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).GetCandidateListCountA(@as(*const IActiveIMMApp, @ptrCast(self)), hIMC, pdwListSize, pdwBufLen);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMApp_GetCandidateListCountW(self: *const T, hIMC: ?HIMC, pdwListSize: ?*u32, pdwBufLen: ?*u32) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).GetCandidateListCountW(@as(*const IActiveIMMApp, @ptrCast(self)), hIMC, pdwListSize, pdwBufLen);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMApp_GetCandidateWindow(self: *const T, hIMC: ?HIMC, dwIndex: u32, pCandidate: ?*CANDIDATEFORM) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).GetCandidateWindow(@as(*const IActiveIMMApp, @ptrCast(self)), hIMC, dwIndex, pCandidate);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMApp_GetCompositionFontA(self: *const T, hIMC: ?HIMC, plf: ?*LOGFONTA) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).GetCompositionFontA(@as(*const IActiveIMMApp, @ptrCast(self)), hIMC, plf);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMApp_GetCompositionFontW(self: *const T, hIMC: ?HIMC, plf: ?*LOGFONTW) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).GetCompositionFontW(@as(*const IActiveIMMApp, @ptrCast(self)), hIMC, plf);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMApp_GetCompositionStringA(self: *const T, hIMC: ?HIMC, dwIndex: u32, dwBufLen: u32, plCopied: ?*i32, pBuf: ?*anyopaque) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).GetCompositionStringA(@as(*const IActiveIMMApp, @ptrCast(self)), hIMC, dwIndex, dwBufLen, plCopied, pBuf);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMApp_GetCompositionStringW(self: *const T, hIMC: ?HIMC, dwIndex: u32, dwBufLen: u32, plCopied: ?*i32, pBuf: ?*anyopaque) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).GetCompositionStringW(@as(*const IActiveIMMApp, @ptrCast(self)), hIMC, dwIndex, dwBufLen, plCopied, pBuf);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMApp_GetCompositionWindow(self: *const T, hIMC: ?HIMC, pCompForm: ?*COMPOSITIONFORM) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).GetCompositionWindow(@as(*const IActiveIMMApp, @ptrCast(self)), hIMC, pCompForm);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMApp_GetContext(self: *const T, hWnd: ?HWND, phIMC: ?*?HIMC) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).GetContext(@as(*const IActiveIMMApp, @ptrCast(self)), hWnd, phIMC);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMApp_GetConversionListA(self: *const T, hKL: ?HKL, hIMC: ?HIMC, pSrc: ?PSTR, uBufLen: u32, uFlag: u32, pDst: ?*CANDIDATELIST, puCopied: ?*u32) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).GetConversionListA(@as(*const IActiveIMMApp, @ptrCast(self)), hKL, hIMC, pSrc, uBufLen, uFlag, pDst, puCopied);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMApp_GetConversionListW(self: *const T, hKL: ?HKL, hIMC: ?HIMC, pSrc: ?PWSTR, uBufLen: u32, uFlag: u32, pDst: ?*CANDIDATELIST, puCopied: ?*u32) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).GetConversionListW(@as(*const IActiveIMMApp, @ptrCast(self)), hKL, hIMC, pSrc, uBufLen, uFlag, pDst, puCopied);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMApp_GetConversionStatus(self: *const T, hIMC: ?HIMC, pfdwConversion: ?*u32, pfdwSentence: ?*u32) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).GetConversionStatus(@as(*const IActiveIMMApp, @ptrCast(self)), hIMC, pfdwConversion, pfdwSentence);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMApp_GetDefaultIMEWnd(self: *const T, hWnd: ?HWND, phDefWnd: ?*?HWND) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).GetDefaultIMEWnd(@as(*const IActiveIMMApp, @ptrCast(self)), hWnd, phDefWnd);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMApp_GetDescriptionA(self: *const T, hKL: ?HKL, uBufLen: u32, szDescription: ?PSTR, puCopied: ?*u32) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).GetDescriptionA(@as(*const IActiveIMMApp, @ptrCast(self)), hKL, uBufLen, szDescription, puCopied);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMApp_GetDescriptionW(self: *const T, hKL: ?HKL, uBufLen: u32, szDescription: ?PWSTR, puCopied: ?*u32) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).GetDescriptionW(@as(*const IActiveIMMApp, @ptrCast(self)), hKL, uBufLen, szDescription, puCopied);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMApp_GetGuideLineA(self: *const T, hIMC: ?HIMC, dwIndex: u32, dwBufLen: u32, pBuf: ?PSTR, pdwResult: ?*u32) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).GetGuideLineA(@as(*const IActiveIMMApp, @ptrCast(self)), hIMC, dwIndex, dwBufLen, pBuf, pdwResult);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMApp_GetGuideLineW(self: *const T, hIMC: ?HIMC, dwIndex: u32, dwBufLen: u32, pBuf: ?PWSTR, pdwResult: ?*u32) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).GetGuideLineW(@as(*const IActiveIMMApp, @ptrCast(self)), hIMC, dwIndex, dwBufLen, pBuf, pdwResult);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMApp_GetIMEFileNameA(self: *const T, hKL: ?HKL, uBufLen: u32, szFileName: ?PSTR, puCopied: ?*u32) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).GetIMEFileNameA(@as(*const IActiveIMMApp, @ptrCast(self)), hKL, uBufLen, szFileName, puCopied);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMApp_GetIMEFileNameW(self: *const T, hKL: ?HKL, uBufLen: u32, szFileName: ?PWSTR, puCopied: ?*u32) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).GetIMEFileNameW(@as(*const IActiveIMMApp, @ptrCast(self)), hKL, uBufLen, szFileName, puCopied);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMApp_GetOpenStatus(self: *const T, hIMC: ?HIMC) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).GetOpenStatus(@as(*const IActiveIMMApp, @ptrCast(self)), hIMC);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMApp_GetProperty(self: *const T, hKL: ?HKL, fdwIndex: u32, pdwProperty: ?*u32) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).GetProperty(@as(*const IActiveIMMApp, @ptrCast(self)), hKL, fdwIndex, pdwProperty);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMApp_GetRegisterWordStyleA(self: *const T, hKL: ?HKL, nItem: u32, pStyleBuf: ?*STYLEBUFA, puCopied: ?*u32) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).GetRegisterWordStyleA(@as(*const IActiveIMMApp, @ptrCast(self)), hKL, nItem, pStyleBuf, puCopied);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMApp_GetRegisterWordStyleW(self: *const T, hKL: ?HKL, nItem: u32, pStyleBuf: ?*STYLEBUFW, puCopied: ?*u32) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).GetRegisterWordStyleW(@as(*const IActiveIMMApp, @ptrCast(self)), hKL, nItem, pStyleBuf, puCopied);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMApp_GetStatusWindowPos(self: *const T, hIMC: ?HIMC, pptPos: ?*POINT) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).GetStatusWindowPos(@as(*const IActiveIMMApp, @ptrCast(self)), hIMC, pptPos);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMApp_GetVirtualKey(self: *const T, hWnd: ?HWND, puVirtualKey: ?*u32) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).GetVirtualKey(@as(*const IActiveIMMApp, @ptrCast(self)), hWnd, puVirtualKey);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMApp_InstallIMEA(self: *const T, szIMEFileName: ?PSTR, szLayoutText: ?PSTR, phKL: ?*?HKL) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).InstallIMEA(@as(*const IActiveIMMApp, @ptrCast(self)), szIMEFileName, szLayoutText, phKL);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMApp_InstallIMEW(self: *const T, szIMEFileName: ?PWSTR, szLayoutText: ?PWSTR, phKL: ?*?HKL) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).InstallIMEW(@as(*const IActiveIMMApp, @ptrCast(self)), szIMEFileName, szLayoutText, phKL);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMApp_IsIME(self: *const T, hKL: ?HKL) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).IsIME(@as(*const IActiveIMMApp, @ptrCast(self)), hKL);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMApp_IsUIMessageA(self: *const T, hWndIME: ?HWND, msg: u32, wParam: WPARAM, lParam: LPARAM) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).IsUIMessageA(@as(*const IActiveIMMApp, @ptrCast(self)), hWndIME, msg, wParam, lParam);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMApp_IsUIMessageW(self: *const T, hWndIME: ?HWND, msg: u32, wParam: WPARAM, lParam: LPARAM) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).IsUIMessageW(@as(*const IActiveIMMApp, @ptrCast(self)), hWndIME, msg, wParam, lParam);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMApp_NotifyIME(self: *const T, hIMC: ?HIMC, dwAction: u32, dwIndex: u32, dwValue: u32) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).NotifyIME(@as(*const IActiveIMMApp, @ptrCast(self)), hIMC, dwAction, dwIndex, dwValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMApp_RegisterWordA(self: *const T, hKL: ?HKL, szReading: ?PSTR, dwStyle: u32, szRegister: ?PSTR) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).RegisterWordA(@as(*const IActiveIMMApp, @ptrCast(self)), hKL, szReading, dwStyle, szRegister);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMApp_RegisterWordW(self: *const T, hKL: ?HKL, szReading: ?PWSTR, dwStyle: u32, szRegister: ?PWSTR) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).RegisterWordW(@as(*const IActiveIMMApp, @ptrCast(self)), hKL, szReading, dwStyle, szRegister);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMApp_ReleaseContext(self: *const T, hWnd: ?HWND, hIMC: ?HIMC) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).ReleaseContext(@as(*const IActiveIMMApp, @ptrCast(self)), hWnd, hIMC);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMApp_SetCandidateWindow(self: *const T, hIMC: ?HIMC, pCandidate: ?*CANDIDATEFORM) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).SetCandidateWindow(@as(*const IActiveIMMApp, @ptrCast(self)), hIMC, pCandidate);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMApp_SetCompositionFontA(self: *const T, hIMC: ?HIMC, plf: ?*LOGFONTA) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).SetCompositionFontA(@as(*const IActiveIMMApp, @ptrCast(self)), hIMC, plf);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMApp_SetCompositionFontW(self: *const T, hIMC: ?HIMC, plf: ?*LOGFONTW) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).SetCompositionFontW(@as(*const IActiveIMMApp, @ptrCast(self)), hIMC, plf);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMApp_SetCompositionStringA(self: *const T, hIMC: ?HIMC, dwIndex: u32, pComp: ?*anyopaque, dwCompLen: u32, pRead: ?*anyopaque, dwReadLen: u32) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).SetCompositionStringA(@as(*const IActiveIMMApp, @ptrCast(self)), hIMC, dwIndex, pComp, dwCompLen, pRead, dwReadLen);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMApp_SetCompositionStringW(self: *const T, hIMC: ?HIMC, dwIndex: u32, pComp: ?*anyopaque, dwCompLen: u32, pRead: ?*anyopaque, dwReadLen: u32) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).SetCompositionStringW(@as(*const IActiveIMMApp, @ptrCast(self)), hIMC, dwIndex, pComp, dwCompLen, pRead, dwReadLen);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMApp_SetCompositionWindow(self: *const T, hIMC: ?HIMC, pCompForm: ?*COMPOSITIONFORM) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).SetCompositionWindow(@as(*const IActiveIMMApp, @ptrCast(self)), hIMC, pCompForm);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMApp_SetConversionStatus(self: *const T, hIMC: ?HIMC, fdwConversion: u32, fdwSentence: u32) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).SetConversionStatus(@as(*const IActiveIMMApp, @ptrCast(self)), hIMC, fdwConversion, fdwSentence);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMApp_SetOpenStatus(self: *const T, hIMC: ?HIMC, fOpen: BOOL) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).SetOpenStatus(@as(*const IActiveIMMApp, @ptrCast(self)), hIMC, fOpen);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMApp_SetStatusWindowPos(self: *const T, hIMC: ?HIMC, pptPos: ?*POINT) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).SetStatusWindowPos(@as(*const IActiveIMMApp, @ptrCast(self)), hIMC, pptPos);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMApp_SimulateHotKey(self: *const T, hWnd: ?HWND, dwHotKeyID: u32) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).SimulateHotKey(@as(*const IActiveIMMApp, @ptrCast(self)), hWnd, dwHotKeyID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMApp_UnregisterWordA(self: *const T, hKL: ?HKL, szReading: ?PSTR, dwStyle: u32, szUnregister: ?PSTR) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).UnregisterWordA(@as(*const IActiveIMMApp, @ptrCast(self)), hKL, szReading, dwStyle, szUnregister);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMApp_UnregisterWordW(self: *const T, hKL: ?HKL, szReading: ?PWSTR, dwStyle: u32, szUnregister: ?PWSTR) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).UnregisterWordW(@as(*const IActiveIMMApp, @ptrCast(self)), hKL, szReading, dwStyle, szUnregister);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMApp_Activate(self: *const T, fRestoreLayout: BOOL) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).Activate(@as(*const IActiveIMMApp, @ptrCast(self)), fRestoreLayout);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMApp_Deactivate(self: *const T) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).Deactivate(@as(*const IActiveIMMApp, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMApp_OnDefWindowProc(self: *const T, hWnd: ?HWND, Msg: u32, wParam: WPARAM, lParam: LPARAM, plResult: ?*LRESULT) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).OnDefWindowProc(@as(*const IActiveIMMApp, @ptrCast(self)), hWnd, Msg, wParam, lParam, plResult);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMApp_FilterClientWindows(self: *const T, aaClassList: ?*u16, uSize: u32) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).FilterClientWindows(@as(*const IActiveIMMApp, @ptrCast(self)), aaClassList, uSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMApp_GetCodePageA(self: *const T, hKL: ?HKL, uCodePage: ?*u32) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).GetCodePageA(@as(*const IActiveIMMApp, @ptrCast(self)), hKL, uCodePage);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMApp_GetLangId(self: *const T, hKL: ?HKL, plid: ?*u16) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).GetLangId(@as(*const IActiveIMMApp, @ptrCast(self)), hKL, plid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMApp_AssociateContextEx(self: *const T, hWnd: ?HWND, hIMC: ?HIMC, dwFlags: u32) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).AssociateContextEx(@as(*const IActiveIMMApp, @ptrCast(self)), hWnd, hIMC, dwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMApp_DisableIME(self: *const T, idThread: u32) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).DisableIME(@as(*const IActiveIMMApp, @ptrCast(self)), idThread);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMApp_GetImeMenuItemsA(self: *const T, hIMC: ?HIMC, dwFlags: u32, dwType: u32, pImeParentMenu: ?*IMEMENUITEMINFOA, pImeMenu: ?*IMEMENUITEMINFOA, dwSize: u32, pdwResult: ?*u32) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).GetImeMenuItemsA(@as(*const IActiveIMMApp, @ptrCast(self)), hIMC, dwFlags, dwType, pImeParentMenu, pImeMenu, dwSize, pdwResult);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMApp_GetImeMenuItemsW(self: *const T, hIMC: ?HIMC, dwFlags: u32, dwType: u32, pImeParentMenu: ?*IMEMENUITEMINFOW, pImeMenu: ?*IMEMENUITEMINFOW, dwSize: u32, pdwResult: ?*u32) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).GetImeMenuItemsW(@as(*const IActiveIMMApp, @ptrCast(self)), hIMC, dwFlags, dwType, pImeParentMenu, pImeMenu, dwSize, pdwResult);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMApp_EnumInputContext(self: *const T, idThread: u32, ppEnum: ?*?*IEnumInputContext) HRESULT {
                return @as(*const IActiveIMMApp.VTable, @ptrCast(self.vtable)).EnumInputContext(@as(*const IActiveIMMApp, @ptrCast(self)), idThread, ppEnum);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveIMMIME_Value = Guid.initString("08c03411-f96b-11d0-a475-00aa006bcc59");
pub const IID_IActiveIMMIME = &IID_IActiveIMMIME_Value;
pub const IActiveIMMIME = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AssociateContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMIME,
                hWnd: ?HWND,
                hIME: ?HIMC,
                phPrev: ?*?HIMC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMIME,
                hWnd: ?HWND,
                hIME: ?HIMC,
                phPrev: ?*?HIMC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ConfigureIMEA: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMIME,
                hKL: ?HKL,
                hWnd: ?HWND,
                dwMode: u32,
                pData: ?*REGISTERWORDA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMIME,
                hKL: ?HKL,
                hWnd: ?HWND,
                dwMode: u32,
                pData: ?*REGISTERWORDA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ConfigureIMEW: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMIME,
                hKL: ?HKL,
                hWnd: ?HWND,
                dwMode: u32,
                pData: ?*REGISTERWORDW,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMIME,
                hKL: ?HKL,
                hWnd: ?HWND,
                dwMode: u32,
                pData: ?*REGISTERWORDW,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMIME,
                phIMC: ?*?HIMC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMIME,
                phIMC: ?*?HIMC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DestroyContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMIME,
                hIME: ?HIMC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMIME,
                hIME: ?HIMC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumRegisterWordA: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMIME,
                hKL: ?HKL,
                szReading: ?PSTR,
                dwStyle: u32,
                szRegister: ?PSTR,
                pData: ?*anyopaque,
                pEnum: ?*?*IEnumRegisterWordA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMIME,
                hKL: ?HKL,
                szReading: ?PSTR,
                dwStyle: u32,
                szRegister: ?PSTR,
                pData: ?*anyopaque,
                pEnum: ?*?*IEnumRegisterWordA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumRegisterWordW: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMIME,
                hKL: ?HKL,
                szReading: ?PWSTR,
                dwStyle: u32,
                szRegister: ?PWSTR,
                pData: ?*anyopaque,
                pEnum: ?*?*IEnumRegisterWordW,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMIME,
                hKL: ?HKL,
                szReading: ?PWSTR,
                dwStyle: u32,
                szRegister: ?PWSTR,
                pData: ?*anyopaque,
                pEnum: ?*?*IEnumRegisterWordW,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EscapeA: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMIME,
                hKL: ?HKL,
                hIMC: ?HIMC,
                uEscape: u32,
                pData: ?*anyopaque,
                plResult: ?*LRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMIME,
                hKL: ?HKL,
                hIMC: ?HIMC,
                uEscape: u32,
                pData: ?*anyopaque,
                plResult: ?*LRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EscapeW: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMIME,
                hKL: ?HKL,
                hIMC: ?HIMC,
                uEscape: u32,
                pData: ?*anyopaque,
                plResult: ?*LRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMIME,
                hKL: ?HKL,
                hIMC: ?HIMC,
                uEscape: u32,
                pData: ?*anyopaque,
                plResult: ?*LRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCandidateListA: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMIME,
                hIMC: ?HIMC,
                dwIndex: u32,
                uBufLen: u32,
                pCandList: ?*CANDIDATELIST,
                puCopied: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMIME,
                hIMC: ?HIMC,
                dwIndex: u32,
                uBufLen: u32,
                pCandList: ?*CANDIDATELIST,
                puCopied: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCandidateListW: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMIME,
                hIMC: ?HIMC,
                dwIndex: u32,
                uBufLen: u32,
                pCandList: ?*CANDIDATELIST,
                puCopied: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMIME,
                hIMC: ?HIMC,
                dwIndex: u32,
                uBufLen: u32,
                pCandList: ?*CANDIDATELIST,
                puCopied: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCandidateListCountA: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMIME,
                hIMC: ?HIMC,
                pdwListSize: ?*u32,
                pdwBufLen: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMIME,
                hIMC: ?HIMC,
                pdwListSize: ?*u32,
                pdwBufLen: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCandidateListCountW: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMIME,
                hIMC: ?HIMC,
                pdwListSize: ?*u32,
                pdwBufLen: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMIME,
                hIMC: ?HIMC,
                pdwListSize: ?*u32,
                pdwBufLen: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCandidateWindow: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMIME,
                hIMC: ?HIMC,
                dwIndex: u32,
                pCandidate: ?*CANDIDATEFORM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMIME,
                hIMC: ?HIMC,
                dwIndex: u32,
                pCandidate: ?*CANDIDATEFORM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCompositionFontA: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMIME,
                hIMC: ?HIMC,
                plf: ?*LOGFONTA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMIME,
                hIMC: ?HIMC,
                plf: ?*LOGFONTA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCompositionFontW: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMIME,
                hIMC: ?HIMC,
                plf: ?*LOGFONTW,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMIME,
                hIMC: ?HIMC,
                plf: ?*LOGFONTW,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCompositionStringA: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMIME,
                hIMC: ?HIMC,
                dwIndex: u32,
                dwBufLen: u32,
                plCopied: ?*i32,
                pBuf: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMIME,
                hIMC: ?HIMC,
                dwIndex: u32,
                dwBufLen: u32,
                plCopied: ?*i32,
                pBuf: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCompositionStringW: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMIME,
                hIMC: ?HIMC,
                dwIndex: u32,
                dwBufLen: u32,
                plCopied: ?*i32,
                pBuf: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMIME,
                hIMC: ?HIMC,
                dwIndex: u32,
                dwBufLen: u32,
                plCopied: ?*i32,
                pBuf: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCompositionWindow: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMIME,
                hIMC: ?HIMC,
                pCompForm: ?*COMPOSITIONFORM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMIME,
                hIMC: ?HIMC,
                pCompForm: ?*COMPOSITIONFORM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMIME,
                hWnd: ?HWND,
                phIMC: ?*?HIMC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMIME,
                hWnd: ?HWND,
                phIMC: ?*?HIMC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetConversionListA: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMIME,
                hKL: ?HKL,
                hIMC: ?HIMC,
                pSrc: ?PSTR,
                uBufLen: u32,
                uFlag: u32,
                pDst: ?*CANDIDATELIST,
                puCopied: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMIME,
                hKL: ?HKL,
                hIMC: ?HIMC,
                pSrc: ?PSTR,
                uBufLen: u32,
                uFlag: u32,
                pDst: ?*CANDIDATELIST,
                puCopied: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetConversionListW: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMIME,
                hKL: ?HKL,
                hIMC: ?HIMC,
                pSrc: ?PWSTR,
                uBufLen: u32,
                uFlag: u32,
                pDst: ?*CANDIDATELIST,
                puCopied: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMIME,
                hKL: ?HKL,
                hIMC: ?HIMC,
                pSrc: ?PWSTR,
                uBufLen: u32,
                uFlag: u32,
                pDst: ?*CANDIDATELIST,
                puCopied: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetConversionStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMIME,
                hIMC: ?HIMC,
                pfdwConversion: ?*u32,
                pfdwSentence: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMIME,
                hIMC: ?HIMC,
                pfdwConversion: ?*u32,
                pfdwSentence: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDefaultIMEWnd: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMIME,
                hWnd: ?HWND,
                phDefWnd: ?*?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMIME,
                hWnd: ?HWND,
                phDefWnd: ?*?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDescriptionA: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMIME,
                hKL: ?HKL,
                uBufLen: u32,
                szDescription: ?PSTR,
                puCopied: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMIME,
                hKL: ?HKL,
                uBufLen: u32,
                szDescription: ?PSTR,
                puCopied: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDescriptionW: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMIME,
                hKL: ?HKL,
                uBufLen: u32,
                szDescription: ?PWSTR,
                puCopied: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMIME,
                hKL: ?HKL,
                uBufLen: u32,
                szDescription: ?PWSTR,
                puCopied: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetGuideLineA: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMIME,
                hIMC: ?HIMC,
                dwIndex: u32,
                dwBufLen: u32,
                pBuf: ?PSTR,
                pdwResult: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMIME,
                hIMC: ?HIMC,
                dwIndex: u32,
                dwBufLen: u32,
                pBuf: ?PSTR,
                pdwResult: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetGuideLineW: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMIME,
                hIMC: ?HIMC,
                dwIndex: u32,
                dwBufLen: u32,
                pBuf: ?PWSTR,
                pdwResult: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMIME,
                hIMC: ?HIMC,
                dwIndex: u32,
                dwBufLen: u32,
                pBuf: ?PWSTR,
                pdwResult: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIMEFileNameA: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMIME,
                hKL: ?HKL,
                uBufLen: u32,
                szFileName: ?PSTR,
                puCopied: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMIME,
                hKL: ?HKL,
                uBufLen: u32,
                szFileName: ?PSTR,
                puCopied: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIMEFileNameW: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMIME,
                hKL: ?HKL,
                uBufLen: u32,
                szFileName: ?PWSTR,
                puCopied: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMIME,
                hKL: ?HKL,
                uBufLen: u32,
                szFileName: ?PWSTR,
                puCopied: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOpenStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMIME,
                hIMC: ?HIMC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMIME,
                hIMC: ?HIMC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMIME,
                hKL: ?HKL,
                fdwIndex: u32,
                pdwProperty: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMIME,
                hKL: ?HKL,
                fdwIndex: u32,
                pdwProperty: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRegisterWordStyleA: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMIME,
                hKL: ?HKL,
                nItem: u32,
                pStyleBuf: ?*STYLEBUFA,
                puCopied: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMIME,
                hKL: ?HKL,
                nItem: u32,
                pStyleBuf: ?*STYLEBUFA,
                puCopied: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRegisterWordStyleW: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMIME,
                hKL: ?HKL,
                nItem: u32,
                pStyleBuf: ?*STYLEBUFW,
                puCopied: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMIME,
                hKL: ?HKL,
                nItem: u32,
                pStyleBuf: ?*STYLEBUFW,
                puCopied: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStatusWindowPos: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMIME,
                hIMC: ?HIMC,
                pptPos: ?*POINT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMIME,
                hIMC: ?HIMC,
                pptPos: ?*POINT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVirtualKey: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMIME,
                hWnd: ?HWND,
                puVirtualKey: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMIME,
                hWnd: ?HWND,
                puVirtualKey: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InstallIMEA: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMIME,
                szIMEFileName: ?PSTR,
                szLayoutText: ?PSTR,
                phKL: ?*?HKL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMIME,
                szIMEFileName: ?PSTR,
                szLayoutText: ?PSTR,
                phKL: ?*?HKL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InstallIMEW: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMIME,
                szIMEFileName: ?PWSTR,
                szLayoutText: ?PWSTR,
                phKL: ?*?HKL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMIME,
                szIMEFileName: ?PWSTR,
                szLayoutText: ?PWSTR,
                phKL: ?*?HKL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsIME: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMIME,
                hKL: ?HKL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMIME,
                hKL: ?HKL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsUIMessageA: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMIME,
                hWndIME: ?HWND,
                msg: u32,
                wParam: WPARAM,
                lParam: LPARAM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMIME,
                hWndIME: ?HWND,
                msg: u32,
                wParam: WPARAM,
                lParam: LPARAM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsUIMessageW: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMIME,
                hWndIME: ?HWND,
                msg: u32,
                wParam: WPARAM,
                lParam: LPARAM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMIME,
                hWndIME: ?HWND,
                msg: u32,
                wParam: WPARAM,
                lParam: LPARAM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NotifyIME: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMIME,
                hIMC: ?HIMC,
                dwAction: u32,
                dwIndex: u32,
                dwValue: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMIME,
                hIMC: ?HIMC,
                dwAction: u32,
                dwIndex: u32,
                dwValue: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RegisterWordA: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMIME,
                hKL: ?HKL,
                szReading: ?PSTR,
                dwStyle: u32,
                szRegister: ?PSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMIME,
                hKL: ?HKL,
                szReading: ?PSTR,
                dwStyle: u32,
                szRegister: ?PSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RegisterWordW: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMIME,
                hKL: ?HKL,
                szReading: ?PWSTR,
                dwStyle: u32,
                szRegister: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMIME,
                hKL: ?HKL,
                szReading: ?PWSTR,
                dwStyle: u32,
                szRegister: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReleaseContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMIME,
                hWnd: ?HWND,
                hIMC: ?HIMC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMIME,
                hWnd: ?HWND,
                hIMC: ?HIMC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCandidateWindow: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMIME,
                hIMC: ?HIMC,
                pCandidate: ?*CANDIDATEFORM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMIME,
                hIMC: ?HIMC,
                pCandidate: ?*CANDIDATEFORM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCompositionFontA: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMIME,
                hIMC: ?HIMC,
                plf: ?*LOGFONTA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMIME,
                hIMC: ?HIMC,
                plf: ?*LOGFONTA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCompositionFontW: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMIME,
                hIMC: ?HIMC,
                plf: ?*LOGFONTW,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMIME,
                hIMC: ?HIMC,
                plf: ?*LOGFONTW,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCompositionStringA: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMIME,
                hIMC: ?HIMC,
                dwIndex: u32,
                pComp: ?*anyopaque,
                dwCompLen: u32,
                pRead: ?*anyopaque,
                dwReadLen: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMIME,
                hIMC: ?HIMC,
                dwIndex: u32,
                pComp: ?*anyopaque,
                dwCompLen: u32,
                pRead: ?*anyopaque,
                dwReadLen: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCompositionStringW: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMIME,
                hIMC: ?HIMC,
                dwIndex: u32,
                pComp: ?*anyopaque,
                dwCompLen: u32,
                pRead: ?*anyopaque,
                dwReadLen: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMIME,
                hIMC: ?HIMC,
                dwIndex: u32,
                pComp: ?*anyopaque,
                dwCompLen: u32,
                pRead: ?*anyopaque,
                dwReadLen: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCompositionWindow: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMIME,
                hIMC: ?HIMC,
                pCompForm: ?*COMPOSITIONFORM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMIME,
                hIMC: ?HIMC,
                pCompForm: ?*COMPOSITIONFORM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetConversionStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMIME,
                hIMC: ?HIMC,
                fdwConversion: u32,
                fdwSentence: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMIME,
                hIMC: ?HIMC,
                fdwConversion: u32,
                fdwSentence: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOpenStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMIME,
                hIMC: ?HIMC,
                fOpen: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMIME,
                hIMC: ?HIMC,
                fOpen: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetStatusWindowPos: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMIME,
                hIMC: ?HIMC,
                pptPos: ?*POINT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMIME,
                hIMC: ?HIMC,
                pptPos: ?*POINT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SimulateHotKey: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMIME,
                hWnd: ?HWND,
                dwHotKeyID: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMIME,
                hWnd: ?HWND,
                dwHotKeyID: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnregisterWordA: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMIME,
                hKL: ?HKL,
                szReading: ?PSTR,
                dwStyle: u32,
                szUnregister: ?PSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMIME,
                hKL: ?HKL,
                szReading: ?PSTR,
                dwStyle: u32,
                szUnregister: ?PSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnregisterWordW: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMIME,
                hKL: ?HKL,
                szReading: ?PWSTR,
                dwStyle: u32,
                szUnregister: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMIME,
                hKL: ?HKL,
                szReading: ?PWSTR,
                dwStyle: u32,
                szUnregister: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GenerateMessage: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMIME,
                hIMC: ?HIMC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMIME,
                hIMC: ?HIMC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LockIMC: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMIME,
                hIMC: ?HIMC,
                ppIMC: ?*?*INPUTCONTEXT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMIME,
                hIMC: ?HIMC,
                ppIMC: ?*?*INPUTCONTEXT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnlockIMC: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMIME,
                hIMC: ?HIMC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMIME,
                hIMC: ?HIMC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIMCLockCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMIME,
                hIMC: ?HIMC,
                pdwLockCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMIME,
                hIMC: ?HIMC,
                pdwLockCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateIMCC: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMIME,
                dwSize: u32,
                phIMCC: ?*?HIMCC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMIME,
                dwSize: u32,
                phIMCC: ?*?HIMCC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DestroyIMCC: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMIME,
                hIMCC: ?HIMCC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMIME,
                hIMCC: ?HIMCC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LockIMCC: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMIME,
                hIMCC: ?HIMCC,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMIME,
                hIMCC: ?HIMCC,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnlockIMCC: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMIME,
                hIMCC: ?HIMCC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMIME,
                hIMCC: ?HIMCC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReSizeIMCC: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMIME,
                hIMCC: ?HIMCC,
                dwSize: u32,
                phIMCC: ?*?HIMCC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMIME,
                hIMCC: ?HIMCC,
                dwSize: u32,
                phIMCC: ?*?HIMCC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIMCCSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMIME,
                hIMCC: ?HIMCC,
                pdwSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMIME,
                hIMCC: ?HIMCC,
                pdwSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIMCCLockCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMIME,
                hIMCC: ?HIMCC,
                pdwLockCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMIME,
                hIMCC: ?HIMCC,
                pdwLockCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetHotKey: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMIME,
                dwHotKeyID: u32,
                puModifiers: ?*u32,
                puVKey: ?*u32,
                phKL: ?*?HKL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMIME,
                dwHotKeyID: u32,
                puModifiers: ?*u32,
                puVKey: ?*u32,
                phKL: ?*?HKL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetHotKey: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMIME,
                dwHotKeyID: u32,
                uModifiers: u32,
                uVKey: u32,
                hKL: ?HKL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMIME,
                dwHotKeyID: u32,
                uModifiers: u32,
                uVKey: u32,
                hKL: ?HKL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateSoftKeyboard: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMIME,
                uType: u32,
                hOwner: ?HWND,
                x: i32,
                y: i32,
                phSoftKbdWnd: ?*?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMIME,
                uType: u32,
                hOwner: ?HWND,
                x: i32,
                y: i32,
                phSoftKbdWnd: ?*?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DestroySoftKeyboard: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMIME,
                hSoftKbdWnd: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMIME,
                hSoftKbdWnd: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ShowSoftKeyboard: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMIME,
                hSoftKbdWnd: ?HWND,
                nCmdShow: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMIME,
                hSoftKbdWnd: ?HWND,
                nCmdShow: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCodePageA: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMIME,
                hKL: ?HKL,
                uCodePage: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMIME,
                hKL: ?HKL,
                uCodePage: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLangId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMIME,
                hKL: ?HKL,
                plid: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMIME,
                hKL: ?HKL,
                plid: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        KeybdEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMIME,
                lgidIME: u16,
                bVk: u8,
                bScan: u8,
                dwFlags: u32,
                dwExtraInfo: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMIME,
                lgidIME: u16,
                bVk: u8,
                bScan: u8,
                dwFlags: u32,
                dwExtraInfo: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LockModal: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnlockModal: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AssociateContextEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMIME,
                hWnd: ?HWND,
                hIMC: ?HIMC,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMIME,
                hWnd: ?HWND,
                hIMC: ?HIMC,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DisableIME: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMIME,
                idThread: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMIME,
                idThread: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetImeMenuItemsA: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMIME,
                hIMC: ?HIMC,
                dwFlags: u32,
                dwType: u32,
                pImeParentMenu: ?*IMEMENUITEMINFOA,
                pImeMenu: ?*IMEMENUITEMINFOA,
                dwSize: u32,
                pdwResult: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMIME,
                hIMC: ?HIMC,
                dwFlags: u32,
                dwType: u32,
                pImeParentMenu: ?*IMEMENUITEMINFOA,
                pImeMenu: ?*IMEMENUITEMINFOA,
                dwSize: u32,
                pdwResult: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetImeMenuItemsW: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMIME,
                hIMC: ?HIMC,
                dwFlags: u32,
                dwType: u32,
                pImeParentMenu: ?*IMEMENUITEMINFOW,
                pImeMenu: ?*IMEMENUITEMINFOW,
                dwSize: u32,
                pdwResult: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMIME,
                hIMC: ?HIMC,
                dwFlags: u32,
                dwType: u32,
                pImeParentMenu: ?*IMEMENUITEMINFOW,
                pImeMenu: ?*IMEMENUITEMINFOW,
                dwSize: u32,
                pdwResult: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumInputContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMIME,
                idThread: u32,
                ppEnum: ?*?*IEnumInputContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMIME,
                idThread: u32,
                ppEnum: ?*?*IEnumInputContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RequestMessageA: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMIME,
                hIMC: ?HIMC,
                wParam: WPARAM,
                lParam: LPARAM,
                plResult: ?*LRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMIME,
                hIMC: ?HIMC,
                wParam: WPARAM,
                lParam: LPARAM,
                plResult: ?*LRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RequestMessageW: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMIME,
                hIMC: ?HIMC,
                wParam: WPARAM,
                lParam: LPARAM,
                plResult: ?*LRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMIME,
                hIMC: ?HIMC,
                wParam: WPARAM,
                lParam: LPARAM,
                plResult: ?*LRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SendIMCA: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMIME,
                hWnd: ?HWND,
                uMsg: u32,
                wParam: WPARAM,
                lParam: LPARAM,
                plResult: ?*LRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMIME,
                hWnd: ?HWND,
                uMsg: u32,
                wParam: WPARAM,
                lParam: LPARAM,
                plResult: ?*LRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SendIMCW: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMIME,
                hWnd: ?HWND,
                uMsg: u32,
                wParam: WPARAM,
                lParam: LPARAM,
                plResult: ?*LRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMIME,
                hWnd: ?HWND,
                uMsg: u32,
                wParam: WPARAM,
                lParam: LPARAM,
                plResult: ?*LRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsSleeping: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIMMIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIMMIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMIME_AssociateContext(self: *const T, hWnd: ?HWND, hIME: ?HIMC, phPrev: ?*?HIMC) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).AssociateContext(@as(*const IActiveIMMIME, @ptrCast(self)), hWnd, hIME, phPrev);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMIME_ConfigureIMEA(self: *const T, hKL: ?HKL, hWnd: ?HWND, dwMode: u32, pData: ?*REGISTERWORDA) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).ConfigureIMEA(@as(*const IActiveIMMIME, @ptrCast(self)), hKL, hWnd, dwMode, pData);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMIME_ConfigureIMEW(self: *const T, hKL: ?HKL, hWnd: ?HWND, dwMode: u32, pData: ?*REGISTERWORDW) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).ConfigureIMEW(@as(*const IActiveIMMIME, @ptrCast(self)), hKL, hWnd, dwMode, pData);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMIME_CreateContext(self: *const T, phIMC: ?*?HIMC) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).CreateContext(@as(*const IActiveIMMIME, @ptrCast(self)), phIMC);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMIME_DestroyContext(self: *const T, hIME: ?HIMC) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).DestroyContext(@as(*const IActiveIMMIME, @ptrCast(self)), hIME);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMIME_EnumRegisterWordA(self: *const T, hKL: ?HKL, szReading: ?PSTR, dwStyle: u32, szRegister: ?PSTR, pData: ?*anyopaque, pEnum: ?*?*IEnumRegisterWordA) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).EnumRegisterWordA(@as(*const IActiveIMMIME, @ptrCast(self)), hKL, szReading, dwStyle, szRegister, pData, pEnum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMIME_EnumRegisterWordW(self: *const T, hKL: ?HKL, szReading: ?PWSTR, dwStyle: u32, szRegister: ?PWSTR, pData: ?*anyopaque, pEnum: ?*?*IEnumRegisterWordW) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).EnumRegisterWordW(@as(*const IActiveIMMIME, @ptrCast(self)), hKL, szReading, dwStyle, szRegister, pData, pEnum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMIME_EscapeA(self: *const T, hKL: ?HKL, hIMC: ?HIMC, uEscape: u32, pData: ?*anyopaque, plResult: ?*LRESULT) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).EscapeA(@as(*const IActiveIMMIME, @ptrCast(self)), hKL, hIMC, uEscape, pData, plResult);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMIME_EscapeW(self: *const T, hKL: ?HKL, hIMC: ?HIMC, uEscape: u32, pData: ?*anyopaque, plResult: ?*LRESULT) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).EscapeW(@as(*const IActiveIMMIME, @ptrCast(self)), hKL, hIMC, uEscape, pData, plResult);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMIME_GetCandidateListA(self: *const T, hIMC: ?HIMC, dwIndex: u32, uBufLen: u32, pCandList: ?*CANDIDATELIST, puCopied: ?*u32) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).GetCandidateListA(@as(*const IActiveIMMIME, @ptrCast(self)), hIMC, dwIndex, uBufLen, pCandList, puCopied);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMIME_GetCandidateListW(self: *const T, hIMC: ?HIMC, dwIndex: u32, uBufLen: u32, pCandList: ?*CANDIDATELIST, puCopied: ?*u32) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).GetCandidateListW(@as(*const IActiveIMMIME, @ptrCast(self)), hIMC, dwIndex, uBufLen, pCandList, puCopied);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMIME_GetCandidateListCountA(self: *const T, hIMC: ?HIMC, pdwListSize: ?*u32, pdwBufLen: ?*u32) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).GetCandidateListCountA(@as(*const IActiveIMMIME, @ptrCast(self)), hIMC, pdwListSize, pdwBufLen);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMIME_GetCandidateListCountW(self: *const T, hIMC: ?HIMC, pdwListSize: ?*u32, pdwBufLen: ?*u32) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).GetCandidateListCountW(@as(*const IActiveIMMIME, @ptrCast(self)), hIMC, pdwListSize, pdwBufLen);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMIME_GetCandidateWindow(self: *const T, hIMC: ?HIMC, dwIndex: u32, pCandidate: ?*CANDIDATEFORM) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).GetCandidateWindow(@as(*const IActiveIMMIME, @ptrCast(self)), hIMC, dwIndex, pCandidate);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMIME_GetCompositionFontA(self: *const T, hIMC: ?HIMC, plf: ?*LOGFONTA) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).GetCompositionFontA(@as(*const IActiveIMMIME, @ptrCast(self)), hIMC, plf);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMIME_GetCompositionFontW(self: *const T, hIMC: ?HIMC, plf: ?*LOGFONTW) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).GetCompositionFontW(@as(*const IActiveIMMIME, @ptrCast(self)), hIMC, plf);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMIME_GetCompositionStringA(self: *const T, hIMC: ?HIMC, dwIndex: u32, dwBufLen: u32, plCopied: ?*i32, pBuf: ?*anyopaque) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).GetCompositionStringA(@as(*const IActiveIMMIME, @ptrCast(self)), hIMC, dwIndex, dwBufLen, plCopied, pBuf);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMIME_GetCompositionStringW(self: *const T, hIMC: ?HIMC, dwIndex: u32, dwBufLen: u32, plCopied: ?*i32, pBuf: ?*anyopaque) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).GetCompositionStringW(@as(*const IActiveIMMIME, @ptrCast(self)), hIMC, dwIndex, dwBufLen, plCopied, pBuf);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMIME_GetCompositionWindow(self: *const T, hIMC: ?HIMC, pCompForm: ?*COMPOSITIONFORM) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).GetCompositionWindow(@as(*const IActiveIMMIME, @ptrCast(self)), hIMC, pCompForm);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMIME_GetContext(self: *const T, hWnd: ?HWND, phIMC: ?*?HIMC) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).GetContext(@as(*const IActiveIMMIME, @ptrCast(self)), hWnd, phIMC);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMIME_GetConversionListA(self: *const T, hKL: ?HKL, hIMC: ?HIMC, pSrc: ?PSTR, uBufLen: u32, uFlag: u32, pDst: ?*CANDIDATELIST, puCopied: ?*u32) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).GetConversionListA(@as(*const IActiveIMMIME, @ptrCast(self)), hKL, hIMC, pSrc, uBufLen, uFlag, pDst, puCopied);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMIME_GetConversionListW(self: *const T, hKL: ?HKL, hIMC: ?HIMC, pSrc: ?PWSTR, uBufLen: u32, uFlag: u32, pDst: ?*CANDIDATELIST, puCopied: ?*u32) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).GetConversionListW(@as(*const IActiveIMMIME, @ptrCast(self)), hKL, hIMC, pSrc, uBufLen, uFlag, pDst, puCopied);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMIME_GetConversionStatus(self: *const T, hIMC: ?HIMC, pfdwConversion: ?*u32, pfdwSentence: ?*u32) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).GetConversionStatus(@as(*const IActiveIMMIME, @ptrCast(self)), hIMC, pfdwConversion, pfdwSentence);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMIME_GetDefaultIMEWnd(self: *const T, hWnd: ?HWND, phDefWnd: ?*?HWND) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).GetDefaultIMEWnd(@as(*const IActiveIMMIME, @ptrCast(self)), hWnd, phDefWnd);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMIME_GetDescriptionA(self: *const T, hKL: ?HKL, uBufLen: u32, szDescription: ?PSTR, puCopied: ?*u32) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).GetDescriptionA(@as(*const IActiveIMMIME, @ptrCast(self)), hKL, uBufLen, szDescription, puCopied);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMIME_GetDescriptionW(self: *const T, hKL: ?HKL, uBufLen: u32, szDescription: ?PWSTR, puCopied: ?*u32) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).GetDescriptionW(@as(*const IActiveIMMIME, @ptrCast(self)), hKL, uBufLen, szDescription, puCopied);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMIME_GetGuideLineA(self: *const T, hIMC: ?HIMC, dwIndex: u32, dwBufLen: u32, pBuf: ?PSTR, pdwResult: ?*u32) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).GetGuideLineA(@as(*const IActiveIMMIME, @ptrCast(self)), hIMC, dwIndex, dwBufLen, pBuf, pdwResult);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMIME_GetGuideLineW(self: *const T, hIMC: ?HIMC, dwIndex: u32, dwBufLen: u32, pBuf: ?PWSTR, pdwResult: ?*u32) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).GetGuideLineW(@as(*const IActiveIMMIME, @ptrCast(self)), hIMC, dwIndex, dwBufLen, pBuf, pdwResult);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMIME_GetIMEFileNameA(self: *const T, hKL: ?HKL, uBufLen: u32, szFileName: ?PSTR, puCopied: ?*u32) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).GetIMEFileNameA(@as(*const IActiveIMMIME, @ptrCast(self)), hKL, uBufLen, szFileName, puCopied);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMIME_GetIMEFileNameW(self: *const T, hKL: ?HKL, uBufLen: u32, szFileName: ?PWSTR, puCopied: ?*u32) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).GetIMEFileNameW(@as(*const IActiveIMMIME, @ptrCast(self)), hKL, uBufLen, szFileName, puCopied);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMIME_GetOpenStatus(self: *const T, hIMC: ?HIMC) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).GetOpenStatus(@as(*const IActiveIMMIME, @ptrCast(self)), hIMC);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMIME_GetProperty(self: *const T, hKL: ?HKL, fdwIndex: u32, pdwProperty: ?*u32) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).GetProperty(@as(*const IActiveIMMIME, @ptrCast(self)), hKL, fdwIndex, pdwProperty);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMIME_GetRegisterWordStyleA(self: *const T, hKL: ?HKL, nItem: u32, pStyleBuf: ?*STYLEBUFA, puCopied: ?*u32) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).GetRegisterWordStyleA(@as(*const IActiveIMMIME, @ptrCast(self)), hKL, nItem, pStyleBuf, puCopied);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMIME_GetRegisterWordStyleW(self: *const T, hKL: ?HKL, nItem: u32, pStyleBuf: ?*STYLEBUFW, puCopied: ?*u32) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).GetRegisterWordStyleW(@as(*const IActiveIMMIME, @ptrCast(self)), hKL, nItem, pStyleBuf, puCopied);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMIME_GetStatusWindowPos(self: *const T, hIMC: ?HIMC, pptPos: ?*POINT) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).GetStatusWindowPos(@as(*const IActiveIMMIME, @ptrCast(self)), hIMC, pptPos);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMIME_GetVirtualKey(self: *const T, hWnd: ?HWND, puVirtualKey: ?*u32) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).GetVirtualKey(@as(*const IActiveIMMIME, @ptrCast(self)), hWnd, puVirtualKey);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMIME_InstallIMEA(self: *const T, szIMEFileName: ?PSTR, szLayoutText: ?PSTR, phKL: ?*?HKL) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).InstallIMEA(@as(*const IActiveIMMIME, @ptrCast(self)), szIMEFileName, szLayoutText, phKL);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMIME_InstallIMEW(self: *const T, szIMEFileName: ?PWSTR, szLayoutText: ?PWSTR, phKL: ?*?HKL) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).InstallIMEW(@as(*const IActiveIMMIME, @ptrCast(self)), szIMEFileName, szLayoutText, phKL);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMIME_IsIME(self: *const T, hKL: ?HKL) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).IsIME(@as(*const IActiveIMMIME, @ptrCast(self)), hKL);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMIME_IsUIMessageA(self: *const T, hWndIME: ?HWND, msg: u32, wParam: WPARAM, lParam: LPARAM) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).IsUIMessageA(@as(*const IActiveIMMIME, @ptrCast(self)), hWndIME, msg, wParam, lParam);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMIME_IsUIMessageW(self: *const T, hWndIME: ?HWND, msg: u32, wParam: WPARAM, lParam: LPARAM) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).IsUIMessageW(@as(*const IActiveIMMIME, @ptrCast(self)), hWndIME, msg, wParam, lParam);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMIME_NotifyIME(self: *const T, hIMC: ?HIMC, dwAction: u32, dwIndex: u32, dwValue: u32) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).NotifyIME(@as(*const IActiveIMMIME, @ptrCast(self)), hIMC, dwAction, dwIndex, dwValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMIME_RegisterWordA(self: *const T, hKL: ?HKL, szReading: ?PSTR, dwStyle: u32, szRegister: ?PSTR) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).RegisterWordA(@as(*const IActiveIMMIME, @ptrCast(self)), hKL, szReading, dwStyle, szRegister);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMIME_RegisterWordW(self: *const T, hKL: ?HKL, szReading: ?PWSTR, dwStyle: u32, szRegister: ?PWSTR) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).RegisterWordW(@as(*const IActiveIMMIME, @ptrCast(self)), hKL, szReading, dwStyle, szRegister);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMIME_ReleaseContext(self: *const T, hWnd: ?HWND, hIMC: ?HIMC) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).ReleaseContext(@as(*const IActiveIMMIME, @ptrCast(self)), hWnd, hIMC);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMIME_SetCandidateWindow(self: *const T, hIMC: ?HIMC, pCandidate: ?*CANDIDATEFORM) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).SetCandidateWindow(@as(*const IActiveIMMIME, @ptrCast(self)), hIMC, pCandidate);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMIME_SetCompositionFontA(self: *const T, hIMC: ?HIMC, plf: ?*LOGFONTA) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).SetCompositionFontA(@as(*const IActiveIMMIME, @ptrCast(self)), hIMC, plf);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMIME_SetCompositionFontW(self: *const T, hIMC: ?HIMC, plf: ?*LOGFONTW) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).SetCompositionFontW(@as(*const IActiveIMMIME, @ptrCast(self)), hIMC, plf);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMIME_SetCompositionStringA(self: *const T, hIMC: ?HIMC, dwIndex: u32, pComp: ?*anyopaque, dwCompLen: u32, pRead: ?*anyopaque, dwReadLen: u32) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).SetCompositionStringA(@as(*const IActiveIMMIME, @ptrCast(self)), hIMC, dwIndex, pComp, dwCompLen, pRead, dwReadLen);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMIME_SetCompositionStringW(self: *const T, hIMC: ?HIMC, dwIndex: u32, pComp: ?*anyopaque, dwCompLen: u32, pRead: ?*anyopaque, dwReadLen: u32) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).SetCompositionStringW(@as(*const IActiveIMMIME, @ptrCast(self)), hIMC, dwIndex, pComp, dwCompLen, pRead, dwReadLen);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMIME_SetCompositionWindow(self: *const T, hIMC: ?HIMC, pCompForm: ?*COMPOSITIONFORM) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).SetCompositionWindow(@as(*const IActiveIMMIME, @ptrCast(self)), hIMC, pCompForm);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMIME_SetConversionStatus(self: *const T, hIMC: ?HIMC, fdwConversion: u32, fdwSentence: u32) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).SetConversionStatus(@as(*const IActiveIMMIME, @ptrCast(self)), hIMC, fdwConversion, fdwSentence);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMIME_SetOpenStatus(self: *const T, hIMC: ?HIMC, fOpen: BOOL) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).SetOpenStatus(@as(*const IActiveIMMIME, @ptrCast(self)), hIMC, fOpen);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMIME_SetStatusWindowPos(self: *const T, hIMC: ?HIMC, pptPos: ?*POINT) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).SetStatusWindowPos(@as(*const IActiveIMMIME, @ptrCast(self)), hIMC, pptPos);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMIME_SimulateHotKey(self: *const T, hWnd: ?HWND, dwHotKeyID: u32) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).SimulateHotKey(@as(*const IActiveIMMIME, @ptrCast(self)), hWnd, dwHotKeyID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMIME_UnregisterWordA(self: *const T, hKL: ?HKL, szReading: ?PSTR, dwStyle: u32, szUnregister: ?PSTR) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).UnregisterWordA(@as(*const IActiveIMMIME, @ptrCast(self)), hKL, szReading, dwStyle, szUnregister);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMIME_UnregisterWordW(self: *const T, hKL: ?HKL, szReading: ?PWSTR, dwStyle: u32, szUnregister: ?PWSTR) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).UnregisterWordW(@as(*const IActiveIMMIME, @ptrCast(self)), hKL, szReading, dwStyle, szUnregister);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMIME_GenerateMessage(self: *const T, hIMC: ?HIMC) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).GenerateMessage(@as(*const IActiveIMMIME, @ptrCast(self)), hIMC);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMIME_LockIMC(self: *const T, hIMC: ?HIMC, ppIMC: ?*?*INPUTCONTEXT) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).LockIMC(@as(*const IActiveIMMIME, @ptrCast(self)), hIMC, ppIMC);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMIME_UnlockIMC(self: *const T, hIMC: ?HIMC) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).UnlockIMC(@as(*const IActiveIMMIME, @ptrCast(self)), hIMC);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMIME_GetIMCLockCount(self: *const T, hIMC: ?HIMC, pdwLockCount: ?*u32) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).GetIMCLockCount(@as(*const IActiveIMMIME, @ptrCast(self)), hIMC, pdwLockCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMIME_CreateIMCC(self: *const T, dwSize: u32, phIMCC: ?*?HIMCC) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).CreateIMCC(@as(*const IActiveIMMIME, @ptrCast(self)), dwSize, phIMCC);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMIME_DestroyIMCC(self: *const T, hIMCC: ?HIMCC) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).DestroyIMCC(@as(*const IActiveIMMIME, @ptrCast(self)), hIMCC);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMIME_LockIMCC(self: *const T, hIMCC: ?HIMCC, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).LockIMCC(@as(*const IActiveIMMIME, @ptrCast(self)), hIMCC, ppv);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMIME_UnlockIMCC(self: *const T, hIMCC: ?HIMCC) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).UnlockIMCC(@as(*const IActiveIMMIME, @ptrCast(self)), hIMCC);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMIME_ReSizeIMCC(self: *const T, hIMCC: ?HIMCC, dwSize: u32, phIMCC: ?*?HIMCC) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).ReSizeIMCC(@as(*const IActiveIMMIME, @ptrCast(self)), hIMCC, dwSize, phIMCC);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMIME_GetIMCCSize(self: *const T, hIMCC: ?HIMCC, pdwSize: ?*u32) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).GetIMCCSize(@as(*const IActiveIMMIME, @ptrCast(self)), hIMCC, pdwSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMIME_GetIMCCLockCount(self: *const T, hIMCC: ?HIMCC, pdwLockCount: ?*u32) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).GetIMCCLockCount(@as(*const IActiveIMMIME, @ptrCast(self)), hIMCC, pdwLockCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMIME_GetHotKey(self: *const T, dwHotKeyID: u32, puModifiers: ?*u32, puVKey: ?*u32, phKL: ?*?HKL) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).GetHotKey(@as(*const IActiveIMMIME, @ptrCast(self)), dwHotKeyID, puModifiers, puVKey, phKL);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMIME_SetHotKey(self: *const T, dwHotKeyID: u32, uModifiers: u32, uVKey: u32, hKL: ?HKL) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).SetHotKey(@as(*const IActiveIMMIME, @ptrCast(self)), dwHotKeyID, uModifiers, uVKey, hKL);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMIME_CreateSoftKeyboard(self: *const T, uType: u32, hOwner: ?HWND, x: i32, y: i32, phSoftKbdWnd: ?*?HWND) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).CreateSoftKeyboard(@as(*const IActiveIMMIME, @ptrCast(self)), uType, hOwner, x, y, phSoftKbdWnd);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMIME_DestroySoftKeyboard(self: *const T, hSoftKbdWnd: ?HWND) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).DestroySoftKeyboard(@as(*const IActiveIMMIME, @ptrCast(self)), hSoftKbdWnd);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMIME_ShowSoftKeyboard(self: *const T, hSoftKbdWnd: ?HWND, nCmdShow: i32) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).ShowSoftKeyboard(@as(*const IActiveIMMIME, @ptrCast(self)), hSoftKbdWnd, nCmdShow);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMIME_GetCodePageA(self: *const T, hKL: ?HKL, uCodePage: ?*u32) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).GetCodePageA(@as(*const IActiveIMMIME, @ptrCast(self)), hKL, uCodePage);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMIME_GetLangId(self: *const T, hKL: ?HKL, plid: ?*u16) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).GetLangId(@as(*const IActiveIMMIME, @ptrCast(self)), hKL, plid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMIME_KeybdEvent(self: *const T, lgidIME: u16, bVk: u8, bScan: u8, dwFlags: u32, dwExtraInfo: u32) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).KeybdEvent(@as(*const IActiveIMMIME, @ptrCast(self)), lgidIME, bVk, bScan, dwFlags, dwExtraInfo);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMIME_LockModal(self: *const T) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).LockModal(@as(*const IActiveIMMIME, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMIME_UnlockModal(self: *const T) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).UnlockModal(@as(*const IActiveIMMIME, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMIME_AssociateContextEx(self: *const T, hWnd: ?HWND, hIMC: ?HIMC, dwFlags: u32) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).AssociateContextEx(@as(*const IActiveIMMIME, @ptrCast(self)), hWnd, hIMC, dwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMIME_DisableIME(self: *const T, idThread: u32) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).DisableIME(@as(*const IActiveIMMIME, @ptrCast(self)), idThread);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMIME_GetImeMenuItemsA(self: *const T, hIMC: ?HIMC, dwFlags: u32, dwType: u32, pImeParentMenu: ?*IMEMENUITEMINFOA, pImeMenu: ?*IMEMENUITEMINFOA, dwSize: u32, pdwResult: ?*u32) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).GetImeMenuItemsA(@as(*const IActiveIMMIME, @ptrCast(self)), hIMC, dwFlags, dwType, pImeParentMenu, pImeMenu, dwSize, pdwResult);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMIME_GetImeMenuItemsW(self: *const T, hIMC: ?HIMC, dwFlags: u32, dwType: u32, pImeParentMenu: ?*IMEMENUITEMINFOW, pImeMenu: ?*IMEMENUITEMINFOW, dwSize: u32, pdwResult: ?*u32) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).GetImeMenuItemsW(@as(*const IActiveIMMIME, @ptrCast(self)), hIMC, dwFlags, dwType, pImeParentMenu, pImeMenu, dwSize, pdwResult);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMIME_EnumInputContext(self: *const T, idThread: u32, ppEnum: ?*?*IEnumInputContext) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).EnumInputContext(@as(*const IActiveIMMIME, @ptrCast(self)), idThread, ppEnum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMIME_RequestMessageA(self: *const T, hIMC: ?HIMC, wParam: WPARAM, lParam: LPARAM, plResult: ?*LRESULT) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).RequestMessageA(@as(*const IActiveIMMIME, @ptrCast(self)), hIMC, wParam, lParam, plResult);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMIME_RequestMessageW(self: *const T, hIMC: ?HIMC, wParam: WPARAM, lParam: LPARAM, plResult: ?*LRESULT) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).RequestMessageW(@as(*const IActiveIMMIME, @ptrCast(self)), hIMC, wParam, lParam, plResult);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMIME_SendIMCA(self: *const T, hWnd: ?HWND, uMsg: u32, wParam: WPARAM, lParam: LPARAM, plResult: ?*LRESULT) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).SendIMCA(@as(*const IActiveIMMIME, @ptrCast(self)), hWnd, uMsg, wParam, lParam, plResult);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMIME_SendIMCW(self: *const T, hWnd: ?HWND, uMsg: u32, wParam: WPARAM, lParam: LPARAM, plResult: ?*LRESULT) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).SendIMCW(@as(*const IActiveIMMIME, @ptrCast(self)), hWnd, uMsg, wParam, lParam, plResult);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIMMIME_IsSleeping(self: *const T) HRESULT {
                return @as(*const IActiveIMMIME.VTable, @ptrCast(self.vtable)).IsSleeping(@as(*const IActiveIMMIME, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveIME_Value = Guid.initString("6fe20962-d077-11d0-8fe7-00aa006bcc59");
pub const IID_IActiveIME = &IID_IActiveIME_Value;
pub const IActiveIME = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Inquire: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIME,
                dwSystemInfoFlags: u32,
                pIMEInfo: ?*IMEINFO,
                szWndClass: ?PWSTR,
                pdwPrivate: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIME,
                dwSystemInfoFlags: u32,
                pIMEInfo: ?*IMEINFO,
                szWndClass: ?PWSTR,
                pdwPrivate: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ConversionList: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIME,
                hIMC: ?HIMC,
                szSource: ?PWSTR,
                uFlag: u32,
                uBufLen: u32,
                pDest: ?*CANDIDATELIST,
                puCopied: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIME,
                hIMC: ?HIMC,
                szSource: ?PWSTR,
                uFlag: u32,
                uBufLen: u32,
                pDest: ?*CANDIDATELIST,
                puCopied: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Configure: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIME,
                hKL: ?HKL,
                hWnd: ?HWND,
                dwMode: u32,
                pRegisterWord: ?*REGISTERWORDW,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIME,
                hKL: ?HKL,
                hWnd: ?HWND,
                dwMode: u32,
                pRegisterWord: ?*REGISTERWORDW,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Destroy: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIME,
                uReserved: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIME,
                uReserved: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Escape: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIME,
                hIMC: ?HIMC,
                uEscape: u32,
                pData: ?*anyopaque,
                plResult: ?*LRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIME,
                hIMC: ?HIMC,
                uEscape: u32,
                pData: ?*anyopaque,
                plResult: ?*LRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetActiveContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIME,
                hIMC: ?HIMC,
                fFlag: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIME,
                hIMC: ?HIMC,
                fFlag: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ProcessKey: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIME,
                hIMC: ?HIMC,
                uVirKey: u32,
                lParam: u32,
                pbKeyState: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIME,
                hIMC: ?HIMC,
                uVirKey: u32,
                lParam: u32,
                pbKeyState: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Notify: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIME,
                hIMC: ?HIMC,
                dwAction: u32,
                dwIndex: u32,
                dwValue: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIME,
                hIMC: ?HIMC,
                dwAction: u32,
                dwIndex: u32,
                dwValue: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Select: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIME,
                hIMC: ?HIMC,
                fSelect: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIME,
                hIMC: ?HIMC,
                fSelect: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCompositionString: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIME,
                hIMC: ?HIMC,
                dwIndex: u32,
                pComp: ?*anyopaque,
                dwCompLen: u32,
                pRead: ?*anyopaque,
                dwReadLen: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIME,
                hIMC: ?HIMC,
                dwIndex: u32,
                pComp: ?*anyopaque,
                dwCompLen: u32,
                pRead: ?*anyopaque,
                dwReadLen: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ToAsciiEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIME,
                uVirKey: u32,
                uScanCode: u32,
                pbKeyState: ?*u8,
                fuState: u32,
                hIMC: ?HIMC,
                pdwTransBuf: ?*u32,
                puSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIME,
                uVirKey: u32,
                uScanCode: u32,
                pbKeyState: ?*u8,
                fuState: u32,
                hIMC: ?HIMC,
                pdwTransBuf: ?*u32,
                puSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RegisterWord: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIME,
                szReading: ?PWSTR,
                dwStyle: u32,
                szString: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIME,
                szReading: ?PWSTR,
                dwStyle: u32,
                szString: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnregisterWord: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIME,
                szReading: ?PWSTR,
                dwStyle: u32,
                szString: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIME,
                szReading: ?PWSTR,
                dwStyle: u32,
                szString: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRegisterWordStyle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIME,
                nItem: u32,
                pStyleBuf: ?*STYLEBUFW,
                puBufSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIME,
                nItem: u32,
                pStyleBuf: ?*STYLEBUFW,
                puBufSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumRegisterWord: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIME,
                szReading: ?PWSTR,
                dwStyle: u32,
                szRegister: ?PWSTR,
                pData: ?*anyopaque,
                ppEnum: ?*?*IEnumRegisterWordW,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIME,
                szReading: ?PWSTR,
                dwStyle: u32,
                szRegister: ?PWSTR,
                pData: ?*anyopaque,
                ppEnum: ?*?*IEnumRegisterWordW,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCodePageA: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIME,
                uCodePage: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIME,
                uCodePage: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLangId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIME,
                plid: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIME,
                plid: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIME_Inquire(self: *const T, dwSystemInfoFlags: u32, pIMEInfo: ?*IMEINFO, szWndClass: ?PWSTR, pdwPrivate: ?*u32) HRESULT {
                return @as(*const IActiveIME.VTable, @ptrCast(self.vtable)).Inquire(@as(*const IActiveIME, @ptrCast(self)), dwSystemInfoFlags, pIMEInfo, szWndClass, pdwPrivate);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIME_ConversionList(self: *const T, hIMC: ?HIMC, szSource: ?PWSTR, uFlag: u32, uBufLen: u32, pDest: ?*CANDIDATELIST, puCopied: ?*u32) HRESULT {
                return @as(*const IActiveIME.VTable, @ptrCast(self.vtable)).ConversionList(@as(*const IActiveIME, @ptrCast(self)), hIMC, szSource, uFlag, uBufLen, pDest, puCopied);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIME_Configure(self: *const T, hKL: ?HKL, hWnd: ?HWND, dwMode: u32, pRegisterWord: ?*REGISTERWORDW) HRESULT {
                return @as(*const IActiveIME.VTable, @ptrCast(self.vtable)).Configure(@as(*const IActiveIME, @ptrCast(self)), hKL, hWnd, dwMode, pRegisterWord);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIME_Destroy(self: *const T, uReserved: u32) HRESULT {
                return @as(*const IActiveIME.VTable, @ptrCast(self.vtable)).Destroy(@as(*const IActiveIME, @ptrCast(self)), uReserved);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIME_Escape(self: *const T, hIMC: ?HIMC, uEscape: u32, pData: ?*anyopaque, plResult: ?*LRESULT) HRESULT {
                return @as(*const IActiveIME.VTable, @ptrCast(self.vtable)).Escape(@as(*const IActiveIME, @ptrCast(self)), hIMC, uEscape, pData, plResult);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIME_SetActiveContext(self: *const T, hIMC: ?HIMC, fFlag: BOOL) HRESULT {
                return @as(*const IActiveIME.VTable, @ptrCast(self.vtable)).SetActiveContext(@as(*const IActiveIME, @ptrCast(self)), hIMC, fFlag);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIME_ProcessKey(self: *const T, hIMC: ?HIMC, uVirKey: u32, lParam: u32, pbKeyState: ?*u8) HRESULT {
                return @as(*const IActiveIME.VTable, @ptrCast(self.vtable)).ProcessKey(@as(*const IActiveIME, @ptrCast(self)), hIMC, uVirKey, lParam, pbKeyState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIME_Notify(self: *const T, hIMC: ?HIMC, dwAction: u32, dwIndex: u32, dwValue: u32) HRESULT {
                return @as(*const IActiveIME.VTable, @ptrCast(self.vtable)).Notify(@as(*const IActiveIME, @ptrCast(self)), hIMC, dwAction, dwIndex, dwValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIME_Select(self: *const T, hIMC: ?HIMC, fSelect: BOOL) HRESULT {
                return @as(*const IActiveIME.VTable, @ptrCast(self.vtable)).Select(@as(*const IActiveIME, @ptrCast(self)), hIMC, fSelect);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIME_SetCompositionString(self: *const T, hIMC: ?HIMC, dwIndex: u32, pComp: ?*anyopaque, dwCompLen: u32, pRead: ?*anyopaque, dwReadLen: u32) HRESULT {
                return @as(*const IActiveIME.VTable, @ptrCast(self.vtable)).SetCompositionString(@as(*const IActiveIME, @ptrCast(self)), hIMC, dwIndex, pComp, dwCompLen, pRead, dwReadLen);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIME_ToAsciiEx(self: *const T, uVirKey: u32, uScanCode: u32, pbKeyState: ?*u8, fuState: u32, hIMC: ?HIMC, pdwTransBuf: ?*u32, puSize: ?*u32) HRESULT {
                return @as(*const IActiveIME.VTable, @ptrCast(self.vtable)).ToAsciiEx(@as(*const IActiveIME, @ptrCast(self)), uVirKey, uScanCode, pbKeyState, fuState, hIMC, pdwTransBuf, puSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIME_RegisterWord(self: *const T, szReading: ?PWSTR, dwStyle: u32, szString: ?PWSTR) HRESULT {
                return @as(*const IActiveIME.VTable, @ptrCast(self.vtable)).RegisterWord(@as(*const IActiveIME, @ptrCast(self)), szReading, dwStyle, szString);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIME_UnregisterWord(self: *const T, szReading: ?PWSTR, dwStyle: u32, szString: ?PWSTR) HRESULT {
                return @as(*const IActiveIME.VTable, @ptrCast(self.vtable)).UnregisterWord(@as(*const IActiveIME, @ptrCast(self)), szReading, dwStyle, szString);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIME_GetRegisterWordStyle(self: *const T, nItem: u32, pStyleBuf: ?*STYLEBUFW, puBufSize: ?*u32) HRESULT {
                return @as(*const IActiveIME.VTable, @ptrCast(self.vtable)).GetRegisterWordStyle(@as(*const IActiveIME, @ptrCast(self)), nItem, pStyleBuf, puBufSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIME_EnumRegisterWord(self: *const T, szReading: ?PWSTR, dwStyle: u32, szRegister: ?PWSTR, pData: ?*anyopaque, ppEnum: ?*?*IEnumRegisterWordW) HRESULT {
                return @as(*const IActiveIME.VTable, @ptrCast(self.vtable)).EnumRegisterWord(@as(*const IActiveIME, @ptrCast(self)), szReading, dwStyle, szRegister, pData, ppEnum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIME_GetCodePageA(self: *const T, uCodePage: ?*u32) HRESULT {
                return @as(*const IActiveIME.VTable, @ptrCast(self.vtable)).GetCodePageA(@as(*const IActiveIME, @ptrCast(self)), uCodePage);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIME_GetLangId(self: *const T, plid: ?*u16) HRESULT {
                return @as(*const IActiveIME.VTable, @ptrCast(self.vtable)).GetLangId(@as(*const IActiveIME, @ptrCast(self)), plid);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveIME2_Value = Guid.initString("e1c4bf0e-2d53-11d2-93e1-0060b067b86e");
pub const IID_IActiveIME2 = &IID_IActiveIME2_Value;
pub const IActiveIME2 = extern struct {
    pub const VTable = extern struct {
        base: IActiveIME.VTable,
        Sleep: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIME2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIME2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Unsleep: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveIME2,
                fDead: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveIME2,
                fDead: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IActiveIME.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIME2_Sleep(self: *const T) HRESULT {
                return @as(*const IActiveIME2.VTable, @ptrCast(self.vtable)).Sleep(@as(*const IActiveIME2, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveIME2_Unsleep(self: *const T, fDead: BOOL) HRESULT {
                return @as(*const IActiveIME2.VTable, @ptrCast(self.vtable)).Unsleep(@as(*const IActiveIME2, @ptrCast(self)), fDead);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

//--------------------------------------------------------------------------------
// Section: Functions (82)
//--------------------------------------------------------------------------------
// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmInstallIMEA(
    lpszIMEFileName: ?[*:0]const u8,
    lpszLayoutText: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) ?HKL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmInstallIMEW(
    lpszIMEFileName: ?[*:0]const u16,
    lpszLayoutText: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) ?HKL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmGetDefaultIMEWnd(
    param0: ?HWND,
) callconv(@import("std").os.windows.WINAPI) ?HWND;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmGetDescriptionA(
    param0: ?HKL,
    lpszDescription: ?[*:0]u8,
    uBufLen: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmGetDescriptionW(
    param0: ?HKL,
    lpszDescription: ?[*:0]u16,
    uBufLen: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmGetIMEFileNameA(
    param0: ?HKL,
    lpszFileName: ?[*:0]u8,
    uBufLen: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmGetIMEFileNameW(
    param0: ?HKL,
    lpszFileName: ?[*:0]u16,
    uBufLen: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmGetProperty(
    param0: ?HKL,
    param1: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmIsIME(
    param0: ?HKL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmSimulateHotKey(
    param0: ?HWND,
    param1: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmCreateContext() callconv(@import("std").os.windows.WINAPI) ?HIMC;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmDestroyContext(
    param0: ?HIMC,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmGetContext(
    param0: ?HWND,
) callconv(@import("std").os.windows.WINAPI) ?HIMC;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmReleaseContext(
    param0: ?HWND,
    param1: ?HIMC,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmAssociateContext(
    param0: ?HWND,
    param1: ?HIMC,
) callconv(@import("std").os.windows.WINAPI) ?HIMC;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmAssociateContextEx(
    param0: ?HWND,
    param1: ?HIMC,
    param2: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmGetCompositionStringA(
    param0: ?HIMC,
    param1: u32,
    // TODO: what to do with BytesParamIndex 3?
    lpBuf: ?*anyopaque,
    dwBufLen: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmGetCompositionStringW(
    param0: ?HIMC,
    param1: u32,
    // TODO: what to do with BytesParamIndex 3?
    lpBuf: ?*anyopaque,
    dwBufLen: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmSetCompositionStringA(
    param0: ?HIMC,
    dwIndex: SET_COMPOSITION_STRING_TYPE,
    // TODO: what to do with BytesParamIndex 3?
    lpComp: ?*anyopaque,
    dwCompLen: u32,
    // TODO: what to do with BytesParamIndex 5?
    lpRead: ?*anyopaque,
    dwReadLen: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmSetCompositionStringW(
    param0: ?HIMC,
    dwIndex: SET_COMPOSITION_STRING_TYPE,
    // TODO: what to do with BytesParamIndex 3?
    lpComp: ?*anyopaque,
    dwCompLen: u32,
    // TODO: what to do with BytesParamIndex 5?
    lpRead: ?*anyopaque,
    dwReadLen: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmGetCandidateListCountA(
    param0: ?HIMC,
    lpdwListCount: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmGetCandidateListCountW(
    param0: ?HIMC,
    lpdwListCount: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmGetCandidateListA(
    param0: ?HIMC,
    deIndex: u32,
    // TODO: what to do with BytesParamIndex 3?
    lpCandList: ?*CANDIDATELIST,
    dwBufLen: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmGetCandidateListW(
    param0: ?HIMC,
    deIndex: u32,
    // TODO: what to do with BytesParamIndex 3?
    lpCandList: ?*CANDIDATELIST,
    dwBufLen: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmGetGuideLineA(
    param0: ?HIMC,
    dwIndex: GET_GUIDE_LINE_TYPE,
    // TODO: what to do with BytesParamIndex 3?
    lpBuf: ?PSTR,
    dwBufLen: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmGetGuideLineW(
    param0: ?HIMC,
    dwIndex: GET_GUIDE_LINE_TYPE,
    // TODO: what to do with BytesParamIndex 3?
    lpBuf: ?PWSTR,
    dwBufLen: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmGetConversionStatus(
    param0: ?HIMC,
    lpfdwConversion: ?*u32,
    lpfdwSentence: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmSetConversionStatus(
    param0: ?HIMC,
    param1: u32,
    param2: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmGetOpenStatus(
    param0: ?HIMC,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmSetOpenStatus(
    param0: ?HIMC,
    param1: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmGetCompositionFontA(
    param0: ?HIMC,
    lplf: ?*LOGFONTA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmGetCompositionFontW(
    param0: ?HIMC,
    lplf: ?*LOGFONTW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmSetCompositionFontA(
    param0: ?HIMC,
    lplf: ?*LOGFONTA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmSetCompositionFontW(
    param0: ?HIMC,
    lplf: ?*LOGFONTW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmConfigureIMEA(
    param0: ?HKL,
    param1: ?HWND,
    param2: u32,
    param3: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmConfigureIMEW(
    param0: ?HKL,
    param1: ?HWND,
    param2: u32,
    param3: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmEscapeA(
    param0: ?HKL,
    param1: ?HIMC,
    param2: u32,
    param3: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmEscapeW(
    param0: ?HKL,
    param1: ?HIMC,
    param2: u32,
    param3: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmGetConversionListA(
    param0: ?HKL,
    param1: ?HIMC,
    lpSrc: ?[*:0]const u8,
    // TODO: what to do with BytesParamIndex 4?
    lpDst: ?*CANDIDATELIST,
    dwBufLen: u32,
    uFlag: GET_CONVERSION_LIST_FLAG,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmGetConversionListW(
    param0: ?HKL,
    param1: ?HIMC,
    lpSrc: ?[*:0]const u16,
    // TODO: what to do with BytesParamIndex 4?
    lpDst: ?*CANDIDATELIST,
    dwBufLen: u32,
    uFlag: GET_CONVERSION_LIST_FLAG,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmNotifyIME(
    param0: ?HIMC,
    dwAction: NOTIFY_IME_ACTION,
    dwIndex: NOTIFY_IME_INDEX,
    dwValue: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmGetStatusWindowPos(
    param0: ?HIMC,
    lpptPos: ?*POINT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmSetStatusWindowPos(
    param0: ?HIMC,
    lpptPos: ?*POINT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmGetCompositionWindow(
    param0: ?HIMC,
    lpCompForm: ?*COMPOSITIONFORM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmSetCompositionWindow(
    param0: ?HIMC,
    lpCompForm: ?*COMPOSITIONFORM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmGetCandidateWindow(
    param0: ?HIMC,
    param1: u32,
    lpCandidate: ?*CANDIDATEFORM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmSetCandidateWindow(
    param0: ?HIMC,
    lpCandidate: ?*CANDIDATEFORM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmIsUIMessageA(
    param0: ?HWND,
    param1: u32,
    param2: WPARAM,
    param3: LPARAM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmIsUIMessageW(
    param0: ?HWND,
    param1: u32,
    param2: WPARAM,
    param3: LPARAM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmGetVirtualKey(
    param0: ?HWND,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmRegisterWordA(
    param0: ?HKL,
    lpszReading: ?[*:0]const u8,
    param2: u32,
    lpszRegister: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmRegisterWordW(
    param0: ?HKL,
    lpszReading: ?[*:0]const u16,
    param2: u32,
    lpszRegister: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmUnregisterWordA(
    param0: ?HKL,
    lpszReading: ?[*:0]const u8,
    param2: u32,
    lpszUnregister: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmUnregisterWordW(
    param0: ?HKL,
    lpszReading: ?[*:0]const u16,
    param2: u32,
    lpszUnregister: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmGetRegisterWordStyleA(
    param0: ?HKL,
    nItem: u32,
    lpStyleBuf: [*]STYLEBUFA,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmGetRegisterWordStyleW(
    param0: ?HKL,
    nItem: u32,
    lpStyleBuf: [*]STYLEBUFW,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmEnumRegisterWordA(
    param0: ?HKL,
    param1: ?REGISTERWORDENUMPROCA,
    lpszReading: ?[*:0]const u8,
    param3: u32,
    lpszRegister: ?[*:0]const u8,
    param5: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmEnumRegisterWordW(
    param0: ?HKL,
    param1: ?REGISTERWORDENUMPROCW,
    lpszReading: ?[*:0]const u16,
    param3: u32,
    lpszRegister: ?[*:0]const u16,
    param5: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmDisableIME(
    param0: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmEnumInputContext(
    idThread: u32,
    lpfn: ?IMCENUMPROC,
    lParam: LPARAM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmGetImeMenuItemsA(
    param0: ?HIMC,
    param1: u32,
    param2: u32,
    lpImeParentMenu: ?*IMEMENUITEMINFOA,
    // TODO: what to do with BytesParamIndex 5?
    lpImeMenu: ?*IMEMENUITEMINFOA,
    dwSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmGetImeMenuItemsW(
    param0: ?HIMC,
    param1: u32,
    param2: u32,
    lpImeParentMenu: ?*IMEMENUITEMINFOW,
    // TODO: what to do with BytesParamIndex 5?
    lpImeMenu: ?*IMEMENUITEMINFOW,
    dwSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmDisableTextFrameService(
    idThread: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "imm32" fn ImmDisableLegacyIME() callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "imm32" fn ImmGetHotKey(
    param0: u32,
    lpuModifiers: ?*u32,
    lpuVKey: ?*u32,
    phKL: ?*isize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "imm32" fn ImmSetHotKey(
    param0: u32,
    param1: u32,
    param2: u32,
    param3: ?HKL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "imm32" fn ImmGenerateMessage(
    param0: ?HIMC,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmRequestMessageA(
    param0: ?HIMC,
    param1: WPARAM,
    param2: LPARAM,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imm32" fn ImmRequestMessageW(
    param0: ?HIMC,
    param1: WPARAM,
    param2: LPARAM,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

pub extern "imm32" fn ImmCreateSoftKeyboard(
    param0: u32,
    param1: ?HWND,
    param2: i32,
    param3: i32,
) callconv(@import("std").os.windows.WINAPI) ?HWND;

pub extern "imm32" fn ImmDestroySoftKeyboard(
    param0: ?HWND,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "imm32" fn ImmShowSoftKeyboard(
    param0: ?HWND,
    param1: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "imm32" fn ImmLockIMC(
    param0: ?HIMC,
) callconv(@import("std").os.windows.WINAPI) ?*INPUTCONTEXT;

pub extern "imm32" fn ImmUnlockIMC(
    param0: ?HIMC,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "imm32" fn ImmGetIMCLockCount(
    param0: ?HIMC,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "imm32" fn ImmCreateIMCC(
    param0: u32,
) callconv(@import("std").os.windows.WINAPI) ?HIMCC;

pub extern "imm32" fn ImmDestroyIMCC(
    param0: ?HIMCC,
) callconv(@import("std").os.windows.WINAPI) ?HIMCC;

pub extern "imm32" fn ImmLockIMCC(
    param0: ?HIMCC,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

pub extern "imm32" fn ImmUnlockIMCC(
    param0: ?HIMCC,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "imm32" fn ImmGetIMCCLockCount(
    param0: ?HIMCC,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "imm32" fn ImmReSizeIMCC(
    param0: ?HIMCC,
    param1: u32,
) callconv(@import("std").os.windows.WINAPI) ?HIMCC;

pub extern "imm32" fn ImmGetIMCCSize(
    param0: ?HIMCC,
) callconv(@import("std").os.windows.WINAPI) u32;

//--------------------------------------------------------------------------------
// Section: Unicode Aliases (25)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../../zig.zig").unicode_mode) {
    .ansi => struct {
        pub const REGISTERWORD = thismodule.REGISTERWORDA;
        pub const STYLEBUF = thismodule.STYLEBUFA;
        pub const IMEMENUITEMINFO = thismodule.IMEMENUITEMINFOA;
        pub const REGISTERWORDENUMPROC = thismodule.REGISTERWORDENUMPROCA;
        pub const IEnumRegisterWord = thismodule.IEnumRegisterWordA;
        pub const ImmInstallIME = thismodule.ImmInstallIMEA;
        pub const ImmGetDescription = thismodule.ImmGetDescriptionA;
        pub const ImmGetIMEFileName = thismodule.ImmGetIMEFileNameA;
        pub const ImmGetCompositionString = thismodule.ImmGetCompositionStringA;
        pub const ImmSetCompositionString = thismodule.ImmSetCompositionStringA;
        pub const ImmGetCandidateListCount = thismodule.ImmGetCandidateListCountA;
        pub const ImmGetCandidateList = thismodule.ImmGetCandidateListA;
        pub const ImmGetGuideLine = thismodule.ImmGetGuideLineA;
        pub const ImmGetCompositionFont = thismodule.ImmGetCompositionFontA;
        pub const ImmSetCompositionFont = thismodule.ImmSetCompositionFontA;
        pub const ImmConfigureIME = thismodule.ImmConfigureIMEA;
        pub const ImmEscape = thismodule.ImmEscapeA;
        pub const ImmGetConversionList = thismodule.ImmGetConversionListA;
        pub const ImmIsUIMessage = thismodule.ImmIsUIMessageA;
        pub const ImmRegisterWord = thismodule.ImmRegisterWordA;
        pub const ImmUnregisterWord = thismodule.ImmUnregisterWordA;
        pub const ImmGetRegisterWordStyle = thismodule.ImmGetRegisterWordStyleA;
        pub const ImmEnumRegisterWord = thismodule.ImmEnumRegisterWordA;
        pub const ImmGetImeMenuItems = thismodule.ImmGetImeMenuItemsA;
        pub const ImmRequestMessage = thismodule.ImmRequestMessageA;
    },
    .wide => struct {
        pub const REGISTERWORD = thismodule.REGISTERWORDW;
        pub const STYLEBUF = thismodule.STYLEBUFW;
        pub const IMEMENUITEMINFO = thismodule.IMEMENUITEMINFOW;
        pub const REGISTERWORDENUMPROC = thismodule.REGISTERWORDENUMPROCW;
        pub const IEnumRegisterWord = thismodule.IEnumRegisterWordW;
        pub const ImmInstallIME = thismodule.ImmInstallIMEW;
        pub const ImmGetDescription = thismodule.ImmGetDescriptionW;
        pub const ImmGetIMEFileName = thismodule.ImmGetIMEFileNameW;
        pub const ImmGetCompositionString = thismodule.ImmGetCompositionStringW;
        pub const ImmSetCompositionString = thismodule.ImmSetCompositionStringW;
        pub const ImmGetCandidateListCount = thismodule.ImmGetCandidateListCountW;
        pub const ImmGetCandidateList = thismodule.ImmGetCandidateListW;
        pub const ImmGetGuideLine = thismodule.ImmGetGuideLineW;
        pub const ImmGetCompositionFont = thismodule.ImmGetCompositionFontW;
        pub const ImmSetCompositionFont = thismodule.ImmSetCompositionFontW;
        pub const ImmConfigureIME = thismodule.ImmConfigureIMEW;
        pub const ImmEscape = thismodule.ImmEscapeW;
        pub const ImmGetConversionList = thismodule.ImmGetConversionListW;
        pub const ImmIsUIMessage = thismodule.ImmIsUIMessageW;
        pub const ImmRegisterWord = thismodule.ImmRegisterWordW;
        pub const ImmUnregisterWord = thismodule.ImmUnregisterWordW;
        pub const ImmGetRegisterWordStyle = thismodule.ImmGetRegisterWordStyleW;
        pub const ImmEnumRegisterWord = thismodule.ImmEnumRegisterWordW;
        pub const ImmGetImeMenuItems = thismodule.ImmGetImeMenuItemsW;
        pub const ImmRequestMessage = thismodule.ImmRequestMessageW;
    },
    .unspecified => if (@import("builtin").is_test) struct {
        pub const REGISTERWORD = *opaque {};
        pub const STYLEBUF = *opaque {};
        pub const IMEMENUITEMINFO = *opaque {};
        pub const REGISTERWORDENUMPROC = *opaque {};
        pub const IEnumRegisterWord = *opaque {};
        pub const ImmInstallIME = *opaque {};
        pub const ImmGetDescription = *opaque {};
        pub const ImmGetIMEFileName = *opaque {};
        pub const ImmGetCompositionString = *opaque {};
        pub const ImmSetCompositionString = *opaque {};
        pub const ImmGetCandidateListCount = *opaque {};
        pub const ImmGetCandidateList = *opaque {};
        pub const ImmGetGuideLine = *opaque {};
        pub const ImmGetCompositionFont = *opaque {};
        pub const ImmSetCompositionFont = *opaque {};
        pub const ImmConfigureIME = *opaque {};
        pub const ImmEscape = *opaque {};
        pub const ImmGetConversionList = *opaque {};
        pub const ImmIsUIMessage = *opaque {};
        pub const ImmRegisterWord = *opaque {};
        pub const ImmUnregisterWord = *opaque {};
        pub const ImmGetRegisterWordStyle = *opaque {};
        pub const ImmEnumRegisterWord = *opaque {};
        pub const ImmGetImeMenuItems = *opaque {};
        pub const ImmRequestMessage = *opaque {};
    } else struct {
        pub const REGISTERWORD = @compileError("'REGISTERWORD' requires that UNICODE be set to true or false in the root module");
        pub const STYLEBUF = @compileError("'STYLEBUF' requires that UNICODE be set to true or false in the root module");
        pub const IMEMENUITEMINFO = @compileError("'IMEMENUITEMINFO' requires that UNICODE be set to true or false in the root module");
        pub const REGISTERWORDENUMPROC = @compileError("'REGISTERWORDENUMPROC' requires that UNICODE be set to true or false in the root module");
        pub const IEnumRegisterWord = @compileError("'IEnumRegisterWord' requires that UNICODE be set to true or false in the root module");
        pub const ImmInstallIME = @compileError("'ImmInstallIME' requires that UNICODE be set to true or false in the root module");
        pub const ImmGetDescription = @compileError("'ImmGetDescription' requires that UNICODE be set to true or false in the root module");
        pub const ImmGetIMEFileName = @compileError("'ImmGetIMEFileName' requires that UNICODE be set to true or false in the root module");
        pub const ImmGetCompositionString = @compileError("'ImmGetCompositionString' requires that UNICODE be set to true or false in the root module");
        pub const ImmSetCompositionString = @compileError("'ImmSetCompositionString' requires that UNICODE be set to true or false in the root module");
        pub const ImmGetCandidateListCount = @compileError("'ImmGetCandidateListCount' requires that UNICODE be set to true or false in the root module");
        pub const ImmGetCandidateList = @compileError("'ImmGetCandidateList' requires that UNICODE be set to true or false in the root module");
        pub const ImmGetGuideLine = @compileError("'ImmGetGuideLine' requires that UNICODE be set to true or false in the root module");
        pub const ImmGetCompositionFont = @compileError("'ImmGetCompositionFont' requires that UNICODE be set to true or false in the root module");
        pub const ImmSetCompositionFont = @compileError("'ImmSetCompositionFont' requires that UNICODE be set to true or false in the root module");
        pub const ImmConfigureIME = @compileError("'ImmConfigureIME' requires that UNICODE be set to true or false in the root module");
        pub const ImmEscape = @compileError("'ImmEscape' requires that UNICODE be set to true or false in the root module");
        pub const ImmGetConversionList = @compileError("'ImmGetConversionList' requires that UNICODE be set to true or false in the root module");
        pub const ImmIsUIMessage = @compileError("'ImmIsUIMessage' requires that UNICODE be set to true or false in the root module");
        pub const ImmRegisterWord = @compileError("'ImmRegisterWord' requires that UNICODE be set to true or false in the root module");
        pub const ImmUnregisterWord = @compileError("'ImmUnregisterWord' requires that UNICODE be set to true or false in the root module");
        pub const ImmGetRegisterWordStyle = @compileError("'ImmGetRegisterWordStyle' requires that UNICODE be set to true or false in the root module");
        pub const ImmEnumRegisterWord = @compileError("'ImmEnumRegisterWord' requires that UNICODE be set to true or false in the root module");
        pub const ImmGetImeMenuItems = @compileError("'ImmGetImeMenuItems' requires that UNICODE be set to true or false in the root module");
        pub const ImmRequestMessage = @compileError("'ImmRequestMessage' requires that UNICODE be set to true or false in the root module");
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (24)
//--------------------------------------------------------------------------------
const Guid = @import("../../zig.zig").Guid;
const BOOL = @import("../../foundation.zig").BOOL;
const BSTR = @import("../../foundation.zig").BSTR;
const CHAR = @import("../../foundation.zig").CHAR;
const HBITMAP = @import("../../graphics/gdi.zig").HBITMAP;
const HICON = @import("../../ui/windows_and_messaging.zig").HICON;
const HIMC = @import("../../globalization.zig").HIMC;
const HIMCC = @import("../../globalization.zig").HIMCC;
const HKL = @import("../../ui/text_services.zig").HKL;
const HRESULT = @import("../../foundation.zig").HRESULT;
const HWND = @import("../../foundation.zig").HWND;
const IClassFactory = @import("../../system/com.zig").IClassFactory;
const IUnknown = @import("../../system/com.zig").IUnknown;
const LOGFONTA = @import("../../graphics/gdi.zig").LOGFONTA;
const LOGFONTW = @import("../../graphics/gdi.zig").LOGFONTW;
const LPARAM = @import("../../foundation.zig").LPARAM;
const LRESULT = @import("../../foundation.zig").LRESULT;
const MSG = @import("../../ui/windows_and_messaging.zig").MSG;
const POINT = @import("../../foundation.zig").POINT;
const PSTR = @import("../../foundation.zig").PSTR;
const PWSTR = @import("../../foundation.zig").PWSTR;
const RECT = @import("../../foundation.zig").RECT;
const SAFEARRAY = @import("../../system/com.zig").SAFEARRAY;
const WPARAM = @import("../../foundation.zig").WPARAM;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "IMCENUMPROC")) {
        _ = IMCENUMPROC;
    }
    if (@hasDecl(@This(), "REGISTERWORDENUMPROCA")) {
        _ = REGISTERWORDENUMPROCA;
    }
    if (@hasDecl(@This(), "REGISTERWORDENUMPROCW")) {
        _ = REGISTERWORDENUMPROCW;
    }
    if (@hasDecl(@This(), "PFNLOG")) {
        _ = PFNLOG;
    }
    if (@hasDecl(@This(), "fpCreateIFECommonInstanceType")) {
        _ = fpCreateIFECommonInstanceType;
    }
    if (@hasDecl(@This(), "fpCreateIFELanguageInstanceType")) {
        _ = fpCreateIFELanguageInstanceType;
    }
    if (@hasDecl(@This(), "fpCreateIFEDictionaryInstanceType")) {
        _ = fpCreateIFEDictionaryInstanceType;
    }

    @setEvalBranchQuota(comptime @import("std").meta.declarations(@This()).len * 3);

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        if (decl.is_pub) {
            _ = @field(@This(), decl.name);
        }
    }
}
