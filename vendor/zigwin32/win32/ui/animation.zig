//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (5)
//--------------------------------------------------------------------------------
pub const UI_ANIMATION_SECONDS_EVENTUALLY = @as(i32, -1);
pub const UI_ANIMATION_REPEAT_INDEFINITELY = @as(i32, -1);
pub const UI_ANIMATION_REPEAT_INDEFINITELY_CONCLUDE_AT_END = @as(i32, -1);
pub const UI_ANIMATION_REPEAT_INDEFINITELY_CONCLUDE_AT_START = @as(i32, -2);
pub const UI_ANIMATION_SECONDS_INFINITE = @as(i32, -1);

//--------------------------------------------------------------------------------
// Section: Types (51)
//--------------------------------------------------------------------------------
pub const UI_ANIMATION_KEYFRAME = isize;

const CLSID_UIAnimationManager_Value = Guid.initString("4c1fc63a-695c-47e8-a339-1a194be3d0b8");
pub const CLSID_UIAnimationManager = &CLSID_UIAnimationManager_Value;

const CLSID_UIAnimationManager2_Value = Guid.initString("d25d8842-8884-4a4a-b321-091314379bdd");
pub const CLSID_UIAnimationManager2 = &CLSID_UIAnimationManager2_Value;

const CLSID_UIAnimationTransitionLibrary_Value = Guid.initString("1d6322ad-aa85-4ef5-a828-86d71067d145");
pub const CLSID_UIAnimationTransitionLibrary = &CLSID_UIAnimationTransitionLibrary_Value;

const CLSID_UIAnimationTransitionLibrary2_Value = Guid.initString("812f944a-c5c8-4cd9-b0a6-b3da802f228d");
pub const CLSID_UIAnimationTransitionLibrary2 = &CLSID_UIAnimationTransitionLibrary2_Value;

const CLSID_UIAnimationTransitionFactory_Value = Guid.initString("8a9b1cdd-fcd7-419c-8b44-42fd17db1887");
pub const CLSID_UIAnimationTransitionFactory = &CLSID_UIAnimationTransitionFactory_Value;

const CLSID_UIAnimationTransitionFactory2_Value = Guid.initString("84302f97-7f7b-4040-b190-72ac9d18e420");
pub const CLSID_UIAnimationTransitionFactory2 = &CLSID_UIAnimationTransitionFactory2_Value;

const CLSID_UIAnimationTimer_Value = Guid.initString("bfcd4a0c-06b6-4384-b768-0daa792c380e");
pub const CLSID_UIAnimationTimer = &CLSID_UIAnimationTimer_Value;

pub const UI_ANIMATION_UPDATE_RESULT = enum(i32) {
    NO_CHANGE = 0,
    VARIABLES_CHANGED = 1,
};
pub const UI_ANIMATION_UPDATE_NO_CHANGE = UI_ANIMATION_UPDATE_RESULT.NO_CHANGE;
pub const UI_ANIMATION_UPDATE_VARIABLES_CHANGED = UI_ANIMATION_UPDATE_RESULT.VARIABLES_CHANGED;

pub const UI_ANIMATION_MANAGER_STATUS = enum(i32) {
    IDLE = 0,
    BUSY = 1,
};
pub const UI_ANIMATION_MANAGER_IDLE = UI_ANIMATION_MANAGER_STATUS.IDLE;
pub const UI_ANIMATION_MANAGER_BUSY = UI_ANIMATION_MANAGER_STATUS.BUSY;

pub const UI_ANIMATION_MODE = enum(i32) {
    DISABLED = 0,
    SYSTEM_DEFAULT = 1,
    ENABLED = 2,
};
pub const UI_ANIMATION_MODE_DISABLED = UI_ANIMATION_MODE.DISABLED;
pub const UI_ANIMATION_MODE_SYSTEM_DEFAULT = UI_ANIMATION_MODE.SYSTEM_DEFAULT;
pub const UI_ANIMATION_MODE_ENABLED = UI_ANIMATION_MODE.ENABLED;

pub const UI_ANIMATION_REPEAT_MODE = enum(i32) {
    NORMAL = 0,
    ALTERNATE = 1,
};
pub const UI_ANIMATION_REPEAT_MODE_NORMAL = UI_ANIMATION_REPEAT_MODE.NORMAL;
pub const UI_ANIMATION_REPEAT_MODE_ALTERNATE = UI_ANIMATION_REPEAT_MODE.ALTERNATE;

// TODO: this type is limited to platform 'windows6.1'
const IID_IUIAnimationManager_Value = Guid.initString("9169896c-ac8d-4e7d-94e5-67fa4dc2f2e8");
pub const IID_IUIAnimationManager = &IID_IUIAnimationManager_Value;
pub const IUIAnimationManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateAnimationVariable: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationManager,
                initialValue: f64,
                variable: ?*?*IUIAnimationVariable,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationManager,
                initialValue: f64,
                variable: ?*?*IUIAnimationVariable,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ScheduleTransition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationManager,
                variable: ?*IUIAnimationVariable,
                transition: ?*IUIAnimationTransition,
                timeNow: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationManager,
                variable: ?*IUIAnimationVariable,
                transition: ?*IUIAnimationTransition,
                timeNow: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateStoryboard: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationManager,
                storyboard: ?*?*IUIAnimationStoryboard,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationManager,
                storyboard: ?*?*IUIAnimationStoryboard,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FinishAllStoryboards: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationManager,
                completionDeadline: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationManager,
                completionDeadline: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AbandonAllStoryboards: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Update: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationManager,
                timeNow: f64,
                updateResult: ?*UI_ANIMATION_UPDATE_RESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationManager,
                timeNow: f64,
                updateResult: ?*UI_ANIMATION_UPDATE_RESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVariableFromTag: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationManager,
                object: ?*IUnknown,
                id: u32,
                variable: ?*?*IUIAnimationVariable,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationManager,
                object: ?*IUnknown,
                id: u32,
                variable: ?*?*IUIAnimationVariable,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStoryboardFromTag: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationManager,
                object: ?*IUnknown,
                id: u32,
                storyboard: ?*?*IUIAnimationStoryboard,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationManager,
                object: ?*IUnknown,
                id: u32,
                storyboard: ?*?*IUIAnimationStoryboard,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationManager,
                status: ?*UI_ANIMATION_MANAGER_STATUS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationManager,
                status: ?*UI_ANIMATION_MANAGER_STATUS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetAnimationMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationManager,
                mode: UI_ANIMATION_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationManager,
                mode: UI_ANIMATION_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Pause: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Resume: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetManagerEventHandler: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationManager,
                handler: ?*IUIAnimationManagerEventHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationManager,
                handler: ?*IUIAnimationManagerEventHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCancelPriorityComparison: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationManager,
                comparison: ?*IUIAnimationPriorityComparison,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationManager,
                comparison: ?*IUIAnimationPriorityComparison,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTrimPriorityComparison: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationManager,
                comparison: ?*IUIAnimationPriorityComparison,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationManager,
                comparison: ?*IUIAnimationPriorityComparison,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCompressPriorityComparison: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationManager,
                comparison: ?*IUIAnimationPriorityComparison,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationManager,
                comparison: ?*IUIAnimationPriorityComparison,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetConcludePriorityComparison: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationManager,
                comparison: ?*IUIAnimationPriorityComparison,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationManager,
                comparison: ?*IUIAnimationPriorityComparison,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDefaultLongestAcceptableDelay: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationManager,
                delay: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationManager,
                delay: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Shutdown: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationManager_CreateAnimationVariable(self: *const T, initialValue: f64, variable: ?*?*IUIAnimationVariable) HRESULT {
                return @as(*const IUIAnimationManager.VTable, @ptrCast(self.vtable)).CreateAnimationVariable(@as(*const IUIAnimationManager, @ptrCast(self)), initialValue, variable);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationManager_ScheduleTransition(self: *const T, variable: ?*IUIAnimationVariable, transition: ?*IUIAnimationTransition, timeNow: f64) HRESULT {
                return @as(*const IUIAnimationManager.VTable, @ptrCast(self.vtable)).ScheduleTransition(@as(*const IUIAnimationManager, @ptrCast(self)), variable, transition, timeNow);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationManager_CreateStoryboard(self: *const T, storyboard: ?*?*IUIAnimationStoryboard) HRESULT {
                return @as(*const IUIAnimationManager.VTable, @ptrCast(self.vtable)).CreateStoryboard(@as(*const IUIAnimationManager, @ptrCast(self)), storyboard);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationManager_FinishAllStoryboards(self: *const T, completionDeadline: f64) HRESULT {
                return @as(*const IUIAnimationManager.VTable, @ptrCast(self.vtable)).FinishAllStoryboards(@as(*const IUIAnimationManager, @ptrCast(self)), completionDeadline);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationManager_AbandonAllStoryboards(self: *const T) HRESULT {
                return @as(*const IUIAnimationManager.VTable, @ptrCast(self.vtable)).AbandonAllStoryboards(@as(*const IUIAnimationManager, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationManager_Update(self: *const T, timeNow: f64, updateResult: ?*UI_ANIMATION_UPDATE_RESULT) HRESULT {
                return @as(*const IUIAnimationManager.VTable, @ptrCast(self.vtable)).Update(@as(*const IUIAnimationManager, @ptrCast(self)), timeNow, updateResult);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationManager_GetVariableFromTag(self: *const T, object: ?*IUnknown, id: u32, variable: ?*?*IUIAnimationVariable) HRESULT {
                return @as(*const IUIAnimationManager.VTable, @ptrCast(self.vtable)).GetVariableFromTag(@as(*const IUIAnimationManager, @ptrCast(self)), object, id, variable);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationManager_GetStoryboardFromTag(self: *const T, object: ?*IUnknown, id: u32, storyboard: ?*?*IUIAnimationStoryboard) HRESULT {
                return @as(*const IUIAnimationManager.VTable, @ptrCast(self.vtable)).GetStoryboardFromTag(@as(*const IUIAnimationManager, @ptrCast(self)), object, id, storyboard);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationManager_GetStatus(self: *const T, status: ?*UI_ANIMATION_MANAGER_STATUS) HRESULT {
                return @as(*const IUIAnimationManager.VTable, @ptrCast(self.vtable)).GetStatus(@as(*const IUIAnimationManager, @ptrCast(self)), status);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationManager_SetAnimationMode(self: *const T, mode: UI_ANIMATION_MODE) HRESULT {
                return @as(*const IUIAnimationManager.VTable, @ptrCast(self.vtable)).SetAnimationMode(@as(*const IUIAnimationManager, @ptrCast(self)), mode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationManager_Pause(self: *const T) HRESULT {
                return @as(*const IUIAnimationManager.VTable, @ptrCast(self.vtable)).Pause(@as(*const IUIAnimationManager, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationManager_Resume(self: *const T) HRESULT {
                return @as(*const IUIAnimationManager.VTable, @ptrCast(self.vtable)).Resume(@as(*const IUIAnimationManager, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationManager_SetManagerEventHandler(self: *const T, handler: ?*IUIAnimationManagerEventHandler) HRESULT {
                return @as(*const IUIAnimationManager.VTable, @ptrCast(self.vtable)).SetManagerEventHandler(@as(*const IUIAnimationManager, @ptrCast(self)), handler);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationManager_SetCancelPriorityComparison(self: *const T, comparison: ?*IUIAnimationPriorityComparison) HRESULT {
                return @as(*const IUIAnimationManager.VTable, @ptrCast(self.vtable)).SetCancelPriorityComparison(@as(*const IUIAnimationManager, @ptrCast(self)), comparison);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationManager_SetTrimPriorityComparison(self: *const T, comparison: ?*IUIAnimationPriorityComparison) HRESULT {
                return @as(*const IUIAnimationManager.VTable, @ptrCast(self.vtable)).SetTrimPriorityComparison(@as(*const IUIAnimationManager, @ptrCast(self)), comparison);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationManager_SetCompressPriorityComparison(self: *const T, comparison: ?*IUIAnimationPriorityComparison) HRESULT {
                return @as(*const IUIAnimationManager.VTable, @ptrCast(self.vtable)).SetCompressPriorityComparison(@as(*const IUIAnimationManager, @ptrCast(self)), comparison);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationManager_SetConcludePriorityComparison(self: *const T, comparison: ?*IUIAnimationPriorityComparison) HRESULT {
                return @as(*const IUIAnimationManager.VTable, @ptrCast(self.vtable)).SetConcludePriorityComparison(@as(*const IUIAnimationManager, @ptrCast(self)), comparison);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationManager_SetDefaultLongestAcceptableDelay(self: *const T, delay: f64) HRESULT {
                return @as(*const IUIAnimationManager.VTable, @ptrCast(self.vtable)).SetDefaultLongestAcceptableDelay(@as(*const IUIAnimationManager, @ptrCast(self)), delay);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationManager_Shutdown(self: *const T) HRESULT {
                return @as(*const IUIAnimationManager.VTable, @ptrCast(self.vtable)).Shutdown(@as(*const IUIAnimationManager, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const UI_ANIMATION_ROUNDING_MODE = enum(i32) {
    NEAREST = 0,
    FLOOR = 1,
    CEILING = 2,
};
pub const UI_ANIMATION_ROUNDING_NEAREST = UI_ANIMATION_ROUNDING_MODE.NEAREST;
pub const UI_ANIMATION_ROUNDING_FLOOR = UI_ANIMATION_ROUNDING_MODE.FLOOR;
pub const UI_ANIMATION_ROUNDING_CEILING = UI_ANIMATION_ROUNDING_MODE.CEILING;

// TODO: this type is limited to platform 'windows6.1'
const IID_IUIAnimationVariable_Value = Guid.initString("8ceeb155-2849-4ce5-9448-91ff70e1e4d9");
pub const IID_IUIAnimationVariable = &IID_IUIAnimationVariable_Value;
pub const IUIAnimationVariable = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationVariable,
                value: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationVariable,
                value: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFinalValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationVariable,
                finalValue: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationVariable,
                finalValue: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPreviousValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationVariable,
                previousValue: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationVariable,
                previousValue: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIntegerValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationVariable,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationVariable,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFinalIntegerValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationVariable,
                finalValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationVariable,
                finalValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPreviousIntegerValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationVariable,
                previousValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationVariable,
                previousValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentStoryboard: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationVariable,
                storyboard: ?*?*IUIAnimationStoryboard,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationVariable,
                storyboard: ?*?*IUIAnimationStoryboard,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetLowerBound: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationVariable,
                bound: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationVariable,
                bound: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetUpperBound: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationVariable,
                bound: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationVariable,
                bound: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetRoundingMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationVariable,
                mode: UI_ANIMATION_ROUNDING_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationVariable,
                mode: UI_ANIMATION_ROUNDING_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTag: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationVariable,
                object: ?*IUnknown,
                id: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationVariable,
                object: ?*IUnknown,
                id: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTag: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationVariable,
                object: ?*?*IUnknown,
                id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationVariable,
                object: ?*?*IUnknown,
                id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetVariableChangeHandler: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationVariable,
                handler: ?*IUIAnimationVariableChangeHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationVariable,
                handler: ?*IUIAnimationVariableChangeHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetVariableIntegerChangeHandler: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationVariable,
                handler: ?*IUIAnimationVariableIntegerChangeHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationVariable,
                handler: ?*IUIAnimationVariableIntegerChangeHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationVariable_GetValue(self: *const T, value: ?*f64) HRESULT {
                return @as(*const IUIAnimationVariable.VTable, @ptrCast(self.vtable)).GetValue(@as(*const IUIAnimationVariable, @ptrCast(self)), value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationVariable_GetFinalValue(self: *const T, finalValue: ?*f64) HRESULT {
                return @as(*const IUIAnimationVariable.VTable, @ptrCast(self.vtable)).GetFinalValue(@as(*const IUIAnimationVariable, @ptrCast(self)), finalValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationVariable_GetPreviousValue(self: *const T, previousValue: ?*f64) HRESULT {
                return @as(*const IUIAnimationVariable.VTable, @ptrCast(self.vtable)).GetPreviousValue(@as(*const IUIAnimationVariable, @ptrCast(self)), previousValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationVariable_GetIntegerValue(self: *const T, value: ?*i32) HRESULT {
                return @as(*const IUIAnimationVariable.VTable, @ptrCast(self.vtable)).GetIntegerValue(@as(*const IUIAnimationVariable, @ptrCast(self)), value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationVariable_GetFinalIntegerValue(self: *const T, finalValue: ?*i32) HRESULT {
                return @as(*const IUIAnimationVariable.VTable, @ptrCast(self.vtable)).GetFinalIntegerValue(@as(*const IUIAnimationVariable, @ptrCast(self)), finalValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationVariable_GetPreviousIntegerValue(self: *const T, previousValue: ?*i32) HRESULT {
                return @as(*const IUIAnimationVariable.VTable, @ptrCast(self.vtable)).GetPreviousIntegerValue(@as(*const IUIAnimationVariable, @ptrCast(self)), previousValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationVariable_GetCurrentStoryboard(self: *const T, storyboard: ?*?*IUIAnimationStoryboard) HRESULT {
                return @as(*const IUIAnimationVariable.VTable, @ptrCast(self.vtable)).GetCurrentStoryboard(@as(*const IUIAnimationVariable, @ptrCast(self)), storyboard);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationVariable_SetLowerBound(self: *const T, bound: f64) HRESULT {
                return @as(*const IUIAnimationVariable.VTable, @ptrCast(self.vtable)).SetLowerBound(@as(*const IUIAnimationVariable, @ptrCast(self)), bound);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationVariable_SetUpperBound(self: *const T, bound: f64) HRESULT {
                return @as(*const IUIAnimationVariable.VTable, @ptrCast(self.vtable)).SetUpperBound(@as(*const IUIAnimationVariable, @ptrCast(self)), bound);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationVariable_SetRoundingMode(self: *const T, mode: UI_ANIMATION_ROUNDING_MODE) HRESULT {
                return @as(*const IUIAnimationVariable.VTable, @ptrCast(self.vtable)).SetRoundingMode(@as(*const IUIAnimationVariable, @ptrCast(self)), mode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationVariable_SetTag(self: *const T, object: ?*IUnknown, id: u32) HRESULT {
                return @as(*const IUIAnimationVariable.VTable, @ptrCast(self.vtable)).SetTag(@as(*const IUIAnimationVariable, @ptrCast(self)), object, id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationVariable_GetTag(self: *const T, object: ?*?*IUnknown, id: ?*u32) HRESULT {
                return @as(*const IUIAnimationVariable.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IUIAnimationVariable, @ptrCast(self)), object, id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationVariable_SetVariableChangeHandler(self: *const T, handler: ?*IUIAnimationVariableChangeHandler) HRESULT {
                return @as(*const IUIAnimationVariable.VTable, @ptrCast(self.vtable)).SetVariableChangeHandler(@as(*const IUIAnimationVariable, @ptrCast(self)), handler);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationVariable_SetVariableIntegerChangeHandler(self: *const T, handler: ?*IUIAnimationVariableIntegerChangeHandler) HRESULT {
                return @as(*const IUIAnimationVariable.VTable, @ptrCast(self.vtable)).SetVariableIntegerChangeHandler(@as(*const IUIAnimationVariable, @ptrCast(self)), handler);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const UI_ANIMATION_STORYBOARD_STATUS = enum(i32) {
    BUILDING = 0,
    SCHEDULED = 1,
    CANCELLED = 2,
    PLAYING = 3,
    TRUNCATED = 4,
    FINISHED = 5,
    READY = 6,
    INSUFFICIENT_PRIORITY = 7,
};
pub const UI_ANIMATION_STORYBOARD_BUILDING = UI_ANIMATION_STORYBOARD_STATUS.BUILDING;
pub const UI_ANIMATION_STORYBOARD_SCHEDULED = UI_ANIMATION_STORYBOARD_STATUS.SCHEDULED;
pub const UI_ANIMATION_STORYBOARD_CANCELLED = UI_ANIMATION_STORYBOARD_STATUS.CANCELLED;
pub const UI_ANIMATION_STORYBOARD_PLAYING = UI_ANIMATION_STORYBOARD_STATUS.PLAYING;
pub const UI_ANIMATION_STORYBOARD_TRUNCATED = UI_ANIMATION_STORYBOARD_STATUS.TRUNCATED;
pub const UI_ANIMATION_STORYBOARD_FINISHED = UI_ANIMATION_STORYBOARD_STATUS.FINISHED;
pub const UI_ANIMATION_STORYBOARD_READY = UI_ANIMATION_STORYBOARD_STATUS.READY;
pub const UI_ANIMATION_STORYBOARD_INSUFFICIENT_PRIORITY = UI_ANIMATION_STORYBOARD_STATUS.INSUFFICIENT_PRIORITY;

pub const UI_ANIMATION_SCHEDULING_RESULT = enum(i32) {
    UNEXPECTED_FAILURE = 0,
    INSUFFICIENT_PRIORITY = 1,
    ALREADY_SCHEDULED = 2,
    SUCCEEDED = 3,
    DEFERRED = 4,
};
pub const UI_ANIMATION_SCHEDULING_UNEXPECTED_FAILURE = UI_ANIMATION_SCHEDULING_RESULT.UNEXPECTED_FAILURE;
pub const UI_ANIMATION_SCHEDULING_INSUFFICIENT_PRIORITY = UI_ANIMATION_SCHEDULING_RESULT.INSUFFICIENT_PRIORITY;
pub const UI_ANIMATION_SCHEDULING_ALREADY_SCHEDULED = UI_ANIMATION_SCHEDULING_RESULT.ALREADY_SCHEDULED;
pub const UI_ANIMATION_SCHEDULING_SUCCEEDED = UI_ANIMATION_SCHEDULING_RESULT.SUCCEEDED;
pub const UI_ANIMATION_SCHEDULING_DEFERRED = UI_ANIMATION_SCHEDULING_RESULT.DEFERRED;

// TODO: this type is limited to platform 'windows6.1'
const IID_IUIAnimationStoryboard_Value = Guid.initString("a8ff128f-9bf9-4af1-9e67-e5e410defb84");
pub const IID_IUIAnimationStoryboard = &IID_IUIAnimationStoryboard_Value;
pub const IUIAnimationStoryboard = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddTransition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationStoryboard,
                variable: ?*IUIAnimationVariable,
                transition: ?*IUIAnimationTransition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationStoryboard,
                variable: ?*IUIAnimationVariable,
                transition: ?*IUIAnimationTransition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddKeyframeAtOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationStoryboard,
                existingKeyframe: UI_ANIMATION_KEYFRAME,
                offset: f64,
                keyframe: ?*UI_ANIMATION_KEYFRAME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationStoryboard,
                existingKeyframe: UI_ANIMATION_KEYFRAME,
                offset: f64,
                keyframe: ?*UI_ANIMATION_KEYFRAME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddKeyframeAfterTransition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationStoryboard,
                transition: ?*IUIAnimationTransition,
                keyframe: ?*UI_ANIMATION_KEYFRAME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationStoryboard,
                transition: ?*IUIAnimationTransition,
                keyframe: ?*UI_ANIMATION_KEYFRAME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddTransitionAtKeyframe: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationStoryboard,
                variable: ?*IUIAnimationVariable,
                transition: ?*IUIAnimationTransition,
                startKeyframe: UI_ANIMATION_KEYFRAME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationStoryboard,
                variable: ?*IUIAnimationVariable,
                transition: ?*IUIAnimationTransition,
                startKeyframe: UI_ANIMATION_KEYFRAME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddTransitionBetweenKeyframes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationStoryboard,
                variable: ?*IUIAnimationVariable,
                transition: ?*IUIAnimationTransition,
                startKeyframe: UI_ANIMATION_KEYFRAME,
                endKeyframe: UI_ANIMATION_KEYFRAME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationStoryboard,
                variable: ?*IUIAnimationVariable,
                transition: ?*IUIAnimationTransition,
                startKeyframe: UI_ANIMATION_KEYFRAME,
                endKeyframe: UI_ANIMATION_KEYFRAME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RepeatBetweenKeyframes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationStoryboard,
                startKeyframe: UI_ANIMATION_KEYFRAME,
                endKeyframe: UI_ANIMATION_KEYFRAME,
                repetitionCount: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationStoryboard,
                startKeyframe: UI_ANIMATION_KEYFRAME,
                endKeyframe: UI_ANIMATION_KEYFRAME,
                repetitionCount: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        HoldVariable: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationStoryboard,
                variable: ?*IUIAnimationVariable,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationStoryboard,
                variable: ?*IUIAnimationVariable,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetLongestAcceptableDelay: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationStoryboard,
                delay: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationStoryboard,
                delay: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Schedule: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationStoryboard,
                timeNow: f64,
                schedulingResult: ?*UI_ANIMATION_SCHEDULING_RESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationStoryboard,
                timeNow: f64,
                schedulingResult: ?*UI_ANIMATION_SCHEDULING_RESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Conclude: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationStoryboard,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationStoryboard,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Finish: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationStoryboard,
                completionDeadline: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationStoryboard,
                completionDeadline: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Abandon: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationStoryboard,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationStoryboard,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTag: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationStoryboard,
                object: ?*IUnknown,
                id: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationStoryboard,
                object: ?*IUnknown,
                id: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTag: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationStoryboard,
                object: ?*?*IUnknown,
                id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationStoryboard,
                object: ?*?*IUnknown,
                id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationStoryboard,
                status: ?*UI_ANIMATION_STORYBOARD_STATUS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationStoryboard,
                status: ?*UI_ANIMATION_STORYBOARD_STATUS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetElapsedTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationStoryboard,
                elapsedTime: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationStoryboard,
                elapsedTime: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetStoryboardEventHandler: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationStoryboard,
                handler: ?*IUIAnimationStoryboardEventHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationStoryboard,
                handler: ?*IUIAnimationStoryboardEventHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationStoryboard_AddTransition(self: *const T, variable: ?*IUIAnimationVariable, transition: ?*IUIAnimationTransition) HRESULT {
                return @as(*const IUIAnimationStoryboard.VTable, @ptrCast(self.vtable)).AddTransition(@as(*const IUIAnimationStoryboard, @ptrCast(self)), variable, transition);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationStoryboard_AddKeyframeAtOffset(self: *const T, existingKeyframe: UI_ANIMATION_KEYFRAME, offset: f64, keyframe: ?*UI_ANIMATION_KEYFRAME) HRESULT {
                return @as(*const IUIAnimationStoryboard.VTable, @ptrCast(self.vtable)).AddKeyframeAtOffset(@as(*const IUIAnimationStoryboard, @ptrCast(self)), existingKeyframe, offset, keyframe);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationStoryboard_AddKeyframeAfterTransition(self: *const T, transition: ?*IUIAnimationTransition, keyframe: ?*UI_ANIMATION_KEYFRAME) HRESULT {
                return @as(*const IUIAnimationStoryboard.VTable, @ptrCast(self.vtable)).AddKeyframeAfterTransition(@as(*const IUIAnimationStoryboard, @ptrCast(self)), transition, keyframe);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationStoryboard_AddTransitionAtKeyframe(self: *const T, variable: ?*IUIAnimationVariable, transition: ?*IUIAnimationTransition, startKeyframe: UI_ANIMATION_KEYFRAME) HRESULT {
                return @as(*const IUIAnimationStoryboard.VTable, @ptrCast(self.vtable)).AddTransitionAtKeyframe(@as(*const IUIAnimationStoryboard, @ptrCast(self)), variable, transition, startKeyframe);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationStoryboard_AddTransitionBetweenKeyframes(self: *const T, variable: ?*IUIAnimationVariable, transition: ?*IUIAnimationTransition, startKeyframe: UI_ANIMATION_KEYFRAME, endKeyframe: UI_ANIMATION_KEYFRAME) HRESULT {
                return @as(*const IUIAnimationStoryboard.VTable, @ptrCast(self.vtable)).AddTransitionBetweenKeyframes(@as(*const IUIAnimationStoryboard, @ptrCast(self)), variable, transition, startKeyframe, endKeyframe);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationStoryboard_RepeatBetweenKeyframes(self: *const T, startKeyframe: UI_ANIMATION_KEYFRAME, endKeyframe: UI_ANIMATION_KEYFRAME, repetitionCount: i32) HRESULT {
                return @as(*const IUIAnimationStoryboard.VTable, @ptrCast(self.vtable)).RepeatBetweenKeyframes(@as(*const IUIAnimationStoryboard, @ptrCast(self)), startKeyframe, endKeyframe, repetitionCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationStoryboard_HoldVariable(self: *const T, variable: ?*IUIAnimationVariable) HRESULT {
                return @as(*const IUIAnimationStoryboard.VTable, @ptrCast(self.vtable)).HoldVariable(@as(*const IUIAnimationStoryboard, @ptrCast(self)), variable);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationStoryboard_SetLongestAcceptableDelay(self: *const T, delay: f64) HRESULT {
                return @as(*const IUIAnimationStoryboard.VTable, @ptrCast(self.vtable)).SetLongestAcceptableDelay(@as(*const IUIAnimationStoryboard, @ptrCast(self)), delay);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationStoryboard_Schedule(self: *const T, timeNow: f64, schedulingResult: ?*UI_ANIMATION_SCHEDULING_RESULT) HRESULT {
                return @as(*const IUIAnimationStoryboard.VTable, @ptrCast(self.vtable)).Schedule(@as(*const IUIAnimationStoryboard, @ptrCast(self)), timeNow, schedulingResult);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationStoryboard_Conclude(self: *const T) HRESULT {
                return @as(*const IUIAnimationStoryboard.VTable, @ptrCast(self.vtable)).Conclude(@as(*const IUIAnimationStoryboard, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationStoryboard_Finish(self: *const T, completionDeadline: f64) HRESULT {
                return @as(*const IUIAnimationStoryboard.VTable, @ptrCast(self.vtable)).Finish(@as(*const IUIAnimationStoryboard, @ptrCast(self)), completionDeadline);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationStoryboard_Abandon(self: *const T) HRESULT {
                return @as(*const IUIAnimationStoryboard.VTable, @ptrCast(self.vtable)).Abandon(@as(*const IUIAnimationStoryboard, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationStoryboard_SetTag(self: *const T, object: ?*IUnknown, id: u32) HRESULT {
                return @as(*const IUIAnimationStoryboard.VTable, @ptrCast(self.vtable)).SetTag(@as(*const IUIAnimationStoryboard, @ptrCast(self)), object, id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationStoryboard_GetTag(self: *const T, object: ?*?*IUnknown, id: ?*u32) HRESULT {
                return @as(*const IUIAnimationStoryboard.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IUIAnimationStoryboard, @ptrCast(self)), object, id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationStoryboard_GetStatus(self: *const T, status: ?*UI_ANIMATION_STORYBOARD_STATUS) HRESULT {
                return @as(*const IUIAnimationStoryboard.VTable, @ptrCast(self.vtable)).GetStatus(@as(*const IUIAnimationStoryboard, @ptrCast(self)), status);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationStoryboard_GetElapsedTime(self: *const T, elapsedTime: ?*f64) HRESULT {
                return @as(*const IUIAnimationStoryboard.VTable, @ptrCast(self.vtable)).GetElapsedTime(@as(*const IUIAnimationStoryboard, @ptrCast(self)), elapsedTime);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationStoryboard_SetStoryboardEventHandler(self: *const T, handler: ?*IUIAnimationStoryboardEventHandler) HRESULT {
                return @as(*const IUIAnimationStoryboard.VTable, @ptrCast(self.vtable)).SetStoryboardEventHandler(@as(*const IUIAnimationStoryboard, @ptrCast(self)), handler);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IUIAnimationTransition_Value = Guid.initString("dc6ce252-f731-41cf-b610-614b6ca049ad");
pub const IID_IUIAnimationTransition = &IID_IUIAnimationTransition_Value;
pub const IUIAnimationTransition = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetInitialValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationTransition,
                value: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationTransition,
                value: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetInitialVelocity: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationTransition,
                velocity: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationTransition,
                velocity: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsDurationKnown: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationTransition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationTransition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDuration: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationTransition,
                duration: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationTransition,
                duration: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationTransition_SetInitialValue(self: *const T, value: f64) HRESULT {
                return @as(*const IUIAnimationTransition.VTable, @ptrCast(self.vtable)).SetInitialValue(@as(*const IUIAnimationTransition, @ptrCast(self)), value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationTransition_SetInitialVelocity(self: *const T, velocity: f64) HRESULT {
                return @as(*const IUIAnimationTransition.VTable, @ptrCast(self.vtable)).SetInitialVelocity(@as(*const IUIAnimationTransition, @ptrCast(self)), velocity);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationTransition_IsDurationKnown(self: *const T) HRESULT {
                return @as(*const IUIAnimationTransition.VTable, @ptrCast(self.vtable)).IsDurationKnown(@as(*const IUIAnimationTransition, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationTransition_GetDuration(self: *const T, duration: ?*f64) HRESULT {
                return @as(*const IUIAnimationTransition.VTable, @ptrCast(self.vtable)).GetDuration(@as(*const IUIAnimationTransition, @ptrCast(self)), duration);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IUIAnimationManagerEventHandler_Value = Guid.initString("783321ed-78a3-4366-b574-6af607a64788");
pub const IID_IUIAnimationManagerEventHandler = &IID_IUIAnimationManagerEventHandler_Value;
pub const IUIAnimationManagerEventHandler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnManagerStatusChanged: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationManagerEventHandler,
                newStatus: UI_ANIMATION_MANAGER_STATUS,
                previousStatus: UI_ANIMATION_MANAGER_STATUS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationManagerEventHandler,
                newStatus: UI_ANIMATION_MANAGER_STATUS,
                previousStatus: UI_ANIMATION_MANAGER_STATUS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationManagerEventHandler_OnManagerStatusChanged(self: *const T, newStatus: UI_ANIMATION_MANAGER_STATUS, previousStatus: UI_ANIMATION_MANAGER_STATUS) HRESULT {
                return @as(*const IUIAnimationManagerEventHandler.VTable, @ptrCast(self.vtable)).OnManagerStatusChanged(@as(*const IUIAnimationManagerEventHandler, @ptrCast(self)), newStatus, previousStatus);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IUIAnimationVariableChangeHandler_Value = Guid.initString("6358b7ba-87d2-42d5-bf71-82e919dd5862");
pub const IID_IUIAnimationVariableChangeHandler = &IID_IUIAnimationVariableChangeHandler_Value;
pub const IUIAnimationVariableChangeHandler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnValueChanged: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationVariableChangeHandler,
                storyboard: ?*IUIAnimationStoryboard,
                variable: ?*IUIAnimationVariable,
                newValue: f64,
                previousValue: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationVariableChangeHandler,
                storyboard: ?*IUIAnimationStoryboard,
                variable: ?*IUIAnimationVariable,
                newValue: f64,
                previousValue: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationVariableChangeHandler_OnValueChanged(self: *const T, storyboard: ?*IUIAnimationStoryboard, variable: ?*IUIAnimationVariable, newValue: f64, previousValue: f64) HRESULT {
                return @as(*const IUIAnimationVariableChangeHandler.VTable, @ptrCast(self.vtable)).OnValueChanged(@as(*const IUIAnimationVariableChangeHandler, @ptrCast(self)), storyboard, variable, newValue, previousValue);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IUIAnimationVariableIntegerChangeHandler_Value = Guid.initString("bb3e1550-356e-44b0-99da-85ac6017865e");
pub const IID_IUIAnimationVariableIntegerChangeHandler = &IID_IUIAnimationVariableIntegerChangeHandler_Value;
pub const IUIAnimationVariableIntegerChangeHandler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnIntegerValueChanged: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationVariableIntegerChangeHandler,
                storyboard: ?*IUIAnimationStoryboard,
                variable: ?*IUIAnimationVariable,
                newValue: i32,
                previousValue: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationVariableIntegerChangeHandler,
                storyboard: ?*IUIAnimationStoryboard,
                variable: ?*IUIAnimationVariable,
                newValue: i32,
                previousValue: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationVariableIntegerChangeHandler_OnIntegerValueChanged(self: *const T, storyboard: ?*IUIAnimationStoryboard, variable: ?*IUIAnimationVariable, newValue: i32, previousValue: i32) HRESULT {
                return @as(*const IUIAnimationVariableIntegerChangeHandler.VTable, @ptrCast(self.vtable)).OnIntegerValueChanged(@as(*const IUIAnimationVariableIntegerChangeHandler, @ptrCast(self)), storyboard, variable, newValue, previousValue);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IUIAnimationStoryboardEventHandler_Value = Guid.initString("3d5c9008-ec7c-4364-9f8a-9af3c58cbae6");
pub const IID_IUIAnimationStoryboardEventHandler = &IID_IUIAnimationStoryboardEventHandler_Value;
pub const IUIAnimationStoryboardEventHandler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnStoryboardStatusChanged: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationStoryboardEventHandler,
                storyboard: ?*IUIAnimationStoryboard,
                newStatus: UI_ANIMATION_STORYBOARD_STATUS,
                previousStatus: UI_ANIMATION_STORYBOARD_STATUS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationStoryboardEventHandler,
                storyboard: ?*IUIAnimationStoryboard,
                newStatus: UI_ANIMATION_STORYBOARD_STATUS,
                previousStatus: UI_ANIMATION_STORYBOARD_STATUS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnStoryboardUpdated: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationStoryboardEventHandler,
                storyboard: ?*IUIAnimationStoryboard,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationStoryboardEventHandler,
                storyboard: ?*IUIAnimationStoryboard,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationStoryboardEventHandler_OnStoryboardStatusChanged(self: *const T, storyboard: ?*IUIAnimationStoryboard, newStatus: UI_ANIMATION_STORYBOARD_STATUS, previousStatus: UI_ANIMATION_STORYBOARD_STATUS) HRESULT {
                return @as(*const IUIAnimationStoryboardEventHandler.VTable, @ptrCast(self.vtable)).OnStoryboardStatusChanged(@as(*const IUIAnimationStoryboardEventHandler, @ptrCast(self)), storyboard, newStatus, previousStatus);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationStoryboardEventHandler_OnStoryboardUpdated(self: *const T, storyboard: ?*IUIAnimationStoryboard) HRESULT {
                return @as(*const IUIAnimationStoryboardEventHandler.VTable, @ptrCast(self.vtable)).OnStoryboardUpdated(@as(*const IUIAnimationStoryboardEventHandler, @ptrCast(self)), storyboard);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const UI_ANIMATION_PRIORITY_EFFECT = enum(i32) {
    FAILURE = 0,
    DELAY = 1,
};
pub const UI_ANIMATION_PRIORITY_EFFECT_FAILURE = UI_ANIMATION_PRIORITY_EFFECT.FAILURE;
pub const UI_ANIMATION_PRIORITY_EFFECT_DELAY = UI_ANIMATION_PRIORITY_EFFECT.DELAY;

// TODO: this type is limited to platform 'windows6.1'
const IID_IUIAnimationPriorityComparison_Value = Guid.initString("83fa9b74-5f86-4618-bc6a-a2fac19b3f44");
pub const IID_IUIAnimationPriorityComparison = &IID_IUIAnimationPriorityComparison_Value;
pub const IUIAnimationPriorityComparison = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        HasPriority: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationPriorityComparison,
                scheduledStoryboard: ?*IUIAnimationStoryboard,
                newStoryboard: ?*IUIAnimationStoryboard,
                priorityEffect: UI_ANIMATION_PRIORITY_EFFECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationPriorityComparison,
                scheduledStoryboard: ?*IUIAnimationStoryboard,
                newStoryboard: ?*IUIAnimationStoryboard,
                priorityEffect: UI_ANIMATION_PRIORITY_EFFECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationPriorityComparison_HasPriority(self: *const T, scheduledStoryboard: ?*IUIAnimationStoryboard, newStoryboard: ?*IUIAnimationStoryboard, priorityEffect: UI_ANIMATION_PRIORITY_EFFECT) HRESULT {
                return @as(*const IUIAnimationPriorityComparison.VTable, @ptrCast(self.vtable)).HasPriority(@as(*const IUIAnimationPriorityComparison, @ptrCast(self)), scheduledStoryboard, newStoryboard, priorityEffect);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const UI_ANIMATION_SLOPE = enum(i32) {
    INCREASING = 0,
    DECREASING = 1,
};
pub const UI_ANIMATION_SLOPE_INCREASING = UI_ANIMATION_SLOPE.INCREASING;
pub const UI_ANIMATION_SLOPE_DECREASING = UI_ANIMATION_SLOPE.DECREASING;

// TODO: this type is limited to platform 'windows6.1'
const IID_IUIAnimationTransitionLibrary_Value = Guid.initString("ca5a14b1-d24f-48b8-8fe4-c78169ba954e");
pub const IID_IUIAnimationTransitionLibrary = &IID_IUIAnimationTransitionLibrary_Value;
pub const IUIAnimationTransitionLibrary = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateInstantaneousTransition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationTransitionLibrary,
                finalValue: f64,
                transition: ?*?*IUIAnimationTransition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationTransitionLibrary,
                finalValue: f64,
                transition: ?*?*IUIAnimationTransition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateConstantTransition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationTransitionLibrary,
                duration: f64,
                transition: ?*?*IUIAnimationTransition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationTransitionLibrary,
                duration: f64,
                transition: ?*?*IUIAnimationTransition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateDiscreteTransition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationTransitionLibrary,
                delay: f64,
                finalValue: f64,
                hold: f64,
                transition: ?*?*IUIAnimationTransition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationTransitionLibrary,
                delay: f64,
                finalValue: f64,
                hold: f64,
                transition: ?*?*IUIAnimationTransition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateLinearTransition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationTransitionLibrary,
                duration: f64,
                finalValue: f64,
                transition: ?*?*IUIAnimationTransition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationTransitionLibrary,
                duration: f64,
                finalValue: f64,
                transition: ?*?*IUIAnimationTransition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateLinearTransitionFromSpeed: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationTransitionLibrary,
                speed: f64,
                finalValue: f64,
                transition: ?*?*IUIAnimationTransition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationTransitionLibrary,
                speed: f64,
                finalValue: f64,
                transition: ?*?*IUIAnimationTransition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateSinusoidalTransitionFromVelocity: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationTransitionLibrary,
                duration: f64,
                period: f64,
                transition: ?*?*IUIAnimationTransition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationTransitionLibrary,
                duration: f64,
                period: f64,
                transition: ?*?*IUIAnimationTransition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateSinusoidalTransitionFromRange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationTransitionLibrary,
                duration: f64,
                minimumValue: f64,
                maximumValue: f64,
                period: f64,
                slope: UI_ANIMATION_SLOPE,
                transition: ?*?*IUIAnimationTransition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationTransitionLibrary,
                duration: f64,
                minimumValue: f64,
                maximumValue: f64,
                period: f64,
                slope: UI_ANIMATION_SLOPE,
                transition: ?*?*IUIAnimationTransition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateAccelerateDecelerateTransition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationTransitionLibrary,
                duration: f64,
                finalValue: f64,
                accelerationRatio: f64,
                decelerationRatio: f64,
                transition: ?*?*IUIAnimationTransition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationTransitionLibrary,
                duration: f64,
                finalValue: f64,
                accelerationRatio: f64,
                decelerationRatio: f64,
                transition: ?*?*IUIAnimationTransition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateReversalTransition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationTransitionLibrary,
                duration: f64,
                transition: ?*?*IUIAnimationTransition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationTransitionLibrary,
                duration: f64,
                transition: ?*?*IUIAnimationTransition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateCubicTransition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationTransitionLibrary,
                duration: f64,
                finalValue: f64,
                finalVelocity: f64,
                transition: ?*?*IUIAnimationTransition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationTransitionLibrary,
                duration: f64,
                finalValue: f64,
                finalVelocity: f64,
                transition: ?*?*IUIAnimationTransition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateSmoothStopTransition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationTransitionLibrary,
                maximumDuration: f64,
                finalValue: f64,
                transition: ?*?*IUIAnimationTransition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationTransitionLibrary,
                maximumDuration: f64,
                finalValue: f64,
                transition: ?*?*IUIAnimationTransition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateParabolicTransitionFromAcceleration: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationTransitionLibrary,
                finalValue: f64,
                finalVelocity: f64,
                acceleration: f64,
                transition: ?*?*IUIAnimationTransition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationTransitionLibrary,
                finalValue: f64,
                finalVelocity: f64,
                acceleration: f64,
                transition: ?*?*IUIAnimationTransition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationTransitionLibrary_CreateInstantaneousTransition(self: *const T, finalValue: f64, transition: ?*?*IUIAnimationTransition) HRESULT {
                return @as(*const IUIAnimationTransitionLibrary.VTable, @ptrCast(self.vtable)).CreateInstantaneousTransition(@as(*const IUIAnimationTransitionLibrary, @ptrCast(self)), finalValue, transition);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationTransitionLibrary_CreateConstantTransition(self: *const T, duration: f64, transition: ?*?*IUIAnimationTransition) HRESULT {
                return @as(*const IUIAnimationTransitionLibrary.VTable, @ptrCast(self.vtable)).CreateConstantTransition(@as(*const IUIAnimationTransitionLibrary, @ptrCast(self)), duration, transition);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationTransitionLibrary_CreateDiscreteTransition(self: *const T, delay: f64, finalValue: f64, hold: f64, transition: ?*?*IUIAnimationTransition) HRESULT {
                return @as(*const IUIAnimationTransitionLibrary.VTable, @ptrCast(self.vtable)).CreateDiscreteTransition(@as(*const IUIAnimationTransitionLibrary, @ptrCast(self)), delay, finalValue, hold, transition);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationTransitionLibrary_CreateLinearTransition(self: *const T, duration: f64, finalValue: f64, transition: ?*?*IUIAnimationTransition) HRESULT {
                return @as(*const IUIAnimationTransitionLibrary.VTable, @ptrCast(self.vtable)).CreateLinearTransition(@as(*const IUIAnimationTransitionLibrary, @ptrCast(self)), duration, finalValue, transition);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationTransitionLibrary_CreateLinearTransitionFromSpeed(self: *const T, speed: f64, finalValue: f64, transition: ?*?*IUIAnimationTransition) HRESULT {
                return @as(*const IUIAnimationTransitionLibrary.VTable, @ptrCast(self.vtable)).CreateLinearTransitionFromSpeed(@as(*const IUIAnimationTransitionLibrary, @ptrCast(self)), speed, finalValue, transition);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationTransitionLibrary_CreateSinusoidalTransitionFromVelocity(self: *const T, duration: f64, period: f64, transition: ?*?*IUIAnimationTransition) HRESULT {
                return @as(*const IUIAnimationTransitionLibrary.VTable, @ptrCast(self.vtable)).CreateSinusoidalTransitionFromVelocity(@as(*const IUIAnimationTransitionLibrary, @ptrCast(self)), duration, period, transition);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationTransitionLibrary_CreateSinusoidalTransitionFromRange(self: *const T, duration: f64, minimumValue: f64, maximumValue: f64, period: f64, slope: UI_ANIMATION_SLOPE, transition: ?*?*IUIAnimationTransition) HRESULT {
                return @as(*const IUIAnimationTransitionLibrary.VTable, @ptrCast(self.vtable)).CreateSinusoidalTransitionFromRange(@as(*const IUIAnimationTransitionLibrary, @ptrCast(self)), duration, minimumValue, maximumValue, period, slope, transition);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationTransitionLibrary_CreateAccelerateDecelerateTransition(self: *const T, duration: f64, finalValue: f64, accelerationRatio: f64, decelerationRatio: f64, transition: ?*?*IUIAnimationTransition) HRESULT {
                return @as(*const IUIAnimationTransitionLibrary.VTable, @ptrCast(self.vtable)).CreateAccelerateDecelerateTransition(@as(*const IUIAnimationTransitionLibrary, @ptrCast(self)), duration, finalValue, accelerationRatio, decelerationRatio, transition);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationTransitionLibrary_CreateReversalTransition(self: *const T, duration: f64, transition: ?*?*IUIAnimationTransition) HRESULT {
                return @as(*const IUIAnimationTransitionLibrary.VTable, @ptrCast(self.vtable)).CreateReversalTransition(@as(*const IUIAnimationTransitionLibrary, @ptrCast(self)), duration, transition);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationTransitionLibrary_CreateCubicTransition(self: *const T, duration: f64, finalValue: f64, finalVelocity: f64, transition: ?*?*IUIAnimationTransition) HRESULT {
                return @as(*const IUIAnimationTransitionLibrary.VTable, @ptrCast(self.vtable)).CreateCubicTransition(@as(*const IUIAnimationTransitionLibrary, @ptrCast(self)), duration, finalValue, finalVelocity, transition);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationTransitionLibrary_CreateSmoothStopTransition(self: *const T, maximumDuration: f64, finalValue: f64, transition: ?*?*IUIAnimationTransition) HRESULT {
                return @as(*const IUIAnimationTransitionLibrary.VTable, @ptrCast(self.vtable)).CreateSmoothStopTransition(@as(*const IUIAnimationTransitionLibrary, @ptrCast(self)), maximumDuration, finalValue, transition);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationTransitionLibrary_CreateParabolicTransitionFromAcceleration(self: *const T, finalValue: f64, finalVelocity: f64, acceleration: f64, transition: ?*?*IUIAnimationTransition) HRESULT {
                return @as(*const IUIAnimationTransitionLibrary.VTable, @ptrCast(self.vtable)).CreateParabolicTransitionFromAcceleration(@as(*const IUIAnimationTransitionLibrary, @ptrCast(self)), finalValue, finalVelocity, acceleration, transition);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const UI_ANIMATION_DEPENDENCIES = enum(u32) {
    NONE = 0,
    INTERMEDIATE_VALUES = 1,
    FINAL_VALUE = 2,
    FINAL_VELOCITY = 4,
    DURATION = 8,
    _,
    pub fn initFlags(o: struct {
        NONE: u1 = 0,
        INTERMEDIATE_VALUES: u1 = 0,
        FINAL_VALUE: u1 = 0,
        FINAL_VELOCITY: u1 = 0,
        DURATION: u1 = 0,
    }) UI_ANIMATION_DEPENDENCIES {
        return @as(UI_ANIMATION_DEPENDENCIES, @enumFromInt((if (o.NONE == 1) @intFromEnum(UI_ANIMATION_DEPENDENCIES.NONE) else 0) | (if (o.INTERMEDIATE_VALUES == 1) @intFromEnum(UI_ANIMATION_DEPENDENCIES.INTERMEDIATE_VALUES) else 0) | (if (o.FINAL_VALUE == 1) @intFromEnum(UI_ANIMATION_DEPENDENCIES.FINAL_VALUE) else 0) | (if (o.FINAL_VELOCITY == 1) @intFromEnum(UI_ANIMATION_DEPENDENCIES.FINAL_VELOCITY) else 0) | (if (o.DURATION == 1) @intFromEnum(UI_ANIMATION_DEPENDENCIES.DURATION) else 0)));
    }
};
pub const UI_ANIMATION_DEPENDENCY_NONE = UI_ANIMATION_DEPENDENCIES.NONE;
pub const UI_ANIMATION_DEPENDENCY_INTERMEDIATE_VALUES = UI_ANIMATION_DEPENDENCIES.INTERMEDIATE_VALUES;
pub const UI_ANIMATION_DEPENDENCY_FINAL_VALUE = UI_ANIMATION_DEPENDENCIES.FINAL_VALUE;
pub const UI_ANIMATION_DEPENDENCY_FINAL_VELOCITY = UI_ANIMATION_DEPENDENCIES.FINAL_VELOCITY;
pub const UI_ANIMATION_DEPENDENCY_DURATION = UI_ANIMATION_DEPENDENCIES.DURATION;

// TODO: this type is limited to platform 'windows6.1'
const IID_IUIAnimationInterpolator_Value = Guid.initString("7815cbba-ddf7-478c-a46c-7b6c738b7978");
pub const IID_IUIAnimationInterpolator = &IID_IUIAnimationInterpolator_Value;
pub const IUIAnimationInterpolator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetInitialValueAndVelocity: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationInterpolator,
                initialValue: f64,
                initialVelocity: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationInterpolator,
                initialValue: f64,
                initialVelocity: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDuration: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationInterpolator,
                duration: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationInterpolator,
                duration: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDuration: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationInterpolator,
                duration: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationInterpolator,
                duration: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFinalValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationInterpolator,
                value: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationInterpolator,
                value: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InterpolateValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationInterpolator,
                offset: f64,
                value: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationInterpolator,
                offset: f64,
                value: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InterpolateVelocity: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationInterpolator,
                offset: f64,
                velocity: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationInterpolator,
                offset: f64,
                velocity: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDependencies: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationInterpolator,
                initialValueDependencies: ?*UI_ANIMATION_DEPENDENCIES,
                initialVelocityDependencies: ?*UI_ANIMATION_DEPENDENCIES,
                durationDependencies: ?*UI_ANIMATION_DEPENDENCIES,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationInterpolator,
                initialValueDependencies: ?*UI_ANIMATION_DEPENDENCIES,
                initialVelocityDependencies: ?*UI_ANIMATION_DEPENDENCIES,
                durationDependencies: ?*UI_ANIMATION_DEPENDENCIES,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationInterpolator_SetInitialValueAndVelocity(self: *const T, initialValue: f64, initialVelocity: f64) HRESULT {
                return @as(*const IUIAnimationInterpolator.VTable, @ptrCast(self.vtable)).SetInitialValueAndVelocity(@as(*const IUIAnimationInterpolator, @ptrCast(self)), initialValue, initialVelocity);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationInterpolator_SetDuration(self: *const T, duration: f64) HRESULT {
                return @as(*const IUIAnimationInterpolator.VTable, @ptrCast(self.vtable)).SetDuration(@as(*const IUIAnimationInterpolator, @ptrCast(self)), duration);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationInterpolator_GetDuration(self: *const T, duration: ?*f64) HRESULT {
                return @as(*const IUIAnimationInterpolator.VTable, @ptrCast(self.vtable)).GetDuration(@as(*const IUIAnimationInterpolator, @ptrCast(self)), duration);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationInterpolator_GetFinalValue(self: *const T, value: ?*f64) HRESULT {
                return @as(*const IUIAnimationInterpolator.VTable, @ptrCast(self.vtable)).GetFinalValue(@as(*const IUIAnimationInterpolator, @ptrCast(self)), value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationInterpolator_InterpolateValue(self: *const T, offset: f64, value: ?*f64) HRESULT {
                return @as(*const IUIAnimationInterpolator.VTable, @ptrCast(self.vtable)).InterpolateValue(@as(*const IUIAnimationInterpolator, @ptrCast(self)), offset, value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationInterpolator_InterpolateVelocity(self: *const T, offset: f64, velocity: ?*f64) HRESULT {
                return @as(*const IUIAnimationInterpolator.VTable, @ptrCast(self.vtable)).InterpolateVelocity(@as(*const IUIAnimationInterpolator, @ptrCast(self)), offset, velocity);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationInterpolator_GetDependencies(self: *const T, initialValueDependencies: ?*UI_ANIMATION_DEPENDENCIES, initialVelocityDependencies: ?*UI_ANIMATION_DEPENDENCIES, durationDependencies: ?*UI_ANIMATION_DEPENDENCIES) HRESULT {
                return @as(*const IUIAnimationInterpolator.VTable, @ptrCast(self.vtable)).GetDependencies(@as(*const IUIAnimationInterpolator, @ptrCast(self)), initialValueDependencies, initialVelocityDependencies, durationDependencies);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IUIAnimationTransitionFactory_Value = Guid.initString("fcd91e03-3e3b-45ad-bbb1-6dfc8153743d");
pub const IID_IUIAnimationTransitionFactory = &IID_IUIAnimationTransitionFactory_Value;
pub const IUIAnimationTransitionFactory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateTransition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationTransitionFactory,
                interpolator: ?*IUIAnimationInterpolator,
                transition: ?*?*IUIAnimationTransition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationTransitionFactory,
                interpolator: ?*IUIAnimationInterpolator,
                transition: ?*?*IUIAnimationTransition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationTransitionFactory_CreateTransition(self: *const T, interpolator: ?*IUIAnimationInterpolator, transition: ?*?*IUIAnimationTransition) HRESULT {
                return @as(*const IUIAnimationTransitionFactory.VTable, @ptrCast(self.vtable)).CreateTransition(@as(*const IUIAnimationTransitionFactory, @ptrCast(self)), interpolator, transition);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const UI_ANIMATION_IDLE_BEHAVIOR = enum(i32) {
    CONTINUE = 0,
    DISABLE = 1,
};
pub const UI_ANIMATION_IDLE_BEHAVIOR_CONTINUE = UI_ANIMATION_IDLE_BEHAVIOR.CONTINUE;
pub const UI_ANIMATION_IDLE_BEHAVIOR_DISABLE = UI_ANIMATION_IDLE_BEHAVIOR.DISABLE;

// TODO: this type is limited to platform 'windows6.1'
const IID_IUIAnimationTimer_Value = Guid.initString("6b0efad1-a053-41d6-9085-33a689144665");
pub const IID_IUIAnimationTimer = &IID_IUIAnimationTimer_Value;
pub const IUIAnimationTimer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetTimerUpdateHandler: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationTimer,
                updateHandler: ?*IUIAnimationTimerUpdateHandler,
                idleBehavior: UI_ANIMATION_IDLE_BEHAVIOR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationTimer,
                updateHandler: ?*IUIAnimationTimerUpdateHandler,
                idleBehavior: UI_ANIMATION_IDLE_BEHAVIOR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTimerEventHandler: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationTimer,
                handler: ?*IUIAnimationTimerEventHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationTimer,
                handler: ?*IUIAnimationTimerEventHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Enable: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationTimer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationTimer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Disable: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationTimer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationTimer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsEnabled: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationTimer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationTimer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationTimer,
                seconds: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationTimer,
                seconds: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFrameRateThreshold: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationTimer,
                framesPerSecond: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationTimer,
                framesPerSecond: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationTimer_SetTimerUpdateHandler(self: *const T, updateHandler: ?*IUIAnimationTimerUpdateHandler, idleBehavior: UI_ANIMATION_IDLE_BEHAVIOR) HRESULT {
                return @as(*const IUIAnimationTimer.VTable, @ptrCast(self.vtable)).SetTimerUpdateHandler(@as(*const IUIAnimationTimer, @ptrCast(self)), updateHandler, idleBehavior);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationTimer_SetTimerEventHandler(self: *const T, handler: ?*IUIAnimationTimerEventHandler) HRESULT {
                return @as(*const IUIAnimationTimer.VTable, @ptrCast(self.vtable)).SetTimerEventHandler(@as(*const IUIAnimationTimer, @ptrCast(self)), handler);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationTimer_Enable(self: *const T) HRESULT {
                return @as(*const IUIAnimationTimer.VTable, @ptrCast(self.vtable)).Enable(@as(*const IUIAnimationTimer, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationTimer_Disable(self: *const T) HRESULT {
                return @as(*const IUIAnimationTimer.VTable, @ptrCast(self.vtable)).Disable(@as(*const IUIAnimationTimer, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationTimer_IsEnabled(self: *const T) HRESULT {
                return @as(*const IUIAnimationTimer.VTable, @ptrCast(self.vtable)).IsEnabled(@as(*const IUIAnimationTimer, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationTimer_GetTime(self: *const T, seconds: ?*f64) HRESULT {
                return @as(*const IUIAnimationTimer.VTable, @ptrCast(self.vtable)).GetTime(@as(*const IUIAnimationTimer, @ptrCast(self)), seconds);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationTimer_SetFrameRateThreshold(self: *const T, framesPerSecond: u32) HRESULT {
                return @as(*const IUIAnimationTimer.VTable, @ptrCast(self.vtable)).SetFrameRateThreshold(@as(*const IUIAnimationTimer, @ptrCast(self)), framesPerSecond);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IUIAnimationTimerUpdateHandler_Value = Guid.initString("195509b7-5d5e-4e3e-b278-ee3759b367ad");
pub const IID_IUIAnimationTimerUpdateHandler = &IID_IUIAnimationTimerUpdateHandler_Value;
pub const IUIAnimationTimerUpdateHandler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnUpdate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationTimerUpdateHandler,
                timeNow: f64,
                result: ?*UI_ANIMATION_UPDATE_RESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationTimerUpdateHandler,
                timeNow: f64,
                result: ?*UI_ANIMATION_UPDATE_RESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTimerClientEventHandler: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationTimerUpdateHandler,
                handler: ?*IUIAnimationTimerClientEventHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationTimerUpdateHandler,
                handler: ?*IUIAnimationTimerClientEventHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ClearTimerClientEventHandler: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationTimerUpdateHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationTimerUpdateHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationTimerUpdateHandler_OnUpdate(self: *const T, timeNow: f64, result: ?*UI_ANIMATION_UPDATE_RESULT) HRESULT {
                return @as(*const IUIAnimationTimerUpdateHandler.VTable, @ptrCast(self.vtable)).OnUpdate(@as(*const IUIAnimationTimerUpdateHandler, @ptrCast(self)), timeNow, result);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationTimerUpdateHandler_SetTimerClientEventHandler(self: *const T, handler: ?*IUIAnimationTimerClientEventHandler) HRESULT {
                return @as(*const IUIAnimationTimerUpdateHandler.VTable, @ptrCast(self.vtable)).SetTimerClientEventHandler(@as(*const IUIAnimationTimerUpdateHandler, @ptrCast(self)), handler);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationTimerUpdateHandler_ClearTimerClientEventHandler(self: *const T) HRESULT {
                return @as(*const IUIAnimationTimerUpdateHandler.VTable, @ptrCast(self.vtable)).ClearTimerClientEventHandler(@as(*const IUIAnimationTimerUpdateHandler, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const UI_ANIMATION_TIMER_CLIENT_STATUS = enum(i32) {
    IDLE = 0,
    BUSY = 1,
};
pub const UI_ANIMATION_TIMER_CLIENT_IDLE = UI_ANIMATION_TIMER_CLIENT_STATUS.IDLE;
pub const UI_ANIMATION_TIMER_CLIENT_BUSY = UI_ANIMATION_TIMER_CLIENT_STATUS.BUSY;

// TODO: this type is limited to platform 'windows6.1'
const IID_IUIAnimationTimerClientEventHandler_Value = Guid.initString("bedb4db6-94fa-4bfb-a47f-ef2d9e408c25");
pub const IID_IUIAnimationTimerClientEventHandler = &IID_IUIAnimationTimerClientEventHandler_Value;
pub const IUIAnimationTimerClientEventHandler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnTimerClientStatusChanged: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationTimerClientEventHandler,
                newStatus: UI_ANIMATION_TIMER_CLIENT_STATUS,
                previousStatus: UI_ANIMATION_TIMER_CLIENT_STATUS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationTimerClientEventHandler,
                newStatus: UI_ANIMATION_TIMER_CLIENT_STATUS,
                previousStatus: UI_ANIMATION_TIMER_CLIENT_STATUS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationTimerClientEventHandler_OnTimerClientStatusChanged(self: *const T, newStatus: UI_ANIMATION_TIMER_CLIENT_STATUS, previousStatus: UI_ANIMATION_TIMER_CLIENT_STATUS) HRESULT {
                return @as(*const IUIAnimationTimerClientEventHandler.VTable, @ptrCast(self.vtable)).OnTimerClientStatusChanged(@as(*const IUIAnimationTimerClientEventHandler, @ptrCast(self)), newStatus, previousStatus);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IUIAnimationTimerEventHandler_Value = Guid.initString("274a7dea-d771-4095-abbd-8df7abd23ce3");
pub const IID_IUIAnimationTimerEventHandler = &IID_IUIAnimationTimerEventHandler_Value;
pub const IUIAnimationTimerEventHandler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnPreUpdate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationTimerEventHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationTimerEventHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnPostUpdate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationTimerEventHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationTimerEventHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnRenderingTooSlow: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationTimerEventHandler,
                framesPerSecond: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationTimerEventHandler,
                framesPerSecond: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationTimerEventHandler_OnPreUpdate(self: *const T) HRESULT {
                return @as(*const IUIAnimationTimerEventHandler.VTable, @ptrCast(self.vtable)).OnPreUpdate(@as(*const IUIAnimationTimerEventHandler, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationTimerEventHandler_OnPostUpdate(self: *const T) HRESULT {
                return @as(*const IUIAnimationTimerEventHandler.VTable, @ptrCast(self.vtable)).OnPostUpdate(@as(*const IUIAnimationTimerEventHandler, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationTimerEventHandler_OnRenderingTooSlow(self: *const T, framesPerSecond: u32) HRESULT {
                return @as(*const IUIAnimationTimerEventHandler.VTable, @ptrCast(self.vtable)).OnRenderingTooSlow(@as(*const IUIAnimationTimerEventHandler, @ptrCast(self)), framesPerSecond);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IUIAnimationManager2_Value = Guid.initString("d8b6f7d4-4109-4d3f-acee-879926968cb1");
pub const IID_IUIAnimationManager2 = &IID_IUIAnimationManager2_Value;
pub const IUIAnimationManager2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateAnimationVectorVariable: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationManager2,
                initialValue: [*]const f64,
                cDimension: u32,
                variable: ?*?*IUIAnimationVariable2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationManager2,
                initialValue: [*]const f64,
                cDimension: u32,
                variable: ?*?*IUIAnimationVariable2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateAnimationVariable: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationManager2,
                initialValue: f64,
                variable: ?*?*IUIAnimationVariable2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationManager2,
                initialValue: f64,
                variable: ?*?*IUIAnimationVariable2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ScheduleTransition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationManager2,
                variable: ?*IUIAnimationVariable2,
                transition: ?*IUIAnimationTransition2,
                timeNow: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationManager2,
                variable: ?*IUIAnimationVariable2,
                transition: ?*IUIAnimationTransition2,
                timeNow: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateStoryboard: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationManager2,
                storyboard: ?*?*IUIAnimationStoryboard2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationManager2,
                storyboard: ?*?*IUIAnimationStoryboard2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FinishAllStoryboards: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationManager2,
                completionDeadline: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationManager2,
                completionDeadline: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AbandonAllStoryboards: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationManager2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationManager2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Update: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationManager2,
                timeNow: f64,
                updateResult: ?*UI_ANIMATION_UPDATE_RESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationManager2,
                timeNow: f64,
                updateResult: ?*UI_ANIMATION_UPDATE_RESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVariableFromTag: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationManager2,
                object: ?*IUnknown,
                id: u32,
                variable: ?*?*IUIAnimationVariable2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationManager2,
                object: ?*IUnknown,
                id: u32,
                variable: ?*?*IUIAnimationVariable2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStoryboardFromTag: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationManager2,
                object: ?*IUnknown,
                id: u32,
                storyboard: ?*?*IUIAnimationStoryboard2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationManager2,
                object: ?*IUnknown,
                id: u32,
                storyboard: ?*?*IUIAnimationStoryboard2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EstimateNextEventTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationManager2,
                seconds: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationManager2,
                seconds: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationManager2,
                status: ?*UI_ANIMATION_MANAGER_STATUS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationManager2,
                status: ?*UI_ANIMATION_MANAGER_STATUS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetAnimationMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationManager2,
                mode: UI_ANIMATION_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationManager2,
                mode: UI_ANIMATION_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Pause: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationManager2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationManager2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Resume: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationManager2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationManager2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetManagerEventHandler: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationManager2,
                handler: ?*IUIAnimationManagerEventHandler2,
                fRegisterForNextAnimationEvent: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationManager2,
                handler: ?*IUIAnimationManagerEventHandler2,
                fRegisterForNextAnimationEvent: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCancelPriorityComparison: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationManager2,
                comparison: ?*IUIAnimationPriorityComparison2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationManager2,
                comparison: ?*IUIAnimationPriorityComparison2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTrimPriorityComparison: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationManager2,
                comparison: ?*IUIAnimationPriorityComparison2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationManager2,
                comparison: ?*IUIAnimationPriorityComparison2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCompressPriorityComparison: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationManager2,
                comparison: ?*IUIAnimationPriorityComparison2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationManager2,
                comparison: ?*IUIAnimationPriorityComparison2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetConcludePriorityComparison: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationManager2,
                comparison: ?*IUIAnimationPriorityComparison2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationManager2,
                comparison: ?*IUIAnimationPriorityComparison2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDefaultLongestAcceptableDelay: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationManager2,
                delay: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationManager2,
                delay: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Shutdown: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationManager2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationManager2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationManager2_CreateAnimationVectorVariable(self: *const T, initialValue: [*]const f64, cDimension: u32, variable: ?*?*IUIAnimationVariable2) HRESULT {
                return @as(*const IUIAnimationManager2.VTable, @ptrCast(self.vtable)).CreateAnimationVectorVariable(@as(*const IUIAnimationManager2, @ptrCast(self)), initialValue, cDimension, variable);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationManager2_CreateAnimationVariable(self: *const T, initialValue: f64, variable: ?*?*IUIAnimationVariable2) HRESULT {
                return @as(*const IUIAnimationManager2.VTable, @ptrCast(self.vtable)).CreateAnimationVariable(@as(*const IUIAnimationManager2, @ptrCast(self)), initialValue, variable);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationManager2_ScheduleTransition(self: *const T, variable: ?*IUIAnimationVariable2, transition: ?*IUIAnimationTransition2, timeNow: f64) HRESULT {
                return @as(*const IUIAnimationManager2.VTable, @ptrCast(self.vtable)).ScheduleTransition(@as(*const IUIAnimationManager2, @ptrCast(self)), variable, transition, timeNow);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationManager2_CreateStoryboard(self: *const T, storyboard: ?*?*IUIAnimationStoryboard2) HRESULT {
                return @as(*const IUIAnimationManager2.VTable, @ptrCast(self.vtable)).CreateStoryboard(@as(*const IUIAnimationManager2, @ptrCast(self)), storyboard);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationManager2_FinishAllStoryboards(self: *const T, completionDeadline: f64) HRESULT {
                return @as(*const IUIAnimationManager2.VTable, @ptrCast(self.vtable)).FinishAllStoryboards(@as(*const IUIAnimationManager2, @ptrCast(self)), completionDeadline);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationManager2_AbandonAllStoryboards(self: *const T) HRESULT {
                return @as(*const IUIAnimationManager2.VTable, @ptrCast(self.vtable)).AbandonAllStoryboards(@as(*const IUIAnimationManager2, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationManager2_Update(self: *const T, timeNow: f64, updateResult: ?*UI_ANIMATION_UPDATE_RESULT) HRESULT {
                return @as(*const IUIAnimationManager2.VTable, @ptrCast(self.vtable)).Update(@as(*const IUIAnimationManager2, @ptrCast(self)), timeNow, updateResult);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationManager2_GetVariableFromTag(self: *const T, object: ?*IUnknown, id: u32, variable: ?*?*IUIAnimationVariable2) HRESULT {
                return @as(*const IUIAnimationManager2.VTable, @ptrCast(self.vtable)).GetVariableFromTag(@as(*const IUIAnimationManager2, @ptrCast(self)), object, id, variable);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationManager2_GetStoryboardFromTag(self: *const T, object: ?*IUnknown, id: u32, storyboard: ?*?*IUIAnimationStoryboard2) HRESULT {
                return @as(*const IUIAnimationManager2.VTable, @ptrCast(self.vtable)).GetStoryboardFromTag(@as(*const IUIAnimationManager2, @ptrCast(self)), object, id, storyboard);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationManager2_EstimateNextEventTime(self: *const T, seconds: ?*f64) HRESULT {
                return @as(*const IUIAnimationManager2.VTable, @ptrCast(self.vtable)).EstimateNextEventTime(@as(*const IUIAnimationManager2, @ptrCast(self)), seconds);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationManager2_GetStatus(self: *const T, status: ?*UI_ANIMATION_MANAGER_STATUS) HRESULT {
                return @as(*const IUIAnimationManager2.VTable, @ptrCast(self.vtable)).GetStatus(@as(*const IUIAnimationManager2, @ptrCast(self)), status);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationManager2_SetAnimationMode(self: *const T, mode: UI_ANIMATION_MODE) HRESULT {
                return @as(*const IUIAnimationManager2.VTable, @ptrCast(self.vtable)).SetAnimationMode(@as(*const IUIAnimationManager2, @ptrCast(self)), mode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationManager2_Pause(self: *const T) HRESULT {
                return @as(*const IUIAnimationManager2.VTable, @ptrCast(self.vtable)).Pause(@as(*const IUIAnimationManager2, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationManager2_Resume(self: *const T) HRESULT {
                return @as(*const IUIAnimationManager2.VTable, @ptrCast(self.vtable)).Resume(@as(*const IUIAnimationManager2, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationManager2_SetManagerEventHandler(self: *const T, handler: ?*IUIAnimationManagerEventHandler2, fRegisterForNextAnimationEvent: BOOL) HRESULT {
                return @as(*const IUIAnimationManager2.VTable, @ptrCast(self.vtable)).SetManagerEventHandler(@as(*const IUIAnimationManager2, @ptrCast(self)), handler, fRegisterForNextAnimationEvent);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationManager2_SetCancelPriorityComparison(self: *const T, comparison: ?*IUIAnimationPriorityComparison2) HRESULT {
                return @as(*const IUIAnimationManager2.VTable, @ptrCast(self.vtable)).SetCancelPriorityComparison(@as(*const IUIAnimationManager2, @ptrCast(self)), comparison);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationManager2_SetTrimPriorityComparison(self: *const T, comparison: ?*IUIAnimationPriorityComparison2) HRESULT {
                return @as(*const IUIAnimationManager2.VTable, @ptrCast(self.vtable)).SetTrimPriorityComparison(@as(*const IUIAnimationManager2, @ptrCast(self)), comparison);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationManager2_SetCompressPriorityComparison(self: *const T, comparison: ?*IUIAnimationPriorityComparison2) HRESULT {
                return @as(*const IUIAnimationManager2.VTable, @ptrCast(self.vtable)).SetCompressPriorityComparison(@as(*const IUIAnimationManager2, @ptrCast(self)), comparison);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationManager2_SetConcludePriorityComparison(self: *const T, comparison: ?*IUIAnimationPriorityComparison2) HRESULT {
                return @as(*const IUIAnimationManager2.VTable, @ptrCast(self.vtable)).SetConcludePriorityComparison(@as(*const IUIAnimationManager2, @ptrCast(self)), comparison);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationManager2_SetDefaultLongestAcceptableDelay(self: *const T, delay: f64) HRESULT {
                return @as(*const IUIAnimationManager2.VTable, @ptrCast(self.vtable)).SetDefaultLongestAcceptableDelay(@as(*const IUIAnimationManager2, @ptrCast(self)), delay);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationManager2_Shutdown(self: *const T) HRESULT {
                return @as(*const IUIAnimationManager2.VTable, @ptrCast(self.vtable)).Shutdown(@as(*const IUIAnimationManager2, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IUIAnimationVariable2_Value = Guid.initString("4914b304-96ab-44d9-9e77-d5109b7e7466");
pub const IID_IUIAnimationVariable2 = &IID_IUIAnimationVariable2_Value;
pub const IUIAnimationVariable2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDimension: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationVariable2,
                dimension: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationVariable2,
                dimension: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationVariable2,
                value: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationVariable2,
                value: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVectorValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationVariable2,
                value: [*]f64,
                cDimension: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationVariable2,
                value: [*]f64,
                cDimension: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurve: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationVariable2,
                animation: ?*IDCompositionAnimation,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationVariable2,
                animation: ?*IDCompositionAnimation,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVectorCurve: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationVariable2,
                animation: [*]?*IDCompositionAnimation,
                cDimension: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationVariable2,
                animation: [*]?*IDCompositionAnimation,
                cDimension: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFinalValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationVariable2,
                finalValue: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationVariable2,
                finalValue: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFinalVectorValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationVariable2,
                finalValue: [*]f64,
                cDimension: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationVariable2,
                finalValue: [*]f64,
                cDimension: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPreviousValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationVariable2,
                previousValue: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationVariable2,
                previousValue: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPreviousVectorValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationVariable2,
                previousValue: [*]f64,
                cDimension: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationVariable2,
                previousValue: [*]f64,
                cDimension: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIntegerValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationVariable2,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationVariable2,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIntegerVectorValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationVariable2,
                value: [*]i32,
                cDimension: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationVariable2,
                value: [*]i32,
                cDimension: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFinalIntegerValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationVariable2,
                finalValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationVariable2,
                finalValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFinalIntegerVectorValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationVariable2,
                finalValue: [*]i32,
                cDimension: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationVariable2,
                finalValue: [*]i32,
                cDimension: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPreviousIntegerValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationVariable2,
                previousValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationVariable2,
                previousValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPreviousIntegerVectorValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationVariable2,
                previousValue: [*]i32,
                cDimension: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationVariable2,
                previousValue: [*]i32,
                cDimension: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentStoryboard: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationVariable2,
                storyboard: ?*?*IUIAnimationStoryboard2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationVariable2,
                storyboard: ?*?*IUIAnimationStoryboard2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetLowerBound: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationVariable2,
                bound: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationVariable2,
                bound: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetLowerBoundVector: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationVariable2,
                bound: [*]const f64,
                cDimension: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationVariable2,
                bound: [*]const f64,
                cDimension: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetUpperBound: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationVariable2,
                bound: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationVariable2,
                bound: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetUpperBoundVector: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationVariable2,
                bound: [*]const f64,
                cDimension: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationVariable2,
                bound: [*]const f64,
                cDimension: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetRoundingMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationVariable2,
                mode: UI_ANIMATION_ROUNDING_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationVariable2,
                mode: UI_ANIMATION_ROUNDING_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTag: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationVariable2,
                object: ?*IUnknown,
                id: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationVariable2,
                object: ?*IUnknown,
                id: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTag: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationVariable2,
                object: ?*?*IUnknown,
                id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationVariable2,
                object: ?*?*IUnknown,
                id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetVariableChangeHandler: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationVariable2,
                handler: ?*IUIAnimationVariableChangeHandler2,
                fRegisterForNextAnimationEvent: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationVariable2,
                handler: ?*IUIAnimationVariableChangeHandler2,
                fRegisterForNextAnimationEvent: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetVariableIntegerChangeHandler: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationVariable2,
                handler: ?*IUIAnimationVariableIntegerChangeHandler2,
                fRegisterForNextAnimationEvent: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationVariable2,
                handler: ?*IUIAnimationVariableIntegerChangeHandler2,
                fRegisterForNextAnimationEvent: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetVariableCurveChangeHandler: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationVariable2,
                handler: ?*IUIAnimationVariableCurveChangeHandler2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationVariable2,
                handler: ?*IUIAnimationVariableCurveChangeHandler2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationVariable2_GetDimension(self: *const T, dimension: ?*u32) HRESULT {
                return @as(*const IUIAnimationVariable2.VTable, @ptrCast(self.vtable)).GetDimension(@as(*const IUIAnimationVariable2, @ptrCast(self)), dimension);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationVariable2_GetValue(self: *const T, value: ?*f64) HRESULT {
                return @as(*const IUIAnimationVariable2.VTable, @ptrCast(self.vtable)).GetValue(@as(*const IUIAnimationVariable2, @ptrCast(self)), value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationVariable2_GetVectorValue(self: *const T, value: [*]f64, cDimension: u32) HRESULT {
                return @as(*const IUIAnimationVariable2.VTable, @ptrCast(self.vtable)).GetVectorValue(@as(*const IUIAnimationVariable2, @ptrCast(self)), value, cDimension);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationVariable2_GetCurve(self: *const T, animation: ?*IDCompositionAnimation) HRESULT {
                return @as(*const IUIAnimationVariable2.VTable, @ptrCast(self.vtable)).GetCurve(@as(*const IUIAnimationVariable2, @ptrCast(self)), animation);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationVariable2_GetVectorCurve(self: *const T, animation: [*]?*IDCompositionAnimation, cDimension: u32) HRESULT {
                return @as(*const IUIAnimationVariable2.VTable, @ptrCast(self.vtable)).GetVectorCurve(@as(*const IUIAnimationVariable2, @ptrCast(self)), animation, cDimension);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationVariable2_GetFinalValue(self: *const T, finalValue: ?*f64) HRESULT {
                return @as(*const IUIAnimationVariable2.VTable, @ptrCast(self.vtable)).GetFinalValue(@as(*const IUIAnimationVariable2, @ptrCast(self)), finalValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationVariable2_GetFinalVectorValue(self: *const T, finalValue: [*]f64, cDimension: u32) HRESULT {
                return @as(*const IUIAnimationVariable2.VTable, @ptrCast(self.vtable)).GetFinalVectorValue(@as(*const IUIAnimationVariable2, @ptrCast(self)), finalValue, cDimension);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationVariable2_GetPreviousValue(self: *const T, previousValue: ?*f64) HRESULT {
                return @as(*const IUIAnimationVariable2.VTable, @ptrCast(self.vtable)).GetPreviousValue(@as(*const IUIAnimationVariable2, @ptrCast(self)), previousValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationVariable2_GetPreviousVectorValue(self: *const T, previousValue: [*]f64, cDimension: u32) HRESULT {
                return @as(*const IUIAnimationVariable2.VTable, @ptrCast(self.vtable)).GetPreviousVectorValue(@as(*const IUIAnimationVariable2, @ptrCast(self)), previousValue, cDimension);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationVariable2_GetIntegerValue(self: *const T, value: ?*i32) HRESULT {
                return @as(*const IUIAnimationVariable2.VTable, @ptrCast(self.vtable)).GetIntegerValue(@as(*const IUIAnimationVariable2, @ptrCast(self)), value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationVariable2_GetIntegerVectorValue(self: *const T, value: [*]i32, cDimension: u32) HRESULT {
                return @as(*const IUIAnimationVariable2.VTable, @ptrCast(self.vtable)).GetIntegerVectorValue(@as(*const IUIAnimationVariable2, @ptrCast(self)), value, cDimension);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationVariable2_GetFinalIntegerValue(self: *const T, finalValue: ?*i32) HRESULT {
                return @as(*const IUIAnimationVariable2.VTable, @ptrCast(self.vtable)).GetFinalIntegerValue(@as(*const IUIAnimationVariable2, @ptrCast(self)), finalValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationVariable2_GetFinalIntegerVectorValue(self: *const T, finalValue: [*]i32, cDimension: u32) HRESULT {
                return @as(*const IUIAnimationVariable2.VTable, @ptrCast(self.vtable)).GetFinalIntegerVectorValue(@as(*const IUIAnimationVariable2, @ptrCast(self)), finalValue, cDimension);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationVariable2_GetPreviousIntegerValue(self: *const T, previousValue: ?*i32) HRESULT {
                return @as(*const IUIAnimationVariable2.VTable, @ptrCast(self.vtable)).GetPreviousIntegerValue(@as(*const IUIAnimationVariable2, @ptrCast(self)), previousValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationVariable2_GetPreviousIntegerVectorValue(self: *const T, previousValue: [*]i32, cDimension: u32) HRESULT {
                return @as(*const IUIAnimationVariable2.VTable, @ptrCast(self.vtable)).GetPreviousIntegerVectorValue(@as(*const IUIAnimationVariable2, @ptrCast(self)), previousValue, cDimension);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationVariable2_GetCurrentStoryboard(self: *const T, storyboard: ?*?*IUIAnimationStoryboard2) HRESULT {
                return @as(*const IUIAnimationVariable2.VTable, @ptrCast(self.vtable)).GetCurrentStoryboard(@as(*const IUIAnimationVariable2, @ptrCast(self)), storyboard);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationVariable2_SetLowerBound(self: *const T, bound: f64) HRESULT {
                return @as(*const IUIAnimationVariable2.VTable, @ptrCast(self.vtable)).SetLowerBound(@as(*const IUIAnimationVariable2, @ptrCast(self)), bound);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationVariable2_SetLowerBoundVector(self: *const T, bound: [*]const f64, cDimension: u32) HRESULT {
                return @as(*const IUIAnimationVariable2.VTable, @ptrCast(self.vtable)).SetLowerBoundVector(@as(*const IUIAnimationVariable2, @ptrCast(self)), bound, cDimension);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationVariable2_SetUpperBound(self: *const T, bound: f64) HRESULT {
                return @as(*const IUIAnimationVariable2.VTable, @ptrCast(self.vtable)).SetUpperBound(@as(*const IUIAnimationVariable2, @ptrCast(self)), bound);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationVariable2_SetUpperBoundVector(self: *const T, bound: [*]const f64, cDimension: u32) HRESULT {
                return @as(*const IUIAnimationVariable2.VTable, @ptrCast(self.vtable)).SetUpperBoundVector(@as(*const IUIAnimationVariable2, @ptrCast(self)), bound, cDimension);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationVariable2_SetRoundingMode(self: *const T, mode: UI_ANIMATION_ROUNDING_MODE) HRESULT {
                return @as(*const IUIAnimationVariable2.VTable, @ptrCast(self.vtable)).SetRoundingMode(@as(*const IUIAnimationVariable2, @ptrCast(self)), mode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationVariable2_SetTag(self: *const T, object: ?*IUnknown, id: u32) HRESULT {
                return @as(*const IUIAnimationVariable2.VTable, @ptrCast(self.vtable)).SetTag(@as(*const IUIAnimationVariable2, @ptrCast(self)), object, id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationVariable2_GetTag(self: *const T, object: ?*?*IUnknown, id: ?*u32) HRESULT {
                return @as(*const IUIAnimationVariable2.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IUIAnimationVariable2, @ptrCast(self)), object, id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationVariable2_SetVariableChangeHandler(self: *const T, handler: ?*IUIAnimationVariableChangeHandler2, fRegisterForNextAnimationEvent: BOOL) HRESULT {
                return @as(*const IUIAnimationVariable2.VTable, @ptrCast(self.vtable)).SetVariableChangeHandler(@as(*const IUIAnimationVariable2, @ptrCast(self)), handler, fRegisterForNextAnimationEvent);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationVariable2_SetVariableIntegerChangeHandler(self: *const T, handler: ?*IUIAnimationVariableIntegerChangeHandler2, fRegisterForNextAnimationEvent: BOOL) HRESULT {
                return @as(*const IUIAnimationVariable2.VTable, @ptrCast(self.vtable)).SetVariableIntegerChangeHandler(@as(*const IUIAnimationVariable2, @ptrCast(self)), handler, fRegisterForNextAnimationEvent);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationVariable2_SetVariableCurveChangeHandler(self: *const T, handler: ?*IUIAnimationVariableCurveChangeHandler2) HRESULT {
                return @as(*const IUIAnimationVariable2.VTable, @ptrCast(self.vtable)).SetVariableCurveChangeHandler(@as(*const IUIAnimationVariable2, @ptrCast(self)), handler);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IUIAnimationTransition2_Value = Guid.initString("62ff9123-a85a-4e9b-a218-435a93e268fd");
pub const IID_IUIAnimationTransition2 = &IID_IUIAnimationTransition2_Value;
pub const IUIAnimationTransition2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDimension: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationTransition2,
                dimension: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationTransition2,
                dimension: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetInitialValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationTransition2,
                value: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationTransition2,
                value: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetInitialVectorValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationTransition2,
                value: [*]const f64,
                cDimension: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationTransition2,
                value: [*]const f64,
                cDimension: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetInitialVelocity: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationTransition2,
                velocity: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationTransition2,
                velocity: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetInitialVectorVelocity: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationTransition2,
                velocity: [*]const f64,
                cDimension: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationTransition2,
                velocity: [*]const f64,
                cDimension: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsDurationKnown: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationTransition2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationTransition2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDuration: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationTransition2,
                duration: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationTransition2,
                duration: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationTransition2_GetDimension(self: *const T, dimension: ?*u32) HRESULT {
                return @as(*const IUIAnimationTransition2.VTable, @ptrCast(self.vtable)).GetDimension(@as(*const IUIAnimationTransition2, @ptrCast(self)), dimension);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationTransition2_SetInitialValue(self: *const T, value: f64) HRESULT {
                return @as(*const IUIAnimationTransition2.VTable, @ptrCast(self.vtable)).SetInitialValue(@as(*const IUIAnimationTransition2, @ptrCast(self)), value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationTransition2_SetInitialVectorValue(self: *const T, value: [*]const f64, cDimension: u32) HRESULT {
                return @as(*const IUIAnimationTransition2.VTable, @ptrCast(self.vtable)).SetInitialVectorValue(@as(*const IUIAnimationTransition2, @ptrCast(self)), value, cDimension);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationTransition2_SetInitialVelocity(self: *const T, velocity: f64) HRESULT {
                return @as(*const IUIAnimationTransition2.VTable, @ptrCast(self.vtable)).SetInitialVelocity(@as(*const IUIAnimationTransition2, @ptrCast(self)), velocity);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationTransition2_SetInitialVectorVelocity(self: *const T, velocity: [*]const f64, cDimension: u32) HRESULT {
                return @as(*const IUIAnimationTransition2.VTable, @ptrCast(self.vtable)).SetInitialVectorVelocity(@as(*const IUIAnimationTransition2, @ptrCast(self)), velocity, cDimension);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationTransition2_IsDurationKnown(self: *const T) HRESULT {
                return @as(*const IUIAnimationTransition2.VTable, @ptrCast(self.vtable)).IsDurationKnown(@as(*const IUIAnimationTransition2, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationTransition2_GetDuration(self: *const T, duration: ?*f64) HRESULT {
                return @as(*const IUIAnimationTransition2.VTable, @ptrCast(self.vtable)).GetDuration(@as(*const IUIAnimationTransition2, @ptrCast(self)), duration);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IUIAnimationManagerEventHandler2_Value = Guid.initString("f6e022ba-bff3-42ec-9033-e073f33e83c3");
pub const IID_IUIAnimationManagerEventHandler2 = &IID_IUIAnimationManagerEventHandler2_Value;
pub const IUIAnimationManagerEventHandler2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnManagerStatusChanged: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationManagerEventHandler2,
                newStatus: UI_ANIMATION_MANAGER_STATUS,
                previousStatus: UI_ANIMATION_MANAGER_STATUS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationManagerEventHandler2,
                newStatus: UI_ANIMATION_MANAGER_STATUS,
                previousStatus: UI_ANIMATION_MANAGER_STATUS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationManagerEventHandler2_OnManagerStatusChanged(self: *const T, newStatus: UI_ANIMATION_MANAGER_STATUS, previousStatus: UI_ANIMATION_MANAGER_STATUS) HRESULT {
                return @as(*const IUIAnimationManagerEventHandler2.VTable, @ptrCast(self.vtable)).OnManagerStatusChanged(@as(*const IUIAnimationManagerEventHandler2, @ptrCast(self)), newStatus, previousStatus);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IUIAnimationVariableChangeHandler2_Value = Guid.initString("63acc8d2-6eae-4bb0-b879-586dd8cfbe42");
pub const IID_IUIAnimationVariableChangeHandler2 = &IID_IUIAnimationVariableChangeHandler2_Value;
pub const IUIAnimationVariableChangeHandler2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnValueChanged: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationVariableChangeHandler2,
                storyboard: ?*IUIAnimationStoryboard2,
                variable: ?*IUIAnimationVariable2,
                newValue: [*]f64,
                previousValue: [*]f64,
                cDimension: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationVariableChangeHandler2,
                storyboard: ?*IUIAnimationStoryboard2,
                variable: ?*IUIAnimationVariable2,
                newValue: [*]f64,
                previousValue: [*]f64,
                cDimension: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationVariableChangeHandler2_OnValueChanged(self: *const T, storyboard: ?*IUIAnimationStoryboard2, variable: ?*IUIAnimationVariable2, newValue: [*]f64, previousValue: [*]f64, cDimension: u32) HRESULT {
                return @as(*const IUIAnimationVariableChangeHandler2.VTable, @ptrCast(self.vtable)).OnValueChanged(@as(*const IUIAnimationVariableChangeHandler2, @ptrCast(self)), storyboard, variable, newValue, previousValue, cDimension);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IUIAnimationVariableIntegerChangeHandler2_Value = Guid.initString("829b6cf1-4f3a-4412-ae09-b243eb4c6b58");
pub const IID_IUIAnimationVariableIntegerChangeHandler2 = &IID_IUIAnimationVariableIntegerChangeHandler2_Value;
pub const IUIAnimationVariableIntegerChangeHandler2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnIntegerValueChanged: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationVariableIntegerChangeHandler2,
                storyboard: ?*IUIAnimationStoryboard2,
                variable: ?*IUIAnimationVariable2,
                newValue: [*]i32,
                previousValue: [*]i32,
                cDimension: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationVariableIntegerChangeHandler2,
                storyboard: ?*IUIAnimationStoryboard2,
                variable: ?*IUIAnimationVariable2,
                newValue: [*]i32,
                previousValue: [*]i32,
                cDimension: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationVariableIntegerChangeHandler2_OnIntegerValueChanged(self: *const T, storyboard: ?*IUIAnimationStoryboard2, variable: ?*IUIAnimationVariable2, newValue: [*]i32, previousValue: [*]i32, cDimension: u32) HRESULT {
                return @as(*const IUIAnimationVariableIntegerChangeHandler2.VTable, @ptrCast(self.vtable)).OnIntegerValueChanged(@as(*const IUIAnimationVariableIntegerChangeHandler2, @ptrCast(self)), storyboard, variable, newValue, previousValue, cDimension);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IUIAnimationVariableCurveChangeHandler2_Value = Guid.initString("72895e91-0145-4c21-9192-5aab40eddf80");
pub const IID_IUIAnimationVariableCurveChangeHandler2 = &IID_IUIAnimationVariableCurveChangeHandler2_Value;
pub const IUIAnimationVariableCurveChangeHandler2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnCurveChanged: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationVariableCurveChangeHandler2,
                variable: ?*IUIAnimationVariable2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationVariableCurveChangeHandler2,
                variable: ?*IUIAnimationVariable2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationVariableCurveChangeHandler2_OnCurveChanged(self: *const T, variable: ?*IUIAnimationVariable2) HRESULT {
                return @as(*const IUIAnimationVariableCurveChangeHandler2.VTable, @ptrCast(self.vtable)).OnCurveChanged(@as(*const IUIAnimationVariableCurveChangeHandler2, @ptrCast(self)), variable);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IUIAnimationStoryboardEventHandler2_Value = Guid.initString("bac5f55a-ba7c-414c-b599-fbf850f553c6");
pub const IID_IUIAnimationStoryboardEventHandler2 = &IID_IUIAnimationStoryboardEventHandler2_Value;
pub const IUIAnimationStoryboardEventHandler2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnStoryboardStatusChanged: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationStoryboardEventHandler2,
                storyboard: ?*IUIAnimationStoryboard2,
                newStatus: UI_ANIMATION_STORYBOARD_STATUS,
                previousStatus: UI_ANIMATION_STORYBOARD_STATUS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationStoryboardEventHandler2,
                storyboard: ?*IUIAnimationStoryboard2,
                newStatus: UI_ANIMATION_STORYBOARD_STATUS,
                previousStatus: UI_ANIMATION_STORYBOARD_STATUS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnStoryboardUpdated: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationStoryboardEventHandler2,
                storyboard: ?*IUIAnimationStoryboard2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationStoryboardEventHandler2,
                storyboard: ?*IUIAnimationStoryboard2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationStoryboardEventHandler2_OnStoryboardStatusChanged(self: *const T, storyboard: ?*IUIAnimationStoryboard2, newStatus: UI_ANIMATION_STORYBOARD_STATUS, previousStatus: UI_ANIMATION_STORYBOARD_STATUS) HRESULT {
                return @as(*const IUIAnimationStoryboardEventHandler2.VTable, @ptrCast(self.vtable)).OnStoryboardStatusChanged(@as(*const IUIAnimationStoryboardEventHandler2, @ptrCast(self)), storyboard, newStatus, previousStatus);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationStoryboardEventHandler2_OnStoryboardUpdated(self: *const T, storyboard: ?*IUIAnimationStoryboard2) HRESULT {
                return @as(*const IUIAnimationStoryboardEventHandler2.VTable, @ptrCast(self.vtable)).OnStoryboardUpdated(@as(*const IUIAnimationStoryboardEventHandler2, @ptrCast(self)), storyboard);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IUIAnimationLoopIterationChangeHandler2_Value = Guid.initString("2d3b15a4-4762-47ab-a030-b23221df3ae0");
pub const IID_IUIAnimationLoopIterationChangeHandler2 = &IID_IUIAnimationLoopIterationChangeHandler2_Value;
pub const IUIAnimationLoopIterationChangeHandler2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnLoopIterationChanged: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationLoopIterationChangeHandler2,
                storyboard: ?*IUIAnimationStoryboard2,
                id: usize,
                newIterationCount: u32,
                oldIterationCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationLoopIterationChangeHandler2,
                storyboard: ?*IUIAnimationStoryboard2,
                id: usize,
                newIterationCount: u32,
                oldIterationCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationLoopIterationChangeHandler2_OnLoopIterationChanged(self: *const T, storyboard: ?*IUIAnimationStoryboard2, id: usize, newIterationCount: u32, oldIterationCount: u32) HRESULT {
                return @as(*const IUIAnimationLoopIterationChangeHandler2.VTable, @ptrCast(self.vtable)).OnLoopIterationChanged(@as(*const IUIAnimationLoopIterationChangeHandler2, @ptrCast(self)), storyboard, id, newIterationCount, oldIterationCount);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IUIAnimationPriorityComparison2_Value = Guid.initString("5b6d7a37-4621-467c-8b05-70131de62ddb");
pub const IID_IUIAnimationPriorityComparison2 = &IID_IUIAnimationPriorityComparison2_Value;
pub const IUIAnimationPriorityComparison2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        HasPriority: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationPriorityComparison2,
                scheduledStoryboard: ?*IUIAnimationStoryboard2,
                newStoryboard: ?*IUIAnimationStoryboard2,
                priorityEffect: UI_ANIMATION_PRIORITY_EFFECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationPriorityComparison2,
                scheduledStoryboard: ?*IUIAnimationStoryboard2,
                newStoryboard: ?*IUIAnimationStoryboard2,
                priorityEffect: UI_ANIMATION_PRIORITY_EFFECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationPriorityComparison2_HasPriority(self: *const T, scheduledStoryboard: ?*IUIAnimationStoryboard2, newStoryboard: ?*IUIAnimationStoryboard2, priorityEffect: UI_ANIMATION_PRIORITY_EFFECT) HRESULT {
                return @as(*const IUIAnimationPriorityComparison2.VTable, @ptrCast(self.vtable)).HasPriority(@as(*const IUIAnimationPriorityComparison2, @ptrCast(self)), scheduledStoryboard, newStoryboard, priorityEffect);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IUIAnimationTransitionLibrary2_Value = Guid.initString("03cfae53-9580-4ee3-b363-2ece51b4af6a");
pub const IID_IUIAnimationTransitionLibrary2 = &IID_IUIAnimationTransitionLibrary2_Value;
pub const IUIAnimationTransitionLibrary2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateInstantaneousTransition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationTransitionLibrary2,
                finalValue: f64,
                transition: ?*?*IUIAnimationTransition2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationTransitionLibrary2,
                finalValue: f64,
                transition: ?*?*IUIAnimationTransition2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateInstantaneousVectorTransition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationTransitionLibrary2,
                finalValue: [*]const f64,
                cDimension: u32,
                transition: ?*?*IUIAnimationTransition2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationTransitionLibrary2,
                finalValue: [*]const f64,
                cDimension: u32,
                transition: ?*?*IUIAnimationTransition2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateConstantTransition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationTransitionLibrary2,
                duration: f64,
                transition: ?*?*IUIAnimationTransition2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationTransitionLibrary2,
                duration: f64,
                transition: ?*?*IUIAnimationTransition2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateDiscreteTransition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationTransitionLibrary2,
                delay: f64,
                finalValue: f64,
                hold: f64,
                transition: ?*?*IUIAnimationTransition2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationTransitionLibrary2,
                delay: f64,
                finalValue: f64,
                hold: f64,
                transition: ?*?*IUIAnimationTransition2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateDiscreteVectorTransition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationTransitionLibrary2,
                delay: f64,
                finalValue: [*]const f64,
                cDimension: u32,
                hold: f64,
                transition: ?*?*IUIAnimationTransition2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationTransitionLibrary2,
                delay: f64,
                finalValue: [*]const f64,
                cDimension: u32,
                hold: f64,
                transition: ?*?*IUIAnimationTransition2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateLinearTransition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationTransitionLibrary2,
                duration: f64,
                finalValue: f64,
                transition: ?*?*IUIAnimationTransition2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationTransitionLibrary2,
                duration: f64,
                finalValue: f64,
                transition: ?*?*IUIAnimationTransition2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateLinearVectorTransition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationTransitionLibrary2,
                duration: f64,
                finalValue: [*]const f64,
                cDimension: u32,
                transition: ?*?*IUIAnimationTransition2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationTransitionLibrary2,
                duration: f64,
                finalValue: [*]const f64,
                cDimension: u32,
                transition: ?*?*IUIAnimationTransition2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateLinearTransitionFromSpeed: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationTransitionLibrary2,
                speed: f64,
                finalValue: f64,
                transition: ?*?*IUIAnimationTransition2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationTransitionLibrary2,
                speed: f64,
                finalValue: f64,
                transition: ?*?*IUIAnimationTransition2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateLinearVectorTransitionFromSpeed: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationTransitionLibrary2,
                speed: f64,
                finalValue: [*]const f64,
                cDimension: u32,
                transition: ?*?*IUIAnimationTransition2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationTransitionLibrary2,
                speed: f64,
                finalValue: [*]const f64,
                cDimension: u32,
                transition: ?*?*IUIAnimationTransition2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateSinusoidalTransitionFromVelocity: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationTransitionLibrary2,
                duration: f64,
                period: f64,
                transition: ?*?*IUIAnimationTransition2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationTransitionLibrary2,
                duration: f64,
                period: f64,
                transition: ?*?*IUIAnimationTransition2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateSinusoidalTransitionFromRange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationTransitionLibrary2,
                duration: f64,
                minimumValue: f64,
                maximumValue: f64,
                period: f64,
                slope: UI_ANIMATION_SLOPE,
                transition: ?*?*IUIAnimationTransition2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationTransitionLibrary2,
                duration: f64,
                minimumValue: f64,
                maximumValue: f64,
                period: f64,
                slope: UI_ANIMATION_SLOPE,
                transition: ?*?*IUIAnimationTransition2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateAccelerateDecelerateTransition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationTransitionLibrary2,
                duration: f64,
                finalValue: f64,
                accelerationRatio: f64,
                decelerationRatio: f64,
                transition: ?*?*IUIAnimationTransition2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationTransitionLibrary2,
                duration: f64,
                finalValue: f64,
                accelerationRatio: f64,
                decelerationRatio: f64,
                transition: ?*?*IUIAnimationTransition2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateReversalTransition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationTransitionLibrary2,
                duration: f64,
                transition: ?*?*IUIAnimationTransition2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationTransitionLibrary2,
                duration: f64,
                transition: ?*?*IUIAnimationTransition2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateCubicTransition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationTransitionLibrary2,
                duration: f64,
                finalValue: f64,
                finalVelocity: f64,
                transition: ?*?*IUIAnimationTransition2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationTransitionLibrary2,
                duration: f64,
                finalValue: f64,
                finalVelocity: f64,
                transition: ?*?*IUIAnimationTransition2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateCubicVectorTransition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationTransitionLibrary2,
                duration: f64,
                finalValue: [*]const f64,
                finalVelocity: [*]const f64,
                cDimension: u32,
                transition: ?*?*IUIAnimationTransition2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationTransitionLibrary2,
                duration: f64,
                finalValue: [*]const f64,
                finalVelocity: [*]const f64,
                cDimension: u32,
                transition: ?*?*IUIAnimationTransition2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateSmoothStopTransition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationTransitionLibrary2,
                maximumDuration: f64,
                finalValue: f64,
                transition: ?*?*IUIAnimationTransition2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationTransitionLibrary2,
                maximumDuration: f64,
                finalValue: f64,
                transition: ?*?*IUIAnimationTransition2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateParabolicTransitionFromAcceleration: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationTransitionLibrary2,
                finalValue: f64,
                finalVelocity: f64,
                acceleration: f64,
                transition: ?*?*IUIAnimationTransition2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationTransitionLibrary2,
                finalValue: f64,
                finalVelocity: f64,
                acceleration: f64,
                transition: ?*?*IUIAnimationTransition2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateCubicBezierLinearTransition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationTransitionLibrary2,
                duration: f64,
                finalValue: f64,
                x1: f64,
                y1: f64,
                x2: f64,
                y2: f64,
                ppTransition: ?*?*IUIAnimationTransition2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationTransitionLibrary2,
                duration: f64,
                finalValue: f64,
                x1: f64,
                y1: f64,
                x2: f64,
                y2: f64,
                ppTransition: ?*?*IUIAnimationTransition2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateCubicBezierLinearVectorTransition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationTransitionLibrary2,
                duration: f64,
                finalValue: [*]const f64,
                cDimension: u32,
                x1: f64,
                y1: f64,
                x2: f64,
                y2: f64,
                ppTransition: ?*?*IUIAnimationTransition2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationTransitionLibrary2,
                duration: f64,
                finalValue: [*]const f64,
                cDimension: u32,
                x1: f64,
                y1: f64,
                x2: f64,
                y2: f64,
                ppTransition: ?*?*IUIAnimationTransition2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationTransitionLibrary2_CreateInstantaneousTransition(self: *const T, finalValue: f64, transition: ?*?*IUIAnimationTransition2) HRESULT {
                return @as(*const IUIAnimationTransitionLibrary2.VTable, @ptrCast(self.vtable)).CreateInstantaneousTransition(@as(*const IUIAnimationTransitionLibrary2, @ptrCast(self)), finalValue, transition);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationTransitionLibrary2_CreateInstantaneousVectorTransition(self: *const T, finalValue: [*]const f64, cDimension: u32, transition: ?*?*IUIAnimationTransition2) HRESULT {
                return @as(*const IUIAnimationTransitionLibrary2.VTable, @ptrCast(self.vtable)).CreateInstantaneousVectorTransition(@as(*const IUIAnimationTransitionLibrary2, @ptrCast(self)), finalValue, cDimension, transition);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationTransitionLibrary2_CreateConstantTransition(self: *const T, duration: f64, transition: ?*?*IUIAnimationTransition2) HRESULT {
                return @as(*const IUIAnimationTransitionLibrary2.VTable, @ptrCast(self.vtable)).CreateConstantTransition(@as(*const IUIAnimationTransitionLibrary2, @ptrCast(self)), duration, transition);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationTransitionLibrary2_CreateDiscreteTransition(self: *const T, delay: f64, finalValue: f64, hold: f64, transition: ?*?*IUIAnimationTransition2) HRESULT {
                return @as(*const IUIAnimationTransitionLibrary2.VTable, @ptrCast(self.vtable)).CreateDiscreteTransition(@as(*const IUIAnimationTransitionLibrary2, @ptrCast(self)), delay, finalValue, hold, transition);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationTransitionLibrary2_CreateDiscreteVectorTransition(self: *const T, delay: f64, finalValue: [*]const f64, cDimension: u32, hold: f64, transition: ?*?*IUIAnimationTransition2) HRESULT {
                return @as(*const IUIAnimationTransitionLibrary2.VTable, @ptrCast(self.vtable)).CreateDiscreteVectorTransition(@as(*const IUIAnimationTransitionLibrary2, @ptrCast(self)), delay, finalValue, cDimension, hold, transition);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationTransitionLibrary2_CreateLinearTransition(self: *const T, duration: f64, finalValue: f64, transition: ?*?*IUIAnimationTransition2) HRESULT {
                return @as(*const IUIAnimationTransitionLibrary2.VTable, @ptrCast(self.vtable)).CreateLinearTransition(@as(*const IUIAnimationTransitionLibrary2, @ptrCast(self)), duration, finalValue, transition);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationTransitionLibrary2_CreateLinearVectorTransition(self: *const T, duration: f64, finalValue: [*]const f64, cDimension: u32, transition: ?*?*IUIAnimationTransition2) HRESULT {
                return @as(*const IUIAnimationTransitionLibrary2.VTable, @ptrCast(self.vtable)).CreateLinearVectorTransition(@as(*const IUIAnimationTransitionLibrary2, @ptrCast(self)), duration, finalValue, cDimension, transition);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationTransitionLibrary2_CreateLinearTransitionFromSpeed(self: *const T, speed: f64, finalValue: f64, transition: ?*?*IUIAnimationTransition2) HRESULT {
                return @as(*const IUIAnimationTransitionLibrary2.VTable, @ptrCast(self.vtable)).CreateLinearTransitionFromSpeed(@as(*const IUIAnimationTransitionLibrary2, @ptrCast(self)), speed, finalValue, transition);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationTransitionLibrary2_CreateLinearVectorTransitionFromSpeed(self: *const T, speed: f64, finalValue: [*]const f64, cDimension: u32, transition: ?*?*IUIAnimationTransition2) HRESULT {
                return @as(*const IUIAnimationTransitionLibrary2.VTable, @ptrCast(self.vtable)).CreateLinearVectorTransitionFromSpeed(@as(*const IUIAnimationTransitionLibrary2, @ptrCast(self)), speed, finalValue, cDimension, transition);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationTransitionLibrary2_CreateSinusoidalTransitionFromVelocity(self: *const T, duration: f64, period: f64, transition: ?*?*IUIAnimationTransition2) HRESULT {
                return @as(*const IUIAnimationTransitionLibrary2.VTable, @ptrCast(self.vtable)).CreateSinusoidalTransitionFromVelocity(@as(*const IUIAnimationTransitionLibrary2, @ptrCast(self)), duration, period, transition);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationTransitionLibrary2_CreateSinusoidalTransitionFromRange(self: *const T, duration: f64, minimumValue: f64, maximumValue: f64, period: f64, slope: UI_ANIMATION_SLOPE, transition: ?*?*IUIAnimationTransition2) HRESULT {
                return @as(*const IUIAnimationTransitionLibrary2.VTable, @ptrCast(self.vtable)).CreateSinusoidalTransitionFromRange(@as(*const IUIAnimationTransitionLibrary2, @ptrCast(self)), duration, minimumValue, maximumValue, period, slope, transition);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationTransitionLibrary2_CreateAccelerateDecelerateTransition(self: *const T, duration: f64, finalValue: f64, accelerationRatio: f64, decelerationRatio: f64, transition: ?*?*IUIAnimationTransition2) HRESULT {
                return @as(*const IUIAnimationTransitionLibrary2.VTable, @ptrCast(self.vtable)).CreateAccelerateDecelerateTransition(@as(*const IUIAnimationTransitionLibrary2, @ptrCast(self)), duration, finalValue, accelerationRatio, decelerationRatio, transition);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationTransitionLibrary2_CreateReversalTransition(self: *const T, duration: f64, transition: ?*?*IUIAnimationTransition2) HRESULT {
                return @as(*const IUIAnimationTransitionLibrary2.VTable, @ptrCast(self.vtable)).CreateReversalTransition(@as(*const IUIAnimationTransitionLibrary2, @ptrCast(self)), duration, transition);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationTransitionLibrary2_CreateCubicTransition(self: *const T, duration: f64, finalValue: f64, finalVelocity: f64, transition: ?*?*IUIAnimationTransition2) HRESULT {
                return @as(*const IUIAnimationTransitionLibrary2.VTable, @ptrCast(self.vtable)).CreateCubicTransition(@as(*const IUIAnimationTransitionLibrary2, @ptrCast(self)), duration, finalValue, finalVelocity, transition);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationTransitionLibrary2_CreateCubicVectorTransition(self: *const T, duration: f64, finalValue: [*]const f64, finalVelocity: [*]const f64, cDimension: u32, transition: ?*?*IUIAnimationTransition2) HRESULT {
                return @as(*const IUIAnimationTransitionLibrary2.VTable, @ptrCast(self.vtable)).CreateCubicVectorTransition(@as(*const IUIAnimationTransitionLibrary2, @ptrCast(self)), duration, finalValue, finalVelocity, cDimension, transition);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationTransitionLibrary2_CreateSmoothStopTransition(self: *const T, maximumDuration: f64, finalValue: f64, transition: ?*?*IUIAnimationTransition2) HRESULT {
                return @as(*const IUIAnimationTransitionLibrary2.VTable, @ptrCast(self.vtable)).CreateSmoothStopTransition(@as(*const IUIAnimationTransitionLibrary2, @ptrCast(self)), maximumDuration, finalValue, transition);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationTransitionLibrary2_CreateParabolicTransitionFromAcceleration(self: *const T, finalValue: f64, finalVelocity: f64, acceleration: f64, transition: ?*?*IUIAnimationTransition2) HRESULT {
                return @as(*const IUIAnimationTransitionLibrary2.VTable, @ptrCast(self.vtable)).CreateParabolicTransitionFromAcceleration(@as(*const IUIAnimationTransitionLibrary2, @ptrCast(self)), finalValue, finalVelocity, acceleration, transition);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationTransitionLibrary2_CreateCubicBezierLinearTransition(self: *const T, duration: f64, finalValue: f64, x1: f64, y1: f64, x2: f64, y2: f64, ppTransition: ?*?*IUIAnimationTransition2) HRESULT {
                return @as(*const IUIAnimationTransitionLibrary2.VTable, @ptrCast(self.vtable)).CreateCubicBezierLinearTransition(@as(*const IUIAnimationTransitionLibrary2, @ptrCast(self)), duration, finalValue, x1, y1, x2, y2, ppTransition);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationTransitionLibrary2_CreateCubicBezierLinearVectorTransition(self: *const T, duration: f64, finalValue: [*]const f64, cDimension: u32, x1: f64, y1: f64, x2: f64, y2: f64, ppTransition: ?*?*IUIAnimationTransition2) HRESULT {
                return @as(*const IUIAnimationTransitionLibrary2.VTable, @ptrCast(self.vtable)).CreateCubicBezierLinearVectorTransition(@as(*const IUIAnimationTransitionLibrary2, @ptrCast(self)), duration, finalValue, cDimension, x1, y1, x2, y2, ppTransition);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IUIAnimationPrimitiveInterpolation_Value = Guid.initString("bab20d63-4361-45da-a24f-ab8508846b5b");
pub const IID_IUIAnimationPrimitiveInterpolation = &IID_IUIAnimationPrimitiveInterpolation_Value;
pub const IUIAnimationPrimitiveInterpolation = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddCubic: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationPrimitiveInterpolation,
                dimension: u32,
                beginOffset: f64,
                constantCoefficient: f32,
                linearCoefficient: f32,
                quadraticCoefficient: f32,
                cubicCoefficient: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationPrimitiveInterpolation,
                dimension: u32,
                beginOffset: f64,
                constantCoefficient: f32,
                linearCoefficient: f32,
                quadraticCoefficient: f32,
                cubicCoefficient: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddSinusoidal: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationPrimitiveInterpolation,
                dimension: u32,
                beginOffset: f64,
                bias: f32,
                amplitude: f32,
                frequency: f32,
                phase: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationPrimitiveInterpolation,
                dimension: u32,
                beginOffset: f64,
                bias: f32,
                amplitude: f32,
                frequency: f32,
                phase: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationPrimitiveInterpolation_AddCubic(self: *const T, dimension: u32, beginOffset: f64, constantCoefficient: f32, linearCoefficient: f32, quadraticCoefficient: f32, cubicCoefficient: f32) HRESULT {
                return @as(*const IUIAnimationPrimitiveInterpolation.VTable, @ptrCast(self.vtable)).AddCubic(@as(*const IUIAnimationPrimitiveInterpolation, @ptrCast(self)), dimension, beginOffset, constantCoefficient, linearCoefficient, quadraticCoefficient, cubicCoefficient);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationPrimitiveInterpolation_AddSinusoidal(self: *const T, dimension: u32, beginOffset: f64, bias: f32, amplitude: f32, frequency: f32, phase: f32) HRESULT {
                return @as(*const IUIAnimationPrimitiveInterpolation.VTable, @ptrCast(self.vtable)).AddSinusoidal(@as(*const IUIAnimationPrimitiveInterpolation, @ptrCast(self)), dimension, beginOffset, bias, amplitude, frequency, phase);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IUIAnimationInterpolator2_Value = Guid.initString("ea76aff8-ea22-4a23-a0ef-a6a966703518");
pub const IID_IUIAnimationInterpolator2 = &IID_IUIAnimationInterpolator2_Value;
pub const IUIAnimationInterpolator2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDimension: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationInterpolator2,
                dimension: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationInterpolator2,
                dimension: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetInitialValueAndVelocity: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationInterpolator2,
                initialValue: [*]f64,
                initialVelocity: [*]f64,
                cDimension: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationInterpolator2,
                initialValue: [*]f64,
                initialVelocity: [*]f64,
                cDimension: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDuration: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationInterpolator2,
                duration: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationInterpolator2,
                duration: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDuration: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationInterpolator2,
                duration: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationInterpolator2,
                duration: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFinalValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationInterpolator2,
                value: [*]f64,
                cDimension: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationInterpolator2,
                value: [*]f64,
                cDimension: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InterpolateValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationInterpolator2,
                offset: f64,
                value: [*]f64,
                cDimension: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationInterpolator2,
                offset: f64,
                value: [*]f64,
                cDimension: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InterpolateVelocity: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationInterpolator2,
                offset: f64,
                velocity: [*]f64,
                cDimension: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationInterpolator2,
                offset: f64,
                velocity: [*]f64,
                cDimension: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPrimitiveInterpolation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationInterpolator2,
                interpolation: ?*IUIAnimationPrimitiveInterpolation,
                cDimension: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationInterpolator2,
                interpolation: ?*IUIAnimationPrimitiveInterpolation,
                cDimension: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDependencies: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationInterpolator2,
                initialValueDependencies: ?*UI_ANIMATION_DEPENDENCIES,
                initialVelocityDependencies: ?*UI_ANIMATION_DEPENDENCIES,
                durationDependencies: ?*UI_ANIMATION_DEPENDENCIES,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationInterpolator2,
                initialValueDependencies: ?*UI_ANIMATION_DEPENDENCIES,
                initialVelocityDependencies: ?*UI_ANIMATION_DEPENDENCIES,
                durationDependencies: ?*UI_ANIMATION_DEPENDENCIES,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationInterpolator2_GetDimension(self: *const T, dimension: ?*u32) HRESULT {
                return @as(*const IUIAnimationInterpolator2.VTable, @ptrCast(self.vtable)).GetDimension(@as(*const IUIAnimationInterpolator2, @ptrCast(self)), dimension);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationInterpolator2_SetInitialValueAndVelocity(self: *const T, initialValue: [*]f64, initialVelocity: [*]f64, cDimension: u32) HRESULT {
                return @as(*const IUIAnimationInterpolator2.VTable, @ptrCast(self.vtable)).SetInitialValueAndVelocity(@as(*const IUIAnimationInterpolator2, @ptrCast(self)), initialValue, initialVelocity, cDimension);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationInterpolator2_SetDuration(self: *const T, duration: f64) HRESULT {
                return @as(*const IUIAnimationInterpolator2.VTable, @ptrCast(self.vtable)).SetDuration(@as(*const IUIAnimationInterpolator2, @ptrCast(self)), duration);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationInterpolator2_GetDuration(self: *const T, duration: ?*f64) HRESULT {
                return @as(*const IUIAnimationInterpolator2.VTable, @ptrCast(self.vtable)).GetDuration(@as(*const IUIAnimationInterpolator2, @ptrCast(self)), duration);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationInterpolator2_GetFinalValue(self: *const T, value: [*]f64, cDimension: u32) HRESULT {
                return @as(*const IUIAnimationInterpolator2.VTable, @ptrCast(self.vtable)).GetFinalValue(@as(*const IUIAnimationInterpolator2, @ptrCast(self)), value, cDimension);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationInterpolator2_InterpolateValue(self: *const T, offset: f64, value: [*]f64, cDimension: u32) HRESULT {
                return @as(*const IUIAnimationInterpolator2.VTable, @ptrCast(self.vtable)).InterpolateValue(@as(*const IUIAnimationInterpolator2, @ptrCast(self)), offset, value, cDimension);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationInterpolator2_InterpolateVelocity(self: *const T, offset: f64, velocity: [*]f64, cDimension: u32) HRESULT {
                return @as(*const IUIAnimationInterpolator2.VTable, @ptrCast(self.vtable)).InterpolateVelocity(@as(*const IUIAnimationInterpolator2, @ptrCast(self)), offset, velocity, cDimension);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationInterpolator2_GetPrimitiveInterpolation(self: *const T, interpolation: ?*IUIAnimationPrimitiveInterpolation, cDimension: u32) HRESULT {
                return @as(*const IUIAnimationInterpolator2.VTable, @ptrCast(self.vtable)).GetPrimitiveInterpolation(@as(*const IUIAnimationInterpolator2, @ptrCast(self)), interpolation, cDimension);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationInterpolator2_GetDependencies(self: *const T, initialValueDependencies: ?*UI_ANIMATION_DEPENDENCIES, initialVelocityDependencies: ?*UI_ANIMATION_DEPENDENCIES, durationDependencies: ?*UI_ANIMATION_DEPENDENCIES) HRESULT {
                return @as(*const IUIAnimationInterpolator2.VTable, @ptrCast(self.vtable)).GetDependencies(@as(*const IUIAnimationInterpolator2, @ptrCast(self)), initialValueDependencies, initialVelocityDependencies, durationDependencies);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IUIAnimationTransitionFactory2_Value = Guid.initString("937d4916-c1a6-42d5-88d8-30344d6efe31");
pub const IID_IUIAnimationTransitionFactory2 = &IID_IUIAnimationTransitionFactory2_Value;
pub const IUIAnimationTransitionFactory2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateTransition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationTransitionFactory2,
                interpolator: ?*IUIAnimationInterpolator2,
                transition: ?*?*IUIAnimationTransition2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationTransitionFactory2,
                interpolator: ?*IUIAnimationInterpolator2,
                transition: ?*?*IUIAnimationTransition2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationTransitionFactory2_CreateTransition(self: *const T, interpolator: ?*IUIAnimationInterpolator2, transition: ?*?*IUIAnimationTransition2) HRESULT {
                return @as(*const IUIAnimationTransitionFactory2.VTable, @ptrCast(self.vtable)).CreateTransition(@as(*const IUIAnimationTransitionFactory2, @ptrCast(self)), interpolator, transition);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IUIAnimationStoryboard2_Value = Guid.initString("ae289cd2-12d4-4945-9419-9e41be034df2");
pub const IID_IUIAnimationStoryboard2 = &IID_IUIAnimationStoryboard2_Value;
pub const IUIAnimationStoryboard2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddTransition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationStoryboard2,
                variable: ?*IUIAnimationVariable2,
                transition: ?*IUIAnimationTransition2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationStoryboard2,
                variable: ?*IUIAnimationVariable2,
                transition: ?*IUIAnimationTransition2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddKeyframeAtOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationStoryboard2,
                existingKeyframe: UI_ANIMATION_KEYFRAME,
                offset: f64,
                keyframe: ?*UI_ANIMATION_KEYFRAME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationStoryboard2,
                existingKeyframe: UI_ANIMATION_KEYFRAME,
                offset: f64,
                keyframe: ?*UI_ANIMATION_KEYFRAME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddKeyframeAfterTransition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationStoryboard2,
                transition: ?*IUIAnimationTransition2,
                keyframe: ?*UI_ANIMATION_KEYFRAME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationStoryboard2,
                transition: ?*IUIAnimationTransition2,
                keyframe: ?*UI_ANIMATION_KEYFRAME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddTransitionAtKeyframe: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationStoryboard2,
                variable: ?*IUIAnimationVariable2,
                transition: ?*IUIAnimationTransition2,
                startKeyframe: UI_ANIMATION_KEYFRAME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationStoryboard2,
                variable: ?*IUIAnimationVariable2,
                transition: ?*IUIAnimationTransition2,
                startKeyframe: UI_ANIMATION_KEYFRAME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddTransitionBetweenKeyframes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationStoryboard2,
                variable: ?*IUIAnimationVariable2,
                transition: ?*IUIAnimationTransition2,
                startKeyframe: UI_ANIMATION_KEYFRAME,
                endKeyframe: UI_ANIMATION_KEYFRAME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationStoryboard2,
                variable: ?*IUIAnimationVariable2,
                transition: ?*IUIAnimationTransition2,
                startKeyframe: UI_ANIMATION_KEYFRAME,
                endKeyframe: UI_ANIMATION_KEYFRAME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RepeatBetweenKeyframes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationStoryboard2,
                startKeyframe: UI_ANIMATION_KEYFRAME,
                endKeyframe: UI_ANIMATION_KEYFRAME,
                cRepetition: f64,
                repeatMode: UI_ANIMATION_REPEAT_MODE,
                pIterationChangeHandler: ?*IUIAnimationLoopIterationChangeHandler2,
                id: usize,
                fRegisterForNextAnimationEvent: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationStoryboard2,
                startKeyframe: UI_ANIMATION_KEYFRAME,
                endKeyframe: UI_ANIMATION_KEYFRAME,
                cRepetition: f64,
                repeatMode: UI_ANIMATION_REPEAT_MODE,
                pIterationChangeHandler: ?*IUIAnimationLoopIterationChangeHandler2,
                id: usize,
                fRegisterForNextAnimationEvent: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        HoldVariable: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationStoryboard2,
                variable: ?*IUIAnimationVariable2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationStoryboard2,
                variable: ?*IUIAnimationVariable2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetLongestAcceptableDelay: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationStoryboard2,
                delay: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationStoryboard2,
                delay: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSkipDuration: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationStoryboard2,
                secondsDuration: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationStoryboard2,
                secondsDuration: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Schedule: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationStoryboard2,
                timeNow: f64,
                schedulingResult: ?*UI_ANIMATION_SCHEDULING_RESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationStoryboard2,
                timeNow: f64,
                schedulingResult: ?*UI_ANIMATION_SCHEDULING_RESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Conclude: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationStoryboard2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationStoryboard2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Finish: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationStoryboard2,
                completionDeadline: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationStoryboard2,
                completionDeadline: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Abandon: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationStoryboard2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationStoryboard2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTag: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationStoryboard2,
                object: ?*IUnknown,
                id: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationStoryboard2,
                object: ?*IUnknown,
                id: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTag: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationStoryboard2,
                object: ?*?*IUnknown,
                id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationStoryboard2,
                object: ?*?*IUnknown,
                id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationStoryboard2,
                status: ?*UI_ANIMATION_STORYBOARD_STATUS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationStoryboard2,
                status: ?*UI_ANIMATION_STORYBOARD_STATUS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetElapsedTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationStoryboard2,
                elapsedTime: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationStoryboard2,
                elapsedTime: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetStoryboardEventHandler: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIAnimationStoryboard2,
                handler: ?*IUIAnimationStoryboardEventHandler2,
                fRegisterStatusChangeForNextAnimationEvent: BOOL,
                fRegisterUpdateForNextAnimationEvent: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIAnimationStoryboard2,
                handler: ?*IUIAnimationStoryboardEventHandler2,
                fRegisterStatusChangeForNextAnimationEvent: BOOL,
                fRegisterUpdateForNextAnimationEvent: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationStoryboard2_AddTransition(self: *const T, variable: ?*IUIAnimationVariable2, transition: ?*IUIAnimationTransition2) HRESULT {
                return @as(*const IUIAnimationStoryboard2.VTable, @ptrCast(self.vtable)).AddTransition(@as(*const IUIAnimationStoryboard2, @ptrCast(self)), variable, transition);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationStoryboard2_AddKeyframeAtOffset(self: *const T, existingKeyframe: UI_ANIMATION_KEYFRAME, offset: f64, keyframe: ?*UI_ANIMATION_KEYFRAME) HRESULT {
                return @as(*const IUIAnimationStoryboard2.VTable, @ptrCast(self.vtable)).AddKeyframeAtOffset(@as(*const IUIAnimationStoryboard2, @ptrCast(self)), existingKeyframe, offset, keyframe);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationStoryboard2_AddKeyframeAfterTransition(self: *const T, transition: ?*IUIAnimationTransition2, keyframe: ?*UI_ANIMATION_KEYFRAME) HRESULT {
                return @as(*const IUIAnimationStoryboard2.VTable, @ptrCast(self.vtable)).AddKeyframeAfterTransition(@as(*const IUIAnimationStoryboard2, @ptrCast(self)), transition, keyframe);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationStoryboard2_AddTransitionAtKeyframe(self: *const T, variable: ?*IUIAnimationVariable2, transition: ?*IUIAnimationTransition2, startKeyframe: UI_ANIMATION_KEYFRAME) HRESULT {
                return @as(*const IUIAnimationStoryboard2.VTable, @ptrCast(self.vtable)).AddTransitionAtKeyframe(@as(*const IUIAnimationStoryboard2, @ptrCast(self)), variable, transition, startKeyframe);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationStoryboard2_AddTransitionBetweenKeyframes(self: *const T, variable: ?*IUIAnimationVariable2, transition: ?*IUIAnimationTransition2, startKeyframe: UI_ANIMATION_KEYFRAME, endKeyframe: UI_ANIMATION_KEYFRAME) HRESULT {
                return @as(*const IUIAnimationStoryboard2.VTable, @ptrCast(self.vtable)).AddTransitionBetweenKeyframes(@as(*const IUIAnimationStoryboard2, @ptrCast(self)), variable, transition, startKeyframe, endKeyframe);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationStoryboard2_RepeatBetweenKeyframes(self: *const T, startKeyframe: UI_ANIMATION_KEYFRAME, endKeyframe: UI_ANIMATION_KEYFRAME, cRepetition: f64, repeatMode: UI_ANIMATION_REPEAT_MODE, pIterationChangeHandler: ?*IUIAnimationLoopIterationChangeHandler2, id: usize, fRegisterForNextAnimationEvent: BOOL) HRESULT {
                return @as(*const IUIAnimationStoryboard2.VTable, @ptrCast(self.vtable)).RepeatBetweenKeyframes(@as(*const IUIAnimationStoryboard2, @ptrCast(self)), startKeyframe, endKeyframe, cRepetition, repeatMode, pIterationChangeHandler, id, fRegisterForNextAnimationEvent);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationStoryboard2_HoldVariable(self: *const T, variable: ?*IUIAnimationVariable2) HRESULT {
                return @as(*const IUIAnimationStoryboard2.VTable, @ptrCast(self.vtable)).HoldVariable(@as(*const IUIAnimationStoryboard2, @ptrCast(self)), variable);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationStoryboard2_SetLongestAcceptableDelay(self: *const T, delay: f64) HRESULT {
                return @as(*const IUIAnimationStoryboard2.VTable, @ptrCast(self.vtable)).SetLongestAcceptableDelay(@as(*const IUIAnimationStoryboard2, @ptrCast(self)), delay);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationStoryboard2_SetSkipDuration(self: *const T, secondsDuration: f64) HRESULT {
                return @as(*const IUIAnimationStoryboard2.VTable, @ptrCast(self.vtable)).SetSkipDuration(@as(*const IUIAnimationStoryboard2, @ptrCast(self)), secondsDuration);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationStoryboard2_Schedule(self: *const T, timeNow: f64, schedulingResult: ?*UI_ANIMATION_SCHEDULING_RESULT) HRESULT {
                return @as(*const IUIAnimationStoryboard2.VTable, @ptrCast(self.vtable)).Schedule(@as(*const IUIAnimationStoryboard2, @ptrCast(self)), timeNow, schedulingResult);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationStoryboard2_Conclude(self: *const T) HRESULT {
                return @as(*const IUIAnimationStoryboard2.VTable, @ptrCast(self.vtable)).Conclude(@as(*const IUIAnimationStoryboard2, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationStoryboard2_Finish(self: *const T, completionDeadline: f64) HRESULT {
                return @as(*const IUIAnimationStoryboard2.VTable, @ptrCast(self.vtable)).Finish(@as(*const IUIAnimationStoryboard2, @ptrCast(self)), completionDeadline);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationStoryboard2_Abandon(self: *const T) HRESULT {
                return @as(*const IUIAnimationStoryboard2.VTable, @ptrCast(self.vtable)).Abandon(@as(*const IUIAnimationStoryboard2, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationStoryboard2_SetTag(self: *const T, object: ?*IUnknown, id: u32) HRESULT {
                return @as(*const IUIAnimationStoryboard2.VTable, @ptrCast(self.vtable)).SetTag(@as(*const IUIAnimationStoryboard2, @ptrCast(self)), object, id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationStoryboard2_GetTag(self: *const T, object: ?*?*IUnknown, id: ?*u32) HRESULT {
                return @as(*const IUIAnimationStoryboard2.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IUIAnimationStoryboard2, @ptrCast(self)), object, id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationStoryboard2_GetStatus(self: *const T, status: ?*UI_ANIMATION_STORYBOARD_STATUS) HRESULT {
                return @as(*const IUIAnimationStoryboard2.VTable, @ptrCast(self.vtable)).GetStatus(@as(*const IUIAnimationStoryboard2, @ptrCast(self)), status);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationStoryboard2_GetElapsedTime(self: *const T, elapsedTime: ?*f64) HRESULT {
                return @as(*const IUIAnimationStoryboard2.VTable, @ptrCast(self.vtable)).GetElapsedTime(@as(*const IUIAnimationStoryboard2, @ptrCast(self)), elapsedTime);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIAnimationStoryboard2_SetStoryboardEventHandler(self: *const T, handler: ?*IUIAnimationStoryboardEventHandler2, fRegisterStatusChangeForNextAnimationEvent: BOOL, fRegisterUpdateForNextAnimationEvent: BOOL) HRESULT {
                return @as(*const IUIAnimationStoryboard2.VTable, @ptrCast(self.vtable)).SetStoryboardEventHandler(@as(*const IUIAnimationStoryboard2, @ptrCast(self)), handler, fRegisterStatusChangeForNextAnimationEvent, fRegisterUpdateForNextAnimationEvent);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

//--------------------------------------------------------------------------------
// Section: Functions (0)
//--------------------------------------------------------------------------------

//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {},
    .wide => struct {},
    .unspecified => if (@import("builtin").is_test) struct {} else struct {},
};
//--------------------------------------------------------------------------------
// Section: Imports (5)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const BOOL = @import("../foundation.zig").BOOL;
const HRESULT = @import("../foundation.zig").HRESULT;
const IDCompositionAnimation = @import("../graphics/direct_composition.zig").IDCompositionAnimation;
const IUnknown = @import("../system/com.zig").IUnknown;

test {
    @setEvalBranchQuota(comptime @import("std").meta.declarations(@This()).len * 3);

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        if (decl.is_pub) {
            _ = @field(@This(), decl.name);
        }
    }
}
