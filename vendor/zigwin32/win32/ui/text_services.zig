//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (434)
//--------------------------------------------------------------------------------
pub const GUID_PROP_TEXTOWNER = Guid.initString("f1e2d520-0969-11d3-8df0-00105a2799b5");
pub const GUID_PROP_ATTRIBUTE = Guid.initString("34b45670-7526-11d2-a147-00105a2799b5");
pub const GUID_PROP_LANGID = Guid.initString("3280ce20-8032-11d2-b603-00105a2799b5");
pub const GUID_PROP_READING = Guid.initString("5463f7c0-8e31-11d2-bf46-00105a2799b5");
pub const GUID_PROP_COMPOSING = Guid.initString("e12ac060-af15-11d2-afc5-00105a2799b5");
pub const GUID_PROP_TKB_ALTERNATES = Guid.initString("70b2a803-968d-462e-b93b-2164c91517f7");
pub const GUID_SYSTEM_FUNCTIONPROVIDER = Guid.initString("9a698bb0-0f21-11d3-8df1-00105a2799b5");
pub const GUID_APP_FUNCTIONPROVIDER = Guid.initString("4caef01e-12af-4b0e-9db1-a6ec5b881208");
pub const GUID_TFCAT_CATEGORY_OF_TIP = Guid.initString("534c48c1-0607-4098-a521-4fc899c73e90");
pub const GUID_TFCAT_TIP_KEYBOARD = Guid.initString("34745c63-b2f0-4784-8b67-5e12c8701a31");
pub const GUID_TFCAT_TIP_SPEECH = Guid.initString("b5a73cd1-8355-426b-a161-259808f26b14");
pub const GUID_TFCAT_TIP_HANDWRITING = Guid.initString("246ecb87-c2f2-4abe-905b-c8b38add2c43");
pub const GUID_TFCAT_PROP_AUDIODATA = Guid.initString("9b7be3a9-e8ab-4d47-a8fe-254fa423436d");
pub const GUID_TFCAT_PROP_INKDATA = Guid.initString("7c6a82ae-b0d7-4f14-a745-14f28b009d61");
pub const GUID_COMPARTMENT_SAPI_AUDIO = Guid.initString("51af2086-cc6b-457d-b5aa-8b19dc290ab4");
pub const GUID_COMPARTMENT_KEYBOARD_DISABLED = Guid.initString("71a5b253-1951-466b-9fbc-9c8808fa84f2");
pub const GUID_COMPARTMENT_KEYBOARD_OPENCLOSE = Guid.initString("58273aad-01bb-4164-95c6-755ba0b5162d");
pub const GUID_COMPARTMENT_HANDWRITING_OPENCLOSE = Guid.initString("f9ae2c6b-1866-4361-af72-7aa30948890e");
pub const GUID_COMPARTMENT_SPEECH_DISABLED = Guid.initString("56c5c607-0703-4e59-8e52-cbc84e8bbe35");
pub const GUID_COMPARTMENT_SPEECH_OPENCLOSE = Guid.initString("544d6a63-e2e8-4752-bbd1-000960bca083");
pub const GUID_COMPARTMENT_SPEECH_GLOBALSTATE = Guid.initString("2a54fe8e-0d08-460c-a75d-87035ff436c5");
pub const GUID_COMPARTMENT_CONVERSIONMODEBIAS = Guid.initString("5497f516-ee91-436e-b946-aa2c05f1ac5b");
pub const GUID_PROP_MODEBIAS = Guid.initString("372e0716-974f-40ac-a088-08cdc92ebfbc");
pub const GUID_COMPARTMENT_KEYBOARD_INPUTMODE = Guid.initString("b6592511-bcee-4122-a7c4-09f4b3fa4396");
pub const GUID_MODEBIAS_NONE = Guid.initString("00000000-0000-0000-0000-000000000000");
pub const GUID_MODEBIAS_URLHISTORY = Guid.initString("8b0e54d9-63f2-4c68-84d4-79aee7a59f09");
pub const GUID_MODEBIAS_FILENAME = Guid.initString("d7f707fe-44c6-4fca-8e76-86ab50c7931b");
pub const GUID_MODEBIAS_READING = Guid.initString("e31643a3-6466-4cbf-8d8b-0bd4d8545461");
pub const GUID_MODEBIAS_DATETIME = Guid.initString("f2bdb372-7f61-4039-92ef-1c35599f0222");
pub const GUID_MODEBIAS_NAME = Guid.initString("fddc10f0-d239-49bf-b8fc-5410caaa427e");
pub const GUID_MODEBIAS_CONVERSATION = Guid.initString("0f4ec104-1790-443b-95f1-e10f939d6546");
pub const GUID_MODEBIAS_NUMERIC = Guid.initString("4021766c-e872-48fd-9cee-4ec5c75e16c3");
pub const GUID_MODEBIAS_HIRAGANA = Guid.initString("d73d316e-9b91-46f1-a280-31597f52c694");
pub const GUID_MODEBIAS_KATAKANA = Guid.initString("2e0eeddd-3a1a-499e-8543-3c7ee7949811");
pub const GUID_MODEBIAS_HANGUL = Guid.initString("76ef0541-23b3-4d77-a074-691801ccea17");
pub const GUID_MODEBIAS_CHINESE = Guid.initString("7add26de-4328-489b-83ae-6493750cad5c");
pub const GUID_MODEBIAS_HALFWIDTHKATAKANA = Guid.initString("005f6b63-78d4-41cc-8859-485ca821a795");
pub const GUID_MODEBIAS_FULLWIDTHALPHANUMERIC = Guid.initString("81489fb8-b36a-473d-8146-e4a2258b24ae");
pub const GUID_MODEBIAS_FULLWIDTHHANGUL = Guid.initString("c01ae6c9-45b5-4fd0-9cb1-9f4cebc39fea");
pub const GUID_TFCAT_PROPSTYLE_STATIC = Guid.initString("565fb8d8-6bd4-4ca1-b223-0f2ccb8f4f96");
pub const GUID_TFCAT_DISPLAYATTRIBUTEPROVIDER = Guid.initString("046b8c80-1647-40f7-9b21-b93b81aabc1b");
pub const GUID_TFCAT_DISPLAYATTRIBUTEPROPERTY = Guid.initString("b95f181b-ea4c-4af1-8056-7c321abbb091");
pub const GUID_COMPARTMENT_SPEECH_UI_STATUS = Guid.initString("d92016f0-9367-4fe7-9abf-bc59dacbe0e3");
pub const GUID_COMPARTMENT_EMPTYCONTEXT = Guid.initString("d7487dbf-804e-41c5-894d-ad96fd4eea13");
pub const GUID_COMPARTMENT_TIPUISTATUS = Guid.initString("148ca3ec-0366-401c-8d75-ed978d85fbc9");
pub const GUID_COMPARTMENT_SPEECH_CFGMENU = Guid.initString("fb6c5c2d-4e83-4bb6-91a2-e019bff6762d");
pub const GUID_LBI_SAPILAYR_CFGMENUBUTTON = Guid.initString("d02f24a1-942d-422e-8d99-b4f2addee999");
pub const GUID_TFCAT_TIPCAP_SECUREMODE = Guid.initString("49d2f9ce-1f5e-11d7-a6d3-00065b84435c");
pub const GUID_TFCAT_TIPCAP_UIELEMENTENABLED = Guid.initString("49d2f9cf-1f5e-11d7-a6d3-00065b84435c");
pub const GUID_TFCAT_TIPCAP_INPUTMODECOMPARTMENT = Guid.initString("ccf05dd7-4a87-11d7-a6e2-00065b84435c");
pub const GUID_TFCAT_TIPCAP_COMLESS = Guid.initString("364215d9-75bc-11d7-a6ef-00065b84435c");
pub const GUID_TFCAT_TIPCAP_WOW16 = Guid.initString("364215da-75bc-11d7-a6ef-00065b84435c");
pub const GUID_TFCAT_TIPCAP_IMMERSIVESUPPORT = Guid.initString("13a016df-560b-46cd-947a-4c3af1e0e35d");
pub const GUID_TFCAT_TIPCAP_IMMERSIVEONLY = Guid.initString("3a4259ac-640d-4ad4-89f7-1eb67e7c4ee8");
pub const GUID_TFCAT_TIPCAP_LOCALSERVER = Guid.initString("74769ee9-4a66-4f9d-90d6-bf8b7c3eb461");
pub const GUID_TFCAT_TIPCAP_TSF3 = Guid.initString("07dcb4af-98de-4548-bef7-25bd45979a1f");
pub const GUID_TFCAT_TIPCAP_DUALMODE = Guid.initString("3af314a2-d79f-4b1b-9992-15086d339b05");
pub const GUID_TFCAT_TIPCAP_SYSTRAYSUPPORT = Guid.initString("25504fb4-7bab-4bc1-9c69-cf81890f0ef5");
pub const GUID_COMPARTMENT_KEYBOARD_INPUTMODE_CONVERSION = Guid.initString("ccf05dd8-4a87-11d7-a6e2-00065b84435c");
pub const GUID_COMPARTMENT_KEYBOARD_INPUTMODE_SENTENCE = Guid.initString("ccf05dd9-4a87-11d7-a6e2-00065b84435c");
pub const GUID_COMPARTMENT_TRANSITORYEXTENSION = Guid.initString("8be347f5-c7a0-11d7-b408-00065b84435c");
pub const GUID_COMPARTMENT_TRANSITORYEXTENSION_DOCUMENTMANAGER = Guid.initString("8be347f7-c7a0-11d7-b408-00065b84435c");
pub const GUID_COMPARTMENT_TRANSITORYEXTENSION_PARENT = Guid.initString("8be347f8-c7a0-11d7-b408-00065b84435c");
pub const GUID_COMPARTMENT_ENABLED_PROFILES_UPDATED = Guid.initString("92c1fd48-a9ae-4a7c-be08-4329e4723817");
pub const GUID_TFCAT_TRANSITORYEXTENSIONUI = Guid.initString("6302de22-a5cf-4b02-bfe8-4d72b2bed3c6");
pub const GUID_LBI_INPUTMODE = Guid.initString("2c77a81e-41cc-4178-a3a7-5f8a987568e6");
pub const CLSID_TF_ThreadMgr = Guid.initString("529a9e6b-6587-4f23-ab9e-9c7d683e3c50");
pub const CLSID_TF_LangBarMgr = Guid.initString("ebb08c45-6c4a-4fdc-ae53-4eb8c4c7db8e");
pub const CLSID_TF_DisplayAttributeMgr = Guid.initString("3ce74de4-53d3-4d74-8b83-431b3828ba53");
pub const CLSID_TF_CategoryMgr = Guid.initString("a4b544a1-438d-4b41-9325-869523e2d6c7");
pub const CLSID_TF_InputProcessorProfiles = Guid.initString("33c53a50-f456-4884-b049-85fd643ecfed");
pub const CLSID_TF_LangBarItemMgr = Guid.initString("b9931692-a2b3-4fab-bf33-9ec6f9fb96ac");
pub const CLSID_TF_ClassicLangBar = Guid.initString("3318360c-1afc-4d09-a86b-9f9cb6dceb9c");
pub const CLSID_TF_TransitoryExtensionUIEntry = Guid.initString("ae6be008-07fb-400d-8beb-337a64f7051f");
pub const CLSID_TsfServices = Guid.initString("39aedc00-6b60-46db-8d31-3642be0e4373");
pub const GUID_TS_SERVICE_DATAOBJECT = Guid.initString("6086fbb5-e225-46ce-a770-c1bbd3e05d7b");
pub const GUID_TS_SERVICE_ACCESSIBLE = Guid.initString("f9786200-a5bf-4a0f-8c24-fb16f5d1aabb");
pub const GUID_TS_SERVICE_ACTIVEX = Guid.initString("ea937a50-c9a6-4b7d-894a-49d99b784834");
pub const TS_E_INVALIDPOS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220992));
pub const TS_E_NOLOCK = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220991));
pub const TS_E_NOOBJECT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220990));
pub const TS_E_NOSERVICE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220989));
pub const TS_E_NOINTERFACE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220988));
pub const TS_E_NOSELECTION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220987));
pub const TS_E_NOLAYOUT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220986));
pub const TS_E_INVALIDPOINT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220985));
pub const TS_E_SYNCHRONOUS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220984));
pub const TS_E_READONLY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220983));
pub const TS_E_FORMAT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220982));
pub const TS_S_ASYNC = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262912));
pub const TS_AS_TEXT_CHANGE = @as(u32, 1);
pub const TS_AS_SEL_CHANGE = @as(u32, 2);
pub const TS_AS_LAYOUT_CHANGE = @as(u32, 4);
pub const TS_AS_ATTR_CHANGE = @as(u32, 8);
pub const TS_AS_STATUS_CHANGE = @as(u32, 16);
pub const TS_LF_SYNC = @as(u32, 1);
pub const TS_SD_READONLY = @as(u32, 1);
pub const TS_SD_LOADING = @as(u32, 2);
pub const TS_SD_RESERVED = @as(u32, 4);
pub const TS_SD_TKBAUTOCORRECTENABLE = @as(u32, 8);
pub const TS_SD_TKBPREDICTIONENABLE = @as(u32, 16);
pub const TS_SD_UIINTEGRATIONENABLE = @as(u32, 32);
pub const TS_SD_INPUTPANEMANUALDISPLAYENABLE = @as(u32, 64);
pub const TS_SD_EMBEDDEDHANDWRITINGVIEW_ENABLED = @as(u32, 128);
pub const TS_SD_EMBEDDEDHANDWRITINGVIEW_VISIBLE = @as(u32, 256);
pub const TS_SS_DISJOINTSEL = @as(u32, 1);
pub const TS_SS_REGIONS = @as(u32, 2);
pub const TS_SS_TRANSITORY = @as(u32, 4);
pub const TS_SS_NOHIDDENTEXT = @as(u32, 8);
pub const TS_SS_TKBAUTOCORRECTENABLE = @as(u32, 16);
pub const TS_SS_TKBPREDICTIONENABLE = @as(u32, 32);
pub const TS_SS_UWPCONTROL = @as(u32, 64);
pub const TS_IE_CORRECTION = @as(u32, 1);
pub const TS_IE_COMPOSITION = @as(u32, 2);
pub const TS_IAS_NOQUERY = @as(u32, 1);
pub const TS_IAS_QUERYONLY = @as(u32, 2);
pub const GXFPF_ROUND_NEAREST = @as(u32, 1);
pub const GXFPF_NEAREST = @as(u32, 2);
pub const TS_CHAR_EMBEDDED = @as(u32, 65532);
pub const TS_CHAR_REGION = @as(u32, 0);
pub const TS_CHAR_REPLACEMENT = @as(u32, 65533);
pub const TS_ATTR_FIND_BACKWARDS = @as(u32, 1);
pub const TS_ATTR_FIND_WANT_OFFSET = @as(u32, 2);
pub const TS_ATTR_FIND_UPDATESTART = @as(u32, 4);
pub const TS_ATTR_FIND_WANT_VALUE = @as(u32, 8);
pub const TS_ATTR_FIND_WANT_END = @as(u32, 16);
pub const TS_ATTR_FIND_HIDDEN = @as(u32, 32);
pub const TS_VCOOKIE_NUL = @as(u32, 4294967295);
pub const TS_SHIFT_COUNT_HIDDEN = @as(u32, 1);
pub const TS_SHIFT_HALT_HIDDEN = @as(u32, 2);
pub const TS_SHIFT_HALT_VISIBLE = @as(u32, 4);
pub const TS_SHIFT_COUNT_ONLY = @as(u32, 8);
pub const TS_GTA_HIDDEN = @as(u32, 1);
pub const TS_GEA_HIDDEN = @as(u32, 1);
pub const TF_E_LOCKED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220224));
pub const TF_E_STACKFULL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220223));
pub const TF_E_NOTOWNEDRANGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220222));
pub const TF_E_NOPROVIDER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220221));
pub const TF_E_DISCONNECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220220));
pub const TF_E_INVALIDVIEW = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220219));
pub const TF_E_ALREADY_EXISTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220218));
pub const TF_E_RANGE_NOT_COVERED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220217));
pub const TF_E_COMPOSITION_REJECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220216));
pub const TF_E_EMPTYCONTEXT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220215));
pub const TF_E_INVALIDPOS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220992));
pub const TF_E_NOLOCK = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220991));
pub const TF_E_NOOBJECT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220990));
pub const TF_E_NOSERVICE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220989));
pub const TF_E_NOINTERFACE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220988));
pub const TF_E_NOSELECTION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220987));
pub const TF_E_NOLAYOUT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220986));
pub const TF_E_INVALIDPOINT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220985));
pub const TF_E_SYNCHRONOUS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220984));
pub const TF_E_READONLY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220983));
pub const TF_E_FORMAT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220982));
pub const TF_S_ASYNC = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262912));
pub const TF_RCM_COMLESS = @as(u32, 1);
pub const TF_RCM_VKEY = @as(u32, 2);
pub const TF_RCM_HINT_READING_LENGTH = @as(u32, 4);
pub const TF_RCM_HINT_COLLISION = @as(u32, 8);
pub const TKB_ALTERNATES_STANDARD = @as(u32, 1);
pub const TKB_ALTERNATES_FOR_AUTOCORRECTION = @as(u32, 2);
pub const TKB_ALTERNATES_FOR_PREDICTION = @as(u32, 3);
pub const TKB_ALTERNATES_AUTOCORRECTION_APPLIED = @as(u32, 4);
pub const TF_TMAE_NOACTIVATETIP = @as(u32, 1);
pub const TF_TMAE_SECUREMODE = @as(u32, 2);
pub const TF_TMAE_UIELEMENTENABLEDONLY = @as(u32, 4);
pub const TF_TMAE_COMLESS = @as(u32, 8);
pub const TF_TMAE_WOW16 = @as(u32, 16);
pub const TF_TMAE_NOACTIVATEKEYBOARDLAYOUT = @as(u32, 32);
pub const TF_TMAE_CONSOLE = @as(u32, 64);
pub const TF_TMF_NOACTIVATETIP = @as(u32, 1);
pub const TF_TMF_SECUREMODE = @as(u32, 2);
pub const TF_TMF_UIELEMENTENABLEDONLY = @as(u32, 4);
pub const TF_TMF_COMLESS = @as(u32, 8);
pub const TF_TMF_WOW16 = @as(u32, 16);
pub const TF_TMF_CONSOLE = @as(u32, 64);
pub const TF_TMF_IMMERSIVEMODE = @as(u32, 1073741824);
pub const TF_TMF_ACTIVATED = @as(u32, 2147483648);
pub const TF_MOD_ALT = @as(u32, 1);
pub const TF_MOD_CONTROL = @as(u32, 2);
pub const TF_MOD_SHIFT = @as(u32, 4);
pub const TF_MOD_RALT = @as(u32, 8);
pub const TF_MOD_RCONTROL = @as(u32, 16);
pub const TF_MOD_RSHIFT = @as(u32, 32);
pub const TF_MOD_LALT = @as(u32, 64);
pub const TF_MOD_LCONTROL = @as(u32, 128);
pub const TF_MOD_LSHIFT = @as(u32, 256);
pub const TF_MOD_ON_KEYUP = @as(u32, 512);
pub const TF_MOD_IGNORE_ALL_MODIFIER = @as(u32, 1024);
pub const TF_US_HIDETIPUI = @as(u32, 1);
pub const TF_DISABLE_SPEECH = @as(u32, 1);
pub const TF_DISABLE_DICTATION = @as(u32, 2);
pub const TF_DISABLE_COMMANDING = @as(u32, 4);
pub const TF_CLUIE_DOCUMENTMGR = @as(u32, 1);
pub const TF_CLUIE_COUNT = @as(u32, 2);
pub const TF_CLUIE_SELECTION = @as(u32, 4);
pub const TF_CLUIE_STRING = @as(u32, 8);
pub const TF_CLUIE_PAGEINDEX = @as(u32, 16);
pub const TF_CLUIE_CURRENTPAGE = @as(u32, 32);
pub const TF_RIUIE_CONTEXT = @as(u32, 1);
pub const TF_RIUIE_STRING = @as(u32, 2);
pub const TF_RIUIE_MAXREADINGSTRINGLENGTH = @as(u32, 4);
pub const TF_RIUIE_ERRORINDEX = @as(u32, 8);
pub const TF_RIUIE_VERTICALORDER = @as(u32, 16);
pub const TF_CONVERSIONMODE_ALPHANUMERIC = @as(u32, 0);
pub const TF_CONVERSIONMODE_NATIVE = @as(u32, 1);
pub const TF_CONVERSIONMODE_KATAKANA = @as(u32, 2);
pub const TF_CONVERSIONMODE_FULLSHAPE = @as(u32, 8);
pub const TF_CONVERSIONMODE_ROMAN = @as(u32, 16);
pub const TF_CONVERSIONMODE_CHARCODE = @as(u32, 32);
pub const TF_CONVERSIONMODE_SOFTKEYBOARD = @as(u32, 128);
pub const TF_CONVERSIONMODE_NOCONVERSION = @as(u32, 256);
pub const TF_CONVERSIONMODE_EUDC = @as(u32, 512);
pub const TF_CONVERSIONMODE_SYMBOL = @as(u32, 1024);
pub const TF_CONVERSIONMODE_FIXED = @as(u32, 2048);
pub const TF_SENTENCEMODE_NONE = @as(u32, 0);
pub const TF_SENTENCEMODE_PLAURALCLAUSE = @as(u32, 1);
pub const TF_SENTENCEMODE_SINGLECONVERT = @as(u32, 2);
pub const TF_SENTENCEMODE_AUTOMATIC = @as(u32, 4);
pub const TF_SENTENCEMODE_PHRASEPREDICT = @as(u32, 8);
pub const TF_SENTENCEMODE_CONVERSATION = @as(u32, 16);
pub const TF_TRANSITORYEXTENSION_NONE = @as(u32, 0);
pub const TF_TRANSITORYEXTENSION_FLOATING = @as(u32, 1);
pub const TF_TRANSITORYEXTENSION_ATSELECTION = @as(u32, 2);
pub const TF_PROFILETYPE_INPUTPROCESSOR = @as(u32, 1);
pub const TF_PROFILETYPE_KEYBOARDLAYOUT = @as(u32, 2);
pub const TF_RIP_FLAG_FREEUNUSEDLIBRARIES = @as(u32, 1);
pub const TF_IPP_FLAG_ACTIVE = @as(u32, 1);
pub const TF_IPP_FLAG_ENABLED = @as(u32, 2);
pub const TF_IPP_FLAG_SUBSTITUTEDBYINPUTPROCESSOR = @as(u32, 4);
pub const TF_IPP_CAPS_DISABLEONTRANSITORY = @as(u32, 1);
pub const TF_IPP_CAPS_SECUREMODESUPPORT = @as(u32, 2);
pub const TF_IPP_CAPS_UIELEMENTENABLED = @as(u32, 4);
pub const TF_IPP_CAPS_COMLESSSUPPORT = @as(u32, 8);
pub const TF_IPP_CAPS_WOW16SUPPORT = @as(u32, 16);
pub const TF_IPP_CAPS_IMMERSIVESUPPORT = @as(u32, 65536);
pub const TF_IPP_CAPS_SYSTRAYSUPPORT = @as(u32, 131072);
pub const TF_IPPMF_FORPROCESS = @as(u32, 268435456);
pub const TF_IPPMF_FORSESSION = @as(u32, 536870912);
pub const TF_IPPMF_FORSYSTEMALL = @as(u32, 1073741824);
pub const TF_IPPMF_ENABLEPROFILE = @as(u32, 1);
pub const TF_IPPMF_DISABLEPROFILE = @as(u32, 2);
pub const TF_IPPMF_DONTCARECURRENTINPUTLANGUAGE = @as(u32, 4);
pub const TF_RP_HIDDENINSETTINGUI = @as(u32, 2);
pub const TF_RP_LOCALPROCESS = @as(u32, 4);
pub const TF_RP_LOCALTHREAD = @as(u32, 8);
pub const TF_RP_SUBITEMINSETTINGUI = @as(u32, 16);
pub const TF_URP_ALLPROFILES = @as(u32, 2);
pub const TF_URP_LOCALPROCESS = @as(u32, 4);
pub const TF_URP_LOCALTHREAD = @as(u32, 8);
pub const TF_IPSINK_FLAG_ACTIVE = @as(u32, 1);
pub const TF_INVALID_EDIT_COOKIE = @as(u32, 0);
pub const TF_POPF_ALL = @as(u32, 1);
pub const TF_SD_READONLY = @as(u32, 1);
pub const TF_SD_LOADING = @as(u32, 2);
pub const TF_SS_DISJOINTSEL = @as(u32, 1);
pub const TF_SS_REGIONS = @as(u32, 2);
pub const TF_SS_TRANSITORY = @as(u32, 4);
pub const TF_SS_TKBAUTOCORRECTENABLE = @as(u32, 16);
pub const TF_SS_TKBPREDICTIONENABLE = @as(u32, 32);
pub const TF_CHAR_EMBEDDED = @as(u32, 65532);
pub const TF_HF_OBJECT = @as(u32, 1);
pub const TF_TF_MOVESTART = @as(u32, 1);
pub const TF_TF_IGNOREEND = @as(u32, 2);
pub const TF_ST_CORRECTION = @as(u32, 1);
pub const TF_IE_CORRECTION = @as(u32, 1);
pub const TF_TU_CORRECTION = @as(u32, 1);
pub const TF_INVALID_COOKIE = @as(u32, 4294967295);
pub const TF_PROFILE_NEWPHONETIC = Guid.initString("b2f9c502-1742-11d4-9790-0080c882687e");
pub const TF_PROFILE_PHONETIC = Guid.initString("761309de-317a-11d4-9b5d-0080c882687e");
pub const TF_PROFILE_NEWCHANGJIE = Guid.initString("f3ba907a-6c7e-11d4-97fa-0080c882687e");
pub const TF_PROFILE_CHANGJIE = Guid.initString("4bdf9f03-c7d3-11d4-b2ab-0080c882687e");
pub const TF_PROFILE_NEWQUICK = Guid.initString("0b883ba0-c1c7-11d4-87f9-0080c882687e");
pub const TF_PROFILE_QUICK = Guid.initString("6024b45f-5c54-11d4-b921-0080c882687e");
pub const TF_PROFILE_CANTONESE = Guid.initString("0aec109c-7e96-11d4-b2ef-0080c882687e");
pub const TF_PROFILE_PINYIN = Guid.initString("f3ba9077-6c7e-11d4-97fa-0080c882687e");
pub const TF_PROFILE_SIMPLEFAST = Guid.initString("fa550b04-5ad7-411f-a5ac-ca038ec515d7");
pub const TF_PROFILE_WUBI = Guid.initString("82590c13-f4dd-44f4-ba1d-8667246fdf8e");
pub const TF_PROFILE_DAYI = Guid.initString("037b2c25-480c-4d7f-b027-d6ca6b69788a");
pub const TF_PROFILE_ARRAY = Guid.initString("d38eff65-aa46-4fd5-91a7-67845fb02f5b");
pub const TF_PROFILE_YI = Guid.initString("409c8376-007b-4357-ae8e-26316ee3fb0d");
pub const TF_PROFILE_TIGRINYA = Guid.initString("3cab88b7-cc3e-46a6-9765-b772ad7761ff");
pub const TF_E_NOCONVERSION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147219968));
pub const TF_DICTATION_ON = @as(u32, 1);
pub const TF_DICTATION_ENABLED = @as(u32, 2);
pub const TF_COMMANDING_ENABLED = @as(u32, 4);
pub const TF_COMMANDING_ON = @as(u32, 8);
pub const TF_SPEECHUI_SHOWN = @as(u32, 16);
pub const TF_SHOW_BALLOON = @as(u32, 1);
pub const TF_DISABLE_BALLOON = @as(u32, 2);
pub const TF_MENUREADY = @as(u32, 1);
pub const TF_PROPUI_STATUS_SAVETOFILE = @as(u32, 1);
pub const GUID_INTEGRATIONSTYLE_SEARCHBOX = Guid.initString("e6d1bd11-82f7-4903-ae21-1a6397cde2eb");
pub const TKBL_UNDEFINED = @as(u32, 0);
pub const TKBL_CLASSIC_TRADITIONAL_CHINESE_PHONETIC = @as(u32, 1028);
pub const TKBL_CLASSIC_TRADITIONAL_CHINESE_CHANGJIE = @as(u32, 61506);
pub const TKBL_CLASSIC_TRADITIONAL_CHINESE_DAYI = @as(u32, 61507);
pub const TKBL_OPT_JAPANESE_ABC = @as(u32, 1041);
pub const TKBL_OPT_KOREAN_HANGUL_2_BULSIK = @as(u32, 1042);
pub const TKBL_OPT_SIMPLIFIED_CHINESE_PINYIN = @as(u32, 2052);
pub const TKBL_OPT_TRADITIONAL_CHINESE_PHONETIC = @as(u32, 1028);
pub const TF_LBI_ICON = @as(u32, 1);
pub const TF_LBI_TEXT = @as(u32, 2);
pub const TF_LBI_TOOLTIP = @as(u32, 4);
pub const TF_LBI_BITMAP = @as(u32, 8);
pub const TF_LBI_BALLOON = @as(u32, 16);
pub const TF_LBI_CUSTOMUI = @as(u32, 32);
pub const TF_LBI_STATUS = @as(u32, 65536);
pub const TF_LBI_STYLE_HIDDENSTATUSCONTROL = @as(u32, 1);
pub const TF_LBI_STYLE_SHOWNINTRAY = @as(u32, 2);
pub const TF_LBI_STYLE_HIDEONNOOTHERITEMS = @as(u32, 4);
pub const TF_LBI_STYLE_SHOWNINTRAYONLY = @as(u32, 8);
pub const TF_LBI_STYLE_HIDDENBYDEFAULT = @as(u32, 16);
pub const TF_LBI_STYLE_TEXTCOLORICON = @as(u32, 32);
pub const TF_LBI_STYLE_BTN_BUTTON = @as(u32, 65536);
pub const TF_LBI_STYLE_BTN_MENU = @as(u32, 131072);
pub const TF_LBI_STYLE_BTN_TOGGLE = @as(u32, 262144);
pub const TF_LBI_STATUS_HIDDEN = @as(u32, 1);
pub const TF_LBI_STATUS_DISABLED = @as(u32, 2);
pub const TF_LBI_STATUS_BTN_TOGGLED = @as(u32, 65536);
pub const TF_LBI_BMPF_VERTICAL = @as(u32, 1);
pub const TF_SFT_SHOWNORMAL = @as(u32, 1);
pub const TF_SFT_DOCK = @as(u32, 2);
pub const TF_SFT_MINIMIZED = @as(u32, 4);
pub const TF_SFT_HIDDEN = @as(u32, 8);
pub const TF_SFT_NOTRANSPARENCY = @as(u32, 16);
pub const TF_SFT_LOWTRANSPARENCY = @as(u32, 32);
pub const TF_SFT_HIGHTRANSPARENCY = @as(u32, 64);
pub const TF_SFT_LABELS = @as(u32, 128);
pub const TF_SFT_NOLABELS = @as(u32, 256);
pub const TF_SFT_EXTRAICONSONMINIMIZED = @as(u32, 512);
pub const TF_SFT_NOEXTRAICONSONMINIMIZED = @as(u32, 1024);
pub const TF_SFT_DESKBAND = @as(u32, 2048);
pub const TF_LBI_DESC_MAXLEN = @as(u32, 32);
pub const TF_LBMENUF_CHECKED = @as(u32, 1);
pub const TF_LBMENUF_SUBMENU = @as(u32, 2);
pub const TF_LBMENUF_SEPARATOR = @as(u32, 4);
pub const TF_LBMENUF_RADIOCHECKED = @as(u32, 8);
pub const TF_LBMENUF_GRAYED = @as(u32, 16);
pub const GUID_PROP_INPUTSCOPE = Guid.initString("1713dd5a-68e7-4a5b-9af6-592a595c778d");
pub const DCM_FLAGS_TASKENG = @as(u32, 1);
pub const DCM_FLAGS_CTFMON = @as(u32, 2);
pub const DCM_FLAGS_LOCALTHREADTSF = @as(u32, 4);
pub const ILMCM_CHECKLAYOUTANDTIPENABLED = @as(u32, 1);
pub const ILMCM_LANGUAGEBAROFF = @as(u32, 2);
pub const LIBID_MSAATEXTLib = Guid.initString("150e2d7a-dac1-4582-947d-2a8fd78b82cd");
pub const TS_STRF_START = @as(u32, 0);
pub const TS_STRF_MID = @as(u32, 1);
pub const TS_STRF_END = @as(u32, 2);
pub const TSATTRID_OTHERS = Guid.initString("b3c32af9-57d0-46a9-bca8-dac238a13057");
pub const TSATTRID_Font = Guid.initString("573ea825-749b-4f8a-9cfd-21c3605ca828");
pub const TSATTRID_Font_FaceName = Guid.initString("b536aeb6-053b-4eb8-b65a-50da1e81e72e");
pub const TSATTRID_Font_SizePts = Guid.initString("c8493302-a5e9-456d-af04-8005e4130f03");
pub const TSATTRID_Font_Style = Guid.initString("68b2a77f-6b0e-4f28-8177-571c2f3a42b1");
pub const TSATTRID_Font_Style_Bold = Guid.initString("48813a43-8a20-4940-8e58-97823f7b268a");
pub const TSATTRID_Font_Style_Italic = Guid.initString("8740682a-a765-48e1-acfc-d22222b2f810");
pub const TSATTRID_Font_Style_SmallCaps = Guid.initString("facb6bc6-9100-4cc6-b969-11eea45a86b4");
pub const TSATTRID_Font_Style_Capitalize = Guid.initString("7d85a3ba-b4fd-43b3-befc-6b985c843141");
pub const TSATTRID_Font_Style_Uppercase = Guid.initString("33a300e8-e340-4937-b697-8f234045cd9a");
pub const TSATTRID_Font_Style_Lowercase = Guid.initString("76d8ccb5-ca7b-4498-8ee9-d5c4f6f74c60");
pub const TSATTRID_Font_Style_Animation = Guid.initString("dcf73d22-e029-47b7-bb36-f263a3d004cc");
pub const TSATTRID_Font_Style_Animation_LasVegasLights = Guid.initString("f40423d5-0f87-4f8f-bada-e6d60c25e152");
pub const TSATTRID_Font_Style_Animation_BlinkingBackground = Guid.initString("86e5b104-0104-4b10-b585-00f2527522b5");
pub const TSATTRID_Font_Style_Animation_SparkleText = Guid.initString("533aad20-962c-4e9f-8c09-b42ea4749711");
pub const TSATTRID_Font_Style_Animation_MarchingBlackAnts = Guid.initString("7644e067-f186-4902-bfc6-ec815aa20e9d");
pub const TSATTRID_Font_Style_Animation_MarchingRedAnts = Guid.initString("78368dad-50fb-4c6f-840b-d486bb6cf781");
pub const TSATTRID_Font_Style_Animation_Shimmer = Guid.initString("2ce31b58-5293-4c36-8809-bf8bb51a27b3");
pub const TSATTRID_Font_Style_Animation_WipeDown = Guid.initString("5872e874-367b-4803-b160-c90ff62569d0");
pub const TSATTRID_Font_Style_Animation_WipeRight = Guid.initString("b855cbe3-3d2c-4600-b1e9-e1c9ce02f842");
pub const TSATTRID_Font_Style_Emboss = Guid.initString("bd8ed742-349e-4e37-82fb-437979cb53a7");
pub const TSATTRID_Font_Style_Engrave = Guid.initString("9c3371de-8332-4897-be5d-89233223179a");
pub const TSATTRID_Font_Style_Hidden = Guid.initString("b1e28770-881c-475f-863f-887a647b1090");
pub const TSATTRID_Font_Style_Kerning = Guid.initString("cc26e1b4-2f9a-47c8-8bff-bf1eb7cce0dd");
pub const TSATTRID_Font_Style_Outlined = Guid.initString("10e6db31-db0d-4ac6-a7f5-9c9cff6f2ab4");
pub const TSATTRID_Font_Style_Position = Guid.initString("15cd26ab-f2fb-4062-b5a6-9a49e1a5cc0b");
pub const TSATTRID_Font_Style_Protected = Guid.initString("1c557cb2-14cf-4554-a574-ecb2f7e7efd4");
pub const TSATTRID_Font_Style_Shadow = Guid.initString("5f686d2f-c6cd-4c56-8a1a-994a4b9766be");
pub const TSATTRID_Font_Style_Spacing = Guid.initString("98c1200d-8f06-409a-8e49-6a554bf7c153");
pub const TSATTRID_Font_Style_Weight = Guid.initString("12f3189c-8bb0-461b-b1fa-eaf907047fe0");
pub const TSATTRID_Font_Style_Height = Guid.initString("7e937477-12e6-458b-926a-1fa44ee8f391");
pub const TSATTRID_Font_Style_Underline = Guid.initString("c3c9c9f3-7902-444b-9a7b-48e70f4b50f7");
pub const TSATTRID_Font_Style_Underline_Single = Guid.initString("1b6720e5-0f73-4951-a6b3-6f19e43c9461");
pub const TSATTRID_Font_Style_Underline_Double = Guid.initString("74d24aa6-1db3-4c69-a176-31120e7586d5");
pub const TSATTRID_Font_Style_Strikethrough = Guid.initString("0c562193-2d08-4668-9601-ced41309d7af");
pub const TSATTRID_Font_Style_Strikethrough_Single = Guid.initString("75d736b6-3c8f-4b97-ab78-1877cb990d31");
pub const TSATTRID_Font_Style_Strikethrough_Double = Guid.initString("62489b31-a3e7-4f94-ac43-ebaf8fcc7a9f");
pub const TSATTRID_Font_Style_Overline = Guid.initString("e3989f4a-992b-4301-8ce1-a5b7c6d1f3c8");
pub const TSATTRID_Font_Style_Overline_Single = Guid.initString("8440d94c-51ce-47b2-8d4c-15751e5f721b");
pub const TSATTRID_Font_Style_Overline_Double = Guid.initString("dc46063a-e115-46e3-bcd8-ca6772aa95b4");
pub const TSATTRID_Font_Style_Blink = Guid.initString("bfb2c036-7acf-4532-b720-b416dd7765a8");
pub const TSATTRID_Font_Style_Subscript = Guid.initString("5774fb84-389b-43bc-a74b-1568347cf0f4");
pub const TSATTRID_Font_Style_Superscript = Guid.initString("2ea4993c-563c-49aa-9372-0bef09a9255b");
pub const TSATTRID_Font_Style_Color = Guid.initString("857a7a37-b8af-4e9a-81b4-acf700c8411b");
pub const TSATTRID_Font_Style_BackgroundColor = Guid.initString("b50eaa4e-3091-4468-81db-d79ea190c7c7");
pub const TSATTRID_Text = Guid.initString("7edb8e68-81f9-449d-a15a-87a8388faac0");
pub const TSATTRID_Text_VerticalWriting = Guid.initString("6bba8195-046f-4ea9-b311-97fd66c4274b");
pub const TSATTRID_Text_RightToLeft = Guid.initString("ca666e71-1b08-453d-bfdd-28e08c8aaf7a");
pub const TSATTRID_Text_Orientation = Guid.initString("6bab707f-8785-4c39-8b52-96f878303ffb");
pub const TSATTRID_Text_Language = Guid.initString("d8c04ef1-5753-4c25-8887-85443fe5f819");
pub const TSATTRID_Text_ReadOnly = Guid.initString("85836617-de32-4afd-a50f-a2db110e6e4d");
pub const TSATTRID_Text_EmbeddedObject = Guid.initString("7edb8e68-81f9-449d-a15a-87a8388faac0");
pub const TSATTRID_Text_Alignment = Guid.initString("139941e6-1767-456d-938e-35ba568b5cd4");
pub const TSATTRID_Text_Alignment_Left = Guid.initString("16ae95d3-6361-43a2-8495-d00f397f1693");
pub const TSATTRID_Text_Alignment_Right = Guid.initString("b36f0f98-1b9e-4360-8616-03fb08a78456");
pub const TSATTRID_Text_Alignment_Center = Guid.initString("a4a95c16-53bf-4d55-8b87-4bdd8d4275fc");
pub const TSATTRID_Text_Alignment_Justify = Guid.initString("ed350740-a0f7-42d3-8ea8-f81b6488faf0");
pub const TSATTRID_Text_Link = Guid.initString("47cd9051-3722-4cd8-b7c8-4e17ca1759f5");
pub const TSATTRID_Text_Hyphenation = Guid.initString("dadf4525-618e-49eb-b1a8-3b68bd7648e3");
pub const TSATTRID_Text_Para = Guid.initString("5edc5822-99dc-4dd6-aec3-b62baa5b2e7c");
pub const TSATTRID_Text_Para_FirstLineIndent = Guid.initString("07c97a13-7472-4dd8-90a9-91e3d7e4f29c");
pub const TSATTRID_Text_Para_LeftIndent = Guid.initString("fb2848e9-7471-41c9-b6b3-8a1450e01897");
pub const TSATTRID_Text_Para_RightIndent = Guid.initString("2c7f26f9-a5e2-48da-b98a-520cb16513bf");
pub const TSATTRID_Text_Para_SpaceAfter = Guid.initString("7b0a3f55-22dc-425f-a411-93da1d8f9baa");
pub const TSATTRID_Text_Para_SpaceBefore = Guid.initString("8df98589-194a-4601-b251-9865a3e906dd");
pub const TSATTRID_Text_Para_LineSpacing = Guid.initString("699b380d-7f8c-46d6-a73b-dfe3d1538df3");
pub const TSATTRID_Text_Para_LineSpacing_Single = Guid.initString("ed350740-a0f7-42d3-8ea8-f81b6488faf0");
pub const TSATTRID_Text_Para_LineSpacing_OnePtFive = Guid.initString("0428a021-0397-4b57-9a17-0795994cd3c5");
pub const TSATTRID_Text_Para_LineSpacing_Double = Guid.initString("82fb1805-a6c4-4231-ac12-6260af2aba28");
pub const TSATTRID_Text_Para_LineSpacing_AtLeast = Guid.initString("adfedf31-2d44-4434-a5ff-7f4c4990a905");
pub const TSATTRID_Text_Para_LineSpacing_Exactly = Guid.initString("3d45ad40-23de-48d7-a6b3-765420c620cc");
pub const TSATTRID_Text_Para_LineSpacing_Multiple = Guid.initString("910f1e3c-d6d0-4f65-8a3c-42b4b31868c5");
pub const TSATTRID_List = Guid.initString("436d673b-26f1-4aee-9e65-8f83a4ed4884");
pub const TSATTRID_List_LevelIndel = Guid.initString("7f7cc899-311f-487b-ad5d-e2a459e12d42");
pub const TSATTRID_List_Type = Guid.initString("ae3e665e-4bce-49e3-a0fe-2db47d3a17ae");
pub const TSATTRID_List_Type_Bullet = Guid.initString("bccd77c5-4c4d-4ce2-b102-559f3b2bfcea");
pub const TSATTRID_List_Type_Arabic = Guid.initString("1338c5d6-98a3-4fa3-9bd1-7a60eef8e9e0");
pub const TSATTRID_List_Type_LowerLetter = Guid.initString("96372285-f3cf-491e-a925-3832347fd237");
pub const TSATTRID_List_Type_UpperLetter = Guid.initString("7987b7cd-ce52-428b-9b95-a357f6f10c45");
pub const TSATTRID_List_Type_LowerRoman = Guid.initString("90466262-3980-4b8e-9368-918bd1218a41");
pub const TSATTRID_List_Type_UpperRoman = Guid.initString("0f6ab552-4a80-467f-b2f1-127e2aa3ba9e");
pub const TSATTRID_App = Guid.initString("a80f77df-4237-40e5-849c-b5fa51c13ac7");
pub const TSATTRID_App_IncorrectSpelling = Guid.initString("f42de43c-ef12-430d-944c-9a08970a25d2");
pub const TSATTRID_App_IncorrectGrammar = Guid.initString("bd54e398-ad03-4b74-b6b3-5edb19996388");

//--------------------------------------------------------------------------------
// Section: Types (211)
//--------------------------------------------------------------------------------
pub const LANG_BAR_ITEM_ICON_MODE_FLAGS = enum(u32) {
    NONE = 0,
    USEPROFILEICON = 1,
};
pub const TF_DTLBI_NONE = LANG_BAR_ITEM_ICON_MODE_FLAGS.NONE;
pub const TF_DTLBI_USEPROFILEICON = LANG_BAR_ITEM_ICON_MODE_FLAGS.USEPROFILEICON;

pub const TEXT_STORE_TEXT_CHANGE_FLAGS = enum(u32) {
    NONE = 0,
    CORRECTION = 1,
    _,
    pub fn initFlags(o: struct {
        NONE: u1 = 0,
        CORRECTION: u1 = 0,
    }) TEXT_STORE_TEXT_CHANGE_FLAGS {
        return @as(TEXT_STORE_TEXT_CHANGE_FLAGS, @enumFromInt((if (o.NONE == 1) @intFromEnum(TEXT_STORE_TEXT_CHANGE_FLAGS.NONE) else 0) | (if (o.CORRECTION == 1) @intFromEnum(TEXT_STORE_TEXT_CHANGE_FLAGS.CORRECTION) else 0)));
    }
};
pub const TS_ST_NONE = TEXT_STORE_TEXT_CHANGE_FLAGS.NONE;
pub const TS_ST_CORRECTION = TEXT_STORE_TEXT_CHANGE_FLAGS.CORRECTION;

pub const TEXT_STORE_CHANGE_FLAGS = enum(u32) {
    NONE = 0,
    CORRECTION = 1,
    _,
    pub fn initFlags(o: struct {
        NONE: u1 = 0,
        CORRECTION: u1 = 0,
    }) TEXT_STORE_CHANGE_FLAGS {
        return @as(TEXT_STORE_CHANGE_FLAGS, @enumFromInt((if (o.NONE == 1) @intFromEnum(TEXT_STORE_CHANGE_FLAGS.NONE) else 0) | (if (o.CORRECTION == 1) @intFromEnum(TEXT_STORE_CHANGE_FLAGS.CORRECTION) else 0)));
    }
};
pub const TS_TC_NONE = TEXT_STORE_CHANGE_FLAGS.NONE;
pub const TS_TC_CORRECTION = TEXT_STORE_CHANGE_FLAGS.CORRECTION;

pub const INSERT_TEXT_AT_SELECTION_FLAGS = enum(u32) {
    NOQUERY = 1,
    QUERYONLY = 2,
    NO_DEFAULT_COMPOSITION = 2147483648,
};
pub const TF_IAS_NOQUERY = INSERT_TEXT_AT_SELECTION_FLAGS.NOQUERY;
pub const TF_IAS_QUERYONLY = INSERT_TEXT_AT_SELECTION_FLAGS.QUERYONLY;
pub const TF_IAS_NO_DEFAULT_COMPOSITION = INSERT_TEXT_AT_SELECTION_FLAGS.NO_DEFAULT_COMPOSITION;

pub const ANCHOR_CHANGE_HISTORY_FLAGS = enum(u32) {
    PRECEDING_DEL = 1,
    FOLLOWING_DEL = 2,
    _,
    pub fn initFlags(o: struct {
        PRECEDING_DEL: u1 = 0,
        FOLLOWING_DEL: u1 = 0,
    }) ANCHOR_CHANGE_HISTORY_FLAGS {
        return @as(ANCHOR_CHANGE_HISTORY_FLAGS, @enumFromInt((if (o.PRECEDING_DEL == 1) @intFromEnum(ANCHOR_CHANGE_HISTORY_FLAGS.PRECEDING_DEL) else 0) | (if (o.FOLLOWING_DEL == 1) @intFromEnum(ANCHOR_CHANGE_HISTORY_FLAGS.FOLLOWING_DEL) else 0)));
    }
};
pub const TS_CH_PRECEDING_DEL = ANCHOR_CHANGE_HISTORY_FLAGS.PRECEDING_DEL;
pub const TS_CH_FOLLOWING_DEL = ANCHOR_CHANGE_HISTORY_FLAGS.FOLLOWING_DEL;

pub const TEXT_STORE_LOCK_FLAGS = enum(u32) {
    D = 2,
    WRITE = 6,
};
pub const TS_LF_READ = TEXT_STORE_LOCK_FLAGS.D;
pub const TS_LF_READWRITE = TEXT_STORE_LOCK_FLAGS.WRITE;

pub const GET_TEXT_AND_PROPERTY_UPDATES_FLAGS = enum(u32) {
    NONE = 0,
    INCL_TEXT = 1,
    _,
    pub fn initFlags(o: struct {
        NONE: u1 = 0,
        INCL_TEXT: u1 = 0,
    }) GET_TEXT_AND_PROPERTY_UPDATES_FLAGS {
        return @as(GET_TEXT_AND_PROPERTY_UPDATES_FLAGS, @enumFromInt((if (o.NONE == 1) @intFromEnum(GET_TEXT_AND_PROPERTY_UPDATES_FLAGS.NONE) else 0) | (if (o.INCL_TEXT == 1) @intFromEnum(GET_TEXT_AND_PROPERTY_UPDATES_FLAGS.INCL_TEXT) else 0)));
    }
};
pub const TF_GTP_NONE = GET_TEXT_AND_PROPERTY_UPDATES_FLAGS.NONE;
pub const TF_GTP_INCL_TEXT = GET_TEXT_AND_PROPERTY_UPDATES_FLAGS.INCL_TEXT;

pub const TF_CONTEXT_EDIT_CONTEXT_FLAGS = enum(u32) {
    ASYNCDONTCARE = 0,
    SYNC = 1,
    READ = 2,
    READWRITE = 6,
    ASYNC = 8,
    _,
    pub fn initFlags(o: struct {
        ASYNCDONTCARE: u1 = 0,
        SYNC: u1 = 0,
        READ: u1 = 0,
        READWRITE: u1 = 0,
        ASYNC: u1 = 0,
    }) TF_CONTEXT_EDIT_CONTEXT_FLAGS {
        return @as(TF_CONTEXT_EDIT_CONTEXT_FLAGS, @enumFromInt((if (o.ASYNCDONTCARE == 1) @intFromEnum(TF_CONTEXT_EDIT_CONTEXT_FLAGS.ASYNCDONTCARE) else 0) | (if (o.SYNC == 1) @intFromEnum(TF_CONTEXT_EDIT_CONTEXT_FLAGS.SYNC) else 0) | (if (o.READ == 1) @intFromEnum(TF_CONTEXT_EDIT_CONTEXT_FLAGS.READ) else 0) | (if (o.READWRITE == 1) @intFromEnum(TF_CONTEXT_EDIT_CONTEXT_FLAGS.READWRITE) else 0) | (if (o.ASYNC == 1) @intFromEnum(TF_CONTEXT_EDIT_CONTEXT_FLAGS.ASYNC) else 0)));
    }
};
pub const TF_ES_ASYNCDONTCARE = TF_CONTEXT_EDIT_CONTEXT_FLAGS.ASYNCDONTCARE;
pub const TF_ES_SYNC = TF_CONTEXT_EDIT_CONTEXT_FLAGS.SYNC;
pub const TF_ES_READ = TF_CONTEXT_EDIT_CONTEXT_FLAGS.READ;
pub const TF_ES_READWRITE = TF_CONTEXT_EDIT_CONTEXT_FLAGS.READWRITE;
pub const TF_ES_ASYNC = TF_CONTEXT_EDIT_CONTEXT_FLAGS.ASYNC;

pub const HKL = *opaque {};

pub const TS_STATUS = extern struct {
    dwDynamicFlags: u32,
    dwStaticFlags: u32,
};

pub const TS_TEXTCHANGE = extern struct {
    acpStart: i32,
    acpOldEnd: i32,
    acpNewEnd: i32,
};

pub const TsActiveSelEnd = enum(i32) {
    NONE = 0,
    START = 1,
    END = 2,
};
pub const TS_AE_NONE = TsActiveSelEnd.NONE;
pub const TS_AE_START = TsActiveSelEnd.START;
pub const TS_AE_END = TsActiveSelEnd.END;

pub const TS_SELECTIONSTYLE = extern struct {
    ase: TsActiveSelEnd,
    fInterimChar: BOOL,
};

pub const TS_SELECTION_ACP = extern struct {
    acpStart: i32,
    acpEnd: i32,
    style: TS_SELECTIONSTYLE,
};

pub const TS_SELECTION_ANCHOR = extern struct {
    paStart: ?*IAnchor,
    paEnd: ?*IAnchor,
    style: TS_SELECTIONSTYLE,
};

pub const TS_ATTRVAL = extern struct {
    idAttr: Guid,
    dwOverlapId: u32,
    varValue: VARIANT,
};

pub const TsLayoutCode = enum(i32) {
    CREATE = 0,
    CHANGE = 1,
    DESTROY = 2,
};
pub const TS_LC_CREATE = TsLayoutCode.CREATE;
pub const TS_LC_CHANGE = TsLayoutCode.CHANGE;
pub const TS_LC_DESTROY = TsLayoutCode.DESTROY;

pub const TsRunType = enum(i32) {
    PLAIN = 0,
    HIDDEN = 1,
    OPAQUE = 2,
};
pub const TS_RT_PLAIN = TsRunType.PLAIN;
pub const TS_RT_HIDDEN = TsRunType.HIDDEN;
pub const TS_RT_OPAQUE = TsRunType.OPAQUE;

pub const TS_RUNINFO = extern struct {
    uCount: u32,
    type: TsRunType,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITextStoreACP_Value = Guid.initString("28888fe3-c2a0-483a-a3ea-8cb1ce51ff3d");
pub const IID_ITextStoreACP = &IID_ITextStoreACP_Value;
pub const ITextStoreACP = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AdviseSink: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreACP,
                riid: ?*const Guid,
                punk: ?*IUnknown,
                dwMask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreACP,
                riid: ?*const Guid,
                punk: ?*IUnknown,
                dwMask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnadviseSink: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreACP,
                punk: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreACP,
                punk: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RequestLock: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreACP,
                dwLockFlags: u32,
                phrSession: ?*HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreACP,
                dwLockFlags: u32,
                phrSession: ?*HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreACP,
                pdcs: ?*TS_STATUS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreACP,
                pdcs: ?*TS_STATUS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryInsert: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreACP,
                acpTestStart: i32,
                acpTestEnd: i32,
                cch: u32,
                pacpResultStart: ?*i32,
                pacpResultEnd: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreACP,
                acpTestStart: i32,
                acpTestEnd: i32,
                cch: u32,
                pacpResultStart: ?*i32,
                pacpResultEnd: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSelection: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreACP,
                ulIndex: u32,
                ulCount: u32,
                pSelection: [*]TS_SELECTION_ACP,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreACP,
                ulIndex: u32,
                ulCount: u32,
                pSelection: [*]TS_SELECTION_ACP,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSelection: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreACP,
                ulCount: u32,
                pSelection: [*]const TS_SELECTION_ACP,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreACP,
                ulCount: u32,
                pSelection: [*]const TS_SELECTION_ACP,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreACP,
                acpStart: i32,
                acpEnd: i32,
                pchPlain: [*:0]u16,
                cchPlainReq: u32,
                pcchPlainRet: ?*u32,
                prgRunInfo: [*]TS_RUNINFO,
                cRunInfoReq: u32,
                pcRunInfoRet: ?*u32,
                pacpNext: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreACP,
                acpStart: i32,
                acpEnd: i32,
                pchPlain: [*:0]u16,
                cchPlainReq: u32,
                pcchPlainRet: ?*u32,
                prgRunInfo: [*]TS_RUNINFO,
                cRunInfoReq: u32,
                pcRunInfoRet: ?*u32,
                pacpNext: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreACP,
                dwFlags: u32,
                acpStart: i32,
                acpEnd: i32,
                pchText: [*:0]const u16,
                cch: u32,
                pChange: ?*TS_TEXTCHANGE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreACP,
                dwFlags: u32,
                acpStart: i32,
                acpEnd: i32,
                pchText: [*:0]const u16,
                cch: u32,
                pChange: ?*TS_TEXTCHANGE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFormattedText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreACP,
                acpStart: i32,
                acpEnd: i32,
                ppDataObject: ?*?*IDataObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreACP,
                acpStart: i32,
                acpEnd: i32,
                ppDataObject: ?*?*IDataObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEmbedded: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreACP,
                acpPos: i32,
                rguidService: ?*const Guid,
                riid: ?*const Guid,
                ppunk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreACP,
                acpPos: i32,
                rguidService: ?*const Guid,
                riid: ?*const Guid,
                ppunk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryInsertEmbedded: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreACP,
                pguidService: ?*const Guid,
                pFormatEtc: ?*const FORMATETC,
                pfInsertable: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreACP,
                pguidService: ?*const Guid,
                pFormatEtc: ?*const FORMATETC,
                pfInsertable: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InsertEmbedded: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreACP,
                dwFlags: u32,
                acpStart: i32,
                acpEnd: i32,
                pDataObject: ?*IDataObject,
                pChange: ?*TS_TEXTCHANGE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreACP,
                dwFlags: u32,
                acpStart: i32,
                acpEnd: i32,
                pDataObject: ?*IDataObject,
                pChange: ?*TS_TEXTCHANGE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InsertTextAtSelection: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreACP,
                dwFlags: u32,
                pchText: [*:0]const u16,
                cch: u32,
                pacpStart: ?*i32,
                pacpEnd: ?*i32,
                pChange: ?*TS_TEXTCHANGE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreACP,
                dwFlags: u32,
                pchText: [*:0]const u16,
                cch: u32,
                pacpStart: ?*i32,
                pacpEnd: ?*i32,
                pChange: ?*TS_TEXTCHANGE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InsertEmbeddedAtSelection: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreACP,
                dwFlags: u32,
                pDataObject: ?*IDataObject,
                pacpStart: ?*i32,
                pacpEnd: ?*i32,
                pChange: ?*TS_TEXTCHANGE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreACP,
                dwFlags: u32,
                pDataObject: ?*IDataObject,
                pacpStart: ?*i32,
                pacpEnd: ?*i32,
                pChange: ?*TS_TEXTCHANGE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RequestSupportedAttrs: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreACP,
                dwFlags: u32,
                cFilterAttrs: u32,
                paFilterAttrs: [*]const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreACP,
                dwFlags: u32,
                cFilterAttrs: u32,
                paFilterAttrs: [*]const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RequestAttrsAtPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreACP,
                acpPos: i32,
                cFilterAttrs: u32,
                paFilterAttrs: [*]const Guid,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreACP,
                acpPos: i32,
                cFilterAttrs: u32,
                paFilterAttrs: [*]const Guid,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RequestAttrsTransitioningAtPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreACP,
                acpPos: i32,
                cFilterAttrs: u32,
                paFilterAttrs: [*]const Guid,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreACP,
                acpPos: i32,
                cFilterAttrs: u32,
                paFilterAttrs: [*]const Guid,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindNextAttrTransition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreACP,
                acpStart: i32,
                acpHalt: i32,
                cFilterAttrs: u32,
                paFilterAttrs: [*]const Guid,
                dwFlags: u32,
                pacpNext: ?*i32,
                pfFound: ?*BOOL,
                plFoundOffset: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreACP,
                acpStart: i32,
                acpHalt: i32,
                cFilterAttrs: u32,
                paFilterAttrs: [*]const Guid,
                dwFlags: u32,
                pacpNext: ?*i32,
                pfFound: ?*BOOL,
                plFoundOffset: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RetrieveRequestedAttrs: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreACP,
                ulCount: u32,
                paAttrVals: [*]TS_ATTRVAL,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreACP,
                ulCount: u32,
                paAttrVals: [*]TS_ATTRVAL,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEndACP: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreACP,
                pacp: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreACP,
                pacp: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetActiveView: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreACP,
                pvcView: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreACP,
                pvcView: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetACPFromPoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreACP,
                vcView: u32,
                ptScreen: ?*const POINT,
                dwFlags: u32,
                pacp: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreACP,
                vcView: u32,
                ptScreen: ?*const POINT,
                dwFlags: u32,
                pacp: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTextExt: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreACP,
                vcView: u32,
                acpStart: i32,
                acpEnd: i32,
                prc: ?*RECT,
                pfClipped: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreACP,
                vcView: u32,
                acpStart: i32,
                acpEnd: i32,
                prc: ?*RECT,
                pfClipped: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetScreenExt: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreACP,
                vcView: u32,
                prc: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreACP,
                vcView: u32,
                prc: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetWnd: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreACP,
                vcView: u32,
                phwnd: ?*?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreACP,
                vcView: u32,
                phwnd: ?*?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreACP_AdviseSink(self: *const T, riid: ?*const Guid, punk: ?*IUnknown, dwMask: u32) HRESULT {
                return @as(*const ITextStoreACP.VTable, @ptrCast(self.vtable)).AdviseSink(@as(*const ITextStoreACP, @ptrCast(self)), riid, punk, dwMask);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreACP_UnadviseSink(self: *const T, punk: ?*IUnknown) HRESULT {
                return @as(*const ITextStoreACP.VTable, @ptrCast(self.vtable)).UnadviseSink(@as(*const ITextStoreACP, @ptrCast(self)), punk);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreACP_RequestLock(self: *const T, dwLockFlags: u32, phrSession: ?*HRESULT) HRESULT {
                return @as(*const ITextStoreACP.VTable, @ptrCast(self.vtable)).RequestLock(@as(*const ITextStoreACP, @ptrCast(self)), dwLockFlags, phrSession);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreACP_GetStatus(self: *const T, pdcs: ?*TS_STATUS) HRESULT {
                return @as(*const ITextStoreACP.VTable, @ptrCast(self.vtable)).GetStatus(@as(*const ITextStoreACP, @ptrCast(self)), pdcs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreACP_QueryInsert(self: *const T, acpTestStart: i32, acpTestEnd: i32, cch: u32, pacpResultStart: ?*i32, pacpResultEnd: ?*i32) HRESULT {
                return @as(*const ITextStoreACP.VTable, @ptrCast(self.vtable)).QueryInsert(@as(*const ITextStoreACP, @ptrCast(self)), acpTestStart, acpTestEnd, cch, pacpResultStart, pacpResultEnd);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreACP_GetSelection(self: *const T, ulIndex: u32, ulCount: u32, pSelection: [*]TS_SELECTION_ACP, pcFetched: ?*u32) HRESULT {
                return @as(*const ITextStoreACP.VTable, @ptrCast(self.vtable)).GetSelection(@as(*const ITextStoreACP, @ptrCast(self)), ulIndex, ulCount, pSelection, pcFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreACP_SetSelection(self: *const T, ulCount: u32, pSelection: [*]const TS_SELECTION_ACP) HRESULT {
                return @as(*const ITextStoreACP.VTable, @ptrCast(self.vtable)).SetSelection(@as(*const ITextStoreACP, @ptrCast(self)), ulCount, pSelection);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreACP_GetText(self: *const T, acpStart: i32, acpEnd: i32, pchPlain: [*:0]u16, cchPlainReq: u32, pcchPlainRet: ?*u32, prgRunInfo: [*]TS_RUNINFO, cRunInfoReq: u32, pcRunInfoRet: ?*u32, pacpNext: ?*i32) HRESULT {
                return @as(*const ITextStoreACP.VTable, @ptrCast(self.vtable)).GetText(@as(*const ITextStoreACP, @ptrCast(self)), acpStart, acpEnd, pchPlain, cchPlainReq, pcchPlainRet, prgRunInfo, cRunInfoReq, pcRunInfoRet, pacpNext);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreACP_SetText(self: *const T, dwFlags: u32, acpStart: i32, acpEnd: i32, pchText: [*:0]const u16, cch: u32, pChange: ?*TS_TEXTCHANGE) HRESULT {
                return @as(*const ITextStoreACP.VTable, @ptrCast(self.vtable)).SetText(@as(*const ITextStoreACP, @ptrCast(self)), dwFlags, acpStart, acpEnd, pchText, cch, pChange);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreACP_GetFormattedText(self: *const T, acpStart: i32, acpEnd: i32, ppDataObject: ?*?*IDataObject) HRESULT {
                return @as(*const ITextStoreACP.VTable, @ptrCast(self.vtable)).GetFormattedText(@as(*const ITextStoreACP, @ptrCast(self)), acpStart, acpEnd, ppDataObject);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreACP_GetEmbedded(self: *const T, acpPos: i32, rguidService: ?*const Guid, riid: ?*const Guid, ppunk: ?*?*IUnknown) HRESULT {
                return @as(*const ITextStoreACP.VTable, @ptrCast(self.vtable)).GetEmbedded(@as(*const ITextStoreACP, @ptrCast(self)), acpPos, rguidService, riid, ppunk);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreACP_QueryInsertEmbedded(self: *const T, pguidService: ?*const Guid, pFormatEtc: ?*const FORMATETC, pfInsertable: ?*BOOL) HRESULT {
                return @as(*const ITextStoreACP.VTable, @ptrCast(self.vtable)).QueryInsertEmbedded(@as(*const ITextStoreACP, @ptrCast(self)), pguidService, pFormatEtc, pfInsertable);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreACP_InsertEmbedded(self: *const T, dwFlags: u32, acpStart: i32, acpEnd: i32, pDataObject: ?*IDataObject, pChange: ?*TS_TEXTCHANGE) HRESULT {
                return @as(*const ITextStoreACP.VTable, @ptrCast(self.vtable)).InsertEmbedded(@as(*const ITextStoreACP, @ptrCast(self)), dwFlags, acpStart, acpEnd, pDataObject, pChange);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreACP_InsertTextAtSelection(self: *const T, dwFlags: u32, pchText: [*:0]const u16, cch: u32, pacpStart: ?*i32, pacpEnd: ?*i32, pChange: ?*TS_TEXTCHANGE) HRESULT {
                return @as(*const ITextStoreACP.VTable, @ptrCast(self.vtable)).InsertTextAtSelection(@as(*const ITextStoreACP, @ptrCast(self)), dwFlags, pchText, cch, pacpStart, pacpEnd, pChange);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreACP_InsertEmbeddedAtSelection(self: *const T, dwFlags: u32, pDataObject: ?*IDataObject, pacpStart: ?*i32, pacpEnd: ?*i32, pChange: ?*TS_TEXTCHANGE) HRESULT {
                return @as(*const ITextStoreACP.VTable, @ptrCast(self.vtable)).InsertEmbeddedAtSelection(@as(*const ITextStoreACP, @ptrCast(self)), dwFlags, pDataObject, pacpStart, pacpEnd, pChange);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreACP_RequestSupportedAttrs(self: *const T, dwFlags: u32, cFilterAttrs: u32, paFilterAttrs: [*]const Guid) HRESULT {
                return @as(*const ITextStoreACP.VTable, @ptrCast(self.vtable)).RequestSupportedAttrs(@as(*const ITextStoreACP, @ptrCast(self)), dwFlags, cFilterAttrs, paFilterAttrs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreACP_RequestAttrsAtPosition(self: *const T, acpPos: i32, cFilterAttrs: u32, paFilterAttrs: [*]const Guid, dwFlags: u32) HRESULT {
                return @as(*const ITextStoreACP.VTable, @ptrCast(self.vtable)).RequestAttrsAtPosition(@as(*const ITextStoreACP, @ptrCast(self)), acpPos, cFilterAttrs, paFilterAttrs, dwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreACP_RequestAttrsTransitioningAtPosition(self: *const T, acpPos: i32, cFilterAttrs: u32, paFilterAttrs: [*]const Guid, dwFlags: u32) HRESULT {
                return @as(*const ITextStoreACP.VTable, @ptrCast(self.vtable)).RequestAttrsTransitioningAtPosition(@as(*const ITextStoreACP, @ptrCast(self)), acpPos, cFilterAttrs, paFilterAttrs, dwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreACP_FindNextAttrTransition(self: *const T, acpStart: i32, acpHalt: i32, cFilterAttrs: u32, paFilterAttrs: [*]const Guid, dwFlags: u32, pacpNext: ?*i32, pfFound: ?*BOOL, plFoundOffset: ?*i32) HRESULT {
                return @as(*const ITextStoreACP.VTable, @ptrCast(self.vtable)).FindNextAttrTransition(@as(*const ITextStoreACP, @ptrCast(self)), acpStart, acpHalt, cFilterAttrs, paFilterAttrs, dwFlags, pacpNext, pfFound, plFoundOffset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreACP_RetrieveRequestedAttrs(self: *const T, ulCount: u32, paAttrVals: [*]TS_ATTRVAL, pcFetched: ?*u32) HRESULT {
                return @as(*const ITextStoreACP.VTable, @ptrCast(self.vtable)).RetrieveRequestedAttrs(@as(*const ITextStoreACP, @ptrCast(self)), ulCount, paAttrVals, pcFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreACP_GetEndACP(self: *const T, pacp: ?*i32) HRESULT {
                return @as(*const ITextStoreACP.VTable, @ptrCast(self.vtable)).GetEndACP(@as(*const ITextStoreACP, @ptrCast(self)), pacp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreACP_GetActiveView(self: *const T, pvcView: ?*u32) HRESULT {
                return @as(*const ITextStoreACP.VTable, @ptrCast(self.vtable)).GetActiveView(@as(*const ITextStoreACP, @ptrCast(self)), pvcView);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreACP_GetACPFromPoint(self: *const T, vcView: u32, ptScreen: ?*const POINT, dwFlags: u32, pacp: ?*i32) HRESULT {
                return @as(*const ITextStoreACP.VTable, @ptrCast(self.vtable)).GetACPFromPoint(@as(*const ITextStoreACP, @ptrCast(self)), vcView, ptScreen, dwFlags, pacp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreACP_GetTextExt(self: *const T, vcView: u32, acpStart: i32, acpEnd: i32, prc: ?*RECT, pfClipped: ?*BOOL) HRESULT {
                return @as(*const ITextStoreACP.VTable, @ptrCast(self.vtable)).GetTextExt(@as(*const ITextStoreACP, @ptrCast(self)), vcView, acpStart, acpEnd, prc, pfClipped);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreACP_GetScreenExt(self: *const T, vcView: u32, prc: ?*RECT) HRESULT {
                return @as(*const ITextStoreACP.VTable, @ptrCast(self.vtable)).GetScreenExt(@as(*const ITextStoreACP, @ptrCast(self)), vcView, prc);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreACP_GetWnd(self: *const T, vcView: u32, phwnd: ?*?HWND) HRESULT {
                return @as(*const ITextStoreACP.VTable, @ptrCast(self.vtable)).GetWnd(@as(*const ITextStoreACP, @ptrCast(self)), vcView, phwnd);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ITextStoreACP2_Value = Guid.initString("f86ad89f-5fe4-4b8d-bb9f-ef3797a84f1f");
pub const IID_ITextStoreACP2 = &IID_ITextStoreACP2_Value;
pub const ITextStoreACP2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AdviseSink: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreACP2,
                riid: ?*const Guid,
                punk: ?*IUnknown,
                dwMask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreACP2,
                riid: ?*const Guid,
                punk: ?*IUnknown,
                dwMask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnadviseSink: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreACP2,
                punk: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreACP2,
                punk: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RequestLock: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreACP2,
                dwLockFlags: u32,
                phrSession: ?*HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreACP2,
                dwLockFlags: u32,
                phrSession: ?*HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreACP2,
                pdcs: ?*TS_STATUS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreACP2,
                pdcs: ?*TS_STATUS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryInsert: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreACP2,
                acpTestStart: i32,
                acpTestEnd: i32,
                cch: u32,
                pacpResultStart: ?*i32,
                pacpResultEnd: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreACP2,
                acpTestStart: i32,
                acpTestEnd: i32,
                cch: u32,
                pacpResultStart: ?*i32,
                pacpResultEnd: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSelection: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreACP2,
                ulIndex: u32,
                ulCount: u32,
                pSelection: [*]TS_SELECTION_ACP,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreACP2,
                ulIndex: u32,
                ulCount: u32,
                pSelection: [*]TS_SELECTION_ACP,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSelection: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreACP2,
                ulCount: u32,
                pSelection: [*]const TS_SELECTION_ACP,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreACP2,
                ulCount: u32,
                pSelection: [*]const TS_SELECTION_ACP,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreACP2,
                acpStart: i32,
                acpEnd: i32,
                pchPlain: [*:0]u16,
                cchPlainReq: u32,
                pcchPlainRet: ?*u32,
                prgRunInfo: [*]TS_RUNINFO,
                cRunInfoReq: u32,
                pcRunInfoRet: ?*u32,
                pacpNext: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreACP2,
                acpStart: i32,
                acpEnd: i32,
                pchPlain: [*:0]u16,
                cchPlainReq: u32,
                pcchPlainRet: ?*u32,
                prgRunInfo: [*]TS_RUNINFO,
                cRunInfoReq: u32,
                pcRunInfoRet: ?*u32,
                pacpNext: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreACP2,
                dwFlags: u32,
                acpStart: i32,
                acpEnd: i32,
                pchText: [*:0]const u16,
                cch: u32,
                pChange: ?*TS_TEXTCHANGE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreACP2,
                dwFlags: u32,
                acpStart: i32,
                acpEnd: i32,
                pchText: [*:0]const u16,
                cch: u32,
                pChange: ?*TS_TEXTCHANGE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFormattedText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreACP2,
                acpStart: i32,
                acpEnd: i32,
                ppDataObject: ?*?*IDataObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreACP2,
                acpStart: i32,
                acpEnd: i32,
                ppDataObject: ?*?*IDataObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEmbedded: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreACP2,
                acpPos: i32,
                rguidService: ?*const Guid,
                riid: ?*const Guid,
                ppunk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreACP2,
                acpPos: i32,
                rguidService: ?*const Guid,
                riid: ?*const Guid,
                ppunk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryInsertEmbedded: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreACP2,
                pguidService: ?*const Guid,
                pFormatEtc: ?*const FORMATETC,
                pfInsertable: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreACP2,
                pguidService: ?*const Guid,
                pFormatEtc: ?*const FORMATETC,
                pfInsertable: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InsertEmbedded: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreACP2,
                dwFlags: u32,
                acpStart: i32,
                acpEnd: i32,
                pDataObject: ?*IDataObject,
                pChange: ?*TS_TEXTCHANGE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreACP2,
                dwFlags: u32,
                acpStart: i32,
                acpEnd: i32,
                pDataObject: ?*IDataObject,
                pChange: ?*TS_TEXTCHANGE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InsertTextAtSelection: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreACP2,
                dwFlags: u32,
                pchText: [*:0]const u16,
                cch: u32,
                pacpStart: ?*i32,
                pacpEnd: ?*i32,
                pChange: ?*TS_TEXTCHANGE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreACP2,
                dwFlags: u32,
                pchText: [*:0]const u16,
                cch: u32,
                pacpStart: ?*i32,
                pacpEnd: ?*i32,
                pChange: ?*TS_TEXTCHANGE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InsertEmbeddedAtSelection: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreACP2,
                dwFlags: u32,
                pDataObject: ?*IDataObject,
                pacpStart: ?*i32,
                pacpEnd: ?*i32,
                pChange: ?*TS_TEXTCHANGE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreACP2,
                dwFlags: u32,
                pDataObject: ?*IDataObject,
                pacpStart: ?*i32,
                pacpEnd: ?*i32,
                pChange: ?*TS_TEXTCHANGE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RequestSupportedAttrs: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreACP2,
                dwFlags: u32,
                cFilterAttrs: u32,
                paFilterAttrs: [*]const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreACP2,
                dwFlags: u32,
                cFilterAttrs: u32,
                paFilterAttrs: [*]const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RequestAttrsAtPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreACP2,
                acpPos: i32,
                cFilterAttrs: u32,
                paFilterAttrs: [*]const Guid,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreACP2,
                acpPos: i32,
                cFilterAttrs: u32,
                paFilterAttrs: [*]const Guid,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RequestAttrsTransitioningAtPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreACP2,
                acpPos: i32,
                cFilterAttrs: u32,
                paFilterAttrs: [*]const Guid,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreACP2,
                acpPos: i32,
                cFilterAttrs: u32,
                paFilterAttrs: [*]const Guid,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindNextAttrTransition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreACP2,
                acpStart: i32,
                acpHalt: i32,
                cFilterAttrs: u32,
                paFilterAttrs: [*]const Guid,
                dwFlags: u32,
                pacpNext: ?*i32,
                pfFound: ?*BOOL,
                plFoundOffset: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreACP2,
                acpStart: i32,
                acpHalt: i32,
                cFilterAttrs: u32,
                paFilterAttrs: [*]const Guid,
                dwFlags: u32,
                pacpNext: ?*i32,
                pfFound: ?*BOOL,
                plFoundOffset: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RetrieveRequestedAttrs: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreACP2,
                ulCount: u32,
                paAttrVals: [*]TS_ATTRVAL,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreACP2,
                ulCount: u32,
                paAttrVals: [*]TS_ATTRVAL,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEndACP: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreACP2,
                pacp: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreACP2,
                pacp: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetActiveView: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreACP2,
                pvcView: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreACP2,
                pvcView: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetACPFromPoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreACP2,
                vcView: u32,
                ptScreen: ?*const POINT,
                dwFlags: u32,
                pacp: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreACP2,
                vcView: u32,
                ptScreen: ?*const POINT,
                dwFlags: u32,
                pacp: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTextExt: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreACP2,
                vcView: u32,
                acpStart: i32,
                acpEnd: i32,
                prc: ?*RECT,
                pfClipped: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreACP2,
                vcView: u32,
                acpStart: i32,
                acpEnd: i32,
                prc: ?*RECT,
                pfClipped: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetScreenExt: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreACP2,
                vcView: u32,
                prc: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreACP2,
                vcView: u32,
                prc: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreACP2_AdviseSink(self: *const T, riid: ?*const Guid, punk: ?*IUnknown, dwMask: u32) HRESULT {
                return @as(*const ITextStoreACP2.VTable, @ptrCast(self.vtable)).AdviseSink(@as(*const ITextStoreACP2, @ptrCast(self)), riid, punk, dwMask);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreACP2_UnadviseSink(self: *const T, punk: ?*IUnknown) HRESULT {
                return @as(*const ITextStoreACP2.VTable, @ptrCast(self.vtable)).UnadviseSink(@as(*const ITextStoreACP2, @ptrCast(self)), punk);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreACP2_RequestLock(self: *const T, dwLockFlags: u32, phrSession: ?*HRESULT) HRESULT {
                return @as(*const ITextStoreACP2.VTable, @ptrCast(self.vtable)).RequestLock(@as(*const ITextStoreACP2, @ptrCast(self)), dwLockFlags, phrSession);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreACP2_GetStatus(self: *const T, pdcs: ?*TS_STATUS) HRESULT {
                return @as(*const ITextStoreACP2.VTable, @ptrCast(self.vtable)).GetStatus(@as(*const ITextStoreACP2, @ptrCast(self)), pdcs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreACP2_QueryInsert(self: *const T, acpTestStart: i32, acpTestEnd: i32, cch: u32, pacpResultStart: ?*i32, pacpResultEnd: ?*i32) HRESULT {
                return @as(*const ITextStoreACP2.VTable, @ptrCast(self.vtable)).QueryInsert(@as(*const ITextStoreACP2, @ptrCast(self)), acpTestStart, acpTestEnd, cch, pacpResultStart, pacpResultEnd);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreACP2_GetSelection(self: *const T, ulIndex: u32, ulCount: u32, pSelection: [*]TS_SELECTION_ACP, pcFetched: ?*u32) HRESULT {
                return @as(*const ITextStoreACP2.VTable, @ptrCast(self.vtable)).GetSelection(@as(*const ITextStoreACP2, @ptrCast(self)), ulIndex, ulCount, pSelection, pcFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreACP2_SetSelection(self: *const T, ulCount: u32, pSelection: [*]const TS_SELECTION_ACP) HRESULT {
                return @as(*const ITextStoreACP2.VTable, @ptrCast(self.vtable)).SetSelection(@as(*const ITextStoreACP2, @ptrCast(self)), ulCount, pSelection);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreACP2_GetText(self: *const T, acpStart: i32, acpEnd: i32, pchPlain: [*:0]u16, cchPlainReq: u32, pcchPlainRet: ?*u32, prgRunInfo: [*]TS_RUNINFO, cRunInfoReq: u32, pcRunInfoRet: ?*u32, pacpNext: ?*i32) HRESULT {
                return @as(*const ITextStoreACP2.VTable, @ptrCast(self.vtable)).GetText(@as(*const ITextStoreACP2, @ptrCast(self)), acpStart, acpEnd, pchPlain, cchPlainReq, pcchPlainRet, prgRunInfo, cRunInfoReq, pcRunInfoRet, pacpNext);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreACP2_SetText(self: *const T, dwFlags: u32, acpStart: i32, acpEnd: i32, pchText: [*:0]const u16, cch: u32, pChange: ?*TS_TEXTCHANGE) HRESULT {
                return @as(*const ITextStoreACP2.VTable, @ptrCast(self.vtable)).SetText(@as(*const ITextStoreACP2, @ptrCast(self)), dwFlags, acpStart, acpEnd, pchText, cch, pChange);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreACP2_GetFormattedText(self: *const T, acpStart: i32, acpEnd: i32, ppDataObject: ?*?*IDataObject) HRESULT {
                return @as(*const ITextStoreACP2.VTable, @ptrCast(self.vtable)).GetFormattedText(@as(*const ITextStoreACP2, @ptrCast(self)), acpStart, acpEnd, ppDataObject);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreACP2_GetEmbedded(self: *const T, acpPos: i32, rguidService: ?*const Guid, riid: ?*const Guid, ppunk: ?*?*IUnknown) HRESULT {
                return @as(*const ITextStoreACP2.VTable, @ptrCast(self.vtable)).GetEmbedded(@as(*const ITextStoreACP2, @ptrCast(self)), acpPos, rguidService, riid, ppunk);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreACP2_QueryInsertEmbedded(self: *const T, pguidService: ?*const Guid, pFormatEtc: ?*const FORMATETC, pfInsertable: ?*BOOL) HRESULT {
                return @as(*const ITextStoreACP2.VTable, @ptrCast(self.vtable)).QueryInsertEmbedded(@as(*const ITextStoreACP2, @ptrCast(self)), pguidService, pFormatEtc, pfInsertable);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreACP2_InsertEmbedded(self: *const T, dwFlags: u32, acpStart: i32, acpEnd: i32, pDataObject: ?*IDataObject, pChange: ?*TS_TEXTCHANGE) HRESULT {
                return @as(*const ITextStoreACP2.VTable, @ptrCast(self.vtable)).InsertEmbedded(@as(*const ITextStoreACP2, @ptrCast(self)), dwFlags, acpStart, acpEnd, pDataObject, pChange);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreACP2_InsertTextAtSelection(self: *const T, dwFlags: u32, pchText: [*:0]const u16, cch: u32, pacpStart: ?*i32, pacpEnd: ?*i32, pChange: ?*TS_TEXTCHANGE) HRESULT {
                return @as(*const ITextStoreACP2.VTable, @ptrCast(self.vtable)).InsertTextAtSelection(@as(*const ITextStoreACP2, @ptrCast(self)), dwFlags, pchText, cch, pacpStart, pacpEnd, pChange);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreACP2_InsertEmbeddedAtSelection(self: *const T, dwFlags: u32, pDataObject: ?*IDataObject, pacpStart: ?*i32, pacpEnd: ?*i32, pChange: ?*TS_TEXTCHANGE) HRESULT {
                return @as(*const ITextStoreACP2.VTable, @ptrCast(self.vtable)).InsertEmbeddedAtSelection(@as(*const ITextStoreACP2, @ptrCast(self)), dwFlags, pDataObject, pacpStart, pacpEnd, pChange);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreACP2_RequestSupportedAttrs(self: *const T, dwFlags: u32, cFilterAttrs: u32, paFilterAttrs: [*]const Guid) HRESULT {
                return @as(*const ITextStoreACP2.VTable, @ptrCast(self.vtable)).RequestSupportedAttrs(@as(*const ITextStoreACP2, @ptrCast(self)), dwFlags, cFilterAttrs, paFilterAttrs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreACP2_RequestAttrsAtPosition(self: *const T, acpPos: i32, cFilterAttrs: u32, paFilterAttrs: [*]const Guid, dwFlags: u32) HRESULT {
                return @as(*const ITextStoreACP2.VTable, @ptrCast(self.vtable)).RequestAttrsAtPosition(@as(*const ITextStoreACP2, @ptrCast(self)), acpPos, cFilterAttrs, paFilterAttrs, dwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreACP2_RequestAttrsTransitioningAtPosition(self: *const T, acpPos: i32, cFilterAttrs: u32, paFilterAttrs: [*]const Guid, dwFlags: u32) HRESULT {
                return @as(*const ITextStoreACP2.VTable, @ptrCast(self.vtable)).RequestAttrsTransitioningAtPosition(@as(*const ITextStoreACP2, @ptrCast(self)), acpPos, cFilterAttrs, paFilterAttrs, dwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreACP2_FindNextAttrTransition(self: *const T, acpStart: i32, acpHalt: i32, cFilterAttrs: u32, paFilterAttrs: [*]const Guid, dwFlags: u32, pacpNext: ?*i32, pfFound: ?*BOOL, plFoundOffset: ?*i32) HRESULT {
                return @as(*const ITextStoreACP2.VTable, @ptrCast(self.vtable)).FindNextAttrTransition(@as(*const ITextStoreACP2, @ptrCast(self)), acpStart, acpHalt, cFilterAttrs, paFilterAttrs, dwFlags, pacpNext, pfFound, plFoundOffset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreACP2_RetrieveRequestedAttrs(self: *const T, ulCount: u32, paAttrVals: [*]TS_ATTRVAL, pcFetched: ?*u32) HRESULT {
                return @as(*const ITextStoreACP2.VTable, @ptrCast(self.vtable)).RetrieveRequestedAttrs(@as(*const ITextStoreACP2, @ptrCast(self)), ulCount, paAttrVals, pcFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreACP2_GetEndACP(self: *const T, pacp: ?*i32) HRESULT {
                return @as(*const ITextStoreACP2.VTable, @ptrCast(self.vtable)).GetEndACP(@as(*const ITextStoreACP2, @ptrCast(self)), pacp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreACP2_GetActiveView(self: *const T, pvcView: ?*u32) HRESULT {
                return @as(*const ITextStoreACP2.VTable, @ptrCast(self.vtable)).GetActiveView(@as(*const ITextStoreACP2, @ptrCast(self)), pvcView);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreACP2_GetACPFromPoint(self: *const T, vcView: u32, ptScreen: ?*const POINT, dwFlags: u32, pacp: ?*i32) HRESULT {
                return @as(*const ITextStoreACP2.VTable, @ptrCast(self.vtable)).GetACPFromPoint(@as(*const ITextStoreACP2, @ptrCast(self)), vcView, ptScreen, dwFlags, pacp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreACP2_GetTextExt(self: *const T, vcView: u32, acpStart: i32, acpEnd: i32, prc: ?*RECT, pfClipped: ?*BOOL) HRESULT {
                return @as(*const ITextStoreACP2.VTable, @ptrCast(self.vtable)).GetTextExt(@as(*const ITextStoreACP2, @ptrCast(self)), vcView, acpStart, acpEnd, prc, pfClipped);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreACP2_GetScreenExt(self: *const T, vcView: u32, prc: ?*RECT) HRESULT {
                return @as(*const ITextStoreACP2.VTable, @ptrCast(self.vtable)).GetScreenExt(@as(*const ITextStoreACP2, @ptrCast(self)), vcView, prc);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITextStoreACPSink_Value = Guid.initString("22d44c94-a419-4542-a272-ae26093ececf");
pub const IID_ITextStoreACPSink = &IID_ITextStoreACPSink_Value;
pub const ITextStoreACPSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnTextChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreACPSink,
                dwFlags: TEXT_STORE_TEXT_CHANGE_FLAGS,
                pChange: ?*const TS_TEXTCHANGE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreACPSink,
                dwFlags: TEXT_STORE_TEXT_CHANGE_FLAGS,
                pChange: ?*const TS_TEXTCHANGE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnSelectionChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreACPSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreACPSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnLayoutChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreACPSink,
                lcode: TsLayoutCode,
                vcView: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreACPSink,
                lcode: TsLayoutCode,
                vcView: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnStatusChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreACPSink,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreACPSink,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnAttrsChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreACPSink,
                acpStart: i32,
                acpEnd: i32,
                cAttrs: u32,
                paAttrs: [*]const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreACPSink,
                acpStart: i32,
                acpEnd: i32,
                cAttrs: u32,
                paAttrs: [*]const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnLockGranted: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreACPSink,
                dwLockFlags: TEXT_STORE_LOCK_FLAGS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreACPSink,
                dwLockFlags: TEXT_STORE_LOCK_FLAGS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnStartEditTransaction: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreACPSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreACPSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnEndEditTransaction: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreACPSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreACPSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreACPSink_OnTextChange(self: *const T, dwFlags: TEXT_STORE_TEXT_CHANGE_FLAGS, pChange: ?*const TS_TEXTCHANGE) HRESULT {
                return @as(*const ITextStoreACPSink.VTable, @ptrCast(self.vtable)).OnTextChange(@as(*const ITextStoreACPSink, @ptrCast(self)), dwFlags, pChange);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreACPSink_OnSelectionChange(self: *const T) HRESULT {
                return @as(*const ITextStoreACPSink.VTable, @ptrCast(self.vtable)).OnSelectionChange(@as(*const ITextStoreACPSink, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreACPSink_OnLayoutChange(self: *const T, lcode: TsLayoutCode, vcView: u32) HRESULT {
                return @as(*const ITextStoreACPSink.VTable, @ptrCast(self.vtable)).OnLayoutChange(@as(*const ITextStoreACPSink, @ptrCast(self)), lcode, vcView);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreACPSink_OnStatusChange(self: *const T, dwFlags: u32) HRESULT {
                return @as(*const ITextStoreACPSink.VTable, @ptrCast(self.vtable)).OnStatusChange(@as(*const ITextStoreACPSink, @ptrCast(self)), dwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreACPSink_OnAttrsChange(self: *const T, acpStart: i32, acpEnd: i32, cAttrs: u32, paAttrs: [*]const Guid) HRESULT {
                return @as(*const ITextStoreACPSink.VTable, @ptrCast(self.vtable)).OnAttrsChange(@as(*const ITextStoreACPSink, @ptrCast(self)), acpStart, acpEnd, cAttrs, paAttrs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreACPSink_OnLockGranted(self: *const T, dwLockFlags: TEXT_STORE_LOCK_FLAGS) HRESULT {
                return @as(*const ITextStoreACPSink.VTable, @ptrCast(self.vtable)).OnLockGranted(@as(*const ITextStoreACPSink, @ptrCast(self)), dwLockFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreACPSink_OnStartEditTransaction(self: *const T) HRESULT {
                return @as(*const ITextStoreACPSink.VTable, @ptrCast(self.vtable)).OnStartEditTransaction(@as(*const ITextStoreACPSink, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreACPSink_OnEndEditTransaction(self: *const T) HRESULT {
                return @as(*const ITextStoreACPSink.VTable, @ptrCast(self.vtable)).OnEndEditTransaction(@as(*const ITextStoreACPSink, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const TsGravity = enum(i32) {
    BACKWARD = 0,
    FORWARD = 1,
};
pub const TS_GR_BACKWARD = TsGravity.BACKWARD;
pub const TS_GR_FORWARD = TsGravity.FORWARD;

pub const TsShiftDir = enum(i32) {
    BACKWARD = 0,
    FORWARD = 1,
};
pub const TS_SD_BACKWARD = TsShiftDir.BACKWARD;
pub const TS_SD_FORWARD = TsShiftDir.FORWARD;

// TODO: this type is limited to platform 'windows5.0'
const IID_IAnchor_Value = Guid.initString("0feb7e34-5a60-4356-8ef7-abdec2ff7cf8");
pub const IID_IAnchor = &IID_IAnchor_Value;
pub const IAnchor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetGravity: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAnchor,
                gravity: TsGravity,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAnchor,
                gravity: TsGravity,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetGravity: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAnchor,
                pgravity: ?*TsGravity,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAnchor,
                pgravity: ?*TsGravity,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsEqual: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAnchor,
                paWith: ?*IAnchor,
                pfEqual: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAnchor,
                paWith: ?*IAnchor,
                pfEqual: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Compare: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAnchor,
                paWith: ?*IAnchor,
                plResult: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAnchor,
                paWith: ?*IAnchor,
                plResult: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Shift: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAnchor,
                dwFlags: u32,
                cchReq: i32,
                pcch: ?*i32,
                paHaltAnchor: ?*IAnchor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAnchor,
                dwFlags: u32,
                cchReq: i32,
                pcch: ?*i32,
                paHaltAnchor: ?*IAnchor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ShiftTo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAnchor,
                paSite: ?*IAnchor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAnchor,
                paSite: ?*IAnchor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ShiftRegion: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAnchor,
                dwFlags: u32,
                dir: TsShiftDir,
                pfNoRegion: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAnchor,
                dwFlags: u32,
                dir: TsShiftDir,
                pfNoRegion: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetChangeHistoryMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAnchor,
                dwMask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAnchor,
                dwMask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetChangeHistory: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAnchor,
                pdwHistory: ?*ANCHOR_CHANGE_HISTORY_FLAGS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAnchor,
                pdwHistory: ?*ANCHOR_CHANGE_HISTORY_FLAGS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ClearChangeHistory: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAnchor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAnchor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAnchor,
                ppaClone: ?*?*IAnchor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAnchor,
                ppaClone: ?*?*IAnchor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAnchor_SetGravity(self: *const T, gravity: TsGravity) HRESULT {
                return @as(*const IAnchor.VTable, @ptrCast(self.vtable)).SetGravity(@as(*const IAnchor, @ptrCast(self)), gravity);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAnchor_GetGravity(self: *const T, pgravity: ?*TsGravity) HRESULT {
                return @as(*const IAnchor.VTable, @ptrCast(self.vtable)).GetGravity(@as(*const IAnchor, @ptrCast(self)), pgravity);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAnchor_IsEqual(self: *const T, paWith: ?*IAnchor, pfEqual: ?*BOOL) HRESULT {
                return @as(*const IAnchor.VTable, @ptrCast(self.vtable)).IsEqual(@as(*const IAnchor, @ptrCast(self)), paWith, pfEqual);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAnchor_Compare(self: *const T, paWith: ?*IAnchor, plResult: ?*i32) HRESULT {
                return @as(*const IAnchor.VTable, @ptrCast(self.vtable)).Compare(@as(*const IAnchor, @ptrCast(self)), paWith, plResult);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAnchor_Shift(self: *const T, dwFlags: u32, cchReq: i32, pcch: ?*i32, paHaltAnchor: ?*IAnchor) HRESULT {
                return @as(*const IAnchor.VTable, @ptrCast(self.vtable)).Shift(@as(*const IAnchor, @ptrCast(self)), dwFlags, cchReq, pcch, paHaltAnchor);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAnchor_ShiftTo(self: *const T, paSite: ?*IAnchor) HRESULT {
                return @as(*const IAnchor.VTable, @ptrCast(self.vtable)).ShiftTo(@as(*const IAnchor, @ptrCast(self)), paSite);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAnchor_ShiftRegion(self: *const T, dwFlags: u32, dir: TsShiftDir, pfNoRegion: ?*BOOL) HRESULT {
                return @as(*const IAnchor.VTable, @ptrCast(self.vtable)).ShiftRegion(@as(*const IAnchor, @ptrCast(self)), dwFlags, dir, pfNoRegion);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAnchor_SetChangeHistoryMask(self: *const T, dwMask: u32) HRESULT {
                return @as(*const IAnchor.VTable, @ptrCast(self.vtable)).SetChangeHistoryMask(@as(*const IAnchor, @ptrCast(self)), dwMask);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAnchor_GetChangeHistory(self: *const T, pdwHistory: ?*ANCHOR_CHANGE_HISTORY_FLAGS) HRESULT {
                return @as(*const IAnchor.VTable, @ptrCast(self.vtable)).GetChangeHistory(@as(*const IAnchor, @ptrCast(self)), pdwHistory);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAnchor_ClearChangeHistory(self: *const T) HRESULT {
                return @as(*const IAnchor.VTable, @ptrCast(self.vtable)).ClearChangeHistory(@as(*const IAnchor, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAnchor_Clone(self: *const T, ppaClone: ?*?*IAnchor) HRESULT {
                return @as(*const IAnchor.VTable, @ptrCast(self.vtable)).Clone(@as(*const IAnchor, @ptrCast(self)), ppaClone);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITextStoreAnchor_Value = Guid.initString("9b2077b0-5f18-4dec-bee9-3cc722f5dfe0");
pub const IID_ITextStoreAnchor = &IID_ITextStoreAnchor_Value;
pub const ITextStoreAnchor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AdviseSink: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreAnchor,
                riid: ?*const Guid,
                punk: ?*IUnknown,
                dwMask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreAnchor,
                riid: ?*const Guid,
                punk: ?*IUnknown,
                dwMask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnadviseSink: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreAnchor,
                punk: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreAnchor,
                punk: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RequestLock: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreAnchor,
                dwLockFlags: u32,
                phrSession: ?*HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreAnchor,
                dwLockFlags: u32,
                phrSession: ?*HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreAnchor,
                pdcs: ?*TS_STATUS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreAnchor,
                pdcs: ?*TS_STATUS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryInsert: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreAnchor,
                paTestStart: ?*IAnchor,
                paTestEnd: ?*IAnchor,
                cch: u32,
                ppaResultStart: ?*?*IAnchor,
                ppaResultEnd: ?*?*IAnchor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreAnchor,
                paTestStart: ?*IAnchor,
                paTestEnd: ?*IAnchor,
                cch: u32,
                ppaResultStart: ?*?*IAnchor,
                ppaResultEnd: ?*?*IAnchor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSelection: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreAnchor,
                ulIndex: u32,
                ulCount: u32,
                pSelection: [*]TS_SELECTION_ANCHOR,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreAnchor,
                ulIndex: u32,
                ulCount: u32,
                pSelection: [*]TS_SELECTION_ANCHOR,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSelection: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreAnchor,
                ulCount: u32,
                pSelection: [*]const TS_SELECTION_ANCHOR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreAnchor,
                ulCount: u32,
                pSelection: [*]const TS_SELECTION_ANCHOR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreAnchor,
                dwFlags: u32,
                paStart: ?*IAnchor,
                paEnd: ?*IAnchor,
                pchText: [*:0]u16,
                cchReq: u32,
                pcch: ?*u32,
                fUpdateAnchor: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreAnchor,
                dwFlags: u32,
                paStart: ?*IAnchor,
                paEnd: ?*IAnchor,
                pchText: [*:0]u16,
                cchReq: u32,
                pcch: ?*u32,
                fUpdateAnchor: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreAnchor,
                dwFlags: u32,
                paStart: ?*IAnchor,
                paEnd: ?*IAnchor,
                pchText: [*:0]const u16,
                cch: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreAnchor,
                dwFlags: u32,
                paStart: ?*IAnchor,
                paEnd: ?*IAnchor,
                pchText: [*:0]const u16,
                cch: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFormattedText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreAnchor,
                paStart: ?*IAnchor,
                paEnd: ?*IAnchor,
                ppDataObject: ?*?*IDataObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreAnchor,
                paStart: ?*IAnchor,
                paEnd: ?*IAnchor,
                ppDataObject: ?*?*IDataObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEmbedded: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreAnchor,
                dwFlags: u32,
                paPos: ?*IAnchor,
                rguidService: ?*const Guid,
                riid: ?*const Guid,
                ppunk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreAnchor,
                dwFlags: u32,
                paPos: ?*IAnchor,
                rguidService: ?*const Guid,
                riid: ?*const Guid,
                ppunk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InsertEmbedded: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreAnchor,
                dwFlags: u32,
                paStart: ?*IAnchor,
                paEnd: ?*IAnchor,
                pDataObject: ?*IDataObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreAnchor,
                dwFlags: u32,
                paStart: ?*IAnchor,
                paEnd: ?*IAnchor,
                pDataObject: ?*IDataObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RequestSupportedAttrs: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreAnchor,
                dwFlags: u32,
                cFilterAttrs: u32,
                paFilterAttrs: [*]const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreAnchor,
                dwFlags: u32,
                cFilterAttrs: u32,
                paFilterAttrs: [*]const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RequestAttrsAtPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreAnchor,
                paPos: ?*IAnchor,
                cFilterAttrs: u32,
                paFilterAttrs: [*]const Guid,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreAnchor,
                paPos: ?*IAnchor,
                cFilterAttrs: u32,
                paFilterAttrs: [*]const Guid,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RequestAttrsTransitioningAtPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreAnchor,
                paPos: ?*IAnchor,
                cFilterAttrs: u32,
                paFilterAttrs: [*]const Guid,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreAnchor,
                paPos: ?*IAnchor,
                cFilterAttrs: u32,
                paFilterAttrs: [*]const Guid,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindNextAttrTransition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreAnchor,
                paStart: ?*IAnchor,
                paHalt: ?*IAnchor,
                cFilterAttrs: u32,
                paFilterAttrs: [*]const Guid,
                dwFlags: u32,
                pfFound: ?*BOOL,
                plFoundOffset: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreAnchor,
                paStart: ?*IAnchor,
                paHalt: ?*IAnchor,
                cFilterAttrs: u32,
                paFilterAttrs: [*]const Guid,
                dwFlags: u32,
                pfFound: ?*BOOL,
                plFoundOffset: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RetrieveRequestedAttrs: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreAnchor,
                ulCount: u32,
                paAttrVals: [*]TS_ATTRVAL,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreAnchor,
                ulCount: u32,
                paAttrVals: [*]TS_ATTRVAL,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStart: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreAnchor,
                ppaStart: ?*?*IAnchor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreAnchor,
                ppaStart: ?*?*IAnchor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEnd: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreAnchor,
                ppaEnd: ?*?*IAnchor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreAnchor,
                ppaEnd: ?*?*IAnchor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetActiveView: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreAnchor,
                pvcView: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreAnchor,
                pvcView: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAnchorFromPoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreAnchor,
                vcView: u32,
                ptScreen: ?*const POINT,
                dwFlags: u32,
                ppaSite: ?*?*IAnchor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreAnchor,
                vcView: u32,
                ptScreen: ?*const POINT,
                dwFlags: u32,
                ppaSite: ?*?*IAnchor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTextExt: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreAnchor,
                vcView: u32,
                paStart: ?*IAnchor,
                paEnd: ?*IAnchor,
                prc: ?*RECT,
                pfClipped: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreAnchor,
                vcView: u32,
                paStart: ?*IAnchor,
                paEnd: ?*IAnchor,
                prc: ?*RECT,
                pfClipped: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetScreenExt: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreAnchor,
                vcView: u32,
                prc: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreAnchor,
                vcView: u32,
                prc: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetWnd: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreAnchor,
                vcView: u32,
                phwnd: ?*?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreAnchor,
                vcView: u32,
                phwnd: ?*?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryInsertEmbedded: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreAnchor,
                pguidService: ?*const Guid,
                pFormatEtc: ?*const FORMATETC,
                pfInsertable: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreAnchor,
                pguidService: ?*const Guid,
                pFormatEtc: ?*const FORMATETC,
                pfInsertable: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InsertTextAtSelection: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreAnchor,
                dwFlags: u32,
                pchText: [*:0]const u16,
                cch: u32,
                ppaStart: ?*?*IAnchor,
                ppaEnd: ?*?*IAnchor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreAnchor,
                dwFlags: u32,
                pchText: [*:0]const u16,
                cch: u32,
                ppaStart: ?*?*IAnchor,
                ppaEnd: ?*?*IAnchor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InsertEmbeddedAtSelection: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreAnchor,
                dwFlags: u32,
                pDataObject: ?*IDataObject,
                ppaStart: ?*?*IAnchor,
                ppaEnd: ?*?*IAnchor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreAnchor,
                dwFlags: u32,
                pDataObject: ?*IDataObject,
                ppaStart: ?*?*IAnchor,
                ppaEnd: ?*?*IAnchor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreAnchor_AdviseSink(self: *const T, riid: ?*const Guid, punk: ?*IUnknown, dwMask: u32) HRESULT {
                return @as(*const ITextStoreAnchor.VTable, @ptrCast(self.vtable)).AdviseSink(@as(*const ITextStoreAnchor, @ptrCast(self)), riid, punk, dwMask);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreAnchor_UnadviseSink(self: *const T, punk: ?*IUnknown) HRESULT {
                return @as(*const ITextStoreAnchor.VTable, @ptrCast(self.vtable)).UnadviseSink(@as(*const ITextStoreAnchor, @ptrCast(self)), punk);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreAnchor_RequestLock(self: *const T, dwLockFlags: u32, phrSession: ?*HRESULT) HRESULT {
                return @as(*const ITextStoreAnchor.VTable, @ptrCast(self.vtable)).RequestLock(@as(*const ITextStoreAnchor, @ptrCast(self)), dwLockFlags, phrSession);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreAnchor_GetStatus(self: *const T, pdcs: ?*TS_STATUS) HRESULT {
                return @as(*const ITextStoreAnchor.VTable, @ptrCast(self.vtable)).GetStatus(@as(*const ITextStoreAnchor, @ptrCast(self)), pdcs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreAnchor_QueryInsert(self: *const T, paTestStart: ?*IAnchor, paTestEnd: ?*IAnchor, cch: u32, ppaResultStart: ?*?*IAnchor, ppaResultEnd: ?*?*IAnchor) HRESULT {
                return @as(*const ITextStoreAnchor.VTable, @ptrCast(self.vtable)).QueryInsert(@as(*const ITextStoreAnchor, @ptrCast(self)), paTestStart, paTestEnd, cch, ppaResultStart, ppaResultEnd);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreAnchor_GetSelection(self: *const T, ulIndex: u32, ulCount: u32, pSelection: [*]TS_SELECTION_ANCHOR, pcFetched: ?*u32) HRESULT {
                return @as(*const ITextStoreAnchor.VTable, @ptrCast(self.vtable)).GetSelection(@as(*const ITextStoreAnchor, @ptrCast(self)), ulIndex, ulCount, pSelection, pcFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreAnchor_SetSelection(self: *const T, ulCount: u32, pSelection: [*]const TS_SELECTION_ANCHOR) HRESULT {
                return @as(*const ITextStoreAnchor.VTable, @ptrCast(self.vtable)).SetSelection(@as(*const ITextStoreAnchor, @ptrCast(self)), ulCount, pSelection);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreAnchor_GetText(self: *const T, dwFlags: u32, paStart: ?*IAnchor, paEnd: ?*IAnchor, pchText: [*:0]u16, cchReq: u32, pcch: ?*u32, fUpdateAnchor: BOOL) HRESULT {
                return @as(*const ITextStoreAnchor.VTable, @ptrCast(self.vtable)).GetText(@as(*const ITextStoreAnchor, @ptrCast(self)), dwFlags, paStart, paEnd, pchText, cchReq, pcch, fUpdateAnchor);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreAnchor_SetText(self: *const T, dwFlags: u32, paStart: ?*IAnchor, paEnd: ?*IAnchor, pchText: [*:0]const u16, cch: u32) HRESULT {
                return @as(*const ITextStoreAnchor.VTable, @ptrCast(self.vtable)).SetText(@as(*const ITextStoreAnchor, @ptrCast(self)), dwFlags, paStart, paEnd, pchText, cch);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreAnchor_GetFormattedText(self: *const T, paStart: ?*IAnchor, paEnd: ?*IAnchor, ppDataObject: ?*?*IDataObject) HRESULT {
                return @as(*const ITextStoreAnchor.VTable, @ptrCast(self.vtable)).GetFormattedText(@as(*const ITextStoreAnchor, @ptrCast(self)), paStart, paEnd, ppDataObject);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreAnchor_GetEmbedded(self: *const T, dwFlags: u32, paPos: ?*IAnchor, rguidService: ?*const Guid, riid: ?*const Guid, ppunk: ?*?*IUnknown) HRESULT {
                return @as(*const ITextStoreAnchor.VTable, @ptrCast(self.vtable)).GetEmbedded(@as(*const ITextStoreAnchor, @ptrCast(self)), dwFlags, paPos, rguidService, riid, ppunk);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreAnchor_InsertEmbedded(self: *const T, dwFlags: u32, paStart: ?*IAnchor, paEnd: ?*IAnchor, pDataObject: ?*IDataObject) HRESULT {
                return @as(*const ITextStoreAnchor.VTable, @ptrCast(self.vtable)).InsertEmbedded(@as(*const ITextStoreAnchor, @ptrCast(self)), dwFlags, paStart, paEnd, pDataObject);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreAnchor_RequestSupportedAttrs(self: *const T, dwFlags: u32, cFilterAttrs: u32, paFilterAttrs: [*]const Guid) HRESULT {
                return @as(*const ITextStoreAnchor.VTable, @ptrCast(self.vtable)).RequestSupportedAttrs(@as(*const ITextStoreAnchor, @ptrCast(self)), dwFlags, cFilterAttrs, paFilterAttrs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreAnchor_RequestAttrsAtPosition(self: *const T, paPos: ?*IAnchor, cFilterAttrs: u32, paFilterAttrs: [*]const Guid, dwFlags: u32) HRESULT {
                return @as(*const ITextStoreAnchor.VTable, @ptrCast(self.vtable)).RequestAttrsAtPosition(@as(*const ITextStoreAnchor, @ptrCast(self)), paPos, cFilterAttrs, paFilterAttrs, dwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreAnchor_RequestAttrsTransitioningAtPosition(self: *const T, paPos: ?*IAnchor, cFilterAttrs: u32, paFilterAttrs: [*]const Guid, dwFlags: u32) HRESULT {
                return @as(*const ITextStoreAnchor.VTable, @ptrCast(self.vtable)).RequestAttrsTransitioningAtPosition(@as(*const ITextStoreAnchor, @ptrCast(self)), paPos, cFilterAttrs, paFilterAttrs, dwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreAnchor_FindNextAttrTransition(self: *const T, paStart: ?*IAnchor, paHalt: ?*IAnchor, cFilterAttrs: u32, paFilterAttrs: [*]const Guid, dwFlags: u32, pfFound: ?*BOOL, plFoundOffset: ?*i32) HRESULT {
                return @as(*const ITextStoreAnchor.VTable, @ptrCast(self.vtable)).FindNextAttrTransition(@as(*const ITextStoreAnchor, @ptrCast(self)), paStart, paHalt, cFilterAttrs, paFilterAttrs, dwFlags, pfFound, plFoundOffset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreAnchor_RetrieveRequestedAttrs(self: *const T, ulCount: u32, paAttrVals: [*]TS_ATTRVAL, pcFetched: ?*u32) HRESULT {
                return @as(*const ITextStoreAnchor.VTable, @ptrCast(self.vtable)).RetrieveRequestedAttrs(@as(*const ITextStoreAnchor, @ptrCast(self)), ulCount, paAttrVals, pcFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreAnchor_GetStart(self: *const T, ppaStart: ?*?*IAnchor) HRESULT {
                return @as(*const ITextStoreAnchor.VTable, @ptrCast(self.vtable)).GetStart(@as(*const ITextStoreAnchor, @ptrCast(self)), ppaStart);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreAnchor_GetEnd(self: *const T, ppaEnd: ?*?*IAnchor) HRESULT {
                return @as(*const ITextStoreAnchor.VTable, @ptrCast(self.vtable)).GetEnd(@as(*const ITextStoreAnchor, @ptrCast(self)), ppaEnd);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreAnchor_GetActiveView(self: *const T, pvcView: ?*u32) HRESULT {
                return @as(*const ITextStoreAnchor.VTable, @ptrCast(self.vtable)).GetActiveView(@as(*const ITextStoreAnchor, @ptrCast(self)), pvcView);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreAnchor_GetAnchorFromPoint(self: *const T, vcView: u32, ptScreen: ?*const POINT, dwFlags: u32, ppaSite: ?*?*IAnchor) HRESULT {
                return @as(*const ITextStoreAnchor.VTable, @ptrCast(self.vtable)).GetAnchorFromPoint(@as(*const ITextStoreAnchor, @ptrCast(self)), vcView, ptScreen, dwFlags, ppaSite);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreAnchor_GetTextExt(self: *const T, vcView: u32, paStart: ?*IAnchor, paEnd: ?*IAnchor, prc: ?*RECT, pfClipped: ?*BOOL) HRESULT {
                return @as(*const ITextStoreAnchor.VTable, @ptrCast(self.vtable)).GetTextExt(@as(*const ITextStoreAnchor, @ptrCast(self)), vcView, paStart, paEnd, prc, pfClipped);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreAnchor_GetScreenExt(self: *const T, vcView: u32, prc: ?*RECT) HRESULT {
                return @as(*const ITextStoreAnchor.VTable, @ptrCast(self.vtable)).GetScreenExt(@as(*const ITextStoreAnchor, @ptrCast(self)), vcView, prc);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreAnchor_GetWnd(self: *const T, vcView: u32, phwnd: ?*?HWND) HRESULT {
                return @as(*const ITextStoreAnchor.VTable, @ptrCast(self.vtable)).GetWnd(@as(*const ITextStoreAnchor, @ptrCast(self)), vcView, phwnd);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreAnchor_QueryInsertEmbedded(self: *const T, pguidService: ?*const Guid, pFormatEtc: ?*const FORMATETC, pfInsertable: ?*BOOL) HRESULT {
                return @as(*const ITextStoreAnchor.VTable, @ptrCast(self.vtable)).QueryInsertEmbedded(@as(*const ITextStoreAnchor, @ptrCast(self)), pguidService, pFormatEtc, pfInsertable);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreAnchor_InsertTextAtSelection(self: *const T, dwFlags: u32, pchText: [*:0]const u16, cch: u32, ppaStart: ?*?*IAnchor, ppaEnd: ?*?*IAnchor) HRESULT {
                return @as(*const ITextStoreAnchor.VTable, @ptrCast(self.vtable)).InsertTextAtSelection(@as(*const ITextStoreAnchor, @ptrCast(self)), dwFlags, pchText, cch, ppaStart, ppaEnd);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreAnchor_InsertEmbeddedAtSelection(self: *const T, dwFlags: u32, pDataObject: ?*IDataObject, ppaStart: ?*?*IAnchor, ppaEnd: ?*?*IAnchor) HRESULT {
                return @as(*const ITextStoreAnchor.VTable, @ptrCast(self.vtable)).InsertEmbeddedAtSelection(@as(*const ITextStoreAnchor, @ptrCast(self)), dwFlags, pDataObject, ppaStart, ppaEnd);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITextStoreAnchorSink_Value = Guid.initString("aa80e905-2021-11d2-93e0-0060b067b86e");
pub const IID_ITextStoreAnchorSink = &IID_ITextStoreAnchorSink_Value;
pub const ITextStoreAnchorSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnTextChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreAnchorSink,
                dwFlags: TEXT_STORE_CHANGE_FLAGS,
                paStart: ?*IAnchor,
                paEnd: ?*IAnchor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreAnchorSink,
                dwFlags: TEXT_STORE_CHANGE_FLAGS,
                paStart: ?*IAnchor,
                paEnd: ?*IAnchor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnSelectionChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreAnchorSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreAnchorSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnLayoutChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreAnchorSink,
                lcode: TsLayoutCode,
                vcView: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreAnchorSink,
                lcode: TsLayoutCode,
                vcView: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnStatusChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreAnchorSink,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreAnchorSink,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnAttrsChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreAnchorSink,
                paStart: ?*IAnchor,
                paEnd: ?*IAnchor,
                cAttrs: u32,
                paAttrs: [*]const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreAnchorSink,
                paStart: ?*IAnchor,
                paEnd: ?*IAnchor,
                cAttrs: u32,
                paAttrs: [*]const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnLockGranted: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreAnchorSink,
                dwLockFlags: TEXT_STORE_LOCK_FLAGS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreAnchorSink,
                dwLockFlags: TEXT_STORE_LOCK_FLAGS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnStartEditTransaction: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreAnchorSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreAnchorSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnEndEditTransaction: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreAnchorSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreAnchorSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreAnchorSink_OnTextChange(self: *const T, dwFlags: TEXT_STORE_CHANGE_FLAGS, paStart: ?*IAnchor, paEnd: ?*IAnchor) HRESULT {
                return @as(*const ITextStoreAnchorSink.VTable, @ptrCast(self.vtable)).OnTextChange(@as(*const ITextStoreAnchorSink, @ptrCast(self)), dwFlags, paStart, paEnd);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreAnchorSink_OnSelectionChange(self: *const T) HRESULT {
                return @as(*const ITextStoreAnchorSink.VTable, @ptrCast(self.vtable)).OnSelectionChange(@as(*const ITextStoreAnchorSink, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreAnchorSink_OnLayoutChange(self: *const T, lcode: TsLayoutCode, vcView: u32) HRESULT {
                return @as(*const ITextStoreAnchorSink.VTable, @ptrCast(self.vtable)).OnLayoutChange(@as(*const ITextStoreAnchorSink, @ptrCast(self)), lcode, vcView);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreAnchorSink_OnStatusChange(self: *const T, dwFlags: u32) HRESULT {
                return @as(*const ITextStoreAnchorSink.VTable, @ptrCast(self.vtable)).OnStatusChange(@as(*const ITextStoreAnchorSink, @ptrCast(self)), dwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreAnchorSink_OnAttrsChange(self: *const T, paStart: ?*IAnchor, paEnd: ?*IAnchor, cAttrs: u32, paAttrs: [*]const Guid) HRESULT {
                return @as(*const ITextStoreAnchorSink.VTable, @ptrCast(self.vtable)).OnAttrsChange(@as(*const ITextStoreAnchorSink, @ptrCast(self)), paStart, paEnd, cAttrs, paAttrs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreAnchorSink_OnLockGranted(self: *const T, dwLockFlags: TEXT_STORE_LOCK_FLAGS) HRESULT {
                return @as(*const ITextStoreAnchorSink.VTable, @ptrCast(self.vtable)).OnLockGranted(@as(*const ITextStoreAnchorSink, @ptrCast(self)), dwLockFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreAnchorSink_OnStartEditTransaction(self: *const T) HRESULT {
                return @as(*const ITextStoreAnchorSink.VTable, @ptrCast(self.vtable)).OnStartEditTransaction(@as(*const ITextStoreAnchorSink, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreAnchorSink_OnEndEditTransaction(self: *const T) HRESULT {
                return @as(*const ITextStoreAnchorSink.VTable, @ptrCast(self.vtable)).OnEndEditTransaction(@as(*const ITextStoreAnchorSink, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfLangBarMgr_Value = Guid.initString("87955690-e627-11d2-8ddb-00105a2799b5");
pub const IID_ITfLangBarMgr = &IID_ITfLangBarMgr_Value;
pub const ITfLangBarMgr = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AdviseEventSink: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfLangBarMgr,
                pSink: ?*ITfLangBarEventSink,
                hwnd: ?HWND,
                dwFlags: u32,
                pdwCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfLangBarMgr,
                pSink: ?*ITfLangBarEventSink,
                hwnd: ?HWND,
                dwFlags: u32,
                pdwCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnadviseEventSink: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfLangBarMgr,
                dwCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfLangBarMgr,
                dwCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetThreadMarshalInterface: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfLangBarMgr,
                dwThreadId: u32,
                dwType: u32,
                riid: ?*const Guid,
                ppunk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfLangBarMgr,
                dwThreadId: u32,
                dwType: u32,
                riid: ?*const Guid,
                ppunk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetThreadLangBarItemMgr: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfLangBarMgr,
                dwThreadId: u32,
                pplbi: ?*?*ITfLangBarItemMgr,
                pdwThreadid: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfLangBarMgr,
                dwThreadId: u32,
                pplbi: ?*?*ITfLangBarItemMgr,
                pdwThreadid: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInputProcessorProfiles: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfLangBarMgr,
                dwThreadId: u32,
                ppaip: ?*?*ITfInputProcessorProfiles,
                pdwThreadid: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfLangBarMgr,
                dwThreadId: u32,
                ppaip: ?*?*ITfInputProcessorProfiles,
                pdwThreadid: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RestoreLastFocus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfLangBarMgr,
                pdwThreadId: ?*u32,
                fPrev: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfLangBarMgr,
                pdwThreadId: ?*u32,
                fPrev: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetModalInput: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfLangBarMgr,
                pSink: ?*ITfLangBarEventSink,
                dwThreadId: u32,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfLangBarMgr,
                pSink: ?*ITfLangBarEventSink,
                dwThreadId: u32,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ShowFloating: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfLangBarMgr,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfLangBarMgr,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetShowFloatingStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfLangBarMgr,
                pdwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfLangBarMgr,
                pdwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfLangBarMgr_AdviseEventSink(self: *const T, pSink: ?*ITfLangBarEventSink, hwnd: ?HWND, dwFlags: u32, pdwCookie: ?*u32) HRESULT {
                return @as(*const ITfLangBarMgr.VTable, @ptrCast(self.vtable)).AdviseEventSink(@as(*const ITfLangBarMgr, @ptrCast(self)), pSink, hwnd, dwFlags, pdwCookie);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfLangBarMgr_UnadviseEventSink(self: *const T, dwCookie: u32) HRESULT {
                return @as(*const ITfLangBarMgr.VTable, @ptrCast(self.vtable)).UnadviseEventSink(@as(*const ITfLangBarMgr, @ptrCast(self)), dwCookie);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfLangBarMgr_GetThreadMarshalInterface(self: *const T, dwThreadId: u32, dwType: u32, riid: ?*const Guid, ppunk: ?*?*IUnknown) HRESULT {
                return @as(*const ITfLangBarMgr.VTable, @ptrCast(self.vtable)).GetThreadMarshalInterface(@as(*const ITfLangBarMgr, @ptrCast(self)), dwThreadId, dwType, riid, ppunk);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfLangBarMgr_GetThreadLangBarItemMgr(self: *const T, dwThreadId: u32, pplbi: ?*?*ITfLangBarItemMgr, pdwThreadid: ?*u32) HRESULT {
                return @as(*const ITfLangBarMgr.VTable, @ptrCast(self.vtable)).GetThreadLangBarItemMgr(@as(*const ITfLangBarMgr, @ptrCast(self)), dwThreadId, pplbi, pdwThreadid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfLangBarMgr_GetInputProcessorProfiles(self: *const T, dwThreadId: u32, ppaip: ?*?*ITfInputProcessorProfiles, pdwThreadid: ?*u32) HRESULT {
                return @as(*const ITfLangBarMgr.VTable, @ptrCast(self.vtable)).GetInputProcessorProfiles(@as(*const ITfLangBarMgr, @ptrCast(self)), dwThreadId, ppaip, pdwThreadid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfLangBarMgr_RestoreLastFocus(self: *const T, pdwThreadId: ?*u32, fPrev: BOOL) HRESULT {
                return @as(*const ITfLangBarMgr.VTable, @ptrCast(self.vtable)).RestoreLastFocus(@as(*const ITfLangBarMgr, @ptrCast(self)), pdwThreadId, fPrev);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfLangBarMgr_SetModalInput(self: *const T, pSink: ?*ITfLangBarEventSink, dwThreadId: u32, dwFlags: u32) HRESULT {
                return @as(*const ITfLangBarMgr.VTable, @ptrCast(self.vtable)).SetModalInput(@as(*const ITfLangBarMgr, @ptrCast(self)), pSink, dwThreadId, dwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfLangBarMgr_ShowFloating(self: *const T, dwFlags: u32) HRESULT {
                return @as(*const ITfLangBarMgr.VTable, @ptrCast(self.vtable)).ShowFloating(@as(*const ITfLangBarMgr, @ptrCast(self)), dwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfLangBarMgr_GetShowFloatingStatus(self: *const T, pdwFlags: ?*u32) HRESULT {
                return @as(*const ITfLangBarMgr.VTable, @ptrCast(self.vtable)).GetShowFloatingStatus(@as(*const ITfLangBarMgr, @ptrCast(self)), pdwFlags);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfLangBarEventSink_Value = Guid.initString("18a4e900-e0ae-11d2-afdd-00105a2799b5");
pub const IID_ITfLangBarEventSink = &IID_ITfLangBarEventSink_Value;
pub const ITfLangBarEventSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnSetFocus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfLangBarEventSink,
                dwThreadId: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfLangBarEventSink,
                dwThreadId: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnThreadTerminate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfLangBarEventSink,
                dwThreadId: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfLangBarEventSink,
                dwThreadId: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnThreadItemChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfLangBarEventSink,
                dwThreadId: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfLangBarEventSink,
                dwThreadId: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnModalInput: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfLangBarEventSink,
                dwThreadId: u32,
                uMsg: u32,
                wParam: WPARAM,
                lParam: LPARAM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfLangBarEventSink,
                dwThreadId: u32,
                uMsg: u32,
                wParam: WPARAM,
                lParam: LPARAM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ShowFloating: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfLangBarEventSink,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfLangBarEventSink,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetItemFloatingRect: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfLangBarEventSink,
                dwThreadId: u32,
                rguid: ?*const Guid,
                prc: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfLangBarEventSink,
                dwThreadId: u32,
                rguid: ?*const Guid,
                prc: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfLangBarEventSink_OnSetFocus(self: *const T, dwThreadId: u32) HRESULT {
                return @as(*const ITfLangBarEventSink.VTable, @ptrCast(self.vtable)).OnSetFocus(@as(*const ITfLangBarEventSink, @ptrCast(self)), dwThreadId);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfLangBarEventSink_OnThreadTerminate(self: *const T, dwThreadId: u32) HRESULT {
                return @as(*const ITfLangBarEventSink.VTable, @ptrCast(self.vtable)).OnThreadTerminate(@as(*const ITfLangBarEventSink, @ptrCast(self)), dwThreadId);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfLangBarEventSink_OnThreadItemChange(self: *const T, dwThreadId: u32) HRESULT {
                return @as(*const ITfLangBarEventSink.VTable, @ptrCast(self.vtable)).OnThreadItemChange(@as(*const ITfLangBarEventSink, @ptrCast(self)), dwThreadId);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfLangBarEventSink_OnModalInput(self: *const T, dwThreadId: u32, uMsg: u32, wParam: WPARAM, lParam: LPARAM) HRESULT {
                return @as(*const ITfLangBarEventSink.VTable, @ptrCast(self.vtable)).OnModalInput(@as(*const ITfLangBarEventSink, @ptrCast(self)), dwThreadId, uMsg, wParam, lParam);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfLangBarEventSink_ShowFloating(self: *const T, dwFlags: u32) HRESULT {
                return @as(*const ITfLangBarEventSink.VTable, @ptrCast(self.vtable)).ShowFloating(@as(*const ITfLangBarEventSink, @ptrCast(self)), dwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfLangBarEventSink_GetItemFloatingRect(self: *const T, dwThreadId: u32, rguid: ?*const Guid, prc: ?*RECT) HRESULT {
                return @as(*const ITfLangBarEventSink.VTable, @ptrCast(self.vtable)).GetItemFloatingRect(@as(*const ITfLangBarEventSink, @ptrCast(self)), dwThreadId, rguid, prc);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfLangBarItemSink_Value = Guid.initString("57dbe1a0-de25-11d2-afdd-00105a2799b5");
pub const IID_ITfLangBarItemSink = &IID_ITfLangBarItemSink_Value;
pub const ITfLangBarItemSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnUpdate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfLangBarItemSink,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfLangBarItemSink,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfLangBarItemSink_OnUpdate(self: *const T, dwFlags: u32) HRESULT {
                return @as(*const ITfLangBarItemSink.VTable, @ptrCast(self.vtable)).OnUpdate(@as(*const ITfLangBarItemSink, @ptrCast(self)), dwFlags);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumTfLangBarItems_Value = Guid.initString("583f34d0-de25-11d2-afdd-00105a2799b5");
pub const IID_IEnumTfLangBarItems = &IID_IEnumTfLangBarItems_Value;
pub const IEnumTfLangBarItems = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumTfLangBarItems,
                ppEnum: ?*?*IEnumTfLangBarItems,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumTfLangBarItems,
                ppEnum: ?*?*IEnumTfLangBarItems,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumTfLangBarItems,
                ulCount: u32,
                ppItem: [*]?*ITfLangBarItem,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumTfLangBarItems,
                ulCount: u32,
                ppItem: [*]?*ITfLangBarItem,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumTfLangBarItems,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumTfLangBarItems,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumTfLangBarItems,
                ulCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumTfLangBarItems,
                ulCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumTfLangBarItems_Clone(self: *const T, ppEnum: ?*?*IEnumTfLangBarItems) HRESULT {
                return @as(*const IEnumTfLangBarItems.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumTfLangBarItems, @ptrCast(self)), ppEnum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumTfLangBarItems_Next(self: *const T, ulCount: u32, ppItem: [*]?*ITfLangBarItem, pcFetched: ?*u32) HRESULT {
                return @as(*const IEnumTfLangBarItems.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumTfLangBarItems, @ptrCast(self)), ulCount, ppItem, pcFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumTfLangBarItems_Reset(self: *const T) HRESULT {
                return @as(*const IEnumTfLangBarItems.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumTfLangBarItems, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumTfLangBarItems_Skip(self: *const T, ulCount: u32) HRESULT {
                return @as(*const IEnumTfLangBarItems.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumTfLangBarItems, @ptrCast(self)), ulCount);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const TF_LANGBARITEMINFO = extern struct {
    clsidService: Guid,
    guidItem: Guid,
    dwStyle: u32,
    ulSort: u32,
    szDescription: [32]u16,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfLangBarItemMgr_Value = Guid.initString("ba468c55-9956-4fb1-a59d-52a7dd7cc6aa");
pub const IID_ITfLangBarItemMgr = &IID_ITfLangBarItemMgr_Value;
pub const ITfLangBarItemMgr = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EnumItems: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfLangBarItemMgr,
                ppEnum: ?*?*IEnumTfLangBarItems,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfLangBarItemMgr,
                ppEnum: ?*?*IEnumTfLangBarItems,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfLangBarItemMgr,
                rguid: ?*const Guid,
                ppItem: ?*?*ITfLangBarItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfLangBarItemMgr,
                rguid: ?*const Guid,
                ppItem: ?*?*ITfLangBarItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfLangBarItemMgr,
                punk: ?*ITfLangBarItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfLangBarItemMgr,
                punk: ?*ITfLangBarItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfLangBarItemMgr,
                punk: ?*ITfLangBarItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfLangBarItemMgr,
                punk: ?*ITfLangBarItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AdviseItemSink: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfLangBarItemMgr,
                punk: ?*ITfLangBarItemSink,
                pdwCookie: ?*u32,
                rguidItem: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfLangBarItemMgr,
                punk: ?*ITfLangBarItemSink,
                pdwCookie: ?*u32,
                rguidItem: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnadviseItemSink: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfLangBarItemMgr,
                dwCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfLangBarItemMgr,
                dwCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetItemFloatingRect: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfLangBarItemMgr,
                dwThreadId: u32,
                rguid: ?*const Guid,
                prc: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfLangBarItemMgr,
                dwThreadId: u32,
                rguid: ?*const Guid,
                prc: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetItemsStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfLangBarItemMgr,
                ulCount: u32,
                prgguid: [*]const Guid,
                pdwStatus: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfLangBarItemMgr,
                ulCount: u32,
                prgguid: [*]const Guid,
                pdwStatus: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetItemNum: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfLangBarItemMgr,
                pulCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfLangBarItemMgr,
                pulCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetItems: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfLangBarItemMgr,
                ulCount: u32,
                ppItem: [*]?*ITfLangBarItem,
                pInfo: [*]TF_LANGBARITEMINFO,
                pdwStatus: [*]u32,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfLangBarItemMgr,
                ulCount: u32,
                ppItem: [*]?*ITfLangBarItem,
                pInfo: [*]TF_LANGBARITEMINFO,
                pdwStatus: [*]u32,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AdviseItemsSink: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfLangBarItemMgr,
                ulCount: u32,
                ppunk: [*]?*ITfLangBarItemSink,
                pguidItem: [*]const Guid,
                pdwCookie: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfLangBarItemMgr,
                ulCount: u32,
                ppunk: [*]?*ITfLangBarItemSink,
                pguidItem: [*]const Guid,
                pdwCookie: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnadviseItemsSink: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfLangBarItemMgr,
                ulCount: u32,
                pdwCookie: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfLangBarItemMgr,
                ulCount: u32,
                pdwCookie: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfLangBarItemMgr_EnumItems(self: *const T, ppEnum: ?*?*IEnumTfLangBarItems) HRESULT {
                return @as(*const ITfLangBarItemMgr.VTable, @ptrCast(self.vtable)).EnumItems(@as(*const ITfLangBarItemMgr, @ptrCast(self)), ppEnum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfLangBarItemMgr_GetItem(self: *const T, rguid: ?*const Guid, ppItem: ?*?*ITfLangBarItem) HRESULT {
                return @as(*const ITfLangBarItemMgr.VTable, @ptrCast(self.vtable)).GetItem(@as(*const ITfLangBarItemMgr, @ptrCast(self)), rguid, ppItem);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfLangBarItemMgr_AddItem(self: *const T, punk: ?*ITfLangBarItem) HRESULT {
                return @as(*const ITfLangBarItemMgr.VTable, @ptrCast(self.vtable)).AddItem(@as(*const ITfLangBarItemMgr, @ptrCast(self)), punk);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfLangBarItemMgr_RemoveItem(self: *const T, punk: ?*ITfLangBarItem) HRESULT {
                return @as(*const ITfLangBarItemMgr.VTable, @ptrCast(self.vtable)).RemoveItem(@as(*const ITfLangBarItemMgr, @ptrCast(self)), punk);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfLangBarItemMgr_AdviseItemSink(self: *const T, punk: ?*ITfLangBarItemSink, pdwCookie: ?*u32, rguidItem: ?*const Guid) HRESULT {
                return @as(*const ITfLangBarItemMgr.VTable, @ptrCast(self.vtable)).AdviseItemSink(@as(*const ITfLangBarItemMgr, @ptrCast(self)), punk, pdwCookie, rguidItem);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfLangBarItemMgr_UnadviseItemSink(self: *const T, dwCookie: u32) HRESULT {
                return @as(*const ITfLangBarItemMgr.VTable, @ptrCast(self.vtable)).UnadviseItemSink(@as(*const ITfLangBarItemMgr, @ptrCast(self)), dwCookie);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfLangBarItemMgr_GetItemFloatingRect(self: *const T, dwThreadId: u32, rguid: ?*const Guid, prc: ?*RECT) HRESULT {
                return @as(*const ITfLangBarItemMgr.VTable, @ptrCast(self.vtable)).GetItemFloatingRect(@as(*const ITfLangBarItemMgr, @ptrCast(self)), dwThreadId, rguid, prc);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfLangBarItemMgr_GetItemsStatus(self: *const T, ulCount: u32, prgguid: [*]const Guid, pdwStatus: [*]u32) HRESULT {
                return @as(*const ITfLangBarItemMgr.VTable, @ptrCast(self.vtable)).GetItemsStatus(@as(*const ITfLangBarItemMgr, @ptrCast(self)), ulCount, prgguid, pdwStatus);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfLangBarItemMgr_GetItemNum(self: *const T, pulCount: ?*u32) HRESULT {
                return @as(*const ITfLangBarItemMgr.VTable, @ptrCast(self.vtable)).GetItemNum(@as(*const ITfLangBarItemMgr, @ptrCast(self)), pulCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfLangBarItemMgr_GetItems(self: *const T, ulCount: u32, ppItem: [*]?*ITfLangBarItem, pInfo: [*]TF_LANGBARITEMINFO, pdwStatus: [*]u32, pcFetched: ?*u32) HRESULT {
                return @as(*const ITfLangBarItemMgr.VTable, @ptrCast(self.vtable)).GetItems(@as(*const ITfLangBarItemMgr, @ptrCast(self)), ulCount, ppItem, pInfo, pdwStatus, pcFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfLangBarItemMgr_AdviseItemsSink(self: *const T, ulCount: u32, ppunk: [*]?*ITfLangBarItemSink, pguidItem: [*]const Guid, pdwCookie: [*]u32) HRESULT {
                return @as(*const ITfLangBarItemMgr.VTable, @ptrCast(self.vtable)).AdviseItemsSink(@as(*const ITfLangBarItemMgr, @ptrCast(self)), ulCount, ppunk, pguidItem, pdwCookie);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfLangBarItemMgr_UnadviseItemsSink(self: *const T, ulCount: u32, pdwCookie: [*]u32) HRESULT {
                return @as(*const ITfLangBarItemMgr.VTable, @ptrCast(self.vtable)).UnadviseItemsSink(@as(*const ITfLangBarItemMgr, @ptrCast(self)), ulCount, pdwCookie);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfLangBarItem_Value = Guid.initString("73540d69-edeb-4ee9-96c9-23aa30b25916");
pub const IID_ITfLangBarItem = &IID_ITfLangBarItem_Value;
pub const ITfLangBarItem = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfLangBarItem,
                pInfo: ?*TF_LANGBARITEMINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfLangBarItem,
                pInfo: ?*TF_LANGBARITEMINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfLangBarItem,
                pdwStatus: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfLangBarItem,
                pdwStatus: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Show: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfLangBarItem,
                fShow: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfLangBarItem,
                fShow: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTooltipString: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfLangBarItem,
                pbstrToolTip: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfLangBarItem,
                pbstrToolTip: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfLangBarItem_GetInfo(self: *const T, pInfo: ?*TF_LANGBARITEMINFO) HRESULT {
                return @as(*const ITfLangBarItem.VTable, @ptrCast(self.vtable)).GetInfo(@as(*const ITfLangBarItem, @ptrCast(self)), pInfo);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfLangBarItem_GetStatus(self: *const T, pdwStatus: ?*u32) HRESULT {
                return @as(*const ITfLangBarItem.VTable, @ptrCast(self.vtable)).GetStatus(@as(*const ITfLangBarItem, @ptrCast(self)), pdwStatus);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfLangBarItem_Show(self: *const T, fShow: BOOL) HRESULT {
                return @as(*const ITfLangBarItem.VTable, @ptrCast(self.vtable)).Show(@as(*const ITfLangBarItem, @ptrCast(self)), fShow);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfLangBarItem_GetTooltipString(self: *const T, pbstrToolTip: ?*?BSTR) HRESULT {
                return @as(*const ITfLangBarItem.VTable, @ptrCast(self.vtable)).GetTooltipString(@as(*const ITfLangBarItem, @ptrCast(self)), pbstrToolTip);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfSystemLangBarItemSink_Value = Guid.initString("1449d9ab-13cf-4687-aa3e-8d8b18574396");
pub const IID_ITfSystemLangBarItemSink = &IID_ITfSystemLangBarItemSink_Value;
pub const ITfSystemLangBarItemSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        InitMenu: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfSystemLangBarItemSink,
                pMenu: ?*ITfMenu,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfSystemLangBarItemSink,
                pMenu: ?*ITfMenu,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnMenuSelect: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfSystemLangBarItemSink,
                wID: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfSystemLangBarItemSink,
                wID: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfSystemLangBarItemSink_InitMenu(self: *const T, pMenu: ?*ITfMenu) HRESULT {
                return @as(*const ITfSystemLangBarItemSink.VTable, @ptrCast(self.vtable)).InitMenu(@as(*const ITfSystemLangBarItemSink, @ptrCast(self)), pMenu);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfSystemLangBarItemSink_OnMenuSelect(self: *const T, wID: u32) HRESULT {
                return @as(*const ITfSystemLangBarItemSink.VTable, @ptrCast(self.vtable)).OnMenuSelect(@as(*const ITfSystemLangBarItemSink, @ptrCast(self)), wID);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfSystemLangBarItem_Value = Guid.initString("1e13e9ec-6b33-4d4a-b5eb-8a92f029f356");
pub const IID_ITfSystemLangBarItem = &IID_ITfSystemLangBarItem_Value;
pub const ITfSystemLangBarItem = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetIcon: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfSystemLangBarItem,
                hIcon: ?HICON,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfSystemLangBarItem,
                hIcon: ?HICON,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTooltipString: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfSystemLangBarItem,
                pchToolTip: [*:0]u16,
                cch: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfSystemLangBarItem,
                pchToolTip: [*:0]u16,
                cch: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfSystemLangBarItem_SetIcon(self: *const T, hIcon: ?HICON) HRESULT {
                return @as(*const ITfSystemLangBarItem.VTable, @ptrCast(self.vtable)).SetIcon(@as(*const ITfSystemLangBarItem, @ptrCast(self)), hIcon);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfSystemLangBarItem_SetTooltipString(self: *const T, pchToolTip: [*:0]u16, cch: u32) HRESULT {
                return @as(*const ITfSystemLangBarItem.VTable, @ptrCast(self.vtable)).SetTooltipString(@as(*const ITfSystemLangBarItem, @ptrCast(self)), pchToolTip, cch);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfSystemLangBarItemText_Value = Guid.initString("5c4ce0e5-ba49-4b52-ac6b-3b397b4f701f");
pub const IID_ITfSystemLangBarItemText = &IID_ITfSystemLangBarItemText_Value;
pub const ITfSystemLangBarItemText = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetItemText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfSystemLangBarItemText,
                pch: [*:0]const u16,
                cch: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfSystemLangBarItemText,
                pch: [*:0]const u16,
                cch: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetItemText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfSystemLangBarItemText,
                pbstrText: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfSystemLangBarItemText,
                pbstrText: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfSystemLangBarItemText_SetItemText(self: *const T, pch: [*:0]const u16, cch: u32) HRESULT {
                return @as(*const ITfSystemLangBarItemText.VTable, @ptrCast(self.vtable)).SetItemText(@as(*const ITfSystemLangBarItemText, @ptrCast(self)), pch, cch);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfSystemLangBarItemText_GetItemText(self: *const T, pbstrText: ?*?BSTR) HRESULT {
                return @as(*const ITfSystemLangBarItemText.VTable, @ptrCast(self.vtable)).GetItemText(@as(*const ITfSystemLangBarItemText, @ptrCast(self)), pbstrText);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfSystemDeviceTypeLangBarItem_Value = Guid.initString("45672eb9-9059-46a2-838d-4530355f6a77");
pub const IID_ITfSystemDeviceTypeLangBarItem = &IID_ITfSystemDeviceTypeLangBarItem_Value;
pub const ITfSystemDeviceTypeLangBarItem = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetIconMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfSystemDeviceTypeLangBarItem,
                dwFlags: LANG_BAR_ITEM_ICON_MODE_FLAGS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfSystemDeviceTypeLangBarItem,
                dwFlags: LANG_BAR_ITEM_ICON_MODE_FLAGS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIconMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfSystemDeviceTypeLangBarItem,
                pdwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfSystemDeviceTypeLangBarItem,
                pdwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfSystemDeviceTypeLangBarItem_SetIconMode(self: *const T, dwFlags: LANG_BAR_ITEM_ICON_MODE_FLAGS) HRESULT {
                return @as(*const ITfSystemDeviceTypeLangBarItem.VTable, @ptrCast(self.vtable)).SetIconMode(@as(*const ITfSystemDeviceTypeLangBarItem, @ptrCast(self)), dwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfSystemDeviceTypeLangBarItem_GetIconMode(self: *const T, pdwFlags: ?*u32) HRESULT {
                return @as(*const ITfSystemDeviceTypeLangBarItem.VTable, @ptrCast(self.vtable)).GetIconMode(@as(*const ITfSystemDeviceTypeLangBarItem, @ptrCast(self)), pdwFlags);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const TfLBIClick = enum(i32) {
    RIGHT = 1,
    LEFT = 2,
};
pub const TF_LBI_CLK_RIGHT = TfLBIClick.RIGHT;
pub const TF_LBI_CLK_LEFT = TfLBIClick.LEFT;

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfLangBarItemButton_Value = Guid.initString("28c7f1d0-de25-11d2-afdd-00105a2799b5");
pub const IID_ITfLangBarItemButton = &IID_ITfLangBarItemButton_Value;
pub const ITfLangBarItemButton = extern struct {
    pub const VTable = extern struct {
        base: ITfLangBarItem.VTable,
        OnClick: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfLangBarItemButton,
                click: TfLBIClick,
                pt: POINT,
                prcArea: ?*const RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfLangBarItemButton,
                click: TfLBIClick,
                pt: POINT,
                prcArea: ?*const RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InitMenu: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfLangBarItemButton,
                pMenu: ?*ITfMenu,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfLangBarItemButton,
                pMenu: ?*ITfMenu,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnMenuSelect: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfLangBarItemButton,
                wID: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfLangBarItemButton,
                wID: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIcon: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfLangBarItemButton,
                phIcon: ?*?HICON,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfLangBarItemButton,
                phIcon: ?*?HICON,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfLangBarItemButton,
                pbstrText: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfLangBarItemButton,
                pbstrText: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITfLangBarItem.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfLangBarItemButton_OnClick(self: *const T, click: TfLBIClick, pt: POINT, prcArea: ?*const RECT) HRESULT {
                return @as(*const ITfLangBarItemButton.VTable, @ptrCast(self.vtable)).OnClick(@as(*const ITfLangBarItemButton, @ptrCast(self)), click, pt, prcArea);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfLangBarItemButton_InitMenu(self: *const T, pMenu: ?*ITfMenu) HRESULT {
                return @as(*const ITfLangBarItemButton.VTable, @ptrCast(self.vtable)).InitMenu(@as(*const ITfLangBarItemButton, @ptrCast(self)), pMenu);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfLangBarItemButton_OnMenuSelect(self: *const T, wID: u32) HRESULT {
                return @as(*const ITfLangBarItemButton.VTable, @ptrCast(self.vtable)).OnMenuSelect(@as(*const ITfLangBarItemButton, @ptrCast(self)), wID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfLangBarItemButton_GetIcon(self: *const T, phIcon: ?*?HICON) HRESULT {
                return @as(*const ITfLangBarItemButton.VTable, @ptrCast(self.vtable)).GetIcon(@as(*const ITfLangBarItemButton, @ptrCast(self)), phIcon);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfLangBarItemButton_GetText(self: *const T, pbstrText: ?*?BSTR) HRESULT {
                return @as(*const ITfLangBarItemButton.VTable, @ptrCast(self.vtable)).GetText(@as(*const ITfLangBarItemButton, @ptrCast(self)), pbstrText);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfLangBarItemBitmapButton_Value = Guid.initString("a26a0525-3fae-4fa0-89ee-88a964f9f1b5");
pub const IID_ITfLangBarItemBitmapButton = &IID_ITfLangBarItemBitmapButton_Value;
pub const ITfLangBarItemBitmapButton = extern struct {
    pub const VTable = extern struct {
        base: ITfLangBarItem.VTable,
        OnClick: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfLangBarItemBitmapButton,
                click: TfLBIClick,
                pt: POINT,
                prcArea: ?*const RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfLangBarItemBitmapButton,
                click: TfLBIClick,
                pt: POINT,
                prcArea: ?*const RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InitMenu: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfLangBarItemBitmapButton,
                pMenu: ?*ITfMenu,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfLangBarItemBitmapButton,
                pMenu: ?*ITfMenu,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnMenuSelect: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfLangBarItemBitmapButton,
                wID: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfLangBarItemBitmapButton,
                wID: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPreferredSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfLangBarItemBitmapButton,
                pszDefault: ?*const SIZE,
                psz: ?*SIZE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfLangBarItemBitmapButton,
                pszDefault: ?*const SIZE,
                psz: ?*SIZE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DrawBitmap: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfLangBarItemBitmapButton,
                bmWidth: i32,
                bmHeight: i32,
                dwFlags: u32,
                phbmp: ?*?HBITMAP,
                phbmpMask: ?*?HBITMAP,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfLangBarItemBitmapButton,
                bmWidth: i32,
                bmHeight: i32,
                dwFlags: u32,
                phbmp: ?*?HBITMAP,
                phbmpMask: ?*?HBITMAP,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfLangBarItemBitmapButton,
                pbstrText: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfLangBarItemBitmapButton,
                pbstrText: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITfLangBarItem.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfLangBarItemBitmapButton_OnClick(self: *const T, click: TfLBIClick, pt: POINT, prcArea: ?*const RECT) HRESULT {
                return @as(*const ITfLangBarItemBitmapButton.VTable, @ptrCast(self.vtable)).OnClick(@as(*const ITfLangBarItemBitmapButton, @ptrCast(self)), click, pt, prcArea);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfLangBarItemBitmapButton_InitMenu(self: *const T, pMenu: ?*ITfMenu) HRESULT {
                return @as(*const ITfLangBarItemBitmapButton.VTable, @ptrCast(self.vtable)).InitMenu(@as(*const ITfLangBarItemBitmapButton, @ptrCast(self)), pMenu);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfLangBarItemBitmapButton_OnMenuSelect(self: *const T, wID: u32) HRESULT {
                return @as(*const ITfLangBarItemBitmapButton.VTable, @ptrCast(self.vtable)).OnMenuSelect(@as(*const ITfLangBarItemBitmapButton, @ptrCast(self)), wID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfLangBarItemBitmapButton_GetPreferredSize(self: *const T, pszDefault: ?*const SIZE, psz: ?*SIZE) HRESULT {
                return @as(*const ITfLangBarItemBitmapButton.VTable, @ptrCast(self.vtable)).GetPreferredSize(@as(*const ITfLangBarItemBitmapButton, @ptrCast(self)), pszDefault, psz);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfLangBarItemBitmapButton_DrawBitmap(self: *const T, bmWidth: i32, bmHeight: i32, dwFlags: u32, phbmp: ?*?HBITMAP, phbmpMask: ?*?HBITMAP) HRESULT {
                return @as(*const ITfLangBarItemBitmapButton.VTable, @ptrCast(self.vtable)).DrawBitmap(@as(*const ITfLangBarItemBitmapButton, @ptrCast(self)), bmWidth, bmHeight, dwFlags, phbmp, phbmpMask);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfLangBarItemBitmapButton_GetText(self: *const T, pbstrText: ?*?BSTR) HRESULT {
                return @as(*const ITfLangBarItemBitmapButton.VTable, @ptrCast(self.vtable)).GetText(@as(*const ITfLangBarItemBitmapButton, @ptrCast(self)), pbstrText);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfLangBarItemBitmap_Value = Guid.initString("73830352-d722-4179-ada5-f045c98df355");
pub const IID_ITfLangBarItemBitmap = &IID_ITfLangBarItemBitmap_Value;
pub const ITfLangBarItemBitmap = extern struct {
    pub const VTable = extern struct {
        base: ITfLangBarItem.VTable,
        OnClick: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfLangBarItemBitmap,
                click: TfLBIClick,
                pt: POINT,
                prcArea: ?*const RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfLangBarItemBitmap,
                click: TfLBIClick,
                pt: POINT,
                prcArea: ?*const RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPreferredSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfLangBarItemBitmap,
                pszDefault: ?*const SIZE,
                psz: ?*SIZE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfLangBarItemBitmap,
                pszDefault: ?*const SIZE,
                psz: ?*SIZE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DrawBitmap: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfLangBarItemBitmap,
                bmWidth: i32,
                bmHeight: i32,
                dwFlags: u32,
                phbmp: ?*?HBITMAP,
                phbmpMask: ?*?HBITMAP,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfLangBarItemBitmap,
                bmWidth: i32,
                bmHeight: i32,
                dwFlags: u32,
                phbmp: ?*?HBITMAP,
                phbmpMask: ?*?HBITMAP,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITfLangBarItem.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfLangBarItemBitmap_OnClick(self: *const T, click: TfLBIClick, pt: POINT, prcArea: ?*const RECT) HRESULT {
                return @as(*const ITfLangBarItemBitmap.VTable, @ptrCast(self.vtable)).OnClick(@as(*const ITfLangBarItemBitmap, @ptrCast(self)), click, pt, prcArea);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfLangBarItemBitmap_GetPreferredSize(self: *const T, pszDefault: ?*const SIZE, psz: ?*SIZE) HRESULT {
                return @as(*const ITfLangBarItemBitmap.VTable, @ptrCast(self.vtable)).GetPreferredSize(@as(*const ITfLangBarItemBitmap, @ptrCast(self)), pszDefault, psz);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfLangBarItemBitmap_DrawBitmap(self: *const T, bmWidth: i32, bmHeight: i32, dwFlags: u32, phbmp: ?*?HBITMAP, phbmpMask: ?*?HBITMAP) HRESULT {
                return @as(*const ITfLangBarItemBitmap.VTable, @ptrCast(self.vtable)).DrawBitmap(@as(*const ITfLangBarItemBitmap, @ptrCast(self)), bmWidth, bmHeight, dwFlags, phbmp, phbmpMask);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const TfLBBalloonStyle = enum(i32) {
    RECO = 0,
    SHOW = 1,
    MISS = 2,
};
pub const TF_LB_BALLOON_RECO = TfLBBalloonStyle.RECO;
pub const TF_LB_BALLOON_SHOW = TfLBBalloonStyle.SHOW;
pub const TF_LB_BALLOON_MISS = TfLBBalloonStyle.MISS;

pub const TF_LBBALLOONINFO = extern struct {
    style: TfLBBalloonStyle,
    bstrText: ?BSTR,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfLangBarItemBalloon_Value = Guid.initString("01c2d285-d3c7-4b7b-b5b5-d97411d0c283");
pub const IID_ITfLangBarItemBalloon = &IID_ITfLangBarItemBalloon_Value;
pub const ITfLangBarItemBalloon = extern struct {
    pub const VTable = extern struct {
        base: ITfLangBarItem.VTable,
        OnClick: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfLangBarItemBalloon,
                click: TfLBIClick,
                pt: POINT,
                prcArea: ?*const RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfLangBarItemBalloon,
                click: TfLBIClick,
                pt: POINT,
                prcArea: ?*const RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPreferredSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfLangBarItemBalloon,
                pszDefault: ?*const SIZE,
                psz: ?*SIZE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfLangBarItemBalloon,
                pszDefault: ?*const SIZE,
                psz: ?*SIZE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBalloonInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfLangBarItemBalloon,
                pInfo: ?*TF_LBBALLOONINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfLangBarItemBalloon,
                pInfo: ?*TF_LBBALLOONINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITfLangBarItem.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfLangBarItemBalloon_OnClick(self: *const T, click: TfLBIClick, pt: POINT, prcArea: ?*const RECT) HRESULT {
                return @as(*const ITfLangBarItemBalloon.VTable, @ptrCast(self.vtable)).OnClick(@as(*const ITfLangBarItemBalloon, @ptrCast(self)), click, pt, prcArea);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfLangBarItemBalloon_GetPreferredSize(self: *const T, pszDefault: ?*const SIZE, psz: ?*SIZE) HRESULT {
                return @as(*const ITfLangBarItemBalloon.VTable, @ptrCast(self.vtable)).GetPreferredSize(@as(*const ITfLangBarItemBalloon, @ptrCast(self)), pszDefault, psz);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfLangBarItemBalloon_GetBalloonInfo(self: *const T, pInfo: ?*TF_LBBALLOONINFO) HRESULT {
                return @as(*const ITfLangBarItemBalloon.VTable, @ptrCast(self.vtable)).GetBalloonInfo(@as(*const ITfLangBarItemBalloon, @ptrCast(self)), pInfo);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfMenu_Value = Guid.initString("6f8a98e4-aaa0-4f15-8c5b-07e0df0a3dd8");
pub const IID_ITfMenu = &IID_ITfMenu_Value;
pub const ITfMenu = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddMenuItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfMenu,
                uId: u32,
                dwFlags: u32,
                hbmp: ?HBITMAP,
                hbmpMask: ?HBITMAP,
                pch: [*:0]const u16,
                cch: u32,
                ppMenu: ?*?*ITfMenu,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfMenu,
                uId: u32,
                dwFlags: u32,
                hbmp: ?HBITMAP,
                hbmpMask: ?HBITMAP,
                pch: [*:0]const u16,
                cch: u32,
                ppMenu: ?*?*ITfMenu,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfMenu_AddMenuItem(self: *const T, uId: u32, dwFlags: u32, hbmp: ?HBITMAP, hbmpMask: ?HBITMAP, pch: [*:0]const u16, cch: u32, ppMenu: ?*?*ITfMenu) HRESULT {
                return @as(*const ITfMenu.VTable, @ptrCast(self.vtable)).AddMenuItem(@as(*const ITfMenu, @ptrCast(self)), uId, dwFlags, hbmp, hbmpMask, pch, cch, ppMenu);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const TF_PERSISTENT_PROPERTY_HEADER_ACP = extern struct {
    guidType: Guid,
    ichStart: i32,
    cch: i32,
    cb: u32,
    dwPrivate: u32,
    clsidTIP: Guid,
};

pub const TF_LANGUAGEPROFILE = extern struct {
    clsid: Guid,
    langid: u16,
    catid: Guid,
    fActive: BOOL,
    guidProfile: Guid,
};

pub const TfAnchor = enum(i32) {
    START = 0,
    END = 1,
};
pub const TF_ANCHOR_START = TfAnchor.START;
pub const TF_ANCHOR_END = TfAnchor.END;

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfThreadMgr_Value = Guid.initString("aa80e801-2021-11d2-93e0-0060b067b86e");
pub const IID_ITfThreadMgr = &IID_ITfThreadMgr_Value;
pub const ITfThreadMgr = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Activate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfThreadMgr,
                ptid: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfThreadMgr,
                ptid: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Deactivate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfThreadMgr,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfThreadMgr,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateDocumentMgr: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfThreadMgr,
                ppdim: ?*?*ITfDocumentMgr,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfThreadMgr,
                ppdim: ?*?*ITfDocumentMgr,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumDocumentMgrs: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfThreadMgr,
                ppEnum: ?*?*IEnumTfDocumentMgrs,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfThreadMgr,
                ppEnum: ?*?*IEnumTfDocumentMgrs,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFocus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfThreadMgr,
                ppdimFocus: ?*?*ITfDocumentMgr,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfThreadMgr,
                ppdimFocus: ?*?*ITfDocumentMgr,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFocus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfThreadMgr,
                pdimFocus: ?*ITfDocumentMgr,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfThreadMgr,
                pdimFocus: ?*ITfDocumentMgr,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AssociateFocus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfThreadMgr,
                hwnd: ?HWND,
                pdimNew: ?*ITfDocumentMgr,
                ppdimPrev: ?*?*ITfDocumentMgr,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfThreadMgr,
                hwnd: ?HWND,
                pdimNew: ?*ITfDocumentMgr,
                ppdimPrev: ?*?*ITfDocumentMgr,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsThreadFocus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfThreadMgr,
                pfThreadFocus: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfThreadMgr,
                pfThreadFocus: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFunctionProvider: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfThreadMgr,
                clsid: ?*const Guid,
                ppFuncProv: ?*?*ITfFunctionProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfThreadMgr,
                clsid: ?*const Guid,
                ppFuncProv: ?*?*ITfFunctionProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumFunctionProviders: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfThreadMgr,
                ppEnum: ?*?*IEnumTfFunctionProviders,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfThreadMgr,
                ppEnum: ?*?*IEnumTfFunctionProviders,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetGlobalCompartment: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfThreadMgr,
                ppCompMgr: ?*?*ITfCompartmentMgr,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfThreadMgr,
                ppCompMgr: ?*?*ITfCompartmentMgr,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfThreadMgr_Activate(self: *const T, ptid: ?*u32) HRESULT {
                return @as(*const ITfThreadMgr.VTable, @ptrCast(self.vtable)).Activate(@as(*const ITfThreadMgr, @ptrCast(self)), ptid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfThreadMgr_Deactivate(self: *const T) HRESULT {
                return @as(*const ITfThreadMgr.VTable, @ptrCast(self.vtable)).Deactivate(@as(*const ITfThreadMgr, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfThreadMgr_CreateDocumentMgr(self: *const T, ppdim: ?*?*ITfDocumentMgr) HRESULT {
                return @as(*const ITfThreadMgr.VTable, @ptrCast(self.vtable)).CreateDocumentMgr(@as(*const ITfThreadMgr, @ptrCast(self)), ppdim);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfThreadMgr_EnumDocumentMgrs(self: *const T, ppEnum: ?*?*IEnumTfDocumentMgrs) HRESULT {
                return @as(*const ITfThreadMgr.VTable, @ptrCast(self.vtable)).EnumDocumentMgrs(@as(*const ITfThreadMgr, @ptrCast(self)), ppEnum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfThreadMgr_GetFocus(self: *const T, ppdimFocus: ?*?*ITfDocumentMgr) HRESULT {
                return @as(*const ITfThreadMgr.VTable, @ptrCast(self.vtable)).GetFocus(@as(*const ITfThreadMgr, @ptrCast(self)), ppdimFocus);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfThreadMgr_SetFocus(self: *const T, pdimFocus: ?*ITfDocumentMgr) HRESULT {
                return @as(*const ITfThreadMgr.VTable, @ptrCast(self.vtable)).SetFocus(@as(*const ITfThreadMgr, @ptrCast(self)), pdimFocus);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfThreadMgr_AssociateFocus(self: *const T, hwnd: ?HWND, pdimNew: ?*ITfDocumentMgr, ppdimPrev: ?*?*ITfDocumentMgr) HRESULT {
                return @as(*const ITfThreadMgr.VTable, @ptrCast(self.vtable)).AssociateFocus(@as(*const ITfThreadMgr, @ptrCast(self)), hwnd, pdimNew, ppdimPrev);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfThreadMgr_IsThreadFocus(self: *const T, pfThreadFocus: ?*BOOL) HRESULT {
                return @as(*const ITfThreadMgr.VTable, @ptrCast(self.vtable)).IsThreadFocus(@as(*const ITfThreadMgr, @ptrCast(self)), pfThreadFocus);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfThreadMgr_GetFunctionProvider(self: *const T, clsid: ?*const Guid, ppFuncProv: ?*?*ITfFunctionProvider) HRESULT {
                return @as(*const ITfThreadMgr.VTable, @ptrCast(self.vtable)).GetFunctionProvider(@as(*const ITfThreadMgr, @ptrCast(self)), clsid, ppFuncProv);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfThreadMgr_EnumFunctionProviders(self: *const T, ppEnum: ?*?*IEnumTfFunctionProviders) HRESULT {
                return @as(*const ITfThreadMgr.VTable, @ptrCast(self.vtable)).EnumFunctionProviders(@as(*const ITfThreadMgr, @ptrCast(self)), ppEnum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfThreadMgr_GetGlobalCompartment(self: *const T, ppCompMgr: ?*?*ITfCompartmentMgr) HRESULT {
                return @as(*const ITfThreadMgr.VTable, @ptrCast(self.vtable)).GetGlobalCompartment(@as(*const ITfThreadMgr, @ptrCast(self)), ppCompMgr);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfThreadMgrEx_Value = Guid.initString("3e90ade3-7594-4cb0-bb58-69628f5f458c");
pub const IID_ITfThreadMgrEx = &IID_ITfThreadMgrEx_Value;
pub const ITfThreadMgrEx = extern struct {
    pub const VTable = extern struct {
        base: ITfThreadMgr.VTable,
        ActivateEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfThreadMgrEx,
                ptid: ?*u32,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfThreadMgrEx,
                ptid: ?*u32,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetActiveFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfThreadMgrEx,
                lpdwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfThreadMgrEx,
                lpdwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITfThreadMgr.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfThreadMgrEx_ActivateEx(self: *const T, ptid: ?*u32, dwFlags: u32) HRESULT {
                return @as(*const ITfThreadMgrEx.VTable, @ptrCast(self.vtable)).ActivateEx(@as(*const ITfThreadMgrEx, @ptrCast(self)), ptid, dwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfThreadMgrEx_GetActiveFlags(self: *const T, lpdwFlags: ?*u32) HRESULT {
                return @as(*const ITfThreadMgrEx.VTable, @ptrCast(self.vtable)).GetActiveFlags(@as(*const ITfThreadMgrEx, @ptrCast(self)), lpdwFlags);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ITfThreadMgr2_Value = Guid.initString("0ab198ef-6477-4ee8-8812-6780edb82d5e");
pub const IID_ITfThreadMgr2 = &IID_ITfThreadMgr2_Value;
pub const ITfThreadMgr2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Activate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfThreadMgr2,
                ptid: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfThreadMgr2,
                ptid: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Deactivate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfThreadMgr2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfThreadMgr2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateDocumentMgr: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfThreadMgr2,
                ppdim: ?*?*ITfDocumentMgr,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfThreadMgr2,
                ppdim: ?*?*ITfDocumentMgr,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumDocumentMgrs: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfThreadMgr2,
                ppEnum: ?*?*IEnumTfDocumentMgrs,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfThreadMgr2,
                ppEnum: ?*?*IEnumTfDocumentMgrs,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFocus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfThreadMgr2,
                ppdimFocus: ?*?*ITfDocumentMgr,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfThreadMgr2,
                ppdimFocus: ?*?*ITfDocumentMgr,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFocus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfThreadMgr2,
                pdimFocus: ?*ITfDocumentMgr,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfThreadMgr2,
                pdimFocus: ?*ITfDocumentMgr,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsThreadFocus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfThreadMgr2,
                pfThreadFocus: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfThreadMgr2,
                pfThreadFocus: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFunctionProvider: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfThreadMgr2,
                clsid: ?*const Guid,
                ppFuncProv: ?*?*ITfFunctionProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfThreadMgr2,
                clsid: ?*const Guid,
                ppFuncProv: ?*?*ITfFunctionProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumFunctionProviders: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfThreadMgr2,
                ppEnum: ?*?*IEnumTfFunctionProviders,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfThreadMgr2,
                ppEnum: ?*?*IEnumTfFunctionProviders,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetGlobalCompartment: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfThreadMgr2,
                ppCompMgr: ?*?*ITfCompartmentMgr,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfThreadMgr2,
                ppCompMgr: ?*?*ITfCompartmentMgr,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ActivateEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfThreadMgr2,
                ptid: ?*u32,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfThreadMgr2,
                ptid: ?*u32,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetActiveFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfThreadMgr2,
                lpdwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfThreadMgr2,
                lpdwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SuspendKeystrokeHandling: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfThreadMgr2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfThreadMgr2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ResumeKeystrokeHandling: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfThreadMgr2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfThreadMgr2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfThreadMgr2_Activate(self: *const T, ptid: ?*u32) HRESULT {
                return @as(*const ITfThreadMgr2.VTable, @ptrCast(self.vtable)).Activate(@as(*const ITfThreadMgr2, @ptrCast(self)), ptid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfThreadMgr2_Deactivate(self: *const T) HRESULT {
                return @as(*const ITfThreadMgr2.VTable, @ptrCast(self.vtable)).Deactivate(@as(*const ITfThreadMgr2, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfThreadMgr2_CreateDocumentMgr(self: *const T, ppdim: ?*?*ITfDocumentMgr) HRESULT {
                return @as(*const ITfThreadMgr2.VTable, @ptrCast(self.vtable)).CreateDocumentMgr(@as(*const ITfThreadMgr2, @ptrCast(self)), ppdim);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfThreadMgr2_EnumDocumentMgrs(self: *const T, ppEnum: ?*?*IEnumTfDocumentMgrs) HRESULT {
                return @as(*const ITfThreadMgr2.VTable, @ptrCast(self.vtable)).EnumDocumentMgrs(@as(*const ITfThreadMgr2, @ptrCast(self)), ppEnum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfThreadMgr2_GetFocus(self: *const T, ppdimFocus: ?*?*ITfDocumentMgr) HRESULT {
                return @as(*const ITfThreadMgr2.VTable, @ptrCast(self.vtable)).GetFocus(@as(*const ITfThreadMgr2, @ptrCast(self)), ppdimFocus);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfThreadMgr2_SetFocus(self: *const T, pdimFocus: ?*ITfDocumentMgr) HRESULT {
                return @as(*const ITfThreadMgr2.VTable, @ptrCast(self.vtable)).SetFocus(@as(*const ITfThreadMgr2, @ptrCast(self)), pdimFocus);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfThreadMgr2_IsThreadFocus(self: *const T, pfThreadFocus: ?*BOOL) HRESULT {
                return @as(*const ITfThreadMgr2.VTable, @ptrCast(self.vtable)).IsThreadFocus(@as(*const ITfThreadMgr2, @ptrCast(self)), pfThreadFocus);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfThreadMgr2_GetFunctionProvider(self: *const T, clsid: ?*const Guid, ppFuncProv: ?*?*ITfFunctionProvider) HRESULT {
                return @as(*const ITfThreadMgr2.VTable, @ptrCast(self.vtable)).GetFunctionProvider(@as(*const ITfThreadMgr2, @ptrCast(self)), clsid, ppFuncProv);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfThreadMgr2_EnumFunctionProviders(self: *const T, ppEnum: ?*?*IEnumTfFunctionProviders) HRESULT {
                return @as(*const ITfThreadMgr2.VTable, @ptrCast(self.vtable)).EnumFunctionProviders(@as(*const ITfThreadMgr2, @ptrCast(self)), ppEnum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfThreadMgr2_GetGlobalCompartment(self: *const T, ppCompMgr: ?*?*ITfCompartmentMgr) HRESULT {
                return @as(*const ITfThreadMgr2.VTable, @ptrCast(self.vtable)).GetGlobalCompartment(@as(*const ITfThreadMgr2, @ptrCast(self)), ppCompMgr);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfThreadMgr2_ActivateEx(self: *const T, ptid: ?*u32, dwFlags: u32) HRESULT {
                return @as(*const ITfThreadMgr2.VTable, @ptrCast(self.vtable)).ActivateEx(@as(*const ITfThreadMgr2, @ptrCast(self)), ptid, dwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfThreadMgr2_GetActiveFlags(self: *const T, lpdwFlags: ?*u32) HRESULT {
                return @as(*const ITfThreadMgr2.VTable, @ptrCast(self.vtable)).GetActiveFlags(@as(*const ITfThreadMgr2, @ptrCast(self)), lpdwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfThreadMgr2_SuspendKeystrokeHandling(self: *const T) HRESULT {
                return @as(*const ITfThreadMgr2.VTable, @ptrCast(self.vtable)).SuspendKeystrokeHandling(@as(*const ITfThreadMgr2, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfThreadMgr2_ResumeKeystrokeHandling(self: *const T) HRESULT {
                return @as(*const ITfThreadMgr2.VTable, @ptrCast(self.vtable)).ResumeKeystrokeHandling(@as(*const ITfThreadMgr2, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfThreadMgrEventSink_Value = Guid.initString("aa80e80e-2021-11d2-93e0-0060b067b86e");
pub const IID_ITfThreadMgrEventSink = &IID_ITfThreadMgrEventSink_Value;
pub const ITfThreadMgrEventSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnInitDocumentMgr: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfThreadMgrEventSink,
                pdim: ?*ITfDocumentMgr,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfThreadMgrEventSink,
                pdim: ?*ITfDocumentMgr,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnUninitDocumentMgr: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfThreadMgrEventSink,
                pdim: ?*ITfDocumentMgr,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfThreadMgrEventSink,
                pdim: ?*ITfDocumentMgr,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnSetFocus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfThreadMgrEventSink,
                pdimFocus: ?*ITfDocumentMgr,
                pdimPrevFocus: ?*ITfDocumentMgr,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfThreadMgrEventSink,
                pdimFocus: ?*ITfDocumentMgr,
                pdimPrevFocus: ?*ITfDocumentMgr,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnPushContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfThreadMgrEventSink,
                pic: ?*ITfContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfThreadMgrEventSink,
                pic: ?*ITfContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnPopContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfThreadMgrEventSink,
                pic: ?*ITfContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfThreadMgrEventSink,
                pic: ?*ITfContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfThreadMgrEventSink_OnInitDocumentMgr(self: *const T, pdim: ?*ITfDocumentMgr) HRESULT {
                return @as(*const ITfThreadMgrEventSink.VTable, @ptrCast(self.vtable)).OnInitDocumentMgr(@as(*const ITfThreadMgrEventSink, @ptrCast(self)), pdim);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfThreadMgrEventSink_OnUninitDocumentMgr(self: *const T, pdim: ?*ITfDocumentMgr) HRESULT {
                return @as(*const ITfThreadMgrEventSink.VTable, @ptrCast(self.vtable)).OnUninitDocumentMgr(@as(*const ITfThreadMgrEventSink, @ptrCast(self)), pdim);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfThreadMgrEventSink_OnSetFocus(self: *const T, pdimFocus: ?*ITfDocumentMgr, pdimPrevFocus: ?*ITfDocumentMgr) HRESULT {
                return @as(*const ITfThreadMgrEventSink.VTable, @ptrCast(self.vtable)).OnSetFocus(@as(*const ITfThreadMgrEventSink, @ptrCast(self)), pdimFocus, pdimPrevFocus);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfThreadMgrEventSink_OnPushContext(self: *const T, pic: ?*ITfContext) HRESULT {
                return @as(*const ITfThreadMgrEventSink.VTable, @ptrCast(self.vtable)).OnPushContext(@as(*const ITfThreadMgrEventSink, @ptrCast(self)), pic);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfThreadMgrEventSink_OnPopContext(self: *const T, pic: ?*ITfContext) HRESULT {
                return @as(*const ITfThreadMgrEventSink.VTable, @ptrCast(self.vtable)).OnPopContext(@as(*const ITfThreadMgrEventSink, @ptrCast(self)), pic);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfConfigureSystemKeystrokeFeed_Value = Guid.initString("0d2c969a-bc9c-437c-84ee-951c49b1a764");
pub const IID_ITfConfigureSystemKeystrokeFeed = &IID_ITfConfigureSystemKeystrokeFeed_Value;
pub const ITfConfigureSystemKeystrokeFeed = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        DisableSystemKeystrokeFeed: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfConfigureSystemKeystrokeFeed,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfConfigureSystemKeystrokeFeed,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnableSystemKeystrokeFeed: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfConfigureSystemKeystrokeFeed,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfConfigureSystemKeystrokeFeed,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfConfigureSystemKeystrokeFeed_DisableSystemKeystrokeFeed(self: *const T) HRESULT {
                return @as(*const ITfConfigureSystemKeystrokeFeed.VTable, @ptrCast(self.vtable)).DisableSystemKeystrokeFeed(@as(*const ITfConfigureSystemKeystrokeFeed, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfConfigureSystemKeystrokeFeed_EnableSystemKeystrokeFeed(self: *const T) HRESULT {
                return @as(*const ITfConfigureSystemKeystrokeFeed.VTable, @ptrCast(self.vtable)).EnableSystemKeystrokeFeed(@as(*const ITfConfigureSystemKeystrokeFeed, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumTfDocumentMgrs_Value = Guid.initString("aa80e808-2021-11d2-93e0-0060b067b86e");
pub const IID_IEnumTfDocumentMgrs = &IID_IEnumTfDocumentMgrs_Value;
pub const IEnumTfDocumentMgrs = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumTfDocumentMgrs,
                ppEnum: ?*?*IEnumTfDocumentMgrs,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumTfDocumentMgrs,
                ppEnum: ?*?*IEnumTfDocumentMgrs,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumTfDocumentMgrs,
                ulCount: u32,
                rgDocumentMgr: [*]?*ITfDocumentMgr,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumTfDocumentMgrs,
                ulCount: u32,
                rgDocumentMgr: [*]?*ITfDocumentMgr,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumTfDocumentMgrs,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumTfDocumentMgrs,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumTfDocumentMgrs,
                ulCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumTfDocumentMgrs,
                ulCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumTfDocumentMgrs_Clone(self: *const T, ppEnum: ?*?*IEnumTfDocumentMgrs) HRESULT {
                return @as(*const IEnumTfDocumentMgrs.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumTfDocumentMgrs, @ptrCast(self)), ppEnum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumTfDocumentMgrs_Next(self: *const T, ulCount: u32, rgDocumentMgr: [*]?*ITfDocumentMgr, pcFetched: ?*u32) HRESULT {
                return @as(*const IEnumTfDocumentMgrs.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumTfDocumentMgrs, @ptrCast(self)), ulCount, rgDocumentMgr, pcFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumTfDocumentMgrs_Reset(self: *const T) HRESULT {
                return @as(*const IEnumTfDocumentMgrs.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumTfDocumentMgrs, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumTfDocumentMgrs_Skip(self: *const T, ulCount: u32) HRESULT {
                return @as(*const IEnumTfDocumentMgrs.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumTfDocumentMgrs, @ptrCast(self)), ulCount);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfDocumentMgr_Value = Guid.initString("aa80e7f4-2021-11d2-93e0-0060b067b86e");
pub const IID_ITfDocumentMgr = &IID_ITfDocumentMgr_Value;
pub const ITfDocumentMgr = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfDocumentMgr,
                tidOwner: u32,
                dwFlags: u32,
                punk: ?*IUnknown,
                ppic: ?*?*ITfContext,
                pecTextStore: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfDocumentMgr,
                tidOwner: u32,
                dwFlags: u32,
                punk: ?*IUnknown,
                ppic: ?*?*ITfContext,
                pecTextStore: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Push: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfDocumentMgr,
                pic: ?*ITfContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfDocumentMgr,
                pic: ?*ITfContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Pop: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfDocumentMgr,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfDocumentMgr,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTop: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfDocumentMgr,
                ppic: ?*?*ITfContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfDocumentMgr,
                ppic: ?*?*ITfContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBase: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfDocumentMgr,
                ppic: ?*?*ITfContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfDocumentMgr,
                ppic: ?*?*ITfContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumContexts: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfDocumentMgr,
                ppEnum: ?*?*IEnumTfContexts,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfDocumentMgr,
                ppEnum: ?*?*IEnumTfContexts,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfDocumentMgr_CreateContext(self: *const T, tidOwner: u32, dwFlags: u32, punk: ?*IUnknown, ppic: ?*?*ITfContext, pecTextStore: ?*u32) HRESULT {
                return @as(*const ITfDocumentMgr.VTable, @ptrCast(self.vtable)).CreateContext(@as(*const ITfDocumentMgr, @ptrCast(self)), tidOwner, dwFlags, punk, ppic, pecTextStore);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfDocumentMgr_Push(self: *const T, pic: ?*ITfContext) HRESULT {
                return @as(*const ITfDocumentMgr.VTable, @ptrCast(self.vtable)).Push(@as(*const ITfDocumentMgr, @ptrCast(self)), pic);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfDocumentMgr_Pop(self: *const T, dwFlags: u32) HRESULT {
                return @as(*const ITfDocumentMgr.VTable, @ptrCast(self.vtable)).Pop(@as(*const ITfDocumentMgr, @ptrCast(self)), dwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfDocumentMgr_GetTop(self: *const T, ppic: ?*?*ITfContext) HRESULT {
                return @as(*const ITfDocumentMgr.VTable, @ptrCast(self.vtable)).GetTop(@as(*const ITfDocumentMgr, @ptrCast(self)), ppic);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfDocumentMgr_GetBase(self: *const T, ppic: ?*?*ITfContext) HRESULT {
                return @as(*const ITfDocumentMgr.VTable, @ptrCast(self.vtable)).GetBase(@as(*const ITfDocumentMgr, @ptrCast(self)), ppic);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfDocumentMgr_EnumContexts(self: *const T, ppEnum: ?*?*IEnumTfContexts) HRESULT {
                return @as(*const ITfDocumentMgr.VTable, @ptrCast(self.vtable)).EnumContexts(@as(*const ITfDocumentMgr, @ptrCast(self)), ppEnum);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumTfContexts_Value = Guid.initString("8f1a7ea6-1654-4502-a86e-b2902344d507");
pub const IID_IEnumTfContexts = &IID_IEnumTfContexts_Value;
pub const IEnumTfContexts = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumTfContexts,
                ppEnum: ?*?*IEnumTfContexts,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumTfContexts,
                ppEnum: ?*?*IEnumTfContexts,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumTfContexts,
                ulCount: u32,
                rgContext: [*]?*ITfContext,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumTfContexts,
                ulCount: u32,
                rgContext: [*]?*ITfContext,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumTfContexts,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumTfContexts,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumTfContexts,
                ulCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumTfContexts,
                ulCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumTfContexts_Clone(self: *const T, ppEnum: ?*?*IEnumTfContexts) HRESULT {
                return @as(*const IEnumTfContexts.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumTfContexts, @ptrCast(self)), ppEnum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumTfContexts_Next(self: *const T, ulCount: u32, rgContext: [*]?*ITfContext, pcFetched: ?*u32) HRESULT {
                return @as(*const IEnumTfContexts.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumTfContexts, @ptrCast(self)), ulCount, rgContext, pcFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumTfContexts_Reset(self: *const T) HRESULT {
                return @as(*const IEnumTfContexts.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumTfContexts, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumTfContexts_Skip(self: *const T, ulCount: u32) HRESULT {
                return @as(*const IEnumTfContexts.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumTfContexts, @ptrCast(self)), ulCount);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfCompositionView_Value = Guid.initString("d7540241-f9a1-4364-befc-dbcd2c4395b7");
pub const IID_ITfCompositionView = &IID_ITfCompositionView_Value;
pub const ITfCompositionView = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetOwnerClsid: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfCompositionView,
                pclsid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfCompositionView,
                pclsid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfCompositionView,
                ppRange: ?*?*ITfRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfCompositionView,
                ppRange: ?*?*ITfRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfCompositionView_GetOwnerClsid(self: *const T, pclsid: ?*Guid) HRESULT {
                return @as(*const ITfCompositionView.VTable, @ptrCast(self.vtable)).GetOwnerClsid(@as(*const ITfCompositionView, @ptrCast(self)), pclsid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfCompositionView_GetRange(self: *const T, ppRange: ?*?*ITfRange) HRESULT {
                return @as(*const ITfCompositionView.VTable, @ptrCast(self.vtable)).GetRange(@as(*const ITfCompositionView, @ptrCast(self)), ppRange);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumITfCompositionView_Value = Guid.initString("5efd22ba-7838-46cb-88e2-cadb14124f8f");
pub const IID_IEnumITfCompositionView = &IID_IEnumITfCompositionView_Value;
pub const IEnumITfCompositionView = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumITfCompositionView,
                ppEnum: ?*?*IEnumITfCompositionView,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumITfCompositionView,
                ppEnum: ?*?*IEnumITfCompositionView,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumITfCompositionView,
                ulCount: u32,
                rgCompositionView: [*]?*ITfCompositionView,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumITfCompositionView,
                ulCount: u32,
                rgCompositionView: [*]?*ITfCompositionView,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumITfCompositionView,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumITfCompositionView,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumITfCompositionView,
                ulCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumITfCompositionView,
                ulCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumITfCompositionView_Clone(self: *const T, ppEnum: ?*?*IEnumITfCompositionView) HRESULT {
                return @as(*const IEnumITfCompositionView.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumITfCompositionView, @ptrCast(self)), ppEnum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumITfCompositionView_Next(self: *const T, ulCount: u32, rgCompositionView: [*]?*ITfCompositionView, pcFetched: ?*u32) HRESULT {
                return @as(*const IEnumITfCompositionView.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumITfCompositionView, @ptrCast(self)), ulCount, rgCompositionView, pcFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumITfCompositionView_Reset(self: *const T) HRESULT {
                return @as(*const IEnumITfCompositionView.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumITfCompositionView, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumITfCompositionView_Skip(self: *const T, ulCount: u32) HRESULT {
                return @as(*const IEnumITfCompositionView.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumITfCompositionView, @ptrCast(self)), ulCount);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfComposition_Value = Guid.initString("20168d64-5a8f-4a5a-b7bd-cfa29f4d0fd9");
pub const IID_ITfComposition = &IID_ITfComposition_Value;
pub const ITfComposition = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetRange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfComposition,
                ppRange: ?*?*ITfRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfComposition,
                ppRange: ?*?*ITfRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ShiftStart: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfComposition,
                ecWrite: u32,
                pNewStart: ?*ITfRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfComposition,
                ecWrite: u32,
                pNewStart: ?*ITfRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ShiftEnd: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfComposition,
                ecWrite: u32,
                pNewEnd: ?*ITfRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfComposition,
                ecWrite: u32,
                pNewEnd: ?*ITfRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndComposition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfComposition,
                ecWrite: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfComposition,
                ecWrite: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfComposition_GetRange(self: *const T, ppRange: ?*?*ITfRange) HRESULT {
                return @as(*const ITfComposition.VTable, @ptrCast(self.vtable)).GetRange(@as(*const ITfComposition, @ptrCast(self)), ppRange);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfComposition_ShiftStart(self: *const T, ecWrite: u32, pNewStart: ?*ITfRange) HRESULT {
                return @as(*const ITfComposition.VTable, @ptrCast(self.vtable)).ShiftStart(@as(*const ITfComposition, @ptrCast(self)), ecWrite, pNewStart);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfComposition_ShiftEnd(self: *const T, ecWrite: u32, pNewEnd: ?*ITfRange) HRESULT {
                return @as(*const ITfComposition.VTable, @ptrCast(self.vtable)).ShiftEnd(@as(*const ITfComposition, @ptrCast(self)), ecWrite, pNewEnd);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfComposition_EndComposition(self: *const T, ecWrite: u32) HRESULT {
                return @as(*const ITfComposition.VTable, @ptrCast(self.vtable)).EndComposition(@as(*const ITfComposition, @ptrCast(self)), ecWrite);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfCompositionSink_Value = Guid.initString("a781718c-579a-4b15-a280-32b8577acc5e");
pub const IID_ITfCompositionSink = &IID_ITfCompositionSink_Value;
pub const ITfCompositionSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnCompositionTerminated: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfCompositionSink,
                ecWrite: u32,
                pComposition: ?*ITfComposition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfCompositionSink,
                ecWrite: u32,
                pComposition: ?*ITfComposition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfCompositionSink_OnCompositionTerminated(self: *const T, ecWrite: u32, pComposition: ?*ITfComposition) HRESULT {
                return @as(*const ITfCompositionSink.VTable, @ptrCast(self.vtable)).OnCompositionTerminated(@as(*const ITfCompositionSink, @ptrCast(self)), ecWrite, pComposition);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfContextComposition_Value = Guid.initString("d40c8aae-ac92-4fc7-9a11-0ee0e23aa39b");
pub const IID_ITfContextComposition = &IID_ITfContextComposition_Value;
pub const ITfContextComposition = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        StartComposition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfContextComposition,
                ecWrite: u32,
                pCompositionRange: ?*ITfRange,
                pSink: ?*ITfCompositionSink,
                ppComposition: ?*?*ITfComposition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfContextComposition,
                ecWrite: u32,
                pCompositionRange: ?*ITfRange,
                pSink: ?*ITfCompositionSink,
                ppComposition: ?*?*ITfComposition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumCompositions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfContextComposition,
                ppEnum: ?*?*IEnumITfCompositionView,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfContextComposition,
                ppEnum: ?*?*IEnumITfCompositionView,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindComposition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfContextComposition,
                ecRead: u32,
                pTestRange: ?*ITfRange,
                ppEnum: ?*?*IEnumITfCompositionView,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfContextComposition,
                ecRead: u32,
                pTestRange: ?*ITfRange,
                ppEnum: ?*?*IEnumITfCompositionView,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TakeOwnership: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfContextComposition,
                ecWrite: u32,
                pComposition: ?*ITfCompositionView,
                pSink: ?*ITfCompositionSink,
                ppComposition: ?*?*ITfComposition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfContextComposition,
                ecWrite: u32,
                pComposition: ?*ITfCompositionView,
                pSink: ?*ITfCompositionSink,
                ppComposition: ?*?*ITfComposition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfContextComposition_StartComposition(self: *const T, ecWrite: u32, pCompositionRange: ?*ITfRange, pSink: ?*ITfCompositionSink, ppComposition: ?*?*ITfComposition) HRESULT {
                return @as(*const ITfContextComposition.VTable, @ptrCast(self.vtable)).StartComposition(@as(*const ITfContextComposition, @ptrCast(self)), ecWrite, pCompositionRange, pSink, ppComposition);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfContextComposition_EnumCompositions(self: *const T, ppEnum: ?*?*IEnumITfCompositionView) HRESULT {
                return @as(*const ITfContextComposition.VTable, @ptrCast(self.vtable)).EnumCompositions(@as(*const ITfContextComposition, @ptrCast(self)), ppEnum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfContextComposition_FindComposition(self: *const T, ecRead: u32, pTestRange: ?*ITfRange, ppEnum: ?*?*IEnumITfCompositionView) HRESULT {
                return @as(*const ITfContextComposition.VTable, @ptrCast(self.vtable)).FindComposition(@as(*const ITfContextComposition, @ptrCast(self)), ecRead, pTestRange, ppEnum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfContextComposition_TakeOwnership(self: *const T, ecWrite: u32, pComposition: ?*ITfCompositionView, pSink: ?*ITfCompositionSink, ppComposition: ?*?*ITfComposition) HRESULT {
                return @as(*const ITfContextComposition.VTable, @ptrCast(self.vtable)).TakeOwnership(@as(*const ITfContextComposition, @ptrCast(self)), ecWrite, pComposition, pSink, ppComposition);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfContextOwnerCompositionServices_Value = Guid.initString("86462810-593b-4916-9764-19c08e9ce110");
pub const IID_ITfContextOwnerCompositionServices = &IID_ITfContextOwnerCompositionServices_Value;
pub const ITfContextOwnerCompositionServices = extern struct {
    pub const VTable = extern struct {
        base: ITfContextComposition.VTable,
        TerminateComposition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfContextOwnerCompositionServices,
                pComposition: ?*ITfCompositionView,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfContextOwnerCompositionServices,
                pComposition: ?*ITfCompositionView,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITfContextComposition.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfContextOwnerCompositionServices_TerminateComposition(self: *const T, pComposition: ?*ITfCompositionView) HRESULT {
                return @as(*const ITfContextOwnerCompositionServices.VTable, @ptrCast(self.vtable)).TerminateComposition(@as(*const ITfContextOwnerCompositionServices, @ptrCast(self)), pComposition);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfContextOwnerCompositionSink_Value = Guid.initString("5f20aa40-b57a-4f34-96ab-3576f377cc79");
pub const IID_ITfContextOwnerCompositionSink = &IID_ITfContextOwnerCompositionSink_Value;
pub const ITfContextOwnerCompositionSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnStartComposition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfContextOwnerCompositionSink,
                pComposition: ?*ITfCompositionView,
                pfOk: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfContextOwnerCompositionSink,
                pComposition: ?*ITfCompositionView,
                pfOk: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnUpdateComposition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfContextOwnerCompositionSink,
                pComposition: ?*ITfCompositionView,
                pRangeNew: ?*ITfRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfContextOwnerCompositionSink,
                pComposition: ?*ITfCompositionView,
                pRangeNew: ?*ITfRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnEndComposition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfContextOwnerCompositionSink,
                pComposition: ?*ITfCompositionView,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfContextOwnerCompositionSink,
                pComposition: ?*ITfCompositionView,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfContextOwnerCompositionSink_OnStartComposition(self: *const T, pComposition: ?*ITfCompositionView, pfOk: ?*BOOL) HRESULT {
                return @as(*const ITfContextOwnerCompositionSink.VTable, @ptrCast(self.vtable)).OnStartComposition(@as(*const ITfContextOwnerCompositionSink, @ptrCast(self)), pComposition, pfOk);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfContextOwnerCompositionSink_OnUpdateComposition(self: *const T, pComposition: ?*ITfCompositionView, pRangeNew: ?*ITfRange) HRESULT {
                return @as(*const ITfContextOwnerCompositionSink.VTable, @ptrCast(self.vtable)).OnUpdateComposition(@as(*const ITfContextOwnerCompositionSink, @ptrCast(self)), pComposition, pRangeNew);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfContextOwnerCompositionSink_OnEndComposition(self: *const T, pComposition: ?*ITfCompositionView) HRESULT {
                return @as(*const ITfContextOwnerCompositionSink.VTable, @ptrCast(self.vtable)).OnEndComposition(@as(*const ITfContextOwnerCompositionSink, @ptrCast(self)), pComposition);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfContextView_Value = Guid.initString("2433bf8e-0f9b-435c-ba2c-180611978c30");
pub const IID_ITfContextView = &IID_ITfContextView_Value;
pub const ITfContextView = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetRangeFromPoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfContextView,
                ec: u32,
                ppt: ?*const POINT,
                dwFlags: u32,
                ppRange: ?*?*ITfRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfContextView,
                ec: u32,
                ppt: ?*const POINT,
                dwFlags: u32,
                ppRange: ?*?*ITfRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTextExt: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfContextView,
                ec: u32,
                pRange: ?*ITfRange,
                prc: ?*RECT,
                pfClipped: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfContextView,
                ec: u32,
                pRange: ?*ITfRange,
                prc: ?*RECT,
                pfClipped: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetScreenExt: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfContextView,
                prc: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfContextView,
                prc: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetWnd: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfContextView,
                phwnd: ?*?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfContextView,
                phwnd: ?*?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfContextView_GetRangeFromPoint(self: *const T, ec: u32, ppt: ?*const POINT, dwFlags: u32, ppRange: ?*?*ITfRange) HRESULT {
                return @as(*const ITfContextView.VTable, @ptrCast(self.vtable)).GetRangeFromPoint(@as(*const ITfContextView, @ptrCast(self)), ec, ppt, dwFlags, ppRange);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfContextView_GetTextExt(self: *const T, ec: u32, pRange: ?*ITfRange, prc: ?*RECT, pfClipped: ?*BOOL) HRESULT {
                return @as(*const ITfContextView.VTable, @ptrCast(self.vtable)).GetTextExt(@as(*const ITfContextView, @ptrCast(self)), ec, pRange, prc, pfClipped);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfContextView_GetScreenExt(self: *const T, prc: ?*RECT) HRESULT {
                return @as(*const ITfContextView.VTable, @ptrCast(self.vtable)).GetScreenExt(@as(*const ITfContextView, @ptrCast(self)), prc);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfContextView_GetWnd(self: *const T, phwnd: ?*?HWND) HRESULT {
                return @as(*const ITfContextView.VTable, @ptrCast(self.vtable)).GetWnd(@as(*const ITfContextView, @ptrCast(self)), phwnd);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumTfContextViews_Value = Guid.initString("f0c0f8dd-cf38-44e1-bb0f-68cf0d551c78");
pub const IID_IEnumTfContextViews = &IID_IEnumTfContextViews_Value;
pub const IEnumTfContextViews = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumTfContextViews,
                ppEnum: ?*?*IEnumTfContextViews,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumTfContextViews,
                ppEnum: ?*?*IEnumTfContextViews,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumTfContextViews,
                ulCount: u32,
                rgViews: [*]?*ITfContextView,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumTfContextViews,
                ulCount: u32,
                rgViews: [*]?*ITfContextView,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumTfContextViews,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumTfContextViews,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumTfContextViews,
                ulCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumTfContextViews,
                ulCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumTfContextViews_Clone(self: *const T, ppEnum: ?*?*IEnumTfContextViews) HRESULT {
                return @as(*const IEnumTfContextViews.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumTfContextViews, @ptrCast(self)), ppEnum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumTfContextViews_Next(self: *const T, ulCount: u32, rgViews: [*]?*ITfContextView, pcFetched: ?*u32) HRESULT {
                return @as(*const IEnumTfContextViews.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumTfContextViews, @ptrCast(self)), ulCount, rgViews, pcFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumTfContextViews_Reset(self: *const T) HRESULT {
                return @as(*const IEnumTfContextViews.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumTfContextViews, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumTfContextViews_Skip(self: *const T, ulCount: u32) HRESULT {
                return @as(*const IEnumTfContextViews.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumTfContextViews, @ptrCast(self)), ulCount);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const TfActiveSelEnd = enum(i32) {
    NONE = 0,
    START = 1,
    END = 2,
};
pub const TF_AE_NONE = TfActiveSelEnd.NONE;
pub const TF_AE_START = TfActiveSelEnd.START;
pub const TF_AE_END = TfActiveSelEnd.END;

pub const TF_SELECTIONSTYLE = extern struct {
    ase: TfActiveSelEnd,
    fInterimChar: BOOL,
};

pub const TF_SELECTION = extern struct {
    range: ?*ITfRange,
    style: TF_SELECTIONSTYLE,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfContext_Value = Guid.initString("aa80e7fd-2021-11d2-93e0-0060b067b86e");
pub const IID_ITfContext = &IID_ITfContext_Value;
pub const ITfContext = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RequestEditSession: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfContext,
                tid: u32,
                pes: ?*ITfEditSession,
                dwFlags: TF_CONTEXT_EDIT_CONTEXT_FLAGS,
                phrSession: ?*HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfContext,
                tid: u32,
                pes: ?*ITfEditSession,
                dwFlags: TF_CONTEXT_EDIT_CONTEXT_FLAGS,
                phrSession: ?*HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InWriteSession: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfContext,
                tid: u32,
                pfWriteSession: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfContext,
                tid: u32,
                pfWriteSession: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSelection: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfContext,
                ec: u32,
                ulIndex: u32,
                ulCount: u32,
                pSelection: [*]TF_SELECTION,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfContext,
                ec: u32,
                ulIndex: u32,
                ulCount: u32,
                pSelection: [*]TF_SELECTION,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSelection: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfContext,
                ec: u32,
                ulCount: u32,
                pSelection: [*]const TF_SELECTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfContext,
                ec: u32,
                ulCount: u32,
                pSelection: [*]const TF_SELECTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStart: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfContext,
                ec: u32,
                ppStart: ?*?*ITfRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfContext,
                ec: u32,
                ppStart: ?*?*ITfRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEnd: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfContext,
                ec: u32,
                ppEnd: ?*?*ITfRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfContext,
                ec: u32,
                ppEnd: ?*?*ITfRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetActiveView: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfContext,
                ppView: ?*?*ITfContextView,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfContext,
                ppView: ?*?*ITfContextView,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumViews: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfContext,
                ppEnum: ?*?*IEnumTfContextViews,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfContext,
                ppEnum: ?*?*IEnumTfContextViews,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfContext,
                pdcs: ?*TS_STATUS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfContext,
                pdcs: ?*TS_STATUS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfContext,
                guidProp: ?*const Guid,
                ppProp: ?*?*ITfProperty,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfContext,
                guidProp: ?*const Guid,
                ppProp: ?*?*ITfProperty,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAppProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfContext,
                guidProp: ?*const Guid,
                ppProp: ?*?*ITfReadOnlyProperty,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfContext,
                guidProp: ?*const Guid,
                ppProp: ?*?*ITfReadOnlyProperty,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TrackProperties: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfContext,
                prgProp: [*]const ?*const Guid,
                cProp: u32,
                prgAppProp: [*]const ?*const Guid,
                cAppProp: u32,
                ppProperty: ?*?*ITfReadOnlyProperty,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfContext,
                prgProp: [*]const ?*const Guid,
                cProp: u32,
                prgAppProp: [*]const ?*const Guid,
                cAppProp: u32,
                ppProperty: ?*?*ITfReadOnlyProperty,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumProperties: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfContext,
                ppEnum: ?*?*IEnumTfProperties,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfContext,
                ppEnum: ?*?*IEnumTfProperties,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDocumentMgr: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfContext,
                ppDm: ?*?*ITfDocumentMgr,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfContext,
                ppDm: ?*?*ITfDocumentMgr,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateRangeBackup: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfContext,
                ec: u32,
                pRange: ?*ITfRange,
                ppBackup: ?*?*ITfRangeBackup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfContext,
                ec: u32,
                pRange: ?*ITfRange,
                ppBackup: ?*?*ITfRangeBackup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfContext_RequestEditSession(self: *const T, tid: u32, pes: ?*ITfEditSession, dwFlags: TF_CONTEXT_EDIT_CONTEXT_FLAGS, phrSession: ?*HRESULT) HRESULT {
                return @as(*const ITfContext.VTable, @ptrCast(self.vtable)).RequestEditSession(@as(*const ITfContext, @ptrCast(self)), tid, pes, dwFlags, phrSession);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfContext_InWriteSession(self: *const T, tid: u32, pfWriteSession: ?*BOOL) HRESULT {
                return @as(*const ITfContext.VTable, @ptrCast(self.vtable)).InWriteSession(@as(*const ITfContext, @ptrCast(self)), tid, pfWriteSession);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfContext_GetSelection(self: *const T, ec: u32, ulIndex: u32, ulCount: u32, pSelection: [*]TF_SELECTION, pcFetched: ?*u32) HRESULT {
                return @as(*const ITfContext.VTable, @ptrCast(self.vtable)).GetSelection(@as(*const ITfContext, @ptrCast(self)), ec, ulIndex, ulCount, pSelection, pcFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfContext_SetSelection(self: *const T, ec: u32, ulCount: u32, pSelection: [*]const TF_SELECTION) HRESULT {
                return @as(*const ITfContext.VTable, @ptrCast(self.vtable)).SetSelection(@as(*const ITfContext, @ptrCast(self)), ec, ulCount, pSelection);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfContext_GetStart(self: *const T, ec: u32, ppStart: ?*?*ITfRange) HRESULT {
                return @as(*const ITfContext.VTable, @ptrCast(self.vtable)).GetStart(@as(*const ITfContext, @ptrCast(self)), ec, ppStart);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfContext_GetEnd(self: *const T, ec: u32, ppEnd: ?*?*ITfRange) HRESULT {
                return @as(*const ITfContext.VTable, @ptrCast(self.vtable)).GetEnd(@as(*const ITfContext, @ptrCast(self)), ec, ppEnd);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfContext_GetActiveView(self: *const T, ppView: ?*?*ITfContextView) HRESULT {
                return @as(*const ITfContext.VTable, @ptrCast(self.vtable)).GetActiveView(@as(*const ITfContext, @ptrCast(self)), ppView);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfContext_EnumViews(self: *const T, ppEnum: ?*?*IEnumTfContextViews) HRESULT {
                return @as(*const ITfContext.VTable, @ptrCast(self.vtable)).EnumViews(@as(*const ITfContext, @ptrCast(self)), ppEnum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfContext_GetStatus(self: *const T, pdcs: ?*TS_STATUS) HRESULT {
                return @as(*const ITfContext.VTable, @ptrCast(self.vtable)).GetStatus(@as(*const ITfContext, @ptrCast(self)), pdcs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfContext_GetProperty(self: *const T, guidProp: ?*const Guid, ppProp: ?*?*ITfProperty) HRESULT {
                return @as(*const ITfContext.VTable, @ptrCast(self.vtable)).GetProperty(@as(*const ITfContext, @ptrCast(self)), guidProp, ppProp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfContext_GetAppProperty(self: *const T, guidProp: ?*const Guid, ppProp: ?*?*ITfReadOnlyProperty) HRESULT {
                return @as(*const ITfContext.VTable, @ptrCast(self.vtable)).GetAppProperty(@as(*const ITfContext, @ptrCast(self)), guidProp, ppProp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfContext_TrackProperties(self: *const T, prgProp: [*]const ?*const Guid, cProp: u32, prgAppProp: [*]const ?*const Guid, cAppProp: u32, ppProperty: ?*?*ITfReadOnlyProperty) HRESULT {
                return @as(*const ITfContext.VTable, @ptrCast(self.vtable)).TrackProperties(@as(*const ITfContext, @ptrCast(self)), prgProp, cProp, prgAppProp, cAppProp, ppProperty);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfContext_EnumProperties(self: *const T, ppEnum: ?*?*IEnumTfProperties) HRESULT {
                return @as(*const ITfContext.VTable, @ptrCast(self.vtable)).EnumProperties(@as(*const ITfContext, @ptrCast(self)), ppEnum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfContext_GetDocumentMgr(self: *const T, ppDm: ?*?*ITfDocumentMgr) HRESULT {
                return @as(*const ITfContext.VTable, @ptrCast(self.vtable)).GetDocumentMgr(@as(*const ITfContext, @ptrCast(self)), ppDm);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfContext_CreateRangeBackup(self: *const T, ec: u32, pRange: ?*ITfRange, ppBackup: ?*?*ITfRangeBackup) HRESULT {
                return @as(*const ITfContext.VTable, @ptrCast(self.vtable)).CreateRangeBackup(@as(*const ITfContext, @ptrCast(self)), ec, pRange, ppBackup);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfQueryEmbedded_Value = Guid.initString("0fab9bdb-d250-4169-84e5-6be118fdd7a8");
pub const IID_ITfQueryEmbedded = &IID_ITfQueryEmbedded_Value;
pub const ITfQueryEmbedded = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryInsertEmbedded: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfQueryEmbedded,
                pguidService: ?*const Guid,
                pFormatEtc: ?*const FORMATETC,
                pfInsertable: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfQueryEmbedded,
                pguidService: ?*const Guid,
                pFormatEtc: ?*const FORMATETC,
                pfInsertable: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfQueryEmbedded_QueryInsertEmbedded(self: *const T, pguidService: ?*const Guid, pFormatEtc: ?*const FORMATETC, pfInsertable: ?*BOOL) HRESULT {
                return @as(*const ITfQueryEmbedded.VTable, @ptrCast(self.vtable)).QueryInsertEmbedded(@as(*const ITfQueryEmbedded, @ptrCast(self)), pguidService, pFormatEtc, pfInsertable);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfInsertAtSelection_Value = Guid.initString("55ce16ba-3014-41c1-9ceb-fade1446ac6c");
pub const IID_ITfInsertAtSelection = &IID_ITfInsertAtSelection_Value;
pub const ITfInsertAtSelection = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        InsertTextAtSelection: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfInsertAtSelection,
                ec: u32,
                dwFlags: INSERT_TEXT_AT_SELECTION_FLAGS,
                pchText: [*:0]const u16,
                cch: i32,
                ppRange: ?*?*ITfRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfInsertAtSelection,
                ec: u32,
                dwFlags: INSERT_TEXT_AT_SELECTION_FLAGS,
                pchText: [*:0]const u16,
                cch: i32,
                ppRange: ?*?*ITfRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InsertEmbeddedAtSelection: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfInsertAtSelection,
                ec: u32,
                dwFlags: u32,
                pDataObject: ?*IDataObject,
                ppRange: ?*?*ITfRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfInsertAtSelection,
                ec: u32,
                dwFlags: u32,
                pDataObject: ?*IDataObject,
                ppRange: ?*?*ITfRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfInsertAtSelection_InsertTextAtSelection(self: *const T, ec: u32, dwFlags: INSERT_TEXT_AT_SELECTION_FLAGS, pchText: [*:0]const u16, cch: i32, ppRange: ?*?*ITfRange) HRESULT {
                return @as(*const ITfInsertAtSelection.VTable, @ptrCast(self.vtable)).InsertTextAtSelection(@as(*const ITfInsertAtSelection, @ptrCast(self)), ec, dwFlags, pchText, cch, ppRange);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfInsertAtSelection_InsertEmbeddedAtSelection(self: *const T, ec: u32, dwFlags: u32, pDataObject: ?*IDataObject, ppRange: ?*?*ITfRange) HRESULT {
                return @as(*const ITfInsertAtSelection.VTable, @ptrCast(self.vtable)).InsertEmbeddedAtSelection(@as(*const ITfInsertAtSelection, @ptrCast(self)), ec, dwFlags, pDataObject, ppRange);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfCleanupContextSink_Value = Guid.initString("01689689-7acb-4e9b-ab7c-7ea46b12b522");
pub const IID_ITfCleanupContextSink = &IID_ITfCleanupContextSink_Value;
pub const ITfCleanupContextSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnCleanupContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfCleanupContextSink,
                ecWrite: u32,
                pic: ?*ITfContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfCleanupContextSink,
                ecWrite: u32,
                pic: ?*ITfContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfCleanupContextSink_OnCleanupContext(self: *const T, ecWrite: u32, pic: ?*ITfContext) HRESULT {
                return @as(*const ITfCleanupContextSink.VTable, @ptrCast(self.vtable)).OnCleanupContext(@as(*const ITfCleanupContextSink, @ptrCast(self)), ecWrite, pic);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfCleanupContextDurationSink_Value = Guid.initString("45c35144-154e-4797-bed8-d33ae7bf8794");
pub const IID_ITfCleanupContextDurationSink = &IID_ITfCleanupContextDurationSink_Value;
pub const ITfCleanupContextDurationSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnStartCleanupContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfCleanupContextDurationSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfCleanupContextDurationSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnEndCleanupContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfCleanupContextDurationSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfCleanupContextDurationSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfCleanupContextDurationSink_OnStartCleanupContext(self: *const T) HRESULT {
                return @as(*const ITfCleanupContextDurationSink.VTable, @ptrCast(self.vtable)).OnStartCleanupContext(@as(*const ITfCleanupContextDurationSink, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfCleanupContextDurationSink_OnEndCleanupContext(self: *const T) HRESULT {
                return @as(*const ITfCleanupContextDurationSink.VTable, @ptrCast(self.vtable)).OnEndCleanupContext(@as(*const ITfCleanupContextDurationSink, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfReadOnlyProperty_Value = Guid.initString("17d49a3d-f8b8-4b2f-b254-52319dd64c53");
pub const IID_ITfReadOnlyProperty = &IID_ITfReadOnlyProperty_Value;
pub const ITfReadOnlyProperty = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfReadOnlyProperty,
                pguid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfReadOnlyProperty,
                pguid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumRanges: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfReadOnlyProperty,
                ec: u32,
                ppEnum: ?*?*IEnumTfRanges,
                pTargetRange: ?*ITfRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfReadOnlyProperty,
                ec: u32,
                ppEnum: ?*?*IEnumTfRanges,
                pTargetRange: ?*ITfRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfReadOnlyProperty,
                ec: u32,
                pRange: ?*ITfRange,
                pvarValue: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfReadOnlyProperty,
                ec: u32,
                pRange: ?*ITfRange,
                pvarValue: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfReadOnlyProperty,
                ppContext: ?*?*ITfContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfReadOnlyProperty,
                ppContext: ?*?*ITfContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfReadOnlyProperty_GetType(self: *const T, pguid: ?*Guid) HRESULT {
                return @as(*const ITfReadOnlyProperty.VTable, @ptrCast(self.vtable)).GetType(@as(*const ITfReadOnlyProperty, @ptrCast(self)), pguid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfReadOnlyProperty_EnumRanges(self: *const T, ec: u32, ppEnum: ?*?*IEnumTfRanges, pTargetRange: ?*ITfRange) HRESULT {
                return @as(*const ITfReadOnlyProperty.VTable, @ptrCast(self.vtable)).EnumRanges(@as(*const ITfReadOnlyProperty, @ptrCast(self)), ec, ppEnum, pTargetRange);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfReadOnlyProperty_GetValue(self: *const T, ec: u32, pRange: ?*ITfRange, pvarValue: ?*VARIANT) HRESULT {
                return @as(*const ITfReadOnlyProperty.VTable, @ptrCast(self.vtable)).GetValue(@as(*const ITfReadOnlyProperty, @ptrCast(self)), ec, pRange, pvarValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfReadOnlyProperty_GetContext(self: *const T, ppContext: ?*?*ITfContext) HRESULT {
                return @as(*const ITfReadOnlyProperty.VTable, @ptrCast(self.vtable)).GetContext(@as(*const ITfReadOnlyProperty, @ptrCast(self)), ppContext);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const TF_PROPERTYVAL = extern struct {
    guidId: Guid,
    varValue: VARIANT,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumTfPropertyValue_Value = Guid.initString("8ed8981b-7c10-4d7d-9fb3-ab72e9c75f72");
pub const IID_IEnumTfPropertyValue = &IID_IEnumTfPropertyValue_Value;
pub const IEnumTfPropertyValue = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumTfPropertyValue,
                ppEnum: ?*?*IEnumTfPropertyValue,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumTfPropertyValue,
                ppEnum: ?*?*IEnumTfPropertyValue,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumTfPropertyValue,
                ulCount: u32,
                rgValues: [*]TF_PROPERTYVAL,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumTfPropertyValue,
                ulCount: u32,
                rgValues: [*]TF_PROPERTYVAL,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumTfPropertyValue,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumTfPropertyValue,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumTfPropertyValue,
                ulCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumTfPropertyValue,
                ulCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumTfPropertyValue_Clone(self: *const T, ppEnum: ?*?*IEnumTfPropertyValue) HRESULT {
                return @as(*const IEnumTfPropertyValue.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumTfPropertyValue, @ptrCast(self)), ppEnum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumTfPropertyValue_Next(self: *const T, ulCount: u32, rgValues: [*]TF_PROPERTYVAL, pcFetched: ?*u32) HRESULT {
                return @as(*const IEnumTfPropertyValue.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumTfPropertyValue, @ptrCast(self)), ulCount, rgValues, pcFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumTfPropertyValue_Reset(self: *const T) HRESULT {
                return @as(*const IEnumTfPropertyValue.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumTfPropertyValue, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumTfPropertyValue_Skip(self: *const T, ulCount: u32) HRESULT {
                return @as(*const IEnumTfPropertyValue.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumTfPropertyValue, @ptrCast(self)), ulCount);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfMouseTracker_Value = Guid.initString("09d146cd-a544-4132-925b-7afa8ef322d0");
pub const IID_ITfMouseTracker = &IID_ITfMouseTracker_Value;
pub const ITfMouseTracker = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AdviseMouseSink: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfMouseTracker,
                range: ?*ITfRange,
                pSink: ?*ITfMouseSink,
                pdwCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfMouseTracker,
                range: ?*ITfRange,
                pSink: ?*ITfMouseSink,
                pdwCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnadviseMouseSink: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfMouseTracker,
                dwCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfMouseTracker,
                dwCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfMouseTracker_AdviseMouseSink(self: *const T, range: ?*ITfRange, pSink: ?*ITfMouseSink, pdwCookie: ?*u32) HRESULT {
                return @as(*const ITfMouseTracker.VTable, @ptrCast(self.vtable)).AdviseMouseSink(@as(*const ITfMouseTracker, @ptrCast(self)), range, pSink, pdwCookie);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfMouseTracker_UnadviseMouseSink(self: *const T, dwCookie: u32) HRESULT {
                return @as(*const ITfMouseTracker.VTable, @ptrCast(self.vtable)).UnadviseMouseSink(@as(*const ITfMouseTracker, @ptrCast(self)), dwCookie);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfMouseTrackerACP_Value = Guid.initString("3bdd78e2-c16e-47fd-b883-ce6facc1a208");
pub const IID_ITfMouseTrackerACP = &IID_ITfMouseTrackerACP_Value;
pub const ITfMouseTrackerACP = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AdviseMouseSink: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfMouseTrackerACP,
                range: ?*ITfRangeACP,
                pSink: ?*ITfMouseSink,
                pdwCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfMouseTrackerACP,
                range: ?*ITfRangeACP,
                pSink: ?*ITfMouseSink,
                pdwCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnadviseMouseSink: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfMouseTrackerACP,
                dwCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfMouseTrackerACP,
                dwCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfMouseTrackerACP_AdviseMouseSink(self: *const T, range: ?*ITfRangeACP, pSink: ?*ITfMouseSink, pdwCookie: ?*u32) HRESULT {
                return @as(*const ITfMouseTrackerACP.VTable, @ptrCast(self.vtable)).AdviseMouseSink(@as(*const ITfMouseTrackerACP, @ptrCast(self)), range, pSink, pdwCookie);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfMouseTrackerACP_UnadviseMouseSink(self: *const T, dwCookie: u32) HRESULT {
                return @as(*const ITfMouseTrackerACP.VTable, @ptrCast(self.vtable)).UnadviseMouseSink(@as(*const ITfMouseTrackerACP, @ptrCast(self)), dwCookie);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfMouseSink_Value = Guid.initString("a1adaaa2-3a24-449d-ac96-5183e7f5c217");
pub const IID_ITfMouseSink = &IID_ITfMouseSink_Value;
pub const ITfMouseSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnMouseEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfMouseSink,
                uEdge: u32,
                uQuadrant: u32,
                dwBtnStatus: u32,
                pfEaten: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfMouseSink,
                uEdge: u32,
                uQuadrant: u32,
                dwBtnStatus: u32,
                pfEaten: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfMouseSink_OnMouseEvent(self: *const T, uEdge: u32, uQuadrant: u32, dwBtnStatus: u32, pfEaten: ?*BOOL) HRESULT {
                return @as(*const ITfMouseSink.VTable, @ptrCast(self.vtable)).OnMouseEvent(@as(*const ITfMouseSink, @ptrCast(self)), uEdge, uQuadrant, dwBtnStatus, pfEaten);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfEditRecord_Value = Guid.initString("42d4d099-7c1a-4a89-b836-6c6f22160df0");
pub const IID_ITfEditRecord = &IID_ITfEditRecord_Value;
pub const ITfEditRecord = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSelectionStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfEditRecord,
                pfChanged: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfEditRecord,
                pfChanged: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTextAndPropertyUpdates: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfEditRecord,
                dwFlags: GET_TEXT_AND_PROPERTY_UPDATES_FLAGS,
                prgProperties: [*]const ?*const Guid,
                cProperties: u32,
                ppEnum: ?*?*IEnumTfRanges,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfEditRecord,
                dwFlags: GET_TEXT_AND_PROPERTY_UPDATES_FLAGS,
                prgProperties: [*]const ?*const Guid,
                cProperties: u32,
                ppEnum: ?*?*IEnumTfRanges,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfEditRecord_GetSelectionStatus(self: *const T, pfChanged: ?*BOOL) HRESULT {
                return @as(*const ITfEditRecord.VTable, @ptrCast(self.vtable)).GetSelectionStatus(@as(*const ITfEditRecord, @ptrCast(self)), pfChanged);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfEditRecord_GetTextAndPropertyUpdates(self: *const T, dwFlags: GET_TEXT_AND_PROPERTY_UPDATES_FLAGS, prgProperties: [*]const ?*const Guid, cProperties: u32, ppEnum: ?*?*IEnumTfRanges) HRESULT {
                return @as(*const ITfEditRecord.VTable, @ptrCast(self.vtable)).GetTextAndPropertyUpdates(@as(*const ITfEditRecord, @ptrCast(self)), dwFlags, prgProperties, cProperties, ppEnum);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfTextEditSink_Value = Guid.initString("8127d409-ccd3-4683-967a-b43d5b482bf7");
pub const IID_ITfTextEditSink = &IID_ITfTextEditSink_Value;
pub const ITfTextEditSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnEndEdit: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfTextEditSink,
                pic: ?*ITfContext,
                ecReadOnly: u32,
                pEditRecord: ?*ITfEditRecord,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfTextEditSink,
                pic: ?*ITfContext,
                ecReadOnly: u32,
                pEditRecord: ?*ITfEditRecord,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfTextEditSink_OnEndEdit(self: *const T, pic: ?*ITfContext, ecReadOnly: u32, pEditRecord: ?*ITfEditRecord) HRESULT {
                return @as(*const ITfTextEditSink.VTable, @ptrCast(self.vtable)).OnEndEdit(@as(*const ITfTextEditSink, @ptrCast(self)), pic, ecReadOnly, pEditRecord);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const TfLayoutCode = enum(i32) {
    CREATE = 0,
    CHANGE = 1,
    DESTROY = 2,
};
pub const TF_LC_CREATE = TfLayoutCode.CREATE;
pub const TF_LC_CHANGE = TfLayoutCode.CHANGE;
pub const TF_LC_DESTROY = TfLayoutCode.DESTROY;

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfTextLayoutSink_Value = Guid.initString("2af2d06a-dd5b-4927-a0b4-54f19c91fade");
pub const IID_ITfTextLayoutSink = &IID_ITfTextLayoutSink_Value;
pub const ITfTextLayoutSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnLayoutChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfTextLayoutSink,
                pic: ?*ITfContext,
                lcode: TfLayoutCode,
                pView: ?*ITfContextView,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfTextLayoutSink,
                pic: ?*ITfContext,
                lcode: TfLayoutCode,
                pView: ?*ITfContextView,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfTextLayoutSink_OnLayoutChange(self: *const T, pic: ?*ITfContext, lcode: TfLayoutCode, pView: ?*ITfContextView) HRESULT {
                return @as(*const ITfTextLayoutSink.VTable, @ptrCast(self.vtable)).OnLayoutChange(@as(*const ITfTextLayoutSink, @ptrCast(self)), pic, lcode, pView);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfStatusSink_Value = Guid.initString("6b7d8d73-b267-4f69-b32e-1ca321ce4f45");
pub const IID_ITfStatusSink = &IID_ITfStatusSink_Value;
pub const ITfStatusSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnStatusChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfStatusSink,
                pic: ?*ITfContext,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfStatusSink,
                pic: ?*ITfContext,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfStatusSink_OnStatusChange(self: *const T, pic: ?*ITfContext, dwFlags: u32) HRESULT {
                return @as(*const ITfStatusSink.VTable, @ptrCast(self.vtable)).OnStatusChange(@as(*const ITfStatusSink, @ptrCast(self)), pic, dwFlags);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfEditTransactionSink_Value = Guid.initString("708fbf70-b520-416b-b06c-2c41ab44f8ba");
pub const IID_ITfEditTransactionSink = &IID_ITfEditTransactionSink_Value;
pub const ITfEditTransactionSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnStartEditTransaction: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfEditTransactionSink,
                pic: ?*ITfContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfEditTransactionSink,
                pic: ?*ITfContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnEndEditTransaction: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfEditTransactionSink,
                pic: ?*ITfContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfEditTransactionSink,
                pic: ?*ITfContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfEditTransactionSink_OnStartEditTransaction(self: *const T, pic: ?*ITfContext) HRESULT {
                return @as(*const ITfEditTransactionSink.VTable, @ptrCast(self.vtable)).OnStartEditTransaction(@as(*const ITfEditTransactionSink, @ptrCast(self)), pic);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfEditTransactionSink_OnEndEditTransaction(self: *const T, pic: ?*ITfContext) HRESULT {
                return @as(*const ITfEditTransactionSink.VTable, @ptrCast(self.vtable)).OnEndEditTransaction(@as(*const ITfEditTransactionSink, @ptrCast(self)), pic);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfContextOwner_Value = Guid.initString("aa80e80c-2021-11d2-93e0-0060b067b86e");
pub const IID_ITfContextOwner = &IID_ITfContextOwner_Value;
pub const ITfContextOwner = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetACPFromPoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfContextOwner,
                ptScreen: ?*const POINT,
                dwFlags: u32,
                pacp: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfContextOwner,
                ptScreen: ?*const POINT,
                dwFlags: u32,
                pacp: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTextExt: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfContextOwner,
                acpStart: i32,
                acpEnd: i32,
                prc: ?*RECT,
                pfClipped: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfContextOwner,
                acpStart: i32,
                acpEnd: i32,
                prc: ?*RECT,
                pfClipped: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetScreenExt: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfContextOwner,
                prc: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfContextOwner,
                prc: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfContextOwner,
                pdcs: ?*TS_STATUS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfContextOwner,
                pdcs: ?*TS_STATUS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetWnd: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfContextOwner,
                phwnd: ?*?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfContextOwner,
                phwnd: ?*?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAttribute: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfContextOwner,
                rguidAttribute: ?*const Guid,
                pvarValue: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfContextOwner,
                rguidAttribute: ?*const Guid,
                pvarValue: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfContextOwner_GetACPFromPoint(self: *const T, ptScreen: ?*const POINT, dwFlags: u32, pacp: ?*i32) HRESULT {
                return @as(*const ITfContextOwner.VTable, @ptrCast(self.vtable)).GetACPFromPoint(@as(*const ITfContextOwner, @ptrCast(self)), ptScreen, dwFlags, pacp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfContextOwner_GetTextExt(self: *const T, acpStart: i32, acpEnd: i32, prc: ?*RECT, pfClipped: ?*BOOL) HRESULT {
                return @as(*const ITfContextOwner.VTable, @ptrCast(self.vtable)).GetTextExt(@as(*const ITfContextOwner, @ptrCast(self)), acpStart, acpEnd, prc, pfClipped);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfContextOwner_GetScreenExt(self: *const T, prc: ?*RECT) HRESULT {
                return @as(*const ITfContextOwner.VTable, @ptrCast(self.vtable)).GetScreenExt(@as(*const ITfContextOwner, @ptrCast(self)), prc);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfContextOwner_GetStatus(self: *const T, pdcs: ?*TS_STATUS) HRESULT {
                return @as(*const ITfContextOwner.VTable, @ptrCast(self.vtable)).GetStatus(@as(*const ITfContextOwner, @ptrCast(self)), pdcs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfContextOwner_GetWnd(self: *const T, phwnd: ?*?HWND) HRESULT {
                return @as(*const ITfContextOwner.VTable, @ptrCast(self.vtable)).GetWnd(@as(*const ITfContextOwner, @ptrCast(self)), phwnd);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfContextOwner_GetAttribute(self: *const T, rguidAttribute: ?*const Guid, pvarValue: ?*VARIANT) HRESULT {
                return @as(*const ITfContextOwner.VTable, @ptrCast(self.vtable)).GetAttribute(@as(*const ITfContextOwner, @ptrCast(self)), rguidAttribute, pvarValue);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfContextOwnerServices_Value = Guid.initString("b23eb630-3e1c-11d3-a745-0050040ab407");
pub const IID_ITfContextOwnerServices = &IID_ITfContextOwnerServices_Value;
pub const ITfContextOwnerServices = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnLayoutChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfContextOwnerServices,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfContextOwnerServices,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnStatusChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfContextOwnerServices,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfContextOwnerServices,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnAttributeChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfContextOwnerServices,
                rguidAttribute: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfContextOwnerServices,
                rguidAttribute: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Serialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfContextOwnerServices,
                pProp: ?*ITfProperty,
                pRange: ?*ITfRange,
                pHdr: ?*TF_PERSISTENT_PROPERTY_HEADER_ACP,
                pStream: ?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfContextOwnerServices,
                pProp: ?*ITfProperty,
                pRange: ?*ITfRange,
                pHdr: ?*TF_PERSISTENT_PROPERTY_HEADER_ACP,
                pStream: ?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Unserialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfContextOwnerServices,
                pProp: ?*ITfProperty,
                pHdr: ?*const TF_PERSISTENT_PROPERTY_HEADER_ACP,
                pStream: ?*IStream,
                pLoader: ?*ITfPersistentPropertyLoaderACP,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfContextOwnerServices,
                pProp: ?*ITfProperty,
                pHdr: ?*const TF_PERSISTENT_PROPERTY_HEADER_ACP,
                pStream: ?*IStream,
                pLoader: ?*ITfPersistentPropertyLoaderACP,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ForceLoadProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfContextOwnerServices,
                pProp: ?*ITfProperty,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfContextOwnerServices,
                pProp: ?*ITfProperty,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateRange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfContextOwnerServices,
                acpStart: i32,
                acpEnd: i32,
                ppRange: ?*?*ITfRangeACP,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfContextOwnerServices,
                acpStart: i32,
                acpEnd: i32,
                ppRange: ?*?*ITfRangeACP,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfContextOwnerServices_OnLayoutChange(self: *const T) HRESULT {
                return @as(*const ITfContextOwnerServices.VTable, @ptrCast(self.vtable)).OnLayoutChange(@as(*const ITfContextOwnerServices, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfContextOwnerServices_OnStatusChange(self: *const T, dwFlags: u32) HRESULT {
                return @as(*const ITfContextOwnerServices.VTable, @ptrCast(self.vtable)).OnStatusChange(@as(*const ITfContextOwnerServices, @ptrCast(self)), dwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfContextOwnerServices_OnAttributeChange(self: *const T, rguidAttribute: ?*const Guid) HRESULT {
                return @as(*const ITfContextOwnerServices.VTable, @ptrCast(self.vtable)).OnAttributeChange(@as(*const ITfContextOwnerServices, @ptrCast(self)), rguidAttribute);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfContextOwnerServices_Serialize(self: *const T, pProp: ?*ITfProperty, pRange: ?*ITfRange, pHdr: ?*TF_PERSISTENT_PROPERTY_HEADER_ACP, pStream: ?*IStream) HRESULT {
                return @as(*const ITfContextOwnerServices.VTable, @ptrCast(self.vtable)).Serialize(@as(*const ITfContextOwnerServices, @ptrCast(self)), pProp, pRange, pHdr, pStream);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfContextOwnerServices_Unserialize(self: *const T, pProp: ?*ITfProperty, pHdr: ?*const TF_PERSISTENT_PROPERTY_HEADER_ACP, pStream: ?*IStream, pLoader: ?*ITfPersistentPropertyLoaderACP) HRESULT {
                return @as(*const ITfContextOwnerServices.VTable, @ptrCast(self.vtable)).Unserialize(@as(*const ITfContextOwnerServices, @ptrCast(self)), pProp, pHdr, pStream, pLoader);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfContextOwnerServices_ForceLoadProperty(self: *const T, pProp: ?*ITfProperty) HRESULT {
                return @as(*const ITfContextOwnerServices.VTable, @ptrCast(self.vtable)).ForceLoadProperty(@as(*const ITfContextOwnerServices, @ptrCast(self)), pProp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfContextOwnerServices_CreateRange(self: *const T, acpStart: i32, acpEnd: i32, ppRange: ?*?*ITfRangeACP) HRESULT {
                return @as(*const ITfContextOwnerServices.VTable, @ptrCast(self.vtable)).CreateRange(@as(*const ITfContextOwnerServices, @ptrCast(self)), acpStart, acpEnd, ppRange);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfContextKeyEventSink_Value = Guid.initString("0552ba5d-c835-4934-bf50-846aaa67432f");
pub const IID_ITfContextKeyEventSink = &IID_ITfContextKeyEventSink_Value;
pub const ITfContextKeyEventSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnKeyDown: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfContextKeyEventSink,
                wParam: WPARAM,
                lParam: LPARAM,
                pfEaten: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfContextKeyEventSink,
                wParam: WPARAM,
                lParam: LPARAM,
                pfEaten: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnKeyUp: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfContextKeyEventSink,
                wParam: WPARAM,
                lParam: LPARAM,
                pfEaten: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfContextKeyEventSink,
                wParam: WPARAM,
                lParam: LPARAM,
                pfEaten: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnTestKeyDown: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfContextKeyEventSink,
                wParam: WPARAM,
                lParam: LPARAM,
                pfEaten: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfContextKeyEventSink,
                wParam: WPARAM,
                lParam: LPARAM,
                pfEaten: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnTestKeyUp: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfContextKeyEventSink,
                wParam: WPARAM,
                lParam: LPARAM,
                pfEaten: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfContextKeyEventSink,
                wParam: WPARAM,
                lParam: LPARAM,
                pfEaten: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfContextKeyEventSink_OnKeyDown(self: *const T, wParam: WPARAM, lParam: LPARAM, pfEaten: ?*BOOL) HRESULT {
                return @as(*const ITfContextKeyEventSink.VTable, @ptrCast(self.vtable)).OnKeyDown(@as(*const ITfContextKeyEventSink, @ptrCast(self)), wParam, lParam, pfEaten);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfContextKeyEventSink_OnKeyUp(self: *const T, wParam: WPARAM, lParam: LPARAM, pfEaten: ?*BOOL) HRESULT {
                return @as(*const ITfContextKeyEventSink.VTable, @ptrCast(self.vtable)).OnKeyUp(@as(*const ITfContextKeyEventSink, @ptrCast(self)), wParam, lParam, pfEaten);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfContextKeyEventSink_OnTestKeyDown(self: *const T, wParam: WPARAM, lParam: LPARAM, pfEaten: ?*BOOL) HRESULT {
                return @as(*const ITfContextKeyEventSink.VTable, @ptrCast(self.vtable)).OnTestKeyDown(@as(*const ITfContextKeyEventSink, @ptrCast(self)), wParam, lParam, pfEaten);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfContextKeyEventSink_OnTestKeyUp(self: *const T, wParam: WPARAM, lParam: LPARAM, pfEaten: ?*BOOL) HRESULT {
                return @as(*const ITfContextKeyEventSink.VTable, @ptrCast(self.vtable)).OnTestKeyUp(@as(*const ITfContextKeyEventSink, @ptrCast(self)), wParam, lParam, pfEaten);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfEditSession_Value = Guid.initString("aa80e803-2021-11d2-93e0-0060b067b86e");
pub const IID_ITfEditSession = &IID_ITfEditSession_Value;
pub const ITfEditSession = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        DoEditSession: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfEditSession,
                ec: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfEditSession,
                ec: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfEditSession_DoEditSession(self: *const T, ec: u32) HRESULT {
                return @as(*const ITfEditSession.VTable, @ptrCast(self.vtable)).DoEditSession(@as(*const ITfEditSession, @ptrCast(self)), ec);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const TfGravity = enum(i32) {
    BACKWARD = 0,
    FORWARD = 1,
};
pub const TF_GRAVITY_BACKWARD = TfGravity.BACKWARD;
pub const TF_GRAVITY_FORWARD = TfGravity.FORWARD;

pub const TfShiftDir = enum(i32) {
    BACKWARD = 0,
    FORWARD = 1,
};
pub const TF_SD_BACKWARD = TfShiftDir.BACKWARD;
pub const TF_SD_FORWARD = TfShiftDir.FORWARD;

pub const TF_HALTCOND = extern struct {
    pHaltRange: ?*ITfRange,
    aHaltPos: TfAnchor,
    dwFlags: u32,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfRange_Value = Guid.initString("aa80e7ff-2021-11d2-93e0-0060b067b86e");
pub const IID_ITfRange = &IID_ITfRange_Value;
pub const ITfRange = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfRange,
                ec: u32,
                dwFlags: u32,
                pchText: [*:0]u16,
                cchMax: u32,
                pcch: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfRange,
                ec: u32,
                dwFlags: u32,
                pchText: [*:0]u16,
                cchMax: u32,
                pcch: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfRange,
                ec: u32,
                dwFlags: u32,
                pchText: [*:0]const u16,
                cch: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfRange,
                ec: u32,
                dwFlags: u32,
                pchText: [*:0]const u16,
                cch: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFormattedText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfRange,
                ec: u32,
                ppDataObject: ?*?*IDataObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfRange,
                ec: u32,
                ppDataObject: ?*?*IDataObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEmbedded: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfRange,
                ec: u32,
                rguidService: ?*const Guid,
                riid: ?*const Guid,
                ppunk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfRange,
                ec: u32,
                rguidService: ?*const Guid,
                riid: ?*const Guid,
                ppunk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InsertEmbedded: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfRange,
                ec: u32,
                dwFlags: u32,
                pDataObject: ?*IDataObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfRange,
                ec: u32,
                dwFlags: u32,
                pDataObject: ?*IDataObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ShiftStart: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfRange,
                ec: u32,
                cchReq: i32,
                pcch: ?*i32,
                pHalt: ?*const TF_HALTCOND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfRange,
                ec: u32,
                cchReq: i32,
                pcch: ?*i32,
                pHalt: ?*const TF_HALTCOND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ShiftEnd: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfRange,
                ec: u32,
                cchReq: i32,
                pcch: ?*i32,
                pHalt: ?*const TF_HALTCOND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfRange,
                ec: u32,
                cchReq: i32,
                pcch: ?*i32,
                pHalt: ?*const TF_HALTCOND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ShiftStartToRange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfRange,
                ec: u32,
                pRange: ?*ITfRange,
                aPos: TfAnchor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfRange,
                ec: u32,
                pRange: ?*ITfRange,
                aPos: TfAnchor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ShiftEndToRange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfRange,
                ec: u32,
                pRange: ?*ITfRange,
                aPos: TfAnchor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfRange,
                ec: u32,
                pRange: ?*ITfRange,
                aPos: TfAnchor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ShiftStartRegion: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfRange,
                ec: u32,
                dir: TfShiftDir,
                pfNoRegion: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfRange,
                ec: u32,
                dir: TfShiftDir,
                pfNoRegion: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ShiftEndRegion: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfRange,
                ec: u32,
                dir: TfShiftDir,
                pfNoRegion: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfRange,
                ec: u32,
                dir: TfShiftDir,
                pfNoRegion: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsEmpty: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfRange,
                ec: u32,
                pfEmpty: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfRange,
                ec: u32,
                pfEmpty: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Collapse: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfRange,
                ec: u32,
                aPos: TfAnchor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfRange,
                ec: u32,
                aPos: TfAnchor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsEqualStart: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfRange,
                ec: u32,
                pWith: ?*ITfRange,
                aPos: TfAnchor,
                pfEqual: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfRange,
                ec: u32,
                pWith: ?*ITfRange,
                aPos: TfAnchor,
                pfEqual: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsEqualEnd: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfRange,
                ec: u32,
                pWith: ?*ITfRange,
                aPos: TfAnchor,
                pfEqual: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfRange,
                ec: u32,
                pWith: ?*ITfRange,
                aPos: TfAnchor,
                pfEqual: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CompareStart: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfRange,
                ec: u32,
                pWith: ?*ITfRange,
                aPos: TfAnchor,
                plResult: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfRange,
                ec: u32,
                pWith: ?*ITfRange,
                aPos: TfAnchor,
                plResult: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CompareEnd: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfRange,
                ec: u32,
                pWith: ?*ITfRange,
                aPos: TfAnchor,
                plResult: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfRange,
                ec: u32,
                pWith: ?*ITfRange,
                aPos: TfAnchor,
                plResult: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AdjustForInsert: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfRange,
                ec: u32,
                cchInsert: u32,
                pfInsertOk: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfRange,
                ec: u32,
                cchInsert: u32,
                pfInsertOk: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetGravity: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfRange,
                pgStart: ?*TfGravity,
                pgEnd: ?*TfGravity,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfRange,
                pgStart: ?*TfGravity,
                pgEnd: ?*TfGravity,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetGravity: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfRange,
                ec: u32,
                gStart: TfGravity,
                gEnd: TfGravity,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfRange,
                ec: u32,
                gStart: TfGravity,
                gEnd: TfGravity,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfRange,
                ppClone: ?*?*ITfRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfRange,
                ppClone: ?*?*ITfRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfRange,
                ppContext: ?*?*ITfContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfRange,
                ppContext: ?*?*ITfContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfRange_GetText(self: *const T, ec: u32, dwFlags: u32, pchText: [*:0]u16, cchMax: u32, pcch: ?*u32) HRESULT {
                return @as(*const ITfRange.VTable, @ptrCast(self.vtable)).GetText(@as(*const ITfRange, @ptrCast(self)), ec, dwFlags, pchText, cchMax, pcch);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfRange_SetText(self: *const T, ec: u32, dwFlags: u32, pchText: [*:0]const u16, cch: i32) HRESULT {
                return @as(*const ITfRange.VTable, @ptrCast(self.vtable)).SetText(@as(*const ITfRange, @ptrCast(self)), ec, dwFlags, pchText, cch);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfRange_GetFormattedText(self: *const T, ec: u32, ppDataObject: ?*?*IDataObject) HRESULT {
                return @as(*const ITfRange.VTable, @ptrCast(self.vtable)).GetFormattedText(@as(*const ITfRange, @ptrCast(self)), ec, ppDataObject);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfRange_GetEmbedded(self: *const T, ec: u32, rguidService: ?*const Guid, riid: ?*const Guid, ppunk: ?*?*IUnknown) HRESULT {
                return @as(*const ITfRange.VTable, @ptrCast(self.vtable)).GetEmbedded(@as(*const ITfRange, @ptrCast(self)), ec, rguidService, riid, ppunk);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfRange_InsertEmbedded(self: *const T, ec: u32, dwFlags: u32, pDataObject: ?*IDataObject) HRESULT {
                return @as(*const ITfRange.VTable, @ptrCast(self.vtable)).InsertEmbedded(@as(*const ITfRange, @ptrCast(self)), ec, dwFlags, pDataObject);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfRange_ShiftStart(self: *const T, ec: u32, cchReq: i32, pcch: ?*i32, pHalt: ?*const TF_HALTCOND) HRESULT {
                return @as(*const ITfRange.VTable, @ptrCast(self.vtable)).ShiftStart(@as(*const ITfRange, @ptrCast(self)), ec, cchReq, pcch, pHalt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfRange_ShiftEnd(self: *const T, ec: u32, cchReq: i32, pcch: ?*i32, pHalt: ?*const TF_HALTCOND) HRESULT {
                return @as(*const ITfRange.VTable, @ptrCast(self.vtable)).ShiftEnd(@as(*const ITfRange, @ptrCast(self)), ec, cchReq, pcch, pHalt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfRange_ShiftStartToRange(self: *const T, ec: u32, pRange: ?*ITfRange, aPos: TfAnchor) HRESULT {
                return @as(*const ITfRange.VTable, @ptrCast(self.vtable)).ShiftStartToRange(@as(*const ITfRange, @ptrCast(self)), ec, pRange, aPos);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfRange_ShiftEndToRange(self: *const T, ec: u32, pRange: ?*ITfRange, aPos: TfAnchor) HRESULT {
                return @as(*const ITfRange.VTable, @ptrCast(self.vtable)).ShiftEndToRange(@as(*const ITfRange, @ptrCast(self)), ec, pRange, aPos);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfRange_ShiftStartRegion(self: *const T, ec: u32, dir: TfShiftDir, pfNoRegion: ?*BOOL) HRESULT {
                return @as(*const ITfRange.VTable, @ptrCast(self.vtable)).ShiftStartRegion(@as(*const ITfRange, @ptrCast(self)), ec, dir, pfNoRegion);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfRange_ShiftEndRegion(self: *const T, ec: u32, dir: TfShiftDir, pfNoRegion: ?*BOOL) HRESULT {
                return @as(*const ITfRange.VTable, @ptrCast(self.vtable)).ShiftEndRegion(@as(*const ITfRange, @ptrCast(self)), ec, dir, pfNoRegion);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfRange_IsEmpty(self: *const T, ec: u32, pfEmpty: ?*BOOL) HRESULT {
                return @as(*const ITfRange.VTable, @ptrCast(self.vtable)).IsEmpty(@as(*const ITfRange, @ptrCast(self)), ec, pfEmpty);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfRange_Collapse(self: *const T, ec: u32, aPos: TfAnchor) HRESULT {
                return @as(*const ITfRange.VTable, @ptrCast(self.vtable)).Collapse(@as(*const ITfRange, @ptrCast(self)), ec, aPos);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfRange_IsEqualStart(self: *const T, ec: u32, pWith: ?*ITfRange, aPos: TfAnchor, pfEqual: ?*BOOL) HRESULT {
                return @as(*const ITfRange.VTable, @ptrCast(self.vtable)).IsEqualStart(@as(*const ITfRange, @ptrCast(self)), ec, pWith, aPos, pfEqual);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfRange_IsEqualEnd(self: *const T, ec: u32, pWith: ?*ITfRange, aPos: TfAnchor, pfEqual: ?*BOOL) HRESULT {
                return @as(*const ITfRange.VTable, @ptrCast(self.vtable)).IsEqualEnd(@as(*const ITfRange, @ptrCast(self)), ec, pWith, aPos, pfEqual);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfRange_CompareStart(self: *const T, ec: u32, pWith: ?*ITfRange, aPos: TfAnchor, plResult: ?*i32) HRESULT {
                return @as(*const ITfRange.VTable, @ptrCast(self.vtable)).CompareStart(@as(*const ITfRange, @ptrCast(self)), ec, pWith, aPos, plResult);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfRange_CompareEnd(self: *const T, ec: u32, pWith: ?*ITfRange, aPos: TfAnchor, plResult: ?*i32) HRESULT {
                return @as(*const ITfRange.VTable, @ptrCast(self.vtable)).CompareEnd(@as(*const ITfRange, @ptrCast(self)), ec, pWith, aPos, plResult);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfRange_AdjustForInsert(self: *const T, ec: u32, cchInsert: u32, pfInsertOk: ?*BOOL) HRESULT {
                return @as(*const ITfRange.VTable, @ptrCast(self.vtable)).AdjustForInsert(@as(*const ITfRange, @ptrCast(self)), ec, cchInsert, pfInsertOk);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfRange_GetGravity(self: *const T, pgStart: ?*TfGravity, pgEnd: ?*TfGravity) HRESULT {
                return @as(*const ITfRange.VTable, @ptrCast(self.vtable)).GetGravity(@as(*const ITfRange, @ptrCast(self)), pgStart, pgEnd);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfRange_SetGravity(self: *const T, ec: u32, gStart: TfGravity, gEnd: TfGravity) HRESULT {
                return @as(*const ITfRange.VTable, @ptrCast(self.vtable)).SetGravity(@as(*const ITfRange, @ptrCast(self)), ec, gStart, gEnd);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfRange_Clone(self: *const T, ppClone: ?*?*ITfRange) HRESULT {
                return @as(*const ITfRange.VTable, @ptrCast(self.vtable)).Clone(@as(*const ITfRange, @ptrCast(self)), ppClone);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfRange_GetContext(self: *const T, ppContext: ?*?*ITfContext) HRESULT {
                return @as(*const ITfRange.VTable, @ptrCast(self.vtable)).GetContext(@as(*const ITfRange, @ptrCast(self)), ppContext);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfRangeACP_Value = Guid.initString("057a6296-029b-4154-b79a-0d461d4ea94c");
pub const IID_ITfRangeACP = &IID_ITfRangeACP_Value;
pub const ITfRangeACP = extern struct {
    pub const VTable = extern struct {
        base: ITfRange.VTable,
        GetExtent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfRangeACP,
                pacpAnchor: ?*i32,
                pcch: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfRangeACP,
                pacpAnchor: ?*i32,
                pcch: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetExtent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfRangeACP,
                acpAnchor: i32,
                cch: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfRangeACP,
                acpAnchor: i32,
                cch: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITfRange.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfRangeACP_GetExtent(self: *const T, pacpAnchor: ?*i32, pcch: ?*i32) HRESULT {
                return @as(*const ITfRangeACP.VTable, @ptrCast(self.vtable)).GetExtent(@as(*const ITfRangeACP, @ptrCast(self)), pacpAnchor, pcch);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfRangeACP_SetExtent(self: *const T, acpAnchor: i32, cch: i32) HRESULT {
                return @as(*const ITfRangeACP.VTable, @ptrCast(self.vtable)).SetExtent(@as(*const ITfRangeACP, @ptrCast(self)), acpAnchor, cch);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITextStoreACPServices_Value = Guid.initString("aa80e901-2021-11d2-93e0-0060b067b86e");
pub const IID_ITextStoreACPServices = &IID_ITextStoreACPServices_Value;
pub const ITextStoreACPServices = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Serialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreACPServices,
                pProp: ?*ITfProperty,
                pRange: ?*ITfRange,
                pHdr: ?*TF_PERSISTENT_PROPERTY_HEADER_ACP,
                pStream: ?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreACPServices,
                pProp: ?*ITfProperty,
                pRange: ?*ITfRange,
                pHdr: ?*TF_PERSISTENT_PROPERTY_HEADER_ACP,
                pStream: ?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Unserialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreACPServices,
                pProp: ?*ITfProperty,
                pHdr: ?*const TF_PERSISTENT_PROPERTY_HEADER_ACP,
                pStream: ?*IStream,
                pLoader: ?*ITfPersistentPropertyLoaderACP,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreACPServices,
                pProp: ?*ITfProperty,
                pHdr: ?*const TF_PERSISTENT_PROPERTY_HEADER_ACP,
                pStream: ?*IStream,
                pLoader: ?*ITfPersistentPropertyLoaderACP,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ForceLoadProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreACPServices,
                pProp: ?*ITfProperty,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreACPServices,
                pProp: ?*ITfProperty,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateRange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreACPServices,
                acpStart: i32,
                acpEnd: i32,
                ppRange: ?*?*ITfRangeACP,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreACPServices,
                acpStart: i32,
                acpEnd: i32,
                ppRange: ?*?*ITfRangeACP,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreACPServices_Serialize(self: *const T, pProp: ?*ITfProperty, pRange: ?*ITfRange, pHdr: ?*TF_PERSISTENT_PROPERTY_HEADER_ACP, pStream: ?*IStream) HRESULT {
                return @as(*const ITextStoreACPServices.VTable, @ptrCast(self.vtable)).Serialize(@as(*const ITextStoreACPServices, @ptrCast(self)), pProp, pRange, pHdr, pStream);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreACPServices_Unserialize(self: *const T, pProp: ?*ITfProperty, pHdr: ?*const TF_PERSISTENT_PROPERTY_HEADER_ACP, pStream: ?*IStream, pLoader: ?*ITfPersistentPropertyLoaderACP) HRESULT {
                return @as(*const ITextStoreACPServices.VTable, @ptrCast(self.vtable)).Unserialize(@as(*const ITextStoreACPServices, @ptrCast(self)), pProp, pHdr, pStream, pLoader);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreACPServices_ForceLoadProperty(self: *const T, pProp: ?*ITfProperty) HRESULT {
                return @as(*const ITextStoreACPServices.VTable, @ptrCast(self.vtable)).ForceLoadProperty(@as(*const ITextStoreACPServices, @ptrCast(self)), pProp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreACPServices_CreateRange(self: *const T, acpStart: i32, acpEnd: i32, ppRange: ?*?*ITfRangeACP) HRESULT {
                return @as(*const ITextStoreACPServices.VTable, @ptrCast(self.vtable)).CreateRange(@as(*const ITextStoreACPServices, @ptrCast(self)), acpStart, acpEnd, ppRange);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfRangeBackup_Value = Guid.initString("463a506d-6992-49d2-9b88-93d55e70bb16");
pub const IID_ITfRangeBackup = &IID_ITfRangeBackup_Value;
pub const ITfRangeBackup = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Restore: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfRangeBackup,
                ec: u32,
                pRange: ?*ITfRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfRangeBackup,
                ec: u32,
                pRange: ?*ITfRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfRangeBackup_Restore(self: *const T, ec: u32, pRange: ?*ITfRange) HRESULT {
                return @as(*const ITfRangeBackup.VTable, @ptrCast(self.vtable)).Restore(@as(*const ITfRangeBackup, @ptrCast(self)), ec, pRange);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfPropertyStore_Value = Guid.initString("6834b120-88cb-11d2-bf45-00105a2799b5");
pub const IID_ITfPropertyStore = &IID_ITfPropertyStore_Value;
pub const ITfPropertyStore = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfPropertyStore,
                pguid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfPropertyStore,
                pguid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDataType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfPropertyStore,
                pdwReserved: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfPropertyStore,
                pdwReserved: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfPropertyStore,
                pvarValue: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfPropertyStore,
                pvarValue: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnTextUpdated: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfPropertyStore,
                dwFlags: u32,
                pRangeNew: ?*ITfRange,
                pfAccept: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfPropertyStore,
                dwFlags: u32,
                pRangeNew: ?*ITfRange,
                pfAccept: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Shrink: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfPropertyStore,
                pRangeNew: ?*ITfRange,
                pfFree: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfPropertyStore,
                pRangeNew: ?*ITfRange,
                pfFree: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Divide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfPropertyStore,
                pRangeThis: ?*ITfRange,
                pRangeNew: ?*ITfRange,
                ppPropStore: ?*?*ITfPropertyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfPropertyStore,
                pRangeThis: ?*ITfRange,
                pRangeNew: ?*ITfRange,
                ppPropStore: ?*?*ITfPropertyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfPropertyStore,
                pPropStore: ?*?*ITfPropertyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfPropertyStore,
                pPropStore: ?*?*ITfPropertyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPropertyRangeCreator: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfPropertyStore,
                pclsid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfPropertyStore,
                pclsid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Serialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfPropertyStore,
                pStream: ?*IStream,
                pcb: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfPropertyStore,
                pStream: ?*IStream,
                pcb: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfPropertyStore_GetType(self: *const T, pguid: ?*Guid) HRESULT {
                return @as(*const ITfPropertyStore.VTable, @ptrCast(self.vtable)).GetType(@as(*const ITfPropertyStore, @ptrCast(self)), pguid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfPropertyStore_GetDataType(self: *const T, pdwReserved: ?*u32) HRESULT {
                return @as(*const ITfPropertyStore.VTable, @ptrCast(self.vtable)).GetDataType(@as(*const ITfPropertyStore, @ptrCast(self)), pdwReserved);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfPropertyStore_GetData(self: *const T, pvarValue: ?*VARIANT) HRESULT {
                return @as(*const ITfPropertyStore.VTable, @ptrCast(self.vtable)).GetData(@as(*const ITfPropertyStore, @ptrCast(self)), pvarValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfPropertyStore_OnTextUpdated(self: *const T, dwFlags: u32, pRangeNew: ?*ITfRange, pfAccept: ?*BOOL) HRESULT {
                return @as(*const ITfPropertyStore.VTable, @ptrCast(self.vtable)).OnTextUpdated(@as(*const ITfPropertyStore, @ptrCast(self)), dwFlags, pRangeNew, pfAccept);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfPropertyStore_Shrink(self: *const T, pRangeNew: ?*ITfRange, pfFree: ?*BOOL) HRESULT {
                return @as(*const ITfPropertyStore.VTable, @ptrCast(self.vtable)).Shrink(@as(*const ITfPropertyStore, @ptrCast(self)), pRangeNew, pfFree);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfPropertyStore_Divide(self: *const T, pRangeThis: ?*ITfRange, pRangeNew: ?*ITfRange, ppPropStore: ?*?*ITfPropertyStore) HRESULT {
                return @as(*const ITfPropertyStore.VTable, @ptrCast(self.vtable)).Divide(@as(*const ITfPropertyStore, @ptrCast(self)), pRangeThis, pRangeNew, ppPropStore);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfPropertyStore_Clone(self: *const T, pPropStore: ?*?*ITfPropertyStore) HRESULT {
                return @as(*const ITfPropertyStore.VTable, @ptrCast(self.vtable)).Clone(@as(*const ITfPropertyStore, @ptrCast(self)), pPropStore);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfPropertyStore_GetPropertyRangeCreator(self: *const T, pclsid: ?*Guid) HRESULT {
                return @as(*const ITfPropertyStore.VTable, @ptrCast(self.vtable)).GetPropertyRangeCreator(@as(*const ITfPropertyStore, @ptrCast(self)), pclsid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfPropertyStore_Serialize(self: *const T, pStream: ?*IStream, pcb: ?*u32) HRESULT {
                return @as(*const ITfPropertyStore.VTable, @ptrCast(self.vtable)).Serialize(@as(*const ITfPropertyStore, @ptrCast(self)), pStream, pcb);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumTfRanges_Value = Guid.initString("f99d3f40-8e32-11d2-bf46-00105a2799b5");
pub const IID_IEnumTfRanges = &IID_IEnumTfRanges_Value;
pub const IEnumTfRanges = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumTfRanges,
                ppEnum: ?*?*IEnumTfRanges,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumTfRanges,
                ppEnum: ?*?*IEnumTfRanges,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumTfRanges,
                ulCount: u32,
                ppRange: [*]?*ITfRange,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumTfRanges,
                ulCount: u32,
                ppRange: [*]?*ITfRange,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumTfRanges,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumTfRanges,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumTfRanges,
                ulCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumTfRanges,
                ulCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumTfRanges_Clone(self: *const T, ppEnum: ?*?*IEnumTfRanges) HRESULT {
                return @as(*const IEnumTfRanges.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumTfRanges, @ptrCast(self)), ppEnum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumTfRanges_Next(self: *const T, ulCount: u32, ppRange: [*]?*ITfRange, pcFetched: ?*u32) HRESULT {
                return @as(*const IEnumTfRanges.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumTfRanges, @ptrCast(self)), ulCount, ppRange, pcFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumTfRanges_Reset(self: *const T) HRESULT {
                return @as(*const IEnumTfRanges.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumTfRanges, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumTfRanges_Skip(self: *const T, ulCount: u32) HRESULT {
                return @as(*const IEnumTfRanges.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumTfRanges, @ptrCast(self)), ulCount);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfCreatePropertyStore_Value = Guid.initString("2463fbf0-b0af-11d2-afc5-00105a2799b5");
pub const IID_ITfCreatePropertyStore = &IID_ITfCreatePropertyStore_Value;
pub const ITfCreatePropertyStore = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IsStoreSerializable: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfCreatePropertyStore,
                guidProp: ?*const Guid,
                pRange: ?*ITfRange,
                pPropStore: ?*ITfPropertyStore,
                pfSerializable: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfCreatePropertyStore,
                guidProp: ?*const Guid,
                pRange: ?*ITfRange,
                pPropStore: ?*ITfPropertyStore,
                pfSerializable: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreatePropertyStore: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfCreatePropertyStore,
                guidProp: ?*const Guid,
                pRange: ?*ITfRange,
                cb: u32,
                pStream: ?*IStream,
                ppStore: ?*?*ITfPropertyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfCreatePropertyStore,
                guidProp: ?*const Guid,
                pRange: ?*ITfRange,
                cb: u32,
                pStream: ?*IStream,
                ppStore: ?*?*ITfPropertyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfCreatePropertyStore_IsStoreSerializable(self: *const T, guidProp: ?*const Guid, pRange: ?*ITfRange, pPropStore: ?*ITfPropertyStore, pfSerializable: ?*BOOL) HRESULT {
                return @as(*const ITfCreatePropertyStore.VTable, @ptrCast(self.vtable)).IsStoreSerializable(@as(*const ITfCreatePropertyStore, @ptrCast(self)), guidProp, pRange, pPropStore, pfSerializable);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfCreatePropertyStore_CreatePropertyStore(self: *const T, guidProp: ?*const Guid, pRange: ?*ITfRange, cb: u32, pStream: ?*IStream, ppStore: ?*?*ITfPropertyStore) HRESULT {
                return @as(*const ITfCreatePropertyStore.VTable, @ptrCast(self.vtable)).CreatePropertyStore(@as(*const ITfCreatePropertyStore, @ptrCast(self)), guidProp, pRange, cb, pStream, ppStore);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfPersistentPropertyLoaderACP_Value = Guid.initString("4ef89150-0807-11d3-8df0-00105a2799b5");
pub const IID_ITfPersistentPropertyLoaderACP = &IID_ITfPersistentPropertyLoaderACP_Value;
pub const ITfPersistentPropertyLoaderACP = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        LoadProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfPersistentPropertyLoaderACP,
                pHdr: ?*const TF_PERSISTENT_PROPERTY_HEADER_ACP,
                ppStream: ?*?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfPersistentPropertyLoaderACP,
                pHdr: ?*const TF_PERSISTENT_PROPERTY_HEADER_ACP,
                ppStream: ?*?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfPersistentPropertyLoaderACP_LoadProperty(self: *const T, pHdr: ?*const TF_PERSISTENT_PROPERTY_HEADER_ACP, ppStream: ?*?*IStream) HRESULT {
                return @as(*const ITfPersistentPropertyLoaderACP.VTable, @ptrCast(self.vtable)).LoadProperty(@as(*const ITfPersistentPropertyLoaderACP, @ptrCast(self)), pHdr, ppStream);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfProperty_Value = Guid.initString("e2449660-9542-11d2-bf46-00105a2799b5");
pub const IID_ITfProperty = &IID_ITfProperty_Value;
pub const ITfProperty = extern struct {
    pub const VTable = extern struct {
        base: ITfReadOnlyProperty.VTable,
        FindRange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfProperty,
                ec: u32,
                pRange: ?*ITfRange,
                ppRange: ?*?*ITfRange,
                aPos: TfAnchor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfProperty,
                ec: u32,
                pRange: ?*ITfRange,
                ppRange: ?*?*ITfRange,
                aPos: TfAnchor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetValueStore: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfProperty,
                ec: u32,
                pRange: ?*ITfRange,
                pPropStore: ?*ITfPropertyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfProperty,
                ec: u32,
                pRange: ?*ITfRange,
                pPropStore: ?*ITfPropertyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfProperty,
                ec: u32,
                pRange: ?*ITfRange,
                pvarValue: ?*const VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfProperty,
                ec: u32,
                pRange: ?*ITfRange,
                pvarValue: ?*const VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clear: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfProperty,
                ec: u32,
                pRange: ?*ITfRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfProperty,
                ec: u32,
                pRange: ?*ITfRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITfReadOnlyProperty.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfProperty_FindRange(self: *const T, ec: u32, pRange: ?*ITfRange, ppRange: ?*?*ITfRange, aPos: TfAnchor) HRESULT {
                return @as(*const ITfProperty.VTable, @ptrCast(self.vtable)).FindRange(@as(*const ITfProperty, @ptrCast(self)), ec, pRange, ppRange, aPos);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfProperty_SetValueStore(self: *const T, ec: u32, pRange: ?*ITfRange, pPropStore: ?*ITfPropertyStore) HRESULT {
                return @as(*const ITfProperty.VTable, @ptrCast(self.vtable)).SetValueStore(@as(*const ITfProperty, @ptrCast(self)), ec, pRange, pPropStore);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfProperty_SetValue(self: *const T, ec: u32, pRange: ?*ITfRange, pvarValue: ?*const VARIANT) HRESULT {
                return @as(*const ITfProperty.VTable, @ptrCast(self.vtable)).SetValue(@as(*const ITfProperty, @ptrCast(self)), ec, pRange, pvarValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfProperty_Clear(self: *const T, ec: u32, pRange: ?*ITfRange) HRESULT {
                return @as(*const ITfProperty.VTable, @ptrCast(self.vtable)).Clear(@as(*const ITfProperty, @ptrCast(self)), ec, pRange);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumTfProperties_Value = Guid.initString("19188cb0-aca9-11d2-afc5-00105a2799b5");
pub const IID_IEnumTfProperties = &IID_IEnumTfProperties_Value;
pub const IEnumTfProperties = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumTfProperties,
                ppEnum: ?*?*IEnumTfProperties,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumTfProperties,
                ppEnum: ?*?*IEnumTfProperties,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumTfProperties,
                ulCount: u32,
                ppProp: [*]?*ITfProperty,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumTfProperties,
                ulCount: u32,
                ppProp: [*]?*ITfProperty,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumTfProperties,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumTfProperties,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumTfProperties,
                ulCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumTfProperties,
                ulCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumTfProperties_Clone(self: *const T, ppEnum: ?*?*IEnumTfProperties) HRESULT {
                return @as(*const IEnumTfProperties.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumTfProperties, @ptrCast(self)), ppEnum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumTfProperties_Next(self: *const T, ulCount: u32, ppProp: [*]?*ITfProperty, pcFetched: ?*u32) HRESULT {
                return @as(*const IEnumTfProperties.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumTfProperties, @ptrCast(self)), ulCount, ppProp, pcFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumTfProperties_Reset(self: *const T) HRESULT {
                return @as(*const IEnumTfProperties.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumTfProperties, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumTfProperties_Skip(self: *const T, ulCount: u32) HRESULT {
                return @as(*const IEnumTfProperties.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumTfProperties, @ptrCast(self)), ulCount);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfCompartment_Value = Guid.initString("bb08f7a9-607a-4384-8623-056892b64371");
pub const IID_ITfCompartment = &IID_ITfCompartment_Value;
pub const ITfCompartment = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfCompartment,
                tid: u32,
                pvarValue: ?*const VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfCompartment,
                tid: u32,
                pvarValue: ?*const VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfCompartment,
                pvarValue: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfCompartment,
                pvarValue: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfCompartment_SetValue(self: *const T, tid: u32, pvarValue: ?*const VARIANT) HRESULT {
                return @as(*const ITfCompartment.VTable, @ptrCast(self.vtable)).SetValue(@as(*const ITfCompartment, @ptrCast(self)), tid, pvarValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfCompartment_GetValue(self: *const T, pvarValue: ?*VARIANT) HRESULT {
                return @as(*const ITfCompartment.VTable, @ptrCast(self.vtable)).GetValue(@as(*const ITfCompartment, @ptrCast(self)), pvarValue);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfCompartmentEventSink_Value = Guid.initString("743abd5f-f26d-48df-8cc5-238492419b64");
pub const IID_ITfCompartmentEventSink = &IID_ITfCompartmentEventSink_Value;
pub const ITfCompartmentEventSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfCompartmentEventSink,
                rguid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfCompartmentEventSink,
                rguid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfCompartmentEventSink_OnChange(self: *const T, rguid: ?*const Guid) HRESULT {
                return @as(*const ITfCompartmentEventSink.VTable, @ptrCast(self.vtable)).OnChange(@as(*const ITfCompartmentEventSink, @ptrCast(self)), rguid);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfCompartmentMgr_Value = Guid.initString("7dcf57ac-18ad-438b-824d-979bffb74b7c");
pub const IID_ITfCompartmentMgr = &IID_ITfCompartmentMgr_Value;
pub const ITfCompartmentMgr = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCompartment: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfCompartmentMgr,
                rguid: ?*const Guid,
                ppcomp: ?*?*ITfCompartment,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfCompartmentMgr,
                rguid: ?*const Guid,
                ppcomp: ?*?*ITfCompartment,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ClearCompartment: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfCompartmentMgr,
                tid: u32,
                rguid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfCompartmentMgr,
                tid: u32,
                rguid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumCompartments: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfCompartmentMgr,
                ppEnum: ?*?*IEnumGUID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfCompartmentMgr,
                ppEnum: ?*?*IEnumGUID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfCompartmentMgr_GetCompartment(self: *const T, rguid: ?*const Guid, ppcomp: ?*?*ITfCompartment) HRESULT {
                return @as(*const ITfCompartmentMgr.VTable, @ptrCast(self.vtable)).GetCompartment(@as(*const ITfCompartmentMgr, @ptrCast(self)), rguid, ppcomp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfCompartmentMgr_ClearCompartment(self: *const T, tid: u32, rguid: ?*const Guid) HRESULT {
                return @as(*const ITfCompartmentMgr.VTable, @ptrCast(self.vtable)).ClearCompartment(@as(*const ITfCompartmentMgr, @ptrCast(self)), tid, rguid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfCompartmentMgr_EnumCompartments(self: *const T, ppEnum: ?*?*IEnumGUID) HRESULT {
                return @as(*const ITfCompartmentMgr.VTable, @ptrCast(self.vtable)).EnumCompartments(@as(*const ITfCompartmentMgr, @ptrCast(self)), ppEnum);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfFunction_Value = Guid.initString("db593490-098f-11d3-8df0-00105a2799b5");
pub const IID_ITfFunction = &IID_ITfFunction_Value;
pub const ITfFunction = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDisplayName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfFunction,
                pbstrName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfFunction,
                pbstrName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfFunction_GetDisplayName(self: *const T, pbstrName: ?*?BSTR) HRESULT {
                return @as(*const ITfFunction.VTable, @ptrCast(self.vtable)).GetDisplayName(@as(*const ITfFunction, @ptrCast(self)), pbstrName);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfFunctionProvider_Value = Guid.initString("101d6610-0990-11d3-8df0-00105a2799b5");
pub const IID_ITfFunctionProvider = &IID_ITfFunctionProvider_Value;
pub const ITfFunctionProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfFunctionProvider,
                pguid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfFunctionProvider,
                pguid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfFunctionProvider,
                pbstrDesc: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfFunctionProvider,
                pbstrDesc: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFunction: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfFunctionProvider,
                rguid: ?*const Guid,
                riid: ?*const Guid,
                ppunk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfFunctionProvider,
                rguid: ?*const Guid,
                riid: ?*const Guid,
                ppunk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfFunctionProvider_GetType(self: *const T, pguid: ?*Guid) HRESULT {
                return @as(*const ITfFunctionProvider.VTable, @ptrCast(self.vtable)).GetType(@as(*const ITfFunctionProvider, @ptrCast(self)), pguid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfFunctionProvider_GetDescription(self: *const T, pbstrDesc: ?*?BSTR) HRESULT {
                return @as(*const ITfFunctionProvider.VTable, @ptrCast(self.vtable)).GetDescription(@as(*const ITfFunctionProvider, @ptrCast(self)), pbstrDesc);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfFunctionProvider_GetFunction(self: *const T, rguid: ?*const Guid, riid: ?*const Guid, ppunk: ?*?*IUnknown) HRESULT {
                return @as(*const ITfFunctionProvider.VTable, @ptrCast(self.vtable)).GetFunction(@as(*const ITfFunctionProvider, @ptrCast(self)), rguid, riid, ppunk);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumTfFunctionProviders_Value = Guid.initString("e4b24db0-0990-11d3-8df0-00105a2799b5");
pub const IID_IEnumTfFunctionProviders = &IID_IEnumTfFunctionProviders_Value;
pub const IEnumTfFunctionProviders = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumTfFunctionProviders,
                ppEnum: ?*?*IEnumTfFunctionProviders,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumTfFunctionProviders,
                ppEnum: ?*?*IEnumTfFunctionProviders,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumTfFunctionProviders,
                ulCount: u32,
                ppCmdobj: [*]?*ITfFunctionProvider,
                pcFetch: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumTfFunctionProviders,
                ulCount: u32,
                ppCmdobj: [*]?*ITfFunctionProvider,
                pcFetch: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumTfFunctionProviders,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumTfFunctionProviders,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumTfFunctionProviders,
                ulCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumTfFunctionProviders,
                ulCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumTfFunctionProviders_Clone(self: *const T, ppEnum: ?*?*IEnumTfFunctionProviders) HRESULT {
                return @as(*const IEnumTfFunctionProviders.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumTfFunctionProviders, @ptrCast(self)), ppEnum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumTfFunctionProviders_Next(self: *const T, ulCount: u32, ppCmdobj: [*]?*ITfFunctionProvider, pcFetch: ?*u32) HRESULT {
                return @as(*const IEnumTfFunctionProviders.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumTfFunctionProviders, @ptrCast(self)), ulCount, ppCmdobj, pcFetch);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumTfFunctionProviders_Reset(self: *const T) HRESULT {
                return @as(*const IEnumTfFunctionProviders.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumTfFunctionProviders, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumTfFunctionProviders_Skip(self: *const T, ulCount: u32) HRESULT {
                return @as(*const IEnumTfFunctionProviders.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumTfFunctionProviders, @ptrCast(self)), ulCount);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfInputProcessorProfiles_Value = Guid.initString("1f02b6c5-7842-4ee6-8a0b-9a24183a95ca");
pub const IID_ITfInputProcessorProfiles = &IID_ITfInputProcessorProfiles_Value;
pub const ITfInputProcessorProfiles = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Register: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfInputProcessorProfiles,
                rclsid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfInputProcessorProfiles,
                rclsid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Unregister: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfInputProcessorProfiles,
                rclsid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfInputProcessorProfiles,
                rclsid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddLanguageProfile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfInputProcessorProfiles,
                rclsid: ?*const Guid,
                langid: u16,
                guidProfile: ?*const Guid,
                pchDesc: [*:0]const u16,
                cchDesc: u32,
                pchIconFile: [*:0]const u16,
                cchFile: u32,
                uIconIndex: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfInputProcessorProfiles,
                rclsid: ?*const Guid,
                langid: u16,
                guidProfile: ?*const Guid,
                pchDesc: [*:0]const u16,
                cchDesc: u32,
                pchIconFile: [*:0]const u16,
                cchFile: u32,
                uIconIndex: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveLanguageProfile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfInputProcessorProfiles,
                rclsid: ?*const Guid,
                langid: u16,
                guidProfile: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfInputProcessorProfiles,
                rclsid: ?*const Guid,
                langid: u16,
                guidProfile: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumInputProcessorInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfInputProcessorProfiles,
                ppEnum: ?*?*IEnumGUID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfInputProcessorProfiles,
                ppEnum: ?*?*IEnumGUID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDefaultLanguageProfile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfInputProcessorProfiles,
                langid: u16,
                catid: ?*const Guid,
                pclsid: ?*Guid,
                pguidProfile: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfInputProcessorProfiles,
                langid: u16,
                catid: ?*const Guid,
                pclsid: ?*Guid,
                pguidProfile: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDefaultLanguageProfile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfInputProcessorProfiles,
                langid: u16,
                rclsid: ?*const Guid,
                guidProfiles: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfInputProcessorProfiles,
                langid: u16,
                rclsid: ?*const Guid,
                guidProfiles: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ActivateLanguageProfile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfInputProcessorProfiles,
                rclsid: ?*const Guid,
                langid: u16,
                guidProfiles: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfInputProcessorProfiles,
                rclsid: ?*const Guid,
                langid: u16,
                guidProfiles: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetActiveLanguageProfile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfInputProcessorProfiles,
                rclsid: ?*const Guid,
                plangid: ?*u16,
                pguidProfile: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfInputProcessorProfiles,
                rclsid: ?*const Guid,
                plangid: ?*u16,
                pguidProfile: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLanguageProfileDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfInputProcessorProfiles,
                rclsid: ?*const Guid,
                langid: u16,
                guidProfile: ?*const Guid,
                pbstrProfile: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfInputProcessorProfiles,
                rclsid: ?*const Guid,
                langid: u16,
                guidProfile: ?*const Guid,
                pbstrProfile: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentLanguage: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfInputProcessorProfiles,
                plangid: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfInputProcessorProfiles,
                plangid: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ChangeCurrentLanguage: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfInputProcessorProfiles,
                langid: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfInputProcessorProfiles,
                langid: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLanguageList: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfInputProcessorProfiles,
                ppLangId: [*]?*u16,
                pulCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfInputProcessorProfiles,
                ppLangId: [*]?*u16,
                pulCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumLanguageProfiles: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfInputProcessorProfiles,
                langid: u16,
                ppEnum: ?*?*IEnumTfLanguageProfiles,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfInputProcessorProfiles,
                langid: u16,
                ppEnum: ?*?*IEnumTfLanguageProfiles,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnableLanguageProfile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfInputProcessorProfiles,
                rclsid: ?*const Guid,
                langid: u16,
                guidProfile: ?*const Guid,
                fEnable: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfInputProcessorProfiles,
                rclsid: ?*const Guid,
                langid: u16,
                guidProfile: ?*const Guid,
                fEnable: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsEnabledLanguageProfile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfInputProcessorProfiles,
                rclsid: ?*const Guid,
                langid: u16,
                guidProfile: ?*const Guid,
                pfEnable: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfInputProcessorProfiles,
                rclsid: ?*const Guid,
                langid: u16,
                guidProfile: ?*const Guid,
                pfEnable: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnableLanguageProfileByDefault: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfInputProcessorProfiles,
                rclsid: ?*const Guid,
                langid: u16,
                guidProfile: ?*const Guid,
                fEnable: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfInputProcessorProfiles,
                rclsid: ?*const Guid,
                langid: u16,
                guidProfile: ?*const Guid,
                fEnable: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SubstituteKeyboardLayout: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfInputProcessorProfiles,
                rclsid: ?*const Guid,
                langid: u16,
                guidProfile: ?*const Guid,
                hKL: ?HKL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfInputProcessorProfiles,
                rclsid: ?*const Guid,
                langid: u16,
                guidProfile: ?*const Guid,
                hKL: ?HKL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfInputProcessorProfiles_Register(self: *const T, rclsid: ?*const Guid) HRESULT {
                return @as(*const ITfInputProcessorProfiles.VTable, @ptrCast(self.vtable)).Register(@as(*const ITfInputProcessorProfiles, @ptrCast(self)), rclsid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfInputProcessorProfiles_Unregister(self: *const T, rclsid: ?*const Guid) HRESULT {
                return @as(*const ITfInputProcessorProfiles.VTable, @ptrCast(self.vtable)).Unregister(@as(*const ITfInputProcessorProfiles, @ptrCast(self)), rclsid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfInputProcessorProfiles_AddLanguageProfile(self: *const T, rclsid: ?*const Guid, langid: u16, guidProfile: ?*const Guid, pchDesc: [*:0]const u16, cchDesc: u32, pchIconFile: [*:0]const u16, cchFile: u32, uIconIndex: u32) HRESULT {
                return @as(*const ITfInputProcessorProfiles.VTable, @ptrCast(self.vtable)).AddLanguageProfile(@as(*const ITfInputProcessorProfiles, @ptrCast(self)), rclsid, langid, guidProfile, pchDesc, cchDesc, pchIconFile, cchFile, uIconIndex);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfInputProcessorProfiles_RemoveLanguageProfile(self: *const T, rclsid: ?*const Guid, langid: u16, guidProfile: ?*const Guid) HRESULT {
                return @as(*const ITfInputProcessorProfiles.VTable, @ptrCast(self.vtable)).RemoveLanguageProfile(@as(*const ITfInputProcessorProfiles, @ptrCast(self)), rclsid, langid, guidProfile);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfInputProcessorProfiles_EnumInputProcessorInfo(self: *const T, ppEnum: ?*?*IEnumGUID) HRESULT {
                return @as(*const ITfInputProcessorProfiles.VTable, @ptrCast(self.vtable)).EnumInputProcessorInfo(@as(*const ITfInputProcessorProfiles, @ptrCast(self)), ppEnum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfInputProcessorProfiles_GetDefaultLanguageProfile(self: *const T, langid: u16, catid: ?*const Guid, pclsid: ?*Guid, pguidProfile: ?*Guid) HRESULT {
                return @as(*const ITfInputProcessorProfiles.VTable, @ptrCast(self.vtable)).GetDefaultLanguageProfile(@as(*const ITfInputProcessorProfiles, @ptrCast(self)), langid, catid, pclsid, pguidProfile);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfInputProcessorProfiles_SetDefaultLanguageProfile(self: *const T, langid: u16, rclsid: ?*const Guid, guidProfiles: ?*const Guid) HRESULT {
                return @as(*const ITfInputProcessorProfiles.VTable, @ptrCast(self.vtable)).SetDefaultLanguageProfile(@as(*const ITfInputProcessorProfiles, @ptrCast(self)), langid, rclsid, guidProfiles);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfInputProcessorProfiles_ActivateLanguageProfile(self: *const T, rclsid: ?*const Guid, langid: u16, guidProfiles: ?*const Guid) HRESULT {
                return @as(*const ITfInputProcessorProfiles.VTable, @ptrCast(self.vtable)).ActivateLanguageProfile(@as(*const ITfInputProcessorProfiles, @ptrCast(self)), rclsid, langid, guidProfiles);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfInputProcessorProfiles_GetActiveLanguageProfile(self: *const T, rclsid: ?*const Guid, plangid: ?*u16, pguidProfile: ?*Guid) HRESULT {
                return @as(*const ITfInputProcessorProfiles.VTable, @ptrCast(self.vtable)).GetActiveLanguageProfile(@as(*const ITfInputProcessorProfiles, @ptrCast(self)), rclsid, plangid, pguidProfile);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfInputProcessorProfiles_GetLanguageProfileDescription(self: *const T, rclsid: ?*const Guid, langid: u16, guidProfile: ?*const Guid, pbstrProfile: ?*?BSTR) HRESULT {
                return @as(*const ITfInputProcessorProfiles.VTable, @ptrCast(self.vtable)).GetLanguageProfileDescription(@as(*const ITfInputProcessorProfiles, @ptrCast(self)), rclsid, langid, guidProfile, pbstrProfile);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfInputProcessorProfiles_GetCurrentLanguage(self: *const T, plangid: ?*u16) HRESULT {
                return @as(*const ITfInputProcessorProfiles.VTable, @ptrCast(self.vtable)).GetCurrentLanguage(@as(*const ITfInputProcessorProfiles, @ptrCast(self)), plangid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfInputProcessorProfiles_ChangeCurrentLanguage(self: *const T, langid: u16) HRESULT {
                return @as(*const ITfInputProcessorProfiles.VTable, @ptrCast(self.vtable)).ChangeCurrentLanguage(@as(*const ITfInputProcessorProfiles, @ptrCast(self)), langid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfInputProcessorProfiles_GetLanguageList(self: *const T, ppLangId: [*]?*u16, pulCount: ?*u32) HRESULT {
                return @as(*const ITfInputProcessorProfiles.VTable, @ptrCast(self.vtable)).GetLanguageList(@as(*const ITfInputProcessorProfiles, @ptrCast(self)), ppLangId, pulCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfInputProcessorProfiles_EnumLanguageProfiles(self: *const T, langid: u16, ppEnum: ?*?*IEnumTfLanguageProfiles) HRESULT {
                return @as(*const ITfInputProcessorProfiles.VTable, @ptrCast(self.vtable)).EnumLanguageProfiles(@as(*const ITfInputProcessorProfiles, @ptrCast(self)), langid, ppEnum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfInputProcessorProfiles_EnableLanguageProfile(self: *const T, rclsid: ?*const Guid, langid: u16, guidProfile: ?*const Guid, fEnable: BOOL) HRESULT {
                return @as(*const ITfInputProcessorProfiles.VTable, @ptrCast(self.vtable)).EnableLanguageProfile(@as(*const ITfInputProcessorProfiles, @ptrCast(self)), rclsid, langid, guidProfile, fEnable);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfInputProcessorProfiles_IsEnabledLanguageProfile(self: *const T, rclsid: ?*const Guid, langid: u16, guidProfile: ?*const Guid, pfEnable: ?*BOOL) HRESULT {
                return @as(*const ITfInputProcessorProfiles.VTable, @ptrCast(self.vtable)).IsEnabledLanguageProfile(@as(*const ITfInputProcessorProfiles, @ptrCast(self)), rclsid, langid, guidProfile, pfEnable);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfInputProcessorProfiles_EnableLanguageProfileByDefault(self: *const T, rclsid: ?*const Guid, langid: u16, guidProfile: ?*const Guid, fEnable: BOOL) HRESULT {
                return @as(*const ITfInputProcessorProfiles.VTable, @ptrCast(self.vtable)).EnableLanguageProfileByDefault(@as(*const ITfInputProcessorProfiles, @ptrCast(self)), rclsid, langid, guidProfile, fEnable);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfInputProcessorProfiles_SubstituteKeyboardLayout(self: *const T, rclsid: ?*const Guid, langid: u16, guidProfile: ?*const Guid, hKL: ?HKL) HRESULT {
                return @as(*const ITfInputProcessorProfiles.VTable, @ptrCast(self.vtable)).SubstituteKeyboardLayout(@as(*const ITfInputProcessorProfiles, @ptrCast(self)), rclsid, langid, guidProfile, hKL);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfInputProcessorProfilesEx_Value = Guid.initString("892f230f-fe00-4a41-a98e-fcd6de0d35ef");
pub const IID_ITfInputProcessorProfilesEx = &IID_ITfInputProcessorProfilesEx_Value;
pub const ITfInputProcessorProfilesEx = extern struct {
    pub const VTable = extern struct {
        base: ITfInputProcessorProfiles.VTable,
        SetLanguageProfileDisplayName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfInputProcessorProfilesEx,
                rclsid: ?*const Guid,
                langid: u16,
                guidProfile: ?*const Guid,
                pchFile: [*:0]const u16,
                cchFile: u32,
                uResId: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfInputProcessorProfilesEx,
                rclsid: ?*const Guid,
                langid: u16,
                guidProfile: ?*const Guid,
                pchFile: [*:0]const u16,
                cchFile: u32,
                uResId: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITfInputProcessorProfiles.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfInputProcessorProfilesEx_SetLanguageProfileDisplayName(self: *const T, rclsid: ?*const Guid, langid: u16, guidProfile: ?*const Guid, pchFile: [*:0]const u16, cchFile: u32, uResId: u32) HRESULT {
                return @as(*const ITfInputProcessorProfilesEx.VTable, @ptrCast(self.vtable)).SetLanguageProfileDisplayName(@as(*const ITfInputProcessorProfilesEx, @ptrCast(self)), rclsid, langid, guidProfile, pchFile, cchFile, uResId);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfInputProcessorProfileSubstituteLayout_Value = Guid.initString("4fd67194-1002-4513-bff2-c0ddf6258552");
pub const IID_ITfInputProcessorProfileSubstituteLayout = &IID_ITfInputProcessorProfileSubstituteLayout_Value;
pub const ITfInputProcessorProfileSubstituteLayout = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSubstituteKeyboardLayout: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfInputProcessorProfileSubstituteLayout,
                rclsid: ?*const Guid,
                langid: u16,
                guidProfile: ?*const Guid,
                phKL: ?*?HKL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfInputProcessorProfileSubstituteLayout,
                rclsid: ?*const Guid,
                langid: u16,
                guidProfile: ?*const Guid,
                phKL: ?*?HKL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfInputProcessorProfileSubstituteLayout_GetSubstituteKeyboardLayout(self: *const T, rclsid: ?*const Guid, langid: u16, guidProfile: ?*const Guid, phKL: ?*?HKL) HRESULT {
                return @as(*const ITfInputProcessorProfileSubstituteLayout.VTable, @ptrCast(self.vtable)).GetSubstituteKeyboardLayout(@as(*const ITfInputProcessorProfileSubstituteLayout, @ptrCast(self)), rclsid, langid, guidProfile, phKL);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfActiveLanguageProfileNotifySink_Value = Guid.initString("b246cb75-a93e-4652-bf8c-b3fe0cfd7e57");
pub const IID_ITfActiveLanguageProfileNotifySink = &IID_ITfActiveLanguageProfileNotifySink_Value;
pub const ITfActiveLanguageProfileNotifySink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnActivated: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfActiveLanguageProfileNotifySink,
                clsid: ?*const Guid,
                guidProfile: ?*const Guid,
                fActivated: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfActiveLanguageProfileNotifySink,
                clsid: ?*const Guid,
                guidProfile: ?*const Guid,
                fActivated: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfActiveLanguageProfileNotifySink_OnActivated(self: *const T, clsid: ?*const Guid, guidProfile: ?*const Guid, fActivated: BOOL) HRESULT {
                return @as(*const ITfActiveLanguageProfileNotifySink.VTable, @ptrCast(self.vtable)).OnActivated(@as(*const ITfActiveLanguageProfileNotifySink, @ptrCast(self)), clsid, guidProfile, fActivated);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumTfLanguageProfiles_Value = Guid.initString("3d61bf11-ac5f-42c8-a4cb-931bcc28c744");
pub const IID_IEnumTfLanguageProfiles = &IID_IEnumTfLanguageProfiles_Value;
pub const IEnumTfLanguageProfiles = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumTfLanguageProfiles,
                ppEnum: ?*?*IEnumTfLanguageProfiles,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumTfLanguageProfiles,
                ppEnum: ?*?*IEnumTfLanguageProfiles,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumTfLanguageProfiles,
                ulCount: u32,
                pProfile: [*]TF_LANGUAGEPROFILE,
                pcFetch: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumTfLanguageProfiles,
                ulCount: u32,
                pProfile: [*]TF_LANGUAGEPROFILE,
                pcFetch: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumTfLanguageProfiles,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumTfLanguageProfiles,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumTfLanguageProfiles,
                ulCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumTfLanguageProfiles,
                ulCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumTfLanguageProfiles_Clone(self: *const T, ppEnum: ?*?*IEnumTfLanguageProfiles) HRESULT {
                return @as(*const IEnumTfLanguageProfiles.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumTfLanguageProfiles, @ptrCast(self)), ppEnum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumTfLanguageProfiles_Next(self: *const T, ulCount: u32, pProfile: [*]TF_LANGUAGEPROFILE, pcFetch: ?*u32) HRESULT {
                return @as(*const IEnumTfLanguageProfiles.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumTfLanguageProfiles, @ptrCast(self)), ulCount, pProfile, pcFetch);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumTfLanguageProfiles_Reset(self: *const T) HRESULT {
                return @as(*const IEnumTfLanguageProfiles.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumTfLanguageProfiles, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumTfLanguageProfiles_Skip(self: *const T, ulCount: u32) HRESULT {
                return @as(*const IEnumTfLanguageProfiles.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumTfLanguageProfiles, @ptrCast(self)), ulCount);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfLanguageProfileNotifySink_Value = Guid.initString("43c9fe15-f494-4c17-9de2-b8a4ac350aa8");
pub const IID_ITfLanguageProfileNotifySink = &IID_ITfLanguageProfileNotifySink_Value;
pub const ITfLanguageProfileNotifySink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnLanguageChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfLanguageProfileNotifySink,
                langid: u16,
                pfAccept: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfLanguageProfileNotifySink,
                langid: u16,
                pfAccept: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnLanguageChanged: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfLanguageProfileNotifySink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfLanguageProfileNotifySink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfLanguageProfileNotifySink_OnLanguageChange(self: *const T, langid: u16, pfAccept: ?*BOOL) HRESULT {
                return @as(*const ITfLanguageProfileNotifySink.VTable, @ptrCast(self.vtable)).OnLanguageChange(@as(*const ITfLanguageProfileNotifySink, @ptrCast(self)), langid, pfAccept);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfLanguageProfileNotifySink_OnLanguageChanged(self: *const T) HRESULT {
                return @as(*const ITfLanguageProfileNotifySink.VTable, @ptrCast(self.vtable)).OnLanguageChanged(@as(*const ITfLanguageProfileNotifySink, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const TF_INPUTPROCESSORPROFILE = extern struct {
    dwProfileType: u32,
    langid: u16,
    clsid: Guid,
    guidProfile: Guid,
    catid: Guid,
    hklSubstitute: ?HKL,
    dwCaps: u32,
    hkl: ?HKL,
    dwFlags: u32,
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ITfInputProcessorProfileMgr_Value = Guid.initString("71c6e74c-0f28-11d8-a82a-00065b84435c");
pub const IID_ITfInputProcessorProfileMgr = &IID_ITfInputProcessorProfileMgr_Value;
pub const ITfInputProcessorProfileMgr = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ActivateProfile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfInputProcessorProfileMgr,
                dwProfileType: u32,
                langid: u16,
                clsid: ?*const Guid,
                guidProfile: ?*const Guid,
                hkl: ?HKL,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfInputProcessorProfileMgr,
                dwProfileType: u32,
                langid: u16,
                clsid: ?*const Guid,
                guidProfile: ?*const Guid,
                hkl: ?HKL,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeactivateProfile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfInputProcessorProfileMgr,
                dwProfileType: u32,
                langid: u16,
                clsid: ?*const Guid,
                guidProfile: ?*const Guid,
                hkl: ?HKL,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfInputProcessorProfileMgr,
                dwProfileType: u32,
                langid: u16,
                clsid: ?*const Guid,
                guidProfile: ?*const Guid,
                hkl: ?HKL,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProfile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfInputProcessorProfileMgr,
                dwProfileType: u32,
                langid: u16,
                clsid: ?*const Guid,
                guidProfile: ?*const Guid,
                hkl: ?HKL,
                pProfile: ?*TF_INPUTPROCESSORPROFILE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfInputProcessorProfileMgr,
                dwProfileType: u32,
                langid: u16,
                clsid: ?*const Guid,
                guidProfile: ?*const Guid,
                hkl: ?HKL,
                pProfile: ?*TF_INPUTPROCESSORPROFILE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumProfiles: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfInputProcessorProfileMgr,
                langid: u16,
                ppEnum: ?*?*IEnumTfInputProcessorProfiles,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfInputProcessorProfileMgr,
                langid: u16,
                ppEnum: ?*?*IEnumTfInputProcessorProfiles,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReleaseInputProcessor: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfInputProcessorProfileMgr,
                rclsid: ?*const Guid,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfInputProcessorProfileMgr,
                rclsid: ?*const Guid,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RegisterProfile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfInputProcessorProfileMgr,
                rclsid: ?*const Guid,
                langid: u16,
                guidProfile: ?*const Guid,
                pchDesc: [*:0]const u16,
                cchDesc: u32,
                pchIconFile: [*:0]const u16,
                cchFile: u32,
                uIconIndex: u32,
                hklsubstitute: ?HKL,
                dwPreferredLayout: u32,
                bEnabledByDefault: BOOL,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfInputProcessorProfileMgr,
                rclsid: ?*const Guid,
                langid: u16,
                guidProfile: ?*const Guid,
                pchDesc: [*:0]const u16,
                cchDesc: u32,
                pchIconFile: [*:0]const u16,
                cchFile: u32,
                uIconIndex: u32,
                hklsubstitute: ?HKL,
                dwPreferredLayout: u32,
                bEnabledByDefault: BOOL,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnregisterProfile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfInputProcessorProfileMgr,
                rclsid: ?*const Guid,
                langid: u16,
                guidProfile: ?*const Guid,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfInputProcessorProfileMgr,
                rclsid: ?*const Guid,
                langid: u16,
                guidProfile: ?*const Guid,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetActiveProfile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfInputProcessorProfileMgr,
                catid: ?*const Guid,
                pProfile: ?*TF_INPUTPROCESSORPROFILE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfInputProcessorProfileMgr,
                catid: ?*const Guid,
                pProfile: ?*TF_INPUTPROCESSORPROFILE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfInputProcessorProfileMgr_ActivateProfile(self: *const T, dwProfileType: u32, langid: u16, clsid: ?*const Guid, guidProfile: ?*const Guid, hkl: ?HKL, dwFlags: u32) HRESULT {
                return @as(*const ITfInputProcessorProfileMgr.VTable, @ptrCast(self.vtable)).ActivateProfile(@as(*const ITfInputProcessorProfileMgr, @ptrCast(self)), dwProfileType, langid, clsid, guidProfile, hkl, dwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfInputProcessorProfileMgr_DeactivateProfile(self: *const T, dwProfileType: u32, langid: u16, clsid: ?*const Guid, guidProfile: ?*const Guid, hkl: ?HKL, dwFlags: u32) HRESULT {
                return @as(*const ITfInputProcessorProfileMgr.VTable, @ptrCast(self.vtable)).DeactivateProfile(@as(*const ITfInputProcessorProfileMgr, @ptrCast(self)), dwProfileType, langid, clsid, guidProfile, hkl, dwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfInputProcessorProfileMgr_GetProfile(self: *const T, dwProfileType: u32, langid: u16, clsid: ?*const Guid, guidProfile: ?*const Guid, hkl: ?HKL, pProfile: ?*TF_INPUTPROCESSORPROFILE) HRESULT {
                return @as(*const ITfInputProcessorProfileMgr.VTable, @ptrCast(self.vtable)).GetProfile(@as(*const ITfInputProcessorProfileMgr, @ptrCast(self)), dwProfileType, langid, clsid, guidProfile, hkl, pProfile);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfInputProcessorProfileMgr_EnumProfiles(self: *const T, langid: u16, ppEnum: ?*?*IEnumTfInputProcessorProfiles) HRESULT {
                return @as(*const ITfInputProcessorProfileMgr.VTable, @ptrCast(self.vtable)).EnumProfiles(@as(*const ITfInputProcessorProfileMgr, @ptrCast(self)), langid, ppEnum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfInputProcessorProfileMgr_ReleaseInputProcessor(self: *const T, rclsid: ?*const Guid, dwFlags: u32) HRESULT {
                return @as(*const ITfInputProcessorProfileMgr.VTable, @ptrCast(self.vtable)).ReleaseInputProcessor(@as(*const ITfInputProcessorProfileMgr, @ptrCast(self)), rclsid, dwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfInputProcessorProfileMgr_RegisterProfile(self: *const T, rclsid: ?*const Guid, langid: u16, guidProfile: ?*const Guid, pchDesc: [*:0]const u16, cchDesc: u32, pchIconFile: [*:0]const u16, cchFile: u32, uIconIndex: u32, hklsubstitute: ?HKL, dwPreferredLayout: u32, bEnabledByDefault: BOOL, dwFlags: u32) HRESULT {
                return @as(*const ITfInputProcessorProfileMgr.VTable, @ptrCast(self.vtable)).RegisterProfile(@as(*const ITfInputProcessorProfileMgr, @ptrCast(self)), rclsid, langid, guidProfile, pchDesc, cchDesc, pchIconFile, cchFile, uIconIndex, hklsubstitute, dwPreferredLayout, bEnabledByDefault, dwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfInputProcessorProfileMgr_UnregisterProfile(self: *const T, rclsid: ?*const Guid, langid: u16, guidProfile: ?*const Guid, dwFlags: u32) HRESULT {
                return @as(*const ITfInputProcessorProfileMgr.VTable, @ptrCast(self.vtable)).UnregisterProfile(@as(*const ITfInputProcessorProfileMgr, @ptrCast(self)), rclsid, langid, guidProfile, dwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfInputProcessorProfileMgr_GetActiveProfile(self: *const T, catid: ?*const Guid, pProfile: ?*TF_INPUTPROCESSORPROFILE) HRESULT {
                return @as(*const ITfInputProcessorProfileMgr.VTable, @ptrCast(self.vtable)).GetActiveProfile(@as(*const ITfInputProcessorProfileMgr, @ptrCast(self)), catid, pProfile);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumTfInputProcessorProfiles_Value = Guid.initString("71c6e74d-0f28-11d8-a82a-00065b84435c");
pub const IID_IEnumTfInputProcessorProfiles = &IID_IEnumTfInputProcessorProfiles_Value;
pub const IEnumTfInputProcessorProfiles = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumTfInputProcessorProfiles,
                ppEnum: ?*?*IEnumTfInputProcessorProfiles,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumTfInputProcessorProfiles,
                ppEnum: ?*?*IEnumTfInputProcessorProfiles,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumTfInputProcessorProfiles,
                ulCount: u32,
                pProfile: [*]TF_INPUTPROCESSORPROFILE,
                pcFetch: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumTfInputProcessorProfiles,
                ulCount: u32,
                pProfile: [*]TF_INPUTPROCESSORPROFILE,
                pcFetch: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumTfInputProcessorProfiles,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumTfInputProcessorProfiles,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumTfInputProcessorProfiles,
                ulCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumTfInputProcessorProfiles,
                ulCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumTfInputProcessorProfiles_Clone(self: *const T, ppEnum: ?*?*IEnumTfInputProcessorProfiles) HRESULT {
                return @as(*const IEnumTfInputProcessorProfiles.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumTfInputProcessorProfiles, @ptrCast(self)), ppEnum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumTfInputProcessorProfiles_Next(self: *const T, ulCount: u32, pProfile: [*]TF_INPUTPROCESSORPROFILE, pcFetch: ?*u32) HRESULT {
                return @as(*const IEnumTfInputProcessorProfiles.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumTfInputProcessorProfiles, @ptrCast(self)), ulCount, pProfile, pcFetch);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumTfInputProcessorProfiles_Reset(self: *const T) HRESULT {
                return @as(*const IEnumTfInputProcessorProfiles.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumTfInputProcessorProfiles, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumTfInputProcessorProfiles_Skip(self: *const T, ulCount: u32) HRESULT {
                return @as(*const IEnumTfInputProcessorProfiles.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumTfInputProcessorProfiles, @ptrCast(self)), ulCount);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfInputProcessorProfileActivationSink_Value = Guid.initString("71c6e74e-0f28-11d8-a82a-00065b84435c");
pub const IID_ITfInputProcessorProfileActivationSink = &IID_ITfInputProcessorProfileActivationSink_Value;
pub const ITfInputProcessorProfileActivationSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnActivated: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfInputProcessorProfileActivationSink,
                dwProfileType: u32,
                langid: u16,
                clsid: ?*const Guid,
                catid: ?*const Guid,
                guidProfile: ?*const Guid,
                hkl: ?HKL,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfInputProcessorProfileActivationSink,
                dwProfileType: u32,
                langid: u16,
                clsid: ?*const Guid,
                catid: ?*const Guid,
                guidProfile: ?*const Guid,
                hkl: ?HKL,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfInputProcessorProfileActivationSink_OnActivated(self: *const T, dwProfileType: u32, langid: u16, clsid: ?*const Guid, catid: ?*const Guid, guidProfile: ?*const Guid, hkl: ?HKL, dwFlags: u32) HRESULT {
                return @as(*const ITfInputProcessorProfileActivationSink.VTable, @ptrCast(self.vtable)).OnActivated(@as(*const ITfInputProcessorProfileActivationSink, @ptrCast(self)), dwProfileType, langid, clsid, catid, guidProfile, hkl, dwFlags);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const TF_PRESERVEDKEY = extern struct {
    uVKey: u32,
    uModifiers: u32,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfKeystrokeMgr_Value = Guid.initString("aa80e7f0-2021-11d2-93e0-0060b067b86e");
pub const IID_ITfKeystrokeMgr = &IID_ITfKeystrokeMgr_Value;
pub const ITfKeystrokeMgr = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AdviseKeyEventSink: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfKeystrokeMgr,
                tid: u32,
                pSink: ?*ITfKeyEventSink,
                fForeground: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfKeystrokeMgr,
                tid: u32,
                pSink: ?*ITfKeyEventSink,
                fForeground: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnadviseKeyEventSink: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfKeystrokeMgr,
                tid: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfKeystrokeMgr,
                tid: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetForeground: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfKeystrokeMgr,
                pclsid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfKeystrokeMgr,
                pclsid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TestKeyDown: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfKeystrokeMgr,
                wParam: WPARAM,
                lParam: LPARAM,
                pfEaten: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfKeystrokeMgr,
                wParam: WPARAM,
                lParam: LPARAM,
                pfEaten: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TestKeyUp: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfKeystrokeMgr,
                wParam: WPARAM,
                lParam: LPARAM,
                pfEaten: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfKeystrokeMgr,
                wParam: WPARAM,
                lParam: LPARAM,
                pfEaten: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        KeyDown: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfKeystrokeMgr,
                wParam: WPARAM,
                lParam: LPARAM,
                pfEaten: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfKeystrokeMgr,
                wParam: WPARAM,
                lParam: LPARAM,
                pfEaten: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        KeyUp: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfKeystrokeMgr,
                wParam: WPARAM,
                lParam: LPARAM,
                pfEaten: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfKeystrokeMgr,
                wParam: WPARAM,
                lParam: LPARAM,
                pfEaten: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPreservedKey: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfKeystrokeMgr,
                pic: ?*ITfContext,
                pprekey: ?*const TF_PRESERVEDKEY,
                pguid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfKeystrokeMgr,
                pic: ?*ITfContext,
                pprekey: ?*const TF_PRESERVEDKEY,
                pguid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsPreservedKey: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfKeystrokeMgr,
                rguid: ?*const Guid,
                pprekey: ?*const TF_PRESERVEDKEY,
                pfRegistered: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfKeystrokeMgr,
                rguid: ?*const Guid,
                pprekey: ?*const TF_PRESERVEDKEY,
                pfRegistered: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PreserveKey: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfKeystrokeMgr,
                tid: u32,
                rguid: ?*const Guid,
                prekey: ?*const TF_PRESERVEDKEY,
                pchDesc: [*:0]const u16,
                cchDesc: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfKeystrokeMgr,
                tid: u32,
                rguid: ?*const Guid,
                prekey: ?*const TF_PRESERVEDKEY,
                pchDesc: [*:0]const u16,
                cchDesc: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnpreserveKey: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfKeystrokeMgr,
                rguid: ?*const Guid,
                pprekey: ?*const TF_PRESERVEDKEY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfKeystrokeMgr,
                rguid: ?*const Guid,
                pprekey: ?*const TF_PRESERVEDKEY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPreservedKeyDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfKeystrokeMgr,
                rguid: ?*const Guid,
                pchDesc: [*:0]const u16,
                cchDesc: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfKeystrokeMgr,
                rguid: ?*const Guid,
                pchDesc: [*:0]const u16,
                cchDesc: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPreservedKeyDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfKeystrokeMgr,
                rguid: ?*const Guid,
                pbstrDesc: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfKeystrokeMgr,
                rguid: ?*const Guid,
                pbstrDesc: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SimulatePreservedKey: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfKeystrokeMgr,
                pic: ?*ITfContext,
                rguid: ?*const Guid,
                pfEaten: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfKeystrokeMgr,
                pic: ?*ITfContext,
                rguid: ?*const Guid,
                pfEaten: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfKeystrokeMgr_AdviseKeyEventSink(self: *const T, tid: u32, pSink: ?*ITfKeyEventSink, fForeground: BOOL) HRESULT {
                return @as(*const ITfKeystrokeMgr.VTable, @ptrCast(self.vtable)).AdviseKeyEventSink(@as(*const ITfKeystrokeMgr, @ptrCast(self)), tid, pSink, fForeground);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfKeystrokeMgr_UnadviseKeyEventSink(self: *const T, tid: u32) HRESULT {
                return @as(*const ITfKeystrokeMgr.VTable, @ptrCast(self.vtable)).UnadviseKeyEventSink(@as(*const ITfKeystrokeMgr, @ptrCast(self)), tid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfKeystrokeMgr_GetForeground(self: *const T, pclsid: ?*Guid) HRESULT {
                return @as(*const ITfKeystrokeMgr.VTable, @ptrCast(self.vtable)).GetForeground(@as(*const ITfKeystrokeMgr, @ptrCast(self)), pclsid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfKeystrokeMgr_TestKeyDown(self: *const T, wParam: WPARAM, lParam: LPARAM, pfEaten: ?*BOOL) HRESULT {
                return @as(*const ITfKeystrokeMgr.VTable, @ptrCast(self.vtable)).TestKeyDown(@as(*const ITfKeystrokeMgr, @ptrCast(self)), wParam, lParam, pfEaten);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfKeystrokeMgr_TestKeyUp(self: *const T, wParam: WPARAM, lParam: LPARAM, pfEaten: ?*BOOL) HRESULT {
                return @as(*const ITfKeystrokeMgr.VTable, @ptrCast(self.vtable)).TestKeyUp(@as(*const ITfKeystrokeMgr, @ptrCast(self)), wParam, lParam, pfEaten);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfKeystrokeMgr_KeyDown(self: *const T, wParam: WPARAM, lParam: LPARAM, pfEaten: ?*BOOL) HRESULT {
                return @as(*const ITfKeystrokeMgr.VTable, @ptrCast(self.vtable)).KeyDown(@as(*const ITfKeystrokeMgr, @ptrCast(self)), wParam, lParam, pfEaten);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfKeystrokeMgr_KeyUp(self: *const T, wParam: WPARAM, lParam: LPARAM, pfEaten: ?*BOOL) HRESULT {
                return @as(*const ITfKeystrokeMgr.VTable, @ptrCast(self.vtable)).KeyUp(@as(*const ITfKeystrokeMgr, @ptrCast(self)), wParam, lParam, pfEaten);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfKeystrokeMgr_GetPreservedKey(self: *const T, pic: ?*ITfContext, pprekey: ?*const TF_PRESERVEDKEY, pguid: ?*Guid) HRESULT {
                return @as(*const ITfKeystrokeMgr.VTable, @ptrCast(self.vtable)).GetPreservedKey(@as(*const ITfKeystrokeMgr, @ptrCast(self)), pic, pprekey, pguid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfKeystrokeMgr_IsPreservedKey(self: *const T, rguid: ?*const Guid, pprekey: ?*const TF_PRESERVEDKEY, pfRegistered: ?*BOOL) HRESULT {
                return @as(*const ITfKeystrokeMgr.VTable, @ptrCast(self.vtable)).IsPreservedKey(@as(*const ITfKeystrokeMgr, @ptrCast(self)), rguid, pprekey, pfRegistered);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfKeystrokeMgr_PreserveKey(self: *const T, tid: u32, rguid: ?*const Guid, prekey: ?*const TF_PRESERVEDKEY, pchDesc: [*:0]const u16, cchDesc: u32) HRESULT {
                return @as(*const ITfKeystrokeMgr.VTable, @ptrCast(self.vtable)).PreserveKey(@as(*const ITfKeystrokeMgr, @ptrCast(self)), tid, rguid, prekey, pchDesc, cchDesc);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfKeystrokeMgr_UnpreserveKey(self: *const T, rguid: ?*const Guid, pprekey: ?*const TF_PRESERVEDKEY) HRESULT {
                return @as(*const ITfKeystrokeMgr.VTable, @ptrCast(self.vtable)).UnpreserveKey(@as(*const ITfKeystrokeMgr, @ptrCast(self)), rguid, pprekey);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfKeystrokeMgr_SetPreservedKeyDescription(self: *const T, rguid: ?*const Guid, pchDesc: [*:0]const u16, cchDesc: u32) HRESULT {
                return @as(*const ITfKeystrokeMgr.VTable, @ptrCast(self.vtable)).SetPreservedKeyDescription(@as(*const ITfKeystrokeMgr, @ptrCast(self)), rguid, pchDesc, cchDesc);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfKeystrokeMgr_GetPreservedKeyDescription(self: *const T, rguid: ?*const Guid, pbstrDesc: ?*?BSTR) HRESULT {
                return @as(*const ITfKeystrokeMgr.VTable, @ptrCast(self.vtable)).GetPreservedKeyDescription(@as(*const ITfKeystrokeMgr, @ptrCast(self)), rguid, pbstrDesc);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfKeystrokeMgr_SimulatePreservedKey(self: *const T, pic: ?*ITfContext, rguid: ?*const Guid, pfEaten: ?*BOOL) HRESULT {
                return @as(*const ITfKeystrokeMgr.VTable, @ptrCast(self.vtable)).SimulatePreservedKey(@as(*const ITfKeystrokeMgr, @ptrCast(self)), pic, rguid, pfEaten);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfKeyEventSink_Value = Guid.initString("aa80e7f5-2021-11d2-93e0-0060b067b86e");
pub const IID_ITfKeyEventSink = &IID_ITfKeyEventSink_Value;
pub const ITfKeyEventSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnSetFocus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfKeyEventSink,
                fForeground: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfKeyEventSink,
                fForeground: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnTestKeyDown: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfKeyEventSink,
                pic: ?*ITfContext,
                wParam: WPARAM,
                lParam: LPARAM,
                pfEaten: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfKeyEventSink,
                pic: ?*ITfContext,
                wParam: WPARAM,
                lParam: LPARAM,
                pfEaten: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnTestKeyUp: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfKeyEventSink,
                pic: ?*ITfContext,
                wParam: WPARAM,
                lParam: LPARAM,
                pfEaten: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfKeyEventSink,
                pic: ?*ITfContext,
                wParam: WPARAM,
                lParam: LPARAM,
                pfEaten: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnKeyDown: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfKeyEventSink,
                pic: ?*ITfContext,
                wParam: WPARAM,
                lParam: LPARAM,
                pfEaten: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfKeyEventSink,
                pic: ?*ITfContext,
                wParam: WPARAM,
                lParam: LPARAM,
                pfEaten: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnKeyUp: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfKeyEventSink,
                pic: ?*ITfContext,
                wParam: WPARAM,
                lParam: LPARAM,
                pfEaten: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfKeyEventSink,
                pic: ?*ITfContext,
                wParam: WPARAM,
                lParam: LPARAM,
                pfEaten: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnPreservedKey: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfKeyEventSink,
                pic: ?*ITfContext,
                rguid: ?*const Guid,
                pfEaten: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfKeyEventSink,
                pic: ?*ITfContext,
                rguid: ?*const Guid,
                pfEaten: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfKeyEventSink_OnSetFocus(self: *const T, fForeground: BOOL) HRESULT {
                return @as(*const ITfKeyEventSink.VTable, @ptrCast(self.vtable)).OnSetFocus(@as(*const ITfKeyEventSink, @ptrCast(self)), fForeground);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfKeyEventSink_OnTestKeyDown(self: *const T, pic: ?*ITfContext, wParam: WPARAM, lParam: LPARAM, pfEaten: ?*BOOL) HRESULT {
                return @as(*const ITfKeyEventSink.VTable, @ptrCast(self.vtable)).OnTestKeyDown(@as(*const ITfKeyEventSink, @ptrCast(self)), pic, wParam, lParam, pfEaten);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfKeyEventSink_OnTestKeyUp(self: *const T, pic: ?*ITfContext, wParam: WPARAM, lParam: LPARAM, pfEaten: ?*BOOL) HRESULT {
                return @as(*const ITfKeyEventSink.VTable, @ptrCast(self.vtable)).OnTestKeyUp(@as(*const ITfKeyEventSink, @ptrCast(self)), pic, wParam, lParam, pfEaten);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfKeyEventSink_OnKeyDown(self: *const T, pic: ?*ITfContext, wParam: WPARAM, lParam: LPARAM, pfEaten: ?*BOOL) HRESULT {
                return @as(*const ITfKeyEventSink.VTable, @ptrCast(self.vtable)).OnKeyDown(@as(*const ITfKeyEventSink, @ptrCast(self)), pic, wParam, lParam, pfEaten);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfKeyEventSink_OnKeyUp(self: *const T, pic: ?*ITfContext, wParam: WPARAM, lParam: LPARAM, pfEaten: ?*BOOL) HRESULT {
                return @as(*const ITfKeyEventSink.VTable, @ptrCast(self.vtable)).OnKeyUp(@as(*const ITfKeyEventSink, @ptrCast(self)), pic, wParam, lParam, pfEaten);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfKeyEventSink_OnPreservedKey(self: *const T, pic: ?*ITfContext, rguid: ?*const Guid, pfEaten: ?*BOOL) HRESULT {
                return @as(*const ITfKeyEventSink.VTable, @ptrCast(self.vtable)).OnPreservedKey(@as(*const ITfKeyEventSink, @ptrCast(self)), pic, rguid, pfEaten);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfKeyTraceEventSink_Value = Guid.initString("1cd4c13b-1c36-4191-a70a-7f3e611f367d");
pub const IID_ITfKeyTraceEventSink = &IID_ITfKeyTraceEventSink_Value;
pub const ITfKeyTraceEventSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnKeyTraceDown: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfKeyTraceEventSink,
                wParam: WPARAM,
                lParam: LPARAM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfKeyTraceEventSink,
                wParam: WPARAM,
                lParam: LPARAM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnKeyTraceUp: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfKeyTraceEventSink,
                wParam: WPARAM,
                lParam: LPARAM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfKeyTraceEventSink,
                wParam: WPARAM,
                lParam: LPARAM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfKeyTraceEventSink_OnKeyTraceDown(self: *const T, wParam: WPARAM, lParam: LPARAM) HRESULT {
                return @as(*const ITfKeyTraceEventSink.VTable, @ptrCast(self.vtable)).OnKeyTraceDown(@as(*const ITfKeyTraceEventSink, @ptrCast(self)), wParam, lParam);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfKeyTraceEventSink_OnKeyTraceUp(self: *const T, wParam: WPARAM, lParam: LPARAM) HRESULT {
                return @as(*const ITfKeyTraceEventSink.VTable, @ptrCast(self.vtable)).OnKeyTraceUp(@as(*const ITfKeyTraceEventSink, @ptrCast(self)), wParam, lParam);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfPreservedKeyNotifySink_Value = Guid.initString("6f77c993-d2b1-446e-853e-5912efc8a286");
pub const IID_ITfPreservedKeyNotifySink = &IID_ITfPreservedKeyNotifySink_Value;
pub const ITfPreservedKeyNotifySink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnUpdated: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfPreservedKeyNotifySink,
                pprekey: ?*const TF_PRESERVEDKEY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfPreservedKeyNotifySink,
                pprekey: ?*const TF_PRESERVEDKEY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfPreservedKeyNotifySink_OnUpdated(self: *const T, pprekey: ?*const TF_PRESERVEDKEY) HRESULT {
                return @as(*const ITfPreservedKeyNotifySink.VTable, @ptrCast(self.vtable)).OnUpdated(@as(*const ITfPreservedKeyNotifySink, @ptrCast(self)), pprekey);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfMessagePump_Value = Guid.initString("8f1b8ad8-0b6b-4874-90c5-bd76011e8f7c");
pub const IID_ITfMessagePump = &IID_ITfMessagePump_Value;
pub const ITfMessagePump = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        PeekMessageA: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfMessagePump,
                pMsg: ?*MSG,
                hwnd: ?HWND,
                wMsgFilterMin: u32,
                wMsgFilterMax: u32,
                wRemoveMsg: u32,
                pfResult: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfMessagePump,
                pMsg: ?*MSG,
                hwnd: ?HWND,
                wMsgFilterMin: u32,
                wMsgFilterMax: u32,
                wRemoveMsg: u32,
                pfResult: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMessageA: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfMessagePump,
                pMsg: ?*MSG,
                hwnd: ?HWND,
                wMsgFilterMin: u32,
                wMsgFilterMax: u32,
                pfResult: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfMessagePump,
                pMsg: ?*MSG,
                hwnd: ?HWND,
                wMsgFilterMin: u32,
                wMsgFilterMax: u32,
                pfResult: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PeekMessageW: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfMessagePump,
                pMsg: ?*MSG,
                hwnd: ?HWND,
                wMsgFilterMin: u32,
                wMsgFilterMax: u32,
                wRemoveMsg: u32,
                pfResult: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfMessagePump,
                pMsg: ?*MSG,
                hwnd: ?HWND,
                wMsgFilterMin: u32,
                wMsgFilterMax: u32,
                wRemoveMsg: u32,
                pfResult: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMessageW: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfMessagePump,
                pMsg: ?*MSG,
                hwnd: ?HWND,
                wMsgFilterMin: u32,
                wMsgFilterMax: u32,
                pfResult: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfMessagePump,
                pMsg: ?*MSG,
                hwnd: ?HWND,
                wMsgFilterMin: u32,
                wMsgFilterMax: u32,
                pfResult: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfMessagePump_PeekMessageA(self: *const T, pMsg: ?*MSG, hwnd: ?HWND, wMsgFilterMin: u32, wMsgFilterMax: u32, wRemoveMsg: u32, pfResult: ?*BOOL) HRESULT {
                return @as(*const ITfMessagePump.VTable, @ptrCast(self.vtable)).PeekMessageA(@as(*const ITfMessagePump, @ptrCast(self)), pMsg, hwnd, wMsgFilterMin, wMsgFilterMax, wRemoveMsg, pfResult);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfMessagePump_GetMessageA(self: *const T, pMsg: ?*MSG, hwnd: ?HWND, wMsgFilterMin: u32, wMsgFilterMax: u32, pfResult: ?*BOOL) HRESULT {
                return @as(*const ITfMessagePump.VTable, @ptrCast(self.vtable)).GetMessageA(@as(*const ITfMessagePump, @ptrCast(self)), pMsg, hwnd, wMsgFilterMin, wMsgFilterMax, pfResult);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfMessagePump_PeekMessageW(self: *const T, pMsg: ?*MSG, hwnd: ?HWND, wMsgFilterMin: u32, wMsgFilterMax: u32, wRemoveMsg: u32, pfResult: ?*BOOL) HRESULT {
                return @as(*const ITfMessagePump.VTable, @ptrCast(self.vtable)).PeekMessageW(@as(*const ITfMessagePump, @ptrCast(self)), pMsg, hwnd, wMsgFilterMin, wMsgFilterMax, wRemoveMsg, pfResult);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfMessagePump_GetMessageW(self: *const T, pMsg: ?*MSG, hwnd: ?HWND, wMsgFilterMin: u32, wMsgFilterMax: u32, pfResult: ?*BOOL) HRESULT {
                return @as(*const ITfMessagePump.VTable, @ptrCast(self.vtable)).GetMessageW(@as(*const ITfMessagePump, @ptrCast(self)), pMsg, hwnd, wMsgFilterMin, wMsgFilterMax, pfResult);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfThreadFocusSink_Value = Guid.initString("c0f1db0c-3a20-405c-a303-96b6010a885f");
pub const IID_ITfThreadFocusSink = &IID_ITfThreadFocusSink_Value;
pub const ITfThreadFocusSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnSetThreadFocus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfThreadFocusSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfThreadFocusSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnKillThreadFocus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfThreadFocusSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfThreadFocusSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfThreadFocusSink_OnSetThreadFocus(self: *const T) HRESULT {
                return @as(*const ITfThreadFocusSink.VTable, @ptrCast(self.vtable)).OnSetThreadFocus(@as(*const ITfThreadFocusSink, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfThreadFocusSink_OnKillThreadFocus(self: *const T) HRESULT {
                return @as(*const ITfThreadFocusSink.VTable, @ptrCast(self.vtable)).OnKillThreadFocus(@as(*const ITfThreadFocusSink, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfTextInputProcessor_Value = Guid.initString("aa80e7f7-2021-11d2-93e0-0060b067b86e");
pub const IID_ITfTextInputProcessor = &IID_ITfTextInputProcessor_Value;
pub const ITfTextInputProcessor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Activate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfTextInputProcessor,
                ptim: ?*ITfThreadMgr,
                tid: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfTextInputProcessor,
                ptim: ?*ITfThreadMgr,
                tid: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Deactivate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfTextInputProcessor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfTextInputProcessor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfTextInputProcessor_Activate(self: *const T, ptim: ?*ITfThreadMgr, tid: u32) HRESULT {
                return @as(*const ITfTextInputProcessor.VTable, @ptrCast(self.vtable)).Activate(@as(*const ITfTextInputProcessor, @ptrCast(self)), ptim, tid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfTextInputProcessor_Deactivate(self: *const T) HRESULT {
                return @as(*const ITfTextInputProcessor.VTable, @ptrCast(self.vtable)).Deactivate(@as(*const ITfTextInputProcessor, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfTextInputProcessorEx_Value = Guid.initString("6e4e2102-f9cd-433d-b496-303ce03a6507");
pub const IID_ITfTextInputProcessorEx = &IID_ITfTextInputProcessorEx_Value;
pub const ITfTextInputProcessorEx = extern struct {
    pub const VTable = extern struct {
        base: ITfTextInputProcessor.VTable,
        ActivateEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfTextInputProcessorEx,
                ptim: ?*ITfThreadMgr,
                tid: u32,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfTextInputProcessorEx,
                ptim: ?*ITfThreadMgr,
                tid: u32,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITfTextInputProcessor.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfTextInputProcessorEx_ActivateEx(self: *const T, ptim: ?*ITfThreadMgr, tid: u32, dwFlags: u32) HRESULT {
                return @as(*const ITfTextInputProcessorEx.VTable, @ptrCast(self.vtable)).ActivateEx(@as(*const ITfTextInputProcessorEx, @ptrCast(self)), ptim, tid, dwFlags);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfClientId_Value = Guid.initString("d60a7b49-1b9f-4be2-b702-47e9dc05dec3");
pub const IID_ITfClientId = &IID_ITfClientId_Value;
pub const ITfClientId = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetClientId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfClientId,
                rclsid: ?*const Guid,
                ptid: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfClientId,
                rclsid: ?*const Guid,
                ptid: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfClientId_GetClientId(self: *const T, rclsid: ?*const Guid, ptid: ?*u32) HRESULT {
                return @as(*const ITfClientId.VTable, @ptrCast(self.vtable)).GetClientId(@as(*const ITfClientId, @ptrCast(self)), rclsid, ptid);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const TF_DA_LINESTYLE = enum(i32) {
    NONE = 0,
    SOLID = 1,
    DOT = 2,
    DASH = 3,
    SQUIGGLE = 4,
};
pub const TF_LS_NONE = TF_DA_LINESTYLE.NONE;
pub const TF_LS_SOLID = TF_DA_LINESTYLE.SOLID;
pub const TF_LS_DOT = TF_DA_LINESTYLE.DOT;
pub const TF_LS_DASH = TF_DA_LINESTYLE.DASH;
pub const TF_LS_SQUIGGLE = TF_DA_LINESTYLE.SQUIGGLE;

pub const TF_DA_COLORTYPE = enum(i32) {
    NONE = 0,
    SYSCOLOR = 1,
    COLORREF = 2,
};
pub const TF_CT_NONE = TF_DA_COLORTYPE.NONE;
pub const TF_CT_SYSCOLOR = TF_DA_COLORTYPE.SYSCOLOR;
pub const TF_CT_COLORREF = TF_DA_COLORTYPE.COLORREF;

pub const TF_DA_COLOR = extern struct {
    type: TF_DA_COLORTYPE,
    Anonymous: extern union {
        nIndex: i32,
        cr: u32,
    },
};

pub const TF_DA_ATTR_INFO = enum(i32) {
    INPUT = 0,
    TARGET_CONVERTED = 1,
    CONVERTED = 2,
    TARGET_NOTCONVERTED = 3,
    INPUT_ERROR = 4,
    FIXEDCONVERTED = 5,
    OTHER = -1,
};
pub const TF_ATTR_INPUT = TF_DA_ATTR_INFO.INPUT;
pub const TF_ATTR_TARGET_CONVERTED = TF_DA_ATTR_INFO.TARGET_CONVERTED;
pub const TF_ATTR_CONVERTED = TF_DA_ATTR_INFO.CONVERTED;
pub const TF_ATTR_TARGET_NOTCONVERTED = TF_DA_ATTR_INFO.TARGET_NOTCONVERTED;
pub const TF_ATTR_INPUT_ERROR = TF_DA_ATTR_INFO.INPUT_ERROR;
pub const TF_ATTR_FIXEDCONVERTED = TF_DA_ATTR_INFO.FIXEDCONVERTED;
pub const TF_ATTR_OTHER = TF_DA_ATTR_INFO.OTHER;

pub const TF_DISPLAYATTRIBUTE = extern struct {
    crText: TF_DA_COLOR,
    crBk: TF_DA_COLOR,
    lsStyle: TF_DA_LINESTYLE,
    fBoldLine: BOOL,
    crLine: TF_DA_COLOR,
    bAttr: TF_DA_ATTR_INFO,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfDisplayAttributeInfo_Value = Guid.initString("70528852-2f26-4aea-8c96-215150578932");
pub const IID_ITfDisplayAttributeInfo = &IID_ITfDisplayAttributeInfo_Value;
pub const ITfDisplayAttributeInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetGUID: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfDisplayAttributeInfo,
                pguid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfDisplayAttributeInfo,
                pguid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfDisplayAttributeInfo,
                pbstrDesc: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfDisplayAttributeInfo,
                pbstrDesc: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAttributeInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfDisplayAttributeInfo,
                pda: ?*TF_DISPLAYATTRIBUTE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfDisplayAttributeInfo,
                pda: ?*TF_DISPLAYATTRIBUTE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetAttributeInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfDisplayAttributeInfo,
                pda: ?*const TF_DISPLAYATTRIBUTE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfDisplayAttributeInfo,
                pda: ?*const TF_DISPLAYATTRIBUTE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfDisplayAttributeInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfDisplayAttributeInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfDisplayAttributeInfo_GetGUID(self: *const T, pguid: ?*Guid) HRESULT {
                return @as(*const ITfDisplayAttributeInfo.VTable, @ptrCast(self.vtable)).GetGUID(@as(*const ITfDisplayAttributeInfo, @ptrCast(self)), pguid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfDisplayAttributeInfo_GetDescription(self: *const T, pbstrDesc: ?*?BSTR) HRESULT {
                return @as(*const ITfDisplayAttributeInfo.VTable, @ptrCast(self.vtable)).GetDescription(@as(*const ITfDisplayAttributeInfo, @ptrCast(self)), pbstrDesc);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfDisplayAttributeInfo_GetAttributeInfo(self: *const T, pda: ?*TF_DISPLAYATTRIBUTE) HRESULT {
                return @as(*const ITfDisplayAttributeInfo.VTable, @ptrCast(self.vtable)).GetAttributeInfo(@as(*const ITfDisplayAttributeInfo, @ptrCast(self)), pda);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfDisplayAttributeInfo_SetAttributeInfo(self: *const T, pda: ?*const TF_DISPLAYATTRIBUTE) HRESULT {
                return @as(*const ITfDisplayAttributeInfo.VTable, @ptrCast(self.vtable)).SetAttributeInfo(@as(*const ITfDisplayAttributeInfo, @ptrCast(self)), pda);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfDisplayAttributeInfo_Reset(self: *const T) HRESULT {
                return @as(*const ITfDisplayAttributeInfo.VTable, @ptrCast(self.vtable)).Reset(@as(*const ITfDisplayAttributeInfo, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumTfDisplayAttributeInfo_Value = Guid.initString("7cef04d7-cb75-4e80-a7ab-5f5bc7d332de");
pub const IID_IEnumTfDisplayAttributeInfo = &IID_IEnumTfDisplayAttributeInfo_Value;
pub const IEnumTfDisplayAttributeInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumTfDisplayAttributeInfo,
                ppEnum: ?*?*IEnumTfDisplayAttributeInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumTfDisplayAttributeInfo,
                ppEnum: ?*?*IEnumTfDisplayAttributeInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumTfDisplayAttributeInfo,
                ulCount: u32,
                rgInfo: [*]?*ITfDisplayAttributeInfo,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumTfDisplayAttributeInfo,
                ulCount: u32,
                rgInfo: [*]?*ITfDisplayAttributeInfo,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumTfDisplayAttributeInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumTfDisplayAttributeInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumTfDisplayAttributeInfo,
                ulCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumTfDisplayAttributeInfo,
                ulCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumTfDisplayAttributeInfo_Clone(self: *const T, ppEnum: ?*?*IEnumTfDisplayAttributeInfo) HRESULT {
                return @as(*const IEnumTfDisplayAttributeInfo.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumTfDisplayAttributeInfo, @ptrCast(self)), ppEnum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumTfDisplayAttributeInfo_Next(self: *const T, ulCount: u32, rgInfo: [*]?*ITfDisplayAttributeInfo, pcFetched: ?*u32) HRESULT {
                return @as(*const IEnumTfDisplayAttributeInfo.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumTfDisplayAttributeInfo, @ptrCast(self)), ulCount, rgInfo, pcFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumTfDisplayAttributeInfo_Reset(self: *const T) HRESULT {
                return @as(*const IEnumTfDisplayAttributeInfo.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumTfDisplayAttributeInfo, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumTfDisplayAttributeInfo_Skip(self: *const T, ulCount: u32) HRESULT {
                return @as(*const IEnumTfDisplayAttributeInfo.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumTfDisplayAttributeInfo, @ptrCast(self)), ulCount);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfDisplayAttributeProvider_Value = Guid.initString("fee47777-163c-4769-996a-6e9c50ad8f54");
pub const IID_ITfDisplayAttributeProvider = &IID_ITfDisplayAttributeProvider_Value;
pub const ITfDisplayAttributeProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EnumDisplayAttributeInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfDisplayAttributeProvider,
                ppEnum: ?*?*IEnumTfDisplayAttributeInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfDisplayAttributeProvider,
                ppEnum: ?*?*IEnumTfDisplayAttributeInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDisplayAttributeInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfDisplayAttributeProvider,
                guid: ?*const Guid,
                ppInfo: ?*?*ITfDisplayAttributeInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfDisplayAttributeProvider,
                guid: ?*const Guid,
                ppInfo: ?*?*ITfDisplayAttributeInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfDisplayAttributeProvider_EnumDisplayAttributeInfo(self: *const T, ppEnum: ?*?*IEnumTfDisplayAttributeInfo) HRESULT {
                return @as(*const ITfDisplayAttributeProvider.VTable, @ptrCast(self.vtable)).EnumDisplayAttributeInfo(@as(*const ITfDisplayAttributeProvider, @ptrCast(self)), ppEnum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfDisplayAttributeProvider_GetDisplayAttributeInfo(self: *const T, guid: ?*const Guid, ppInfo: ?*?*ITfDisplayAttributeInfo) HRESULT {
                return @as(*const ITfDisplayAttributeProvider.VTable, @ptrCast(self.vtable)).GetDisplayAttributeInfo(@as(*const ITfDisplayAttributeProvider, @ptrCast(self)), guid, ppInfo);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfDisplayAttributeMgr_Value = Guid.initString("8ded7393-5db1-475c-9e71-a39111b0ff67");
pub const IID_ITfDisplayAttributeMgr = &IID_ITfDisplayAttributeMgr_Value;
pub const ITfDisplayAttributeMgr = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnUpdateInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfDisplayAttributeMgr,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfDisplayAttributeMgr,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumDisplayAttributeInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfDisplayAttributeMgr,
                ppEnum: ?*?*IEnumTfDisplayAttributeInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfDisplayAttributeMgr,
                ppEnum: ?*?*IEnumTfDisplayAttributeInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDisplayAttributeInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfDisplayAttributeMgr,
                guid: ?*const Guid,
                ppInfo: ?*?*ITfDisplayAttributeInfo,
                pclsidOwner: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfDisplayAttributeMgr,
                guid: ?*const Guid,
                ppInfo: ?*?*ITfDisplayAttributeInfo,
                pclsidOwner: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfDisplayAttributeMgr_OnUpdateInfo(self: *const T) HRESULT {
                return @as(*const ITfDisplayAttributeMgr.VTable, @ptrCast(self.vtable)).OnUpdateInfo(@as(*const ITfDisplayAttributeMgr, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfDisplayAttributeMgr_EnumDisplayAttributeInfo(self: *const T, ppEnum: ?*?*IEnumTfDisplayAttributeInfo) HRESULT {
                return @as(*const ITfDisplayAttributeMgr.VTable, @ptrCast(self.vtable)).EnumDisplayAttributeInfo(@as(*const ITfDisplayAttributeMgr, @ptrCast(self)), ppEnum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfDisplayAttributeMgr_GetDisplayAttributeInfo(self: *const T, guid: ?*const Guid, ppInfo: ?*?*ITfDisplayAttributeInfo, pclsidOwner: ?*Guid) HRESULT {
                return @as(*const ITfDisplayAttributeMgr.VTable, @ptrCast(self.vtable)).GetDisplayAttributeInfo(@as(*const ITfDisplayAttributeMgr, @ptrCast(self)), guid, ppInfo, pclsidOwner);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfDisplayAttributeNotifySink_Value = Guid.initString("ad56f402-e162-4f25-908f-7d577cf9bda9");
pub const IID_ITfDisplayAttributeNotifySink = &IID_ITfDisplayAttributeNotifySink_Value;
pub const ITfDisplayAttributeNotifySink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnUpdateInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfDisplayAttributeNotifySink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfDisplayAttributeNotifySink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfDisplayAttributeNotifySink_OnUpdateInfo(self: *const T) HRESULT {
                return @as(*const ITfDisplayAttributeNotifySink.VTable, @ptrCast(self.vtable)).OnUpdateInfo(@as(*const ITfDisplayAttributeNotifySink, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfCategoryMgr_Value = Guid.initString("c3acefb5-f69d-4905-938f-fcadcf4be830");
pub const IID_ITfCategoryMgr = &IID_ITfCategoryMgr_Value;
pub const ITfCategoryMgr = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RegisterCategory: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfCategoryMgr,
                rclsid: ?*const Guid,
                rcatid: ?*const Guid,
                rguid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfCategoryMgr,
                rclsid: ?*const Guid,
                rcatid: ?*const Guid,
                rguid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnregisterCategory: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfCategoryMgr,
                rclsid: ?*const Guid,
                rcatid: ?*const Guid,
                rguid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfCategoryMgr,
                rclsid: ?*const Guid,
                rcatid: ?*const Guid,
                rguid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumCategoriesInItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfCategoryMgr,
                rguid: ?*const Guid,
                ppEnum: ?*?*IEnumGUID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfCategoryMgr,
                rguid: ?*const Guid,
                ppEnum: ?*?*IEnumGUID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumItemsInCategory: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfCategoryMgr,
                rcatid: ?*const Guid,
                ppEnum: ?*?*IEnumGUID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfCategoryMgr,
                rcatid: ?*const Guid,
                ppEnum: ?*?*IEnumGUID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindClosestCategory: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfCategoryMgr,
                rguid: ?*const Guid,
                pcatid: ?*Guid,
                ppcatidList: [*]const ?*const Guid,
                ulCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfCategoryMgr,
                rguid: ?*const Guid,
                pcatid: ?*Guid,
                ppcatidList: [*]const ?*const Guid,
                ulCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RegisterGUIDDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfCategoryMgr,
                rclsid: ?*const Guid,
                rguid: ?*const Guid,
                pchDesc: [*:0]const u16,
                cch: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfCategoryMgr,
                rclsid: ?*const Guid,
                rguid: ?*const Guid,
                pchDesc: [*:0]const u16,
                cch: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnregisterGUIDDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfCategoryMgr,
                rclsid: ?*const Guid,
                rguid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfCategoryMgr,
                rclsid: ?*const Guid,
                rguid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetGUIDDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfCategoryMgr,
                rguid: ?*const Guid,
                pbstrDesc: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfCategoryMgr,
                rguid: ?*const Guid,
                pbstrDesc: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RegisterGUIDDWORD: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfCategoryMgr,
                rclsid: ?*const Guid,
                rguid: ?*const Guid,
                dw: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfCategoryMgr,
                rclsid: ?*const Guid,
                rguid: ?*const Guid,
                dw: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnregisterGUIDDWORD: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfCategoryMgr,
                rclsid: ?*const Guid,
                rguid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfCategoryMgr,
                rclsid: ?*const Guid,
                rguid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetGUIDDWORD: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfCategoryMgr,
                rguid: ?*const Guid,
                pdw: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfCategoryMgr,
                rguid: ?*const Guid,
                pdw: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RegisterGUID: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfCategoryMgr,
                rguid: ?*const Guid,
                pguidatom: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfCategoryMgr,
                rguid: ?*const Guid,
                pguidatom: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetGUID: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfCategoryMgr,
                guidatom: u32,
                pguid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfCategoryMgr,
                guidatom: u32,
                pguid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsEqualTfGuidAtom: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfCategoryMgr,
                guidatom: u32,
                rguid: ?*const Guid,
                pfEqual: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfCategoryMgr,
                guidatom: u32,
                rguid: ?*const Guid,
                pfEqual: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfCategoryMgr_RegisterCategory(self: *const T, rclsid: ?*const Guid, rcatid: ?*const Guid, rguid: ?*const Guid) HRESULT {
                return @as(*const ITfCategoryMgr.VTable, @ptrCast(self.vtable)).RegisterCategory(@as(*const ITfCategoryMgr, @ptrCast(self)), rclsid, rcatid, rguid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfCategoryMgr_UnregisterCategory(self: *const T, rclsid: ?*const Guid, rcatid: ?*const Guid, rguid: ?*const Guid) HRESULT {
                return @as(*const ITfCategoryMgr.VTable, @ptrCast(self.vtable)).UnregisterCategory(@as(*const ITfCategoryMgr, @ptrCast(self)), rclsid, rcatid, rguid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfCategoryMgr_EnumCategoriesInItem(self: *const T, rguid: ?*const Guid, ppEnum: ?*?*IEnumGUID) HRESULT {
                return @as(*const ITfCategoryMgr.VTable, @ptrCast(self.vtable)).EnumCategoriesInItem(@as(*const ITfCategoryMgr, @ptrCast(self)), rguid, ppEnum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfCategoryMgr_EnumItemsInCategory(self: *const T, rcatid: ?*const Guid, ppEnum: ?*?*IEnumGUID) HRESULT {
                return @as(*const ITfCategoryMgr.VTable, @ptrCast(self.vtable)).EnumItemsInCategory(@as(*const ITfCategoryMgr, @ptrCast(self)), rcatid, ppEnum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfCategoryMgr_FindClosestCategory(self: *const T, rguid: ?*const Guid, pcatid: ?*Guid, ppcatidList: [*]const ?*const Guid, ulCount: u32) HRESULT {
                return @as(*const ITfCategoryMgr.VTable, @ptrCast(self.vtable)).FindClosestCategory(@as(*const ITfCategoryMgr, @ptrCast(self)), rguid, pcatid, ppcatidList, ulCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfCategoryMgr_RegisterGUIDDescription(self: *const T, rclsid: ?*const Guid, rguid: ?*const Guid, pchDesc: [*:0]const u16, cch: u32) HRESULT {
                return @as(*const ITfCategoryMgr.VTable, @ptrCast(self.vtable)).RegisterGUIDDescription(@as(*const ITfCategoryMgr, @ptrCast(self)), rclsid, rguid, pchDesc, cch);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfCategoryMgr_UnregisterGUIDDescription(self: *const T, rclsid: ?*const Guid, rguid: ?*const Guid) HRESULT {
                return @as(*const ITfCategoryMgr.VTable, @ptrCast(self.vtable)).UnregisterGUIDDescription(@as(*const ITfCategoryMgr, @ptrCast(self)), rclsid, rguid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfCategoryMgr_GetGUIDDescription(self: *const T, rguid: ?*const Guid, pbstrDesc: ?*?BSTR) HRESULT {
                return @as(*const ITfCategoryMgr.VTable, @ptrCast(self.vtable)).GetGUIDDescription(@as(*const ITfCategoryMgr, @ptrCast(self)), rguid, pbstrDesc);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfCategoryMgr_RegisterGUIDDWORD(self: *const T, rclsid: ?*const Guid, rguid: ?*const Guid, dw: u32) HRESULT {
                return @as(*const ITfCategoryMgr.VTable, @ptrCast(self.vtable)).RegisterGUIDDWORD(@as(*const ITfCategoryMgr, @ptrCast(self)), rclsid, rguid, dw);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfCategoryMgr_UnregisterGUIDDWORD(self: *const T, rclsid: ?*const Guid, rguid: ?*const Guid) HRESULT {
                return @as(*const ITfCategoryMgr.VTable, @ptrCast(self.vtable)).UnregisterGUIDDWORD(@as(*const ITfCategoryMgr, @ptrCast(self)), rclsid, rguid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfCategoryMgr_GetGUIDDWORD(self: *const T, rguid: ?*const Guid, pdw: ?*u32) HRESULT {
                return @as(*const ITfCategoryMgr.VTable, @ptrCast(self.vtable)).GetGUIDDWORD(@as(*const ITfCategoryMgr, @ptrCast(self)), rguid, pdw);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfCategoryMgr_RegisterGUID(self: *const T, rguid: ?*const Guid, pguidatom: ?*u32) HRESULT {
                return @as(*const ITfCategoryMgr.VTable, @ptrCast(self.vtable)).RegisterGUID(@as(*const ITfCategoryMgr, @ptrCast(self)), rguid, pguidatom);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfCategoryMgr_GetGUID(self: *const T, guidatom: u32, pguid: ?*Guid) HRESULT {
                return @as(*const ITfCategoryMgr.VTable, @ptrCast(self.vtable)).GetGUID(@as(*const ITfCategoryMgr, @ptrCast(self)), guidatom, pguid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfCategoryMgr_IsEqualTfGuidAtom(self: *const T, guidatom: u32, rguid: ?*const Guid, pfEqual: ?*BOOL) HRESULT {
                return @as(*const ITfCategoryMgr.VTable, @ptrCast(self.vtable)).IsEqualTfGuidAtom(@as(*const ITfCategoryMgr, @ptrCast(self)), guidatom, rguid, pfEqual);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfSource_Value = Guid.initString("4ea48a35-60ae-446f-8fd6-e6a8d82459f7");
pub const IID_ITfSource = &IID_ITfSource_Value;
pub const ITfSource = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AdviseSink: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfSource,
                riid: ?*const Guid,
                punk: ?*IUnknown,
                pdwCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfSource,
                riid: ?*const Guid,
                punk: ?*IUnknown,
                pdwCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnadviseSink: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfSource,
                dwCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfSource,
                dwCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfSource_AdviseSink(self: *const T, riid: ?*const Guid, punk: ?*IUnknown, pdwCookie: ?*u32) HRESULT {
                return @as(*const ITfSource.VTable, @ptrCast(self.vtable)).AdviseSink(@as(*const ITfSource, @ptrCast(self)), riid, punk, pdwCookie);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfSource_UnadviseSink(self: *const T, dwCookie: u32) HRESULT {
                return @as(*const ITfSource.VTable, @ptrCast(self.vtable)).UnadviseSink(@as(*const ITfSource, @ptrCast(self)), dwCookie);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfSourceSingle_Value = Guid.initString("73131f9c-56a9-49dd-b0ee-d046633f7528");
pub const IID_ITfSourceSingle = &IID_ITfSourceSingle_Value;
pub const ITfSourceSingle = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AdviseSingleSink: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfSourceSingle,
                tid: u32,
                riid: ?*const Guid,
                punk: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfSourceSingle,
                tid: u32,
                riid: ?*const Guid,
                punk: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnadviseSingleSink: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfSourceSingle,
                tid: u32,
                riid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfSourceSingle,
                tid: u32,
                riid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfSourceSingle_AdviseSingleSink(self: *const T, tid: u32, riid: ?*const Guid, punk: ?*IUnknown) HRESULT {
                return @as(*const ITfSourceSingle.VTable, @ptrCast(self.vtable)).AdviseSingleSink(@as(*const ITfSourceSingle, @ptrCast(self)), tid, riid, punk);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfSourceSingle_UnadviseSingleSink(self: *const T, tid: u32, riid: ?*const Guid) HRESULT {
                return @as(*const ITfSourceSingle.VTable, @ptrCast(self.vtable)).UnadviseSingleSink(@as(*const ITfSourceSingle, @ptrCast(self)), tid, riid);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfUIElementMgr_Value = Guid.initString("ea1ea135-19df-11d7-a6d2-00065b84435c");
pub const IID_ITfUIElementMgr = &IID_ITfUIElementMgr_Value;
pub const ITfUIElementMgr = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        BeginUIElement: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfUIElementMgr,
                pElement: ?*ITfUIElement,
                pbShow: ?*BOOL,
                pdwUIElementId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfUIElementMgr,
                pElement: ?*ITfUIElement,
                pbShow: ?*BOOL,
                pdwUIElementId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UpdateUIElement: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfUIElementMgr,
                dwUIElementId: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfUIElementMgr,
                dwUIElementId: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndUIElement: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfUIElementMgr,
                dwUIElementId: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfUIElementMgr,
                dwUIElementId: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetUIElement: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfUIElementMgr,
                dwUIELementId: u32,
                ppElement: ?*?*ITfUIElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfUIElementMgr,
                dwUIELementId: u32,
                ppElement: ?*?*ITfUIElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumUIElements: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfUIElementMgr,
                ppEnum: ?*?*IEnumTfUIElements,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfUIElementMgr,
                ppEnum: ?*?*IEnumTfUIElements,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfUIElementMgr_BeginUIElement(self: *const T, pElement: ?*ITfUIElement, pbShow: ?*BOOL, pdwUIElementId: ?*u32) HRESULT {
                return @as(*const ITfUIElementMgr.VTable, @ptrCast(self.vtable)).BeginUIElement(@as(*const ITfUIElementMgr, @ptrCast(self)), pElement, pbShow, pdwUIElementId);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfUIElementMgr_UpdateUIElement(self: *const T, dwUIElementId: u32) HRESULT {
                return @as(*const ITfUIElementMgr.VTable, @ptrCast(self.vtable)).UpdateUIElement(@as(*const ITfUIElementMgr, @ptrCast(self)), dwUIElementId);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfUIElementMgr_EndUIElement(self: *const T, dwUIElementId: u32) HRESULT {
                return @as(*const ITfUIElementMgr.VTable, @ptrCast(self.vtable)).EndUIElement(@as(*const ITfUIElementMgr, @ptrCast(self)), dwUIElementId);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfUIElementMgr_GetUIElement(self: *const T, dwUIELementId: u32, ppElement: ?*?*ITfUIElement) HRESULT {
                return @as(*const ITfUIElementMgr.VTable, @ptrCast(self.vtable)).GetUIElement(@as(*const ITfUIElementMgr, @ptrCast(self)), dwUIELementId, ppElement);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfUIElementMgr_EnumUIElements(self: *const T, ppEnum: ?*?*IEnumTfUIElements) HRESULT {
                return @as(*const ITfUIElementMgr.VTable, @ptrCast(self.vtable)).EnumUIElements(@as(*const ITfUIElementMgr, @ptrCast(self)), ppEnum);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumTfUIElements_Value = Guid.initString("887aa91e-acba-4931-84da-3c5208cf543f");
pub const IID_IEnumTfUIElements = &IID_IEnumTfUIElements_Value;
pub const IEnumTfUIElements = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumTfUIElements,
                ppEnum: ?*?*IEnumTfUIElements,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumTfUIElements,
                ppEnum: ?*?*IEnumTfUIElements,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumTfUIElements,
                ulCount: u32,
                ppElement: [*]?*ITfUIElement,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumTfUIElements,
                ulCount: u32,
                ppElement: [*]?*ITfUIElement,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumTfUIElements,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumTfUIElements,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumTfUIElements,
                ulCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumTfUIElements,
                ulCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumTfUIElements_Clone(self: *const T, ppEnum: ?*?*IEnumTfUIElements) HRESULT {
                return @as(*const IEnumTfUIElements.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumTfUIElements, @ptrCast(self)), ppEnum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumTfUIElements_Next(self: *const T, ulCount: u32, ppElement: [*]?*ITfUIElement, pcFetched: ?*u32) HRESULT {
                return @as(*const IEnumTfUIElements.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumTfUIElements, @ptrCast(self)), ulCount, ppElement, pcFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumTfUIElements_Reset(self: *const T) HRESULT {
                return @as(*const IEnumTfUIElements.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumTfUIElements, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumTfUIElements_Skip(self: *const T, ulCount: u32) HRESULT {
                return @as(*const IEnumTfUIElements.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumTfUIElements, @ptrCast(self)), ulCount);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfUIElementSink_Value = Guid.initString("ea1ea136-19df-11d7-a6d2-00065b84435c");
pub const IID_ITfUIElementSink = &IID_ITfUIElementSink_Value;
pub const ITfUIElementSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        BeginUIElement: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfUIElementSink,
                dwUIElementId: u32,
                pbShow: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfUIElementSink,
                dwUIElementId: u32,
                pbShow: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UpdateUIElement: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfUIElementSink,
                dwUIElementId: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfUIElementSink,
                dwUIElementId: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndUIElement: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfUIElementSink,
                dwUIElementId: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfUIElementSink,
                dwUIElementId: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfUIElementSink_BeginUIElement(self: *const T, dwUIElementId: u32, pbShow: ?*BOOL) HRESULT {
                return @as(*const ITfUIElementSink.VTable, @ptrCast(self.vtable)).BeginUIElement(@as(*const ITfUIElementSink, @ptrCast(self)), dwUIElementId, pbShow);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfUIElementSink_UpdateUIElement(self: *const T, dwUIElementId: u32) HRESULT {
                return @as(*const ITfUIElementSink.VTable, @ptrCast(self.vtable)).UpdateUIElement(@as(*const ITfUIElementSink, @ptrCast(self)), dwUIElementId);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfUIElementSink_EndUIElement(self: *const T, dwUIElementId: u32) HRESULT {
                return @as(*const ITfUIElementSink.VTable, @ptrCast(self.vtable)).EndUIElement(@as(*const ITfUIElementSink, @ptrCast(self)), dwUIElementId);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfUIElement_Value = Guid.initString("ea1ea137-19df-11d7-a6d2-00065b84435c");
pub const IID_ITfUIElement = &IID_ITfUIElement_Value;
pub const ITfUIElement = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfUIElement,
                pbstrDescription: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfUIElement,
                pbstrDescription: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetGUID: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfUIElement,
                pguid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfUIElement,
                pguid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Show: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfUIElement,
                bShow: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfUIElement,
                bShow: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsShown: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfUIElement,
                pbShow: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfUIElement,
                pbShow: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfUIElement_GetDescription(self: *const T, pbstrDescription: ?*?BSTR) HRESULT {
                return @as(*const ITfUIElement.VTable, @ptrCast(self.vtable)).GetDescription(@as(*const ITfUIElement, @ptrCast(self)), pbstrDescription);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfUIElement_GetGUID(self: *const T, pguid: ?*Guid) HRESULT {
                return @as(*const ITfUIElement.VTable, @ptrCast(self.vtable)).GetGUID(@as(*const ITfUIElement, @ptrCast(self)), pguid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfUIElement_Show(self: *const T, bShow: BOOL) HRESULT {
                return @as(*const ITfUIElement.VTable, @ptrCast(self.vtable)).Show(@as(*const ITfUIElement, @ptrCast(self)), bShow);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfUIElement_IsShown(self: *const T, pbShow: ?*BOOL) HRESULT {
                return @as(*const ITfUIElement.VTable, @ptrCast(self.vtable)).IsShown(@as(*const ITfUIElement, @ptrCast(self)), pbShow);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfCandidateListUIElement_Value = Guid.initString("ea1ea138-19df-11d7-a6d2-00065b84435c");
pub const IID_ITfCandidateListUIElement = &IID_ITfCandidateListUIElement_Value;
pub const ITfCandidateListUIElement = extern struct {
    pub const VTable = extern struct {
        base: ITfUIElement.VTable,
        GetUpdatedFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfCandidateListUIElement,
                pdwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfCandidateListUIElement,
                pdwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDocumentMgr: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfCandidateListUIElement,
                ppdim: ?*?*ITfDocumentMgr,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfCandidateListUIElement,
                ppdim: ?*?*ITfDocumentMgr,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfCandidateListUIElement,
                puCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfCandidateListUIElement,
                puCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSelection: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfCandidateListUIElement,
                puIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfCandidateListUIElement,
                puIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetString: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfCandidateListUIElement,
                uIndex: u32,
                pstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfCandidateListUIElement,
                uIndex: u32,
                pstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPageIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfCandidateListUIElement,
                pIndex: [*]u32,
                uSize: u32,
                puPageCnt: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfCandidateListUIElement,
                pIndex: [*]u32,
                uSize: u32,
                puPageCnt: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPageIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfCandidateListUIElement,
                pIndex: [*]u32,
                uPageCnt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfCandidateListUIElement,
                pIndex: [*]u32,
                uPageCnt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentPage: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfCandidateListUIElement,
                puPage: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfCandidateListUIElement,
                puPage: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITfUIElement.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfCandidateListUIElement_GetUpdatedFlags(self: *const T, pdwFlags: ?*u32) HRESULT {
                return @as(*const ITfCandidateListUIElement.VTable, @ptrCast(self.vtable)).GetUpdatedFlags(@as(*const ITfCandidateListUIElement, @ptrCast(self)), pdwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfCandidateListUIElement_GetDocumentMgr(self: *const T, ppdim: ?*?*ITfDocumentMgr) HRESULT {
                return @as(*const ITfCandidateListUIElement.VTable, @ptrCast(self.vtable)).GetDocumentMgr(@as(*const ITfCandidateListUIElement, @ptrCast(self)), ppdim);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfCandidateListUIElement_GetCount(self: *const T, puCount: ?*u32) HRESULT {
                return @as(*const ITfCandidateListUIElement.VTable, @ptrCast(self.vtable)).GetCount(@as(*const ITfCandidateListUIElement, @ptrCast(self)), puCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfCandidateListUIElement_GetSelection(self: *const T, puIndex: ?*u32) HRESULT {
                return @as(*const ITfCandidateListUIElement.VTable, @ptrCast(self.vtable)).GetSelection(@as(*const ITfCandidateListUIElement, @ptrCast(self)), puIndex);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfCandidateListUIElement_GetString(self: *const T, uIndex: u32, pstr: ?*?BSTR) HRESULT {
                return @as(*const ITfCandidateListUIElement.VTable, @ptrCast(self.vtable)).GetString(@as(*const ITfCandidateListUIElement, @ptrCast(self)), uIndex, pstr);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfCandidateListUIElement_GetPageIndex(self: *const T, pIndex: [*]u32, uSize: u32, puPageCnt: ?*u32) HRESULT {
                return @as(*const ITfCandidateListUIElement.VTable, @ptrCast(self.vtable)).GetPageIndex(@as(*const ITfCandidateListUIElement, @ptrCast(self)), pIndex, uSize, puPageCnt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfCandidateListUIElement_SetPageIndex(self: *const T, pIndex: [*]u32, uPageCnt: u32) HRESULT {
                return @as(*const ITfCandidateListUIElement.VTable, @ptrCast(self.vtable)).SetPageIndex(@as(*const ITfCandidateListUIElement, @ptrCast(self)), pIndex, uPageCnt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfCandidateListUIElement_GetCurrentPage(self: *const T, puPage: ?*u32) HRESULT {
                return @as(*const ITfCandidateListUIElement.VTable, @ptrCast(self.vtable)).GetCurrentPage(@as(*const ITfCandidateListUIElement, @ptrCast(self)), puPage);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfCandidateListUIElementBehavior_Value = Guid.initString("85fad185-58ce-497a-9460-355366b64b9a");
pub const IID_ITfCandidateListUIElementBehavior = &IID_ITfCandidateListUIElementBehavior_Value;
pub const ITfCandidateListUIElementBehavior = extern struct {
    pub const VTable = extern struct {
        base: ITfCandidateListUIElement.VTable,
        SetSelection: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfCandidateListUIElementBehavior,
                nIndex: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfCandidateListUIElementBehavior,
                nIndex: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Finalize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfCandidateListUIElementBehavior,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfCandidateListUIElementBehavior,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Abort: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfCandidateListUIElementBehavior,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfCandidateListUIElementBehavior,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITfCandidateListUIElement.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfCandidateListUIElementBehavior_SetSelection(self: *const T, nIndex: u32) HRESULT {
                return @as(*const ITfCandidateListUIElementBehavior.VTable, @ptrCast(self.vtable)).SetSelection(@as(*const ITfCandidateListUIElementBehavior, @ptrCast(self)), nIndex);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfCandidateListUIElementBehavior_Finalize(self: *const T) HRESULT {
                return @as(*const ITfCandidateListUIElementBehavior.VTable, @ptrCast(self.vtable)).Finalize(@as(*const ITfCandidateListUIElementBehavior, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfCandidateListUIElementBehavior_Abort(self: *const T) HRESULT {
                return @as(*const ITfCandidateListUIElementBehavior.VTable, @ptrCast(self.vtable)).Abort(@as(*const ITfCandidateListUIElementBehavior, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfReadingInformationUIElement_Value = Guid.initString("ea1ea139-19df-11d7-a6d2-00065b84435c");
pub const IID_ITfReadingInformationUIElement = &IID_ITfReadingInformationUIElement_Value;
pub const ITfReadingInformationUIElement = extern struct {
    pub const VTable = extern struct {
        base: ITfUIElement.VTable,
        GetUpdatedFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfReadingInformationUIElement,
                pdwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfReadingInformationUIElement,
                pdwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfReadingInformationUIElement,
                ppic: ?*?*ITfContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfReadingInformationUIElement,
                ppic: ?*?*ITfContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetString: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfReadingInformationUIElement,
                pstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfReadingInformationUIElement,
                pstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMaxReadingStringLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfReadingInformationUIElement,
                pcchMax: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfReadingInformationUIElement,
                pcchMax: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetErrorIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfReadingInformationUIElement,
                pErrorIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfReadingInformationUIElement,
                pErrorIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsVerticalOrderPreferred: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfReadingInformationUIElement,
                pfVertical: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfReadingInformationUIElement,
                pfVertical: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITfUIElement.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfReadingInformationUIElement_GetUpdatedFlags(self: *const T, pdwFlags: ?*u32) HRESULT {
                return @as(*const ITfReadingInformationUIElement.VTable, @ptrCast(self.vtable)).GetUpdatedFlags(@as(*const ITfReadingInformationUIElement, @ptrCast(self)), pdwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfReadingInformationUIElement_GetContext(self: *const T, ppic: ?*?*ITfContext) HRESULT {
                return @as(*const ITfReadingInformationUIElement.VTable, @ptrCast(self.vtable)).GetContext(@as(*const ITfReadingInformationUIElement, @ptrCast(self)), ppic);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfReadingInformationUIElement_GetString(self: *const T, pstr: ?*?BSTR) HRESULT {
                return @as(*const ITfReadingInformationUIElement.VTable, @ptrCast(self.vtable)).GetString(@as(*const ITfReadingInformationUIElement, @ptrCast(self)), pstr);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfReadingInformationUIElement_GetMaxReadingStringLength(self: *const T, pcchMax: ?*u32) HRESULT {
                return @as(*const ITfReadingInformationUIElement.VTable, @ptrCast(self.vtable)).GetMaxReadingStringLength(@as(*const ITfReadingInformationUIElement, @ptrCast(self)), pcchMax);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfReadingInformationUIElement_GetErrorIndex(self: *const T, pErrorIndex: ?*u32) HRESULT {
                return @as(*const ITfReadingInformationUIElement.VTable, @ptrCast(self.vtable)).GetErrorIndex(@as(*const ITfReadingInformationUIElement, @ptrCast(self)), pErrorIndex);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfReadingInformationUIElement_IsVerticalOrderPreferred(self: *const T, pfVertical: ?*BOOL) HRESULT {
                return @as(*const ITfReadingInformationUIElement.VTable, @ptrCast(self.vtable)).IsVerticalOrderPreferred(@as(*const ITfReadingInformationUIElement, @ptrCast(self)), pfVertical);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfTransitoryExtensionUIElement_Value = Guid.initString("858f956a-972f-42a2-a2f2-0321e1abe209");
pub const IID_ITfTransitoryExtensionUIElement = &IID_ITfTransitoryExtensionUIElement_Value;
pub const ITfTransitoryExtensionUIElement = extern struct {
    pub const VTable = extern struct {
        base: ITfUIElement.VTable,
        GetDocumentMgr: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfTransitoryExtensionUIElement,
                ppdim: ?*?*ITfDocumentMgr,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfTransitoryExtensionUIElement,
                ppdim: ?*?*ITfDocumentMgr,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITfUIElement.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfTransitoryExtensionUIElement_GetDocumentMgr(self: *const T, ppdim: ?*?*ITfDocumentMgr) HRESULT {
                return @as(*const ITfTransitoryExtensionUIElement.VTable, @ptrCast(self.vtable)).GetDocumentMgr(@as(*const ITfTransitoryExtensionUIElement, @ptrCast(self)), ppdim);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfTransitoryExtensionSink_Value = Guid.initString("a615096f-1c57-4813-8a15-55ee6e5a839c");
pub const IID_ITfTransitoryExtensionSink = &IID_ITfTransitoryExtensionSink_Value;
pub const ITfTransitoryExtensionSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnTransitoryExtensionUpdated: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfTransitoryExtensionSink,
                pic: ?*ITfContext,
                ecReadOnly: u32,
                pResultRange: ?*ITfRange,
                pCompositionRange: ?*ITfRange,
                pfDeleteResultRange: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfTransitoryExtensionSink,
                pic: ?*ITfContext,
                ecReadOnly: u32,
                pResultRange: ?*ITfRange,
                pCompositionRange: ?*ITfRange,
                pfDeleteResultRange: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfTransitoryExtensionSink_OnTransitoryExtensionUpdated(self: *const T, pic: ?*ITfContext, ecReadOnly: u32, pResultRange: ?*ITfRange, pCompositionRange: ?*ITfRange, pfDeleteResultRange: ?*BOOL) HRESULT {
                return @as(*const ITfTransitoryExtensionSink.VTable, @ptrCast(self.vtable)).OnTransitoryExtensionUpdated(@as(*const ITfTransitoryExtensionSink, @ptrCast(self)), pic, ecReadOnly, pResultRange, pCompositionRange, pfDeleteResultRange);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfToolTipUIElement_Value = Guid.initString("52b18b5c-555d-46b2-b00a-fa680144fbdb");
pub const IID_ITfToolTipUIElement = &IID_ITfToolTipUIElement_Value;
pub const ITfToolTipUIElement = extern struct {
    pub const VTable = extern struct {
        base: ITfUIElement.VTable,
        GetString: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfToolTipUIElement,
                pstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfToolTipUIElement,
                pstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITfUIElement.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfToolTipUIElement_GetString(self: *const T, pstr: ?*?BSTR) HRESULT {
                return @as(*const ITfToolTipUIElement.VTable, @ptrCast(self.vtable)).GetString(@as(*const ITfToolTipUIElement, @ptrCast(self)), pstr);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ITfReverseConversionList_Value = Guid.initString("151d69f0-86f4-4674-b721-56911e797f47");
pub const IID_ITfReverseConversionList = &IID_ITfReverseConversionList_Value;
pub const ITfReverseConversionList = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfReverseConversionList,
                puIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfReverseConversionList,
                puIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetString: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfReverseConversionList,
                uIndex: u32,
                pbstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfReverseConversionList,
                uIndex: u32,
                pbstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfReverseConversionList_GetLength(self: *const T, puIndex: ?*u32) HRESULT {
                return @as(*const ITfReverseConversionList.VTable, @ptrCast(self.vtable)).GetLength(@as(*const ITfReverseConversionList, @ptrCast(self)), puIndex);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfReverseConversionList_GetString(self: *const T, uIndex: u32, pbstr: ?*?BSTR) HRESULT {
                return @as(*const ITfReverseConversionList.VTable, @ptrCast(self.vtable)).GetString(@as(*const ITfReverseConversionList, @ptrCast(self)), uIndex, pbstr);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ITfReverseConversion_Value = Guid.initString("a415e162-157d-417d-8a8c-0ab26c7d2781");
pub const IID_ITfReverseConversion = &IID_ITfReverseConversion_Value;
pub const ITfReverseConversion = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        DoReverseConversion: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfReverseConversion,
                lpstr: ?[*:0]const u16,
                ppList: ?*?*ITfReverseConversionList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfReverseConversion,
                lpstr: ?[*:0]const u16,
                ppList: ?*?*ITfReverseConversionList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfReverseConversion_DoReverseConversion(self: *const T, lpstr: ?[*:0]const u16, ppList: ?*?*ITfReverseConversionList) HRESULT {
                return @as(*const ITfReverseConversion.VTable, @ptrCast(self.vtable)).DoReverseConversion(@as(*const ITfReverseConversion, @ptrCast(self)), lpstr, ppList);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ITfReverseConversionMgr_Value = Guid.initString("b643c236-c493-41b6-abb3-692412775cc4");
pub const IID_ITfReverseConversionMgr = &IID_ITfReverseConversionMgr_Value;
pub const ITfReverseConversionMgr = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetReverseConversion: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfReverseConversionMgr,
                langid: u16,
                guidProfile: ?*const Guid,
                dwflag: u32,
                ppReverseConversion: ?*?*ITfReverseConversion,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfReverseConversionMgr,
                langid: u16,
                guidProfile: ?*const Guid,
                dwflag: u32,
                ppReverseConversion: ?*?*ITfReverseConversion,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfReverseConversionMgr_GetReverseConversion(self: *const T, langid: u16, guidProfile: ?*const Guid, dwflag: u32, ppReverseConversion: ?*?*ITfReverseConversion) HRESULT {
                return @as(*const ITfReverseConversionMgr.VTable, @ptrCast(self.vtable)).GetReverseConversion(@as(*const ITfReverseConversionMgr, @ptrCast(self)), langid, guidProfile, dwflag, ppReverseConversion);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfCandidateString_Value = Guid.initString("581f317e-fd9d-443f-b972-ed00467c5d40");
pub const IID_ITfCandidateString = &IID_ITfCandidateString_Value;
pub const ITfCandidateString = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetString: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfCandidateString,
                pbstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfCandidateString,
                pbstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfCandidateString,
                pnIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfCandidateString,
                pnIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfCandidateString_GetString(self: *const T, pbstr: ?*?BSTR) HRESULT {
                return @as(*const ITfCandidateString.VTable, @ptrCast(self.vtable)).GetString(@as(*const ITfCandidateString, @ptrCast(self)), pbstr);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfCandidateString_GetIndex(self: *const T, pnIndex: ?*u32) HRESULT {
                return @as(*const ITfCandidateString.VTable, @ptrCast(self.vtable)).GetIndex(@as(*const ITfCandidateString, @ptrCast(self)), pnIndex);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumTfCandidates_Value = Guid.initString("defb1926-6c80-4ce8-87d4-d6b72b812bde");
pub const IID_IEnumTfCandidates = &IID_IEnumTfCandidates_Value;
pub const IEnumTfCandidates = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumTfCandidates,
                ppEnum: ?*?*IEnumTfCandidates,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumTfCandidates,
                ppEnum: ?*?*IEnumTfCandidates,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumTfCandidates,
                ulCount: u32,
                ppCand: [*]?*ITfCandidateString,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumTfCandidates,
                ulCount: u32,
                ppCand: [*]?*ITfCandidateString,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumTfCandidates,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumTfCandidates,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumTfCandidates,
                ulCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumTfCandidates,
                ulCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumTfCandidates_Clone(self: *const T, ppEnum: ?*?*IEnumTfCandidates) HRESULT {
                return @as(*const IEnumTfCandidates.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumTfCandidates, @ptrCast(self)), ppEnum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumTfCandidates_Next(self: *const T, ulCount: u32, ppCand: [*]?*ITfCandidateString, pcFetched: ?*u32) HRESULT {
                return @as(*const IEnumTfCandidates.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumTfCandidates, @ptrCast(self)), ulCount, ppCand, pcFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumTfCandidates_Reset(self: *const T) HRESULT {
                return @as(*const IEnumTfCandidates.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumTfCandidates, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumTfCandidates_Skip(self: *const T, ulCount: u32) HRESULT {
                return @as(*const IEnumTfCandidates.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumTfCandidates, @ptrCast(self)), ulCount);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const TfCandidateResult = enum(i32) {
    FINALIZED = 0,
    SELECTED = 1,
    CANCELED = 2,
};
pub const CAND_FINALIZED = TfCandidateResult.FINALIZED;
pub const CAND_SELECTED = TfCandidateResult.SELECTED;
pub const CAND_CANCELED = TfCandidateResult.CANCELED;

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfCandidateList_Value = Guid.initString("a3ad50fb-9bdb-49e3-a843-6c76520fbf5d");
pub const IID_ITfCandidateList = &IID_ITfCandidateList_Value;
pub const ITfCandidateList = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EnumCandidates: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfCandidateList,
                ppEnum: ?*?*IEnumTfCandidates,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfCandidateList,
                ppEnum: ?*?*IEnumTfCandidates,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCandidate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfCandidateList,
                nIndex: u32,
                ppCand: ?*?*ITfCandidateString,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfCandidateList,
                nIndex: u32,
                ppCand: ?*?*ITfCandidateString,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCandidateNum: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfCandidateList,
                pnCnt: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfCandidateList,
                pnCnt: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetResult: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfCandidateList,
                nIndex: u32,
                imcr: TfCandidateResult,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfCandidateList,
                nIndex: u32,
                imcr: TfCandidateResult,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfCandidateList_EnumCandidates(self: *const T, ppEnum: ?*?*IEnumTfCandidates) HRESULT {
                return @as(*const ITfCandidateList.VTable, @ptrCast(self.vtable)).EnumCandidates(@as(*const ITfCandidateList, @ptrCast(self)), ppEnum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfCandidateList_GetCandidate(self: *const T, nIndex: u32, ppCand: ?*?*ITfCandidateString) HRESULT {
                return @as(*const ITfCandidateList.VTable, @ptrCast(self.vtable)).GetCandidate(@as(*const ITfCandidateList, @ptrCast(self)), nIndex, ppCand);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfCandidateList_GetCandidateNum(self: *const T, pnCnt: ?*u32) HRESULT {
                return @as(*const ITfCandidateList.VTable, @ptrCast(self.vtable)).GetCandidateNum(@as(*const ITfCandidateList, @ptrCast(self)), pnCnt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfCandidateList_SetResult(self: *const T, nIndex: u32, imcr: TfCandidateResult) HRESULT {
                return @as(*const ITfCandidateList.VTable, @ptrCast(self.vtable)).SetResult(@as(*const ITfCandidateList, @ptrCast(self)), nIndex, imcr);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfFnReconversion_Value = Guid.initString("4cea93c0-0a58-11d3-8df0-00105a2799b5");
pub const IID_ITfFnReconversion = &IID_ITfFnReconversion_Value;
pub const ITfFnReconversion = extern struct {
    pub const VTable = extern struct {
        base: ITfFunction.VTable,
        QueryRange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfFnReconversion,
                pRange: ?*ITfRange,
                ppNewRange: ?*?*ITfRange,
                pfConvertable: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfFnReconversion,
                pRange: ?*ITfRange,
                ppNewRange: ?*?*ITfRange,
                pfConvertable: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetReconversion: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfFnReconversion,
                pRange: ?*ITfRange,
                ppCandList: ?*?*ITfCandidateList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfFnReconversion,
                pRange: ?*ITfRange,
                ppCandList: ?*?*ITfCandidateList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reconvert: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfFnReconversion,
                pRange: ?*ITfRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfFnReconversion,
                pRange: ?*ITfRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITfFunction.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfFnReconversion_QueryRange(self: *const T, pRange: ?*ITfRange, ppNewRange: ?*?*ITfRange, pfConvertable: ?*BOOL) HRESULT {
                return @as(*const ITfFnReconversion.VTable, @ptrCast(self.vtable)).QueryRange(@as(*const ITfFnReconversion, @ptrCast(self)), pRange, ppNewRange, pfConvertable);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfFnReconversion_GetReconversion(self: *const T, pRange: ?*ITfRange, ppCandList: ?*?*ITfCandidateList) HRESULT {
                return @as(*const ITfFnReconversion.VTable, @ptrCast(self.vtable)).GetReconversion(@as(*const ITfFnReconversion, @ptrCast(self)), pRange, ppCandList);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfFnReconversion_Reconvert(self: *const T, pRange: ?*ITfRange) HRESULT {
                return @as(*const ITfFnReconversion.VTable, @ptrCast(self.vtable)).Reconvert(@as(*const ITfFnReconversion, @ptrCast(self)), pRange);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfFnPlayBack_Value = Guid.initString("a3a416a4-0f64-11d3-b5b7-00c04fc324a1");
pub const IID_ITfFnPlayBack = &IID_ITfFnPlayBack_Value;
pub const ITfFnPlayBack = extern struct {
    pub const VTable = extern struct {
        base: ITfFunction.VTable,
        QueryRange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfFnPlayBack,
                pRange: ?*ITfRange,
                ppNewRange: ?*?*ITfRange,
                pfPlayable: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfFnPlayBack,
                pRange: ?*ITfRange,
                ppNewRange: ?*?*ITfRange,
                pfPlayable: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Play: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfFnPlayBack,
                pRange: ?*ITfRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfFnPlayBack,
                pRange: ?*ITfRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITfFunction.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfFnPlayBack_QueryRange(self: *const T, pRange: ?*ITfRange, ppNewRange: ?*?*ITfRange, pfPlayable: ?*BOOL) HRESULT {
                return @as(*const ITfFnPlayBack.VTable, @ptrCast(self.vtable)).QueryRange(@as(*const ITfFnPlayBack, @ptrCast(self)), pRange, ppNewRange, pfPlayable);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfFnPlayBack_Play(self: *const T, pRange: ?*ITfRange) HRESULT {
                return @as(*const ITfFnPlayBack.VTable, @ptrCast(self.vtable)).Play(@as(*const ITfFnPlayBack, @ptrCast(self)), pRange);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfFnLangProfileUtil_Value = Guid.initString("a87a8574-a6c1-4e15-99f0-3d3965f548eb");
pub const IID_ITfFnLangProfileUtil = &IID_ITfFnLangProfileUtil_Value;
pub const ITfFnLangProfileUtil = extern struct {
    pub const VTable = extern struct {
        base: ITfFunction.VTable,
        RegisterActiveProfiles: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfFnLangProfileUtil,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfFnLangProfileUtil,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsProfileAvailableForLang: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfFnLangProfileUtil,
                langid: u16,
                pfAvailable: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfFnLangProfileUtil,
                langid: u16,
                pfAvailable: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITfFunction.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfFnLangProfileUtil_RegisterActiveProfiles(self: *const T) HRESULT {
                return @as(*const ITfFnLangProfileUtil.VTable, @ptrCast(self.vtable)).RegisterActiveProfiles(@as(*const ITfFnLangProfileUtil, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfFnLangProfileUtil_IsProfileAvailableForLang(self: *const T, langid: u16, pfAvailable: ?*BOOL) HRESULT {
                return @as(*const ITfFnLangProfileUtil.VTable, @ptrCast(self.vtable)).IsProfileAvailableForLang(@as(*const ITfFnLangProfileUtil, @ptrCast(self)), langid, pfAvailable);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfFnConfigure_Value = Guid.initString("88f567c6-1757-49f8-a1b2-89234c1eeff9");
pub const IID_ITfFnConfigure = &IID_ITfFnConfigure_Value;
pub const ITfFnConfigure = extern struct {
    pub const VTable = extern struct {
        base: ITfFunction.VTable,
        Show: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfFnConfigure,
                hwndParent: ?HWND,
                langid: u16,
                rguidProfile: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfFnConfigure,
                hwndParent: ?HWND,
                langid: u16,
                rguidProfile: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITfFunction.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfFnConfigure_Show(self: *const T, hwndParent: ?HWND, langid: u16, rguidProfile: ?*const Guid) HRESULT {
                return @as(*const ITfFnConfigure.VTable, @ptrCast(self.vtable)).Show(@as(*const ITfFnConfigure, @ptrCast(self)), hwndParent, langid, rguidProfile);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfFnConfigureRegisterWord_Value = Guid.initString("bb95808a-6d8f-4bca-8400-5390b586aedf");
pub const IID_ITfFnConfigureRegisterWord = &IID_ITfFnConfigureRegisterWord_Value;
pub const ITfFnConfigureRegisterWord = extern struct {
    pub const VTable = extern struct {
        base: ITfFunction.VTable,
        Show: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfFnConfigureRegisterWord,
                hwndParent: ?HWND,
                langid: u16,
                rguidProfile: ?*const Guid,
                bstrRegistered: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfFnConfigureRegisterWord,
                hwndParent: ?HWND,
                langid: u16,
                rguidProfile: ?*const Guid,
                bstrRegistered: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITfFunction.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfFnConfigureRegisterWord_Show(self: *const T, hwndParent: ?HWND, langid: u16, rguidProfile: ?*const Guid, bstrRegistered: ?BSTR) HRESULT {
                return @as(*const ITfFnConfigureRegisterWord.VTable, @ptrCast(self.vtable)).Show(@as(*const ITfFnConfigureRegisterWord, @ptrCast(self)), hwndParent, langid, rguidProfile, bstrRegistered);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfFnConfigureRegisterEudc_Value = Guid.initString("b5e26ff5-d7ad-4304-913f-21a2ed95a1b0");
pub const IID_ITfFnConfigureRegisterEudc = &IID_ITfFnConfigureRegisterEudc_Value;
pub const ITfFnConfigureRegisterEudc = extern struct {
    pub const VTable = extern struct {
        base: ITfFunction.VTable,
        Show: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfFnConfigureRegisterEudc,
                hwndParent: ?HWND,
                langid: u16,
                rguidProfile: ?*const Guid,
                bstrRegistered: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfFnConfigureRegisterEudc,
                hwndParent: ?HWND,
                langid: u16,
                rguidProfile: ?*const Guid,
                bstrRegistered: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITfFunction.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfFnConfigureRegisterEudc_Show(self: *const T, hwndParent: ?HWND, langid: u16, rguidProfile: ?*const Guid, bstrRegistered: ?BSTR) HRESULT {
                return @as(*const ITfFnConfigureRegisterEudc.VTable, @ptrCast(self.vtable)).Show(@as(*const ITfFnConfigureRegisterEudc, @ptrCast(self)), hwndParent, langid, rguidProfile, bstrRegistered);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfFnShowHelp_Value = Guid.initString("5ab1d30c-094d-4c29-8ea5-0bf59be87bf3");
pub const IID_ITfFnShowHelp = &IID_ITfFnShowHelp_Value;
pub const ITfFnShowHelp = extern struct {
    pub const VTable = extern struct {
        base: ITfFunction.VTable,
        Show: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfFnShowHelp,
                hwndParent: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfFnShowHelp,
                hwndParent: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITfFunction.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfFnShowHelp_Show(self: *const T, hwndParent: ?HWND) HRESULT {
                return @as(*const ITfFnShowHelp.VTable, @ptrCast(self.vtable)).Show(@as(*const ITfFnShowHelp, @ptrCast(self)), hwndParent);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfFnBalloon_Value = Guid.initString("3bab89e4-5fbe-45f4-a5bc-dca36ad225a8");
pub const IID_ITfFnBalloon = &IID_ITfFnBalloon_Value;
pub const ITfFnBalloon = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        UpdateBalloon: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfFnBalloon,
                style: TfLBBalloonStyle,
                pch: [*:0]const u16,
                cch: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfFnBalloon,
                style: TfLBBalloonStyle,
                pch: [*:0]const u16,
                cch: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfFnBalloon_UpdateBalloon(self: *const T, style: TfLBBalloonStyle, pch: [*:0]const u16, cch: u32) HRESULT {
                return @as(*const ITfFnBalloon.VTable, @ptrCast(self.vtable)).UpdateBalloon(@as(*const ITfFnBalloon, @ptrCast(self)), style, pch, cch);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const TfSapiObject = enum(i32) {
    RESMGR = 0,
    RECOCONTEXT = 1,
    RECOGNIZER = 2,
    VOICE = 3,
    DICTGRAM = 4,
    RECOGNIZERNOINIT = 5,
};
pub const GETIF_RESMGR = TfSapiObject.RESMGR;
pub const GETIF_RECOCONTEXT = TfSapiObject.RECOCONTEXT;
pub const GETIF_RECOGNIZER = TfSapiObject.RECOGNIZER;
pub const GETIF_VOICE = TfSapiObject.VOICE;
pub const GETIF_DICTGRAM = TfSapiObject.DICTGRAM;
pub const GETIF_RECOGNIZERNOINIT = TfSapiObject.RECOGNIZERNOINIT;

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfFnGetSAPIObject_Value = Guid.initString("5c0ab7ea-167d-4f59-bfb5-4693755e90ca");
pub const IID_ITfFnGetSAPIObject = &IID_ITfFnGetSAPIObject_Value;
pub const ITfFnGetSAPIObject = extern struct {
    pub const VTable = extern struct {
        base: ITfFunction.VTable,
        Get: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfFnGetSAPIObject,
                sObj: TfSapiObject,
                ppunk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfFnGetSAPIObject,
                sObj: TfSapiObject,
                ppunk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITfFunction.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfFnGetSAPIObject_Get(self: *const T, sObj: TfSapiObject, ppunk: ?*?*IUnknown) HRESULT {
                return @as(*const ITfFnGetSAPIObject.VTable, @ptrCast(self.vtable)).Get(@as(*const ITfFnGetSAPIObject, @ptrCast(self)), sObj, ppunk);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfFnPropertyUIStatus_Value = Guid.initString("2338ac6e-2b9d-44c0-a75e-ee64f256b3bd");
pub const IID_ITfFnPropertyUIStatus = &IID_ITfFnPropertyUIStatus_Value;
pub const ITfFnPropertyUIStatus = extern struct {
    pub const VTable = extern struct {
        base: ITfFunction.VTable,
        GetStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfFnPropertyUIStatus,
                refguidProp: ?*const Guid,
                pdw: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfFnPropertyUIStatus,
                refguidProp: ?*const Guid,
                pdw: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfFnPropertyUIStatus,
                refguidProp: ?*const Guid,
                dw: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfFnPropertyUIStatus,
                refguidProp: ?*const Guid,
                dw: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITfFunction.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfFnPropertyUIStatus_GetStatus(self: *const T, refguidProp: ?*const Guid, pdw: ?*u32) HRESULT {
                return @as(*const ITfFnPropertyUIStatus.VTable, @ptrCast(self.vtable)).GetStatus(@as(*const ITfFnPropertyUIStatus, @ptrCast(self)), refguidProp, pdw);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfFnPropertyUIStatus_SetStatus(self: *const T, refguidProp: ?*const Guid, dw: u32) HRESULT {
                return @as(*const ITfFnPropertyUIStatus.VTable, @ptrCast(self.vtable)).SetStatus(@as(*const ITfFnPropertyUIStatus, @ptrCast(self)), refguidProp, dw);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumSpeechCommands_Value = Guid.initString("8c5dac4f-083c-4b85-a4c9-71746048adca");
pub const IID_IEnumSpeechCommands = &IID_IEnumSpeechCommands_Value;
pub const IEnumSpeechCommands = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumSpeechCommands,
                ppEnum: ?*?*IEnumSpeechCommands,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumSpeechCommands,
                ppEnum: ?*?*IEnumSpeechCommands,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumSpeechCommands,
                ulCount: u32,
                pSpCmds: [*]?*u16,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumSpeechCommands,
                ulCount: u32,
                pSpCmds: [*]?*u16,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumSpeechCommands,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumSpeechCommands,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumSpeechCommands,
                ulCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumSpeechCommands,
                ulCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumSpeechCommands_Clone(self: *const T, ppEnum: ?*?*IEnumSpeechCommands) HRESULT {
                return @as(*const IEnumSpeechCommands.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumSpeechCommands, @ptrCast(self)), ppEnum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumSpeechCommands_Next(self: *const T, ulCount: u32, pSpCmds: [*]?*u16, pcFetched: ?*u32) HRESULT {
                return @as(*const IEnumSpeechCommands.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumSpeechCommands, @ptrCast(self)), ulCount, pSpCmds, pcFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumSpeechCommands_Reset(self: *const T) HRESULT {
                return @as(*const IEnumSpeechCommands.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumSpeechCommands, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumSpeechCommands_Skip(self: *const T, ulCount: u32) HRESULT {
                return @as(*const IEnumSpeechCommands.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumSpeechCommands, @ptrCast(self)), ulCount);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechCommandProvider_Value = Guid.initString("38e09d4c-586d-435a-b592-c8a86691dec6");
pub const IID_ISpeechCommandProvider = &IID_ISpeechCommandProvider_Value;
pub const ISpeechCommandProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EnumSpeechCommands: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISpeechCommandProvider,
                langid: u16,
                ppEnum: ?*?*IEnumSpeechCommands,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISpeechCommandProvider,
                langid: u16,
                ppEnum: ?*?*IEnumSpeechCommands,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ProcessCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISpeechCommandProvider,
                pszCommand: [*:0]const u16,
                cch: u32,
                langid: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISpeechCommandProvider,
                pszCommand: [*:0]const u16,
                cch: u32,
                langid: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISpeechCommandProvider_EnumSpeechCommands(self: *const T, langid: u16, ppEnum: ?*?*IEnumSpeechCommands) HRESULT {
                return @as(*const ISpeechCommandProvider.VTable, @ptrCast(self.vtable)).EnumSpeechCommands(@as(*const ISpeechCommandProvider, @ptrCast(self)), langid, ppEnum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISpeechCommandProvider_ProcessCommand(self: *const T, pszCommand: [*:0]const u16, cch: u32, langid: u16) HRESULT {
                return @as(*const ISpeechCommandProvider.VTable, @ptrCast(self.vtable)).ProcessCommand(@as(*const ISpeechCommandProvider, @ptrCast(self)), pszCommand, cch, langid);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITfFnCustomSpeechCommand_Value = Guid.initString("fca6c349-a12f-43a3-8dd6-5a5a4282577b");
pub const IID_ITfFnCustomSpeechCommand = &IID_ITfFnCustomSpeechCommand_Value;
pub const ITfFnCustomSpeechCommand = extern struct {
    pub const VTable = extern struct {
        base: ITfFunction.VTable,
        SetSpeechCommandProvider: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfFnCustomSpeechCommand,
                pspcmdProvider: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfFnCustomSpeechCommand,
                pspcmdProvider: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITfFunction.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfFnCustomSpeechCommand_SetSpeechCommandProvider(self: *const T, pspcmdProvider: ?*IUnknown) HRESULT {
                return @as(*const ITfFnCustomSpeechCommand.VTable, @ptrCast(self.vtable)).SetSpeechCommandProvider(@as(*const ITfFnCustomSpeechCommand, @ptrCast(self)), pspcmdProvider);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfFnLMProcessor_Value = Guid.initString("7afbf8e7-ac4b-4082-b058-890899d3a010");
pub const IID_ITfFnLMProcessor = &IID_ITfFnLMProcessor_Value;
pub const ITfFnLMProcessor = extern struct {
    pub const VTable = extern struct {
        base: ITfFunction.VTable,
        QueryRange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfFnLMProcessor,
                pRange: ?*ITfRange,
                ppNewRange: ?*?*ITfRange,
                pfAccepted: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfFnLMProcessor,
                pRange: ?*ITfRange,
                ppNewRange: ?*?*ITfRange,
                pfAccepted: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryLangID: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfFnLMProcessor,
                langid: u16,
                pfAccepted: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfFnLMProcessor,
                langid: u16,
                pfAccepted: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetReconversion: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfFnLMProcessor,
                pRange: ?*ITfRange,
                ppCandList: ?*?*ITfCandidateList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfFnLMProcessor,
                pRange: ?*ITfRange,
                ppCandList: ?*?*ITfCandidateList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reconvert: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfFnLMProcessor,
                pRange: ?*ITfRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfFnLMProcessor,
                pRange: ?*ITfRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryKey: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfFnLMProcessor,
                fUp: BOOL,
                vKey: WPARAM,
                lparamKeydata: LPARAM,
                pfInterested: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfFnLMProcessor,
                fUp: BOOL,
                vKey: WPARAM,
                lparamKeydata: LPARAM,
                pfInterested: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InvokeKey: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfFnLMProcessor,
                fUp: BOOL,
                vKey: WPARAM,
                lparamKeyData: LPARAM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfFnLMProcessor,
                fUp: BOOL,
                vKey: WPARAM,
                lparamKeyData: LPARAM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InvokeFunc: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfFnLMProcessor,
                pic: ?*ITfContext,
                refguidFunc: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfFnLMProcessor,
                pic: ?*ITfContext,
                refguidFunc: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITfFunction.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfFnLMProcessor_QueryRange(self: *const T, pRange: ?*ITfRange, ppNewRange: ?*?*ITfRange, pfAccepted: ?*BOOL) HRESULT {
                return @as(*const ITfFnLMProcessor.VTable, @ptrCast(self.vtable)).QueryRange(@as(*const ITfFnLMProcessor, @ptrCast(self)), pRange, ppNewRange, pfAccepted);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfFnLMProcessor_QueryLangID(self: *const T, langid: u16, pfAccepted: ?*BOOL) HRESULT {
                return @as(*const ITfFnLMProcessor.VTable, @ptrCast(self.vtable)).QueryLangID(@as(*const ITfFnLMProcessor, @ptrCast(self)), langid, pfAccepted);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfFnLMProcessor_GetReconversion(self: *const T, pRange: ?*ITfRange, ppCandList: ?*?*ITfCandidateList) HRESULT {
                return @as(*const ITfFnLMProcessor.VTable, @ptrCast(self.vtable)).GetReconversion(@as(*const ITfFnLMProcessor, @ptrCast(self)), pRange, ppCandList);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfFnLMProcessor_Reconvert(self: *const T, pRange: ?*ITfRange) HRESULT {
                return @as(*const ITfFnLMProcessor.VTable, @ptrCast(self.vtable)).Reconvert(@as(*const ITfFnLMProcessor, @ptrCast(self)), pRange);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfFnLMProcessor_QueryKey(self: *const T, fUp: BOOL, vKey: WPARAM, lparamKeydata: LPARAM, pfInterested: ?*BOOL) HRESULT {
                return @as(*const ITfFnLMProcessor.VTable, @ptrCast(self.vtable)).QueryKey(@as(*const ITfFnLMProcessor, @ptrCast(self)), fUp, vKey, lparamKeydata, pfInterested);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfFnLMProcessor_InvokeKey(self: *const T, fUp: BOOL, vKey: WPARAM, lparamKeyData: LPARAM) HRESULT {
                return @as(*const ITfFnLMProcessor.VTable, @ptrCast(self.vtable)).InvokeKey(@as(*const ITfFnLMProcessor, @ptrCast(self)), fUp, vKey, lparamKeyData);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfFnLMProcessor_InvokeFunc(self: *const T, pic: ?*ITfContext, refguidFunc: ?*const Guid) HRESULT {
                return @as(*const ITfFnLMProcessor.VTable, @ptrCast(self.vtable)).InvokeFunc(@as(*const ITfFnLMProcessor, @ptrCast(self)), pic, refguidFunc);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfFnLMInternal_Value = Guid.initString("04b825b1-ac9a-4f7b-b5ad-c7168f1ee445");
pub const IID_ITfFnLMInternal = &IID_ITfFnLMInternal_Value;
pub const ITfFnLMInternal = extern struct {
    pub const VTable = extern struct {
        base: ITfFnLMProcessor.VTable,
        ProcessLattice: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfFnLMInternal,
                pRange: ?*ITfRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfFnLMInternal,
                pRange: ?*ITfRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITfFnLMProcessor.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfFnLMInternal_ProcessLattice(self: *const T, pRange: ?*ITfRange) HRESULT {
                return @as(*const ITfFnLMInternal.VTable, @ptrCast(self.vtable)).ProcessLattice(@as(*const ITfFnLMInternal, @ptrCast(self)), pRange);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const TF_LMLATTELEMENT = extern struct {
    dwFrameStart: u32,
    dwFrameLen: u32,
    dwFlags: u32,
    Anonymous: extern union {
        iCost: i32,
    },
    bstrText: ?BSTR,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumTfLatticeElements_Value = Guid.initString("56988052-47da-4a05-911a-e3d941f17145");
pub const IID_IEnumTfLatticeElements = &IID_IEnumTfLatticeElements_Value;
pub const IEnumTfLatticeElements = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumTfLatticeElements,
                ppEnum: ?*?*IEnumTfLatticeElements,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumTfLatticeElements,
                ppEnum: ?*?*IEnumTfLatticeElements,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumTfLatticeElements,
                ulCount: u32,
                rgsElements: [*]TF_LMLATTELEMENT,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumTfLatticeElements,
                ulCount: u32,
                rgsElements: [*]TF_LMLATTELEMENT,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumTfLatticeElements,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumTfLatticeElements,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumTfLatticeElements,
                ulCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumTfLatticeElements,
                ulCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumTfLatticeElements_Clone(self: *const T, ppEnum: ?*?*IEnumTfLatticeElements) HRESULT {
                return @as(*const IEnumTfLatticeElements.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumTfLatticeElements, @ptrCast(self)), ppEnum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumTfLatticeElements_Next(self: *const T, ulCount: u32, rgsElements: [*]TF_LMLATTELEMENT, pcFetched: ?*u32) HRESULT {
                return @as(*const IEnumTfLatticeElements.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumTfLatticeElements, @ptrCast(self)), ulCount, rgsElements, pcFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumTfLatticeElements_Reset(self: *const T) HRESULT {
                return @as(*const IEnumTfLatticeElements.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumTfLatticeElements, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumTfLatticeElements_Skip(self: *const T, ulCount: u32) HRESULT {
                return @as(*const IEnumTfLatticeElements.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumTfLatticeElements, @ptrCast(self)), ulCount);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfLMLattice_Value = Guid.initString("d4236675-a5bf-4570-9d42-5d6d7b02d59b");
pub const IID_ITfLMLattice = &IID_ITfLMLattice_Value;
pub const ITfLMLattice = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfLMLattice,
                rguidType: ?*const Guid,
                pfSupported: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfLMLattice,
                rguidType: ?*const Guid,
                pfSupported: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumLatticeElements: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfLMLattice,
                dwFrameStart: u32,
                rguidType: ?*const Guid,
                ppEnum: ?*?*IEnumTfLatticeElements,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfLMLattice,
                dwFrameStart: u32,
                rguidType: ?*const Guid,
                ppEnum: ?*?*IEnumTfLatticeElements,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfLMLattice_QueryType(self: *const T, rguidType: ?*const Guid, pfSupported: ?*BOOL) HRESULT {
                return @as(*const ITfLMLattice.VTable, @ptrCast(self.vtable)).QueryType(@as(*const ITfLMLattice, @ptrCast(self)), rguidType, pfSupported);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfLMLattice_EnumLatticeElements(self: *const T, dwFrameStart: u32, rguidType: ?*const Guid, ppEnum: ?*?*IEnumTfLatticeElements) HRESULT {
                return @as(*const ITfLMLattice.VTable, @ptrCast(self.vtable)).EnumLatticeElements(@as(*const ITfLMLattice, @ptrCast(self)), dwFrameStart, rguidType, ppEnum);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfFnAdviseText_Value = Guid.initString("3527268b-7d53-4dd9-92b7-7296ae461249");
pub const IID_ITfFnAdviseText = &IID_ITfFnAdviseText_Value;
pub const ITfFnAdviseText = extern struct {
    pub const VTable = extern struct {
        base: ITfFunction.VTable,
        OnTextUpdate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfFnAdviseText,
                pRange: ?*ITfRange,
                pchText: [*:0]const u16,
                cch: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfFnAdviseText,
                pRange: ?*ITfRange,
                pchText: [*:0]const u16,
                cch: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnLatticeUpdate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfFnAdviseText,
                pRange: ?*ITfRange,
                pLattice: ?*ITfLMLattice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfFnAdviseText,
                pRange: ?*ITfRange,
                pLattice: ?*ITfLMLattice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITfFunction.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfFnAdviseText_OnTextUpdate(self: *const T, pRange: ?*ITfRange, pchText: [*:0]const u16, cch: i32) HRESULT {
                return @as(*const ITfFnAdviseText.VTable, @ptrCast(self.vtable)).OnTextUpdate(@as(*const ITfFnAdviseText, @ptrCast(self)), pRange, pchText, cch);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfFnAdviseText_OnLatticeUpdate(self: *const T, pRange: ?*ITfRange, pLattice: ?*ITfLMLattice) HRESULT {
                return @as(*const ITfFnAdviseText.VTable, @ptrCast(self.vtable)).OnLatticeUpdate(@as(*const ITfFnAdviseText, @ptrCast(self)), pRange, pLattice);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ITfFnSearchCandidateProvider_Value = Guid.initString("87a2ad8f-f27b-4920-8501-67602280175d");
pub const IID_ITfFnSearchCandidateProvider = &IID_ITfFnSearchCandidateProvider_Value;
pub const ITfFnSearchCandidateProvider = extern struct {
    pub const VTable = extern struct {
        base: ITfFunction.VTable,
        GetSearchCandidates: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfFnSearchCandidateProvider,
                bstrQuery: ?BSTR,
                bstrApplicationId: ?BSTR,
                pplist: ?*?*ITfCandidateList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfFnSearchCandidateProvider,
                bstrQuery: ?BSTR,
                bstrApplicationId: ?BSTR,
                pplist: ?*?*ITfCandidateList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetResult: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfFnSearchCandidateProvider,
                bstrQuery: ?BSTR,
                bstrApplicationID: ?BSTR,
                bstrResult: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfFnSearchCandidateProvider,
                bstrQuery: ?BSTR,
                bstrApplicationID: ?BSTR,
                bstrResult: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITfFunction.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfFnSearchCandidateProvider_GetSearchCandidates(self: *const T, bstrQuery: ?BSTR, bstrApplicationId: ?BSTR, pplist: ?*?*ITfCandidateList) HRESULT {
                return @as(*const ITfFnSearchCandidateProvider.VTable, @ptrCast(self.vtable)).GetSearchCandidates(@as(*const ITfFnSearchCandidateProvider, @ptrCast(self)), bstrQuery, bstrApplicationId, pplist);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfFnSearchCandidateProvider_SetResult(self: *const T, bstrQuery: ?BSTR, bstrApplicationID: ?BSTR, bstrResult: ?BSTR) HRESULT {
                return @as(*const ITfFnSearchCandidateProvider.VTable, @ptrCast(self.vtable)).SetResult(@as(*const ITfFnSearchCandidateProvider, @ptrCast(self)), bstrQuery, bstrApplicationID, bstrResult);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const TfIntegratableCandidateListSelectionStyle = enum(i32) {
    ACTIVE_SELECTION = 0,
    IMPLIED_SELECTION = 1,
};
pub const STYLE_ACTIVE_SELECTION = TfIntegratableCandidateListSelectionStyle.ACTIVE_SELECTION;
pub const STYLE_IMPLIED_SELECTION = TfIntegratableCandidateListSelectionStyle.IMPLIED_SELECTION;

// TODO: this type is limited to platform 'windows8.0'
const IID_ITfIntegratableCandidateListUIElement_Value = Guid.initString("c7a6f54f-b180-416f-b2bf-7bf2e4683d7b");
pub const IID_ITfIntegratableCandidateListUIElement = &IID_ITfIntegratableCandidateListUIElement_Value;
pub const ITfIntegratableCandidateListUIElement = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetIntegrationStyle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfIntegratableCandidateListUIElement,
                guidIntegrationStyle: Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfIntegratableCandidateListUIElement,
                guidIntegrationStyle: Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSelectionStyle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfIntegratableCandidateListUIElement,
                ptfSelectionStyle: ?*TfIntegratableCandidateListSelectionStyle,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfIntegratableCandidateListUIElement,
                ptfSelectionStyle: ?*TfIntegratableCandidateListSelectionStyle,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnKeyDown: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfIntegratableCandidateListUIElement,
                wParam: WPARAM,
                lParam: LPARAM,
                pfEaten: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfIntegratableCandidateListUIElement,
                wParam: WPARAM,
                lParam: LPARAM,
                pfEaten: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ShowCandidateNumbers: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfIntegratableCandidateListUIElement,
                pfShow: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfIntegratableCandidateListUIElement,
                pfShow: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FinalizeExactCompositionString: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfIntegratableCandidateListUIElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfIntegratableCandidateListUIElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfIntegratableCandidateListUIElement_SetIntegrationStyle(self: *const T, guidIntegrationStyle: Guid) HRESULT {
                return @as(*const ITfIntegratableCandidateListUIElement.VTable, @ptrCast(self.vtable)).SetIntegrationStyle(@as(*const ITfIntegratableCandidateListUIElement, @ptrCast(self)), guidIntegrationStyle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfIntegratableCandidateListUIElement_GetSelectionStyle(self: *const T, ptfSelectionStyle: ?*TfIntegratableCandidateListSelectionStyle) HRESULT {
                return @as(*const ITfIntegratableCandidateListUIElement.VTable, @ptrCast(self.vtable)).GetSelectionStyle(@as(*const ITfIntegratableCandidateListUIElement, @ptrCast(self)), ptfSelectionStyle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfIntegratableCandidateListUIElement_OnKeyDown(self: *const T, wParam: WPARAM, lParam: LPARAM, pfEaten: ?*BOOL) HRESULT {
                return @as(*const ITfIntegratableCandidateListUIElement.VTable, @ptrCast(self.vtable)).OnKeyDown(@as(*const ITfIntegratableCandidateListUIElement, @ptrCast(self)), wParam, lParam, pfEaten);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfIntegratableCandidateListUIElement_ShowCandidateNumbers(self: *const T, pfShow: ?*BOOL) HRESULT {
                return @as(*const ITfIntegratableCandidateListUIElement.VTable, @ptrCast(self.vtable)).ShowCandidateNumbers(@as(*const ITfIntegratableCandidateListUIElement, @ptrCast(self)), pfShow);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfIntegratableCandidateListUIElement_FinalizeExactCompositionString(self: *const T) HRESULT {
                return @as(*const ITfIntegratableCandidateListUIElement.VTable, @ptrCast(self.vtable)).FinalizeExactCompositionString(@as(*const ITfIntegratableCandidateListUIElement, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const TKBLayoutType = enum(i32) {
    UNDEFINED = 0,
    CLASSIC = 1,
    OPTIMIZED = 2,
};
pub const TKBLT_UNDEFINED = TKBLayoutType.UNDEFINED;
pub const TKBLT_CLASSIC = TKBLayoutType.CLASSIC;
pub const TKBLT_OPTIMIZED = TKBLayoutType.OPTIMIZED;

// TODO: this type is limited to platform 'windows8.0'
const IID_ITfFnGetPreferredTouchKeyboardLayout_Value = Guid.initString("5f309a41-590a-4acc-a97f-d8efff13fdfc");
pub const IID_ITfFnGetPreferredTouchKeyboardLayout = &IID_ITfFnGetPreferredTouchKeyboardLayout_Value;
pub const ITfFnGetPreferredTouchKeyboardLayout = extern struct {
    pub const VTable = extern struct {
        base: ITfFunction.VTable,
        GetLayout: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfFnGetPreferredTouchKeyboardLayout,
                pTKBLayoutType: ?*TKBLayoutType,
                pwPreferredLayoutId: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfFnGetPreferredTouchKeyboardLayout,
                pTKBLayoutType: ?*TKBLayoutType,
                pwPreferredLayoutId: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITfFunction.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfFnGetPreferredTouchKeyboardLayout_GetLayout(self: *const T, pTKBLayoutType: ?*TKBLayoutType, pwPreferredLayoutId: ?*u16) HRESULT {
                return @as(*const ITfFnGetPreferredTouchKeyboardLayout.VTable, @ptrCast(self.vtable)).GetLayout(@as(*const ITfFnGetPreferredTouchKeyboardLayout, @ptrCast(self)), pTKBLayoutType, pwPreferredLayoutId);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.1'
const IID_ITfFnGetLinguisticAlternates_Value = Guid.initString("ea163ce2-7a65-4506-82a3-c528215da64e");
pub const IID_ITfFnGetLinguisticAlternates = &IID_ITfFnGetLinguisticAlternates_Value;
pub const ITfFnGetLinguisticAlternates = extern struct {
    pub const VTable = extern struct {
        base: ITfFunction.VTable,
        GetAlternates: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfFnGetLinguisticAlternates,
                pRange: ?*ITfRange,
                ppCandidateList: ?*?*ITfCandidateList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfFnGetLinguisticAlternates,
                pRange: ?*ITfRange,
                ppCandidateList: ?*?*ITfCandidateList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITfFunction.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfFnGetLinguisticAlternates_GetAlternates(self: *const T, pRange: ?*ITfRange, ppCandidateList: ?*?*ITfCandidateList) HRESULT {
                return @as(*const ITfFnGetLinguisticAlternates.VTable, @ptrCast(self.vtable)).GetAlternates(@as(*const ITfFnGetLinguisticAlternates, @ptrCast(self)), pRange, ppCandidateList);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.1'
const IID_IUIManagerEventSink_Value = Guid.initString("cd91d690-a7e8-4265-9b38-8bb3bbaba7de");
pub const IID_IUIManagerEventSink = &IID_IUIManagerEventSink_Value;
pub const IUIManagerEventSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnWindowOpening: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIManagerEventSink,
                prcBounds: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIManagerEventSink,
                prcBounds: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnWindowOpened: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIManagerEventSink,
                prcBounds: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIManagerEventSink,
                prcBounds: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnWindowUpdating: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIManagerEventSink,
                prcUpdatedBounds: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIManagerEventSink,
                prcUpdatedBounds: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnWindowUpdated: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIManagerEventSink,
                prcUpdatedBounds: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIManagerEventSink,
                prcUpdatedBounds: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnWindowClosing: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIManagerEventSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIManagerEventSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnWindowClosed: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUIManagerEventSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUIManagerEventSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIManagerEventSink_OnWindowOpening(self: *const T, prcBounds: ?*RECT) HRESULT {
                return @as(*const IUIManagerEventSink.VTable, @ptrCast(self.vtable)).OnWindowOpening(@as(*const IUIManagerEventSink, @ptrCast(self)), prcBounds);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIManagerEventSink_OnWindowOpened(self: *const T, prcBounds: ?*RECT) HRESULT {
                return @as(*const IUIManagerEventSink.VTable, @ptrCast(self.vtable)).OnWindowOpened(@as(*const IUIManagerEventSink, @ptrCast(self)), prcBounds);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIManagerEventSink_OnWindowUpdating(self: *const T, prcUpdatedBounds: ?*RECT) HRESULT {
                return @as(*const IUIManagerEventSink.VTable, @ptrCast(self.vtable)).OnWindowUpdating(@as(*const IUIManagerEventSink, @ptrCast(self)), prcUpdatedBounds);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIManagerEventSink_OnWindowUpdated(self: *const T, prcUpdatedBounds: ?*RECT) HRESULT {
                return @as(*const IUIManagerEventSink.VTable, @ptrCast(self.vtable)).OnWindowUpdated(@as(*const IUIManagerEventSink, @ptrCast(self)), prcUpdatedBounds);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIManagerEventSink_OnWindowClosing(self: *const T) HRESULT {
                return @as(*const IUIManagerEventSink.VTable, @ptrCast(self.vtable)).OnWindowClosing(@as(*const IUIManagerEventSink, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUIManagerEventSink_OnWindowClosed(self: *const T) HRESULT {
                return @as(*const IUIManagerEventSink.VTable, @ptrCast(self.vtable)).OnWindowClosed(@as(*const IUIManagerEventSink, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const InputScope = enum(i32) {
    DEFAULT = 0,
    URL = 1,
    FILE_FULLFILEPATH = 2,
    FILE_FILENAME = 3,
    EMAIL_USERNAME = 4,
    EMAIL_SMTPEMAILADDRESS = 5,
    LOGINNAME = 6,
    PERSONALNAME_FULLNAME = 7,
    PERSONALNAME_PREFIX = 8,
    PERSONALNAME_GIVENNAME = 9,
    PERSONALNAME_MIDDLENAME = 10,
    PERSONALNAME_SURNAME = 11,
    PERSONALNAME_SUFFIX = 12,
    ADDRESS_FULLPOSTALADDRESS = 13,
    ADDRESS_POSTALCODE = 14,
    ADDRESS_STREET = 15,
    ADDRESS_STATEORPROVINCE = 16,
    ADDRESS_CITY = 17,
    ADDRESS_COUNTRYNAME = 18,
    ADDRESS_COUNTRYSHORTNAME = 19,
    CURRENCY_AMOUNTANDSYMBOL = 20,
    CURRENCY_AMOUNT = 21,
    DATE_FULLDATE = 22,
    DATE_MONTH = 23,
    DATE_DAY = 24,
    DATE_YEAR = 25,
    DATE_MONTHNAME = 26,
    DATE_DAYNAME = 27,
    DIGITS = 28,
    NUMBER = 29,
    ONECHAR = 30,
    PASSWORD = 31,
    TELEPHONE_FULLTELEPHONENUMBER = 32,
    TELEPHONE_COUNTRYCODE = 33,
    TELEPHONE_AREACODE = 34,
    TELEPHONE_LOCALNUMBER = 35,
    TIME_FULLTIME = 36,
    TIME_HOUR = 37,
    TIME_MINORSEC = 38,
    NUMBER_FULLWIDTH = 39,
    ALPHANUMERIC_HALFWIDTH = 40,
    ALPHANUMERIC_FULLWIDTH = 41,
    CURRENCY_CHINESE = 42,
    BOPOMOFO = 43,
    HIRAGANA = 44,
    KATAKANA_HALFWIDTH = 45,
    KATAKANA_FULLWIDTH = 46,
    HANJA = 47,
    HANGUL_HALFWIDTH = 48,
    HANGUL_FULLWIDTH = 49,
    SEARCH = 50,
    FORMULA = 51,
    SEARCH_INCREMENTAL = 52,
    CHINESE_HALFWIDTH = 53,
    CHINESE_FULLWIDTH = 54,
    NATIVE_SCRIPT = 55,
    YOMI = 56,
    TEXT = 57,
    CHAT = 58,
    NAME_OR_PHONENUMBER = 59,
    EMAILNAME_OR_ADDRESS = 60,
    PRIVATE = 61,
    MAPS = 62,
    NUMERIC_PASSWORD = 63,
    NUMERIC_PIN = 64,
    ALPHANUMERIC_PIN = 65,
    ALPHANUMERIC_PIN_SET = 66,
    FORMULA_NUMBER = 67,
    CHAT_WITHOUT_EMOJI = 68,
    PHRASELIST = -1,
    REGULAREXPRESSION = -2,
    SRGS = -3,
    XML = -4,
    ENUMSTRING = -5,
};
pub const IS_DEFAULT = InputScope.DEFAULT;
pub const IS_URL = InputScope.URL;
pub const IS_FILE_FULLFILEPATH = InputScope.FILE_FULLFILEPATH;
pub const IS_FILE_FILENAME = InputScope.FILE_FILENAME;
pub const IS_EMAIL_USERNAME = InputScope.EMAIL_USERNAME;
pub const IS_EMAIL_SMTPEMAILADDRESS = InputScope.EMAIL_SMTPEMAILADDRESS;
pub const IS_LOGINNAME = InputScope.LOGINNAME;
pub const IS_PERSONALNAME_FULLNAME = InputScope.PERSONALNAME_FULLNAME;
pub const IS_PERSONALNAME_PREFIX = InputScope.PERSONALNAME_PREFIX;
pub const IS_PERSONALNAME_GIVENNAME = InputScope.PERSONALNAME_GIVENNAME;
pub const IS_PERSONALNAME_MIDDLENAME = InputScope.PERSONALNAME_MIDDLENAME;
pub const IS_PERSONALNAME_SURNAME = InputScope.PERSONALNAME_SURNAME;
pub const IS_PERSONALNAME_SUFFIX = InputScope.PERSONALNAME_SUFFIX;
pub const IS_ADDRESS_FULLPOSTALADDRESS = InputScope.ADDRESS_FULLPOSTALADDRESS;
pub const IS_ADDRESS_POSTALCODE = InputScope.ADDRESS_POSTALCODE;
pub const IS_ADDRESS_STREET = InputScope.ADDRESS_STREET;
pub const IS_ADDRESS_STATEORPROVINCE = InputScope.ADDRESS_STATEORPROVINCE;
pub const IS_ADDRESS_CITY = InputScope.ADDRESS_CITY;
pub const IS_ADDRESS_COUNTRYNAME = InputScope.ADDRESS_COUNTRYNAME;
pub const IS_ADDRESS_COUNTRYSHORTNAME = InputScope.ADDRESS_COUNTRYSHORTNAME;
pub const IS_CURRENCY_AMOUNTANDSYMBOL = InputScope.CURRENCY_AMOUNTANDSYMBOL;
pub const IS_CURRENCY_AMOUNT = InputScope.CURRENCY_AMOUNT;
pub const IS_DATE_FULLDATE = InputScope.DATE_FULLDATE;
pub const IS_DATE_MONTH = InputScope.DATE_MONTH;
pub const IS_DATE_DAY = InputScope.DATE_DAY;
pub const IS_DATE_YEAR = InputScope.DATE_YEAR;
pub const IS_DATE_MONTHNAME = InputScope.DATE_MONTHNAME;
pub const IS_DATE_DAYNAME = InputScope.DATE_DAYNAME;
pub const IS_DIGITS = InputScope.DIGITS;
pub const IS_NUMBER = InputScope.NUMBER;
pub const IS_ONECHAR = InputScope.ONECHAR;
pub const IS_PASSWORD = InputScope.PASSWORD;
pub const IS_TELEPHONE_FULLTELEPHONENUMBER = InputScope.TELEPHONE_FULLTELEPHONENUMBER;
pub const IS_TELEPHONE_COUNTRYCODE = InputScope.TELEPHONE_COUNTRYCODE;
pub const IS_TELEPHONE_AREACODE = InputScope.TELEPHONE_AREACODE;
pub const IS_TELEPHONE_LOCALNUMBER = InputScope.TELEPHONE_LOCALNUMBER;
pub const IS_TIME_FULLTIME = InputScope.TIME_FULLTIME;
pub const IS_TIME_HOUR = InputScope.TIME_HOUR;
pub const IS_TIME_MINORSEC = InputScope.TIME_MINORSEC;
pub const IS_NUMBER_FULLWIDTH = InputScope.NUMBER_FULLWIDTH;
pub const IS_ALPHANUMERIC_HALFWIDTH = InputScope.ALPHANUMERIC_HALFWIDTH;
pub const IS_ALPHANUMERIC_FULLWIDTH = InputScope.ALPHANUMERIC_FULLWIDTH;
pub const IS_CURRENCY_CHINESE = InputScope.CURRENCY_CHINESE;
pub const IS_BOPOMOFO = InputScope.BOPOMOFO;
pub const IS_HIRAGANA = InputScope.HIRAGANA;
pub const IS_KATAKANA_HALFWIDTH = InputScope.KATAKANA_HALFWIDTH;
pub const IS_KATAKANA_FULLWIDTH = InputScope.KATAKANA_FULLWIDTH;
pub const IS_HANJA = InputScope.HANJA;
pub const IS_HANGUL_HALFWIDTH = InputScope.HANGUL_HALFWIDTH;
pub const IS_HANGUL_FULLWIDTH = InputScope.HANGUL_FULLWIDTH;
pub const IS_SEARCH = InputScope.SEARCH;
pub const IS_FORMULA = InputScope.FORMULA;
pub const IS_SEARCH_INCREMENTAL = InputScope.SEARCH_INCREMENTAL;
pub const IS_CHINESE_HALFWIDTH = InputScope.CHINESE_HALFWIDTH;
pub const IS_CHINESE_FULLWIDTH = InputScope.CHINESE_FULLWIDTH;
pub const IS_NATIVE_SCRIPT = InputScope.NATIVE_SCRIPT;
pub const IS_YOMI = InputScope.YOMI;
pub const IS_TEXT = InputScope.TEXT;
pub const IS_CHAT = InputScope.CHAT;
pub const IS_NAME_OR_PHONENUMBER = InputScope.NAME_OR_PHONENUMBER;
pub const IS_EMAILNAME_OR_ADDRESS = InputScope.EMAILNAME_OR_ADDRESS;
pub const IS_PRIVATE = InputScope.PRIVATE;
pub const IS_MAPS = InputScope.MAPS;
pub const IS_NUMERIC_PASSWORD = InputScope.NUMERIC_PASSWORD;
pub const IS_NUMERIC_PIN = InputScope.NUMERIC_PIN;
pub const IS_ALPHANUMERIC_PIN = InputScope.ALPHANUMERIC_PIN;
pub const IS_ALPHANUMERIC_PIN_SET = InputScope.ALPHANUMERIC_PIN_SET;
pub const IS_FORMULA_NUMBER = InputScope.FORMULA_NUMBER;
pub const IS_CHAT_WITHOUT_EMOJI = InputScope.CHAT_WITHOUT_EMOJI;
pub const IS_PHRASELIST = InputScope.PHRASELIST;
pub const IS_REGULAREXPRESSION = InputScope.REGULAREXPRESSION;
pub const IS_SRGS = InputScope.SRGS;
pub const IS_XML = InputScope.XML;
pub const IS_ENUMSTRING = InputScope.ENUMSTRING;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ITfInputScope_Value = Guid.initString("fde1eaee-6924-4cdf-91e7-da38cff5559d");
pub const IID_ITfInputScope = &IID_ITfInputScope_Value;
pub const ITfInputScope = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetInputScopes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfInputScope,
                pprgInputScopes: [*]?*InputScope,
                pcCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfInputScope,
                pprgInputScopes: [*]?*InputScope,
                pcCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPhrase: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfInputScope,
                ppbstrPhrases: [*]?*?BSTR,
                pcCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfInputScope,
                ppbstrPhrases: [*]?*?BSTR,
                pcCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRegularExpression: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfInputScope,
                pbstrRegExp: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfInputScope,
                pbstrRegExp: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSRGS: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfInputScope,
                pbstrSRGS: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfInputScope,
                pbstrSRGS: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetXML: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfInputScope,
                pbstrXML: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfInputScope,
                pbstrXML: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfInputScope_GetInputScopes(self: *const T, pprgInputScopes: [*]?*InputScope, pcCount: ?*u32) HRESULT {
                return @as(*const ITfInputScope.VTable, @ptrCast(self.vtable)).GetInputScopes(@as(*const ITfInputScope, @ptrCast(self)), pprgInputScopes, pcCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfInputScope_GetPhrase(self: *const T, ppbstrPhrases: [*]?*?BSTR, pcCount: ?*u32) HRESULT {
                return @as(*const ITfInputScope.VTable, @ptrCast(self.vtable)).GetPhrase(@as(*const ITfInputScope, @ptrCast(self)), ppbstrPhrases, pcCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfInputScope_GetRegularExpression(self: *const T, pbstrRegExp: ?*?BSTR) HRESULT {
                return @as(*const ITfInputScope.VTable, @ptrCast(self.vtable)).GetRegularExpression(@as(*const ITfInputScope, @ptrCast(self)), pbstrRegExp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfInputScope_GetSRGS(self: *const T, pbstrSRGS: ?*?BSTR) HRESULT {
                return @as(*const ITfInputScope.VTable, @ptrCast(self.vtable)).GetSRGS(@as(*const ITfInputScope, @ptrCast(self)), pbstrSRGS);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfInputScope_GetXML(self: *const T, pbstrXML: ?*?BSTR) HRESULT {
                return @as(*const ITfInputScope.VTable, @ptrCast(self.vtable)).GetXML(@as(*const ITfInputScope, @ptrCast(self)), pbstrXML);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ITfInputScope2_Value = Guid.initString("5731eaa0-6bc2-4681-a532-92fbb74d7c41");
pub const IID_ITfInputScope2 = &IID_ITfInputScope2_Value;
pub const ITfInputScope2 = extern struct {
    pub const VTable = extern struct {
        base: ITfInputScope.VTable,
        EnumWordList: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfInputScope2,
                ppEnumString: ?*?*IEnumString,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfInputScope2,
                ppEnumString: ?*?*IEnumString,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITfInputScope.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfInputScope2_EnumWordList(self: *const T, ppEnumString: ?*?*IEnumString) HRESULT {
                return @as(*const ITfInputScope2.VTable, @ptrCast(self.vtable)).EnumWordList(@as(*const ITfInputScope2, @ptrCast(self)), ppEnumString);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const CLSID_MSAAControl_Value = Guid.initString("08cd963f-7a3e-4f5c-9bd8-d692bb043c5b");
pub const CLSID_MSAAControl = &CLSID_MSAAControl_Value;

const CLSID_AccStore_Value = Guid.initString("5440837f-4bff-4ae5-a1b1-7722ecc6332a");
pub const CLSID_AccStore = &CLSID_AccStore_Value;

const CLSID_AccDictionary_Value = Guid.initString("6572ee16-5fe5-4331-bb6d-76a49c56e423");
pub const CLSID_AccDictionary = &CLSID_AccDictionary_Value;

const CLSID_AccServerDocMgr_Value = Guid.initString("6089a37e-eb8a-482d-bd6f-f9f46904d16d");
pub const CLSID_AccServerDocMgr = &CLSID_AccServerDocMgr_Value;

const CLSID_AccClientDocMgr_Value = Guid.initString("fc48cc30-4f3e-4fa1-803b-ad0e196a83b1");
pub const CLSID_AccClientDocMgr = &CLSID_AccClientDocMgr_Value;

const CLSID_DocWrap_Value = Guid.initString("bf426f7e-7a5e-44d6-830c-a390ea9462a3");
pub const CLSID_DocWrap = &CLSID_DocWrap_Value;

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfMSAAControl_Value = Guid.initString("b5f8fb3b-393f-4f7c-84cb-504924c2705a");
pub const IID_ITfMSAAControl = &IID_ITfMSAAControl_Value;
pub const ITfMSAAControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SystemEnableMSAA: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfMSAAControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfMSAAControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SystemDisableMSAA: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfMSAAControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfMSAAControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfMSAAControl_SystemEnableMSAA(self: *const T) HRESULT {
                return @as(*const ITfMSAAControl.VTable, @ptrCast(self.vtable)).SystemEnableMSAA(@as(*const ITfMSAAControl, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfMSAAControl_SystemDisableMSAA(self: *const T) HRESULT {
                return @as(*const ITfMSAAControl.VTable, @ptrCast(self.vtable)).SystemDisableMSAA(@as(*const ITfMSAAControl, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IInternalDocWrap_Value = Guid.initString("e1aa6466-9db4-40ba-be03-77c38e8e60b2");
pub const IID_IInternalDocWrap = &IID_IInternalDocWrap_Value;
pub const IInternalDocWrap = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        NotifyRevoke: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInternalDocWrap,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInternalDocWrap,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInternalDocWrap_NotifyRevoke(self: *const T) HRESULT {
                return @as(*const IInternalDocWrap.VTable, @ptrCast(self.vtable)).NotifyRevoke(@as(*const IInternalDocWrap, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITextStoreACPEx_Value = Guid.initString("a2de3bc2-3d8e-11d3-81a9-f753fbe61a00");
pub const IID_ITextStoreACPEx = &IID_ITextStoreACPEx_Value;
pub const ITextStoreACPEx = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ScrollToRect: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreACPEx,
                acpStart: i32,
                acpEnd: i32,
                rc: RECT,
                dwPosition: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreACPEx,
                acpStart: i32,
                acpEnd: i32,
                rc: RECT,
                dwPosition: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreACPEx_ScrollToRect(self: *const T, acpStart: i32, acpEnd: i32, rc: RECT, dwPosition: u32) HRESULT {
                return @as(*const ITextStoreACPEx.VTable, @ptrCast(self.vtable)).ScrollToRect(@as(*const ITextStoreACPEx, @ptrCast(self)), acpStart, acpEnd, rc, dwPosition);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITextStoreAnchorEx_Value = Guid.initString("a2de3bc1-3d8e-11d3-81a9-f753fbe61a00");
pub const IID_ITextStoreAnchorEx = &IID_ITextStoreAnchorEx_Value;
pub const ITextStoreAnchorEx = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ScrollToRect: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreAnchorEx,
                pStart: ?*IAnchor,
                pEnd: ?*IAnchor,
                rc: RECT,
                dwPosition: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreAnchorEx,
                pStart: ?*IAnchor,
                pEnd: ?*IAnchor,
                rc: RECT,
                dwPosition: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreAnchorEx_ScrollToRect(self: *const T, pStart: ?*IAnchor, pEnd: ?*IAnchor, rc: RECT, dwPosition: u32) HRESULT {
                return @as(*const ITextStoreAnchorEx.VTable, @ptrCast(self.vtable)).ScrollToRect(@as(*const ITextStoreAnchorEx, @ptrCast(self)), pStart, pEnd, rc, dwPosition);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITextStoreACPSinkEx_Value = Guid.initString("2bdf9464-41e2-43e3-950c-a6865ba25cd4");
pub const IID_ITextStoreACPSinkEx = &IID_ITextStoreACPSinkEx_Value;
pub const ITextStoreACPSinkEx = extern struct {
    pub const VTable = extern struct {
        base: ITextStoreACPSink.VTable,
        OnDisconnect: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreACPSinkEx,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreACPSinkEx,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITextStoreACPSink.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreACPSinkEx_OnDisconnect(self: *const T) HRESULT {
                return @as(*const ITextStoreACPSinkEx.VTable, @ptrCast(self.vtable)).OnDisconnect(@as(*const ITextStoreACPSinkEx, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITextStoreSinkAnchorEx_Value = Guid.initString("25642426-028d-4474-977b-111bb114fe3e");
pub const IID_ITextStoreSinkAnchorEx = &IID_ITextStoreSinkAnchorEx_Value;
pub const ITextStoreSinkAnchorEx = extern struct {
    pub const VTable = extern struct {
        base: ITextStoreAnchorSink.VTable,
        OnDisconnect: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoreSinkAnchorEx,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoreSinkAnchorEx,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITextStoreAnchorSink.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoreSinkAnchorEx_OnDisconnect(self: *const T) HRESULT {
                return @as(*const ITextStoreSinkAnchorEx.VTable, @ptrCast(self.vtable)).OnDisconnect(@as(*const ITextStoreSinkAnchorEx, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IAccDictionary_Value = Guid.initString("1dc4cb5f-d737-474d-ade9-5ccfc9bc1cc9");
pub const IID_IAccDictionary = &IID_IAccDictionary_Value;
pub const IAccDictionary = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetLocalizedString: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAccDictionary,
                Term: ?*const Guid,
                lcid: u32,
                pResult: ?*?BSTR,
                plcid: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAccDictionary,
                Term: ?*const Guid,
                lcid: u32,
                pResult: ?*?BSTR,
                plcid: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetParentTerm: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAccDictionary,
                Term: ?*const Guid,
                pParentTerm: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAccDictionary,
                Term: ?*const Guid,
                pParentTerm: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMnemonicString: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAccDictionary,
                Term: ?*const Guid,
                pResult: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAccDictionary,
                Term: ?*const Guid,
                pResult: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LookupMnemonicTerm: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAccDictionary,
                bstrMnemonic: ?BSTR,
                pTerm: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAccDictionary,
                bstrMnemonic: ?BSTR,
                pTerm: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ConvertValueToString: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAccDictionary,
                Term: ?*const Guid,
                lcid: u32,
                varValue: VARIANT,
                pbstrResult: ?*?BSTR,
                plcid: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAccDictionary,
                Term: ?*const Guid,
                lcid: u32,
                varValue: VARIANT,
                pbstrResult: ?*?BSTR,
                plcid: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAccDictionary_GetLocalizedString(self: *const T, Term: ?*const Guid, lcid: u32, pResult: ?*?BSTR, plcid: ?*u32) HRESULT {
                return @as(*const IAccDictionary.VTable, @ptrCast(self.vtable)).GetLocalizedString(@as(*const IAccDictionary, @ptrCast(self)), Term, lcid, pResult, plcid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAccDictionary_GetParentTerm(self: *const T, Term: ?*const Guid, pParentTerm: ?*Guid) HRESULT {
                return @as(*const IAccDictionary.VTable, @ptrCast(self.vtable)).GetParentTerm(@as(*const IAccDictionary, @ptrCast(self)), Term, pParentTerm);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAccDictionary_GetMnemonicString(self: *const T, Term: ?*const Guid, pResult: ?*?BSTR) HRESULT {
                return @as(*const IAccDictionary.VTable, @ptrCast(self.vtable)).GetMnemonicString(@as(*const IAccDictionary, @ptrCast(self)), Term, pResult);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAccDictionary_LookupMnemonicTerm(self: *const T, bstrMnemonic: ?BSTR, pTerm: ?*Guid) HRESULT {
                return @as(*const IAccDictionary.VTable, @ptrCast(self.vtable)).LookupMnemonicTerm(@as(*const IAccDictionary, @ptrCast(self)), bstrMnemonic, pTerm);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAccDictionary_ConvertValueToString(self: *const T, Term: ?*const Guid, lcid: u32, varValue: VARIANT, pbstrResult: ?*?BSTR, plcid: ?*u32) HRESULT {
                return @as(*const IAccDictionary.VTable, @ptrCast(self.vtable)).ConvertValueToString(@as(*const IAccDictionary, @ptrCast(self)), Term, lcid, varValue, pbstrResult, plcid);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVersionInfo_Value = Guid.initString("401518ec-db00-4611-9b29-2a0e4b9afa85");
pub const IID_IVersionInfo = &IID_IVersionInfo_Value;
pub const IVersionInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSubcomponentCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IVersionInfo,
                ulSub: u32,
                ulCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IVersionInfo,
                ulSub: u32,
                ulCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetImplementationID: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IVersionInfo,
                ulSub: u32,
                implid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IVersionInfo,
                ulSub: u32,
                implid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBuildVersion: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IVersionInfo,
                ulSub: u32,
                pdwMajor: ?*u32,
                pdwMinor: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IVersionInfo,
                ulSub: u32,
                pdwMajor: ?*u32,
                pdwMinor: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetComponentDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IVersionInfo,
                ulSub: u32,
                pImplStr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IVersionInfo,
                ulSub: u32,
                pImplStr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInstanceDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IVersionInfo,
                ulSub: u32,
                pImplStr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IVersionInfo,
                ulSub: u32,
                pImplStr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IVersionInfo_GetSubcomponentCount(self: *const T, ulSub: u32, ulCount: ?*u32) HRESULT {
                return @as(*const IVersionInfo.VTable, @ptrCast(self.vtable)).GetSubcomponentCount(@as(*const IVersionInfo, @ptrCast(self)), ulSub, ulCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IVersionInfo_GetImplementationID(self: *const T, ulSub: u32, implid: ?*Guid) HRESULT {
                return @as(*const IVersionInfo.VTable, @ptrCast(self.vtable)).GetImplementationID(@as(*const IVersionInfo, @ptrCast(self)), ulSub, implid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IVersionInfo_GetBuildVersion(self: *const T, ulSub: u32, pdwMajor: ?*u32, pdwMinor: ?*u32) HRESULT {
                return @as(*const IVersionInfo.VTable, @ptrCast(self.vtable)).GetBuildVersion(@as(*const IVersionInfo, @ptrCast(self)), ulSub, pdwMajor, pdwMinor);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IVersionInfo_GetComponentDescription(self: *const T, ulSub: u32, pImplStr: ?*?BSTR) HRESULT {
                return @as(*const IVersionInfo.VTable, @ptrCast(self.vtable)).GetComponentDescription(@as(*const IVersionInfo, @ptrCast(self)), ulSub, pImplStr);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IVersionInfo_GetInstanceDescription(self: *const T, ulSub: u32, pImplStr: ?*?BSTR) HRESULT {
                return @as(*const IVersionInfo.VTable, @ptrCast(self.vtable)).GetInstanceDescription(@as(*const IVersionInfo, @ptrCast(self)), ulSub, pImplStr);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ICoCreateLocally_Value = Guid.initString("03de00aa-f272-41e3-99cb-03c5e8114ea0");
pub const IID_ICoCreateLocally = &IID_ICoCreateLocally_Value;
pub const ICoCreateLocally = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CoCreateLocally: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICoCreateLocally,
                rclsid: ?*const Guid,
                dwClsContext: u32,
                riid: ?*const Guid,
                punk: ?*?*IUnknown,
                riidParam: ?*const Guid,
                punkParam: ?*IUnknown,
                varParam: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICoCreateLocally,
                rclsid: ?*const Guid,
                dwClsContext: u32,
                riid: ?*const Guid,
                punk: ?*?*IUnknown,
                riidParam: ?*const Guid,
                punkParam: ?*IUnknown,
                varParam: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICoCreateLocally_CoCreateLocally(self: *const T, rclsid: ?*const Guid, dwClsContext: u32, riid: ?*const Guid, punk: ?*?*IUnknown, riidParam: ?*const Guid, punkParam: ?*IUnknown, varParam: VARIANT) HRESULT {
                return @as(*const ICoCreateLocally.VTable, @ptrCast(self.vtable)).CoCreateLocally(@as(*const ICoCreateLocally, @ptrCast(self)), rclsid, dwClsContext, riid, punk, riidParam, punkParam, varParam);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ICoCreatedLocally_Value = Guid.initString("0a53eb6c-1908-4742-8cff-2cee2e93f94c");
pub const IID_ICoCreatedLocally = &IID_ICoCreatedLocally_Value;
pub const ICoCreatedLocally = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        LocalInit: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICoCreatedLocally,
                punkLocalObject: ?*IUnknown,
                riidParam: ?*const Guid,
                punkParam: ?*IUnknown,
                varParam: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICoCreatedLocally,
                punkLocalObject: ?*IUnknown,
                riidParam: ?*const Guid,
                punkParam: ?*IUnknown,
                varParam: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICoCreatedLocally_LocalInit(self: *const T, punkLocalObject: ?*IUnknown, riidParam: ?*const Guid, punkParam: ?*IUnknown, varParam: VARIANT) HRESULT {
                return @as(*const ICoCreatedLocally.VTable, @ptrCast(self.vtable)).LocalInit(@as(*const ICoCreatedLocally, @ptrCast(self)), punkLocalObject, riidParam, punkParam, varParam);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IAccStore_Value = Guid.initString("e2cd4a63-2b72-4d48-b739-95e4765195ba");
pub const IID_IAccStore = &IID_IAccStore_Value;
pub const IAccStore = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Register: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAccStore,
                riid: ?*const Guid,
                punk: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAccStore,
                riid: ?*const Guid,
                punk: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Unregister: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAccStore,
                punk: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAccStore,
                punk: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDocuments: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAccStore,
                enumUnknown: ?*?*IEnumUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAccStore,
                enumUnknown: ?*?*IEnumUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LookupByHWND: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAccStore,
                hWnd: ?HWND,
                riid: ?*const Guid,
                ppunk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAccStore,
                hWnd: ?HWND,
                riid: ?*const Guid,
                ppunk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LookupByPoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAccStore,
                pt: POINT,
                riid: ?*const Guid,
                ppunk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAccStore,
                pt: POINT,
                riid: ?*const Guid,
                ppunk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnDocumentFocus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAccStore,
                punk: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAccStore,
                punk: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFocused: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAccStore,
                riid: ?*const Guid,
                ppunk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAccStore,
                riid: ?*const Guid,
                ppunk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAccStore_Register(self: *const T, riid: ?*const Guid, punk: ?*IUnknown) HRESULT {
                return @as(*const IAccStore.VTable, @ptrCast(self.vtable)).Register(@as(*const IAccStore, @ptrCast(self)), riid, punk);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAccStore_Unregister(self: *const T, punk: ?*IUnknown) HRESULT {
                return @as(*const IAccStore.VTable, @ptrCast(self.vtable)).Unregister(@as(*const IAccStore, @ptrCast(self)), punk);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAccStore_GetDocuments(self: *const T, enumUnknown: ?*?*IEnumUnknown) HRESULT {
                return @as(*const IAccStore.VTable, @ptrCast(self.vtable)).GetDocuments(@as(*const IAccStore, @ptrCast(self)), enumUnknown);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAccStore_LookupByHWND(self: *const T, hWnd: ?HWND, riid: ?*const Guid, ppunk: ?*?*IUnknown) HRESULT {
                return @as(*const IAccStore.VTable, @ptrCast(self.vtable)).LookupByHWND(@as(*const IAccStore, @ptrCast(self)), hWnd, riid, ppunk);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAccStore_LookupByPoint(self: *const T, pt: POINT, riid: ?*const Guid, ppunk: ?*?*IUnknown) HRESULT {
                return @as(*const IAccStore.VTable, @ptrCast(self.vtable)).LookupByPoint(@as(*const IAccStore, @ptrCast(self)), pt, riid, ppunk);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAccStore_OnDocumentFocus(self: *const T, punk: ?*IUnknown) HRESULT {
                return @as(*const IAccStore.VTable, @ptrCast(self.vtable)).OnDocumentFocus(@as(*const IAccStore, @ptrCast(self)), punk);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAccStore_GetFocused(self: *const T, riid: ?*const Guid, ppunk: ?*?*IUnknown) HRESULT {
                return @as(*const IAccStore.VTable, @ptrCast(self.vtable)).GetFocused(@as(*const IAccStore, @ptrCast(self)), riid, ppunk);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IAccServerDocMgr_Value = Guid.initString("ad7c73cf-6dd5-4855-abc2-b04bad5b9153");
pub const IID_IAccServerDocMgr = &IID_IAccServerDocMgr_Value;
pub const IAccServerDocMgr = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        NewDocument: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAccServerDocMgr,
                riid: ?*const Guid,
                punk: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAccServerDocMgr,
                riid: ?*const Guid,
                punk: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RevokeDocument: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAccServerDocMgr,
                punk: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAccServerDocMgr,
                punk: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnDocumentFocus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAccServerDocMgr,
                punk: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAccServerDocMgr,
                punk: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAccServerDocMgr_NewDocument(self: *const T, riid: ?*const Guid, punk: ?*IUnknown) HRESULT {
                return @as(*const IAccServerDocMgr.VTable, @ptrCast(self.vtable)).NewDocument(@as(*const IAccServerDocMgr, @ptrCast(self)), riid, punk);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAccServerDocMgr_RevokeDocument(self: *const T, punk: ?*IUnknown) HRESULT {
                return @as(*const IAccServerDocMgr.VTable, @ptrCast(self.vtable)).RevokeDocument(@as(*const IAccServerDocMgr, @ptrCast(self)), punk);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAccServerDocMgr_OnDocumentFocus(self: *const T, punk: ?*IUnknown) HRESULT {
                return @as(*const IAccServerDocMgr.VTable, @ptrCast(self.vtable)).OnDocumentFocus(@as(*const IAccServerDocMgr, @ptrCast(self)), punk);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IAccClientDocMgr_Value = Guid.initString("4c896039-7b6d-49e6-a8c1-45116a98292b");
pub const IID_IAccClientDocMgr = &IID_IAccClientDocMgr_Value;
pub const IAccClientDocMgr = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDocuments: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAccClientDocMgr,
                enumUnknown: ?*?*IEnumUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAccClientDocMgr,
                enumUnknown: ?*?*IEnumUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LookupByHWND: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAccClientDocMgr,
                hWnd: ?HWND,
                riid: ?*const Guid,
                ppunk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAccClientDocMgr,
                hWnd: ?HWND,
                riid: ?*const Guid,
                ppunk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LookupByPoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAccClientDocMgr,
                pt: POINT,
                riid: ?*const Guid,
                ppunk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAccClientDocMgr,
                pt: POINT,
                riid: ?*const Guid,
                ppunk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFocused: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAccClientDocMgr,
                riid: ?*const Guid,
                ppunk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAccClientDocMgr,
                riid: ?*const Guid,
                ppunk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAccClientDocMgr_GetDocuments(self: *const T, enumUnknown: ?*?*IEnumUnknown) HRESULT {
                return @as(*const IAccClientDocMgr.VTable, @ptrCast(self.vtable)).GetDocuments(@as(*const IAccClientDocMgr, @ptrCast(self)), enumUnknown);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAccClientDocMgr_LookupByHWND(self: *const T, hWnd: ?HWND, riid: ?*const Guid, ppunk: ?*?*IUnknown) HRESULT {
                return @as(*const IAccClientDocMgr.VTable, @ptrCast(self.vtable)).LookupByHWND(@as(*const IAccClientDocMgr, @ptrCast(self)), hWnd, riid, ppunk);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAccClientDocMgr_LookupByPoint(self: *const T, pt: POINT, riid: ?*const Guid, ppunk: ?*?*IUnknown) HRESULT {
                return @as(*const IAccClientDocMgr.VTable, @ptrCast(self.vtable)).LookupByPoint(@as(*const IAccClientDocMgr, @ptrCast(self)), pt, riid, ppunk);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAccClientDocMgr_GetFocused(self: *const T, riid: ?*const Guid, ppunk: ?*?*IUnknown) HRESULT {
                return @as(*const IAccClientDocMgr.VTable, @ptrCast(self.vtable)).GetFocused(@as(*const IAccClientDocMgr, @ptrCast(self)), riid, ppunk);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDocWrap_Value = Guid.initString("dcd285fe-0be0-43bd-99c9-aaaec513c555");
pub const IID_IDocWrap = &IID_IDocWrap_Value;
pub const IDocWrap = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetDoc: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDocWrap,
                riid: ?*const Guid,
                punk: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDocWrap,
                riid: ?*const Guid,
                punk: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetWrappedDoc: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDocWrap,
                riid: ?*const Guid,
                ppunk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDocWrap,
                riid: ?*const Guid,
                ppunk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDocWrap_SetDoc(self: *const T, riid: ?*const Guid, punk: ?*IUnknown) HRESULT {
                return @as(*const IDocWrap.VTable, @ptrCast(self.vtable)).SetDoc(@as(*const IDocWrap, @ptrCast(self)), riid, punk);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDocWrap_GetWrappedDoc(self: *const T, riid: ?*const Guid, ppunk: ?*?*IUnknown) HRESULT {
                return @as(*const IDocWrap.VTable, @ptrCast(self.vtable)).GetWrappedDoc(@as(*const IDocWrap, @ptrCast(self)), riid, ppunk);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IClonableWrapper_Value = Guid.initString("b33e75ff-e84c-4dca-a25c-33b8dc003374");
pub const IID_IClonableWrapper = &IID_IClonableWrapper_Value;
pub const IClonableWrapper = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CloneNewWrapper: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IClonableWrapper,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IClonableWrapper,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IClonableWrapper_CloneNewWrapper(self: *const T, riid: ?*const Guid, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const IClonableWrapper.VTable, @ptrCast(self.vtable)).CloneNewWrapper(@as(*const IClonableWrapper, @ptrCast(self)), riid, ppv);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfSpeechUIServer_Value = Guid.initString("90e9a944-9244-489f-a78f-de67afc013a7");
pub const IID_ITfSpeechUIServer = &IID_ITfSpeechUIServer_Value;
pub const ITfSpeechUIServer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfSpeechUIServer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfSpeechUIServer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ShowUI: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfSpeechUIServer,
                fShow: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfSpeechUIServer,
                fShow: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UpdateBalloon: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITfSpeechUIServer,
                style: TfLBBalloonStyle,
                pch: [*:0]const u16,
                cch: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITfSpeechUIServer,
                style: TfLBBalloonStyle,
                pch: [*:0]const u16,
                cch: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfSpeechUIServer_Initialize(self: *const T) HRESULT {
                return @as(*const ITfSpeechUIServer.VTable, @ptrCast(self.vtable)).Initialize(@as(*const ITfSpeechUIServer, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfSpeechUIServer_ShowUI(self: *const T, fShow: BOOL) HRESULT {
                return @as(*const ITfSpeechUIServer.VTable, @ptrCast(self.vtable)).ShowUI(@as(*const ITfSpeechUIServer, @ptrCast(self)), fShow);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITfSpeechUIServer_UpdateBalloon(self: *const T, style: TfLBBalloonStyle, pch: [*:0]const u16, cch: u32) HRESULT {
                return @as(*const ITfSpeechUIServer.VTable, @ptrCast(self.vtable)).UpdateBalloon(@as(*const ITfSpeechUIServer, @ptrCast(self)), style, pch, cch);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

//--------------------------------------------------------------------------------
// Section: Functions (3)
//--------------------------------------------------------------------------------
pub extern "msctfmonitor" fn DoMsCtfMonitor(
    dwFlags: u32,
    hEventForServiceStop: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "msctfmonitor" fn InitLocalMsCtfMonitor(
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "msctfmonitor" fn UninitLocalMsCtfMonitor() callconv(@import("std").os.windows.WINAPI) HRESULT;

//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {},
    .wide => struct {},
    .unspecified => if (@import("builtin").is_test) struct {} else struct {},
};
//--------------------------------------------------------------------------------
// Section: Imports (23)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const BOOL = @import("../foundation.zig").BOOL;
const BSTR = @import("../foundation.zig").BSTR;
const FORMATETC = @import("../system/com.zig").FORMATETC;
const HANDLE = @import("../foundation.zig").HANDLE;
const HBITMAP = @import("../graphics/gdi.zig").HBITMAP;
const HICON = @import("../ui/windows_and_messaging.zig").HICON;
const HRESULT = @import("../foundation.zig").HRESULT;
const HWND = @import("../foundation.zig").HWND;
const IDataObject = @import("../system/com.zig").IDataObject;
const IEnumGUID = @import("../system/com.zig").IEnumGUID;
const IEnumString = @import("../system/com.zig").IEnumString;
const IEnumUnknown = @import("../system/com.zig").IEnumUnknown;
const IStream = @import("../system/com.zig").IStream;
const IUnknown = @import("../system/com.zig").IUnknown;
const LPARAM = @import("../foundation.zig").LPARAM;
const MSG = @import("../ui/windows_and_messaging.zig").MSG;
const POINT = @import("../foundation.zig").POINT;
const PWSTR = @import("../foundation.zig").PWSTR;
const RECT = @import("../foundation.zig").RECT;
const SIZE = @import("../foundation.zig").SIZE;
const VARIANT = @import("../system/com.zig").VARIANT;
const WPARAM = @import("../foundation.zig").WPARAM;

test {
    @setEvalBranchQuota(comptime @import("std").meta.declarations(@This()).len * 3);

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        if (decl.is_pub) {
            _ = @field(@This(), decl.name);
        }
    }
}
