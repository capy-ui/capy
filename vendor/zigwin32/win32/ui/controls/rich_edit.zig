//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (452)
//--------------------------------------------------------------------------------
pub const WM_CONTEXTMENU = @as(u32, 123);
pub const WM_UNICHAR = @as(u32, 265);
pub const WM_PRINTCLIENT = @as(u32, 792);
pub const EM_CANPASTE = @as(u32, 1074);
pub const EM_DISPLAYBAND = @as(u32, 1075);
pub const EM_EXGETSEL = @as(u32, 1076);
pub const EM_EXLIMITTEXT = @as(u32, 1077);
pub const EM_EXLINEFROMCHAR = @as(u32, 1078);
pub const EM_EXSETSEL = @as(u32, 1079);
pub const EM_FINDTEXT = @as(u32, 1080);
pub const EM_FORMATRANGE = @as(u32, 1081);
pub const EM_GETCHARFORMAT = @as(u32, 1082);
pub const EM_GETEVENTMASK = @as(u32, 1083);
pub const EM_GETOLEINTERFACE = @as(u32, 1084);
pub const EM_GETPARAFORMAT = @as(u32, 1085);
pub const EM_GETSELTEXT = @as(u32, 1086);
pub const EM_HIDESELECTION = @as(u32, 1087);
pub const EM_PASTESPECIAL = @as(u32, 1088);
pub const EM_REQUESTRESIZE = @as(u32, 1089);
pub const EM_SELECTIONTYPE = @as(u32, 1090);
pub const EM_SETBKGNDCOLOR = @as(u32, 1091);
pub const EM_SETCHARFORMAT = @as(u32, 1092);
pub const EM_SETEVENTMASK = @as(u32, 1093);
pub const EM_SETOLECALLBACK = @as(u32, 1094);
pub const EM_SETPARAFORMAT = @as(u32, 1095);
pub const EM_SETTARGETDEVICE = @as(u32, 1096);
pub const EM_STREAMIN = @as(u32, 1097);
pub const EM_STREAMOUT = @as(u32, 1098);
pub const EM_GETTEXTRANGE = @as(u32, 1099);
pub const EM_FINDWORDBREAK = @as(u32, 1100);
pub const EM_SETOPTIONS = @as(u32, 1101);
pub const EM_GETOPTIONS = @as(u32, 1102);
pub const EM_FINDTEXTEX = @as(u32, 1103);
pub const EM_GETWORDBREAKPROCEX = @as(u32, 1104);
pub const EM_SETWORDBREAKPROCEX = @as(u32, 1105);
pub const EM_SETUNDOLIMIT = @as(u32, 1106);
pub const EM_REDO = @as(u32, 1108);
pub const EM_CANREDO = @as(u32, 1109);
pub const EM_GETUNDONAME = @as(u32, 1110);
pub const EM_GETREDONAME = @as(u32, 1111);
pub const EM_STOPGROUPTYPING = @as(u32, 1112);
pub const EM_SETTEXTMODE = @as(u32, 1113);
pub const EM_GETTEXTMODE = @as(u32, 1114);
pub const EM_AUTOURLDETECT = @as(u32, 1115);
pub const AURL_ENABLEURL = @as(u32, 1);
pub const AURL_ENABLEEMAILADDR = @as(u32, 2);
pub const AURL_ENABLETELNO = @as(u32, 4);
pub const AURL_ENABLEEAURLS = @as(u32, 8);
pub const AURL_ENABLEDRIVELETTERS = @as(u32, 16);
pub const AURL_DISABLEMIXEDLGC = @as(u32, 32);
pub const EM_GETAUTOURLDETECT = @as(u32, 1116);
pub const EM_SETPALETTE = @as(u32, 1117);
pub const EM_GETTEXTEX = @as(u32, 1118);
pub const EM_GETTEXTLENGTHEX = @as(u32, 1119);
pub const EM_SHOWSCROLLBAR = @as(u32, 1120);
pub const EM_SETTEXTEX = @as(u32, 1121);
pub const EM_SETPUNCTUATION = @as(u32, 1124);
pub const EM_GETPUNCTUATION = @as(u32, 1125);
pub const EM_SETWORDWRAPMODE = @as(u32, 1126);
pub const EM_GETWORDWRAPMODE = @as(u32, 1127);
pub const EM_SETIMECOLOR = @as(u32, 1128);
pub const EM_GETIMECOLOR = @as(u32, 1129);
pub const EM_SETIMEOPTIONS = @as(u32, 1130);
pub const EM_GETIMEOPTIONS = @as(u32, 1131);
pub const EM_CONVPOSITION = @as(u32, 1132);
pub const EM_SETLANGOPTIONS = @as(u32, 1144);
pub const EM_GETLANGOPTIONS = @as(u32, 1145);
pub const EM_GETIMECOMPMODE = @as(u32, 1146);
pub const EM_FINDTEXTW = @as(u32, 1147);
pub const EM_FINDTEXTEXW = @as(u32, 1148);
pub const EM_RECONVERSION = @as(u32, 1149);
pub const EM_SETIMEMODEBIAS = @as(u32, 1150);
pub const EM_GETIMEMODEBIAS = @as(u32, 1151);
pub const EM_SETBIDIOPTIONS = @as(u32, 1224);
pub const EM_GETBIDIOPTIONS = @as(u32, 1225);
pub const EM_SETTYPOGRAPHYOPTIONS = @as(u32, 1226);
pub const EM_GETTYPOGRAPHYOPTIONS = @as(u32, 1227);
pub const EM_SETEDITSTYLE = @as(u32, 1228);
pub const EM_GETEDITSTYLE = @as(u32, 1229);
pub const SES_EMULATESYSEDIT = @as(u32, 1);
pub const SES_BEEPONMAXTEXT = @as(u32, 2);
pub const SES_EXTENDBACKCOLOR = @as(u32, 4);
pub const SES_MAPCPS = @as(u32, 8);
pub const SES_HYPERLINKTOOLTIPS = @as(u32, 8);
pub const SES_EMULATE10 = @as(u32, 16);
pub const SES_DEFAULTLATINLIGA = @as(u32, 16);
pub const SES_USECRLF = @as(u32, 32);
pub const SES_NOFOCUSLINKNOTIFY = @as(u32, 32);
pub const SES_USEAIMM = @as(u32, 64);
pub const SES_NOIME = @as(u32, 128);
pub const SES_ALLOWBEEPS = @as(u32, 256);
pub const SES_UPPERCASE = @as(u32, 512);
pub const SES_LOWERCASE = @as(u32, 1024);
pub const SES_NOINPUTSEQUENCECHK = @as(u32, 2048);
pub const SES_BIDI = @as(u32, 4096);
pub const SES_SCROLLONKILLFOCUS = @as(u32, 8192);
pub const SES_XLTCRCRLFTOCR = @as(u32, 16384);
pub const SES_DRAFTMODE = @as(u32, 32768);
pub const SES_USECTF = @as(u32, 65536);
pub const SES_HIDEGRIDLINES = @as(u32, 131072);
pub const SES_USEATFONT = @as(u32, 262144);
pub const SES_CUSTOMLOOK = @as(u32, 524288);
pub const SES_LBSCROLLNOTIFY = @as(u32, 1048576);
pub const SES_CTFALLOWEMBED = @as(u32, 2097152);
pub const SES_CTFALLOWSMARTTAG = @as(u32, 4194304);
pub const SES_CTFALLOWPROOFING = @as(u32, 8388608);
pub const SES_LOGICALCARET = @as(u32, 16777216);
pub const SES_WORDDRAGDROP = @as(u32, 33554432);
pub const SES_SMARTDRAGDROP = @as(u32, 67108864);
pub const SES_MULTISELECT = @as(u32, 134217728);
pub const SES_CTFNOLOCK = @as(u32, 268435456);
pub const SES_NOEALINEHEIGHTADJUST = @as(u32, 536870912);
pub const SES_MAX = @as(u32, 536870912);
pub const IMF_AUTOKEYBOARD = @as(u32, 1);
pub const IMF_AUTOFONT = @as(u32, 2);
pub const IMF_IMECANCELCOMPLETE = @as(u32, 4);
pub const IMF_IMEALWAYSSENDNOTIFY = @as(u32, 8);
pub const IMF_AUTOFONTSIZEADJUST = @as(u32, 16);
pub const IMF_UIFONTS = @as(u32, 32);
pub const IMF_NOIMPLICITLANG = @as(u32, 64);
pub const IMF_DUALFONT = @as(u32, 128);
pub const IMF_NOKBDLIDFIXUP = @as(u32, 512);
pub const IMF_NORTFFONTSUBSTITUTE = @as(u32, 1024);
pub const IMF_SPELLCHECKING = @as(u32, 2048);
pub const IMF_TKBPREDICTION = @as(u32, 4096);
pub const IMF_IMEUIINTEGRATION = @as(u32, 8192);
pub const ICM_NOTOPEN = @as(u32, 0);
pub const ICM_LEVEL3 = @as(u32, 1);
pub const ICM_LEVEL2 = @as(u32, 2);
pub const ICM_LEVEL2_5 = @as(u32, 3);
pub const ICM_LEVEL2_SUI = @as(u32, 4);
pub const ICM_CTF = @as(u32, 5);
pub const TO_ADVANCEDTYPOGRAPHY = @as(u32, 1);
pub const TO_SIMPLELINEBREAK = @as(u32, 2);
pub const TO_DISABLECUSTOMTEXTOUT = @as(u32, 4);
pub const TO_ADVANCEDLAYOUT = @as(u32, 8);
pub const EM_OUTLINE = @as(u32, 1244);
pub const EM_GETSCROLLPOS = @as(u32, 1245);
pub const EM_SETSCROLLPOS = @as(u32, 1246);
pub const EM_SETFONTSIZE = @as(u32, 1247);
pub const EM_GETZOOM = @as(u32, 1248);
pub const EM_SETZOOM = @as(u32, 1249);
pub const EM_GETVIEWKIND = @as(u32, 1250);
pub const EM_SETVIEWKIND = @as(u32, 1251);
pub const EM_GETPAGE = @as(u32, 1252);
pub const EM_SETPAGE = @as(u32, 1253);
pub const EM_GETHYPHENATEINFO = @as(u32, 1254);
pub const EM_SETHYPHENATEINFO = @as(u32, 1255);
pub const EM_GETPAGEROTATE = @as(u32, 1259);
pub const EM_SETPAGEROTATE = @as(u32, 1260);
pub const EM_GETCTFMODEBIAS = @as(u32, 1261);
pub const EM_SETCTFMODEBIAS = @as(u32, 1262);
pub const EM_GETCTFOPENSTATUS = @as(u32, 1264);
pub const EM_SETCTFOPENSTATUS = @as(u32, 1265);
pub const EM_GETIMECOMPTEXT = @as(u32, 1266);
pub const EM_ISIME = @as(u32, 1267);
pub const EM_GETIMEPROPERTY = @as(u32, 1268);
pub const EM_GETQUERYRTFOBJ = @as(u32, 1293);
pub const EM_SETQUERYRTFOBJ = @as(u32, 1294);
pub const EPR_0 = @as(u32, 0);
pub const EPR_270 = @as(u32, 1);
pub const EPR_180 = @as(u32, 2);
pub const EPR_90 = @as(u32, 3);
pub const EPR_SE = @as(u32, 5);
pub const CTFMODEBIAS_DEFAULT = @as(u32, 0);
pub const CTFMODEBIAS_FILENAME = @as(u32, 1);
pub const CTFMODEBIAS_NAME = @as(u32, 2);
pub const CTFMODEBIAS_READING = @as(u32, 3);
pub const CTFMODEBIAS_DATETIME = @as(u32, 4);
pub const CTFMODEBIAS_CONVERSATION = @as(u32, 5);
pub const CTFMODEBIAS_NUMERIC = @as(u32, 6);
pub const CTFMODEBIAS_HIRAGANA = @as(u32, 7);
pub const CTFMODEBIAS_KATAKANA = @as(u32, 8);
pub const CTFMODEBIAS_HANGUL = @as(u32, 9);
pub const CTFMODEBIAS_HALFWIDTHKATAKANA = @as(u32, 10);
pub const CTFMODEBIAS_FULLWIDTHALPHANUMERIC = @as(u32, 11);
pub const CTFMODEBIAS_HALFWIDTHALPHANUMERIC = @as(u32, 12);
pub const IMF_SMODE_PLAURALCLAUSE = @as(u32, 1);
pub const IMF_SMODE_NONE = @as(u32, 2);
pub const EMO_EXIT = @as(u32, 0);
pub const EMO_ENTER = @as(u32, 1);
pub const EMO_PROMOTE = @as(u32, 2);
pub const EMO_EXPAND = @as(u32, 3);
pub const EMO_MOVESELECTION = @as(u32, 4);
pub const EMO_GETVIEWMODE = @as(u32, 5);
pub const EMO_EXPANDSELECTION = @as(u32, 0);
pub const EMO_EXPANDDOCUMENT = @as(u32, 1);
pub const VM_NORMAL = @as(u32, 4);
pub const VM_OUTLINE = @as(u32, 2);
pub const VM_PAGE = @as(u32, 9);
pub const EM_INSERTTABLE = @as(u32, 1256);
pub const EM_GETAUTOCORRECTPROC = @as(u32, 1257);
pub const EM_SETAUTOCORRECTPROC = @as(u32, 1258);
pub const EM_CALLAUTOCORRECTPROC = @as(u32, 1279);
pub const ATP_NOCHANGE = @as(u32, 0);
pub const ATP_CHANGE = @as(u32, 1);
pub const ATP_NODELIMITER = @as(u32, 2);
pub const ATP_REPLACEALLTEXT = @as(u32, 4);
pub const EM_GETTABLEPARMS = @as(u32, 1289);
pub const EM_SETEDITSTYLEEX = @as(u32, 1299);
pub const EM_GETEDITSTYLEEX = @as(u32, 1300);
pub const SES_EX_NOTABLE = @as(u32, 4);
pub const SES_EX_NOMATH = @as(u32, 64);
pub const SES_EX_HANDLEFRIENDLYURL = @as(u32, 256);
pub const SES_EX_NOTHEMING = @as(u32, 524288);
pub const SES_EX_NOACETATESELECTION = @as(u32, 1048576);
pub const SES_EX_USESINGLELINE = @as(u32, 2097152);
pub const SES_EX_MULTITOUCH = @as(u32, 134217728);
pub const SES_EX_HIDETEMPFORMAT = @as(u32, 268435456);
pub const SES_EX_USEMOUSEWPARAM = @as(u32, 536870912);
pub const EM_GETSTORYTYPE = @as(u32, 1314);
pub const EM_SETSTORYTYPE = @as(u32, 1315);
pub const EM_GETELLIPSISMODE = @as(u32, 1329);
pub const EM_SETELLIPSISMODE = @as(u32, 1330);
pub const ELLIPSIS_MASK = @as(u32, 3);
pub const ELLIPSIS_NONE = @as(u32, 0);
pub const ELLIPSIS_END = @as(u32, 1);
pub const ELLIPSIS_WORD = @as(u32, 3);
pub const EM_SETTABLEPARMS = @as(u32, 1331);
pub const EM_GETTOUCHOPTIONS = @as(u32, 1334);
pub const EM_SETTOUCHOPTIONS = @as(u32, 1335);
pub const EM_INSERTIMAGE = @as(u32, 1338);
pub const EM_SETUIANAME = @as(u32, 1344);
pub const EM_GETELLIPSISSTATE = @as(u32, 1346);
pub const RTO_SHOWHANDLES = @as(u32, 1);
pub const RTO_DISABLEHANDLES = @as(u32, 2);
pub const RTO_READINGMODE = @as(u32, 3);
pub const EN_MSGFILTER = @as(u32, 1792);
pub const EN_REQUESTRESIZE = @as(u32, 1793);
pub const EN_SELCHANGE = @as(u32, 1794);
pub const EN_DROPFILES = @as(u32, 1795);
pub const EN_PROTECTED = @as(u32, 1796);
pub const EN_CORRECTTEXT = @as(u32, 1797);
pub const EN_STOPNOUNDO = @as(u32, 1798);
pub const EN_IMECHANGE = @as(u32, 1799);
pub const EN_SAVECLIPBOARD = @as(u32, 1800);
pub const EN_OLEOPFAILED = @as(u32, 1801);
pub const EN_OBJECTPOSITIONS = @as(u32, 1802);
pub const EN_LINK = @as(u32, 1803);
pub const EN_DRAGDROPDONE = @as(u32, 1804);
pub const EN_PARAGRAPHEXPANDED = @as(u32, 1805);
pub const EN_PAGECHANGE = @as(u32, 1806);
pub const EN_LOWFIRTF = @as(u32, 1807);
pub const EN_ALIGNLTR = @as(u32, 1808);
pub const EN_ALIGNRTL = @as(u32, 1809);
pub const EN_CLIPFORMAT = @as(u32, 1810);
pub const EN_STARTCOMPOSITION = @as(u32, 1811);
pub const EN_ENDCOMPOSITION = @as(u32, 1812);
pub const ENM_NONE = @as(u32, 0);
pub const ENM_CHANGE = @as(u32, 1);
pub const ENM_UPDATE = @as(u32, 2);
pub const ENM_SCROLL = @as(u32, 4);
pub const ENM_SCROLLEVENTS = @as(u32, 8);
pub const ENM_DRAGDROPDONE = @as(u32, 16);
pub const ENM_PARAGRAPHEXPANDED = @as(u32, 32);
pub const ENM_PAGECHANGE = @as(u32, 64);
pub const ENM_CLIPFORMAT = @as(u32, 128);
pub const ENM_KEYEVENTS = @as(u32, 65536);
pub const ENM_MOUSEEVENTS = @as(u32, 131072);
pub const ENM_REQUESTRESIZE = @as(u32, 262144);
pub const ENM_SELCHANGE = @as(u32, 524288);
pub const ENM_DROPFILES = @as(u32, 1048576);
pub const ENM_PROTECTED = @as(u32, 2097152);
pub const ENM_CORRECTTEXT = @as(u32, 4194304);
pub const ENM_IMECHANGE = @as(u32, 8388608);
pub const ENM_LANGCHANGE = @as(u32, 16777216);
pub const ENM_OBJECTPOSITIONS = @as(u32, 33554432);
pub const ENM_LINK = @as(u32, 67108864);
pub const ENM_LOWFIRTF = @as(u32, 134217728);
pub const ENM_STARTCOMPOSITION = @as(u32, 268435456);
pub const ENM_ENDCOMPOSITION = @as(u32, 536870912);
pub const ENM_GROUPTYPINGCHANGE = @as(u32, 1073741824);
pub const ENM_HIDELINKTOOLTIP = @as(u32, 2147483648);
pub const ES_SAVESEL = @as(u32, 32768);
pub const ES_SUNKEN = @as(u32, 16384);
pub const ES_DISABLENOSCROLL = @as(u32, 8192);
pub const ES_SELECTIONBAR = @as(u32, 16777216);
pub const ES_NOOLEDRAGDROP = @as(u32, 8);
pub const ES_EX_NOCALLOLEINIT = @as(u32, 0);
pub const ES_VERTICAL = @as(u32, 4194304);
pub const ES_NOIME = @as(u32, 524288);
pub const ES_SELFIME = @as(u32, 262144);
pub const ECO_AUTOWORDSELECTION = @as(u32, 1);
pub const ECO_AUTOVSCROLL = @as(u32, 64);
pub const ECO_AUTOHSCROLL = @as(u32, 128);
pub const ECO_NOHIDESEL = @as(u32, 256);
pub const ECO_READONLY = @as(u32, 2048);
pub const ECO_WANTRETURN = @as(u32, 4096);
pub const ECO_SAVESEL = @as(u32, 32768);
pub const ECO_SELECTIONBAR = @as(u32, 16777216);
pub const ECO_VERTICAL = @as(u32, 4194304);
pub const ECOOP_SET = @as(u32, 1);
pub const ECOOP_OR = @as(u32, 2);
pub const ECOOP_AND = @as(u32, 3);
pub const ECOOP_XOR = @as(u32, 4);
pub const WB_MOVEWORDPREV = @as(u32, 4);
pub const WB_MOVEWORDNEXT = @as(u32, 5);
pub const WB_PREVBREAK = @as(u32, 6);
pub const WB_NEXTBREAK = @as(u32, 7);
pub const PC_FOLLOWING = @as(u32, 1);
pub const PC_LEADING = @as(u32, 2);
pub const PC_OVERFLOW = @as(u32, 3);
pub const PC_DELIMITER = @as(u32, 4);
pub const WBF_WORDWRAP = @as(u32, 16);
pub const WBF_WORDBREAK = @as(u32, 32);
pub const WBF_OVERFLOW = @as(u32, 64);
pub const WBF_LEVEL1 = @as(u32, 128);
pub const WBF_LEVEL2 = @as(u32, 256);
pub const WBF_CUSTOM = @as(u32, 512);
pub const IMF_FORCENONE = @as(u32, 1);
pub const IMF_FORCEENABLE = @as(u32, 2);
pub const IMF_FORCEDISABLE = @as(u32, 4);
pub const IMF_CLOSESTATUSWINDOW = @as(u32, 8);
pub const IMF_VERTICAL = @as(u32, 32);
pub const IMF_FORCEACTIVE = @as(u32, 64);
pub const IMF_FORCEINACTIVE = @as(u32, 128);
pub const IMF_FORCEREMEMBER = @as(u32, 256);
pub const IMF_MULTIPLEEDIT = @as(u32, 1024);
pub const SCF_SELECTION = @as(u32, 1);
pub const SCF_WORD = @as(u32, 2);
pub const SCF_DEFAULT = @as(u32, 0);
pub const SCF_ALL = @as(u32, 4);
pub const SCF_USEUIRULES = @as(u32, 8);
pub const SCF_ASSOCIATEFONT = @as(u32, 16);
pub const SCF_NOKBUPDATE = @as(u32, 32);
pub const SCF_ASSOCIATEFONT2 = @as(u32, 64);
pub const SCF_SMARTFONT = @as(u32, 128);
pub const SCF_CHARREPFROMLCID = @as(u32, 256);
pub const SPF_DONTSETDEFAULT = @as(u32, 2);
pub const SPF_SETDEFAULT = @as(u32, 4);
pub const SF_TEXT = @as(u32, 1);
pub const SF_RTF = @as(u32, 2);
pub const SF_RTFNOOBJS = @as(u32, 3);
pub const SF_TEXTIZED = @as(u32, 4);
pub const SF_UNICODE = @as(u32, 16);
pub const SF_USECODEPAGE = @as(u32, 32);
pub const SF_NCRFORNONASCII = @as(u32, 64);
pub const SFF_WRITEXTRAPAR = @as(u32, 128);
pub const SFF_SELECTION = @as(u32, 32768);
pub const SFF_PLAINRTF = @as(u32, 16384);
pub const SFF_PERSISTVIEWSCALE = @as(u32, 8192);
pub const SFF_KEEPDOCINFO = @as(u32, 4096);
pub const SFF_PWD = @as(u32, 2048);
pub const SF_RTFVAL = @as(u32, 1792);
pub const MAX_TAB_STOPS = @as(u32, 32);
pub const MAX_TABLE_CELLS = @as(u32, 63);
pub const PFM_SPACEBEFORE = @as(u32, 64);
pub const PFM_SPACEAFTER = @as(u32, 128);
pub const PFM_LINESPACING = @as(u32, 256);
pub const PFM_STYLE = @as(u32, 1024);
pub const PFM_BORDER = @as(u32, 2048);
pub const PFM_SHADING = @as(u32, 4096);
pub const PFM_NUMBERINGSTYLE = @as(u32, 8192);
pub const PFM_NUMBERINGTAB = @as(u32, 16384);
pub const PFM_NUMBERINGSTART = @as(u32, 32768);
pub const PFM_KEEP = @as(u32, 131072);
pub const PFM_KEEPNEXT = @as(u32, 262144);
pub const PFM_PAGEBREAKBEFORE = @as(u32, 524288);
pub const PFM_NOLINENUMBER = @as(u32, 1048576);
pub const PFM_NOWIDOWCONTROL = @as(u32, 2097152);
pub const PFM_DONOTHYPHEN = @as(u32, 4194304);
pub const PFM_SIDEBYSIDE = @as(u32, 8388608);
pub const PFM_COLLAPSED = @as(u32, 16777216);
pub const PFM_OUTLINELEVEL = @as(u32, 33554432);
pub const PFM_BOX = @as(u32, 67108864);
pub const PFM_RESERVED2 = @as(u32, 134217728);
pub const PFM_TABLEROWDELIMITER = @as(u32, 268435456);
pub const PFM_TEXTWRAPPINGBREAK = @as(u32, 536870912);
pub const PFM_TABLE = @as(u32, 1073741824);
pub const PFN_BULLET = @as(u32, 1);
pub const PFN_ARABIC = @as(u32, 2);
pub const PFN_LCLETTER = @as(u32, 3);
pub const PFN_UCLETTER = @as(u32, 4);
pub const PFN_LCROMAN = @as(u32, 5);
pub const PFN_UCROMAN = @as(u32, 6);
pub const PFA_JUSTIFY = @as(u32, 4);
pub const PFA_FULL_INTERWORD = @as(u32, 4);
pub const WM_NOTIFY = @as(u32, 78);
pub const GCMF_GRIPPER = @as(u32, 1);
pub const GCMF_SPELLING = @as(u32, 2);
pub const GCMF_TOUCHMENU = @as(u32, 16384);
pub const GCMF_MOUSEMENU = @as(u32, 8192);
pub const OLEOP_DOVERB = @as(u32, 1);
pub const ST_DEFAULT = @as(u32, 0);
pub const ST_KEEPUNDO = @as(u32, 1);
pub const ST_SELECTION = @as(u32, 2);
pub const ST_NEWCHARS = @as(u32, 4);
pub const ST_UNICODE = @as(u32, 8);
pub const BOM_DEFPARADIR = @as(u32, 1);
pub const BOM_PLAINTEXT = @as(u32, 2);
pub const BOM_NEUTRALOVERRIDE = @as(u32, 4);
pub const BOM_CONTEXTREADING = @as(u32, 8);
pub const BOM_CONTEXTALIGNMENT = @as(u32, 16);
pub const BOM_LEGACYBIDICLASS = @as(u32, 64);
pub const BOM_UNICODEBIDI = @as(u32, 128);
pub const BOE_RTLDIR = @as(u32, 1);
pub const BOE_PLAINTEXT = @as(u32, 2);
pub const BOE_NEUTRALOVERRIDE = @as(u32, 4);
pub const BOE_CONTEXTREADING = @as(u32, 8);
pub const BOE_CONTEXTALIGNMENT = @as(u32, 16);
pub const BOE_FORCERECALC = @as(u32, 32);
pub const BOE_LEGACYBIDICLASS = @as(u32, 64);
pub const BOE_UNICODEBIDI = @as(u32, 128);
pub const FR_MATCHDIAC = @as(u32, 536870912);
pub const FR_MATCHKASHIDA = @as(u32, 1073741824);
pub const FR_MATCHALEFHAMZA = @as(u32, 2147483648);
pub const PFA_FULL_NEWSPAPER = @as(u32, 5);
pub const PFA_FULL_INTERLETTER = @as(u32, 6);
pub const PFA_FULL_SCALED = @as(u32, 7);
pub const PFA_FULL_GLYPHS = @as(u32, 8);
pub const AURL_ENABLEEA = @as(u32, 1);
pub const GCM_TOUCHMENU = @as(u32, 16384);
pub const GCM_MOUSEMENU = @as(u32, 8192);
pub const S_MSG_KEY_IGNORED = @import("../../zig.zig").typedConst(HRESULT, @as(i32, 262657));
pub const TXTBIT_RICHTEXT = @as(u32, 1);
pub const TXTBIT_MULTILINE = @as(u32, 2);
pub const TXTBIT_READONLY = @as(u32, 4);
pub const TXTBIT_SHOWACCELERATOR = @as(u32, 8);
pub const TXTBIT_USEPASSWORD = @as(u32, 16);
pub const TXTBIT_HIDESELECTION = @as(u32, 32);
pub const TXTBIT_SAVESELECTION = @as(u32, 64);
pub const TXTBIT_AUTOWORDSEL = @as(u32, 128);
pub const TXTBIT_VERTICAL = @as(u32, 256);
pub const TXTBIT_SELBARCHANGE = @as(u32, 512);
pub const TXTBIT_WORDWRAP = @as(u32, 1024);
pub const TXTBIT_ALLOWBEEP = @as(u32, 2048);
pub const TXTBIT_DISABLEDRAG = @as(u32, 4096);
pub const TXTBIT_VIEWINSETCHANGE = @as(u32, 8192);
pub const TXTBIT_BACKSTYLECHANGE = @as(u32, 16384);
pub const TXTBIT_MAXLENGTHCHANGE = @as(u32, 32768);
pub const TXTBIT_SCROLLBARCHANGE = @as(u32, 65536);
pub const TXTBIT_CHARFORMATCHANGE = @as(u32, 131072);
pub const TXTBIT_PARAFORMATCHANGE = @as(u32, 262144);
pub const TXTBIT_EXTENTCHANGE = @as(u32, 524288);
pub const TXTBIT_CLIENTRECTCHANGE = @as(u32, 1048576);
pub const TXTBIT_USECURRENTBKG = @as(u32, 2097152);
pub const TXTBIT_NOTHREADREFCOUNT = @as(u32, 4194304);
pub const TXTBIT_SHOWPASSWORD = @as(u32, 8388608);
pub const TXTBIT_D2DDWRITE = @as(u32, 16777216);
pub const TXTBIT_D2DSIMPLETYPOGRAPHY = @as(u32, 33554432);
pub const TXTBIT_D2DPIXELSNAPPED = @as(u32, 67108864);
pub const TXTBIT_D2DSUBPIXELLINES = @as(u32, 134217728);
pub const TXTBIT_FLASHLASTPASSWORDCHAR = @as(u32, 268435456);
pub const TXTBIT_ADVANCEDINPUT = @as(u32, 536870912);
pub const TXES_ISDIALOG = @as(u32, 1);
pub const REO_NULL = @as(i32, 0);
pub const REO_READWRITEMASK = @as(i32, 2047);
pub const RECO_PASTE = @as(i32, 0);
pub const RECO_DROP = @as(i32, 1);
pub const RECO_COPY = @as(i32, 2);
pub const RECO_CUT = @as(i32, 3);
pub const RECO_DRAG = @as(i32, 4);

//--------------------------------------------------------------------------------
// Section: Types (101)
//--------------------------------------------------------------------------------
pub const CFM_MASK = enum(u32) {
    SUBSCRIPT = 196608,
    // SUPERSCRIPT = 196608, this enum value conflicts with SUBSCRIPT
    EFFECTS = 1073741887,
    ALL = 4160749631,
    BOLD = 1,
    CHARSET = 134217728,
    COLOR = 1073741824,
    FACE = 536870912,
    ITALIC = 2,
    OFFSET = 268435456,
    PROTECTED = 16,
    SIZE = 2147483648,
    STRIKEOUT = 8,
    UNDERLINE = 4,
    LINK = 32,
    SMALLCAPS = 64,
    ALLCAPS = 128,
    HIDDEN = 256,
    OUTLINE = 512,
    SHADOW = 1024,
    EMBOSS = 2048,
    IMPRINT = 4096,
    DISABLED = 8192,
    REVISED = 16384,
    REVAUTHOR = 32768,
    ANIMATION = 262144,
    STYLE = 524288,
    KERNING = 1048576,
    SPACING = 2097152,
    WEIGHT = 4194304,
    UNDERLINETYPE = 8388608,
    COOKIE = 16777216,
    LCID = 33554432,
    BACKCOLOR = 67108864,
    EFFECTS2 = 1141080063,
    ALL2 = 4294967295,
    // FONTBOUND = 1048576, this enum value conflicts with KERNING
    // LINKPROTECTED = 8388608, this enum value conflicts with UNDERLINETYPE
    // EXTENDED = 33554432, this enum value conflicts with LCID
    // MATHNOBUILDUP = 134217728, this enum value conflicts with CHARSET
    // MATH = 268435456, this enum value conflicts with OFFSET
    // MATHORDINARY = 536870912, this enum value conflicts with FACE
    ALLEFFECTS = 2115207167,
    _,
    pub fn initFlags(o: struct {
        SUBSCRIPT: u1 = 0,
        EFFECTS: u1 = 0,
        ALL: u1 = 0,
        BOLD: u1 = 0,
        CHARSET: u1 = 0,
        COLOR: u1 = 0,
        FACE: u1 = 0,
        ITALIC: u1 = 0,
        OFFSET: u1 = 0,
        PROTECTED: u1 = 0,
        SIZE: u1 = 0,
        STRIKEOUT: u1 = 0,
        UNDERLINE: u1 = 0,
        LINK: u1 = 0,
        SMALLCAPS: u1 = 0,
        ALLCAPS: u1 = 0,
        HIDDEN: u1 = 0,
        OUTLINE: u1 = 0,
        SHADOW: u1 = 0,
        EMBOSS: u1 = 0,
        IMPRINT: u1 = 0,
        DISABLED: u1 = 0,
        REVISED: u1 = 0,
        REVAUTHOR: u1 = 0,
        ANIMATION: u1 = 0,
        STYLE: u1 = 0,
        KERNING: u1 = 0,
        SPACING: u1 = 0,
        WEIGHT: u1 = 0,
        UNDERLINETYPE: u1 = 0,
        COOKIE: u1 = 0,
        LCID: u1 = 0,
        BACKCOLOR: u1 = 0,
        EFFECTS2: u1 = 0,
        ALL2: u1 = 0,
        ALLEFFECTS: u1 = 0,
    }) CFM_MASK {
        return @as(CFM_MASK, @enumFromInt((if (o.SUBSCRIPT == 1) @intFromEnum(CFM_MASK.SUBSCRIPT) else 0) | (if (o.EFFECTS == 1) @intFromEnum(CFM_MASK.EFFECTS) else 0) | (if (o.ALL == 1) @intFromEnum(CFM_MASK.ALL) else 0) | (if (o.BOLD == 1) @intFromEnum(CFM_MASK.BOLD) else 0) | (if (o.CHARSET == 1) @intFromEnum(CFM_MASK.CHARSET) else 0) | (if (o.COLOR == 1) @intFromEnum(CFM_MASK.COLOR) else 0) | (if (o.FACE == 1) @intFromEnum(CFM_MASK.FACE) else 0) | (if (o.ITALIC == 1) @intFromEnum(CFM_MASK.ITALIC) else 0) | (if (o.OFFSET == 1) @intFromEnum(CFM_MASK.OFFSET) else 0) | (if (o.PROTECTED == 1) @intFromEnum(CFM_MASK.PROTECTED) else 0) | (if (o.SIZE == 1) @intFromEnum(CFM_MASK.SIZE) else 0) | (if (o.STRIKEOUT == 1) @intFromEnum(CFM_MASK.STRIKEOUT) else 0) | (if (o.UNDERLINE == 1) @intFromEnum(CFM_MASK.UNDERLINE) else 0) | (if (o.LINK == 1) @intFromEnum(CFM_MASK.LINK) else 0) | (if (o.SMALLCAPS == 1) @intFromEnum(CFM_MASK.SMALLCAPS) else 0) | (if (o.ALLCAPS == 1) @intFromEnum(CFM_MASK.ALLCAPS) else 0) | (if (o.HIDDEN == 1) @intFromEnum(CFM_MASK.HIDDEN) else 0) | (if (o.OUTLINE == 1) @intFromEnum(CFM_MASK.OUTLINE) else 0) | (if (o.SHADOW == 1) @intFromEnum(CFM_MASK.SHADOW) else 0) | (if (o.EMBOSS == 1) @intFromEnum(CFM_MASK.EMBOSS) else 0) | (if (o.IMPRINT == 1) @intFromEnum(CFM_MASK.IMPRINT) else 0) | (if (o.DISABLED == 1) @intFromEnum(CFM_MASK.DISABLED) else 0) | (if (o.REVISED == 1) @intFromEnum(CFM_MASK.REVISED) else 0) | (if (o.REVAUTHOR == 1) @intFromEnum(CFM_MASK.REVAUTHOR) else 0) | (if (o.ANIMATION == 1) @intFromEnum(CFM_MASK.ANIMATION) else 0) | (if (o.STYLE == 1) @intFromEnum(CFM_MASK.STYLE) else 0) | (if (o.KERNING == 1) @intFromEnum(CFM_MASK.KERNING) else 0) | (if (o.SPACING == 1) @intFromEnum(CFM_MASK.SPACING) else 0) | (if (o.WEIGHT == 1) @intFromEnum(CFM_MASK.WEIGHT) else 0) | (if (o.UNDERLINETYPE == 1) @intFromEnum(CFM_MASK.UNDERLINETYPE) else 0) | (if (o.COOKIE == 1) @intFromEnum(CFM_MASK.COOKIE) else 0) | (if (o.LCID == 1) @intFromEnum(CFM_MASK.LCID) else 0) | (if (o.BACKCOLOR == 1) @intFromEnum(CFM_MASK.BACKCOLOR) else 0) | (if (o.EFFECTS2 == 1) @intFromEnum(CFM_MASK.EFFECTS2) else 0) | (if (o.ALL2 == 1) @intFromEnum(CFM_MASK.ALL2) else 0) | (if (o.ALLEFFECTS == 1) @intFromEnum(CFM_MASK.ALLEFFECTS) else 0)));
    }
};
pub const CFM_SUBSCRIPT = CFM_MASK.SUBSCRIPT;
pub const CFM_SUPERSCRIPT = CFM_MASK.SUBSCRIPT;
pub const CFM_EFFECTS = CFM_MASK.EFFECTS;
pub const CFM_ALL = CFM_MASK.ALL;
pub const CFM_BOLD = CFM_MASK.BOLD;
pub const CFM_CHARSET = CFM_MASK.CHARSET;
pub const CFM_COLOR = CFM_MASK.COLOR;
pub const CFM_FACE = CFM_MASK.FACE;
pub const CFM_ITALIC = CFM_MASK.ITALIC;
pub const CFM_OFFSET = CFM_MASK.OFFSET;
pub const CFM_PROTECTED = CFM_MASK.PROTECTED;
pub const CFM_SIZE = CFM_MASK.SIZE;
pub const CFM_STRIKEOUT = CFM_MASK.STRIKEOUT;
pub const CFM_UNDERLINE = CFM_MASK.UNDERLINE;
pub const CFM_LINK = CFM_MASK.LINK;
pub const CFM_SMALLCAPS = CFM_MASK.SMALLCAPS;
pub const CFM_ALLCAPS = CFM_MASK.ALLCAPS;
pub const CFM_HIDDEN = CFM_MASK.HIDDEN;
pub const CFM_OUTLINE = CFM_MASK.OUTLINE;
pub const CFM_SHADOW = CFM_MASK.SHADOW;
pub const CFM_EMBOSS = CFM_MASK.EMBOSS;
pub const CFM_IMPRINT = CFM_MASK.IMPRINT;
pub const CFM_DISABLED = CFM_MASK.DISABLED;
pub const CFM_REVISED = CFM_MASK.REVISED;
pub const CFM_REVAUTHOR = CFM_MASK.REVAUTHOR;
pub const CFM_ANIMATION = CFM_MASK.ANIMATION;
pub const CFM_STYLE = CFM_MASK.STYLE;
pub const CFM_KERNING = CFM_MASK.KERNING;
pub const CFM_SPACING = CFM_MASK.SPACING;
pub const CFM_WEIGHT = CFM_MASK.WEIGHT;
pub const CFM_UNDERLINETYPE = CFM_MASK.UNDERLINETYPE;
pub const CFM_COOKIE = CFM_MASK.COOKIE;
pub const CFM_LCID = CFM_MASK.LCID;
pub const CFM_BACKCOLOR = CFM_MASK.BACKCOLOR;
pub const CFM_EFFECTS2 = CFM_MASK.EFFECTS2;
pub const CFM_ALL2 = CFM_MASK.ALL2;
pub const CFM_FONTBOUND = CFM_MASK.KERNING;
pub const CFM_LINKPROTECTED = CFM_MASK.UNDERLINETYPE;
pub const CFM_EXTENDED = CFM_MASK.LCID;
pub const CFM_MATHNOBUILDUP = CFM_MASK.CHARSET;
pub const CFM_MATH = CFM_MASK.OFFSET;
pub const CFM_MATHORDINARY = CFM_MASK.FACE;
pub const CFM_ALLEFFECTS = CFM_MASK.ALLEFFECTS;

pub const CFE_EFFECTS = enum(u32) {
    ALLCAPS = 128,
    AUTOBACKCOLOR = 67108864,
    DISABLED = 8192,
    EMBOSS = 2048,
    HIDDEN = 256,
    IMPRINT = 4096,
    OUTLINE = 512,
    REVISED = 16384,
    SHADOW = 1024,
    SMALLCAPS = 64,
    AUTOCOLOR = 1073741824,
    BOLD = 1,
    ITALIC = 2,
    STRIKEOUT = 8,
    UNDERLINE = 4,
    PROTECTED = 16,
    LINK = 32,
    SUBSCRIPT = 65536,
    SUPERSCRIPT = 131072,
    FONTBOUND = 1048576,
    LINKPROTECTED = 8388608,
    EXTENDED = 33554432,
    MATHNOBUILDUP = 134217728,
    MATH = 268435456,
    MATHORDINARY = 536870912,
    _,
    pub fn initFlags(o: struct {
        ALLCAPS: u1 = 0,
        AUTOBACKCOLOR: u1 = 0,
        DISABLED: u1 = 0,
        EMBOSS: u1 = 0,
        HIDDEN: u1 = 0,
        IMPRINT: u1 = 0,
        OUTLINE: u1 = 0,
        REVISED: u1 = 0,
        SHADOW: u1 = 0,
        SMALLCAPS: u1 = 0,
        AUTOCOLOR: u1 = 0,
        BOLD: u1 = 0,
        ITALIC: u1 = 0,
        STRIKEOUT: u1 = 0,
        UNDERLINE: u1 = 0,
        PROTECTED: u1 = 0,
        LINK: u1 = 0,
        SUBSCRIPT: u1 = 0,
        SUPERSCRIPT: u1 = 0,
        FONTBOUND: u1 = 0,
        LINKPROTECTED: u1 = 0,
        EXTENDED: u1 = 0,
        MATHNOBUILDUP: u1 = 0,
        MATH: u1 = 0,
        MATHORDINARY: u1 = 0,
    }) CFE_EFFECTS {
        return @as(CFE_EFFECTS, @enumFromInt((if (o.ALLCAPS == 1) @intFromEnum(CFE_EFFECTS.ALLCAPS) else 0) | (if (o.AUTOBACKCOLOR == 1) @intFromEnum(CFE_EFFECTS.AUTOBACKCOLOR) else 0) | (if (o.DISABLED == 1) @intFromEnum(CFE_EFFECTS.DISABLED) else 0) | (if (o.EMBOSS == 1) @intFromEnum(CFE_EFFECTS.EMBOSS) else 0) | (if (o.HIDDEN == 1) @intFromEnum(CFE_EFFECTS.HIDDEN) else 0) | (if (o.IMPRINT == 1) @intFromEnum(CFE_EFFECTS.IMPRINT) else 0) | (if (o.OUTLINE == 1) @intFromEnum(CFE_EFFECTS.OUTLINE) else 0) | (if (o.REVISED == 1) @intFromEnum(CFE_EFFECTS.REVISED) else 0) | (if (o.SHADOW == 1) @intFromEnum(CFE_EFFECTS.SHADOW) else 0) | (if (o.SMALLCAPS == 1) @intFromEnum(CFE_EFFECTS.SMALLCAPS) else 0) | (if (o.AUTOCOLOR == 1) @intFromEnum(CFE_EFFECTS.AUTOCOLOR) else 0) | (if (o.BOLD == 1) @intFromEnum(CFE_EFFECTS.BOLD) else 0) | (if (o.ITALIC == 1) @intFromEnum(CFE_EFFECTS.ITALIC) else 0) | (if (o.STRIKEOUT == 1) @intFromEnum(CFE_EFFECTS.STRIKEOUT) else 0) | (if (o.UNDERLINE == 1) @intFromEnum(CFE_EFFECTS.UNDERLINE) else 0) | (if (o.PROTECTED == 1) @intFromEnum(CFE_EFFECTS.PROTECTED) else 0) | (if (o.LINK == 1) @intFromEnum(CFE_EFFECTS.LINK) else 0) | (if (o.SUBSCRIPT == 1) @intFromEnum(CFE_EFFECTS.SUBSCRIPT) else 0) | (if (o.SUPERSCRIPT == 1) @intFromEnum(CFE_EFFECTS.SUPERSCRIPT) else 0) | (if (o.FONTBOUND == 1) @intFromEnum(CFE_EFFECTS.FONTBOUND) else 0) | (if (o.LINKPROTECTED == 1) @intFromEnum(CFE_EFFECTS.LINKPROTECTED) else 0) | (if (o.EXTENDED == 1) @intFromEnum(CFE_EFFECTS.EXTENDED) else 0) | (if (o.MATHNOBUILDUP == 1) @intFromEnum(CFE_EFFECTS.MATHNOBUILDUP) else 0) | (if (o.MATH == 1) @intFromEnum(CFE_EFFECTS.MATH) else 0) | (if (o.MATHORDINARY == 1) @intFromEnum(CFE_EFFECTS.MATHORDINARY) else 0)));
    }
};
// TODO: enum 'CFE_EFFECTS' has known issues with its value aliases

pub const PARAFORMAT_MASK = enum(u32) {
    ALIGNMENT = 8,
    NUMBERING = 32,
    OFFSET = 4,
    OFFSETINDENT = 2147483648,
    RIGHTINDENT = 2,
    RTLPARA = 65536,
    STARTINDENT = 1,
    TABSTOPS = 16,
    _,
    pub fn initFlags(o: struct {
        ALIGNMENT: u1 = 0,
        NUMBERING: u1 = 0,
        OFFSET: u1 = 0,
        OFFSETINDENT: u1 = 0,
        RIGHTINDENT: u1 = 0,
        RTLPARA: u1 = 0,
        STARTINDENT: u1 = 0,
        TABSTOPS: u1 = 0,
    }) PARAFORMAT_MASK {
        return @as(PARAFORMAT_MASK, @enumFromInt((if (o.ALIGNMENT == 1) @intFromEnum(PARAFORMAT_MASK.ALIGNMENT) else 0) | (if (o.NUMBERING == 1) @intFromEnum(PARAFORMAT_MASK.NUMBERING) else 0) | (if (o.OFFSET == 1) @intFromEnum(PARAFORMAT_MASK.OFFSET) else 0) | (if (o.OFFSETINDENT == 1) @intFromEnum(PARAFORMAT_MASK.OFFSETINDENT) else 0) | (if (o.RIGHTINDENT == 1) @intFromEnum(PARAFORMAT_MASK.RIGHTINDENT) else 0) | (if (o.RTLPARA == 1) @intFromEnum(PARAFORMAT_MASK.RTLPARA) else 0) | (if (o.STARTINDENT == 1) @intFromEnum(PARAFORMAT_MASK.STARTINDENT) else 0) | (if (o.TABSTOPS == 1) @intFromEnum(PARAFORMAT_MASK.TABSTOPS) else 0)));
    }
};
pub const PFM_ALIGNMENT = PARAFORMAT_MASK.ALIGNMENT;
pub const PFM_NUMBERING = PARAFORMAT_MASK.NUMBERING;
pub const PFM_OFFSET = PARAFORMAT_MASK.OFFSET;
pub const PFM_OFFSETINDENT = PARAFORMAT_MASK.OFFSETINDENT;
pub const PFM_RIGHTINDENT = PARAFORMAT_MASK.RIGHTINDENT;
pub const PFM_RTLPARA = PARAFORMAT_MASK.RTLPARA;
pub const PFM_STARTINDENT = PARAFORMAT_MASK.STARTINDENT;
pub const PFM_TABSTOPS = PARAFORMAT_MASK.TABSTOPS;

pub const RICH_EDIT_GET_CONTEXT_MENU_SEL_TYPE = enum(u16) {
    SEL_EMPTY = 0,
    SEL_TEXT = 1,
    SEL_OBJECT = 2,
    SEL_MULTICHAR = 4,
    SEL_MULTIOBJECT = 8,
    GCM_RIGHTMOUSEDROP = 32768,
    _,
    pub fn initFlags(o: struct {
        SEL_EMPTY: u1 = 0,
        SEL_TEXT: u1 = 0,
        SEL_OBJECT: u1 = 0,
        SEL_MULTICHAR: u1 = 0,
        SEL_MULTIOBJECT: u1 = 0,
        GCM_RIGHTMOUSEDROP: u1 = 0,
    }) RICH_EDIT_GET_CONTEXT_MENU_SEL_TYPE {
        return @as(RICH_EDIT_GET_CONTEXT_MENU_SEL_TYPE, @enumFromInt((if (o.SEL_EMPTY == 1) @intFromEnum(RICH_EDIT_GET_CONTEXT_MENU_SEL_TYPE.SEL_EMPTY) else 0) | (if (o.SEL_TEXT == 1) @intFromEnum(RICH_EDIT_GET_CONTEXT_MENU_SEL_TYPE.SEL_TEXT) else 0) | (if (o.SEL_OBJECT == 1) @intFromEnum(RICH_EDIT_GET_CONTEXT_MENU_SEL_TYPE.SEL_OBJECT) else 0) | (if (o.SEL_MULTICHAR == 1) @intFromEnum(RICH_EDIT_GET_CONTEXT_MENU_SEL_TYPE.SEL_MULTICHAR) else 0) | (if (o.SEL_MULTIOBJECT == 1) @intFromEnum(RICH_EDIT_GET_CONTEXT_MENU_SEL_TYPE.SEL_MULTIOBJECT) else 0) | (if (o.GCM_RIGHTMOUSEDROP == 1) @intFromEnum(RICH_EDIT_GET_CONTEXT_MENU_SEL_TYPE.GCM_RIGHTMOUSEDROP) else 0)));
    }
};
pub const SEL_EMPTY = RICH_EDIT_GET_CONTEXT_MENU_SEL_TYPE.SEL_EMPTY;
pub const SEL_TEXT = RICH_EDIT_GET_CONTEXT_MENU_SEL_TYPE.SEL_TEXT;
pub const SEL_OBJECT = RICH_EDIT_GET_CONTEXT_MENU_SEL_TYPE.SEL_OBJECT;
pub const SEL_MULTICHAR = RICH_EDIT_GET_CONTEXT_MENU_SEL_TYPE.SEL_MULTICHAR;
pub const SEL_MULTIOBJECT = RICH_EDIT_GET_CONTEXT_MENU_SEL_TYPE.SEL_MULTIOBJECT;
pub const GCM_RIGHTMOUSEDROP = RICH_EDIT_GET_CONTEXT_MENU_SEL_TYPE.GCM_RIGHTMOUSEDROP;

pub const RICH_EDIT_GET_OBJECT_FLAGS = enum(u32) {
    POLEOBJ = 1,
    PSTG = 2,
    POLESITE = 4,
    NO_INTERFACES = 0,
    ALL_INTERFACES = 7,
    _,
    pub fn initFlags(o: struct {
        POLEOBJ: u1 = 0,
        PSTG: u1 = 0,
        POLESITE: u1 = 0,
        NO_INTERFACES: u1 = 0,
        ALL_INTERFACES: u1 = 0,
    }) RICH_EDIT_GET_OBJECT_FLAGS {
        return @as(RICH_EDIT_GET_OBJECT_FLAGS, @enumFromInt((if (o.POLEOBJ == 1) @intFromEnum(RICH_EDIT_GET_OBJECT_FLAGS.POLEOBJ) else 0) | (if (o.PSTG == 1) @intFromEnum(RICH_EDIT_GET_OBJECT_FLAGS.PSTG) else 0) | (if (o.POLESITE == 1) @intFromEnum(RICH_EDIT_GET_OBJECT_FLAGS.POLESITE) else 0) | (if (o.NO_INTERFACES == 1) @intFromEnum(RICH_EDIT_GET_OBJECT_FLAGS.NO_INTERFACES) else 0) | (if (o.ALL_INTERFACES == 1) @intFromEnum(RICH_EDIT_GET_OBJECT_FLAGS.ALL_INTERFACES) else 0)));
    }
};
pub const REO_GETOBJ_POLEOBJ = RICH_EDIT_GET_OBJECT_FLAGS.POLEOBJ;
pub const REO_GETOBJ_PSTG = RICH_EDIT_GET_OBJECT_FLAGS.PSTG;
pub const REO_GETOBJ_POLESITE = RICH_EDIT_GET_OBJECT_FLAGS.POLESITE;
pub const REO_GETOBJ_NO_INTERFACES = RICH_EDIT_GET_OBJECT_FLAGS.NO_INTERFACES;
pub const REO_GETOBJ_ALL_INTERFACES = RICH_EDIT_GET_OBJECT_FLAGS.ALL_INTERFACES;

pub const PARAFORMAT_BORDERS = enum(u16) {
    LEFT = 1,
    RIGHT = 2,
    TOP = 4,
    BOTTOM = 8,
    INSIDE = 16,
    OUTSIDE = 32,
    AUTOCOLOR = 64,
    _,
    pub fn initFlags(o: struct {
        LEFT: u1 = 0,
        RIGHT: u1 = 0,
        TOP: u1 = 0,
        BOTTOM: u1 = 0,
        INSIDE: u1 = 0,
        OUTSIDE: u1 = 0,
        AUTOCOLOR: u1 = 0,
    }) PARAFORMAT_BORDERS {
        return @as(PARAFORMAT_BORDERS, @enumFromInt((if (o.LEFT == 1) @intFromEnum(PARAFORMAT_BORDERS.LEFT) else 0) | (if (o.RIGHT == 1) @intFromEnum(PARAFORMAT_BORDERS.RIGHT) else 0) | (if (o.TOP == 1) @intFromEnum(PARAFORMAT_BORDERS.TOP) else 0) | (if (o.BOTTOM == 1) @intFromEnum(PARAFORMAT_BORDERS.BOTTOM) else 0) | (if (o.INSIDE == 1) @intFromEnum(PARAFORMAT_BORDERS.INSIDE) else 0) | (if (o.OUTSIDE == 1) @intFromEnum(PARAFORMAT_BORDERS.OUTSIDE) else 0) | (if (o.AUTOCOLOR == 1) @intFromEnum(PARAFORMAT_BORDERS.AUTOCOLOR) else 0)));
    }
};
pub const PARAFORMAT_BORDERS_LEFT = PARAFORMAT_BORDERS.LEFT;
pub const PARAFORMAT_BORDERS_RIGHT = PARAFORMAT_BORDERS.RIGHT;
pub const PARAFORMAT_BORDERS_TOP = PARAFORMAT_BORDERS.TOP;
pub const PARAFORMAT_BORDERS_BOTTOM = PARAFORMAT_BORDERS.BOTTOM;
pub const PARAFORMAT_BORDERS_INSIDE = PARAFORMAT_BORDERS.INSIDE;
pub const PARAFORMAT_BORDERS_OUTSIDE = PARAFORMAT_BORDERS.OUTSIDE;
pub const PARAFORMAT_BORDERS_AUTOCOLOR = PARAFORMAT_BORDERS.AUTOCOLOR;

pub const PARAFORMAT_SHADING_STYLE = enum(u16) {
    NONE = 0,
    DARK_HORIZ = 1,
    DARK_VERT = 2,
    DARK_DOWN_DIAG = 3,
    DARK_UP_DIAG = 4,
    DARK_GRID = 5,
    DARK_TRELLIS = 6,
    LIGHT_HORZ = 7,
    LIGHT_VERT = 8,
    LIGHT_DOWN_DIAG = 9,
    LIGHT_UP_DIAG = 10,
    LIGHT_GRID = 11,
    LIGHT_TRELLIS = 12,
};
pub const PARAFORMAT_SHADING_STYLE_NONE = PARAFORMAT_SHADING_STYLE.NONE;
pub const PARAFORMAT_SHADING_STYLE_DARK_HORIZ = PARAFORMAT_SHADING_STYLE.DARK_HORIZ;
pub const PARAFORMAT_SHADING_STYLE_DARK_VERT = PARAFORMAT_SHADING_STYLE.DARK_VERT;
pub const PARAFORMAT_SHADING_STYLE_DARK_DOWN_DIAG = PARAFORMAT_SHADING_STYLE.DARK_DOWN_DIAG;
pub const PARAFORMAT_SHADING_STYLE_DARK_UP_DIAG = PARAFORMAT_SHADING_STYLE.DARK_UP_DIAG;
pub const PARAFORMAT_SHADING_STYLE_DARK_GRID = PARAFORMAT_SHADING_STYLE.DARK_GRID;
pub const PARAFORMAT_SHADING_STYLE_DARK_TRELLIS = PARAFORMAT_SHADING_STYLE.DARK_TRELLIS;
pub const PARAFORMAT_SHADING_STYLE_LIGHT_HORZ = PARAFORMAT_SHADING_STYLE.LIGHT_HORZ;
pub const PARAFORMAT_SHADING_STYLE_LIGHT_VERT = PARAFORMAT_SHADING_STYLE.LIGHT_VERT;
pub const PARAFORMAT_SHADING_STYLE_LIGHT_DOWN_DIAG = PARAFORMAT_SHADING_STYLE.LIGHT_DOWN_DIAG;
pub const PARAFORMAT_SHADING_STYLE_LIGHT_UP_DIAG = PARAFORMAT_SHADING_STYLE.LIGHT_UP_DIAG;
pub const PARAFORMAT_SHADING_STYLE_LIGHT_GRID = PARAFORMAT_SHADING_STYLE.LIGHT_GRID;
pub const PARAFORMAT_SHADING_STYLE_LIGHT_TRELLIS = PARAFORMAT_SHADING_STYLE.LIGHT_TRELLIS;

pub const GETTEXTEX_FLAGS = enum(u32) {
    DEFAULT = 0,
    NOHIDDENTEXT = 8,
    RAWTEXT = 4,
    SELECTION = 2,
    USECRLF = 1,
};
pub const GT_DEFAULT = GETTEXTEX_FLAGS.DEFAULT;
pub const GT_NOHIDDENTEXT = GETTEXTEX_FLAGS.NOHIDDENTEXT;
pub const GT_RAWTEXT = GETTEXTEX_FLAGS.RAWTEXT;
pub const GT_SELECTION = GETTEXTEX_FLAGS.SELECTION;
pub const GT_USECRLF = GETTEXTEX_FLAGS.USECRLF;

pub const ENDCOMPOSITIONNOTIFY_CODE = enum(u32) {
    ENDCOMPOSITION = 1,
    NEWTEXT = 2,
};
pub const ECN_ENDCOMPOSITION = ENDCOMPOSITIONNOTIFY_CODE.ENDCOMPOSITION;
pub const ECN_NEWTEXT = ENDCOMPOSITIONNOTIFY_CODE.NEWTEXT;

pub const IMECOMPTEXT_FLAGS = enum(u32) {
    R = 1,
};
pub const ICT_RESULTREADSTR = IMECOMPTEXT_FLAGS.R;

pub const GETTEXTLENGTHEX_FLAGS = enum(u32) {
    DEFAULT = 0,
    USECRLF = 1,
    PRECISE = 2,
    CLOSE = 4,
    NUMCHARS = 8,
    NUMBYTES = 16,
    _,
    pub fn initFlags(o: struct {
        DEFAULT: u1 = 0,
        USECRLF: u1 = 0,
        PRECISE: u1 = 0,
        CLOSE: u1 = 0,
        NUMCHARS: u1 = 0,
        NUMBYTES: u1 = 0,
    }) GETTEXTLENGTHEX_FLAGS {
        return @as(GETTEXTLENGTHEX_FLAGS, @enumFromInt((if (o.DEFAULT == 1) @intFromEnum(GETTEXTLENGTHEX_FLAGS.DEFAULT) else 0) | (if (o.USECRLF == 1) @intFromEnum(GETTEXTLENGTHEX_FLAGS.USECRLF) else 0) | (if (o.PRECISE == 1) @intFromEnum(GETTEXTLENGTHEX_FLAGS.PRECISE) else 0) | (if (o.CLOSE == 1) @intFromEnum(GETTEXTLENGTHEX_FLAGS.CLOSE) else 0) | (if (o.NUMCHARS == 1) @intFromEnum(GETTEXTLENGTHEX_FLAGS.NUMCHARS) else 0) | (if (o.NUMBYTES == 1) @intFromEnum(GETTEXTLENGTHEX_FLAGS.NUMBYTES) else 0)));
    }
};
pub const GTL_DEFAULT = GETTEXTLENGTHEX_FLAGS.DEFAULT;
pub const GTL_USECRLF = GETTEXTLENGTHEX_FLAGS.USECRLF;
pub const GTL_PRECISE = GETTEXTLENGTHEX_FLAGS.PRECISE;
pub const GTL_CLOSE = GETTEXTLENGTHEX_FLAGS.CLOSE;
pub const GTL_NUMCHARS = GETTEXTLENGTHEX_FLAGS.NUMCHARS;
pub const GTL_NUMBYTES = GETTEXTLENGTHEX_FLAGS.NUMBYTES;

pub const REOBJECT_FLAGS = enum(u32) {
    ALIGNTORIGHT = 256,
    BELOWBASELINE = 2,
    BLANK = 16,
    CANROTATE = 128,
    DONTNEEDPALETTE = 32,
    DYNAMICSIZE = 8,
    GETMETAFILE = 4194304,
    HILITED = 16777216,
    INPLACEACTIVE = 33554432,
    INVERTEDSELECT = 4,
    LINK = 2147483648,
    LINKAVAILABLE = 8388608,
    OPEN = 67108864,
    OWNERDRAWSELECT = 64,
    RESIZABLE = 1,
    SELECTED = 134217728,
    STATIC = 1073741824,
    USEASBACKGROUND = 1024,
    WRAPTEXTAROUND = 512,
    _,
    pub fn initFlags(o: struct {
        ALIGNTORIGHT: u1 = 0,
        BELOWBASELINE: u1 = 0,
        BLANK: u1 = 0,
        CANROTATE: u1 = 0,
        DONTNEEDPALETTE: u1 = 0,
        DYNAMICSIZE: u1 = 0,
        GETMETAFILE: u1 = 0,
        HILITED: u1 = 0,
        INPLACEACTIVE: u1 = 0,
        INVERTEDSELECT: u1 = 0,
        LINK: u1 = 0,
        LINKAVAILABLE: u1 = 0,
        OPEN: u1 = 0,
        OWNERDRAWSELECT: u1 = 0,
        RESIZABLE: u1 = 0,
        SELECTED: u1 = 0,
        STATIC: u1 = 0,
        USEASBACKGROUND: u1 = 0,
        WRAPTEXTAROUND: u1 = 0,
    }) REOBJECT_FLAGS {
        return @as(REOBJECT_FLAGS, @enumFromInt((if (o.ALIGNTORIGHT == 1) @intFromEnum(REOBJECT_FLAGS.ALIGNTORIGHT) else 0) | (if (o.BELOWBASELINE == 1) @intFromEnum(REOBJECT_FLAGS.BELOWBASELINE) else 0) | (if (o.BLANK == 1) @intFromEnum(REOBJECT_FLAGS.BLANK) else 0) | (if (o.CANROTATE == 1) @intFromEnum(REOBJECT_FLAGS.CANROTATE) else 0) | (if (o.DONTNEEDPALETTE == 1) @intFromEnum(REOBJECT_FLAGS.DONTNEEDPALETTE) else 0) | (if (o.DYNAMICSIZE == 1) @intFromEnum(REOBJECT_FLAGS.DYNAMICSIZE) else 0) | (if (o.GETMETAFILE == 1) @intFromEnum(REOBJECT_FLAGS.GETMETAFILE) else 0) | (if (o.HILITED == 1) @intFromEnum(REOBJECT_FLAGS.HILITED) else 0) | (if (o.INPLACEACTIVE == 1) @intFromEnum(REOBJECT_FLAGS.INPLACEACTIVE) else 0) | (if (o.INVERTEDSELECT == 1) @intFromEnum(REOBJECT_FLAGS.INVERTEDSELECT) else 0) | (if (o.LINK == 1) @intFromEnum(REOBJECT_FLAGS.LINK) else 0) | (if (o.LINKAVAILABLE == 1) @intFromEnum(REOBJECT_FLAGS.LINKAVAILABLE) else 0) | (if (o.OPEN == 1) @intFromEnum(REOBJECT_FLAGS.OPEN) else 0) | (if (o.OWNERDRAWSELECT == 1) @intFromEnum(REOBJECT_FLAGS.OWNERDRAWSELECT) else 0) | (if (o.RESIZABLE == 1) @intFromEnum(REOBJECT_FLAGS.RESIZABLE) else 0) | (if (o.SELECTED == 1) @intFromEnum(REOBJECT_FLAGS.SELECTED) else 0) | (if (o.STATIC == 1) @intFromEnum(REOBJECT_FLAGS.STATIC) else 0) | (if (o.USEASBACKGROUND == 1) @intFromEnum(REOBJECT_FLAGS.USEASBACKGROUND) else 0) | (if (o.WRAPTEXTAROUND == 1) @intFromEnum(REOBJECT_FLAGS.WRAPTEXTAROUND) else 0)));
    }
};
pub const REO_ALIGNTORIGHT = REOBJECT_FLAGS.ALIGNTORIGHT;
pub const REO_BELOWBASELINE = REOBJECT_FLAGS.BELOWBASELINE;
pub const REO_BLANK = REOBJECT_FLAGS.BLANK;
pub const REO_CANROTATE = REOBJECT_FLAGS.CANROTATE;
pub const REO_DONTNEEDPALETTE = REOBJECT_FLAGS.DONTNEEDPALETTE;
pub const REO_DYNAMICSIZE = REOBJECT_FLAGS.DYNAMICSIZE;
pub const REO_GETMETAFILE = REOBJECT_FLAGS.GETMETAFILE;
pub const REO_HILITED = REOBJECT_FLAGS.HILITED;
pub const REO_INPLACEACTIVE = REOBJECT_FLAGS.INPLACEACTIVE;
pub const REO_INVERTEDSELECT = REOBJECT_FLAGS.INVERTEDSELECT;
pub const REO_LINK = REOBJECT_FLAGS.LINK;
pub const REO_LINKAVAILABLE = REOBJECT_FLAGS.LINKAVAILABLE;
pub const REO_OPEN = REOBJECT_FLAGS.OPEN;
pub const REO_OWNERDRAWSELECT = REOBJECT_FLAGS.OWNERDRAWSELECT;
pub const REO_RESIZABLE = REOBJECT_FLAGS.RESIZABLE;
pub const REO_SELECTED = REOBJECT_FLAGS.SELECTED;
pub const REO_STATIC = REOBJECT_FLAGS.STATIC;
pub const REO_USEASBACKGROUND = REOBJECT_FLAGS.USEASBACKGROUND;
pub const REO_WRAPTEXTAROUND = REOBJECT_FLAGS.WRAPTEXTAROUND;

pub const PARAFORMAT_NUMBERING_STYLE = enum(u16) {
    PAREN = 0,
    PARENS = 256,
    PERIOD = 512,
    PLAIN = 768,
    NONUMBER = 1024,
    NEWNUMBER = 32768,
};
pub const PFNS_PAREN = PARAFORMAT_NUMBERING_STYLE.PAREN;
pub const PFNS_PARENS = PARAFORMAT_NUMBERING_STYLE.PARENS;
pub const PFNS_PERIOD = PARAFORMAT_NUMBERING_STYLE.PERIOD;
pub const PFNS_PLAIN = PARAFORMAT_NUMBERING_STYLE.PLAIN;
pub const PFNS_NONUMBER = PARAFORMAT_NUMBERING_STYLE.NONUMBER;
pub const PFNS_NEWNUMBER = PARAFORMAT_NUMBERING_STYLE.NEWNUMBER;

pub const PARAFORMAT_ALIGNMENT = enum(u16) {
    CENTER = 3,
    LEFT = 1,
    RIGHT = 2,
};
pub const PFA_CENTER = PARAFORMAT_ALIGNMENT.CENTER;
pub const PFA_LEFT = PARAFORMAT_ALIGNMENT.LEFT;
pub const PFA_RIGHT = PARAFORMAT_ALIGNMENT.RIGHT;

pub const TEXTMODE = enum(i32) {
    PLAINTEXT = 1,
    RICHTEXT = 2,
    SINGLELEVELUNDO = 4,
    MULTILEVELUNDO = 8,
    SINGLECODEPAGE = 16,
    MULTICODEPAGE = 32,
};
pub const TM_PLAINTEXT = TEXTMODE.PLAINTEXT;
pub const TM_RICHTEXT = TEXTMODE.RICHTEXT;
pub const TM_SINGLELEVELUNDO = TEXTMODE.SINGLELEVELUNDO;
pub const TM_MULTILEVELUNDO = TEXTMODE.MULTILEVELUNDO;
pub const TM_SINGLECODEPAGE = TEXTMODE.SINGLECODEPAGE;
pub const TM_MULTICODEPAGE = TEXTMODE.MULTICODEPAGE;

pub const IMECOMPTEXT = extern struct {
    cb: i32,
    flags: IMECOMPTEXT_FLAGS,
};

pub const TABLEROWPARMS = extern struct {
    cbRow: u8,
    cbCell: u8,
    cCell: u8,
    cRow: u8,
    dxCellMargin: i32,
    dxIndent: i32,
    dyHeight: i32,
    _bitfield: u32,
    cpStartRow: i32,
    bTableLevel: u8,
    iCell: u8,
};

pub const TABLECELLPARMS = extern struct {
    dxWidth: i32,
    _bitfield: u16,
    wShading: u16,
    dxBrdrLeft: i16,
    dyBrdrTop: i16,
    dxBrdrRight: i16,
    dyBrdrBottom: i16,
    crBrdrLeft: u32,
    crBrdrTop: u32,
    crBrdrRight: u32,
    crBrdrBottom: u32,
    crBackPat: u32,
    crForePat: u32,
};

pub const AutoCorrectProc = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        langid: u16,
        pszBefore: ?[*:0]const u16,
        pszAfter: ?PWSTR,
        cchAfter: i32,
        pcchReplaced: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
    else => *const fn (
        langid: u16,
        pszBefore: ?[*:0]const u16,
        pszAfter: ?PWSTR,
        cchAfter: i32,
        pcchReplaced: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
};

pub const RICHEDIT_IMAGE_PARAMETERS = extern struct {
    xWidth: i32 align(4),
    yHeight: i32 align(4),
    Ascent: i32 align(4),
    Type: TEXT_ALIGN_OPTIONS align(4),
    pwszAlternateText: ?[*:0]const u16 align(4),
    pIStream: ?*IStream align(4),
};

pub const ENDCOMPOSITIONNOTIFY = extern struct {
    nmhdr: NMHDR align(4),
    dwCode: ENDCOMPOSITIONNOTIFY_CODE align(4),
};

pub const EDITWORDBREAKPROCEX = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        pchText: ?PSTR,
        cchText: i32,
        bCharSet: u8,
        action: i32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
    else => *const fn (
        pchText: ?PSTR,
        cchText: i32,
        bCharSet: u8,
        action: i32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
};

pub const CHARFORMATA = extern struct {
    cbSize: u32,
    dwMask: CFM_MASK,
    dwEffects: CFE_EFFECTS,
    yHeight: i32,
    yOffset: i32,
    crTextColor: u32,
    bCharSet: u8,
    bPitchAndFamily: u8,
    szFaceName: [32]CHAR,
};

pub const CHARFORMATW = extern struct {
    cbSize: u32,
    dwMask: CFM_MASK,
    dwEffects: CFE_EFFECTS,
    yHeight: i32,
    yOffset: i32,
    crTextColor: u32,
    bCharSet: u8,
    bPitchAndFamily: u8,
    szFaceName: [32]u16,
};

pub const CHARFORMAT2W = extern struct {
    __AnonymousBase_richedit_L711_C23: CHARFORMATW,
    wWeight: u16,
    sSpacing: i16,
    crBackColor: u32,
    lcid: u32,
    Anonymous: extern union {
        dwReserved: u32,
        dwCookie: u32,
    },
    sStyle: i16,
    wKerning: u16,
    bUnderlineType: u8,
    bAnimation: u8,
    bRevAuthor: u8,
    bUnderlineColor: u8,
};

pub const CHARFORMAT2A = extern struct {
    __AnonymousBase_richedit_L736_C23: CHARFORMATA,
    wWeight: u16,
    sSpacing: i16,
    crBackColor: u32,
    lcid: u32,
    Anonymous: extern union {
        dwReserved: u32,
        dwCookie: u32,
    },
    sStyle: i16,
    wKerning: u16,
    bUnderlineType: u8,
    bAnimation: u8,
    bRevAuthor: u8,
    bUnderlineColor: u8,
};

pub const CHARRANGE = extern struct {
    cpMin: i32,
    cpMax: i32,
};

pub const TEXTRANGEA = extern struct {
    chrg: CHARRANGE align(4),
    lpstrText: ?PSTR align(4),
};

pub const TEXTRANGEW = extern struct {
    chrg: CHARRANGE align(4),
    lpstrText: ?PWSTR align(4),
};

pub const EDITSTREAMCALLBACK = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        dwCookie: usize,
        pbBuff: ?*u8,
        cb: i32,
        pcb: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) u32,
    else => *const fn (
        dwCookie: usize,
        pbBuff: ?*u8,
        cb: i32,
        pcb: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) u32,
};

pub const EDITSTREAM = extern struct {
    dwCookie: usize align(4),
    dwError: u32 align(4),
    pfnCallback: ?EDITSTREAMCALLBACK align(4),
};

pub const FINDTEXTA = extern struct {
    chrg: CHARRANGE align(4),
    lpstrText: ?[*:0]const u8 align(4),
};

pub const FINDTEXTW = extern struct {
    chrg: CHARRANGE align(4),
    lpstrText: ?[*:0]const u16 align(4),
};

pub const FINDTEXTEXA = extern struct {
    chrg: CHARRANGE align(4),
    lpstrText: ?[*:0]const u8 align(4),
    chrgText: CHARRANGE align(4),
};

pub const FINDTEXTEXW = extern struct {
    chrg: CHARRANGE align(4),
    lpstrText: ?[*:0]const u16 align(4),
    chrgText: CHARRANGE align(4),
};

pub const FORMATRANGE = extern struct {
    hdc: ?HDC align(4),
    hdcTarget: ?HDC align(4),
    rc: RECT align(4),
    rcPage: RECT align(4),
    chrg: CHARRANGE align(4),
};

pub const PARAFORMAT = extern struct {
    cbSize: u32,
    dwMask: PARAFORMAT_MASK,
    wNumbering: u16,
    Anonymous: extern union {
        wReserved: u16,
        wEffects: u16,
    },
    dxStartIndent: i32,
    dxRightIndent: i32,
    dxOffset: i32,
    wAlignment: PARAFORMAT_ALIGNMENT,
    cTabCount: i16,
    rgxTabs: [32]u32,
};

pub const PARAFORMAT2 = extern struct {
    __AnonymousBase_richedit_L1149_C22: PARAFORMAT,
    dySpaceBefore: i32,
    dySpaceAfter: i32,
    dyLineSpacing: i32,
    sStyle: i16,
    bLineSpacingRule: u8,
    bOutlineLevel: u8,
    wShadingWeight: u16,
    wShadingStyle: PARAFORMAT_SHADING_STYLE,
    wNumberingStart: u16,
    wNumberingStyle: PARAFORMAT_NUMBERING_STYLE,
    wNumberingTab: u16,
    wBorderSpace: u16,
    wBorderWidth: u16,
    wBorders: PARAFORMAT_BORDERS,
};

pub const MSGFILTER = extern struct {
    nmhdr: NMHDR align(4),
    msg: u32 align(4),
    wParam: WPARAM align(4),
    lParam: LPARAM align(4),
};

pub const REQRESIZE = extern struct {
    nmhdr: NMHDR align(4),
    rc: RECT align(4),
};

pub const SELCHANGE = extern struct {
    nmhdr: NMHDR align(4),
    chrg: CHARRANGE align(4),
    seltyp: RICH_EDIT_GET_CONTEXT_MENU_SEL_TYPE align(4),
};

pub const _grouptypingchange = extern struct {
    nmhdr: NMHDR align(4),
    fGroupTyping: BOOL align(4),
};

pub const CLIPBOARDFORMAT = extern struct {
    nmhdr: NMHDR align(4),
    cf: u16 align(4),
};

pub const GETCONTEXTMENUEX = extern struct {
    chrg: CHARRANGE align(4),
    dwFlags: u32 align(4),
    pt: POINT align(4),
    pvReserved: ?*anyopaque align(4),
};

pub const ENDROPFILES = extern struct {
    nmhdr: NMHDR align(4),
    hDrop: ?HANDLE align(4),
    cp: i32 align(4),
    fProtected: BOOL align(4),
};

pub const ENPROTECTED = extern struct {
    nmhdr: NMHDR align(4),
    msg: u32 align(4),
    wParam: WPARAM align(4),
    lParam: LPARAM align(4),
    chrg: CHARRANGE align(4),
};

pub const ENSAVECLIPBOARD = extern struct {
    nmhdr: NMHDR align(4),
    cObjectCount: i32 align(4),
    cch: i32 align(4),
};

pub const ENOLEOPFAILED = extern struct {
    nmhdr: NMHDR align(4),
    iob: i32 align(4),
    lOper: i32 align(4),
    hr: HRESULT align(4),
};

pub const OBJECTPOSITIONS = extern struct {
    nmhdr: NMHDR align(4),
    cObjectCount: i32 align(4),
    pcpPositions: ?*i32 align(4),
};

pub const ENLINK = extern struct {
    nmhdr: NMHDR align(4),
    msg: u32 align(4),
    wParam: WPARAM align(4),
    lParam: LPARAM align(4),
    chrg: CHARRANGE align(4),
};

pub const ENLOWFIRTF = extern struct {
    nmhdr: NMHDR align(4),
    szControl: ?PSTR align(4),
};

pub const ENCORRECTTEXT = extern struct {
    nmhdr: NMHDR align(4),
    chrg: CHARRANGE align(4),
    seltyp: RICH_EDIT_GET_CONTEXT_MENU_SEL_TYPE align(4),
};

pub const PUNCTUATION = extern struct {
    iSize: u32 align(4),
    szPunctuation: ?PSTR align(4),
};

pub const COMPCOLOR = extern struct {
    crText: u32,
    crBackground: u32,
    dwEffects: u32,
};

pub const REPASTESPECIAL = extern struct {
    dwAspect: DVASPECT align(4),
    dwParam: usize align(4),
};

pub const UNDONAMEID = enum(i32) {
    UNKNOWN = 0,
    TYPING = 1,
    DELETE = 2,
    DRAGDROP = 3,
    CUT = 4,
    PASTE = 5,
    AUTOTABLE = 6,
};
pub const UID_UNKNOWN = UNDONAMEID.UNKNOWN;
pub const UID_TYPING = UNDONAMEID.TYPING;
pub const UID_DELETE = UNDONAMEID.DELETE;
pub const UID_DRAGDROP = UNDONAMEID.DRAGDROP;
pub const UID_CUT = UNDONAMEID.CUT;
pub const UID_PASTE = UNDONAMEID.PASTE;
pub const UID_AUTOTABLE = UNDONAMEID.AUTOTABLE;

pub const SETTEXTEX = extern struct {
    flags: u32,
    codepage: u32,
};

pub const GETTEXTEX = extern struct {
    cb: u32 align(4),
    flags: GETTEXTEX_FLAGS align(4),
    codepage: u32 align(4),
    lpDefaultChar: ?[*:0]const u8 align(4),
    lpUsedDefChar: ?*i32 align(4),
};

pub const GETTEXTLENGTHEX = extern struct {
    flags: GETTEXTLENGTHEX_FLAGS,
    codepage: u32,
};

pub const BIDIOPTIONS = extern struct {
    cbSize: u32,
    wMask: u16,
    wEffects: u16,
};

pub const KHYPH = enum(i32) {
    Nil = 0,
    Normal = 1,
    AddBefore = 2,
    ChangeBefore = 3,
    DeleteBefore = 4,
    ChangeAfter = 5,
    DelAndChange = 6,
};
pub const khyphNil = KHYPH.Nil;
pub const khyphNormal = KHYPH.Normal;
pub const khyphAddBefore = KHYPH.AddBefore;
pub const khyphChangeBefore = KHYPH.ChangeBefore;
pub const khyphDeleteBefore = KHYPH.DeleteBefore;
pub const khyphChangeAfter = KHYPH.ChangeAfter;
pub const khyphDelAndChange = KHYPH.DelAndChange;

pub const hyphresult = extern struct {
    khyph: KHYPH,
    ichHyph: i32,
    chHyph: u16,
};

pub const HYPHENATEINFO = extern struct {
    cbSize: i16 align(4),
    dxHyphenateZone: i16 align(4),
    pfnHyphenate: isize align(4),
};

pub const TXTBACKSTYLE = enum(i32) {
    TRANSPARENT = 0,
    OPAQUE = 1,
};
pub const TXTBACK_TRANSPARENT = TXTBACKSTYLE.TRANSPARENT;
pub const TXTBACK_OPAQUE = TXTBACKSTYLE.OPAQUE;

pub const TXTHITRESULT = enum(i32) {
    NOHIT = 0,
    TRANSPARENT = 1,
    CLOSE = 2,
    HIT = 3,
};
pub const TXTHITRESULT_NOHIT = TXTHITRESULT.NOHIT;
pub const TXTHITRESULT_TRANSPARENT = TXTHITRESULT.TRANSPARENT;
pub const TXTHITRESULT_CLOSE = TXTHITRESULT.CLOSE;
pub const TXTHITRESULT_HIT = TXTHITRESULT.HIT;

pub const TXTNATURALSIZE = enum(i32) {
    FITTOCONTENT2 = 0,
    FITTOCONTENT = 1,
    ROUNDTOLINE = 2,
    FITTOCONTENT3 = 3,
    FITTOCONTENTWSP = 4,
    INCLUDELASTLINE = 1073741824,
    EMU = -2147483648,
};
pub const TXTNS_FITTOCONTENT2 = TXTNATURALSIZE.FITTOCONTENT2;
pub const TXTNS_FITTOCONTENT = TXTNATURALSIZE.FITTOCONTENT;
pub const TXTNS_ROUNDTOLINE = TXTNATURALSIZE.ROUNDTOLINE;
pub const TXTNS_FITTOCONTENT3 = TXTNATURALSIZE.FITTOCONTENT3;
pub const TXTNS_FITTOCONTENTWSP = TXTNATURALSIZE.FITTOCONTENTWSP;
pub const TXTNS_INCLUDELASTLINE = TXTNATURALSIZE.INCLUDELASTLINE;
pub const TXTNS_EMU = TXTNATURALSIZE.EMU;

pub const TXTVIEW = enum(i32) {
    ACTIVE = 0,
    INACTIVE = -1,
};
pub const TXTVIEW_ACTIVE = TXTVIEW.ACTIVE;
pub const TXTVIEW_INACTIVE = TXTVIEW.INACTIVE;

pub const CHANGETYPE = enum(i32) {
    GENERIC = 0,
    TEXTCHANGED = 1,
    NEWUNDO = 2,
    NEWREDO = 4,
};
pub const CN_GENERIC = CHANGETYPE.GENERIC;
pub const CN_TEXTCHANGED = CHANGETYPE.TEXTCHANGED;
pub const CN_NEWUNDO = CHANGETYPE.NEWUNDO;
pub const CN_NEWREDO = CHANGETYPE.NEWREDO;

pub const CHANGENOTIFY = extern struct {
    dwChangeType: CHANGETYPE,
    pvCookieData: ?*anyopaque,
};

pub const ITextServices = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        TxSendMessage: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextServices,
                msg: u32,
                wparam: WPARAM,
                lparam: LPARAM,
                plresult: ?*LRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextServices,
                msg: u32,
                wparam: WPARAM,
                lparam: LPARAM,
                plresult: ?*LRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TxDraw: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextServices,
                dwDrawAspect: DVASPECT,
                lindex: i32,
                pvAspect: ?*anyopaque,
                ptd: ?*DVTARGETDEVICE,
                hdcDraw: ?HDC,
                hicTargetDev: ?HDC,
                lprcBounds: ?*RECTL,
                lprcWBounds: ?*RECTL,
                lprcUpdate: ?*RECT,
                pfnContinue: isize,
                dwContinue: u32,
                lViewId: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextServices,
                dwDrawAspect: DVASPECT,
                lindex: i32,
                pvAspect: ?*anyopaque,
                ptd: ?*DVTARGETDEVICE,
                hdcDraw: ?HDC,
                hicTargetDev: ?HDC,
                lprcBounds: ?*RECTL,
                lprcWBounds: ?*RECTL,
                lprcUpdate: ?*RECT,
                pfnContinue: isize,
                dwContinue: u32,
                lViewId: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TxGetHScroll: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextServices,
                plMin: ?*i32,
                plMax: ?*i32,
                plPos: ?*i32,
                plPage: ?*i32,
                pfEnabled: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextServices,
                plMin: ?*i32,
                plMax: ?*i32,
                plPos: ?*i32,
                plPage: ?*i32,
                pfEnabled: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TxGetVScroll: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextServices,
                plMin: ?*i32,
                plMax: ?*i32,
                plPos: ?*i32,
                plPage: ?*i32,
                pfEnabled: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextServices,
                plMin: ?*i32,
                plMax: ?*i32,
                plPos: ?*i32,
                plPage: ?*i32,
                pfEnabled: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnTxSetCursor: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextServices,
                dwDrawAspect: DVASPECT,
                lindex: i32,
                pvAspect: ?*anyopaque,
                ptd: ?*DVTARGETDEVICE,
                hdcDraw: ?HDC,
                hicTargetDev: ?HDC,
                lprcClient: ?*RECT,
                x: i32,
                y: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextServices,
                dwDrawAspect: DVASPECT,
                lindex: i32,
                pvAspect: ?*anyopaque,
                ptd: ?*DVTARGETDEVICE,
                hdcDraw: ?HDC,
                hicTargetDev: ?HDC,
                lprcClient: ?*RECT,
                x: i32,
                y: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TxQueryHitPoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextServices,
                dwDrawAspect: DVASPECT,
                lindex: i32,
                pvAspect: ?*anyopaque,
                ptd: ?*DVTARGETDEVICE,
                hdcDraw: ?HDC,
                hicTargetDev: ?HDC,
                lprcClient: ?*RECT,
                x: i32,
                y: i32,
                pHitResult: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextServices,
                dwDrawAspect: DVASPECT,
                lindex: i32,
                pvAspect: ?*anyopaque,
                ptd: ?*DVTARGETDEVICE,
                hdcDraw: ?HDC,
                hicTargetDev: ?HDC,
                lprcClient: ?*RECT,
                x: i32,
                y: i32,
                pHitResult: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnTxInPlaceActivate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextServices,
                prcClient: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextServices,
                prcClient: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnTxInPlaceDeactivate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextServices,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextServices,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnTxUIActivate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextServices,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextServices,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnTxUIDeactivate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextServices,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextServices,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TxGetText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextServices,
                pbstrText: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextServices,
                pbstrText: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TxSetText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextServices,
                pszText: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextServices,
                pszText: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TxGetCurTargetX: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextServices,
                param0: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextServices,
                param0: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TxGetBaseLinePos: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextServices,
                param0: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextServices,
                param0: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TxGetNaturalSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextServices,
                dwAspect: u32,
                hdcDraw: ?HDC,
                hicTargetDev: ?HDC,
                ptd: ?*DVTARGETDEVICE,
                dwMode: u32,
                psizelExtent: ?*const SIZE,
                pwidth: ?*i32,
                pheight: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextServices,
                dwAspect: u32,
                hdcDraw: ?HDC,
                hicTargetDev: ?HDC,
                ptd: ?*DVTARGETDEVICE,
                dwMode: u32,
                psizelExtent: ?*const SIZE,
                pwidth: ?*i32,
                pheight: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TxGetDropTarget: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextServices,
                ppDropTarget: ?*?*IDropTarget,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextServices,
                ppDropTarget: ?*?*IDropTarget,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnTxPropertyBitsChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextServices,
                dwMask: u32,
                dwBits: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextServices,
                dwMask: u32,
                dwBits: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TxGetCachedSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextServices,
                pdwWidth: ?*u32,
                pdwHeight: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextServices,
                pdwWidth: ?*u32,
                pdwHeight: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextServices_TxSendMessage(self: *const T, msg: u32, wparam: WPARAM, lparam: LPARAM, plresult: ?*LRESULT) HRESULT {
                return @as(*const ITextServices.VTable, @ptrCast(self.vtable)).TxSendMessage(@as(*const ITextServices, @ptrCast(self)), msg, wparam, lparam, plresult);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextServices_TxDraw(self: *const T, dwDrawAspect: DVASPECT, lindex: i32, pvAspect: ?*anyopaque, ptd: ?*DVTARGETDEVICE, hdcDraw: ?HDC, hicTargetDev: ?HDC, lprcBounds: ?*RECTL, lprcWBounds: ?*RECTL, lprcUpdate: ?*RECT, pfnContinue: isize, dwContinue: u32, lViewId: i32) HRESULT {
                return @as(*const ITextServices.VTable, @ptrCast(self.vtable)).TxDraw(@as(*const ITextServices, @ptrCast(self)), dwDrawAspect, lindex, pvAspect, ptd, hdcDraw, hicTargetDev, lprcBounds, lprcWBounds, lprcUpdate, pfnContinue, dwContinue, lViewId);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextServices_TxGetHScroll(self: *const T, plMin: ?*i32, plMax: ?*i32, plPos: ?*i32, plPage: ?*i32, pfEnabled: ?*BOOL) HRESULT {
                return @as(*const ITextServices.VTable, @ptrCast(self.vtable)).TxGetHScroll(@as(*const ITextServices, @ptrCast(self)), plMin, plMax, plPos, plPage, pfEnabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextServices_TxGetVScroll(self: *const T, plMin: ?*i32, plMax: ?*i32, plPos: ?*i32, plPage: ?*i32, pfEnabled: ?*BOOL) HRESULT {
                return @as(*const ITextServices.VTable, @ptrCast(self.vtable)).TxGetVScroll(@as(*const ITextServices, @ptrCast(self)), plMin, plMax, plPos, plPage, pfEnabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextServices_OnTxSetCursor(self: *const T, dwDrawAspect: DVASPECT, lindex: i32, pvAspect: ?*anyopaque, ptd: ?*DVTARGETDEVICE, hdcDraw: ?HDC, hicTargetDev: ?HDC, lprcClient: ?*RECT, x: i32, y: i32) HRESULT {
                return @as(*const ITextServices.VTable, @ptrCast(self.vtable)).OnTxSetCursor(@as(*const ITextServices, @ptrCast(self)), dwDrawAspect, lindex, pvAspect, ptd, hdcDraw, hicTargetDev, lprcClient, x, y);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextServices_TxQueryHitPoint(self: *const T, dwDrawAspect: DVASPECT, lindex: i32, pvAspect: ?*anyopaque, ptd: ?*DVTARGETDEVICE, hdcDraw: ?HDC, hicTargetDev: ?HDC, lprcClient: ?*RECT, x: i32, y: i32, pHitResult: ?*u32) HRESULT {
                return @as(*const ITextServices.VTable, @ptrCast(self.vtable)).TxQueryHitPoint(@as(*const ITextServices, @ptrCast(self)), dwDrawAspect, lindex, pvAspect, ptd, hdcDraw, hicTargetDev, lprcClient, x, y, pHitResult);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextServices_OnTxInPlaceActivate(self: *const T, prcClient: ?*RECT) HRESULT {
                return @as(*const ITextServices.VTable, @ptrCast(self.vtable)).OnTxInPlaceActivate(@as(*const ITextServices, @ptrCast(self)), prcClient);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextServices_OnTxInPlaceDeactivate(self: *const T) HRESULT {
                return @as(*const ITextServices.VTable, @ptrCast(self.vtable)).OnTxInPlaceDeactivate(@as(*const ITextServices, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextServices_OnTxUIActivate(self: *const T) HRESULT {
                return @as(*const ITextServices.VTable, @ptrCast(self.vtable)).OnTxUIActivate(@as(*const ITextServices, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextServices_OnTxUIDeactivate(self: *const T) HRESULT {
                return @as(*const ITextServices.VTable, @ptrCast(self.vtable)).OnTxUIDeactivate(@as(*const ITextServices, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextServices_TxGetText(self: *const T, pbstrText: ?*?BSTR) HRESULT {
                return @as(*const ITextServices.VTable, @ptrCast(self.vtable)).TxGetText(@as(*const ITextServices, @ptrCast(self)), pbstrText);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextServices_TxSetText(self: *const T, pszText: ?[*:0]const u16) HRESULT {
                return @as(*const ITextServices.VTable, @ptrCast(self.vtable)).TxSetText(@as(*const ITextServices, @ptrCast(self)), pszText);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextServices_TxGetCurTargetX(self: *const T, param0: ?*i32) HRESULT {
                return @as(*const ITextServices.VTable, @ptrCast(self.vtable)).TxGetCurTargetX(@as(*const ITextServices, @ptrCast(self)), param0);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextServices_TxGetBaseLinePos(self: *const T, param0: ?*i32) HRESULT {
                return @as(*const ITextServices.VTable, @ptrCast(self.vtable)).TxGetBaseLinePos(@as(*const ITextServices, @ptrCast(self)), param0);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextServices_TxGetNaturalSize(self: *const T, dwAspect: u32, hdcDraw: ?HDC, hicTargetDev: ?HDC, ptd: ?*DVTARGETDEVICE, dwMode: u32, psizelExtent: ?*const SIZE, pwidth: ?*i32, pheight: ?*i32) HRESULT {
                return @as(*const ITextServices.VTable, @ptrCast(self.vtable)).TxGetNaturalSize(@as(*const ITextServices, @ptrCast(self)), dwAspect, hdcDraw, hicTargetDev, ptd, dwMode, psizelExtent, pwidth, pheight);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextServices_TxGetDropTarget(self: *const T, ppDropTarget: ?*?*IDropTarget) HRESULT {
                return @as(*const ITextServices.VTable, @ptrCast(self.vtable)).TxGetDropTarget(@as(*const ITextServices, @ptrCast(self)), ppDropTarget);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextServices_OnTxPropertyBitsChange(self: *const T, dwMask: u32, dwBits: u32) HRESULT {
                return @as(*const ITextServices.VTable, @ptrCast(self.vtable)).OnTxPropertyBitsChange(@as(*const ITextServices, @ptrCast(self)), dwMask, dwBits);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextServices_TxGetCachedSize(self: *const T, pdwWidth: ?*u32, pdwHeight: ?*u32) HRESULT {
                return @as(*const ITextServices.VTable, @ptrCast(self.vtable)).TxGetCachedSize(@as(*const ITextServices, @ptrCast(self)), pdwWidth, pdwHeight);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const CARET_FLAGS = enum(i32) {
    NONE = 0,
    CUSTOM = 1,
    RTL = 2,
    ITALIC = 32,
    NULL = 64,
    ROTATE90 = 128,
};
pub const CARET_NONE = CARET_FLAGS.NONE;
pub const CARET_CUSTOM = CARET_FLAGS.CUSTOM;
pub const CARET_RTL = CARET_FLAGS.RTL;
pub const CARET_ITALIC = CARET_FLAGS.ITALIC;
pub const CARET_NULL = CARET_FLAGS.NULL;
pub const CARET_ROTATE90 = CARET_FLAGS.ROTATE90;

pub const CARET_INFO = extern union {
    hbitmap: ?HBITMAP,
    caretFlags: CARET_FLAGS,
};

pub const ITextHost = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        TxGetDC: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextHost,
            ) callconv(@import("std").os.windows.WINAPI) ?HDC,
            else => *const fn (
                self: *const ITextHost,
            ) callconv(@import("std").os.windows.WINAPI) ?HDC,
        },
        TxReleaseDC: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextHost,
                hdc: ?HDC,
            ) callconv(@import("std").os.windows.WINAPI) i32,
            else => *const fn (
                self: *const ITextHost,
                hdc: ?HDC,
            ) callconv(@import("std").os.windows.WINAPI) i32,
        },
        TxShowScrollBar: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextHost,
                fnBar: i32,
                fShow: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
            else => *const fn (
                self: *const ITextHost,
                fnBar: i32,
                fShow: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
        },
        TxEnableScrollBar: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextHost,
                fuSBFlags: SCROLLBAR_CONSTANTS,
                fuArrowflags: ENABLE_SCROLL_BAR_ARROWS,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
            else => *const fn (
                self: *const ITextHost,
                fuSBFlags: SCROLLBAR_CONSTANTS,
                fuArrowflags: ENABLE_SCROLL_BAR_ARROWS,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
        },
        TxSetScrollRange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextHost,
                fnBar: i32,
                nMinPos: i32,
                nMaxPos: i32,
                fRedraw: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
            else => *const fn (
                self: *const ITextHost,
                fnBar: i32,
                nMinPos: i32,
                nMaxPos: i32,
                fRedraw: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
        },
        TxSetScrollPos: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextHost,
                fnBar: i32,
                nPos: i32,
                fRedraw: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
            else => *const fn (
                self: *const ITextHost,
                fnBar: i32,
                nPos: i32,
                fRedraw: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
        },
        TxInvalidateRect: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextHost,
                prc: ?*RECT,
                fMode: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const ITextHost,
                prc: ?*RECT,
                fMode: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        TxViewChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextHost,
                fUpdate: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const ITextHost,
                fUpdate: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        TxCreateCaret: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextHost,
                hbmp: ?HBITMAP,
                xWidth: i32,
                yHeight: i32,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
            else => *const fn (
                self: *const ITextHost,
                hbmp: ?HBITMAP,
                xWidth: i32,
                yHeight: i32,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
        },
        TxShowCaret: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextHost,
                fShow: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
            else => *const fn (
                self: *const ITextHost,
                fShow: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
        },
        TxSetCaretPos: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextHost,
                x: i32,
                y: i32,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
            else => *const fn (
                self: *const ITextHost,
                x: i32,
                y: i32,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
        },
        TxSetTimer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextHost,
                idTimer: u32,
                uTimeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
            else => *const fn (
                self: *const ITextHost,
                idTimer: u32,
                uTimeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
        },
        TxKillTimer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextHost,
                idTimer: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const ITextHost,
                idTimer: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        TxScrollWindowEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextHost,
                dx: i32,
                dy: i32,
                lprcScroll: ?*RECT,
                lprcClip: ?*RECT,
                hrgnUpdate: ?HRGN,
                lprcUpdate: ?*RECT,
                fuScroll: SHOW_WINDOW_CMD,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const ITextHost,
                dx: i32,
                dy: i32,
                lprcScroll: ?*RECT,
                lprcClip: ?*RECT,
                hrgnUpdate: ?HRGN,
                lprcUpdate: ?*RECT,
                fuScroll: SHOW_WINDOW_CMD,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        TxSetCapture: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextHost,
                fCapture: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const ITextHost,
                fCapture: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        TxSetFocus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextHost,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const ITextHost,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        TxSetCursor: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextHost,
                hcur: ?HCURSOR,
                fText: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const ITextHost,
                hcur: ?HCURSOR,
                fText: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        TxScreenToClient: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextHost,
                lppt: ?*POINT,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
            else => *const fn (
                self: *const ITextHost,
                lppt: ?*POINT,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
        },
        TxClientToScreen: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextHost,
                lppt: ?*POINT,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
            else => *const fn (
                self: *const ITextHost,
                lppt: ?*POINT,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
        },
        TxActivate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextHost,
                plOldState: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextHost,
                plOldState: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TxDeactivate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextHost,
                lNewState: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextHost,
                lNewState: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TxGetClientRect: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextHost,
                prc: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextHost,
                prc: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TxGetViewInset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextHost,
                prc: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextHost,
                prc: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TxGetCharFormat: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextHost,
                ppCF: ?*const ?*CHARFORMATW,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextHost,
                ppCF: ?*const ?*CHARFORMATW,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TxGetParaFormat: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextHost,
                ppPF: ?*const ?*PARAFORMAT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextHost,
                ppPF: ?*const ?*PARAFORMAT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TxGetSysColor: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextHost,
                nIndex: i32,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn (
                self: *const ITextHost,
                nIndex: i32,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
        TxGetBackStyle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextHost,
                pstyle: ?*TXTBACKSTYLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextHost,
                pstyle: ?*TXTBACKSTYLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TxGetMaxLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextHost,
                plength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextHost,
                plength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TxGetScrollBars: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextHost,
                pdwScrollBar: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextHost,
                pdwScrollBar: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TxGetPasswordChar: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextHost,
                pch: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextHost,
                pch: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TxGetAcceleratorPos: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextHost,
                pcp: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextHost,
                pcp: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TxGetExtent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextHost,
                lpExtent: ?*SIZE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextHost,
                lpExtent: ?*SIZE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnTxCharFormatChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextHost,
                pCF: ?*const CHARFORMATW,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextHost,
                pCF: ?*const CHARFORMATW,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnTxParaFormatChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextHost,
                pPF: ?*const PARAFORMAT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextHost,
                pPF: ?*const PARAFORMAT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TxGetPropertyBits: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextHost,
                dwMask: u32,
                pdwBits: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextHost,
                dwMask: u32,
                pdwBits: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TxNotify: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextHost,
                iNotify: u32,
                pv: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextHost,
                iNotify: u32,
                pv: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TxImmGetContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextHost,
            ) callconv(@import("std").os.windows.WINAPI) ?HIMC,
            else => *const fn (
                self: *const ITextHost,
            ) callconv(@import("std").os.windows.WINAPI) ?HIMC,
        },
        TxImmReleaseContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextHost,
                himc: ?HIMC,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const ITextHost,
                himc: ?HIMC,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        TxGetSelectionBarWidth: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextHost,
                lSelBarWidth: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextHost,
                lSelBarWidth: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextHost_TxGetDC(self: *const T) ?HDC {
                return @as(*const ITextHost.VTable, @ptrCast(self.vtable)).TxGetDC(@as(*const ITextHost, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextHost_TxReleaseDC(self: *const T, hdc: ?HDC) i32 {
                return @as(*const ITextHost.VTable, @ptrCast(self.vtable)).TxReleaseDC(@as(*const ITextHost, @ptrCast(self)), hdc);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextHost_TxShowScrollBar(self: *const T, fnBar: i32, fShow: BOOL) BOOL {
                return @as(*const ITextHost.VTable, @ptrCast(self.vtable)).TxShowScrollBar(@as(*const ITextHost, @ptrCast(self)), fnBar, fShow);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextHost_TxEnableScrollBar(self: *const T, fuSBFlags: SCROLLBAR_CONSTANTS, fuArrowflags: ENABLE_SCROLL_BAR_ARROWS) BOOL {
                return @as(*const ITextHost.VTable, @ptrCast(self.vtable)).TxEnableScrollBar(@as(*const ITextHost, @ptrCast(self)), fuSBFlags, fuArrowflags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextHost_TxSetScrollRange(self: *const T, fnBar: i32, nMinPos: i32, nMaxPos: i32, fRedraw: BOOL) BOOL {
                return @as(*const ITextHost.VTable, @ptrCast(self.vtable)).TxSetScrollRange(@as(*const ITextHost, @ptrCast(self)), fnBar, nMinPos, nMaxPos, fRedraw);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextHost_TxSetScrollPos(self: *const T, fnBar: i32, nPos: i32, fRedraw: BOOL) BOOL {
                return @as(*const ITextHost.VTable, @ptrCast(self.vtable)).TxSetScrollPos(@as(*const ITextHost, @ptrCast(self)), fnBar, nPos, fRedraw);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextHost_TxInvalidateRect(self: *const T, prc: ?*RECT, fMode: BOOL) void {
                return @as(*const ITextHost.VTable, @ptrCast(self.vtable)).TxInvalidateRect(@as(*const ITextHost, @ptrCast(self)), prc, fMode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextHost_TxViewChange(self: *const T, fUpdate: BOOL) void {
                return @as(*const ITextHost.VTable, @ptrCast(self.vtable)).TxViewChange(@as(*const ITextHost, @ptrCast(self)), fUpdate);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextHost_TxCreateCaret(self: *const T, hbmp: ?HBITMAP, xWidth: i32, yHeight: i32) BOOL {
                return @as(*const ITextHost.VTable, @ptrCast(self.vtable)).TxCreateCaret(@as(*const ITextHost, @ptrCast(self)), hbmp, xWidth, yHeight);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextHost_TxShowCaret(self: *const T, fShow: BOOL) BOOL {
                return @as(*const ITextHost.VTable, @ptrCast(self.vtable)).TxShowCaret(@as(*const ITextHost, @ptrCast(self)), fShow);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextHost_TxSetCaretPos(self: *const T, x: i32, y: i32) BOOL {
                return @as(*const ITextHost.VTable, @ptrCast(self.vtable)).TxSetCaretPos(@as(*const ITextHost, @ptrCast(self)), x, y);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextHost_TxSetTimer(self: *const T, idTimer: u32, uTimeout: u32) BOOL {
                return @as(*const ITextHost.VTable, @ptrCast(self.vtable)).TxSetTimer(@as(*const ITextHost, @ptrCast(self)), idTimer, uTimeout);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextHost_TxKillTimer(self: *const T, idTimer: u32) void {
                return @as(*const ITextHost.VTable, @ptrCast(self.vtable)).TxKillTimer(@as(*const ITextHost, @ptrCast(self)), idTimer);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextHost_TxScrollWindowEx(self: *const T, dx: i32, dy: i32, lprcScroll: ?*RECT, lprcClip: ?*RECT, hrgnUpdate: ?HRGN, lprcUpdate: ?*RECT, fuScroll: SHOW_WINDOW_CMD) void {
                return @as(*const ITextHost.VTable, @ptrCast(self.vtable)).TxScrollWindowEx(@as(*const ITextHost, @ptrCast(self)), dx, dy, lprcScroll, lprcClip, hrgnUpdate, lprcUpdate, fuScroll);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextHost_TxSetCapture(self: *const T, fCapture: BOOL) void {
                return @as(*const ITextHost.VTable, @ptrCast(self.vtable)).TxSetCapture(@as(*const ITextHost, @ptrCast(self)), fCapture);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextHost_TxSetFocus(self: *const T) void {
                return @as(*const ITextHost.VTable, @ptrCast(self.vtable)).TxSetFocus(@as(*const ITextHost, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextHost_TxSetCursor(self: *const T, hcur: ?HCURSOR, fText: BOOL) void {
                return @as(*const ITextHost.VTable, @ptrCast(self.vtable)).TxSetCursor(@as(*const ITextHost, @ptrCast(self)), hcur, fText);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextHost_TxScreenToClient(self: *const T, lppt: ?*POINT) BOOL {
                return @as(*const ITextHost.VTable, @ptrCast(self.vtable)).TxScreenToClient(@as(*const ITextHost, @ptrCast(self)), lppt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextHost_TxClientToScreen(self: *const T, lppt: ?*POINT) BOOL {
                return @as(*const ITextHost.VTable, @ptrCast(self.vtable)).TxClientToScreen(@as(*const ITextHost, @ptrCast(self)), lppt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextHost_TxActivate(self: *const T, plOldState: ?*i32) HRESULT {
                return @as(*const ITextHost.VTable, @ptrCast(self.vtable)).TxActivate(@as(*const ITextHost, @ptrCast(self)), plOldState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextHost_TxDeactivate(self: *const T, lNewState: i32) HRESULT {
                return @as(*const ITextHost.VTable, @ptrCast(self.vtable)).TxDeactivate(@as(*const ITextHost, @ptrCast(self)), lNewState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextHost_TxGetClientRect(self: *const T, prc: ?*RECT) HRESULT {
                return @as(*const ITextHost.VTable, @ptrCast(self.vtable)).TxGetClientRect(@as(*const ITextHost, @ptrCast(self)), prc);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextHost_TxGetViewInset(self: *const T, prc: ?*RECT) HRESULT {
                return @as(*const ITextHost.VTable, @ptrCast(self.vtable)).TxGetViewInset(@as(*const ITextHost, @ptrCast(self)), prc);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextHost_TxGetCharFormat(self: *const T, ppCF: ?*const ?*CHARFORMATW) HRESULT {
                return @as(*const ITextHost.VTable, @ptrCast(self.vtable)).TxGetCharFormat(@as(*const ITextHost, @ptrCast(self)), ppCF);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextHost_TxGetParaFormat(self: *const T, ppPF: ?*const ?*PARAFORMAT) HRESULT {
                return @as(*const ITextHost.VTable, @ptrCast(self.vtable)).TxGetParaFormat(@as(*const ITextHost, @ptrCast(self)), ppPF);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextHost_TxGetSysColor(self: *const T, nIndex: i32) u32 {
                return @as(*const ITextHost.VTable, @ptrCast(self.vtable)).TxGetSysColor(@as(*const ITextHost, @ptrCast(self)), nIndex);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextHost_TxGetBackStyle(self: *const T, pstyle: ?*TXTBACKSTYLE) HRESULT {
                return @as(*const ITextHost.VTable, @ptrCast(self.vtable)).TxGetBackStyle(@as(*const ITextHost, @ptrCast(self)), pstyle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextHost_TxGetMaxLength(self: *const T, plength: ?*u32) HRESULT {
                return @as(*const ITextHost.VTable, @ptrCast(self.vtable)).TxGetMaxLength(@as(*const ITextHost, @ptrCast(self)), plength);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextHost_TxGetScrollBars(self: *const T, pdwScrollBar: ?*u32) HRESULT {
                return @as(*const ITextHost.VTable, @ptrCast(self.vtable)).TxGetScrollBars(@as(*const ITextHost, @ptrCast(self)), pdwScrollBar);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextHost_TxGetPasswordChar(self: *const T, pch: ?*i8) HRESULT {
                return @as(*const ITextHost.VTable, @ptrCast(self.vtable)).TxGetPasswordChar(@as(*const ITextHost, @ptrCast(self)), pch);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextHost_TxGetAcceleratorPos(self: *const T, pcp: ?*i32) HRESULT {
                return @as(*const ITextHost.VTable, @ptrCast(self.vtable)).TxGetAcceleratorPos(@as(*const ITextHost, @ptrCast(self)), pcp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextHost_TxGetExtent(self: *const T, lpExtent: ?*SIZE) HRESULT {
                return @as(*const ITextHost.VTable, @ptrCast(self.vtable)).TxGetExtent(@as(*const ITextHost, @ptrCast(self)), lpExtent);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextHost_OnTxCharFormatChange(self: *const T, pCF: ?*const CHARFORMATW) HRESULT {
                return @as(*const ITextHost.VTable, @ptrCast(self.vtable)).OnTxCharFormatChange(@as(*const ITextHost, @ptrCast(self)), pCF);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextHost_OnTxParaFormatChange(self: *const T, pPF: ?*const PARAFORMAT) HRESULT {
                return @as(*const ITextHost.VTable, @ptrCast(self.vtable)).OnTxParaFormatChange(@as(*const ITextHost, @ptrCast(self)), pPF);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextHost_TxGetPropertyBits(self: *const T, dwMask: u32, pdwBits: ?*u32) HRESULT {
                return @as(*const ITextHost.VTable, @ptrCast(self.vtable)).TxGetPropertyBits(@as(*const ITextHost, @ptrCast(self)), dwMask, pdwBits);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextHost_TxNotify(self: *const T, iNotify: u32, pv: ?*anyopaque) HRESULT {
                return @as(*const ITextHost.VTable, @ptrCast(self.vtable)).TxNotify(@as(*const ITextHost, @ptrCast(self)), iNotify, pv);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextHost_TxImmGetContext(self: *const T) ?HIMC {
                return @as(*const ITextHost.VTable, @ptrCast(self.vtable)).TxImmGetContext(@as(*const ITextHost, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextHost_TxImmReleaseContext(self: *const T, himc: ?HIMC) void {
                return @as(*const ITextHost.VTable, @ptrCast(self.vtable)).TxImmReleaseContext(@as(*const ITextHost, @ptrCast(self)), himc);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextHost_TxGetSelectionBarWidth(self: *const T, lSelBarWidth: ?*i32) HRESULT {
                return @as(*const ITextHost.VTable, @ptrCast(self.vtable)).TxGetSelectionBarWidth(@as(*const ITextHost, @ptrCast(self)), lSelBarWidth);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
pub const IRicheditUiaOverrides = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPropertyOverrideValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRicheditUiaOverrides,
                propertyId: i32,
                pRetValue: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRicheditUiaOverrides,
                propertyId: i32,
                pRetValue: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRicheditUiaOverrides_GetPropertyOverrideValue(self: *const T, propertyId: i32, pRetValue: ?*VARIANT) HRESULT {
                return @as(*const IRicheditUiaOverrides.VTable, @ptrCast(self.vtable)).GetPropertyOverrideValue(@as(*const IRicheditUiaOverrides, @ptrCast(self)), propertyId, pRetValue);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const PCreateTextServices = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        punkOuter: ?*IUnknown,
        pITextHost: ?*ITextHost,
        ppUnk: ?*?*IUnknown,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn (
        punkOuter: ?*IUnknown,
        pITextHost: ?*ITextHost,
        ppUnk: ?*?*IUnknown,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
};

pub const PShutdownTextServices = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        pTextServices: ?*IUnknown,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn (
        pTextServices: ?*IUnknown,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
};

pub const ITextHost2 = extern struct {
    pub const VTable = extern struct {
        base: ITextHost.VTable,
        TxIsDoubleClickPending: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextHost2,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
            else => *const fn (
                self: *const ITextHost2,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
        },
        TxGetWindow: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextHost2,
                phwnd: ?*?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextHost2,
                phwnd: ?*?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TxSetForegroundWindow: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextHost2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextHost2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TxGetPalette: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextHost2,
            ) callconv(@import("std").os.windows.WINAPI) ?HPALETTE,
            else => *const fn (
                self: *const ITextHost2,
            ) callconv(@import("std").os.windows.WINAPI) ?HPALETTE,
        },
        TxGetEastAsianFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextHost2,
                pFlags: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextHost2,
                pFlags: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TxSetCursor2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextHost2,
                hcur: ?HCURSOR,
                bText: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) ?HCURSOR,
            else => *const fn (
                self: *const ITextHost2,
                hcur: ?HCURSOR,
                bText: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) ?HCURSOR,
        },
        TxFreeTextServicesNotification: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextHost2,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const ITextHost2,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        TxGetEditStyle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextHost2,
                dwItem: u32,
                pdwData: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextHost2,
                dwItem: u32,
                pdwData: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TxGetWindowStyles: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextHost2,
                pdwStyle: ?*u32,
                pdwExStyle: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextHost2,
                pdwStyle: ?*u32,
                pdwExStyle: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TxShowDropCaret: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextHost2,
                fShow: BOOL,
                hdc: ?HDC,
                prc: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextHost2,
                fShow: BOOL,
                hdc: ?HDC,
                prc: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TxDestroyCaret: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextHost2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextHost2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TxGetHorzExtent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextHost2,
                plHorzExtent: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextHost2,
                plHorzExtent: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITextHost.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextHost2_TxIsDoubleClickPending(self: *const T) BOOL {
                return @as(*const ITextHost2.VTable, @ptrCast(self.vtable)).TxIsDoubleClickPending(@as(*const ITextHost2, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextHost2_TxGetWindow(self: *const T, phwnd: ?*?HWND) HRESULT {
                return @as(*const ITextHost2.VTable, @ptrCast(self.vtable)).TxGetWindow(@as(*const ITextHost2, @ptrCast(self)), phwnd);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextHost2_TxSetForegroundWindow(self: *const T) HRESULT {
                return @as(*const ITextHost2.VTable, @ptrCast(self.vtable)).TxSetForegroundWindow(@as(*const ITextHost2, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextHost2_TxGetPalette(self: *const T) ?HPALETTE {
                return @as(*const ITextHost2.VTable, @ptrCast(self.vtable)).TxGetPalette(@as(*const ITextHost2, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextHost2_TxGetEastAsianFlags(self: *const T, pFlags: ?*i32) HRESULT {
                return @as(*const ITextHost2.VTable, @ptrCast(self.vtable)).TxGetEastAsianFlags(@as(*const ITextHost2, @ptrCast(self)), pFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextHost2_TxSetCursor2(self: *const T, hcur: ?HCURSOR, bText: BOOL) ?HCURSOR {
                return @as(*const ITextHost2.VTable, @ptrCast(self.vtable)).TxSetCursor2(@as(*const ITextHost2, @ptrCast(self)), hcur, bText);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextHost2_TxFreeTextServicesNotification(self: *const T) void {
                return @as(*const ITextHost2.VTable, @ptrCast(self.vtable)).TxFreeTextServicesNotification(@as(*const ITextHost2, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextHost2_TxGetEditStyle(self: *const T, dwItem: u32, pdwData: ?*u32) HRESULT {
                return @as(*const ITextHost2.VTable, @ptrCast(self.vtable)).TxGetEditStyle(@as(*const ITextHost2, @ptrCast(self)), dwItem, pdwData);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextHost2_TxGetWindowStyles(self: *const T, pdwStyle: ?*u32, pdwExStyle: ?*u32) HRESULT {
                return @as(*const ITextHost2.VTable, @ptrCast(self.vtable)).TxGetWindowStyles(@as(*const ITextHost2, @ptrCast(self)), pdwStyle, pdwExStyle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextHost2_TxShowDropCaret(self: *const T, fShow: BOOL, hdc: ?HDC, prc: ?*RECT) HRESULT {
                return @as(*const ITextHost2.VTable, @ptrCast(self.vtable)).TxShowDropCaret(@as(*const ITextHost2, @ptrCast(self)), fShow, hdc, prc);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextHost2_TxDestroyCaret(self: *const T) HRESULT {
                return @as(*const ITextHost2.VTable, @ptrCast(self.vtable)).TxDestroyCaret(@as(*const ITextHost2, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextHost2_TxGetHorzExtent(self: *const T, plHorzExtent: ?*i32) HRESULT {
                return @as(*const ITextHost2.VTable, @ptrCast(self.vtable)).TxGetHorzExtent(@as(*const ITextHost2, @ptrCast(self)), plHorzExtent);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const ITextServices2 = extern struct {
    pub const VTable = extern struct {
        base: ITextServices.VTable,
        TxGetNaturalSize2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextServices2,
                dwAspect: u32,
                hdcDraw: ?HDC,
                hicTargetDev: ?HDC,
                ptd: ?*DVTARGETDEVICE,
                dwMode: u32,
                psizelExtent: ?*const SIZE,
                pwidth: ?*i32,
                pheight: ?*i32,
                pascent: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextServices2,
                dwAspect: u32,
                hdcDraw: ?HDC,
                hicTargetDev: ?HDC,
                ptd: ?*DVTARGETDEVICE,
                dwMode: u32,
                psizelExtent: ?*const SIZE,
                pwidth: ?*i32,
                pheight: ?*i32,
                pascent: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TxDrawD2D: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextServices2,
                pRenderTarget: ?*ID2D1RenderTarget,
                lprcBounds: ?*RECTL,
                lprcUpdate: ?*RECT,
                lViewId: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextServices2,
                pRenderTarget: ?*ID2D1RenderTarget,
                lprcBounds: ?*RECTL,
                lprcUpdate: ?*RECT,
                lViewId: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITextServices.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextServices2_TxGetNaturalSize2(self: *const T, dwAspect: u32, hdcDraw: ?HDC, hicTargetDev: ?HDC, ptd: ?*DVTARGETDEVICE, dwMode: u32, psizelExtent: ?*const SIZE, pwidth: ?*i32, pheight: ?*i32, pascent: ?*i32) HRESULT {
                return @as(*const ITextServices2.VTable, @ptrCast(self.vtable)).TxGetNaturalSize2(@as(*const ITextServices2, @ptrCast(self)), dwAspect, hdcDraw, hicTargetDev, ptd, dwMode, psizelExtent, pwidth, pheight, pascent);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextServices2_TxDrawD2D(self: *const T, pRenderTarget: ?*ID2D1RenderTarget, lprcBounds: ?*RECTL, lprcUpdate: ?*RECT, lViewId: i32) HRESULT {
                return @as(*const ITextServices2.VTable, @ptrCast(self.vtable)).TxDrawD2D(@as(*const ITextServices2, @ptrCast(self)), pRenderTarget, lprcBounds, lprcUpdate, lViewId);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const REOBJECT = extern struct {
    cbStruct: u32,
    cp: i32,
    clsid: Guid,
    poleobj: ?*IOleObject,
    pstg: ?*IStorage,
    polesite: ?*IOleClientSite,
    sizel: SIZE,
    dvaspect: u32,
    dwFlags: REOBJECT_FLAGS,
    dwUser: u32,
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IRichEditOle_Value = Guid.initString("00020d00-0000-0000-c000-000000000046");
pub const IID_IRichEditOle = &IID_IRichEditOle_Value;
pub const IRichEditOle = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetClientSite: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRichEditOle,
                lplpolesite: ?*?*IOleClientSite,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRichEditOle,
                lplpolesite: ?*?*IOleClientSite,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetObjectCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRichEditOle,
            ) callconv(@import("std").os.windows.WINAPI) i32,
            else => *const fn (
                self: *const IRichEditOle,
            ) callconv(@import("std").os.windows.WINAPI) i32,
        },
        GetLinkCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRichEditOle,
            ) callconv(@import("std").os.windows.WINAPI) i32,
            else => *const fn (
                self: *const IRichEditOle,
            ) callconv(@import("std").os.windows.WINAPI) i32,
        },
        GetObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRichEditOle,
                iob: i32,
                lpreobject: ?*REOBJECT,
                dwFlags: RICH_EDIT_GET_OBJECT_FLAGS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRichEditOle,
                iob: i32,
                lpreobject: ?*REOBJECT,
                dwFlags: RICH_EDIT_GET_OBJECT_FLAGS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InsertObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRichEditOle,
                lpreobject: ?*REOBJECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRichEditOle,
                lpreobject: ?*REOBJECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ConvertObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRichEditOle,
                iob: i32,
                rclsidNew: ?*const Guid,
                lpstrUserTypeNew: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRichEditOle,
                iob: i32,
                rclsidNew: ?*const Guid,
                lpstrUserTypeNew: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ActivateAs: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRichEditOle,
                rclsid: ?*const Guid,
                rclsidAs: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRichEditOle,
                rclsid: ?*const Guid,
                rclsidAs: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetHostNames: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRichEditOle,
                lpstrContainerApp: ?[*:0]const u8,
                lpstrContainerObj: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRichEditOle,
                lpstrContainerApp: ?[*:0]const u8,
                lpstrContainerObj: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetLinkAvailable: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRichEditOle,
                iob: i32,
                fAvailable: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRichEditOle,
                iob: i32,
                fAvailable: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDvaspect: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRichEditOle,
                iob: i32,
                dvaspect: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRichEditOle,
                iob: i32,
                dvaspect: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        HandsOffStorage: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRichEditOle,
                iob: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRichEditOle,
                iob: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SaveCompleted: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRichEditOle,
                iob: i32,
                lpstg: ?*IStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRichEditOle,
                iob: i32,
                lpstg: ?*IStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InPlaceDeactivate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRichEditOle,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRichEditOle,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ContextSensitiveHelp: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRichEditOle,
                fEnterMode: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRichEditOle,
                fEnterMode: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetClipboardData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRichEditOle,
                lpchrg: ?*CHARRANGE,
                reco: u32,
                lplpdataobj: ?*?*IDataObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRichEditOle,
                lpchrg: ?*CHARRANGE,
                reco: u32,
                lplpdataobj: ?*?*IDataObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ImportDataObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRichEditOle,
                lpdataobj: ?*IDataObject,
                cf: u16,
                hMetaPict: isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRichEditOle,
                lpdataobj: ?*IDataObject,
                cf: u16,
                hMetaPict: isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRichEditOle_GetClientSite(self: *const T, lplpolesite: ?*?*IOleClientSite) HRESULT {
                return @as(*const IRichEditOle.VTable, @ptrCast(self.vtable)).GetClientSite(@as(*const IRichEditOle, @ptrCast(self)), lplpolesite);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRichEditOle_GetObjectCount(self: *const T) i32 {
                return @as(*const IRichEditOle.VTable, @ptrCast(self.vtable)).GetObjectCount(@as(*const IRichEditOle, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRichEditOle_GetLinkCount(self: *const T) i32 {
                return @as(*const IRichEditOle.VTable, @ptrCast(self.vtable)).GetLinkCount(@as(*const IRichEditOle, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRichEditOle_GetObject(self: *const T, iob: i32, lpreobject: ?*REOBJECT, dwFlags: RICH_EDIT_GET_OBJECT_FLAGS) HRESULT {
                return @as(*const IRichEditOle.VTable, @ptrCast(self.vtable)).GetObject(@as(*const IRichEditOle, @ptrCast(self)), iob, lpreobject, dwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRichEditOle_InsertObject(self: *const T, lpreobject: ?*REOBJECT) HRESULT {
                return @as(*const IRichEditOle.VTable, @ptrCast(self.vtable)).InsertObject(@as(*const IRichEditOle, @ptrCast(self)), lpreobject);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRichEditOle_ConvertObject(self: *const T, iob: i32, rclsidNew: ?*const Guid, lpstrUserTypeNew: ?[*:0]const u8) HRESULT {
                return @as(*const IRichEditOle.VTable, @ptrCast(self.vtable)).ConvertObject(@as(*const IRichEditOle, @ptrCast(self)), iob, rclsidNew, lpstrUserTypeNew);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRichEditOle_ActivateAs(self: *const T, rclsid: ?*const Guid, rclsidAs: ?*const Guid) HRESULT {
                return @as(*const IRichEditOle.VTable, @ptrCast(self.vtable)).ActivateAs(@as(*const IRichEditOle, @ptrCast(self)), rclsid, rclsidAs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRichEditOle_SetHostNames(self: *const T, lpstrContainerApp: ?[*:0]const u8, lpstrContainerObj: ?[*:0]const u8) HRESULT {
                return @as(*const IRichEditOle.VTable, @ptrCast(self.vtable)).SetHostNames(@as(*const IRichEditOle, @ptrCast(self)), lpstrContainerApp, lpstrContainerObj);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRichEditOle_SetLinkAvailable(self: *const T, iob: i32, fAvailable: BOOL) HRESULT {
                return @as(*const IRichEditOle.VTable, @ptrCast(self.vtable)).SetLinkAvailable(@as(*const IRichEditOle, @ptrCast(self)), iob, fAvailable);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRichEditOle_SetDvaspect(self: *const T, iob: i32, dvaspect: u32) HRESULT {
                return @as(*const IRichEditOle.VTable, @ptrCast(self.vtable)).SetDvaspect(@as(*const IRichEditOle, @ptrCast(self)), iob, dvaspect);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRichEditOle_HandsOffStorage(self: *const T, iob: i32) HRESULT {
                return @as(*const IRichEditOle.VTable, @ptrCast(self.vtable)).HandsOffStorage(@as(*const IRichEditOle, @ptrCast(self)), iob);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRichEditOle_SaveCompleted(self: *const T, iob: i32, lpstg: ?*IStorage) HRESULT {
                return @as(*const IRichEditOle.VTable, @ptrCast(self.vtable)).SaveCompleted(@as(*const IRichEditOle, @ptrCast(self)), iob, lpstg);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRichEditOle_InPlaceDeactivate(self: *const T) HRESULT {
                return @as(*const IRichEditOle.VTable, @ptrCast(self.vtable)).InPlaceDeactivate(@as(*const IRichEditOle, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRichEditOle_ContextSensitiveHelp(self: *const T, fEnterMode: BOOL) HRESULT {
                return @as(*const IRichEditOle.VTable, @ptrCast(self.vtable)).ContextSensitiveHelp(@as(*const IRichEditOle, @ptrCast(self)), fEnterMode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRichEditOle_GetClipboardData(self: *const T, lpchrg: ?*CHARRANGE, reco: u32, lplpdataobj: ?*?*IDataObject) HRESULT {
                return @as(*const IRichEditOle.VTable, @ptrCast(self.vtable)).GetClipboardData(@as(*const IRichEditOle, @ptrCast(self)), lpchrg, reco, lplpdataobj);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRichEditOle_ImportDataObject(self: *const T, lpdataobj: ?*IDataObject, cf: u16, hMetaPict: isize) HRESULT {
                return @as(*const IRichEditOle.VTable, @ptrCast(self.vtable)).ImportDataObject(@as(*const IRichEditOle, @ptrCast(self)), lpdataobj, cf, hMetaPict);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IRichEditOleCallback_Value = Guid.initString("00020d03-0000-0000-c000-000000000046");
pub const IID_IRichEditOleCallback = &IID_IRichEditOleCallback_Value;
pub const IRichEditOleCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetNewStorage: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRichEditOleCallback,
                lplpstg: ?*?*IStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRichEditOleCallback,
                lplpstg: ?*?*IStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInPlaceContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRichEditOleCallback,
                lplpFrame: ?*?*IOleInPlaceFrame,
                lplpDoc: ?*?*IOleInPlaceUIWindow,
                lpFrameInfo: ?*OIFI,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRichEditOleCallback,
                lplpFrame: ?*?*IOleInPlaceFrame,
                lplpDoc: ?*?*IOleInPlaceUIWindow,
                lpFrameInfo: ?*OIFI,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ShowContainerUI: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRichEditOleCallback,
                fShow: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRichEditOleCallback,
                fShow: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryInsertObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRichEditOleCallback,
                lpclsid: ?*Guid,
                lpstg: ?*IStorage,
                cp: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRichEditOleCallback,
                lpclsid: ?*Guid,
                lpstg: ?*IStorage,
                cp: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeleteObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRichEditOleCallback,
                lpoleobj: ?*IOleObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRichEditOleCallback,
                lpoleobj: ?*IOleObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryAcceptData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRichEditOleCallback,
                lpdataobj: ?*IDataObject,
                lpcfFormat: ?*u16,
                reco: u32,
                fReally: BOOL,
                hMetaPict: isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRichEditOleCallback,
                lpdataobj: ?*IDataObject,
                lpcfFormat: ?*u16,
                reco: u32,
                fReally: BOOL,
                hMetaPict: isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ContextSensitiveHelp: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRichEditOleCallback,
                fEnterMode: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRichEditOleCallback,
                fEnterMode: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetClipboardData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRichEditOleCallback,
                lpchrg: ?*CHARRANGE,
                reco: u32,
                lplpdataobj: ?*?*IDataObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRichEditOleCallback,
                lpchrg: ?*CHARRANGE,
                reco: u32,
                lplpdataobj: ?*?*IDataObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDragDropEffect: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRichEditOleCallback,
                fDrag: BOOL,
                grfKeyState: u32,
                pdwEffect: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRichEditOleCallback,
                fDrag: BOOL,
                grfKeyState: u32,
                pdwEffect: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetContextMenu: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRichEditOleCallback,
                seltype: RICH_EDIT_GET_CONTEXT_MENU_SEL_TYPE,
                lpoleobj: ?*IOleObject,
                lpchrg: ?*CHARRANGE,
                lphmenu: ?*?HMENU,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRichEditOleCallback,
                seltype: RICH_EDIT_GET_CONTEXT_MENU_SEL_TYPE,
                lpoleobj: ?*IOleObject,
                lpchrg: ?*CHARRANGE,
                lphmenu: ?*?HMENU,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRichEditOleCallback_GetNewStorage(self: *const T, lplpstg: ?*?*IStorage) HRESULT {
                return @as(*const IRichEditOleCallback.VTable, @ptrCast(self.vtable)).GetNewStorage(@as(*const IRichEditOleCallback, @ptrCast(self)), lplpstg);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRichEditOleCallback_GetInPlaceContext(self: *const T, lplpFrame: ?*?*IOleInPlaceFrame, lplpDoc: ?*?*IOleInPlaceUIWindow, lpFrameInfo: ?*OIFI) HRESULT {
                return @as(*const IRichEditOleCallback.VTable, @ptrCast(self.vtable)).GetInPlaceContext(@as(*const IRichEditOleCallback, @ptrCast(self)), lplpFrame, lplpDoc, lpFrameInfo);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRichEditOleCallback_ShowContainerUI(self: *const T, fShow: BOOL) HRESULT {
                return @as(*const IRichEditOleCallback.VTable, @ptrCast(self.vtable)).ShowContainerUI(@as(*const IRichEditOleCallback, @ptrCast(self)), fShow);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRichEditOleCallback_QueryInsertObject(self: *const T, lpclsid: ?*Guid, lpstg: ?*IStorage, cp: i32) HRESULT {
                return @as(*const IRichEditOleCallback.VTable, @ptrCast(self.vtable)).QueryInsertObject(@as(*const IRichEditOleCallback, @ptrCast(self)), lpclsid, lpstg, cp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRichEditOleCallback_DeleteObject(self: *const T, lpoleobj: ?*IOleObject) HRESULT {
                return @as(*const IRichEditOleCallback.VTable, @ptrCast(self.vtable)).DeleteObject(@as(*const IRichEditOleCallback, @ptrCast(self)), lpoleobj);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRichEditOleCallback_QueryAcceptData(self: *const T, lpdataobj: ?*IDataObject, lpcfFormat: ?*u16, reco: u32, fReally: BOOL, hMetaPict: isize) HRESULT {
                return @as(*const IRichEditOleCallback.VTable, @ptrCast(self.vtable)).QueryAcceptData(@as(*const IRichEditOleCallback, @ptrCast(self)), lpdataobj, lpcfFormat, reco, fReally, hMetaPict);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRichEditOleCallback_ContextSensitiveHelp(self: *const T, fEnterMode: BOOL) HRESULT {
                return @as(*const IRichEditOleCallback.VTable, @ptrCast(self.vtable)).ContextSensitiveHelp(@as(*const IRichEditOleCallback, @ptrCast(self)), fEnterMode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRichEditOleCallback_GetClipboardData(self: *const T, lpchrg: ?*CHARRANGE, reco: u32, lplpdataobj: ?*?*IDataObject) HRESULT {
                return @as(*const IRichEditOleCallback.VTable, @ptrCast(self.vtable)).GetClipboardData(@as(*const IRichEditOleCallback, @ptrCast(self)), lpchrg, reco, lplpdataobj);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRichEditOleCallback_GetDragDropEffect(self: *const T, fDrag: BOOL, grfKeyState: u32, pdwEffect: ?*u32) HRESULT {
                return @as(*const IRichEditOleCallback.VTable, @ptrCast(self.vtable)).GetDragDropEffect(@as(*const IRichEditOleCallback, @ptrCast(self)), fDrag, grfKeyState, pdwEffect);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRichEditOleCallback_GetContextMenu(self: *const T, seltype: RICH_EDIT_GET_CONTEXT_MENU_SEL_TYPE, lpoleobj: ?*IOleObject, lpchrg: ?*CHARRANGE, lphmenu: ?*?HMENU) HRESULT {
                return @as(*const IRichEditOleCallback.VTable, @ptrCast(self.vtable)).GetContextMenu(@as(*const IRichEditOleCallback, @ptrCast(self)), seltype, lpoleobj, lpchrg, lphmenu);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const tomConstants = enum(i32) {
    False = 0,
    True = -1,
    Undefined = -9999999,
    Toggle = -9999998,
    AutoColor = -9999997,
    Default = -9999996,
    Suspend = -9999995,
    Resume = -9999994,
    // ApplyNow = 0, this enum value conflicts with False
    ApplyLater = 1,
    TrackParms = 2,
    CacheParms = 3,
    ApplyTmp = 4,
    DisableSmartFont = 8,
    EnableSmartFont = 9,
    UsePoints = 10,
    UseTwips = 11,
    Backward = -1073741823,
    Forward = 1073741823,
    // Move = 0, this enum value conflicts with False
    // Extend = 1, this enum value conflicts with ApplyLater
    // NoSelection = 0, this enum value conflicts with False
    // SelectionIP = 1, this enum value conflicts with ApplyLater
    // SelectionNormal = 2, this enum value conflicts with TrackParms
    // SelectionFrame = 3, this enum value conflicts with CacheParms
    // SelectionColumn = 4, this enum value conflicts with ApplyTmp
    SelectionRow = 5,
    SelectionBlock = 6,
    SelectionInlineShape = 7,
    // SelectionShape = 8, this enum value conflicts with DisableSmartFont
    // SelStartActive = 1, this enum value conflicts with ApplyLater
    // SelAtEOL = 2, this enum value conflicts with TrackParms
    // SelOvertype = 4, this enum value conflicts with ApplyTmp
    // SelActive = 8, this enum value conflicts with DisableSmartFont
    SelReplace = 16,
    // End = 0, this enum value conflicts with False
    Start = 32,
    // CollapseEnd = 0, this enum value conflicts with False
    // CollapseStart = 1, this enum value conflicts with ApplyLater
    ClientCoord = 256,
    AllowOffClient = 512,
    Transform = 1024,
    ObjectArg = 2048,
    AtEnd = 4096,
    // None = 0, this enum value conflicts with False
    // Single = 1, this enum value conflicts with ApplyLater
    // Words = 2, this enum value conflicts with TrackParms
    // Double = 3, this enum value conflicts with CacheParms
    // Dotted = 4, this enum value conflicts with ApplyTmp
    // Dash = 5, this enum value conflicts with SelectionRow
    // DashDot = 6, this enum value conflicts with SelectionBlock
    // DashDotDot = 7, this enum value conflicts with SelectionInlineShape
    // Wave = 8, this enum value conflicts with DisableSmartFont
    // Thick = 9, this enum value conflicts with EnableSmartFont
    // Hair = 10, this enum value conflicts with UsePoints
    // DoubleWave = 11, this enum value conflicts with UseTwips
    HeavyWave = 12,
    LongDash = 13,
    ThickDash = 14,
    ThickDashDot = 15,
    // ThickDashDotDot = 16, this enum value conflicts with SelReplace
    ThickDotted = 17,
    ThickLongDash = 18,
    // LineSpaceSingle = 0, this enum value conflicts with False
    // LineSpace1pt5 = 1, this enum value conflicts with ApplyLater
    // LineSpaceDouble = 2, this enum value conflicts with TrackParms
    // LineSpaceAtLeast = 3, this enum value conflicts with CacheParms
    // LineSpaceExactly = 4, this enum value conflicts with ApplyTmp
    // LineSpaceMultiple = 5, this enum value conflicts with SelectionRow
    // LineSpacePercent = 6, this enum value conflicts with SelectionBlock
    // AlignLeft = 0, this enum value conflicts with False
    // AlignCenter = 1, this enum value conflicts with ApplyLater
    // AlignRight = 2, this enum value conflicts with TrackParms
    // AlignJustify = 3, this enum value conflicts with CacheParms
    // AlignDecimal = 3, this enum value conflicts with CacheParms
    // AlignBar = 4, this enum value conflicts with ApplyTmp
    // DefaultTab = 5, this enum value conflicts with SelectionRow
    // AlignInterWord = 3, this enum value conflicts with CacheParms
    // AlignNewspaper = 4, this enum value conflicts with ApplyTmp
    // AlignInterLetter = 5, this enum value conflicts with SelectionRow
    // AlignScaled = 6, this enum value conflicts with SelectionBlock
    // Spaces = 0, this enum value conflicts with False
    // Dots = 1, this enum value conflicts with ApplyLater
    // Dashes = 2, this enum value conflicts with TrackParms
    // Lines = 3, this enum value conflicts with CacheParms
    // ThickLines = 4, this enum value conflicts with ApplyTmp
    // Equals = 5, this enum value conflicts with SelectionRow
    TabBack = -3,
    TabNext = -2,
    // TabHere = -1, this enum value conflicts with True
    // ListNone = 0, this enum value conflicts with False
    // ListBullet = 1, this enum value conflicts with ApplyLater
    // ListNumberAsArabic = 2, this enum value conflicts with TrackParms
    // ListNumberAsLCLetter = 3, this enum value conflicts with CacheParms
    // ListNumberAsUCLetter = 4, this enum value conflicts with ApplyTmp
    // ListNumberAsLCRoman = 5, this enum value conflicts with SelectionRow
    // ListNumberAsUCRoman = 6, this enum value conflicts with SelectionBlock
    // ListNumberAsSequence = 7, this enum value conflicts with SelectionInlineShape
    // ListNumberedCircle = 8, this enum value conflicts with DisableSmartFont
    // ListNumberedBlackCircleWingding = 9, this enum value conflicts with EnableSmartFont
    // ListNumberedWhiteCircleWingding = 10, this enum value conflicts with UsePoints
    // ListNumberedArabicWide = 11, this enum value conflicts with UseTwips
    // ListNumberedChS = 12, this enum value conflicts with HeavyWave
    // ListNumberedChT = 13, this enum value conflicts with LongDash
    // ListNumberedJpnChS = 14, this enum value conflicts with ThickDash
    // ListNumberedJpnKor = 15, this enum value conflicts with ThickDashDot
    // ListNumberedArabic1 = 16, this enum value conflicts with SelReplace
    // ListNumberedArabic2 = 17, this enum value conflicts with ThickDotted
    // ListNumberedHebrew = 18, this enum value conflicts with ThickLongDash
    ListNumberedThaiAlpha = 19,
    ListNumberedThaiNum = 20,
    ListNumberedHindiAlpha = 21,
    ListNumberedHindiAlpha1 = 22,
    ListNumberedHindiNum = 23,
    ListParentheses = 65536,
    ListPeriod = 131072,
    ListPlain = 196608,
    ListNoNumber = 262144,
    ListMinus = 524288,
    IgnoreNumberStyle = 16777216,
    // ParaStyleNormal = -1, this enum value conflicts with True
    // ParaStyleHeading1 = -2, this enum value conflicts with TabNext
    // ParaStyleHeading2 = -3, this enum value conflicts with TabBack
    ParaStyleHeading3 = -4,
    ParaStyleHeading4 = -5,
    ParaStyleHeading5 = -6,
    ParaStyleHeading6 = -7,
    ParaStyleHeading7 = -8,
    ParaStyleHeading8 = -9,
    ParaStyleHeading9 = -10,
    // Character = 1, this enum value conflicts with ApplyLater
    // Word = 2, this enum value conflicts with TrackParms
    // Sentence = 3, this enum value conflicts with CacheParms
    // Paragraph = 4, this enum value conflicts with ApplyTmp
    // Line = 5, this enum value conflicts with SelectionRow
    // Story = 6, this enum value conflicts with SelectionBlock
    // Screen = 7, this enum value conflicts with SelectionInlineShape
    // Section = 8, this enum value conflicts with DisableSmartFont
    // TableColumn = 9, this enum value conflicts with EnableSmartFont
    // Column = 9, this enum value conflicts with EnableSmartFont
    // Row = 10, this enum value conflicts with UsePoints
    // Window = 11, this enum value conflicts with UseTwips
    // Cell = 12, this enum value conflicts with HeavyWave
    // CharFormat = 13, this enum value conflicts with LongDash
    // ParaFormat = 14, this enum value conflicts with ThickDash
    // Table = 15, this enum value conflicts with ThickDashDot
    // Object = 16, this enum value conflicts with SelReplace
    // Page = 17, this enum value conflicts with ThickDotted
    // HardParagraph = 18, this enum value conflicts with ThickLongDash
    // Cluster = 19, this enum value conflicts with ListNumberedThaiAlpha
    // InlineObject = 20, this enum value conflicts with ListNumberedThaiNum
    // InlineObjectArg = 21, this enum value conflicts with ListNumberedHindiAlpha
    // LeafLine = 22, this enum value conflicts with ListNumberedHindiAlpha1
    // LayoutColumn = 23, this enum value conflicts with ListNumberedHindiNum
    ProcessId = 1073741825,
    // MatchWord = 2, this enum value conflicts with TrackParms
    // MatchCase = 4, this enum value conflicts with ApplyTmp
    // MatchPattern = 8, this enum value conflicts with DisableSmartFont
    // UnknownStory = 0, this enum value conflicts with False
    // MainTextStory = 1, this enum value conflicts with ApplyLater
    // FootnotesStory = 2, this enum value conflicts with TrackParms
    // EndnotesStory = 3, this enum value conflicts with CacheParms
    // CommentsStory = 4, this enum value conflicts with ApplyTmp
    // TextFrameStory = 5, this enum value conflicts with SelectionRow
    // EvenPagesHeaderStory = 6, this enum value conflicts with SelectionBlock
    // PrimaryHeaderStory = 7, this enum value conflicts with SelectionInlineShape
    // EvenPagesFooterStory = 8, this enum value conflicts with DisableSmartFont
    // PrimaryFooterStory = 9, this enum value conflicts with EnableSmartFont
    // FirstPageHeaderStory = 10, this enum value conflicts with UsePoints
    // FirstPageFooterStory = 11, this enum value conflicts with UseTwips
    ScratchStory = 127,
    FindStory = 128,
    ReplaceStory = 129,
    // StoryInactive = 0, this enum value conflicts with False
    // StoryActiveDisplay = 1, this enum value conflicts with ApplyLater
    // StoryActiveUI = 2, this enum value conflicts with TrackParms
    // StoryActiveDisplayUI = 3, this enum value conflicts with CacheParms
    // NoAnimation = 0, this enum value conflicts with False
    // LasVegasLights = 1, this enum value conflicts with ApplyLater
    // BlinkingBackground = 2, this enum value conflicts with TrackParms
    // SparkleText = 3, this enum value conflicts with CacheParms
    // MarchingBlackAnts = 4, this enum value conflicts with ApplyTmp
    // MarchingRedAnts = 5, this enum value conflicts with SelectionRow
    // Shimmer = 6, this enum value conflicts with SelectionBlock
    // WipeDown = 7, this enum value conflicts with SelectionInlineShape
    // WipeRight = 8, this enum value conflicts with DisableSmartFont
    // AnimationMax = 8, this enum value conflicts with DisableSmartFont
    // LowerCase = 0, this enum value conflicts with False
    // UpperCase = 1, this enum value conflicts with ApplyLater
    // TitleCase = 2, this enum value conflicts with TrackParms
    // SentenceCase = 4, this enum value conflicts with ApplyTmp
    // ToggleCase = 5, this enum value conflicts with SelectionRow
    // ReadOnly = 256, this enum value conflicts with ClientCoord
    // ShareDenyRead = 512, this enum value conflicts with AllowOffClient
    // ShareDenyWrite = 1024, this enum value conflicts with Transform
    // PasteFile = 4096, this enum value conflicts with AtEnd
    // CreateNew = 16, this enum value conflicts with SelReplace
    // CreateAlways = 32, this enum value conflicts with Start
    OpenExisting = 48,
    OpenAlways = 64,
    TruncateExisting = 80,
    // RTF = 1, this enum value conflicts with ApplyLater
    // Text = 2, this enum value conflicts with TrackParms
    // HTML = 3, this enum value conflicts with CacheParms
    // WordDocument = 4, this enum value conflicts with ApplyTmp
    Bold = -2147483647,
    Italic = -2147483646,
    Underline = -2147483644,
    Strikeout = -2147483640,
    Protected = -2147483632,
    Link = -2147483616,
    SmallCaps = -2147483584,
    AllCaps = -2147483520,
    Hidden = -2147483392,
    Outline = -2147483136,
    Shadow = -2147482624,
    Emboss = -2147481600,
    Imprint = -2147479552,
    Disabled = -2147475456,
    Revised = -2147467264,
    SubscriptCF = -2147418112,
    SuperscriptCF = -2147352576,
    FontBound = -2146435072,
    LinkProtected = -2139095040,
    InlineObjectStart = -2130706432,
    ExtendedChar = -2113929216,
    AutoBackColor = -2080374784,
    MathZoneNoBuildUp = -2013265920,
    MathZone = -1879048192,
    MathZoneOrdinary = -1610612736,
    AutoTextColor = -1073741824,
    // MathZoneDisplay = 262144, this enum value conflicts with ListNoNumber
    // ParaEffectRTL = 1, this enum value conflicts with ApplyLater
    // ParaEffectKeep = 2, this enum value conflicts with TrackParms
    // ParaEffectKeepNext = 4, this enum value conflicts with ApplyTmp
    // ParaEffectPageBreakBefore = 8, this enum value conflicts with DisableSmartFont
    // ParaEffectNoLineNumber = 16, this enum value conflicts with SelReplace
    // ParaEffectNoWidowControl = 32, this enum value conflicts with Start
    // ParaEffectDoNotHyphen = 64, this enum value conflicts with OpenAlways
    // ParaEffectSideBySide = 128, this enum value conflicts with FindStory
    // ParaEffectCollapsed = 256, this enum value conflicts with ClientCoord
    // ParaEffectOutlineLevel = 512, this enum value conflicts with AllowOffClient
    // ParaEffectBox = 1024, this enum value conflicts with Transform
    // ParaEffectTableRowDelimiter = 4096, this enum value conflicts with AtEnd
    ParaEffectTable = 16384,
    // ModWidthPairs = 1, this enum value conflicts with ApplyLater
    // ModWidthSpace = 2, this enum value conflicts with TrackParms
    // AutoSpaceAlpha = 4, this enum value conflicts with ApplyTmp
    // AutoSpaceNumeric = 8, this enum value conflicts with DisableSmartFont
    // AutoSpaceParens = 16, this enum value conflicts with SelReplace
    // EmbeddedFont = 32, this enum value conflicts with Start
    // Doublestrike = 64, this enum value conflicts with OpenAlways
    // Overlapping = 128, this enum value conflicts with FindStory
    // NormalCaret = 0, this enum value conflicts with False
    // KoreanBlockCaret = 1, this enum value conflicts with ApplyLater
    // NullCaret = 2, this enum value conflicts with TrackParms
    // IncludeInset = 1, this enum value conflicts with ApplyLater
    // UnicodeBiDi = 1, this enum value conflicts with ApplyLater
    // MathCFCheck = 4, this enum value conflicts with ApplyTmp
    // Unlink = 8, this enum value conflicts with DisableSmartFont
    // Unhide = 16, this enum value conflicts with SelReplace
    // CheckTextLimit = 32, this enum value conflicts with Start
    // IgnoreCurrentFont = 0, this enum value conflicts with False
    // MatchCharRep = 1, this enum value conflicts with ApplyLater
    // MatchFontSignature = 2, this enum value conflicts with TrackParms
    // MatchAscii = 4, this enum value conflicts with ApplyTmp
    // GetHeightOnly = 8, this enum value conflicts with DisableSmartFont
    // MatchMathFont = 16, this enum value conflicts with SelReplace
    Charset = -2147483648,
    CharRepFromLcid = 1073741824,
    // Ansi = 0, this enum value conflicts with False
    // EastEurope = 1, this enum value conflicts with ApplyLater
    // Cyrillic = 2, this enum value conflicts with TrackParms
    // Greek = 3, this enum value conflicts with CacheParms
    // Turkish = 4, this enum value conflicts with ApplyTmp
    // Hebrew = 5, this enum value conflicts with SelectionRow
    // Arabic = 6, this enum value conflicts with SelectionBlock
    // Baltic = 7, this enum value conflicts with SelectionInlineShape
    // Vietnamese = 8, this enum value conflicts with DisableSmartFont
    // DefaultCharRep = 9, this enum value conflicts with EnableSmartFont
    // Symbol = 10, this enum value conflicts with UsePoints
    // Thai = 11, this enum value conflicts with UseTwips
    // ShiftJIS = 12, this enum value conflicts with HeavyWave
    // GB2312 = 13, this enum value conflicts with LongDash
    // Hangul = 14, this enum value conflicts with ThickDash
    // BIG5 = 15, this enum value conflicts with ThickDashDot
    // PC437 = 16, this enum value conflicts with SelReplace
    // OEM = 17, this enum value conflicts with ThickDotted
    // Mac = 18, this enum value conflicts with ThickLongDash
    // Armenian = 19, this enum value conflicts with ListNumberedThaiAlpha
    // Syriac = 20, this enum value conflicts with ListNumberedThaiNum
    // Thaana = 21, this enum value conflicts with ListNumberedHindiAlpha
    // Devanagari = 22, this enum value conflicts with ListNumberedHindiAlpha1
    // Bengali = 23, this enum value conflicts with ListNumberedHindiNum
    Gurmukhi = 24,
    Gujarati = 25,
    Oriya = 26,
    Tamil = 27,
    Telugu = 28,
    Kannada = 29,
    Malayalam = 30,
    Sinhala = 31,
    // Lao = 32, this enum value conflicts with Start
    Tibetan = 33,
    Myanmar = 34,
    Georgian = 35,
    Jamo = 36,
    Ethiopic = 37,
    Cherokee = 38,
    Aboriginal = 39,
    Ogham = 40,
    Runic = 41,
    Khmer = 42,
    Mongolian = 43,
    Braille = 44,
    Yi = 45,
    Limbu = 46,
    TaiLe = 47,
    // NewTaiLue = 48, this enum value conflicts with OpenExisting
    SylotiNagri = 49,
    Kharoshthi = 50,
    Kayahli = 51,
    Usymbol = 52,
    Emoji = 53,
    Glagolitic = 54,
    Lisu = 55,
    Vai = 56,
    NKo = 57,
    Osmanya = 58,
    PhagsPa = 59,
    Gothic = 60,
    Deseret = 61,
    Tifinagh = 62,
    CharRepMax = 63,
    // RE10Mode = 1, this enum value conflicts with ApplyLater
    // UseAtFont = 2, this enum value conflicts with TrackParms
    // TextFlowMask = 12, this enum value conflicts with HeavyWave
    // TextFlowES = 0, this enum value conflicts with False
    // TextFlowSW = 4, this enum value conflicts with ApplyTmp
    // TextFlowWN = 8, this enum value conflicts with DisableSmartFont
    // TextFlowNE = 12, this enum value conflicts with HeavyWave
    // NoIME = 524288, this enum value conflicts with ListMinus
    // SelfIME = 262144, this enum value conflicts with ListNoNumber
    // NoUpScroll = 65536, this enum value conflicts with ListParentheses
    // NoVpScroll = 262144, this enum value conflicts with ListNoNumber
    // NoLink = 0, this enum value conflicts with False
    // ClientLink = 1, this enum value conflicts with ApplyLater
    // FriendlyLinkName = 2, this enum value conflicts with TrackParms
    // FriendlyLinkAddress = 3, this enum value conflicts with CacheParms
    // AutoLinkURL = 4, this enum value conflicts with ApplyTmp
    // AutoLinkEmail = 5, this enum value conflicts with SelectionRow
    // AutoLinkPhone = 6, this enum value conflicts with SelectionBlock
    // AutoLinkPath = 7, this enum value conflicts with SelectionInlineShape
    // CompressNone = 0, this enum value conflicts with False
    // CompressPunctuation = 1, this enum value conflicts with ApplyLater
    // CompressPunctuationAndKana = 2, this enum value conflicts with TrackParms
    // CompressMax = 2, this enum value conflicts with TrackParms
    // UnderlinePositionAuto = 0, this enum value conflicts with False
    // UnderlinePositionBelow = 1, this enum value conflicts with ApplyLater
    // UnderlinePositionAbove = 2, this enum value conflicts with TrackParms
    // UnderlinePositionMax = 2, this enum value conflicts with TrackParms
    // FontAlignmentAuto = 0, this enum value conflicts with False
    // FontAlignmentTop = 1, this enum value conflicts with ApplyLater
    // FontAlignmentBaseline = 2, this enum value conflicts with TrackParms
    // FontAlignmentBottom = 3, this enum value conflicts with CacheParms
    // FontAlignmentCenter = 4, this enum value conflicts with ApplyTmp
    // FontAlignmentMax = 4, this enum value conflicts with ApplyTmp
    // RubyBelow = 128, this enum value conflicts with FindStory
    // RubyAlignCenter = 0, this enum value conflicts with False
    // RubyAlign010 = 1, this enum value conflicts with ApplyLater
    // RubyAlign121 = 2, this enum value conflicts with TrackParms
    // RubyAlignLeft = 3, this enum value conflicts with CacheParms
    // RubyAlignRight = 4, this enum value conflicts with ApplyTmp
    // LimitsDefault = 0, this enum value conflicts with False
    // LimitsUnderOver = 1, this enum value conflicts with ApplyLater
    // LimitsSubSup = 2, this enum value conflicts with TrackParms
    // UpperLimitAsSuperScript = 3, this enum value conflicts with CacheParms
    // LimitsOpposite = 4, this enum value conflicts with ApplyTmp
    // ShowLLimPlaceHldr = 8, this enum value conflicts with DisableSmartFont
    // ShowULimPlaceHldr = 16, this enum value conflicts with SelReplace
    // DontGrowWithContent = 64, this enum value conflicts with OpenAlways
    // GrowWithContent = 128, this enum value conflicts with FindStory
    // SubSupAlign = 1, this enum value conflicts with ApplyLater
    // LimitAlignMask = 3, this enum value conflicts with CacheParms
    // LimitAlignCenter = 0, this enum value conflicts with False
    // LimitAlignLeft = 1, this enum value conflicts with ApplyLater
    // LimitAlignRight = 2, this enum value conflicts with TrackParms
    // ShowDegPlaceHldr = 8, this enum value conflicts with DisableSmartFont
    // AlignDefault = 0, this enum value conflicts with False
    // AlignMatchAscentDescent = 2, this enum value conflicts with TrackParms
    // MathVariant = 32, this enum value conflicts with Start
    // StyleDefault = 0, this enum value conflicts with False
    // StyleScriptScriptCramped = 1, this enum value conflicts with ApplyLater
    // StyleScriptScript = 2, this enum value conflicts with TrackParms
    // StyleScriptCramped = 3, this enum value conflicts with CacheParms
    // StyleScript = 4, this enum value conflicts with ApplyTmp
    // StyleTextCramped = 5, this enum value conflicts with SelectionRow
    // StyleText = 6, this enum value conflicts with SelectionBlock
    // StyleDisplayCramped = 7, this enum value conflicts with SelectionInlineShape
    // StyleDisplay = 8, this enum value conflicts with DisableSmartFont
    // MathRelSize = 64, this enum value conflicts with OpenAlways
    DecDecSize = 254,
    DecSize = 255,
    IncSize = 65,
    IncIncSize = 66,
    // GravityUI = 0, this enum value conflicts with False
    // GravityBack = 1, this enum value conflicts with ApplyLater
    // GravityFore = 2, this enum value conflicts with TrackParms
    // GravityIn = 3, this enum value conflicts with CacheParms
    // GravityOut = 4, this enum value conflicts with ApplyTmp
    GravityBackward = 536870912,
    // GravityForward = 1073741824, this enum value conflicts with CharRepFromLcid
    // AdjustCRLF = 1, this enum value conflicts with ApplyLater
    // UseCRLF = 2, this enum value conflicts with TrackParms
    // Textize = 4, this enum value conflicts with ApplyTmp
    // AllowFinalEOP = 8, this enum value conflicts with DisableSmartFont
    // FoldMathAlpha = 16, this enum value conflicts with SelReplace
    // NoHidden = 32, this enum value conflicts with Start
    // IncludeNumbering = 64, this enum value conflicts with OpenAlways
    // TranslateTableCell = 128, this enum value conflicts with FindStory
    // NoMathZoneBrackets = 256, this enum value conflicts with ClientCoord
    // ConvertMathChar = 512, this enum value conflicts with AllowOffClient
    // NoUCGreekItalic = 1024, this enum value conflicts with Transform
    // AllowMathBold = 2048, this enum value conflicts with ObjectArg
    // LanguageTag = 4096, this enum value conflicts with AtEnd
    ConvertRTF = 8192,
    // ApplyRtfDocProps = 16384, this enum value conflicts with ParaEffectTable
    // PhantomShow = 1, this enum value conflicts with ApplyLater
    // PhantomZeroWidth = 2, this enum value conflicts with TrackParms
    // PhantomZeroAscent = 4, this enum value conflicts with ApplyTmp
    // PhantomZeroDescent = 8, this enum value conflicts with DisableSmartFont
    // PhantomTransparent = 16, this enum value conflicts with SelReplace
    // PhantomASmash = 5, this enum value conflicts with SelectionRow
    // PhantomDSmash = 9, this enum value conflicts with EnableSmartFont
    // PhantomHSmash = 3, this enum value conflicts with CacheParms
    // PhantomSmash = 13, this enum value conflicts with LongDash
    // PhantomHorz = 12, this enum value conflicts with HeavyWave
    // PhantomVert = 2, this enum value conflicts with TrackParms
    // BoxHideTop = 1, this enum value conflicts with ApplyLater
    // BoxHideBottom = 2, this enum value conflicts with TrackParms
    // BoxHideLeft = 4, this enum value conflicts with ApplyTmp
    // BoxHideRight = 8, this enum value conflicts with DisableSmartFont
    // BoxStrikeH = 16, this enum value conflicts with SelReplace
    // BoxStrikeV = 32, this enum value conflicts with Start
    // BoxStrikeTLBR = 64, this enum value conflicts with OpenAlways
    // BoxStrikeBLTR = 128, this enum value conflicts with FindStory
    // BoxAlignCenter = 1, this enum value conflicts with ApplyLater
    // SpaceMask = 28, this enum value conflicts with Telugu
    // SpaceDefault = 0, this enum value conflicts with False
    // SpaceUnary = 4, this enum value conflicts with ApplyTmp
    // SpaceBinary = 8, this enum value conflicts with DisableSmartFont
    // SpaceRelational = 12, this enum value conflicts with HeavyWave
    // SpaceSkip = 16, this enum value conflicts with SelReplace
    // SpaceOrd = 20, this enum value conflicts with ListNumberedThaiNum
    // SpaceDifferential = 24, this enum value conflicts with Gurmukhi
    // SizeText = 32, this enum value conflicts with Start
    // SizeScript = 64, this enum value conflicts with OpenAlways
    SizeScriptScript = 96,
    // NoBreak = 128, this enum value conflicts with FindStory
    // TransparentForPositioning = 256, this enum value conflicts with ClientCoord
    // TransparentForSpacing = 512, this enum value conflicts with AllowOffClient
    // StretchCharBelow = 0, this enum value conflicts with False
    // StretchCharAbove = 1, this enum value conflicts with ApplyLater
    // StretchBaseBelow = 2, this enum value conflicts with TrackParms
    // StretchBaseAbove = 3, this enum value conflicts with CacheParms
    // MatrixAlignMask = 3, this enum value conflicts with CacheParms
    // MatrixAlignCenter = 0, this enum value conflicts with False
    // MatrixAlignTopRow = 1, this enum value conflicts with ApplyLater
    // MatrixAlignBottomRow = 3, this enum value conflicts with CacheParms
    // ShowMatPlaceHldr = 8, this enum value conflicts with DisableSmartFont
    // EqArrayLayoutWidth = 1, this enum value conflicts with ApplyLater
    // EqArrayAlignMask = 12, this enum value conflicts with HeavyWave
    // EqArrayAlignCenter = 0, this enum value conflicts with False
    // EqArrayAlignTopRow = 4, this enum value conflicts with ApplyTmp
    // EqArrayAlignBottomRow = 12, this enum value conflicts with HeavyWave
    // MathManualBreakMask = 127, this enum value conflicts with ScratchStory
    MathBreakLeft = 125,
    MathBreakCenter = 126,
    // MathBreakRight = 127, this enum value conflicts with ScratchStory
    // MathEqAlign = 128, this enum value conflicts with FindStory
    MathArgShadingStart = 593,
    MathArgShadingEnd = 594,
    MathObjShadingStart = 595,
    MathObjShadingEnd = 596,
    // FunctionTypeNone = 0, this enum value conflicts with False
    // FunctionTypeTakesArg = 1, this enum value conflicts with ApplyLater
    // FunctionTypeTakesLim = 2, this enum value conflicts with TrackParms
    // FunctionTypeTakesLim2 = 3, this enum value conflicts with CacheParms
    // FunctionTypeIsLim = 4, this enum value conflicts with ApplyTmp
    // MathParaAlignDefault = 0, this enum value conflicts with False
    // MathParaAlignCenterGroup = 1, this enum value conflicts with ApplyLater
    // MathParaAlignCenter = 2, this enum value conflicts with TrackParms
    // MathParaAlignLeft = 3, this enum value conflicts with CacheParms
    // MathParaAlignRight = 4, this enum value conflicts with ApplyTmp
    // MathDispAlignMask = 3, this enum value conflicts with CacheParms
    // MathDispAlignCenterGroup = 0, this enum value conflicts with False
    // MathDispAlignCenter = 1, this enum value conflicts with ApplyLater
    // MathDispAlignLeft = 2, this enum value conflicts with TrackParms
    // MathDispAlignRight = 3, this enum value conflicts with CacheParms
    // MathDispIntUnderOver = 4, this enum value conflicts with ApplyTmp
    // MathDispFracTeX = 8, this enum value conflicts with DisableSmartFont
    // MathDispNaryGrow = 16, this enum value conflicts with SelReplace
    // MathDocEmptyArgMask = 96, this enum value conflicts with SizeScriptScript
    // MathDocEmptyArgAuto = 0, this enum value conflicts with False
    // MathDocEmptyArgAlways = 32, this enum value conflicts with Start
    // MathDocEmptyArgNever = 64, this enum value conflicts with OpenAlways
    // MathDocSbSpOpUnchanged = 128, this enum value conflicts with FindStory
    MathDocDiffMask = 768,
    // MathDocDiffDefault = 0, this enum value conflicts with False
    // MathDocDiffUpright = 256, this enum value conflicts with ClientCoord
    // MathDocDiffItalic = 512, this enum value conflicts with AllowOffClient
    // MathDocDiffOpenItalic = 768, this enum value conflicts with MathDocDiffMask
    // MathDispNarySubSup = 1024, this enum value conflicts with Transform
    // MathDispDef = 2048, this enum value conflicts with ObjectArg
    // MathEnableRtl = 4096, this enum value conflicts with AtEnd
    // MathBrkBinMask = 196608, this enum value conflicts with ListPlain
    // MathBrkBinBefore = 0, this enum value conflicts with False
    // MathBrkBinAfter = 65536, this enum value conflicts with ListParentheses
    // MathBrkBinDup = 131072, this enum value conflicts with ListPeriod
    MathBrkBinSubMask = 786432,
    // MathBrkBinSubMM = 0, this enum value conflicts with False
    // MathBrkBinSubPM = 262144, this enum value conflicts with ListNoNumber
    // MathBrkBinSubMP = 524288, this enum value conflicts with ListMinus
    SelRange = 597,
    // Hstring = 596, this enum value conflicts with MathObjShadingEnd
    FontPropTeXStyle = 828,
    FontPropAlign = 829,
    FontStretch = 830,
    FontStyle = 831,
    // FontStyleUpright = 0, this enum value conflicts with False
    // FontStyleOblique = 1, this enum value conflicts with ApplyLater
    // FontStyleItalic = 2, this enum value conflicts with TrackParms
    // FontStretchDefault = 0, this enum value conflicts with False
    // FontStretchUltraCondensed = 1, this enum value conflicts with ApplyLater
    // FontStretchExtraCondensed = 2, this enum value conflicts with TrackParms
    // FontStretchCondensed = 3, this enum value conflicts with CacheParms
    // FontStretchSemiCondensed = 4, this enum value conflicts with ApplyTmp
    // FontStretchNormal = 5, this enum value conflicts with SelectionRow
    // FontStretchSemiExpanded = 6, this enum value conflicts with SelectionBlock
    // FontStretchExpanded = 7, this enum value conflicts with SelectionInlineShape
    // FontStretchExtraExpanded = 8, this enum value conflicts with DisableSmartFont
    // FontStretchUltraExpanded = 9, this enum value conflicts with EnableSmartFont
    // FontWeightDefault = 0, this enum value conflicts with False
    FontWeightThin = 100,
    FontWeightExtraLight = 200,
    FontWeightLight = 300,
    FontWeightNormal = 400,
    // FontWeightRegular = 400, this enum value conflicts with FontWeightNormal
    FontWeightMedium = 500,
    FontWeightSemiBold = 600,
    FontWeightBold = 700,
    FontWeightExtraBold = 800,
    FontWeightBlack = 900,
    // FontWeightHeavy = 900, this enum value conflicts with FontWeightBlack
    FontWeightExtraBlack = 950,
    ParaPropMathAlign = 1079,
    // DocMathBuild = 128, this enum value conflicts with FindStory
    // MathLMargin = 129, this enum value conflicts with ReplaceStory
    MathRMargin = 130,
    MathWrapIndent = 131,
    MathWrapRight = 132,
    MathPostSpace = 134,
    MathPreSpace = 133,
    MathInterSpace = 135,
    MathIntraSpace = 136,
    CanCopy = 137,
    CanRedo = 138,
    CanUndo = 139,
    UndoLimit = 140,
    DocAutoLink = 141,
    EllipsisMode = 142,
    EllipsisState = 143,
    // EllipsisNone = 0, this enum value conflicts with False
    // EllipsisEnd = 1, this enum value conflicts with ApplyLater
    // EllipsisWord = 3, this enum value conflicts with CacheParms
    // EllipsisPresent = 1, this enum value conflicts with ApplyLater
    // VTopCell = 1, this enum value conflicts with ApplyLater
    // VLowCell = 2, this enum value conflicts with TrackParms
    // HStartCell = 4, this enum value conflicts with ApplyTmp
    // HContCell = 8, this enum value conflicts with DisableSmartFont
    // RowUpdate = 1, this enum value conflicts with ApplyLater
    // RowApplyDefault = 0, this enum value conflicts with False
    // CellStructureChangeOnly = 1, this enum value conflicts with ApplyLater
    RowHeightActual = 2059,
};
pub const tomFalse = tomConstants.False;
pub const tomTrue = tomConstants.True;
pub const tomUndefined = tomConstants.Undefined;
pub const tomToggle = tomConstants.Toggle;
pub const tomAutoColor = tomConstants.AutoColor;
pub const tomDefault = tomConstants.Default;
pub const tomSuspend = tomConstants.Suspend;
pub const tomResume = tomConstants.Resume;
pub const tomApplyNow = tomConstants.False;
pub const tomApplyLater = tomConstants.ApplyLater;
pub const tomTrackParms = tomConstants.TrackParms;
pub const tomCacheParms = tomConstants.CacheParms;
pub const tomApplyTmp = tomConstants.ApplyTmp;
pub const tomDisableSmartFont = tomConstants.DisableSmartFont;
pub const tomEnableSmartFont = tomConstants.EnableSmartFont;
pub const tomUsePoints = tomConstants.UsePoints;
pub const tomUseTwips = tomConstants.UseTwips;
pub const tomBackward = tomConstants.Backward;
pub const tomForward = tomConstants.Forward;
pub const tomMove = tomConstants.False;
pub const tomExtend = tomConstants.ApplyLater;
pub const tomNoSelection = tomConstants.False;
pub const tomSelectionIP = tomConstants.ApplyLater;
pub const tomSelectionNormal = tomConstants.TrackParms;
pub const tomSelectionFrame = tomConstants.CacheParms;
pub const tomSelectionColumn = tomConstants.ApplyTmp;
pub const tomSelectionRow = tomConstants.SelectionRow;
pub const tomSelectionBlock = tomConstants.SelectionBlock;
pub const tomSelectionInlineShape = tomConstants.SelectionInlineShape;
pub const tomSelectionShape = tomConstants.DisableSmartFont;
pub const tomSelStartActive = tomConstants.ApplyLater;
pub const tomSelAtEOL = tomConstants.TrackParms;
pub const tomSelOvertype = tomConstants.ApplyTmp;
pub const tomSelActive = tomConstants.DisableSmartFont;
pub const tomSelReplace = tomConstants.SelReplace;
pub const tomEnd = tomConstants.False;
pub const tomStart = tomConstants.Start;
pub const tomCollapseEnd = tomConstants.False;
pub const tomCollapseStart = tomConstants.ApplyLater;
pub const tomClientCoord = tomConstants.ClientCoord;
pub const tomAllowOffClient = tomConstants.AllowOffClient;
pub const tomTransform = tomConstants.Transform;
pub const tomObjectArg = tomConstants.ObjectArg;
pub const tomAtEnd = tomConstants.AtEnd;
pub const tomNone = tomConstants.False;
pub const tomSingle = tomConstants.ApplyLater;
pub const tomWords = tomConstants.TrackParms;
pub const tomDouble = tomConstants.CacheParms;
pub const tomDotted = tomConstants.ApplyTmp;
pub const tomDash = tomConstants.SelectionRow;
pub const tomDashDot = tomConstants.SelectionBlock;
pub const tomDashDotDot = tomConstants.SelectionInlineShape;
pub const tomWave = tomConstants.DisableSmartFont;
pub const tomThick = tomConstants.EnableSmartFont;
pub const tomHair = tomConstants.UsePoints;
pub const tomDoubleWave = tomConstants.UseTwips;
pub const tomHeavyWave = tomConstants.HeavyWave;
pub const tomLongDash = tomConstants.LongDash;
pub const tomThickDash = tomConstants.ThickDash;
pub const tomThickDashDot = tomConstants.ThickDashDot;
pub const tomThickDashDotDot = tomConstants.SelReplace;
pub const tomThickDotted = tomConstants.ThickDotted;
pub const tomThickLongDash = tomConstants.ThickLongDash;
pub const tomLineSpaceSingle = tomConstants.False;
pub const tomLineSpace1pt5 = tomConstants.ApplyLater;
pub const tomLineSpaceDouble = tomConstants.TrackParms;
pub const tomLineSpaceAtLeast = tomConstants.CacheParms;
pub const tomLineSpaceExactly = tomConstants.ApplyTmp;
pub const tomLineSpaceMultiple = tomConstants.SelectionRow;
pub const tomLineSpacePercent = tomConstants.SelectionBlock;
pub const tomAlignLeft = tomConstants.False;
pub const tomAlignCenter = tomConstants.ApplyLater;
pub const tomAlignRight = tomConstants.TrackParms;
pub const tomAlignJustify = tomConstants.CacheParms;
pub const tomAlignDecimal = tomConstants.CacheParms;
pub const tomAlignBar = tomConstants.ApplyTmp;
pub const tomDefaultTab = tomConstants.SelectionRow;
pub const tomAlignInterWord = tomConstants.CacheParms;
pub const tomAlignNewspaper = tomConstants.ApplyTmp;
pub const tomAlignInterLetter = tomConstants.SelectionRow;
pub const tomAlignScaled = tomConstants.SelectionBlock;
pub const tomSpaces = tomConstants.False;
pub const tomDots = tomConstants.ApplyLater;
pub const tomDashes = tomConstants.TrackParms;
pub const tomLines = tomConstants.CacheParms;
pub const tomThickLines = tomConstants.ApplyTmp;
pub const tomEquals = tomConstants.SelectionRow;
pub const tomTabBack = tomConstants.TabBack;
pub const tomTabNext = tomConstants.TabNext;
pub const tomTabHere = tomConstants.True;
pub const tomListNone = tomConstants.False;
pub const tomListBullet = tomConstants.ApplyLater;
pub const tomListNumberAsArabic = tomConstants.TrackParms;
pub const tomListNumberAsLCLetter = tomConstants.CacheParms;
pub const tomListNumberAsUCLetter = tomConstants.ApplyTmp;
pub const tomListNumberAsLCRoman = tomConstants.SelectionRow;
pub const tomListNumberAsUCRoman = tomConstants.SelectionBlock;
pub const tomListNumberAsSequence = tomConstants.SelectionInlineShape;
pub const tomListNumberedCircle = tomConstants.DisableSmartFont;
pub const tomListNumberedBlackCircleWingding = tomConstants.EnableSmartFont;
pub const tomListNumberedWhiteCircleWingding = tomConstants.UsePoints;
pub const tomListNumberedArabicWide = tomConstants.UseTwips;
pub const tomListNumberedChS = tomConstants.HeavyWave;
pub const tomListNumberedChT = tomConstants.LongDash;
pub const tomListNumberedJpnChS = tomConstants.ThickDash;
pub const tomListNumberedJpnKor = tomConstants.ThickDashDot;
pub const tomListNumberedArabic1 = tomConstants.SelReplace;
pub const tomListNumberedArabic2 = tomConstants.ThickDotted;
pub const tomListNumberedHebrew = tomConstants.ThickLongDash;
pub const tomListNumberedThaiAlpha = tomConstants.ListNumberedThaiAlpha;
pub const tomListNumberedThaiNum = tomConstants.ListNumberedThaiNum;
pub const tomListNumberedHindiAlpha = tomConstants.ListNumberedHindiAlpha;
pub const tomListNumberedHindiAlpha1 = tomConstants.ListNumberedHindiAlpha1;
pub const tomListNumberedHindiNum = tomConstants.ListNumberedHindiNum;
pub const tomListParentheses = tomConstants.ListParentheses;
pub const tomListPeriod = tomConstants.ListPeriod;
pub const tomListPlain = tomConstants.ListPlain;
pub const tomListNoNumber = tomConstants.ListNoNumber;
pub const tomListMinus = tomConstants.ListMinus;
pub const tomIgnoreNumberStyle = tomConstants.IgnoreNumberStyle;
pub const tomParaStyleNormal = tomConstants.True;
pub const tomParaStyleHeading1 = tomConstants.TabNext;
pub const tomParaStyleHeading2 = tomConstants.TabBack;
pub const tomParaStyleHeading3 = tomConstants.ParaStyleHeading3;
pub const tomParaStyleHeading4 = tomConstants.ParaStyleHeading4;
pub const tomParaStyleHeading5 = tomConstants.ParaStyleHeading5;
pub const tomParaStyleHeading6 = tomConstants.ParaStyleHeading6;
pub const tomParaStyleHeading7 = tomConstants.ParaStyleHeading7;
pub const tomParaStyleHeading8 = tomConstants.ParaStyleHeading8;
pub const tomParaStyleHeading9 = tomConstants.ParaStyleHeading9;
pub const tomCharacter = tomConstants.ApplyLater;
pub const tomWord = tomConstants.TrackParms;
pub const tomSentence = tomConstants.CacheParms;
pub const tomParagraph = tomConstants.ApplyTmp;
pub const tomLine = tomConstants.SelectionRow;
pub const tomStory = tomConstants.SelectionBlock;
pub const tomScreen = tomConstants.SelectionInlineShape;
pub const tomSection = tomConstants.DisableSmartFont;
pub const tomTableColumn = tomConstants.EnableSmartFont;
pub const tomColumn = tomConstants.EnableSmartFont;
pub const tomRow = tomConstants.UsePoints;
pub const tomWindow = tomConstants.UseTwips;
pub const tomCell = tomConstants.HeavyWave;
pub const tomCharFormat = tomConstants.LongDash;
pub const tomParaFormat = tomConstants.ThickDash;
pub const tomTable = tomConstants.ThickDashDot;
pub const tomObject = tomConstants.SelReplace;
pub const tomPage = tomConstants.ThickDotted;
pub const tomHardParagraph = tomConstants.ThickLongDash;
pub const tomCluster = tomConstants.ListNumberedThaiAlpha;
pub const tomInlineObject = tomConstants.ListNumberedThaiNum;
pub const tomInlineObjectArg = tomConstants.ListNumberedHindiAlpha;
pub const tomLeafLine = tomConstants.ListNumberedHindiAlpha1;
pub const tomLayoutColumn = tomConstants.ListNumberedHindiNum;
pub const tomProcessId = tomConstants.ProcessId;
pub const tomMatchWord = tomConstants.TrackParms;
pub const tomMatchCase = tomConstants.ApplyTmp;
pub const tomMatchPattern = tomConstants.DisableSmartFont;
pub const tomUnknownStory = tomConstants.False;
pub const tomMainTextStory = tomConstants.ApplyLater;
pub const tomFootnotesStory = tomConstants.TrackParms;
pub const tomEndnotesStory = tomConstants.CacheParms;
pub const tomCommentsStory = tomConstants.ApplyTmp;
pub const tomTextFrameStory = tomConstants.SelectionRow;
pub const tomEvenPagesHeaderStory = tomConstants.SelectionBlock;
pub const tomPrimaryHeaderStory = tomConstants.SelectionInlineShape;
pub const tomEvenPagesFooterStory = tomConstants.DisableSmartFont;
pub const tomPrimaryFooterStory = tomConstants.EnableSmartFont;
pub const tomFirstPageHeaderStory = tomConstants.UsePoints;
pub const tomFirstPageFooterStory = tomConstants.UseTwips;
pub const tomScratchStory = tomConstants.ScratchStory;
pub const tomFindStory = tomConstants.FindStory;
pub const tomReplaceStory = tomConstants.ReplaceStory;
pub const tomStoryInactive = tomConstants.False;
pub const tomStoryActiveDisplay = tomConstants.ApplyLater;
pub const tomStoryActiveUI = tomConstants.TrackParms;
pub const tomStoryActiveDisplayUI = tomConstants.CacheParms;
pub const tomNoAnimation = tomConstants.False;
pub const tomLasVegasLights = tomConstants.ApplyLater;
pub const tomBlinkingBackground = tomConstants.TrackParms;
pub const tomSparkleText = tomConstants.CacheParms;
pub const tomMarchingBlackAnts = tomConstants.ApplyTmp;
pub const tomMarchingRedAnts = tomConstants.SelectionRow;
pub const tomShimmer = tomConstants.SelectionBlock;
pub const tomWipeDown = tomConstants.SelectionInlineShape;
pub const tomWipeRight = tomConstants.DisableSmartFont;
pub const tomAnimationMax = tomConstants.DisableSmartFont;
pub const tomLowerCase = tomConstants.False;
pub const tomUpperCase = tomConstants.ApplyLater;
pub const tomTitleCase = tomConstants.TrackParms;
pub const tomSentenceCase = tomConstants.ApplyTmp;
pub const tomToggleCase = tomConstants.SelectionRow;
pub const tomReadOnly = tomConstants.ClientCoord;
pub const tomShareDenyRead = tomConstants.AllowOffClient;
pub const tomShareDenyWrite = tomConstants.Transform;
pub const tomPasteFile = tomConstants.AtEnd;
pub const tomCreateNew = tomConstants.SelReplace;
pub const tomCreateAlways = tomConstants.Start;
pub const tomOpenExisting = tomConstants.OpenExisting;
pub const tomOpenAlways = tomConstants.OpenAlways;
pub const tomTruncateExisting = tomConstants.TruncateExisting;
pub const tomRTF = tomConstants.ApplyLater;
pub const tomText = tomConstants.TrackParms;
pub const tomHTML = tomConstants.CacheParms;
pub const tomWordDocument = tomConstants.ApplyTmp;
pub const tomBold = tomConstants.Bold;
pub const tomItalic = tomConstants.Italic;
pub const tomUnderline = tomConstants.Underline;
pub const tomStrikeout = tomConstants.Strikeout;
pub const tomProtected = tomConstants.Protected;
pub const tomLink = tomConstants.Link;
pub const tomSmallCaps = tomConstants.SmallCaps;
pub const tomAllCaps = tomConstants.AllCaps;
pub const tomHidden = tomConstants.Hidden;
pub const tomOutline = tomConstants.Outline;
pub const tomShadow = tomConstants.Shadow;
pub const tomEmboss = tomConstants.Emboss;
pub const tomImprint = tomConstants.Imprint;
pub const tomDisabled = tomConstants.Disabled;
pub const tomRevised = tomConstants.Revised;
pub const tomSubscriptCF = tomConstants.SubscriptCF;
pub const tomSuperscriptCF = tomConstants.SuperscriptCF;
pub const tomFontBound = tomConstants.FontBound;
pub const tomLinkProtected = tomConstants.LinkProtected;
pub const tomInlineObjectStart = tomConstants.InlineObjectStart;
pub const tomExtendedChar = tomConstants.ExtendedChar;
pub const tomAutoBackColor = tomConstants.AutoBackColor;
pub const tomMathZoneNoBuildUp = tomConstants.MathZoneNoBuildUp;
pub const tomMathZone = tomConstants.MathZone;
pub const tomMathZoneOrdinary = tomConstants.MathZoneOrdinary;
pub const tomAutoTextColor = tomConstants.AutoTextColor;
pub const tomMathZoneDisplay = tomConstants.ListNoNumber;
pub const tomParaEffectRTL = tomConstants.ApplyLater;
pub const tomParaEffectKeep = tomConstants.TrackParms;
pub const tomParaEffectKeepNext = tomConstants.ApplyTmp;
pub const tomParaEffectPageBreakBefore = tomConstants.DisableSmartFont;
pub const tomParaEffectNoLineNumber = tomConstants.SelReplace;
pub const tomParaEffectNoWidowControl = tomConstants.Start;
pub const tomParaEffectDoNotHyphen = tomConstants.OpenAlways;
pub const tomParaEffectSideBySide = tomConstants.FindStory;
pub const tomParaEffectCollapsed = tomConstants.ClientCoord;
pub const tomParaEffectOutlineLevel = tomConstants.AllowOffClient;
pub const tomParaEffectBox = tomConstants.Transform;
pub const tomParaEffectTableRowDelimiter = tomConstants.AtEnd;
pub const tomParaEffectTable = tomConstants.ParaEffectTable;
pub const tomModWidthPairs = tomConstants.ApplyLater;
pub const tomModWidthSpace = tomConstants.TrackParms;
pub const tomAutoSpaceAlpha = tomConstants.ApplyTmp;
pub const tomAutoSpaceNumeric = tomConstants.DisableSmartFont;
pub const tomAutoSpaceParens = tomConstants.SelReplace;
pub const tomEmbeddedFont = tomConstants.Start;
pub const tomDoublestrike = tomConstants.OpenAlways;
pub const tomOverlapping = tomConstants.FindStory;
pub const tomNormalCaret = tomConstants.False;
pub const tomKoreanBlockCaret = tomConstants.ApplyLater;
pub const tomNullCaret = tomConstants.TrackParms;
pub const tomIncludeInset = tomConstants.ApplyLater;
pub const tomUnicodeBiDi = tomConstants.ApplyLater;
pub const tomMathCFCheck = tomConstants.ApplyTmp;
pub const tomUnlink = tomConstants.DisableSmartFont;
pub const tomUnhide = tomConstants.SelReplace;
pub const tomCheckTextLimit = tomConstants.Start;
pub const tomIgnoreCurrentFont = tomConstants.False;
pub const tomMatchCharRep = tomConstants.ApplyLater;
pub const tomMatchFontSignature = tomConstants.TrackParms;
pub const tomMatchAscii = tomConstants.ApplyTmp;
pub const tomGetHeightOnly = tomConstants.DisableSmartFont;
pub const tomMatchMathFont = tomConstants.SelReplace;
pub const tomCharset = tomConstants.Charset;
pub const tomCharRepFromLcid = tomConstants.CharRepFromLcid;
pub const tomAnsi = tomConstants.False;
pub const tomEastEurope = tomConstants.ApplyLater;
pub const tomCyrillic = tomConstants.TrackParms;
pub const tomGreek = tomConstants.CacheParms;
pub const tomTurkish = tomConstants.ApplyTmp;
pub const tomHebrew = tomConstants.SelectionRow;
pub const tomArabic = tomConstants.SelectionBlock;
pub const tomBaltic = tomConstants.SelectionInlineShape;
pub const tomVietnamese = tomConstants.DisableSmartFont;
pub const tomDefaultCharRep = tomConstants.EnableSmartFont;
pub const tomSymbol = tomConstants.UsePoints;
pub const tomThai = tomConstants.UseTwips;
pub const tomShiftJIS = tomConstants.HeavyWave;
pub const tomGB2312 = tomConstants.LongDash;
pub const tomHangul = tomConstants.ThickDash;
pub const tomBIG5 = tomConstants.ThickDashDot;
pub const tomPC437 = tomConstants.SelReplace;
pub const tomOEM = tomConstants.ThickDotted;
pub const tomMac = tomConstants.ThickLongDash;
pub const tomArmenian = tomConstants.ListNumberedThaiAlpha;
pub const tomSyriac = tomConstants.ListNumberedThaiNum;
pub const tomThaana = tomConstants.ListNumberedHindiAlpha;
pub const tomDevanagari = tomConstants.ListNumberedHindiAlpha1;
pub const tomBengali = tomConstants.ListNumberedHindiNum;
pub const tomGurmukhi = tomConstants.Gurmukhi;
pub const tomGujarati = tomConstants.Gujarati;
pub const tomOriya = tomConstants.Oriya;
pub const tomTamil = tomConstants.Tamil;
pub const tomTelugu = tomConstants.Telugu;
pub const tomKannada = tomConstants.Kannada;
pub const tomMalayalam = tomConstants.Malayalam;
pub const tomSinhala = tomConstants.Sinhala;
pub const tomLao = tomConstants.Start;
pub const tomTibetan = tomConstants.Tibetan;
pub const tomMyanmar = tomConstants.Myanmar;
pub const tomGeorgian = tomConstants.Georgian;
pub const tomJamo = tomConstants.Jamo;
pub const tomEthiopic = tomConstants.Ethiopic;
pub const tomCherokee = tomConstants.Cherokee;
pub const tomAboriginal = tomConstants.Aboriginal;
pub const tomOgham = tomConstants.Ogham;
pub const tomRunic = tomConstants.Runic;
pub const tomKhmer = tomConstants.Khmer;
pub const tomMongolian = tomConstants.Mongolian;
pub const tomBraille = tomConstants.Braille;
pub const tomYi = tomConstants.Yi;
pub const tomLimbu = tomConstants.Limbu;
pub const tomTaiLe = tomConstants.TaiLe;
pub const tomNewTaiLue = tomConstants.OpenExisting;
pub const tomSylotiNagri = tomConstants.SylotiNagri;
pub const tomKharoshthi = tomConstants.Kharoshthi;
pub const tomKayahli = tomConstants.Kayahli;
pub const tomUsymbol = tomConstants.Usymbol;
pub const tomEmoji = tomConstants.Emoji;
pub const tomGlagolitic = tomConstants.Glagolitic;
pub const tomLisu = tomConstants.Lisu;
pub const tomVai = tomConstants.Vai;
pub const tomNKo = tomConstants.NKo;
pub const tomOsmanya = tomConstants.Osmanya;
pub const tomPhagsPa = tomConstants.PhagsPa;
pub const tomGothic = tomConstants.Gothic;
pub const tomDeseret = tomConstants.Deseret;
pub const tomTifinagh = tomConstants.Tifinagh;
pub const tomCharRepMax = tomConstants.CharRepMax;
pub const tomRE10Mode = tomConstants.ApplyLater;
pub const tomUseAtFont = tomConstants.TrackParms;
pub const tomTextFlowMask = tomConstants.HeavyWave;
pub const tomTextFlowES = tomConstants.False;
pub const tomTextFlowSW = tomConstants.ApplyTmp;
pub const tomTextFlowWN = tomConstants.DisableSmartFont;
pub const tomTextFlowNE = tomConstants.HeavyWave;
pub const tomNoIME = tomConstants.ListMinus;
pub const tomSelfIME = tomConstants.ListNoNumber;
pub const tomNoUpScroll = tomConstants.ListParentheses;
pub const tomNoVpScroll = tomConstants.ListNoNumber;
pub const tomNoLink = tomConstants.False;
pub const tomClientLink = tomConstants.ApplyLater;
pub const tomFriendlyLinkName = tomConstants.TrackParms;
pub const tomFriendlyLinkAddress = tomConstants.CacheParms;
pub const tomAutoLinkURL = tomConstants.ApplyTmp;
pub const tomAutoLinkEmail = tomConstants.SelectionRow;
pub const tomAutoLinkPhone = tomConstants.SelectionBlock;
pub const tomAutoLinkPath = tomConstants.SelectionInlineShape;
pub const tomCompressNone = tomConstants.False;
pub const tomCompressPunctuation = tomConstants.ApplyLater;
pub const tomCompressPunctuationAndKana = tomConstants.TrackParms;
pub const tomCompressMax = tomConstants.TrackParms;
pub const tomUnderlinePositionAuto = tomConstants.False;
pub const tomUnderlinePositionBelow = tomConstants.ApplyLater;
pub const tomUnderlinePositionAbove = tomConstants.TrackParms;
pub const tomUnderlinePositionMax = tomConstants.TrackParms;
pub const tomFontAlignmentAuto = tomConstants.False;
pub const tomFontAlignmentTop = tomConstants.ApplyLater;
pub const tomFontAlignmentBaseline = tomConstants.TrackParms;
pub const tomFontAlignmentBottom = tomConstants.CacheParms;
pub const tomFontAlignmentCenter = tomConstants.ApplyTmp;
pub const tomFontAlignmentMax = tomConstants.ApplyTmp;
pub const tomRubyBelow = tomConstants.FindStory;
pub const tomRubyAlignCenter = tomConstants.False;
pub const tomRubyAlign010 = tomConstants.ApplyLater;
pub const tomRubyAlign121 = tomConstants.TrackParms;
pub const tomRubyAlignLeft = tomConstants.CacheParms;
pub const tomRubyAlignRight = tomConstants.ApplyTmp;
pub const tomLimitsDefault = tomConstants.False;
pub const tomLimitsUnderOver = tomConstants.ApplyLater;
pub const tomLimitsSubSup = tomConstants.TrackParms;
pub const tomUpperLimitAsSuperScript = tomConstants.CacheParms;
pub const tomLimitsOpposite = tomConstants.ApplyTmp;
pub const tomShowLLimPlaceHldr = tomConstants.DisableSmartFont;
pub const tomShowULimPlaceHldr = tomConstants.SelReplace;
pub const tomDontGrowWithContent = tomConstants.OpenAlways;
pub const tomGrowWithContent = tomConstants.FindStory;
pub const tomSubSupAlign = tomConstants.ApplyLater;
pub const tomLimitAlignMask = tomConstants.CacheParms;
pub const tomLimitAlignCenter = tomConstants.False;
pub const tomLimitAlignLeft = tomConstants.ApplyLater;
pub const tomLimitAlignRight = tomConstants.TrackParms;
pub const tomShowDegPlaceHldr = tomConstants.DisableSmartFont;
pub const tomAlignDefault = tomConstants.False;
pub const tomAlignMatchAscentDescent = tomConstants.TrackParms;
pub const tomMathVariant = tomConstants.Start;
pub const tomStyleDefault = tomConstants.False;
pub const tomStyleScriptScriptCramped = tomConstants.ApplyLater;
pub const tomStyleScriptScript = tomConstants.TrackParms;
pub const tomStyleScriptCramped = tomConstants.CacheParms;
pub const tomStyleScript = tomConstants.ApplyTmp;
pub const tomStyleTextCramped = tomConstants.SelectionRow;
pub const tomStyleText = tomConstants.SelectionBlock;
pub const tomStyleDisplayCramped = tomConstants.SelectionInlineShape;
pub const tomStyleDisplay = tomConstants.DisableSmartFont;
pub const tomMathRelSize = tomConstants.OpenAlways;
pub const tomDecDecSize = tomConstants.DecDecSize;
pub const tomDecSize = tomConstants.DecSize;
pub const tomIncSize = tomConstants.IncSize;
pub const tomIncIncSize = tomConstants.IncIncSize;
pub const tomGravityUI = tomConstants.False;
pub const tomGravityBack = tomConstants.ApplyLater;
pub const tomGravityFore = tomConstants.TrackParms;
pub const tomGravityIn = tomConstants.CacheParms;
pub const tomGravityOut = tomConstants.ApplyTmp;
pub const tomGravityBackward = tomConstants.GravityBackward;
pub const tomGravityForward = tomConstants.CharRepFromLcid;
pub const tomAdjustCRLF = tomConstants.ApplyLater;
pub const tomUseCRLF = tomConstants.TrackParms;
pub const tomTextize = tomConstants.ApplyTmp;
pub const tomAllowFinalEOP = tomConstants.DisableSmartFont;
pub const tomFoldMathAlpha = tomConstants.SelReplace;
pub const tomNoHidden = tomConstants.Start;
pub const tomIncludeNumbering = tomConstants.OpenAlways;
pub const tomTranslateTableCell = tomConstants.FindStory;
pub const tomNoMathZoneBrackets = tomConstants.ClientCoord;
pub const tomConvertMathChar = tomConstants.AllowOffClient;
pub const tomNoUCGreekItalic = tomConstants.Transform;
pub const tomAllowMathBold = tomConstants.ObjectArg;
pub const tomLanguageTag = tomConstants.AtEnd;
pub const tomConvertRTF = tomConstants.ConvertRTF;
pub const tomApplyRtfDocProps = tomConstants.ParaEffectTable;
pub const tomPhantomShow = tomConstants.ApplyLater;
pub const tomPhantomZeroWidth = tomConstants.TrackParms;
pub const tomPhantomZeroAscent = tomConstants.ApplyTmp;
pub const tomPhantomZeroDescent = tomConstants.DisableSmartFont;
pub const tomPhantomTransparent = tomConstants.SelReplace;
pub const tomPhantomASmash = tomConstants.SelectionRow;
pub const tomPhantomDSmash = tomConstants.EnableSmartFont;
pub const tomPhantomHSmash = tomConstants.CacheParms;
pub const tomPhantomSmash = tomConstants.LongDash;
pub const tomPhantomHorz = tomConstants.HeavyWave;
pub const tomPhantomVert = tomConstants.TrackParms;
pub const tomBoxHideTop = tomConstants.ApplyLater;
pub const tomBoxHideBottom = tomConstants.TrackParms;
pub const tomBoxHideLeft = tomConstants.ApplyTmp;
pub const tomBoxHideRight = tomConstants.DisableSmartFont;
pub const tomBoxStrikeH = tomConstants.SelReplace;
pub const tomBoxStrikeV = tomConstants.Start;
pub const tomBoxStrikeTLBR = tomConstants.OpenAlways;
pub const tomBoxStrikeBLTR = tomConstants.FindStory;
pub const tomBoxAlignCenter = tomConstants.ApplyLater;
pub const tomSpaceMask = tomConstants.Telugu;
pub const tomSpaceDefault = tomConstants.False;
pub const tomSpaceUnary = tomConstants.ApplyTmp;
pub const tomSpaceBinary = tomConstants.DisableSmartFont;
pub const tomSpaceRelational = tomConstants.HeavyWave;
pub const tomSpaceSkip = tomConstants.SelReplace;
pub const tomSpaceOrd = tomConstants.ListNumberedThaiNum;
pub const tomSpaceDifferential = tomConstants.Gurmukhi;
pub const tomSizeText = tomConstants.Start;
pub const tomSizeScript = tomConstants.OpenAlways;
pub const tomSizeScriptScript = tomConstants.SizeScriptScript;
pub const tomNoBreak = tomConstants.FindStory;
pub const tomTransparentForPositioning = tomConstants.ClientCoord;
pub const tomTransparentForSpacing = tomConstants.AllowOffClient;
pub const tomStretchCharBelow = tomConstants.False;
pub const tomStretchCharAbove = tomConstants.ApplyLater;
pub const tomStretchBaseBelow = tomConstants.TrackParms;
pub const tomStretchBaseAbove = tomConstants.CacheParms;
pub const tomMatrixAlignMask = tomConstants.CacheParms;
pub const tomMatrixAlignCenter = tomConstants.False;
pub const tomMatrixAlignTopRow = tomConstants.ApplyLater;
pub const tomMatrixAlignBottomRow = tomConstants.CacheParms;
pub const tomShowMatPlaceHldr = tomConstants.DisableSmartFont;
pub const tomEqArrayLayoutWidth = tomConstants.ApplyLater;
pub const tomEqArrayAlignMask = tomConstants.HeavyWave;
pub const tomEqArrayAlignCenter = tomConstants.False;
pub const tomEqArrayAlignTopRow = tomConstants.ApplyTmp;
pub const tomEqArrayAlignBottomRow = tomConstants.HeavyWave;
pub const tomMathManualBreakMask = tomConstants.ScratchStory;
pub const tomMathBreakLeft = tomConstants.MathBreakLeft;
pub const tomMathBreakCenter = tomConstants.MathBreakCenter;
pub const tomMathBreakRight = tomConstants.ScratchStory;
pub const tomMathEqAlign = tomConstants.FindStory;
pub const tomMathArgShadingStart = tomConstants.MathArgShadingStart;
pub const tomMathArgShadingEnd = tomConstants.MathArgShadingEnd;
pub const tomMathObjShadingStart = tomConstants.MathObjShadingStart;
pub const tomMathObjShadingEnd = tomConstants.MathObjShadingEnd;
pub const tomFunctionTypeNone = tomConstants.False;
pub const tomFunctionTypeTakesArg = tomConstants.ApplyLater;
pub const tomFunctionTypeTakesLim = tomConstants.TrackParms;
pub const tomFunctionTypeTakesLim2 = tomConstants.CacheParms;
pub const tomFunctionTypeIsLim = tomConstants.ApplyTmp;
pub const tomMathParaAlignDefault = tomConstants.False;
pub const tomMathParaAlignCenterGroup = tomConstants.ApplyLater;
pub const tomMathParaAlignCenter = tomConstants.TrackParms;
pub const tomMathParaAlignLeft = tomConstants.CacheParms;
pub const tomMathParaAlignRight = tomConstants.ApplyTmp;
pub const tomMathDispAlignMask = tomConstants.CacheParms;
pub const tomMathDispAlignCenterGroup = tomConstants.False;
pub const tomMathDispAlignCenter = tomConstants.ApplyLater;
pub const tomMathDispAlignLeft = tomConstants.TrackParms;
pub const tomMathDispAlignRight = tomConstants.CacheParms;
pub const tomMathDispIntUnderOver = tomConstants.ApplyTmp;
pub const tomMathDispFracTeX = tomConstants.DisableSmartFont;
pub const tomMathDispNaryGrow = tomConstants.SelReplace;
pub const tomMathDocEmptyArgMask = tomConstants.SizeScriptScript;
pub const tomMathDocEmptyArgAuto = tomConstants.False;
pub const tomMathDocEmptyArgAlways = tomConstants.Start;
pub const tomMathDocEmptyArgNever = tomConstants.OpenAlways;
pub const tomMathDocSbSpOpUnchanged = tomConstants.FindStory;
pub const tomMathDocDiffMask = tomConstants.MathDocDiffMask;
pub const tomMathDocDiffDefault = tomConstants.False;
pub const tomMathDocDiffUpright = tomConstants.ClientCoord;
pub const tomMathDocDiffItalic = tomConstants.AllowOffClient;
pub const tomMathDocDiffOpenItalic = tomConstants.MathDocDiffMask;
pub const tomMathDispNarySubSup = tomConstants.Transform;
pub const tomMathDispDef = tomConstants.ObjectArg;
pub const tomMathEnableRtl = tomConstants.AtEnd;
pub const tomMathBrkBinMask = tomConstants.ListPlain;
pub const tomMathBrkBinBefore = tomConstants.False;
pub const tomMathBrkBinAfter = tomConstants.ListParentheses;
pub const tomMathBrkBinDup = tomConstants.ListPeriod;
pub const tomMathBrkBinSubMask = tomConstants.MathBrkBinSubMask;
pub const tomMathBrkBinSubMM = tomConstants.False;
pub const tomMathBrkBinSubPM = tomConstants.ListNoNumber;
pub const tomMathBrkBinSubMP = tomConstants.ListMinus;
pub const tomSelRange = tomConstants.SelRange;
pub const tomHstring = tomConstants.MathObjShadingEnd;
pub const tomFontPropTeXStyle = tomConstants.FontPropTeXStyle;
pub const tomFontPropAlign = tomConstants.FontPropAlign;
pub const tomFontStretch = tomConstants.FontStretch;
pub const tomFontStyle = tomConstants.FontStyle;
pub const tomFontStyleUpright = tomConstants.False;
pub const tomFontStyleOblique = tomConstants.ApplyLater;
pub const tomFontStyleItalic = tomConstants.TrackParms;
pub const tomFontStretchDefault = tomConstants.False;
pub const tomFontStretchUltraCondensed = tomConstants.ApplyLater;
pub const tomFontStretchExtraCondensed = tomConstants.TrackParms;
pub const tomFontStretchCondensed = tomConstants.CacheParms;
pub const tomFontStretchSemiCondensed = tomConstants.ApplyTmp;
pub const tomFontStretchNormal = tomConstants.SelectionRow;
pub const tomFontStretchSemiExpanded = tomConstants.SelectionBlock;
pub const tomFontStretchExpanded = tomConstants.SelectionInlineShape;
pub const tomFontStretchExtraExpanded = tomConstants.DisableSmartFont;
pub const tomFontStretchUltraExpanded = tomConstants.EnableSmartFont;
pub const tomFontWeightDefault = tomConstants.False;
pub const tomFontWeightThin = tomConstants.FontWeightThin;
pub const tomFontWeightExtraLight = tomConstants.FontWeightExtraLight;
pub const tomFontWeightLight = tomConstants.FontWeightLight;
pub const tomFontWeightNormal = tomConstants.FontWeightNormal;
pub const tomFontWeightRegular = tomConstants.FontWeightNormal;
pub const tomFontWeightMedium = tomConstants.FontWeightMedium;
pub const tomFontWeightSemiBold = tomConstants.FontWeightSemiBold;
pub const tomFontWeightBold = tomConstants.FontWeightBold;
pub const tomFontWeightExtraBold = tomConstants.FontWeightExtraBold;
pub const tomFontWeightBlack = tomConstants.FontWeightBlack;
pub const tomFontWeightHeavy = tomConstants.FontWeightBlack;
pub const tomFontWeightExtraBlack = tomConstants.FontWeightExtraBlack;
pub const tomParaPropMathAlign = tomConstants.ParaPropMathAlign;
pub const tomDocMathBuild = tomConstants.FindStory;
pub const tomMathLMargin = tomConstants.ReplaceStory;
pub const tomMathRMargin = tomConstants.MathRMargin;
pub const tomMathWrapIndent = tomConstants.MathWrapIndent;
pub const tomMathWrapRight = tomConstants.MathWrapRight;
pub const tomMathPostSpace = tomConstants.MathPostSpace;
pub const tomMathPreSpace = tomConstants.MathPreSpace;
pub const tomMathInterSpace = tomConstants.MathInterSpace;
pub const tomMathIntraSpace = tomConstants.MathIntraSpace;
pub const tomCanCopy = tomConstants.CanCopy;
pub const tomCanRedo = tomConstants.CanRedo;
pub const tomCanUndo = tomConstants.CanUndo;
pub const tomUndoLimit = tomConstants.UndoLimit;
pub const tomDocAutoLink = tomConstants.DocAutoLink;
pub const tomEllipsisMode = tomConstants.EllipsisMode;
pub const tomEllipsisState = tomConstants.EllipsisState;
pub const tomEllipsisNone = tomConstants.False;
pub const tomEllipsisEnd = tomConstants.ApplyLater;
pub const tomEllipsisWord = tomConstants.CacheParms;
pub const tomEllipsisPresent = tomConstants.ApplyLater;
pub const tomVTopCell = tomConstants.ApplyLater;
pub const tomVLowCell = tomConstants.TrackParms;
pub const tomHStartCell = tomConstants.ApplyTmp;
pub const tomHContCell = tomConstants.DisableSmartFont;
pub const tomRowUpdate = tomConstants.ApplyLater;
pub const tomRowApplyDefault = tomConstants.False;
pub const tomCellStructureChangeOnly = tomConstants.ApplyLater;
pub const tomRowHeightActual = tomConstants.RowHeightActual;

pub const OBJECTTYPE = enum(i32) {
    SimpleText = 0,
    Ruby = 1,
    HorzVert = 2,
    Warichu = 3,
    Eq = 9,
    Math = 10,
    // Accent = 10, this enum value conflicts with Math
    Box = 11,
    BoxedFormula = 12,
    Brackets = 13,
    BracketsWithSeps = 14,
    EquationArray = 15,
    Fraction = 16,
    FunctionApply = 17,
    LeftSubSup = 18,
    LowerLimit = 19,
    Matrix = 20,
    Nary = 21,
    OpChar = 22,
    Overbar = 23,
    Phantom = 24,
    Radical = 25,
    SlashedFraction = 26,
    Stack = 27,
    StretchStack = 28,
    Subscript = 29,
    SubSup = 30,
    Superscript = 31,
    Underbar = 32,
    UpperLimit = 33,
    // ObjectMax = 33, this enum value conflicts with UpperLimit
};
pub const tomSimpleText = OBJECTTYPE.SimpleText;
pub const tomRuby = OBJECTTYPE.Ruby;
pub const tomHorzVert = OBJECTTYPE.HorzVert;
pub const tomWarichu = OBJECTTYPE.Warichu;
pub const tomEq = OBJECTTYPE.Eq;
pub const tomMath = OBJECTTYPE.Math;
pub const tomAccent = OBJECTTYPE.Math;
pub const tomBox = OBJECTTYPE.Box;
pub const tomBoxedFormula = OBJECTTYPE.BoxedFormula;
pub const tomBrackets = OBJECTTYPE.Brackets;
pub const tomBracketsWithSeps = OBJECTTYPE.BracketsWithSeps;
pub const tomEquationArray = OBJECTTYPE.EquationArray;
pub const tomFraction = OBJECTTYPE.Fraction;
pub const tomFunctionApply = OBJECTTYPE.FunctionApply;
pub const tomLeftSubSup = OBJECTTYPE.LeftSubSup;
pub const tomLowerLimit = OBJECTTYPE.LowerLimit;
pub const tomMatrix = OBJECTTYPE.Matrix;
pub const tomNary = OBJECTTYPE.Nary;
pub const tomOpChar = OBJECTTYPE.OpChar;
pub const tomOverbar = OBJECTTYPE.Overbar;
pub const tomPhantom = OBJECTTYPE.Phantom;
pub const tomRadical = OBJECTTYPE.Radical;
pub const tomSlashedFraction = OBJECTTYPE.SlashedFraction;
pub const tomStack = OBJECTTYPE.Stack;
pub const tomStretchStack = OBJECTTYPE.StretchStack;
pub const tomSubscript = OBJECTTYPE.Subscript;
pub const tomSubSup = OBJECTTYPE.SubSup;
pub const tomSuperscript = OBJECTTYPE.Superscript;
pub const tomUnderbar = OBJECTTYPE.Underbar;
pub const tomUpperLimit = OBJECTTYPE.UpperLimit;
pub const tomObjectMax = OBJECTTYPE.UpperLimit;

pub const MANCODE = enum(i32) {
    BOLD = 16,
    ITAL = 32,
    GREEK = 64,
    ROMN = 0,
    SCRP = 1,
    FRAK = 2,
    OPEN = 3,
    SANS = 4,
    MONO = 5,
    MATH = 6,
    ISOL = 7,
    INIT = 8,
    TAIL = 9,
    STRCH = 10,
    LOOP = 11,
    OPENA = 12,
};
pub const MBOLD = MANCODE.BOLD;
pub const MITAL = MANCODE.ITAL;
pub const MGREEK = MANCODE.GREEK;
pub const MROMN = MANCODE.ROMN;
pub const MSCRP = MANCODE.SCRP;
pub const MFRAK = MANCODE.FRAK;
pub const MOPEN = MANCODE.OPEN;
pub const MSANS = MANCODE.SANS;
pub const MMONO = MANCODE.MONO;
pub const MMATH = MANCODE.MATH;
pub const MISOL = MANCODE.ISOL;
pub const MINIT = MANCODE.INIT;
pub const MTAIL = MANCODE.TAIL;
pub const MSTRCH = MANCODE.STRCH;
pub const MLOOP = MANCODE.LOOP;
pub const MOPENA = MANCODE.OPENA;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ITextDocument_Value = Guid.initString("8cc497c0-a1df-11ce-8098-00aa0047be5d");
pub const IID_ITextDocument = &IID_ITextDocument_Value;
pub const ITextDocument = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        GetName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextDocument,
                pName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextDocument,
                pName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSelection: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextDocument,
                ppSel: ?*?*ITextSelection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextDocument,
                ppSel: ?*?*ITextSelection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStoryCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextDocument,
                pCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextDocument,
                pCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStoryRanges: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextDocument,
                ppStories: ?*?*ITextStoryRanges,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextDocument,
                ppStories: ?*?*ITextStoryRanges,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSaved: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextDocument,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextDocument,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSaved: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextDocument,
                Value: tomConstants,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextDocument,
                Value: tomConstants,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDefaultTabStop: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextDocument,
                pValue: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextDocument,
                pValue: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDefaultTabStop: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextDocument,
                Value: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextDocument,
                Value: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        New: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextDocument,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextDocument,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Open: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextDocument,
                pVar: ?*VARIANT,
                Flags: i32,
                CodePage: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextDocument,
                pVar: ?*VARIANT,
                Flags: i32,
                CodePage: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Save: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextDocument,
                pVar: ?*VARIANT,
                Flags: i32,
                CodePage: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextDocument,
                pVar: ?*VARIANT,
                Flags: i32,
                CodePage: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Freeze: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextDocument,
                pCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextDocument,
                pCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Unfreeze: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextDocument,
                pCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextDocument,
                pCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BeginEditCollection: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextDocument,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextDocument,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndEditCollection: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextDocument,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextDocument,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Undo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextDocument,
                Count: i32,
                pCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextDocument,
                Count: i32,
                pCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Redo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextDocument,
                Count: i32,
                pCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextDocument,
                Count: i32,
                pCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Range: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextDocument,
                cpActive: i32,
                cpAnchor: i32,
                ppRange: ?*?*ITextRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextDocument,
                cpActive: i32,
                cpAnchor: i32,
                ppRange: ?*?*ITextRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RangeFromPoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextDocument,
                x: i32,
                y: i32,
                ppRange: ?*?*ITextRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextDocument,
                x: i32,
                y: i32,
                ppRange: ?*?*ITextRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextDocument_GetName(self: *const T, pName: ?*?BSTR) HRESULT {
                return @as(*const ITextDocument.VTable, @ptrCast(self.vtable)).GetName(@as(*const ITextDocument, @ptrCast(self)), pName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextDocument_GetSelection(self: *const T, ppSel: ?*?*ITextSelection) HRESULT {
                return @as(*const ITextDocument.VTable, @ptrCast(self.vtable)).GetSelection(@as(*const ITextDocument, @ptrCast(self)), ppSel);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextDocument_GetStoryCount(self: *const T, pCount: ?*i32) HRESULT {
                return @as(*const ITextDocument.VTable, @ptrCast(self.vtable)).GetStoryCount(@as(*const ITextDocument, @ptrCast(self)), pCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextDocument_GetStoryRanges(self: *const T, ppStories: ?*?*ITextStoryRanges) HRESULT {
                return @as(*const ITextDocument.VTable, @ptrCast(self.vtable)).GetStoryRanges(@as(*const ITextDocument, @ptrCast(self)), ppStories);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextDocument_GetSaved(self: *const T, pValue: ?*i32) HRESULT {
                return @as(*const ITextDocument.VTable, @ptrCast(self.vtable)).GetSaved(@as(*const ITextDocument, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextDocument_SetSaved(self: *const T, Value: tomConstants) HRESULT {
                return @as(*const ITextDocument.VTable, @ptrCast(self.vtable)).SetSaved(@as(*const ITextDocument, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextDocument_GetDefaultTabStop(self: *const T, pValue: ?*f32) HRESULT {
                return @as(*const ITextDocument.VTable, @ptrCast(self.vtable)).GetDefaultTabStop(@as(*const ITextDocument, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextDocument_SetDefaultTabStop(self: *const T, Value: f32) HRESULT {
                return @as(*const ITextDocument.VTable, @ptrCast(self.vtable)).SetDefaultTabStop(@as(*const ITextDocument, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextDocument_New(self: *const T) HRESULT {
                return @as(*const ITextDocument.VTable, @ptrCast(self.vtable)).New(@as(*const ITextDocument, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextDocument_Open(self: *const T, pVar: ?*VARIANT, Flags: i32, CodePage: i32) HRESULT {
                return @as(*const ITextDocument.VTable, @ptrCast(self.vtable)).Open(@as(*const ITextDocument, @ptrCast(self)), pVar, Flags, CodePage);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextDocument_Save(self: *const T, pVar: ?*VARIANT, Flags: i32, CodePage: i32) HRESULT {
                return @as(*const ITextDocument.VTable, @ptrCast(self.vtable)).Save(@as(*const ITextDocument, @ptrCast(self)), pVar, Flags, CodePage);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextDocument_Freeze(self: *const T, pCount: ?*i32) HRESULT {
                return @as(*const ITextDocument.VTable, @ptrCast(self.vtable)).Freeze(@as(*const ITextDocument, @ptrCast(self)), pCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextDocument_Unfreeze(self: *const T, pCount: ?*i32) HRESULT {
                return @as(*const ITextDocument.VTable, @ptrCast(self.vtable)).Unfreeze(@as(*const ITextDocument, @ptrCast(self)), pCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextDocument_BeginEditCollection(self: *const T) HRESULT {
                return @as(*const ITextDocument.VTable, @ptrCast(self.vtable)).BeginEditCollection(@as(*const ITextDocument, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextDocument_EndEditCollection(self: *const T) HRESULT {
                return @as(*const ITextDocument.VTable, @ptrCast(self.vtable)).EndEditCollection(@as(*const ITextDocument, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextDocument_Undo(self: *const T, Count: i32, pCount: ?*i32) HRESULT {
                return @as(*const ITextDocument.VTable, @ptrCast(self.vtable)).Undo(@as(*const ITextDocument, @ptrCast(self)), Count, pCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextDocument_Redo(self: *const T, Count: i32, pCount: ?*i32) HRESULT {
                return @as(*const ITextDocument.VTable, @ptrCast(self.vtable)).Redo(@as(*const ITextDocument, @ptrCast(self)), Count, pCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextDocument_Range(self: *const T, cpActive: i32, cpAnchor: i32, ppRange: ?*?*ITextRange) HRESULT {
                return @as(*const ITextDocument.VTable, @ptrCast(self.vtable)).Range(@as(*const ITextDocument, @ptrCast(self)), cpActive, cpAnchor, ppRange);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextDocument_RangeFromPoint(self: *const T, x: i32, y: i32, ppRange: ?*?*ITextRange) HRESULT {
                return @as(*const ITextDocument.VTable, @ptrCast(self.vtable)).RangeFromPoint(@as(*const ITextDocument, @ptrCast(self)), x, y, ppRange);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ITextRange_Value = Guid.initString("8cc497c2-a1df-11ce-8098-00aa0047be5d");
pub const IID_ITextRange = &IID_ITextRange_Value;
pub const ITextRange = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        GetText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRange,
                pbstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRange,
                pbstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRange,
                bstr: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRange,
                bstr: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetChar: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRange,
                pChar: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRange,
                pChar: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetChar: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRange,
                Char: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRange,
                Char: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDuplicate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRange,
                ppRange: ?*?*ITextRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRange,
                ppRange: ?*?*ITextRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFormattedText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRange,
                ppRange: ?*?*ITextRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRange,
                ppRange: ?*?*ITextRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFormattedText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRange,
                pRange: ?*ITextRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRange,
                pRange: ?*ITextRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStart: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRange,
                pcpFirst: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRange,
                pcpFirst: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetStart: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRange,
                cpFirst: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRange,
                cpFirst: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEnd: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRange,
                pcpLim: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRange,
                pcpLim: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEnd: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRange,
                cpLim: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRange,
                cpLim: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFont: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRange,
                ppFont: ?*?*ITextFont,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRange,
                ppFont: ?*?*ITextFont,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFont: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRange,
                pFont: ?*ITextFont,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRange,
                pFont: ?*ITextFont,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPara: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRange,
                ppPara: ?*?*ITextPara,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRange,
                ppPara: ?*?*ITextPara,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPara: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRange,
                pPara: ?*ITextPara,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRange,
                pPara: ?*ITextPara,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStoryLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRange,
                pCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRange,
                pCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStoryType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRange,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRange,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Collapse: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRange,
                bStart: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRange,
                bStart: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Expand: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRange,
                Unit: i32,
                pDelta: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRange,
                Unit: i32,
                pDelta: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRange,
                Unit: i32,
                pIndex: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRange,
                Unit: i32,
                pIndex: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRange,
                Unit: i32,
                Index: i32,
                Extend: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRange,
                Unit: i32,
                Index: i32,
                Extend: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetRange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRange,
                cpAnchor: i32,
                cpActive: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRange,
                cpAnchor: i32,
                cpActive: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InRange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRange,
                pRange: ?*ITextRange,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRange,
                pRange: ?*ITextRange,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InStory: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRange,
                pRange: ?*ITextRange,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRange,
                pRange: ?*ITextRange,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsEqual: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRange,
                pRange: ?*ITextRange,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRange,
                pRange: ?*ITextRange,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Select: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartOf: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRange,
                Unit: i32,
                Extend: i32,
                pDelta: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRange,
                Unit: i32,
                Extend: i32,
                pDelta: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndOf: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRange,
                Unit: i32,
                Extend: i32,
                pDelta: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRange,
                Unit: i32,
                Extend: i32,
                pDelta: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Move: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRange,
                Unit: i32,
                Count: i32,
                pDelta: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRange,
                Unit: i32,
                Count: i32,
                pDelta: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        MoveStart: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRange,
                Unit: i32,
                Count: i32,
                pDelta: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRange,
                Unit: i32,
                Count: i32,
                pDelta: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        MoveEnd: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRange,
                Unit: i32,
                Count: i32,
                pDelta: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRange,
                Unit: i32,
                Count: i32,
                pDelta: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        MoveWhile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRange,
                Cset: ?*VARIANT,
                Count: i32,
                pDelta: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRange,
                Cset: ?*VARIANT,
                Count: i32,
                pDelta: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        MoveStartWhile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRange,
                Cset: ?*VARIANT,
                Count: i32,
                pDelta: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRange,
                Cset: ?*VARIANT,
                Count: i32,
                pDelta: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        MoveEndWhile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRange,
                Cset: ?*VARIANT,
                Count: i32,
                pDelta: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRange,
                Cset: ?*VARIANT,
                Count: i32,
                pDelta: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        MoveUntil: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRange,
                Cset: ?*VARIANT,
                Count: i32,
                pDelta: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRange,
                Cset: ?*VARIANT,
                Count: i32,
                pDelta: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        MoveStartUntil: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRange,
                Cset: ?*VARIANT,
                Count: i32,
                pDelta: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRange,
                Cset: ?*VARIANT,
                Count: i32,
                pDelta: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        MoveEndUntil: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRange,
                Cset: ?*VARIANT,
                Count: i32,
                pDelta: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRange,
                Cset: ?*VARIANT,
                Count: i32,
                pDelta: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRange,
                bstr: ?BSTR,
                Count: i32,
                Flags: i32,
                pLength: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRange,
                bstr: ?BSTR,
                Count: i32,
                Flags: i32,
                pLength: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindTextStart: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRange,
                bstr: ?BSTR,
                Count: i32,
                Flags: i32,
                pLength: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRange,
                bstr: ?BSTR,
                Count: i32,
                Flags: i32,
                pLength: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindTextEnd: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRange,
                bstr: ?BSTR,
                Count: i32,
                Flags: i32,
                pLength: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRange,
                bstr: ?BSTR,
                Count: i32,
                Flags: i32,
                pLength: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Delete: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRange,
                Unit: i32,
                Count: i32,
                pDelta: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRange,
                Unit: i32,
                Count: i32,
                pDelta: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Cut: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRange,
                pVar: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRange,
                pVar: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Copy: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRange,
                pVar: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRange,
                pVar: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Paste: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRange,
                pVar: ?*VARIANT,
                Format: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRange,
                pVar: ?*VARIANT,
                Format: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CanPaste: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRange,
                pVar: ?*VARIANT,
                Format: i32,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRange,
                pVar: ?*VARIANT,
                Format: i32,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CanEdit: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRange,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRange,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ChangeCase: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRange,
                Type: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRange,
                Type: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRange,
                Type: i32,
                px: ?*i32,
                py: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRange,
                Type: i32,
                px: ?*i32,
                py: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRange,
                x: i32,
                y: i32,
                Type: i32,
                Extend: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRange,
                x: i32,
                y: i32,
                Type: i32,
                Extend: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ScrollIntoView: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRange,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRange,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEmbeddedObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRange,
                ppObject: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRange,
                ppObject: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRange_GetText(self: *const T, pbstr: ?*?BSTR) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).GetText(@as(*const ITextRange, @ptrCast(self)), pbstr);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRange_SetText(self: *const T, bstr: ?BSTR) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).SetText(@as(*const ITextRange, @ptrCast(self)), bstr);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRange_GetChar(self: *const T, pChar: ?*i32) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).GetChar(@as(*const ITextRange, @ptrCast(self)), pChar);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRange_SetChar(self: *const T, Char: i32) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).SetChar(@as(*const ITextRange, @ptrCast(self)), Char);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRange_GetDuplicate(self: *const T, ppRange: ?*?*ITextRange) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).GetDuplicate(@as(*const ITextRange, @ptrCast(self)), ppRange);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRange_GetFormattedText(self: *const T, ppRange: ?*?*ITextRange) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).GetFormattedText(@as(*const ITextRange, @ptrCast(self)), ppRange);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRange_SetFormattedText(self: *const T, pRange: ?*ITextRange) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).SetFormattedText(@as(*const ITextRange, @ptrCast(self)), pRange);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRange_GetStart(self: *const T, pcpFirst: ?*i32) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).GetStart(@as(*const ITextRange, @ptrCast(self)), pcpFirst);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRange_SetStart(self: *const T, cpFirst: i32) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).SetStart(@as(*const ITextRange, @ptrCast(self)), cpFirst);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRange_GetEnd(self: *const T, pcpLim: ?*i32) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).GetEnd(@as(*const ITextRange, @ptrCast(self)), pcpLim);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRange_SetEnd(self: *const T, cpLim: i32) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).SetEnd(@as(*const ITextRange, @ptrCast(self)), cpLim);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRange_GetFont(self: *const T, ppFont: ?*?*ITextFont) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).GetFont(@as(*const ITextRange, @ptrCast(self)), ppFont);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRange_SetFont(self: *const T, pFont: ?*ITextFont) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).SetFont(@as(*const ITextRange, @ptrCast(self)), pFont);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRange_GetPara(self: *const T, ppPara: ?*?*ITextPara) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).GetPara(@as(*const ITextRange, @ptrCast(self)), ppPara);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRange_SetPara(self: *const T, pPara: ?*ITextPara) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).SetPara(@as(*const ITextRange, @ptrCast(self)), pPara);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRange_GetStoryLength(self: *const T, pCount: ?*i32) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).GetStoryLength(@as(*const ITextRange, @ptrCast(self)), pCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRange_GetStoryType(self: *const T, pValue: ?*i32) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).GetStoryType(@as(*const ITextRange, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRange_Collapse(self: *const T, bStart: i32) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).Collapse(@as(*const ITextRange, @ptrCast(self)), bStart);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRange_Expand(self: *const T, Unit: i32, pDelta: ?*i32) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).Expand(@as(*const ITextRange, @ptrCast(self)), Unit, pDelta);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRange_GetIndex(self: *const T, Unit: i32, pIndex: ?*i32) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).GetIndex(@as(*const ITextRange, @ptrCast(self)), Unit, pIndex);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRange_SetIndex(self: *const T, Unit: i32, Index: i32, Extend: i32) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).SetIndex(@as(*const ITextRange, @ptrCast(self)), Unit, Index, Extend);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRange_SetRange(self: *const T, cpAnchor: i32, cpActive: i32) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).SetRange(@as(*const ITextRange, @ptrCast(self)), cpAnchor, cpActive);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRange_InRange(self: *const T, pRange: ?*ITextRange, pValue: ?*i32) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).InRange(@as(*const ITextRange, @ptrCast(self)), pRange, pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRange_InStory(self: *const T, pRange: ?*ITextRange, pValue: ?*i32) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).InStory(@as(*const ITextRange, @ptrCast(self)), pRange, pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRange_IsEqual(self: *const T, pRange: ?*ITextRange, pValue: ?*i32) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).IsEqual(@as(*const ITextRange, @ptrCast(self)), pRange, pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRange_Select(self: *const T) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).Select(@as(*const ITextRange, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRange_StartOf(self: *const T, Unit: i32, Extend: i32, pDelta: ?*i32) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).StartOf(@as(*const ITextRange, @ptrCast(self)), Unit, Extend, pDelta);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRange_EndOf(self: *const T, Unit: i32, Extend: i32, pDelta: ?*i32) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).EndOf(@as(*const ITextRange, @ptrCast(self)), Unit, Extend, pDelta);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRange_Move(self: *const T, Unit: i32, Count: i32, pDelta: ?*i32) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).Move(@as(*const ITextRange, @ptrCast(self)), Unit, Count, pDelta);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRange_MoveStart(self: *const T, Unit: i32, Count: i32, pDelta: ?*i32) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).MoveStart(@as(*const ITextRange, @ptrCast(self)), Unit, Count, pDelta);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRange_MoveEnd(self: *const T, Unit: i32, Count: i32, pDelta: ?*i32) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).MoveEnd(@as(*const ITextRange, @ptrCast(self)), Unit, Count, pDelta);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRange_MoveWhile(self: *const T, Cset: ?*VARIANT, Count: i32, pDelta: ?*i32) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).MoveWhile(@as(*const ITextRange, @ptrCast(self)), Cset, Count, pDelta);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRange_MoveStartWhile(self: *const T, Cset: ?*VARIANT, Count: i32, pDelta: ?*i32) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).MoveStartWhile(@as(*const ITextRange, @ptrCast(self)), Cset, Count, pDelta);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRange_MoveEndWhile(self: *const T, Cset: ?*VARIANT, Count: i32, pDelta: ?*i32) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).MoveEndWhile(@as(*const ITextRange, @ptrCast(self)), Cset, Count, pDelta);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRange_MoveUntil(self: *const T, Cset: ?*VARIANT, Count: i32, pDelta: ?*i32) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).MoveUntil(@as(*const ITextRange, @ptrCast(self)), Cset, Count, pDelta);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRange_MoveStartUntil(self: *const T, Cset: ?*VARIANT, Count: i32, pDelta: ?*i32) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).MoveStartUntil(@as(*const ITextRange, @ptrCast(self)), Cset, Count, pDelta);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRange_MoveEndUntil(self: *const T, Cset: ?*VARIANT, Count: i32, pDelta: ?*i32) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).MoveEndUntil(@as(*const ITextRange, @ptrCast(self)), Cset, Count, pDelta);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRange_FindText(self: *const T, bstr: ?BSTR, Count: i32, Flags: i32, pLength: ?*i32) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).FindText(@as(*const ITextRange, @ptrCast(self)), bstr, Count, Flags, pLength);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRange_FindTextStart(self: *const T, bstr: ?BSTR, Count: i32, Flags: i32, pLength: ?*i32) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).FindTextStart(@as(*const ITextRange, @ptrCast(self)), bstr, Count, Flags, pLength);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRange_FindTextEnd(self: *const T, bstr: ?BSTR, Count: i32, Flags: i32, pLength: ?*i32) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).FindTextEnd(@as(*const ITextRange, @ptrCast(self)), bstr, Count, Flags, pLength);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRange_Delete(self: *const T, Unit: i32, Count: i32, pDelta: ?*i32) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).Delete(@as(*const ITextRange, @ptrCast(self)), Unit, Count, pDelta);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRange_Cut(self: *const T, pVar: ?*VARIANT) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).Cut(@as(*const ITextRange, @ptrCast(self)), pVar);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRange_Copy(self: *const T, pVar: ?*VARIANT) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).Copy(@as(*const ITextRange, @ptrCast(self)), pVar);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRange_Paste(self: *const T, pVar: ?*VARIANT, Format: i32) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).Paste(@as(*const ITextRange, @ptrCast(self)), pVar, Format);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRange_CanPaste(self: *const T, pVar: ?*VARIANT, Format: i32, pValue: ?*i32) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).CanPaste(@as(*const ITextRange, @ptrCast(self)), pVar, Format, pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRange_CanEdit(self: *const T, pValue: ?*i32) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).CanEdit(@as(*const ITextRange, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRange_ChangeCase(self: *const T, Type: i32) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).ChangeCase(@as(*const ITextRange, @ptrCast(self)), Type);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRange_GetPoint(self: *const T, Type: i32, px: ?*i32, py: ?*i32) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).GetPoint(@as(*const ITextRange, @ptrCast(self)), Type, px, py);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRange_SetPoint(self: *const T, x: i32, y: i32, Type: i32, Extend: i32) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).SetPoint(@as(*const ITextRange, @ptrCast(self)), x, y, Type, Extend);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRange_ScrollIntoView(self: *const T, Value: i32) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).ScrollIntoView(@as(*const ITextRange, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRange_GetEmbeddedObject(self: *const T, ppObject: ?*?*IUnknown) HRESULT {
                return @as(*const ITextRange.VTable, @ptrCast(self.vtable)).GetEmbeddedObject(@as(*const ITextRange, @ptrCast(self)), ppObject);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ITextSelection_Value = Guid.initString("8cc497c1-a1df-11ce-8098-00aa0047be5d");
pub const IID_ITextSelection = &IID_ITextSelection_Value;
pub const ITextSelection = extern struct {
    pub const VTable = extern struct {
        base: ITextRange.VTable,
        GetFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextSelection,
                pFlags: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextSelection,
                pFlags: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextSelection,
                Flags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextSelection,
                Flags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextSelection,
                pType: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextSelection,
                pType: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        MoveLeft: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextSelection,
                Unit: i32,
                Count: i32,
                Extend: i32,
                pDelta: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextSelection,
                Unit: i32,
                Count: i32,
                Extend: i32,
                pDelta: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        MoveRight: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextSelection,
                Unit: i32,
                Count: i32,
                Extend: i32,
                pDelta: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextSelection,
                Unit: i32,
                Count: i32,
                Extend: i32,
                pDelta: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        MoveUp: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextSelection,
                Unit: i32,
                Count: i32,
                Extend: i32,
                pDelta: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextSelection,
                Unit: i32,
                Count: i32,
                Extend: i32,
                pDelta: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        MoveDown: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextSelection,
                Unit: i32,
                Count: i32,
                Extend: i32,
                pDelta: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextSelection,
                Unit: i32,
                Count: i32,
                Extend: i32,
                pDelta: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        HomeKey: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextSelection,
                Unit: tomConstants,
                Extend: i32,
                pDelta: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextSelection,
                Unit: tomConstants,
                Extend: i32,
                pDelta: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndKey: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextSelection,
                Unit: i32,
                Extend: i32,
                pDelta: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextSelection,
                Unit: i32,
                Extend: i32,
                pDelta: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TypeText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextSelection,
                bstr: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextSelection,
                bstr: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITextRange.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextSelection_GetFlags(self: *const T, pFlags: ?*i32) HRESULT {
                return @as(*const ITextSelection.VTable, @ptrCast(self.vtable)).GetFlags(@as(*const ITextSelection, @ptrCast(self)), pFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextSelection_SetFlags(self: *const T, Flags: i32) HRESULT {
                return @as(*const ITextSelection.VTable, @ptrCast(self.vtable)).SetFlags(@as(*const ITextSelection, @ptrCast(self)), Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextSelection_GetType(self: *const T, pType: ?*i32) HRESULT {
                return @as(*const ITextSelection.VTable, @ptrCast(self.vtable)).GetType(@as(*const ITextSelection, @ptrCast(self)), pType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextSelection_MoveLeft(self: *const T, Unit: i32, Count: i32, Extend: i32, pDelta: ?*i32) HRESULT {
                return @as(*const ITextSelection.VTable, @ptrCast(self.vtable)).MoveLeft(@as(*const ITextSelection, @ptrCast(self)), Unit, Count, Extend, pDelta);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextSelection_MoveRight(self: *const T, Unit: i32, Count: i32, Extend: i32, pDelta: ?*i32) HRESULT {
                return @as(*const ITextSelection.VTable, @ptrCast(self.vtable)).MoveRight(@as(*const ITextSelection, @ptrCast(self)), Unit, Count, Extend, pDelta);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextSelection_MoveUp(self: *const T, Unit: i32, Count: i32, Extend: i32, pDelta: ?*i32) HRESULT {
                return @as(*const ITextSelection.VTable, @ptrCast(self.vtable)).MoveUp(@as(*const ITextSelection, @ptrCast(self)), Unit, Count, Extend, pDelta);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextSelection_MoveDown(self: *const T, Unit: i32, Count: i32, Extend: i32, pDelta: ?*i32) HRESULT {
                return @as(*const ITextSelection.VTable, @ptrCast(self.vtable)).MoveDown(@as(*const ITextSelection, @ptrCast(self)), Unit, Count, Extend, pDelta);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextSelection_HomeKey(self: *const T, Unit: tomConstants, Extend: i32, pDelta: ?*i32) HRESULT {
                return @as(*const ITextSelection.VTable, @ptrCast(self.vtable)).HomeKey(@as(*const ITextSelection, @ptrCast(self)), Unit, Extend, pDelta);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextSelection_EndKey(self: *const T, Unit: i32, Extend: i32, pDelta: ?*i32) HRESULT {
                return @as(*const ITextSelection.VTable, @ptrCast(self.vtable)).EndKey(@as(*const ITextSelection, @ptrCast(self)), Unit, Extend, pDelta);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextSelection_TypeText(self: *const T, bstr: ?BSTR) HRESULT {
                return @as(*const ITextSelection.VTable, @ptrCast(self.vtable)).TypeText(@as(*const ITextSelection, @ptrCast(self)), bstr);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ITextFont_Value = Guid.initString("8cc497c3-a1df-11ce-8098-00aa0047be5d");
pub const IID_ITextFont = &IID_ITextFont_Value;
pub const ITextFont = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        GetDuplicate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont,
                ppFont: ?*?*ITextFont,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont,
                ppFont: ?*?*ITextFont,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDuplicate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont,
                pFont: ?*ITextFont,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont,
                pFont: ?*ITextFont,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CanChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsEqual: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont,
                pFont: ?*ITextFont,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont,
                pFont: ?*ITextFont,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont,
                Value: tomConstants,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont,
                Value: tomConstants,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStyle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetStyle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAllCaps: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetAllCaps: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAnimation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetAnimation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBackColor: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetBackColor: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBold: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetBold: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEmboss: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEmboss: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetForeColor: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetForeColor: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetHidden: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetHidden: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEngrave: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEngrave: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetItalic: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetItalic: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetKerning: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont,
                pValue: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont,
                pValue: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetKerning: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont,
                Value: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont,
                Value: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLanguageID: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetLanguageID: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont,
                pbstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont,
                pbstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont,
                bstr: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont,
                bstr: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutline: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutline: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont,
                pValue: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont,
                pValue: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont,
                Value: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont,
                Value: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProtected: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetProtected: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetShadow: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetShadow: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont,
                pValue: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont,
                pValue: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont,
                Value: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont,
                Value: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSmallCaps: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSmallCaps: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSpacing: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont,
                pValue: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont,
                pValue: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSpacing: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont,
                Value: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont,
                Value: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStrikeThrough: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetStrikeThrough: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSubscript: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSubscript: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSuperscript: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSuperscript: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetUnderline: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetUnderline: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetWeight: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetWeight: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont_GetDuplicate(self: *const T, ppFont: ?*?*ITextFont) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).GetDuplicate(@as(*const ITextFont, @ptrCast(self)), ppFont);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont_SetDuplicate(self: *const T, pFont: ?*ITextFont) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).SetDuplicate(@as(*const ITextFont, @ptrCast(self)), pFont);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont_CanChange(self: *const T, pValue: ?*i32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).CanChange(@as(*const ITextFont, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont_IsEqual(self: *const T, pFont: ?*ITextFont, pValue: ?*i32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).IsEqual(@as(*const ITextFont, @ptrCast(self)), pFont, pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont_Reset(self: *const T, Value: tomConstants) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).Reset(@as(*const ITextFont, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont_GetStyle(self: *const T, pValue: ?*i32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).GetStyle(@as(*const ITextFont, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont_SetStyle(self: *const T, Value: i32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).SetStyle(@as(*const ITextFont, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont_GetAllCaps(self: *const T, pValue: ?*i32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).GetAllCaps(@as(*const ITextFont, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont_SetAllCaps(self: *const T, Value: i32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).SetAllCaps(@as(*const ITextFont, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont_GetAnimation(self: *const T, pValue: ?*i32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).GetAnimation(@as(*const ITextFont, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont_SetAnimation(self: *const T, Value: i32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).SetAnimation(@as(*const ITextFont, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont_GetBackColor(self: *const T, pValue: ?*i32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).GetBackColor(@as(*const ITextFont, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont_SetBackColor(self: *const T, Value: i32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).SetBackColor(@as(*const ITextFont, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont_GetBold(self: *const T, pValue: ?*i32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).GetBold(@as(*const ITextFont, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont_SetBold(self: *const T, Value: i32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).SetBold(@as(*const ITextFont, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont_GetEmboss(self: *const T, pValue: ?*i32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).GetEmboss(@as(*const ITextFont, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont_SetEmboss(self: *const T, Value: i32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).SetEmboss(@as(*const ITextFont, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont_GetForeColor(self: *const T, pValue: ?*i32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).GetForeColor(@as(*const ITextFont, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont_SetForeColor(self: *const T, Value: i32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).SetForeColor(@as(*const ITextFont, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont_GetHidden(self: *const T, pValue: ?*i32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).GetHidden(@as(*const ITextFont, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont_SetHidden(self: *const T, Value: i32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).SetHidden(@as(*const ITextFont, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont_GetEngrave(self: *const T, pValue: ?*i32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).GetEngrave(@as(*const ITextFont, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont_SetEngrave(self: *const T, Value: i32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).SetEngrave(@as(*const ITextFont, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont_GetItalic(self: *const T, pValue: ?*i32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).GetItalic(@as(*const ITextFont, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont_SetItalic(self: *const T, Value: i32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).SetItalic(@as(*const ITextFont, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont_GetKerning(self: *const T, pValue: ?*f32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).GetKerning(@as(*const ITextFont, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont_SetKerning(self: *const T, Value: f32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).SetKerning(@as(*const ITextFont, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont_GetLanguageID(self: *const T, pValue: ?*i32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).GetLanguageID(@as(*const ITextFont, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont_SetLanguageID(self: *const T, Value: i32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).SetLanguageID(@as(*const ITextFont, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont_GetName(self: *const T, pbstr: ?*?BSTR) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).GetName(@as(*const ITextFont, @ptrCast(self)), pbstr);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont_SetName(self: *const T, bstr: ?BSTR) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).SetName(@as(*const ITextFont, @ptrCast(self)), bstr);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont_GetOutline(self: *const T, pValue: ?*i32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).GetOutline(@as(*const ITextFont, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont_SetOutline(self: *const T, Value: i32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).SetOutline(@as(*const ITextFont, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont_GetPosition(self: *const T, pValue: ?*f32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).GetPosition(@as(*const ITextFont, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont_SetPosition(self: *const T, Value: f32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).SetPosition(@as(*const ITextFont, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont_GetProtected(self: *const T, pValue: ?*i32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).GetProtected(@as(*const ITextFont, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont_SetProtected(self: *const T, Value: i32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).SetProtected(@as(*const ITextFont, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont_GetShadow(self: *const T, pValue: ?*i32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).GetShadow(@as(*const ITextFont, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont_SetShadow(self: *const T, Value: i32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).SetShadow(@as(*const ITextFont, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont_GetSize(self: *const T, pValue: ?*f32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).GetSize(@as(*const ITextFont, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont_SetSize(self: *const T, Value: f32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).SetSize(@as(*const ITextFont, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont_GetSmallCaps(self: *const T, pValue: ?*i32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).GetSmallCaps(@as(*const ITextFont, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont_SetSmallCaps(self: *const T, Value: i32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).SetSmallCaps(@as(*const ITextFont, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont_GetSpacing(self: *const T, pValue: ?*f32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).GetSpacing(@as(*const ITextFont, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont_SetSpacing(self: *const T, Value: f32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).SetSpacing(@as(*const ITextFont, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont_GetStrikeThrough(self: *const T, pValue: ?*i32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).GetStrikeThrough(@as(*const ITextFont, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont_SetStrikeThrough(self: *const T, Value: i32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).SetStrikeThrough(@as(*const ITextFont, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont_GetSubscript(self: *const T, pValue: ?*i32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).GetSubscript(@as(*const ITextFont, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont_SetSubscript(self: *const T, Value: i32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).SetSubscript(@as(*const ITextFont, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont_GetSuperscript(self: *const T, pValue: ?*i32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).GetSuperscript(@as(*const ITextFont, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont_SetSuperscript(self: *const T, Value: i32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).SetSuperscript(@as(*const ITextFont, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont_GetUnderline(self: *const T, pValue: ?*i32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).GetUnderline(@as(*const ITextFont, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont_SetUnderline(self: *const T, Value: i32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).SetUnderline(@as(*const ITextFont, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont_GetWeight(self: *const T, pValue: ?*i32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).GetWeight(@as(*const ITextFont, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont_SetWeight(self: *const T, Value: i32) HRESULT {
                return @as(*const ITextFont.VTable, @ptrCast(self.vtable)).SetWeight(@as(*const ITextFont, @ptrCast(self)), Value);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ITextPara_Value = Guid.initString("8cc497c4-a1df-11ce-8098-00aa0047be5d");
pub const IID_ITextPara = &IID_ITextPara_Value;
pub const ITextPara = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        GetDuplicate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextPara,
                ppPara: ?*?*ITextPara,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextPara,
                ppPara: ?*?*ITextPara,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDuplicate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextPara,
                pPara: ?*ITextPara,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextPara,
                pPara: ?*ITextPara,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CanChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextPara,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextPara,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsEqual: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextPara,
                pPara: ?*ITextPara,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextPara,
                pPara: ?*ITextPara,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextPara,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextPara,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStyle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextPara,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextPara,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetStyle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextPara,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextPara,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAlignment: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextPara,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextPara,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetAlignment: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextPara,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextPara,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetHyphenation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextPara,
                pValue: ?*tomConstants,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextPara,
                pValue: ?*tomConstants,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetHyphenation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextPara,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextPara,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFirstLineIndent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextPara,
                pValue: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextPara,
                pValue: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetKeepTogether: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextPara,
                pValue: ?*tomConstants,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextPara,
                pValue: ?*tomConstants,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetKeepTogether: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextPara,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextPara,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetKeepWithNext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextPara,
                pValue: ?*tomConstants,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextPara,
                pValue: ?*tomConstants,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetKeepWithNext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextPara,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextPara,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLeftIndent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextPara,
                pValue: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextPara,
                pValue: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLineSpacing: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextPara,
                pValue: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextPara,
                pValue: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLineSpacingRule: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextPara,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextPara,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetListAlignment: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextPara,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextPara,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetListAlignment: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextPara,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextPara,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetListLevelIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextPara,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextPara,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetListLevelIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextPara,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextPara,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetListStart: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextPara,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextPara,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetListStart: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextPara,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextPara,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetListTab: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextPara,
                pValue: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextPara,
                pValue: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetListTab: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextPara,
                Value: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextPara,
                Value: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetListType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextPara,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextPara,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetListType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextPara,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextPara,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNoLineNumber: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextPara,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextPara,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetNoLineNumber: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextPara,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextPara,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPageBreakBefore: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextPara,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextPara,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPageBreakBefore: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextPara,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextPara,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRightIndent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextPara,
                pValue: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextPara,
                pValue: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetRightIndent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextPara,
                Value: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextPara,
                Value: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetIndents: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextPara,
                First: f32,
                Left: f32,
                Right: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextPara,
                First: f32,
                Left: f32,
                Right: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetLineSpacing: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextPara,
                Rule: i32,
                Spacing: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextPara,
                Rule: i32,
                Spacing: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSpaceAfter: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextPara,
                pValue: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextPara,
                pValue: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSpaceAfter: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextPara,
                Value: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextPara,
                Value: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSpaceBefore: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextPara,
                pValue: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextPara,
                pValue: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSpaceBefore: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextPara,
                Value: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextPara,
                Value: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetWidowControl: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextPara,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextPara,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetWidowControl: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextPara,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextPara,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTabCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextPara,
                pCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextPara,
                pCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddTab: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextPara,
                tbPos: f32,
                tbAlign: i32,
                tbLeader: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextPara,
                tbPos: f32,
                tbAlign: i32,
                tbLeader: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ClearAllTabs: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextPara,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextPara,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeleteTab: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextPara,
                tbPos: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextPara,
                tbPos: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTab: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextPara,
                iTab: i32,
                ptbPos: ?*f32,
                ptbAlign: ?*i32,
                ptbLeader: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextPara,
                iTab: i32,
                ptbPos: ?*f32,
                ptbAlign: ?*i32,
                ptbLeader: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextPara_GetDuplicate(self: *const T, ppPara: ?*?*ITextPara) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).GetDuplicate(@as(*const ITextPara, @ptrCast(self)), ppPara);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextPara_SetDuplicate(self: *const T, pPara: ?*ITextPara) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).SetDuplicate(@as(*const ITextPara, @ptrCast(self)), pPara);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextPara_CanChange(self: *const T, pValue: ?*i32) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).CanChange(@as(*const ITextPara, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextPara_IsEqual(self: *const T, pPara: ?*ITextPara, pValue: ?*i32) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).IsEqual(@as(*const ITextPara, @ptrCast(self)), pPara, pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextPara_Reset(self: *const T, Value: i32) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).Reset(@as(*const ITextPara, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextPara_GetStyle(self: *const T, pValue: ?*i32) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).GetStyle(@as(*const ITextPara, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextPara_SetStyle(self: *const T, Value: i32) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).SetStyle(@as(*const ITextPara, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextPara_GetAlignment(self: *const T, pValue: ?*i32) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).GetAlignment(@as(*const ITextPara, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextPara_SetAlignment(self: *const T, Value: i32) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).SetAlignment(@as(*const ITextPara, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextPara_GetHyphenation(self: *const T, pValue: ?*tomConstants) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).GetHyphenation(@as(*const ITextPara, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextPara_SetHyphenation(self: *const T, Value: i32) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).SetHyphenation(@as(*const ITextPara, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextPara_GetFirstLineIndent(self: *const T, pValue: ?*f32) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).GetFirstLineIndent(@as(*const ITextPara, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextPara_GetKeepTogether(self: *const T, pValue: ?*tomConstants) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).GetKeepTogether(@as(*const ITextPara, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextPara_SetKeepTogether(self: *const T, Value: i32) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).SetKeepTogether(@as(*const ITextPara, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextPara_GetKeepWithNext(self: *const T, pValue: ?*tomConstants) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).GetKeepWithNext(@as(*const ITextPara, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextPara_SetKeepWithNext(self: *const T, Value: i32) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).SetKeepWithNext(@as(*const ITextPara, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextPara_GetLeftIndent(self: *const T, pValue: ?*f32) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).GetLeftIndent(@as(*const ITextPara, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextPara_GetLineSpacing(self: *const T, pValue: ?*f32) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).GetLineSpacing(@as(*const ITextPara, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextPara_GetLineSpacingRule(self: *const T, pValue: ?*i32) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).GetLineSpacingRule(@as(*const ITextPara, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextPara_GetListAlignment(self: *const T, pValue: ?*i32) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).GetListAlignment(@as(*const ITextPara, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextPara_SetListAlignment(self: *const T, Value: i32) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).SetListAlignment(@as(*const ITextPara, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextPara_GetListLevelIndex(self: *const T, pValue: ?*i32) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).GetListLevelIndex(@as(*const ITextPara, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextPara_SetListLevelIndex(self: *const T, Value: i32) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).SetListLevelIndex(@as(*const ITextPara, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextPara_GetListStart(self: *const T, pValue: ?*i32) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).GetListStart(@as(*const ITextPara, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextPara_SetListStart(self: *const T, Value: i32) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).SetListStart(@as(*const ITextPara, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextPara_GetListTab(self: *const T, pValue: ?*f32) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).GetListTab(@as(*const ITextPara, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextPara_SetListTab(self: *const T, Value: f32) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).SetListTab(@as(*const ITextPara, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextPara_GetListType(self: *const T, pValue: ?*i32) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).GetListType(@as(*const ITextPara, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextPara_SetListType(self: *const T, Value: i32) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).SetListType(@as(*const ITextPara, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextPara_GetNoLineNumber(self: *const T, pValue: ?*i32) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).GetNoLineNumber(@as(*const ITextPara, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextPara_SetNoLineNumber(self: *const T, Value: i32) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).SetNoLineNumber(@as(*const ITextPara, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextPara_GetPageBreakBefore(self: *const T, pValue: ?*i32) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).GetPageBreakBefore(@as(*const ITextPara, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextPara_SetPageBreakBefore(self: *const T, Value: i32) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).SetPageBreakBefore(@as(*const ITextPara, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextPara_GetRightIndent(self: *const T, pValue: ?*f32) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).GetRightIndent(@as(*const ITextPara, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextPara_SetRightIndent(self: *const T, Value: f32) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).SetRightIndent(@as(*const ITextPara, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextPara_SetIndents(self: *const T, First: f32, Left: f32, Right: f32) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).SetIndents(@as(*const ITextPara, @ptrCast(self)), First, Left, Right);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextPara_SetLineSpacing(self: *const T, Rule: i32, Spacing: f32) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).SetLineSpacing(@as(*const ITextPara, @ptrCast(self)), Rule, Spacing);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextPara_GetSpaceAfter(self: *const T, pValue: ?*f32) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).GetSpaceAfter(@as(*const ITextPara, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextPara_SetSpaceAfter(self: *const T, Value: f32) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).SetSpaceAfter(@as(*const ITextPara, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextPara_GetSpaceBefore(self: *const T, pValue: ?*f32) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).GetSpaceBefore(@as(*const ITextPara, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextPara_SetSpaceBefore(self: *const T, Value: f32) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).SetSpaceBefore(@as(*const ITextPara, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextPara_GetWidowControl(self: *const T, pValue: ?*i32) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).GetWidowControl(@as(*const ITextPara, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextPara_SetWidowControl(self: *const T, Value: i32) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).SetWidowControl(@as(*const ITextPara, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextPara_GetTabCount(self: *const T, pCount: ?*i32) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).GetTabCount(@as(*const ITextPara, @ptrCast(self)), pCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextPara_AddTab(self: *const T, tbPos: f32, tbAlign: i32, tbLeader: i32) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).AddTab(@as(*const ITextPara, @ptrCast(self)), tbPos, tbAlign, tbLeader);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextPara_ClearAllTabs(self: *const T) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).ClearAllTabs(@as(*const ITextPara, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextPara_DeleteTab(self: *const T, tbPos: f32) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).DeleteTab(@as(*const ITextPara, @ptrCast(self)), tbPos);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextPara_GetTab(self: *const T, iTab: i32, ptbPos: ?*f32, ptbAlign: ?*i32, ptbLeader: ?*i32) HRESULT {
                return @as(*const ITextPara.VTable, @ptrCast(self.vtable)).GetTab(@as(*const ITextPara, @ptrCast(self)), iTab, ptbPos, ptbAlign, ptbLeader);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ITextStoryRanges_Value = Guid.initString("8cc497c5-a1df-11ce-8098-00aa0047be5d");
pub const IID_ITextStoryRanges = &IID_ITextStoryRanges_Value;
pub const ITextStoryRanges = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        _NewEnum: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoryRanges,
                ppunkEnum: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoryRanges,
                ppunkEnum: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Item: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoryRanges,
                Index: i32,
                ppRange: ?*?*ITextRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoryRanges,
                Index: i32,
                ppRange: ?*?*ITextRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoryRanges,
                pCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoryRanges,
                pCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoryRanges__NewEnum(self: *const T, ppunkEnum: ?*?*IUnknown) HRESULT {
                return @as(*const ITextStoryRanges.VTable, @ptrCast(self.vtable))._NewEnum(@as(*const ITextStoryRanges, @ptrCast(self)), ppunkEnum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoryRanges_Item(self: *const T, Index: i32, ppRange: ?*?*ITextRange) HRESULT {
                return @as(*const ITextStoryRanges.VTable, @ptrCast(self.vtable)).Item(@as(*const ITextStoryRanges, @ptrCast(self)), Index, ppRange);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoryRanges_GetCount(self: *const T, pCount: ?*i32) HRESULT {
                return @as(*const ITextStoryRanges.VTable, @ptrCast(self.vtable)).GetCount(@as(*const ITextStoryRanges, @ptrCast(self)), pCount);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ITextDocument2_Value = Guid.initString("c241f5e0-7206-11d8-a2c7-00a0d1d6c6b3");
pub const IID_ITextDocument2 = &IID_ITextDocument2_Value;
pub const ITextDocument2 = extern struct {
    pub const VTable = extern struct {
        base: ITextDocument.VTable,
        GetCaretType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextDocument2,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextDocument2,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCaretType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextDocument2,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextDocument2,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDisplays: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextDocument2,
                ppDisplays: ?*?*ITextDisplays,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextDocument2,
                ppDisplays: ?*?*ITextDisplays,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDocumentFont: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextDocument2,
                ppFont: ?*?*ITextFont2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextDocument2,
                ppFont: ?*?*ITextFont2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDocumentFont: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextDocument2,
                pFont: ?*ITextFont2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextDocument2,
                pFont: ?*ITextFont2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDocumentPara: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextDocument2,
                ppPara: ?*?*ITextPara2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextDocument2,
                ppPara: ?*?*ITextPara2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDocumentPara: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextDocument2,
                pPara: ?*ITextPara2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextDocument2,
                pPara: ?*ITextPara2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEastAsianFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextDocument2,
                pFlags: ?*tomConstants,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextDocument2,
                pFlags: ?*tomConstants,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetGenerator: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextDocument2,
                pbstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextDocument2,
                pbstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetIMEInProgress: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextDocument2,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextDocument2,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNotificationMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextDocument2,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextDocument2,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetNotificationMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextDocument2,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextDocument2,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSelection2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextDocument2,
                ppSel: ?*?*ITextSelection2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextDocument2,
                ppSel: ?*?*ITextSelection2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStoryRanges2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextDocument2,
                ppStories: ?*?*ITextStoryRanges2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextDocument2,
                ppStories: ?*?*ITextStoryRanges2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTypographyOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextDocument2,
                pOptions: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextDocument2,
                pOptions: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVersion: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextDocument2,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextDocument2,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetWindow: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextDocument2,
                pHwnd: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextDocument2,
                pHwnd: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AttachMsgFilter: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextDocument2,
                pFilter: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextDocument2,
                pFilter: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CheckTextLimit: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextDocument2,
                cch: i32,
                pcch: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextDocument2,
                cch: i32,
                pcch: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCallManager: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextDocument2,
                ppVoid: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextDocument2,
                ppVoid: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetClientRect: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextDocument2,
                Type: tomConstants,
                pLeft: ?*i32,
                pTop: ?*i32,
                pRight: ?*i32,
                pBottom: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextDocument2,
                Type: tomConstants,
                pLeft: ?*i32,
                pTop: ?*i32,
                pRight: ?*i32,
                pBottom: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEffectColor: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextDocument2,
                Index: i32,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextDocument2,
                Index: i32,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetImmContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextDocument2,
                pContext: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextDocument2,
                pContext: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPreferredFont: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextDocument2,
                cp: i32,
                CharRep: i32,
                Options: i32,
                curCharRep: i32,
                curFontSize: i32,
                pbstr: ?*?BSTR,
                pPitchAndFamily: ?*i32,
                pNewFontSize: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextDocument2,
                cp: i32,
                CharRep: i32,
                Options: i32,
                curCharRep: i32,
                curFontSize: i32,
                pbstr: ?*?BSTR,
                pPitchAndFamily: ?*i32,
                pNewFontSize: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextDocument2,
                Type: i32,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextDocument2,
                Type: i32,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStrings: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextDocument2,
                ppStrs: ?*?*ITextStrings,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextDocument2,
                ppStrs: ?*?*ITextStrings,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Notify: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextDocument2,
                Notify: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextDocument2,
                Notify: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Range2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextDocument2,
                cpActive: i32,
                cpAnchor: i32,
                ppRange: ?*?*ITextRange2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextDocument2,
                cpActive: i32,
                cpAnchor: i32,
                ppRange: ?*?*ITextRange2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RangeFromPoint2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextDocument2,
                x: i32,
                y: i32,
                Type: i32,
                ppRange: ?*?*ITextRange2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextDocument2,
                x: i32,
                y: i32,
                Type: i32,
                ppRange: ?*?*ITextRange2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReleaseCallManager: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextDocument2,
                pVoid: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextDocument2,
                pVoid: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReleaseImmContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextDocument2,
                Context: i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextDocument2,
                Context: i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEffectColor: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextDocument2,
                Index: i32,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextDocument2,
                Index: i32,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextDocument2,
                Type: i32,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextDocument2,
                Type: i32,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTypographyOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextDocument2,
                Options: i32,
                Mask: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextDocument2,
                Options: i32,
                Mask: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SysBeep: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextDocument2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextDocument2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Update: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextDocument2,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextDocument2,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UpdateWindow: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextDocument2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextDocument2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMathProperties: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextDocument2,
                pOptions: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextDocument2,
                pOptions: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetMathProperties: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextDocument2,
                Options: i32,
                Mask: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextDocument2,
                Options: i32,
                Mask: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetActiveStory: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextDocument2,
                ppStory: ?*?*ITextStory,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextDocument2,
                ppStory: ?*?*ITextStory,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetActiveStory: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextDocument2,
                pStory: ?*ITextStory,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextDocument2,
                pStory: ?*ITextStory,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMainStory: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextDocument2,
                ppStory: ?*?*ITextStory,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextDocument2,
                ppStory: ?*?*ITextStory,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNewStory: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextDocument2,
                ppStory: ?*?*ITextStory,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextDocument2,
                ppStory: ?*?*ITextStory,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStory: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextDocument2,
                Index: i32,
                ppStory: ?*?*ITextStory,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextDocument2,
                Index: i32,
                ppStory: ?*?*ITextStory,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITextDocument.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextDocument2_GetCaretType(self: *const T, pValue: ?*i32) HRESULT {
                return @as(*const ITextDocument2.VTable, @ptrCast(self.vtable)).GetCaretType(@as(*const ITextDocument2, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextDocument2_SetCaretType(self: *const T, Value: i32) HRESULT {
                return @as(*const ITextDocument2.VTable, @ptrCast(self.vtable)).SetCaretType(@as(*const ITextDocument2, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextDocument2_GetDisplays(self: *const T, ppDisplays: ?*?*ITextDisplays) HRESULT {
                return @as(*const ITextDocument2.VTable, @ptrCast(self.vtable)).GetDisplays(@as(*const ITextDocument2, @ptrCast(self)), ppDisplays);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextDocument2_GetDocumentFont(self: *const T, ppFont: ?*?*ITextFont2) HRESULT {
                return @as(*const ITextDocument2.VTable, @ptrCast(self.vtable)).GetDocumentFont(@as(*const ITextDocument2, @ptrCast(self)), ppFont);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextDocument2_SetDocumentFont(self: *const T, pFont: ?*ITextFont2) HRESULT {
                return @as(*const ITextDocument2.VTable, @ptrCast(self.vtable)).SetDocumentFont(@as(*const ITextDocument2, @ptrCast(self)), pFont);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextDocument2_GetDocumentPara(self: *const T, ppPara: ?*?*ITextPara2) HRESULT {
                return @as(*const ITextDocument2.VTable, @ptrCast(self.vtable)).GetDocumentPara(@as(*const ITextDocument2, @ptrCast(self)), ppPara);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextDocument2_SetDocumentPara(self: *const T, pPara: ?*ITextPara2) HRESULT {
                return @as(*const ITextDocument2.VTable, @ptrCast(self.vtable)).SetDocumentPara(@as(*const ITextDocument2, @ptrCast(self)), pPara);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextDocument2_GetEastAsianFlags(self: *const T, pFlags: ?*tomConstants) HRESULT {
                return @as(*const ITextDocument2.VTable, @ptrCast(self.vtable)).GetEastAsianFlags(@as(*const ITextDocument2, @ptrCast(self)), pFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextDocument2_GetGenerator(self: *const T, pbstr: ?*?BSTR) HRESULT {
                return @as(*const ITextDocument2.VTable, @ptrCast(self.vtable)).GetGenerator(@as(*const ITextDocument2, @ptrCast(self)), pbstr);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextDocument2_SetIMEInProgress(self: *const T, Value: i32) HRESULT {
                return @as(*const ITextDocument2.VTable, @ptrCast(self.vtable)).SetIMEInProgress(@as(*const ITextDocument2, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextDocument2_GetNotificationMode(self: *const T, pValue: ?*i32) HRESULT {
                return @as(*const ITextDocument2.VTable, @ptrCast(self.vtable)).GetNotificationMode(@as(*const ITextDocument2, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextDocument2_SetNotificationMode(self: *const T, Value: i32) HRESULT {
                return @as(*const ITextDocument2.VTable, @ptrCast(self.vtable)).SetNotificationMode(@as(*const ITextDocument2, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextDocument2_GetSelection2(self: *const T, ppSel: ?*?*ITextSelection2) HRESULT {
                return @as(*const ITextDocument2.VTable, @ptrCast(self.vtable)).GetSelection2(@as(*const ITextDocument2, @ptrCast(self)), ppSel);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextDocument2_GetStoryRanges2(self: *const T, ppStories: ?*?*ITextStoryRanges2) HRESULT {
                return @as(*const ITextDocument2.VTable, @ptrCast(self.vtable)).GetStoryRanges2(@as(*const ITextDocument2, @ptrCast(self)), ppStories);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextDocument2_GetTypographyOptions(self: *const T, pOptions: ?*i32) HRESULT {
                return @as(*const ITextDocument2.VTable, @ptrCast(self.vtable)).GetTypographyOptions(@as(*const ITextDocument2, @ptrCast(self)), pOptions);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextDocument2_GetVersion(self: *const T, pValue: ?*i32) HRESULT {
                return @as(*const ITextDocument2.VTable, @ptrCast(self.vtable)).GetVersion(@as(*const ITextDocument2, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextDocument2_GetWindow(self: *const T, pHwnd: ?*i64) HRESULT {
                return @as(*const ITextDocument2.VTable, @ptrCast(self.vtable)).GetWindow(@as(*const ITextDocument2, @ptrCast(self)), pHwnd);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextDocument2_AttachMsgFilter(self: *const T, pFilter: ?*IUnknown) HRESULT {
                return @as(*const ITextDocument2.VTable, @ptrCast(self.vtable)).AttachMsgFilter(@as(*const ITextDocument2, @ptrCast(self)), pFilter);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextDocument2_CheckTextLimit(self: *const T, cch: i32, pcch: ?*i32) HRESULT {
                return @as(*const ITextDocument2.VTable, @ptrCast(self.vtable)).CheckTextLimit(@as(*const ITextDocument2, @ptrCast(self)), cch, pcch);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextDocument2_GetCallManager(self: *const T, ppVoid: ?*?*IUnknown) HRESULT {
                return @as(*const ITextDocument2.VTable, @ptrCast(self.vtable)).GetCallManager(@as(*const ITextDocument2, @ptrCast(self)), ppVoid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextDocument2_GetClientRect(self: *const T, Type: tomConstants, pLeft: ?*i32, pTop: ?*i32, pRight: ?*i32, pBottom: ?*i32) HRESULT {
                return @as(*const ITextDocument2.VTable, @ptrCast(self.vtable)).GetClientRect(@as(*const ITextDocument2, @ptrCast(self)), Type, pLeft, pTop, pRight, pBottom);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextDocument2_GetEffectColor(self: *const T, Index: i32, pValue: ?*i32) HRESULT {
                return @as(*const ITextDocument2.VTable, @ptrCast(self.vtable)).GetEffectColor(@as(*const ITextDocument2, @ptrCast(self)), Index, pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextDocument2_GetImmContext(self: *const T, pContext: ?*i64) HRESULT {
                return @as(*const ITextDocument2.VTable, @ptrCast(self.vtable)).GetImmContext(@as(*const ITextDocument2, @ptrCast(self)), pContext);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextDocument2_GetPreferredFont(self: *const T, cp: i32, CharRep: i32, Options: i32, curCharRep: i32, curFontSize: i32, pbstr: ?*?BSTR, pPitchAndFamily: ?*i32, pNewFontSize: ?*i32) HRESULT {
                return @as(*const ITextDocument2.VTable, @ptrCast(self.vtable)).GetPreferredFont(@as(*const ITextDocument2, @ptrCast(self)), cp, CharRep, Options, curCharRep, curFontSize, pbstr, pPitchAndFamily, pNewFontSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextDocument2_GetProperty(self: *const T, Type: i32, pValue: ?*i32) HRESULT {
                return @as(*const ITextDocument2.VTable, @ptrCast(self.vtable)).GetProperty(@as(*const ITextDocument2, @ptrCast(self)), Type, pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextDocument2_GetStrings(self: *const T, ppStrs: ?*?*ITextStrings) HRESULT {
                return @as(*const ITextDocument2.VTable, @ptrCast(self.vtable)).GetStrings(@as(*const ITextDocument2, @ptrCast(self)), ppStrs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextDocument2_Notify(self: *const T, Notify: i32) HRESULT {
                return @as(*const ITextDocument2.VTable, @ptrCast(self.vtable)).Notify(@as(*const ITextDocument2, @ptrCast(self)), Notify);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextDocument2_Range2(self: *const T, cpActive: i32, cpAnchor: i32, ppRange: ?*?*ITextRange2) HRESULT {
                return @as(*const ITextDocument2.VTable, @ptrCast(self.vtable)).Range2(@as(*const ITextDocument2, @ptrCast(self)), cpActive, cpAnchor, ppRange);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextDocument2_RangeFromPoint2(self: *const T, x: i32, y: i32, Type: i32, ppRange: ?*?*ITextRange2) HRESULT {
                return @as(*const ITextDocument2.VTable, @ptrCast(self.vtable)).RangeFromPoint2(@as(*const ITextDocument2, @ptrCast(self)), x, y, Type, ppRange);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextDocument2_ReleaseCallManager(self: *const T, pVoid: ?*IUnknown) HRESULT {
                return @as(*const ITextDocument2.VTable, @ptrCast(self.vtable)).ReleaseCallManager(@as(*const ITextDocument2, @ptrCast(self)), pVoid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextDocument2_ReleaseImmContext(self: *const T, Context: i64) HRESULT {
                return @as(*const ITextDocument2.VTable, @ptrCast(self.vtable)).ReleaseImmContext(@as(*const ITextDocument2, @ptrCast(self)), Context);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextDocument2_SetEffectColor(self: *const T, Index: i32, Value: i32) HRESULT {
                return @as(*const ITextDocument2.VTable, @ptrCast(self.vtable)).SetEffectColor(@as(*const ITextDocument2, @ptrCast(self)), Index, Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextDocument2_SetProperty(self: *const T, Type: i32, Value: i32) HRESULT {
                return @as(*const ITextDocument2.VTable, @ptrCast(self.vtable)).SetProperty(@as(*const ITextDocument2, @ptrCast(self)), Type, Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextDocument2_SetTypographyOptions(self: *const T, Options: i32, Mask: i32) HRESULT {
                return @as(*const ITextDocument2.VTable, @ptrCast(self.vtable)).SetTypographyOptions(@as(*const ITextDocument2, @ptrCast(self)), Options, Mask);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextDocument2_SysBeep(self: *const T) HRESULT {
                return @as(*const ITextDocument2.VTable, @ptrCast(self.vtable)).SysBeep(@as(*const ITextDocument2, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextDocument2_Update(self: *const T, Value: i32) HRESULT {
                return @as(*const ITextDocument2.VTable, @ptrCast(self.vtable)).Update(@as(*const ITextDocument2, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextDocument2_UpdateWindow(self: *const T) HRESULT {
                return @as(*const ITextDocument2.VTable, @ptrCast(self.vtable)).UpdateWindow(@as(*const ITextDocument2, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextDocument2_GetMathProperties(self: *const T, pOptions: ?*i32) HRESULT {
                return @as(*const ITextDocument2.VTable, @ptrCast(self.vtable)).GetMathProperties(@as(*const ITextDocument2, @ptrCast(self)), pOptions);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextDocument2_SetMathProperties(self: *const T, Options: i32, Mask: i32) HRESULT {
                return @as(*const ITextDocument2.VTable, @ptrCast(self.vtable)).SetMathProperties(@as(*const ITextDocument2, @ptrCast(self)), Options, Mask);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextDocument2_GetActiveStory(self: *const T, ppStory: ?*?*ITextStory) HRESULT {
                return @as(*const ITextDocument2.VTable, @ptrCast(self.vtable)).GetActiveStory(@as(*const ITextDocument2, @ptrCast(self)), ppStory);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextDocument2_SetActiveStory(self: *const T, pStory: ?*ITextStory) HRESULT {
                return @as(*const ITextDocument2.VTable, @ptrCast(self.vtable)).SetActiveStory(@as(*const ITextDocument2, @ptrCast(self)), pStory);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextDocument2_GetMainStory(self: *const T, ppStory: ?*?*ITextStory) HRESULT {
                return @as(*const ITextDocument2.VTable, @ptrCast(self.vtable)).GetMainStory(@as(*const ITextDocument2, @ptrCast(self)), ppStory);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextDocument2_GetNewStory(self: *const T, ppStory: ?*?*ITextStory) HRESULT {
                return @as(*const ITextDocument2.VTable, @ptrCast(self.vtable)).GetNewStory(@as(*const ITextDocument2, @ptrCast(self)), ppStory);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextDocument2_GetStory(self: *const T, Index: i32, ppStory: ?*?*ITextStory) HRESULT {
                return @as(*const ITextDocument2.VTable, @ptrCast(self.vtable)).GetStory(@as(*const ITextDocument2, @ptrCast(self)), Index, ppStory);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ITextRange2_Value = Guid.initString("c241f5e2-7206-11d8-a2c7-00a0d1d6c6b3");
pub const IID_ITextRange2 = &IID_ITextRange2_Value;
pub const ITextRange2 = extern struct {
    pub const VTable = extern struct {
        base: ITextSelection.VTable,
        GetCch: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRange2,
                pcch: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRange2,
                pcch: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCells: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRange2,
                ppCells: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRange2,
                ppCells: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetColumn: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRange2,
                ppColumn: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRange2,
                ppColumn: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRange2,
                pCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRange2,
                pCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDuplicate2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRange2,
                ppRange: ?*?*ITextRange2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRange2,
                ppRange: ?*?*ITextRange2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFont2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRange2,
                ppFont: ?*?*ITextFont2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRange2,
                ppFont: ?*?*ITextFont2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFont2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRange2,
                pFont: ?*ITextFont2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRange2,
                pFont: ?*ITextFont2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFormattedText2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRange2,
                ppRange: ?*?*ITextRange2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRange2,
                ppRange: ?*?*ITextRange2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFormattedText2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRange2,
                pRange: ?*ITextRange2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRange2,
                pRange: ?*ITextRange2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetGravity: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRange2,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRange2,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetGravity: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRange2,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRange2,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPara2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRange2,
                ppPara: ?*?*ITextPara2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRange2,
                ppPara: ?*?*ITextPara2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPara2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRange2,
                pPara: ?*ITextPara2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRange2,
                pPara: ?*ITextPara2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRow: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRange2,
                ppRow: ?*?*ITextRow,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRange2,
                ppRow: ?*?*ITextRow,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStartPara: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRange2,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRange2,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTable: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRange2,
                ppTable: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRange2,
                ppTable: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetURL: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRange2,
                pbstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRange2,
                pbstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetURL: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRange2,
                bstr: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRange2,
                bstr: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddSubrange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRange2,
                cp1: i32,
                cp2: i32,
                Activate: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRange2,
                cp1: i32,
                cp2: i32,
                Activate: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BuildUpMath: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRange2,
                Flags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRange2,
                Flags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeleteSubrange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRange2,
                cpFirst: i32,
                cpLim: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRange2,
                cpFirst: i32,
                cpLim: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Find: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRange2,
                pRange: ?*ITextRange2,
                Count: i32,
                Flags: i32,
                pDelta: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRange2,
                pRange: ?*ITextRange2,
                Count: i32,
                Flags: i32,
                pDelta: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetChar2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRange2,
                pChar: ?*i32,
                Offset: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRange2,
                pChar: ?*i32,
                Offset: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDropCap: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRange2,
                pcLine: ?*i32,
                pPosition: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRange2,
                pcLine: ?*i32,
                pPosition: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInlineObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRange2,
                pType: ?*i32,
                pAlign: ?*i32,
                pChar: ?*i32,
                pChar1: ?*i32,
                pChar2: ?*i32,
                pCount: ?*i32,
                pTeXStyle: ?*i32,
                pcCol: ?*i32,
                pLevel: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRange2,
                pType: ?*i32,
                pAlign: ?*i32,
                pChar: ?*i32,
                pChar1: ?*i32,
                pChar2: ?*i32,
                pCount: ?*i32,
                pTeXStyle: ?*i32,
                pcCol: ?*i32,
                pLevel: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRange2,
                Type: i32,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRange2,
                Type: i32,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRect: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRange2,
                Type: i32,
                pLeft: ?*i32,
                pTop: ?*i32,
                pRight: ?*i32,
                pBottom: ?*i32,
                pHit: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRange2,
                Type: i32,
                pLeft: ?*i32,
                pTop: ?*i32,
                pRight: ?*i32,
                pBottom: ?*i32,
                pHit: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSubrange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRange2,
                iSubrange: i32,
                pcpFirst: ?*i32,
                pcpLim: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRange2,
                iSubrange: i32,
                pcpFirst: ?*i32,
                pcpLim: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetText2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRange2,
                Flags: i32,
                pbstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRange2,
                Flags: i32,
                pbstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        HexToUnicode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRange2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRange2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InsertTable: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRange2,
                cCol: i32,
                cRow: i32,
                AutoFit: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRange2,
                cCol: i32,
                cRow: i32,
                AutoFit: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Linearize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRange2,
                Flags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRange2,
                Flags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetActiveSubrange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRange2,
                cpAnchor: i32,
                cpActive: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRange2,
                cpAnchor: i32,
                cpActive: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDropCap: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRange2,
                cLine: i32,
                Position: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRange2,
                cLine: i32,
                Position: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRange2,
                Type: i32,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRange2,
                Type: i32,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetText2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRange2,
                Flags: i32,
                bstr: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRange2,
                Flags: i32,
                bstr: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnicodeToHex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRange2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRange2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetInlineObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRange2,
                Type: i32,
                Align: i32,
                Char: i32,
                Char1: i32,
                Char2: i32,
                Count: i32,
                TeXStyle: i32,
                cCol: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRange2,
                Type: i32,
                Align: i32,
                Char: i32,
                Char1: i32,
                Char2: i32,
                Count: i32,
                TeXStyle: i32,
                cCol: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMathFunctionType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRange2,
                bstr: ?BSTR,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRange2,
                bstr: ?BSTR,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InsertImage: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRange2,
                width: i32,
                height: i32,
                ascent: i32,
                Type: TEXT_ALIGN_OPTIONS,
                bstrAltText: ?BSTR,
                pStream: ?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRange2,
                width: i32,
                height: i32,
                ascent: i32,
                Type: TEXT_ALIGN_OPTIONS,
                bstrAltText: ?BSTR,
                pStream: ?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITextSelection.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRange2_GetCch(self: *const T, pcch: ?*i32) HRESULT {
                return @as(*const ITextRange2.VTable, @ptrCast(self.vtable)).GetCch(@as(*const ITextRange2, @ptrCast(self)), pcch);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRange2_GetCells(self: *const T, ppCells: ?*?*IUnknown) HRESULT {
                return @as(*const ITextRange2.VTable, @ptrCast(self.vtable)).GetCells(@as(*const ITextRange2, @ptrCast(self)), ppCells);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRange2_GetColumn(self: *const T, ppColumn: ?*?*IUnknown) HRESULT {
                return @as(*const ITextRange2.VTable, @ptrCast(self.vtable)).GetColumn(@as(*const ITextRange2, @ptrCast(self)), ppColumn);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRange2_GetCount(self: *const T, pCount: ?*i32) HRESULT {
                return @as(*const ITextRange2.VTable, @ptrCast(self.vtable)).GetCount(@as(*const ITextRange2, @ptrCast(self)), pCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRange2_GetDuplicate2(self: *const T, ppRange: ?*?*ITextRange2) HRESULT {
                return @as(*const ITextRange2.VTable, @ptrCast(self.vtable)).GetDuplicate2(@as(*const ITextRange2, @ptrCast(self)), ppRange);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRange2_GetFont2(self: *const T, ppFont: ?*?*ITextFont2) HRESULT {
                return @as(*const ITextRange2.VTable, @ptrCast(self.vtable)).GetFont2(@as(*const ITextRange2, @ptrCast(self)), ppFont);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRange2_SetFont2(self: *const T, pFont: ?*ITextFont2) HRESULT {
                return @as(*const ITextRange2.VTable, @ptrCast(self.vtable)).SetFont2(@as(*const ITextRange2, @ptrCast(self)), pFont);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRange2_GetFormattedText2(self: *const T, ppRange: ?*?*ITextRange2) HRESULT {
                return @as(*const ITextRange2.VTable, @ptrCast(self.vtable)).GetFormattedText2(@as(*const ITextRange2, @ptrCast(self)), ppRange);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRange2_SetFormattedText2(self: *const T, pRange: ?*ITextRange2) HRESULT {
                return @as(*const ITextRange2.VTable, @ptrCast(self.vtable)).SetFormattedText2(@as(*const ITextRange2, @ptrCast(self)), pRange);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRange2_GetGravity(self: *const T, pValue: ?*i32) HRESULT {
                return @as(*const ITextRange2.VTable, @ptrCast(self.vtable)).GetGravity(@as(*const ITextRange2, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRange2_SetGravity(self: *const T, Value: i32) HRESULT {
                return @as(*const ITextRange2.VTable, @ptrCast(self.vtable)).SetGravity(@as(*const ITextRange2, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRange2_GetPara2(self: *const T, ppPara: ?*?*ITextPara2) HRESULT {
                return @as(*const ITextRange2.VTable, @ptrCast(self.vtable)).GetPara2(@as(*const ITextRange2, @ptrCast(self)), ppPara);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRange2_SetPara2(self: *const T, pPara: ?*ITextPara2) HRESULT {
                return @as(*const ITextRange2.VTable, @ptrCast(self.vtable)).SetPara2(@as(*const ITextRange2, @ptrCast(self)), pPara);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRange2_GetRow(self: *const T, ppRow: ?*?*ITextRow) HRESULT {
                return @as(*const ITextRange2.VTable, @ptrCast(self.vtable)).GetRow(@as(*const ITextRange2, @ptrCast(self)), ppRow);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRange2_GetStartPara(self: *const T, pValue: ?*i32) HRESULT {
                return @as(*const ITextRange2.VTable, @ptrCast(self.vtable)).GetStartPara(@as(*const ITextRange2, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRange2_GetTable(self: *const T, ppTable: ?*?*IUnknown) HRESULT {
                return @as(*const ITextRange2.VTable, @ptrCast(self.vtable)).GetTable(@as(*const ITextRange2, @ptrCast(self)), ppTable);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRange2_GetURL(self: *const T, pbstr: ?*?BSTR) HRESULT {
                return @as(*const ITextRange2.VTable, @ptrCast(self.vtable)).GetURL(@as(*const ITextRange2, @ptrCast(self)), pbstr);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRange2_SetURL(self: *const T, bstr: ?BSTR) HRESULT {
                return @as(*const ITextRange2.VTable, @ptrCast(self.vtable)).SetURL(@as(*const ITextRange2, @ptrCast(self)), bstr);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRange2_AddSubrange(self: *const T, cp1: i32, cp2: i32, Activate: i32) HRESULT {
                return @as(*const ITextRange2.VTable, @ptrCast(self.vtable)).AddSubrange(@as(*const ITextRange2, @ptrCast(self)), cp1, cp2, Activate);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRange2_BuildUpMath(self: *const T, Flags: i32) HRESULT {
                return @as(*const ITextRange2.VTable, @ptrCast(self.vtable)).BuildUpMath(@as(*const ITextRange2, @ptrCast(self)), Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRange2_DeleteSubrange(self: *const T, cpFirst: i32, cpLim: i32) HRESULT {
                return @as(*const ITextRange2.VTable, @ptrCast(self.vtable)).DeleteSubrange(@as(*const ITextRange2, @ptrCast(self)), cpFirst, cpLim);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRange2_Find(self: *const T, pRange: ?*ITextRange2, Count: i32, Flags: i32, pDelta: ?*i32) HRESULT {
                return @as(*const ITextRange2.VTable, @ptrCast(self.vtable)).Find(@as(*const ITextRange2, @ptrCast(self)), pRange, Count, Flags, pDelta);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRange2_GetChar2(self: *const T, pChar: ?*i32, Offset: i32) HRESULT {
                return @as(*const ITextRange2.VTable, @ptrCast(self.vtable)).GetChar2(@as(*const ITextRange2, @ptrCast(self)), pChar, Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRange2_GetDropCap(self: *const T, pcLine: ?*i32, pPosition: ?*i32) HRESULT {
                return @as(*const ITextRange2.VTable, @ptrCast(self.vtable)).GetDropCap(@as(*const ITextRange2, @ptrCast(self)), pcLine, pPosition);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRange2_GetInlineObject(self: *const T, pType: ?*i32, pAlign: ?*i32, pChar: ?*i32, pChar1: ?*i32, pChar2: ?*i32, pCount: ?*i32, pTeXStyle: ?*i32, pcCol: ?*i32, pLevel: ?*i32) HRESULT {
                return @as(*const ITextRange2.VTable, @ptrCast(self.vtable)).GetInlineObject(@as(*const ITextRange2, @ptrCast(self)), pType, pAlign, pChar, pChar1, pChar2, pCount, pTeXStyle, pcCol, pLevel);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRange2_GetProperty(self: *const T, Type: i32, pValue: ?*i32) HRESULT {
                return @as(*const ITextRange2.VTable, @ptrCast(self.vtable)).GetProperty(@as(*const ITextRange2, @ptrCast(self)), Type, pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRange2_GetRect(self: *const T, Type: i32, pLeft: ?*i32, pTop: ?*i32, pRight: ?*i32, pBottom: ?*i32, pHit: ?*i32) HRESULT {
                return @as(*const ITextRange2.VTable, @ptrCast(self.vtable)).GetRect(@as(*const ITextRange2, @ptrCast(self)), Type, pLeft, pTop, pRight, pBottom, pHit);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRange2_GetSubrange(self: *const T, iSubrange: i32, pcpFirst: ?*i32, pcpLim: ?*i32) HRESULT {
                return @as(*const ITextRange2.VTable, @ptrCast(self.vtable)).GetSubrange(@as(*const ITextRange2, @ptrCast(self)), iSubrange, pcpFirst, pcpLim);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRange2_GetText2(self: *const T, Flags: i32, pbstr: ?*?BSTR) HRESULT {
                return @as(*const ITextRange2.VTable, @ptrCast(self.vtable)).GetText2(@as(*const ITextRange2, @ptrCast(self)), Flags, pbstr);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRange2_HexToUnicode(self: *const T) HRESULT {
                return @as(*const ITextRange2.VTable, @ptrCast(self.vtable)).HexToUnicode(@as(*const ITextRange2, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRange2_InsertTable(self: *const T, cCol: i32, cRow: i32, AutoFit: i32) HRESULT {
                return @as(*const ITextRange2.VTable, @ptrCast(self.vtable)).InsertTable(@as(*const ITextRange2, @ptrCast(self)), cCol, cRow, AutoFit);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRange2_Linearize(self: *const T, Flags: i32) HRESULT {
                return @as(*const ITextRange2.VTable, @ptrCast(self.vtable)).Linearize(@as(*const ITextRange2, @ptrCast(self)), Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRange2_SetActiveSubrange(self: *const T, cpAnchor: i32, cpActive: i32) HRESULT {
                return @as(*const ITextRange2.VTable, @ptrCast(self.vtable)).SetActiveSubrange(@as(*const ITextRange2, @ptrCast(self)), cpAnchor, cpActive);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRange2_SetDropCap(self: *const T, cLine: i32, Position: i32) HRESULT {
                return @as(*const ITextRange2.VTable, @ptrCast(self.vtable)).SetDropCap(@as(*const ITextRange2, @ptrCast(self)), cLine, Position);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRange2_SetProperty(self: *const T, Type: i32, Value: i32) HRESULT {
                return @as(*const ITextRange2.VTable, @ptrCast(self.vtable)).SetProperty(@as(*const ITextRange2, @ptrCast(self)), Type, Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRange2_SetText2(self: *const T, Flags: i32, bstr: ?BSTR) HRESULT {
                return @as(*const ITextRange2.VTable, @ptrCast(self.vtable)).SetText2(@as(*const ITextRange2, @ptrCast(self)), Flags, bstr);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRange2_UnicodeToHex(self: *const T) HRESULT {
                return @as(*const ITextRange2.VTable, @ptrCast(self.vtable)).UnicodeToHex(@as(*const ITextRange2, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRange2_SetInlineObject(self: *const T, Type: i32, Align: i32, Char: i32, Char1: i32, Char2: i32, Count: i32, TeXStyle: i32, cCol: i32) HRESULT {
                return @as(*const ITextRange2.VTable, @ptrCast(self.vtable)).SetInlineObject(@as(*const ITextRange2, @ptrCast(self)), Type, Align, Char, Char1, Char2, Count, TeXStyle, cCol);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRange2_GetMathFunctionType(self: *const T, bstr: ?BSTR, pValue: ?*i32) HRESULT {
                return @as(*const ITextRange2.VTable, @ptrCast(self.vtable)).GetMathFunctionType(@as(*const ITextRange2, @ptrCast(self)), bstr, pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRange2_InsertImage(self: *const T, width: i32, height: i32, ascent: i32, Type: TEXT_ALIGN_OPTIONS, bstrAltText: ?BSTR, pStream: ?*IStream) HRESULT {
                return @as(*const ITextRange2.VTable, @ptrCast(self.vtable)).InsertImage(@as(*const ITextRange2, @ptrCast(self)), width, height, ascent, Type, bstrAltText, pStream);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ITextSelection2_Value = Guid.initString("c241f5e1-7206-11d8-a2c7-00a0d1d6c6b3");
pub const IID_ITextSelection2 = &IID_ITextSelection2_Value;
pub const ITextSelection2 = extern struct {
    pub const VTable = extern struct {
        base: ITextRange2.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITextRange2.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ITextFont2_Value = Guid.initString("c241f5e3-7206-11d8-a2c7-00a0d1d6c6b3");
pub const IID_ITextFont2 = &IID_ITextFont2_Value;
pub const ITextFont2 = extern struct {
    pub const VTable = extern struct {
        base: ITextFont.VTable,
        GetCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont2,
                pCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont2,
                pCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAutoLigatures: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont2,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont2,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetAutoLigatures: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont2,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont2,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAutospaceAlpha: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont2,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont2,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetAutospaceAlpha: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont2,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont2,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAutospaceNumeric: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont2,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont2,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetAutospaceNumeric: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont2,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont2,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAutospaceParens: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont2,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont2,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetAutospaceParens: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont2,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont2,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCharRep: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont2,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont2,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCharRep: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont2,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont2,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCompressionMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont2,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont2,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCompressionMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont2,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont2,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCookie: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont2,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont2,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCookie: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont2,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont2,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDoubleStrike: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont2,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont2,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDoubleStrike: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont2,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont2,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDuplicate2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont2,
                ppFont: ?*?*ITextFont2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont2,
                ppFont: ?*?*ITextFont2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDuplicate2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont2,
                pFont: ?*ITextFont2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont2,
                pFont: ?*ITextFont2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLinkType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont2,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont2,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMathZone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont2,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont2,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetMathZone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont2,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont2,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModWidthPairs: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont2,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont2,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetModWidthPairs: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont2,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont2,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModWidthSpace: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont2,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont2,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetModWidthSpace: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont2,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont2,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOldNumbers: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont2,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont2,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOldNumbers: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont2,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont2,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOverlapping: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont2,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont2,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOverlapping: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont2,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont2,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPositionSubSuper: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont2,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont2,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPositionSubSuper: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont2,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont2,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetScaling: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont2,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont2,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetScaling: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont2,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont2,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSpaceExtension: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont2,
                pValue: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont2,
                pValue: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSpaceExtension: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont2,
                Value: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont2,
                Value: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetUnderlinePositionMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont2,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont2,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetUnderlinePositionMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont2,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont2,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEffects: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont2,
                pValue: ?*i32,
                pMask: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont2,
                pValue: ?*i32,
                pMask: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEffects2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont2,
                pValue: ?*i32,
                pMask: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont2,
                pValue: ?*i32,
                pMask: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont2,
                Type: i32,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont2,
                Type: i32,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPropertyInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont2,
                Index: i32,
                pType: ?*i32,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont2,
                Index: i32,
                pType: ?*i32,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsEqual2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont2,
                pFont: ?*ITextFont2,
                pB: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont2,
                pFont: ?*ITextFont2,
                pB: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEffects: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont2,
                Value: i32,
                Mask: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont2,
                Value: i32,
                Mask: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEffects2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont2,
                Value: i32,
                Mask: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont2,
                Value: i32,
                Mask: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextFont2,
                Type: i32,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextFont2,
                Type: i32,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITextFont.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont2_GetCount(self: *const T, pCount: ?*i32) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).GetCount(@as(*const ITextFont2, @ptrCast(self)), pCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont2_GetAutoLigatures(self: *const T, pValue: ?*i32) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).GetAutoLigatures(@as(*const ITextFont2, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont2_SetAutoLigatures(self: *const T, Value: i32) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).SetAutoLigatures(@as(*const ITextFont2, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont2_GetAutospaceAlpha(self: *const T, pValue: ?*i32) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).GetAutospaceAlpha(@as(*const ITextFont2, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont2_SetAutospaceAlpha(self: *const T, Value: i32) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).SetAutospaceAlpha(@as(*const ITextFont2, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont2_GetAutospaceNumeric(self: *const T, pValue: ?*i32) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).GetAutospaceNumeric(@as(*const ITextFont2, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont2_SetAutospaceNumeric(self: *const T, Value: i32) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).SetAutospaceNumeric(@as(*const ITextFont2, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont2_GetAutospaceParens(self: *const T, pValue: ?*i32) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).GetAutospaceParens(@as(*const ITextFont2, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont2_SetAutospaceParens(self: *const T, Value: i32) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).SetAutospaceParens(@as(*const ITextFont2, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont2_GetCharRep(self: *const T, pValue: ?*i32) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).GetCharRep(@as(*const ITextFont2, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont2_SetCharRep(self: *const T, Value: i32) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).SetCharRep(@as(*const ITextFont2, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont2_GetCompressionMode(self: *const T, pValue: ?*i32) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).GetCompressionMode(@as(*const ITextFont2, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont2_SetCompressionMode(self: *const T, Value: i32) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).SetCompressionMode(@as(*const ITextFont2, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont2_GetCookie(self: *const T, pValue: ?*i32) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).GetCookie(@as(*const ITextFont2, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont2_SetCookie(self: *const T, Value: i32) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).SetCookie(@as(*const ITextFont2, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont2_GetDoubleStrike(self: *const T, pValue: ?*i32) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).GetDoubleStrike(@as(*const ITextFont2, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont2_SetDoubleStrike(self: *const T, Value: i32) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).SetDoubleStrike(@as(*const ITextFont2, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont2_GetDuplicate2(self: *const T, ppFont: ?*?*ITextFont2) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).GetDuplicate2(@as(*const ITextFont2, @ptrCast(self)), ppFont);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont2_SetDuplicate2(self: *const T, pFont: ?*ITextFont2) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).SetDuplicate2(@as(*const ITextFont2, @ptrCast(self)), pFont);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont2_GetLinkType(self: *const T, pValue: ?*i32) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).GetLinkType(@as(*const ITextFont2, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont2_GetMathZone(self: *const T, pValue: ?*i32) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).GetMathZone(@as(*const ITextFont2, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont2_SetMathZone(self: *const T, Value: i32) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).SetMathZone(@as(*const ITextFont2, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont2_GetModWidthPairs(self: *const T, pValue: ?*i32) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).GetModWidthPairs(@as(*const ITextFont2, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont2_SetModWidthPairs(self: *const T, Value: i32) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).SetModWidthPairs(@as(*const ITextFont2, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont2_GetModWidthSpace(self: *const T, pValue: ?*i32) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).GetModWidthSpace(@as(*const ITextFont2, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont2_SetModWidthSpace(self: *const T, Value: i32) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).SetModWidthSpace(@as(*const ITextFont2, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont2_GetOldNumbers(self: *const T, pValue: ?*i32) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).GetOldNumbers(@as(*const ITextFont2, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont2_SetOldNumbers(self: *const T, Value: i32) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).SetOldNumbers(@as(*const ITextFont2, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont2_GetOverlapping(self: *const T, pValue: ?*i32) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).GetOverlapping(@as(*const ITextFont2, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont2_SetOverlapping(self: *const T, Value: i32) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).SetOverlapping(@as(*const ITextFont2, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont2_GetPositionSubSuper(self: *const T, pValue: ?*i32) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).GetPositionSubSuper(@as(*const ITextFont2, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont2_SetPositionSubSuper(self: *const T, Value: i32) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).SetPositionSubSuper(@as(*const ITextFont2, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont2_GetScaling(self: *const T, pValue: ?*i32) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).GetScaling(@as(*const ITextFont2, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont2_SetScaling(self: *const T, Value: i32) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).SetScaling(@as(*const ITextFont2, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont2_GetSpaceExtension(self: *const T, pValue: ?*f32) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).GetSpaceExtension(@as(*const ITextFont2, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont2_SetSpaceExtension(self: *const T, Value: f32) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).SetSpaceExtension(@as(*const ITextFont2, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont2_GetUnderlinePositionMode(self: *const T, pValue: ?*i32) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).GetUnderlinePositionMode(@as(*const ITextFont2, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont2_SetUnderlinePositionMode(self: *const T, Value: i32) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).SetUnderlinePositionMode(@as(*const ITextFont2, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont2_GetEffects(self: *const T, pValue: ?*i32, pMask: ?*i32) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).GetEffects(@as(*const ITextFont2, @ptrCast(self)), pValue, pMask);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont2_GetEffects2(self: *const T, pValue: ?*i32, pMask: ?*i32) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).GetEffects2(@as(*const ITextFont2, @ptrCast(self)), pValue, pMask);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont2_GetProperty(self: *const T, Type: i32, pValue: ?*i32) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).GetProperty(@as(*const ITextFont2, @ptrCast(self)), Type, pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont2_GetPropertyInfo(self: *const T, Index: i32, pType: ?*i32, pValue: ?*i32) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).GetPropertyInfo(@as(*const ITextFont2, @ptrCast(self)), Index, pType, pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont2_IsEqual2(self: *const T, pFont: ?*ITextFont2, pB: ?*i32) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).IsEqual2(@as(*const ITextFont2, @ptrCast(self)), pFont, pB);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont2_SetEffects(self: *const T, Value: i32, Mask: i32) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).SetEffects(@as(*const ITextFont2, @ptrCast(self)), Value, Mask);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont2_SetEffects2(self: *const T, Value: i32, Mask: i32) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).SetEffects2(@as(*const ITextFont2, @ptrCast(self)), Value, Mask);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextFont2_SetProperty(self: *const T, Type: i32, Value: i32) HRESULT {
                return @as(*const ITextFont2.VTable, @ptrCast(self.vtable)).SetProperty(@as(*const ITextFont2, @ptrCast(self)), Type, Value);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ITextPara2_Value = Guid.initString("c241f5e4-7206-11d8-a2c7-00a0d1d6c6b3");
pub const IID_ITextPara2 = &IID_ITextPara2_Value;
pub const ITextPara2 = extern struct {
    pub const VTable = extern struct {
        base: ITextPara.VTable,
        GetBorders: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextPara2,
                ppBorders: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextPara2,
                ppBorders: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDuplicate2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextPara2,
                ppPara: ?*?*ITextPara2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextPara2,
                ppPara: ?*?*ITextPara2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDuplicate2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextPara2,
                pPara: ?*ITextPara2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextPara2,
                pPara: ?*ITextPara2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFontAlignment: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextPara2,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextPara2,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFontAlignment: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextPara2,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextPara2,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetHangingPunctuation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextPara2,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextPara2,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetHangingPunctuation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextPara2,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextPara2,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSnapToGrid: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextPara2,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextPara2,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSnapToGrid: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextPara2,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextPara2,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTrimPunctuationAtStart: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextPara2,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextPara2,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTrimPunctuationAtStart: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextPara2,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextPara2,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEffects: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextPara2,
                pValue: ?*i32,
                pMask: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextPara2,
                pValue: ?*i32,
                pMask: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextPara2,
                Type: i32,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextPara2,
                Type: i32,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsEqual2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextPara2,
                pPara: ?*ITextPara2,
                pB: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextPara2,
                pPara: ?*ITextPara2,
                pB: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEffects: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextPara2,
                Value: i32,
                Mask: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextPara2,
                Value: i32,
                Mask: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextPara2,
                Type: i32,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextPara2,
                Type: i32,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITextPara.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextPara2_GetBorders(self: *const T, ppBorders: ?*?*IUnknown) HRESULT {
                return @as(*const ITextPara2.VTable, @ptrCast(self.vtable)).GetBorders(@as(*const ITextPara2, @ptrCast(self)), ppBorders);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextPara2_GetDuplicate2(self: *const T, ppPara: ?*?*ITextPara2) HRESULT {
                return @as(*const ITextPara2.VTable, @ptrCast(self.vtable)).GetDuplicate2(@as(*const ITextPara2, @ptrCast(self)), ppPara);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextPara2_SetDuplicate2(self: *const T, pPara: ?*ITextPara2) HRESULT {
                return @as(*const ITextPara2.VTable, @ptrCast(self.vtable)).SetDuplicate2(@as(*const ITextPara2, @ptrCast(self)), pPara);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextPara2_GetFontAlignment(self: *const T, pValue: ?*i32) HRESULT {
                return @as(*const ITextPara2.VTable, @ptrCast(self.vtable)).GetFontAlignment(@as(*const ITextPara2, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextPara2_SetFontAlignment(self: *const T, Value: i32) HRESULT {
                return @as(*const ITextPara2.VTable, @ptrCast(self.vtable)).SetFontAlignment(@as(*const ITextPara2, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextPara2_GetHangingPunctuation(self: *const T, pValue: ?*i32) HRESULT {
                return @as(*const ITextPara2.VTable, @ptrCast(self.vtable)).GetHangingPunctuation(@as(*const ITextPara2, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextPara2_SetHangingPunctuation(self: *const T, Value: i32) HRESULT {
                return @as(*const ITextPara2.VTable, @ptrCast(self.vtable)).SetHangingPunctuation(@as(*const ITextPara2, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextPara2_GetSnapToGrid(self: *const T, pValue: ?*i32) HRESULT {
                return @as(*const ITextPara2.VTable, @ptrCast(self.vtable)).GetSnapToGrid(@as(*const ITextPara2, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextPara2_SetSnapToGrid(self: *const T, Value: i32) HRESULT {
                return @as(*const ITextPara2.VTable, @ptrCast(self.vtable)).SetSnapToGrid(@as(*const ITextPara2, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextPara2_GetTrimPunctuationAtStart(self: *const T, pValue: ?*i32) HRESULT {
                return @as(*const ITextPara2.VTable, @ptrCast(self.vtable)).GetTrimPunctuationAtStart(@as(*const ITextPara2, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextPara2_SetTrimPunctuationAtStart(self: *const T, Value: i32) HRESULT {
                return @as(*const ITextPara2.VTable, @ptrCast(self.vtable)).SetTrimPunctuationAtStart(@as(*const ITextPara2, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextPara2_GetEffects(self: *const T, pValue: ?*i32, pMask: ?*i32) HRESULT {
                return @as(*const ITextPara2.VTable, @ptrCast(self.vtable)).GetEffects(@as(*const ITextPara2, @ptrCast(self)), pValue, pMask);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextPara2_GetProperty(self: *const T, Type: i32, pValue: ?*i32) HRESULT {
                return @as(*const ITextPara2.VTable, @ptrCast(self.vtable)).GetProperty(@as(*const ITextPara2, @ptrCast(self)), Type, pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextPara2_IsEqual2(self: *const T, pPara: ?*ITextPara2, pB: ?*i32) HRESULT {
                return @as(*const ITextPara2.VTable, @ptrCast(self.vtable)).IsEqual2(@as(*const ITextPara2, @ptrCast(self)), pPara, pB);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextPara2_SetEffects(self: *const T, Value: i32, Mask: i32) HRESULT {
                return @as(*const ITextPara2.VTable, @ptrCast(self.vtable)).SetEffects(@as(*const ITextPara2, @ptrCast(self)), Value, Mask);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextPara2_SetProperty(self: *const T, Type: i32, Value: i32) HRESULT {
                return @as(*const ITextPara2.VTable, @ptrCast(self.vtable)).SetProperty(@as(*const ITextPara2, @ptrCast(self)), Type, Value);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ITextStoryRanges2_Value = Guid.initString("c241f5e5-7206-11d8-a2c7-00a0d1d6c6b3");
pub const IID_ITextStoryRanges2 = &IID_ITextStoryRanges2_Value;
pub const ITextStoryRanges2 = extern struct {
    pub const VTable = extern struct {
        base: ITextStoryRanges.VTable,
        Item2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStoryRanges2,
                Index: i32,
                ppRange: ?*?*ITextRange2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStoryRanges2,
                Index: i32,
                ppRange: ?*?*ITextRange2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITextStoryRanges.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStoryRanges2_Item2(self: *const T, Index: i32, ppRange: ?*?*ITextRange2) HRESULT {
                return @as(*const ITextStoryRanges2.VTable, @ptrCast(self.vtable)).Item2(@as(*const ITextStoryRanges2, @ptrCast(self)), Index, ppRange);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ITextStory_Value = Guid.initString("c241f5f3-7206-11d8-a2c7-00a0d1d6c6b3");
pub const IID_ITextStory = &IID_ITextStory_Value;
pub const ITextStory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetActive: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStory,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStory,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetActive: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStory,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStory,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDisplay: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStory,
                ppDisplay: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStory,
                ppDisplay: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStory,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStory,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStory,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStory,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStory,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStory,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStory,
                Type: i32,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStory,
                Type: i32,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStory,
                cpActive: i32,
                cpAnchor: i32,
                ppRange: ?*?*ITextRange2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStory,
                cpActive: i32,
                cpAnchor: i32,
                ppRange: ?*?*ITextRange2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStory,
                Flags: i32,
                pbstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStory,
                Flags: i32,
                pbstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFormattedText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStory,
                pUnk: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStory,
                pUnk: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStory,
                Type: i32,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStory,
                Type: i32,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStory,
                Flags: i32,
                bstr: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStory,
                Flags: i32,
                bstr: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStory_GetActive(self: *const T, pValue: ?*i32) HRESULT {
                return @as(*const ITextStory.VTable, @ptrCast(self.vtable)).GetActive(@as(*const ITextStory, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStory_SetActive(self: *const T, Value: i32) HRESULT {
                return @as(*const ITextStory.VTable, @ptrCast(self.vtable)).SetActive(@as(*const ITextStory, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStory_GetDisplay(self: *const T, ppDisplay: ?*?*IUnknown) HRESULT {
                return @as(*const ITextStory.VTable, @ptrCast(self.vtable)).GetDisplay(@as(*const ITextStory, @ptrCast(self)), ppDisplay);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStory_GetIndex(self: *const T, pValue: ?*i32) HRESULT {
                return @as(*const ITextStory.VTable, @ptrCast(self.vtable)).GetIndex(@as(*const ITextStory, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStory_GetType(self: *const T, pValue: ?*i32) HRESULT {
                return @as(*const ITextStory.VTable, @ptrCast(self.vtable)).GetType(@as(*const ITextStory, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStory_SetType(self: *const T, Value: i32) HRESULT {
                return @as(*const ITextStory.VTable, @ptrCast(self.vtable)).SetType(@as(*const ITextStory, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStory_GetProperty(self: *const T, Type: i32, pValue: ?*i32) HRESULT {
                return @as(*const ITextStory.VTable, @ptrCast(self.vtable)).GetProperty(@as(*const ITextStory, @ptrCast(self)), Type, pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStory_GetRange(self: *const T, cpActive: i32, cpAnchor: i32, ppRange: ?*?*ITextRange2) HRESULT {
                return @as(*const ITextStory.VTable, @ptrCast(self.vtable)).GetRange(@as(*const ITextStory, @ptrCast(self)), cpActive, cpAnchor, ppRange);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStory_GetText(self: *const T, Flags: i32, pbstr: ?*?BSTR) HRESULT {
                return @as(*const ITextStory.VTable, @ptrCast(self.vtable)).GetText(@as(*const ITextStory, @ptrCast(self)), Flags, pbstr);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStory_SetFormattedText(self: *const T, pUnk: ?*IUnknown) HRESULT {
                return @as(*const ITextStory.VTable, @ptrCast(self.vtable)).SetFormattedText(@as(*const ITextStory, @ptrCast(self)), pUnk);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStory_SetProperty(self: *const T, Type: i32, Value: i32) HRESULT {
                return @as(*const ITextStory.VTable, @ptrCast(self.vtable)).SetProperty(@as(*const ITextStory, @ptrCast(self)), Type, Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStory_SetText(self: *const T, Flags: i32, bstr: ?BSTR) HRESULT {
                return @as(*const ITextStory.VTable, @ptrCast(self.vtable)).SetText(@as(*const ITextStory, @ptrCast(self)), Flags, bstr);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ITextStrings_Value = Guid.initString("c241f5e7-7206-11d8-a2c7-00a0d1d6c6b3");
pub const IID_ITextStrings = &IID_ITextStrings_Value;
pub const ITextStrings = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Item: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStrings,
                Index: i32,
                ppRange: ?*?*ITextRange2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStrings,
                Index: i32,
                ppRange: ?*?*ITextRange2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStrings,
                pCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStrings,
                pCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Add: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStrings,
                bstr: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStrings,
                bstr: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Append: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStrings,
                pRange: ?*ITextRange2,
                iString: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStrings,
                pRange: ?*ITextRange2,
                iString: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Cat2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStrings,
                iString: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStrings,
                iString: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CatTop2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStrings,
                bstr: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStrings,
                bstr: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeleteRange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStrings,
                pRange: ?*ITextRange2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStrings,
                pRange: ?*ITextRange2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EncodeFunction: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStrings,
                Type: i32,
                Align: i32,
                Char: i32,
                Char1: i32,
                Char2: i32,
                Count: i32,
                TeXStyle: i32,
                cCol: i32,
                pRange: ?*ITextRange2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStrings,
                Type: i32,
                Align: i32,
                Char: i32,
                Char1: i32,
                Char2: i32,
                Count: i32,
                TeXStyle: i32,
                cCol: i32,
                pRange: ?*ITextRange2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCch: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStrings,
                iString: i32,
                pcch: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStrings,
                iString: i32,
                pcch: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InsertNullStr: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStrings,
                iString: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStrings,
                iString: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        MoveBoundary: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStrings,
                iString: i32,
                cch: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStrings,
                iString: i32,
                cch: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PrefixTop: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStrings,
                bstr: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStrings,
                bstr: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Remove: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStrings,
                iString: i32,
                cString: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStrings,
                iString: i32,
                cString: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFormattedText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStrings,
                pRangeD: ?*ITextRange2,
                pRangeS: ?*ITextRange2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStrings,
                pRangeD: ?*ITextRange2,
                pRangeS: ?*ITextRange2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOpCp: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStrings,
                iString: i32,
                cp: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStrings,
                iString: i32,
                cp: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SuffixTop: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStrings,
                bstr: ?BSTR,
                pRange: ?*ITextRange2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStrings,
                bstr: ?BSTR,
                pRange: ?*ITextRange2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Swap: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextStrings,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextStrings,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStrings_Item(self: *const T, Index: i32, ppRange: ?*?*ITextRange2) HRESULT {
                return @as(*const ITextStrings.VTable, @ptrCast(self.vtable)).Item(@as(*const ITextStrings, @ptrCast(self)), Index, ppRange);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStrings_GetCount(self: *const T, pCount: ?*i32) HRESULT {
                return @as(*const ITextStrings.VTable, @ptrCast(self.vtable)).GetCount(@as(*const ITextStrings, @ptrCast(self)), pCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStrings_Add(self: *const T, bstr: ?BSTR) HRESULT {
                return @as(*const ITextStrings.VTable, @ptrCast(self.vtable)).Add(@as(*const ITextStrings, @ptrCast(self)), bstr);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStrings_Append(self: *const T, pRange: ?*ITextRange2, iString: i32) HRESULT {
                return @as(*const ITextStrings.VTable, @ptrCast(self.vtable)).Append(@as(*const ITextStrings, @ptrCast(self)), pRange, iString);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStrings_Cat2(self: *const T, iString: i32) HRESULT {
                return @as(*const ITextStrings.VTable, @ptrCast(self.vtable)).Cat2(@as(*const ITextStrings, @ptrCast(self)), iString);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStrings_CatTop2(self: *const T, bstr: ?BSTR) HRESULT {
                return @as(*const ITextStrings.VTable, @ptrCast(self.vtable)).CatTop2(@as(*const ITextStrings, @ptrCast(self)), bstr);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStrings_DeleteRange(self: *const T, pRange: ?*ITextRange2) HRESULT {
                return @as(*const ITextStrings.VTable, @ptrCast(self.vtable)).DeleteRange(@as(*const ITextStrings, @ptrCast(self)), pRange);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStrings_EncodeFunction(self: *const T, Type: i32, Align: i32, Char: i32, Char1: i32, Char2: i32, Count: i32, TeXStyle: i32, cCol: i32, pRange: ?*ITextRange2) HRESULT {
                return @as(*const ITextStrings.VTable, @ptrCast(self.vtable)).EncodeFunction(@as(*const ITextStrings, @ptrCast(self)), Type, Align, Char, Char1, Char2, Count, TeXStyle, cCol, pRange);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStrings_GetCch(self: *const T, iString: i32, pcch: ?*i32) HRESULT {
                return @as(*const ITextStrings.VTable, @ptrCast(self.vtable)).GetCch(@as(*const ITextStrings, @ptrCast(self)), iString, pcch);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStrings_InsertNullStr(self: *const T, iString: i32) HRESULT {
                return @as(*const ITextStrings.VTable, @ptrCast(self.vtable)).InsertNullStr(@as(*const ITextStrings, @ptrCast(self)), iString);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStrings_MoveBoundary(self: *const T, iString: i32, cch: i32) HRESULT {
                return @as(*const ITextStrings.VTable, @ptrCast(self.vtable)).MoveBoundary(@as(*const ITextStrings, @ptrCast(self)), iString, cch);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStrings_PrefixTop(self: *const T, bstr: ?BSTR) HRESULT {
                return @as(*const ITextStrings.VTable, @ptrCast(self.vtable)).PrefixTop(@as(*const ITextStrings, @ptrCast(self)), bstr);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStrings_Remove(self: *const T, iString: i32, cString: i32) HRESULT {
                return @as(*const ITextStrings.VTable, @ptrCast(self.vtable)).Remove(@as(*const ITextStrings, @ptrCast(self)), iString, cString);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStrings_SetFormattedText(self: *const T, pRangeD: ?*ITextRange2, pRangeS: ?*ITextRange2) HRESULT {
                return @as(*const ITextStrings.VTable, @ptrCast(self.vtable)).SetFormattedText(@as(*const ITextStrings, @ptrCast(self)), pRangeD, pRangeS);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStrings_SetOpCp(self: *const T, iString: i32, cp: i32) HRESULT {
                return @as(*const ITextStrings.VTable, @ptrCast(self.vtable)).SetOpCp(@as(*const ITextStrings, @ptrCast(self)), iString, cp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStrings_SuffixTop(self: *const T, bstr: ?BSTR, pRange: ?*ITextRange2) HRESULT {
                return @as(*const ITextStrings.VTable, @ptrCast(self.vtable)).SuffixTop(@as(*const ITextStrings, @ptrCast(self)), bstr, pRange);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextStrings_Swap(self: *const T) HRESULT {
                return @as(*const ITextStrings.VTable, @ptrCast(self.vtable)).Swap(@as(*const ITextStrings, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ITextRow_Value = Guid.initString("c241f5ef-7206-11d8-a2c7-00a0d1d6c6b3");
pub const IID_ITextRow = &IID_ITextRow_Value;
pub const ITextRow = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        GetAlignment: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRow,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRow,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetAlignment: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRow,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRow,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCellCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRow,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRow,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCellCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRow,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRow,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCellCountCache: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRow,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRow,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCellCountCache: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRow,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRow,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCellIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRow,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRow,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCellIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRow,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRow,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCellMargin: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRow,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRow,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCellMargin: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRow,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRow,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetHeight: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRow,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRow,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetHeight: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRow,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRow,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIndent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRow,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRow,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetIndent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRow,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRow,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetKeepTogether: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRow,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRow,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetKeepTogether: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRow,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRow,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetKeepWithNext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRow,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRow,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetKeepWithNext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRow,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRow,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNestLevel: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRow,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRow,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRTL: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRow,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRow,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetRTL: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRow,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRow,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCellAlignment: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRow,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRow,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCellAlignment: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRow,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRow,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCellColorBack: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRow,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRow,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCellColorBack: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRow,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRow,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCellColorFore: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRow,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRow,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCellColorFore: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRow,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRow,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCellMergeFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRow,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRow,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCellMergeFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRow,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRow,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCellShading: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRow,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRow,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCellShading: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRow,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRow,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCellVerticalText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRow,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRow,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCellVerticalText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRow,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRow,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCellWidth: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRow,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRow,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCellWidth: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRow,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRow,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCellBorderColors: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRow,
                pcrLeft: ?*i32,
                pcrTop: ?*i32,
                pcrRight: ?*i32,
                pcrBottom: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRow,
                pcrLeft: ?*i32,
                pcrTop: ?*i32,
                pcrRight: ?*i32,
                pcrBottom: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCellBorderWidths: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRow,
                pduLeft: ?*i32,
                pduTop: ?*i32,
                pduRight: ?*i32,
                pduBottom: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRow,
                pduLeft: ?*i32,
                pduTop: ?*i32,
                pduRight: ?*i32,
                pduBottom: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCellBorderColors: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRow,
                crLeft: i32,
                crTop: i32,
                crRight: i32,
                crBottom: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRow,
                crLeft: i32,
                crTop: i32,
                crRight: i32,
                crBottom: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCellBorderWidths: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRow,
                duLeft: i32,
                duTop: i32,
                duRight: i32,
                duBottom: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRow,
                duLeft: i32,
                duTop: i32,
                duRight: i32,
                duBottom: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Apply: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRow,
                cRow: i32,
                Flags: tomConstants,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRow,
                cRow: i32,
                Flags: tomConstants,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CanChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRow,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRow,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRow,
                Type: i32,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRow,
                Type: i32,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Insert: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRow,
                cRow: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRow,
                cRow: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsEqual: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRow,
                pRow: ?*ITextRow,
                pB: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRow,
                pRow: ?*ITextRow,
                pB: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRow,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRow,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextRow,
                Type: i32,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextRow,
                Type: i32,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRow_GetAlignment(self: *const T, pValue: ?*i32) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).GetAlignment(@as(*const ITextRow, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRow_SetAlignment(self: *const T, Value: i32) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).SetAlignment(@as(*const ITextRow, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRow_GetCellCount(self: *const T, pValue: ?*i32) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).GetCellCount(@as(*const ITextRow, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRow_SetCellCount(self: *const T, Value: i32) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).SetCellCount(@as(*const ITextRow, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRow_GetCellCountCache(self: *const T, pValue: ?*i32) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).GetCellCountCache(@as(*const ITextRow, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRow_SetCellCountCache(self: *const T, Value: i32) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).SetCellCountCache(@as(*const ITextRow, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRow_GetCellIndex(self: *const T, pValue: ?*i32) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).GetCellIndex(@as(*const ITextRow, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRow_SetCellIndex(self: *const T, Value: i32) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).SetCellIndex(@as(*const ITextRow, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRow_GetCellMargin(self: *const T, pValue: ?*i32) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).GetCellMargin(@as(*const ITextRow, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRow_SetCellMargin(self: *const T, Value: i32) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).SetCellMargin(@as(*const ITextRow, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRow_GetHeight(self: *const T, pValue: ?*i32) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).GetHeight(@as(*const ITextRow, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRow_SetHeight(self: *const T, Value: i32) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).SetHeight(@as(*const ITextRow, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRow_GetIndent(self: *const T, pValue: ?*i32) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).GetIndent(@as(*const ITextRow, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRow_SetIndent(self: *const T, Value: i32) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).SetIndent(@as(*const ITextRow, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRow_GetKeepTogether(self: *const T, pValue: ?*i32) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).GetKeepTogether(@as(*const ITextRow, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRow_SetKeepTogether(self: *const T, Value: i32) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).SetKeepTogether(@as(*const ITextRow, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRow_GetKeepWithNext(self: *const T, pValue: ?*i32) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).GetKeepWithNext(@as(*const ITextRow, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRow_SetKeepWithNext(self: *const T, Value: i32) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).SetKeepWithNext(@as(*const ITextRow, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRow_GetNestLevel(self: *const T, pValue: ?*i32) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).GetNestLevel(@as(*const ITextRow, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRow_GetRTL(self: *const T, pValue: ?*i32) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).GetRTL(@as(*const ITextRow, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRow_SetRTL(self: *const T, Value: i32) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).SetRTL(@as(*const ITextRow, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRow_GetCellAlignment(self: *const T, pValue: ?*i32) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).GetCellAlignment(@as(*const ITextRow, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRow_SetCellAlignment(self: *const T, Value: i32) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).SetCellAlignment(@as(*const ITextRow, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRow_GetCellColorBack(self: *const T, pValue: ?*i32) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).GetCellColorBack(@as(*const ITextRow, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRow_SetCellColorBack(self: *const T, Value: i32) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).SetCellColorBack(@as(*const ITextRow, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRow_GetCellColorFore(self: *const T, pValue: ?*i32) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).GetCellColorFore(@as(*const ITextRow, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRow_SetCellColorFore(self: *const T, Value: i32) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).SetCellColorFore(@as(*const ITextRow, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRow_GetCellMergeFlags(self: *const T, pValue: ?*i32) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).GetCellMergeFlags(@as(*const ITextRow, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRow_SetCellMergeFlags(self: *const T, Value: i32) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).SetCellMergeFlags(@as(*const ITextRow, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRow_GetCellShading(self: *const T, pValue: ?*i32) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).GetCellShading(@as(*const ITextRow, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRow_SetCellShading(self: *const T, Value: i32) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).SetCellShading(@as(*const ITextRow, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRow_GetCellVerticalText(self: *const T, pValue: ?*i32) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).GetCellVerticalText(@as(*const ITextRow, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRow_SetCellVerticalText(self: *const T, Value: i32) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).SetCellVerticalText(@as(*const ITextRow, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRow_GetCellWidth(self: *const T, pValue: ?*i32) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).GetCellWidth(@as(*const ITextRow, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRow_SetCellWidth(self: *const T, Value: i32) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).SetCellWidth(@as(*const ITextRow, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRow_GetCellBorderColors(self: *const T, pcrLeft: ?*i32, pcrTop: ?*i32, pcrRight: ?*i32, pcrBottom: ?*i32) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).GetCellBorderColors(@as(*const ITextRow, @ptrCast(self)), pcrLeft, pcrTop, pcrRight, pcrBottom);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRow_GetCellBorderWidths(self: *const T, pduLeft: ?*i32, pduTop: ?*i32, pduRight: ?*i32, pduBottom: ?*i32) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).GetCellBorderWidths(@as(*const ITextRow, @ptrCast(self)), pduLeft, pduTop, pduRight, pduBottom);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRow_SetCellBorderColors(self: *const T, crLeft: i32, crTop: i32, crRight: i32, crBottom: i32) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).SetCellBorderColors(@as(*const ITextRow, @ptrCast(self)), crLeft, crTop, crRight, crBottom);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRow_SetCellBorderWidths(self: *const T, duLeft: i32, duTop: i32, duRight: i32, duBottom: i32) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).SetCellBorderWidths(@as(*const ITextRow, @ptrCast(self)), duLeft, duTop, duRight, duBottom);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRow_Apply(self: *const T, cRow: i32, Flags: tomConstants) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).Apply(@as(*const ITextRow, @ptrCast(self)), cRow, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRow_CanChange(self: *const T, pValue: ?*i32) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).CanChange(@as(*const ITextRow, @ptrCast(self)), pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRow_GetProperty(self: *const T, Type: i32, pValue: ?*i32) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).GetProperty(@as(*const ITextRow, @ptrCast(self)), Type, pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRow_Insert(self: *const T, cRow: i32) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).Insert(@as(*const ITextRow, @ptrCast(self)), cRow);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRow_IsEqual(self: *const T, pRow: ?*ITextRow, pB: ?*i32) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).IsEqual(@as(*const ITextRow, @ptrCast(self)), pRow, pB);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRow_Reset(self: *const T, Value: i32) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).Reset(@as(*const ITextRow, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextRow_SetProperty(self: *const T, Type: i32, Value: i32) HRESULT {
                return @as(*const ITextRow.VTable, @ptrCast(self.vtable)).SetProperty(@as(*const ITextRow, @ptrCast(self)), Type, Value);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ITextDisplays_Value = Guid.initString("c241f5f2-7206-11d8-a2c7-00a0d1d6c6b3");
pub const IID_ITextDisplays = &IID_ITextDisplays_Value;
pub const ITextDisplays = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITextDocument2Old_Value = Guid.initString("01c25500-4268-11d1-883a-3c8b00c10000");
pub const IID_ITextDocument2Old = &IID_ITextDocument2Old_Value;
pub const ITextDocument2Old = extern struct {
    pub const VTable = extern struct {
        base: ITextDocument.VTable,
        AttachMsgFilter: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextDocument2Old,
                pFilter: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextDocument2Old,
                pFilter: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEffectColor: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextDocument2Old,
                Index: i32,
                cr: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextDocument2Old,
                Index: i32,
                cr: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEffectColor: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextDocument2Old,
                Index: i32,
                pcr: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextDocument2Old,
                Index: i32,
                pcr: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCaretType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextDocument2Old,
                pCaretType: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextDocument2Old,
                pCaretType: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCaretType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextDocument2Old,
                CaretType: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextDocument2Old,
                CaretType: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetImmContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextDocument2Old,
                pContext: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextDocument2Old,
                pContext: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReleaseImmContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextDocument2Old,
                Context: i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextDocument2Old,
                Context: i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPreferredFont: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextDocument2Old,
                cp: i32,
                CharRep: i32,
                Option: i32,
                CharRepCur: i32,
                curFontSize: i32,
                pbstr: ?*?BSTR,
                pPitchAndFamily: ?*i32,
                pNewFontSize: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextDocument2Old,
                cp: i32,
                CharRep: i32,
                Option: i32,
                CharRepCur: i32,
                curFontSize: i32,
                pbstr: ?*?BSTR,
                pPitchAndFamily: ?*i32,
                pNewFontSize: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNotificationMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextDocument2Old,
                pMode: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextDocument2Old,
                pMode: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetNotificationMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextDocument2Old,
                Mode: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextDocument2Old,
                Mode: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetClientRect: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextDocument2Old,
                Type: i32,
                pLeft: ?*i32,
                pTop: ?*i32,
                pRight: ?*i32,
                pBottom: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextDocument2Old,
                Type: i32,
                pLeft: ?*i32,
                pTop: ?*i32,
                pRight: ?*i32,
                pBottom: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSelection2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextDocument2Old,
                ppSel: ?*?*ITextSelection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextDocument2Old,
                ppSel: ?*?*ITextSelection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetWindow: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextDocument2Old,
                phWnd: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextDocument2Old,
                phWnd: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFEFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextDocument2Old,
                pFlags: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextDocument2Old,
                pFlags: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UpdateWindow: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextDocument2Old,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextDocument2Old,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CheckTextLimit: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextDocument2Old,
                cch: i32,
                pcch: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextDocument2Old,
                cch: i32,
                pcch: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IMEInProgress: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextDocument2Old,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextDocument2Old,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SysBeep: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextDocument2Old,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextDocument2Old,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Update: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextDocument2Old,
                Mode: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextDocument2Old,
                Mode: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Notify: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextDocument2Old,
                Notify: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextDocument2Old,
                Notify: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDocumentFont: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextDocument2Old,
                ppITextFont: ?*?*ITextFont,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextDocument2Old,
                ppITextFont: ?*?*ITextFont,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDocumentPara: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextDocument2Old,
                ppITextPara: ?*?*ITextPara,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextDocument2Old,
                ppITextPara: ?*?*ITextPara,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCallManager: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextDocument2Old,
                ppVoid: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextDocument2Old,
                ppVoid: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReleaseCallManager: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextDocument2Old,
                pVoid: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextDocument2Old,
                pVoid: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITextDocument.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextDocument2Old_AttachMsgFilter(self: *const T, pFilter: ?*IUnknown) HRESULT {
                return @as(*const ITextDocument2Old.VTable, @ptrCast(self.vtable)).AttachMsgFilter(@as(*const ITextDocument2Old, @ptrCast(self)), pFilter);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextDocument2Old_SetEffectColor(self: *const T, Index: i32, cr: u32) HRESULT {
                return @as(*const ITextDocument2Old.VTable, @ptrCast(self.vtable)).SetEffectColor(@as(*const ITextDocument2Old, @ptrCast(self)), Index, cr);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextDocument2Old_GetEffectColor(self: *const T, Index: i32, pcr: ?*u32) HRESULT {
                return @as(*const ITextDocument2Old.VTable, @ptrCast(self.vtable)).GetEffectColor(@as(*const ITextDocument2Old, @ptrCast(self)), Index, pcr);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextDocument2Old_GetCaretType(self: *const T, pCaretType: ?*i32) HRESULT {
                return @as(*const ITextDocument2Old.VTable, @ptrCast(self.vtable)).GetCaretType(@as(*const ITextDocument2Old, @ptrCast(self)), pCaretType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextDocument2Old_SetCaretType(self: *const T, CaretType: i32) HRESULT {
                return @as(*const ITextDocument2Old.VTable, @ptrCast(self.vtable)).SetCaretType(@as(*const ITextDocument2Old, @ptrCast(self)), CaretType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextDocument2Old_GetImmContext(self: *const T, pContext: ?*i64) HRESULT {
                return @as(*const ITextDocument2Old.VTable, @ptrCast(self.vtable)).GetImmContext(@as(*const ITextDocument2Old, @ptrCast(self)), pContext);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextDocument2Old_ReleaseImmContext(self: *const T, Context: i64) HRESULT {
                return @as(*const ITextDocument2Old.VTable, @ptrCast(self.vtable)).ReleaseImmContext(@as(*const ITextDocument2Old, @ptrCast(self)), Context);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextDocument2Old_GetPreferredFont(self: *const T, cp: i32, CharRep: i32, Option: i32, CharRepCur: i32, curFontSize: i32, pbstr: ?*?BSTR, pPitchAndFamily: ?*i32, pNewFontSize: ?*i32) HRESULT {
                return @as(*const ITextDocument2Old.VTable, @ptrCast(self.vtable)).GetPreferredFont(@as(*const ITextDocument2Old, @ptrCast(self)), cp, CharRep, Option, CharRepCur, curFontSize, pbstr, pPitchAndFamily, pNewFontSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextDocument2Old_GetNotificationMode(self: *const T, pMode: ?*i32) HRESULT {
                return @as(*const ITextDocument2Old.VTable, @ptrCast(self.vtable)).GetNotificationMode(@as(*const ITextDocument2Old, @ptrCast(self)), pMode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextDocument2Old_SetNotificationMode(self: *const T, Mode: i32) HRESULT {
                return @as(*const ITextDocument2Old.VTable, @ptrCast(self.vtable)).SetNotificationMode(@as(*const ITextDocument2Old, @ptrCast(self)), Mode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextDocument2Old_GetClientRect(self: *const T, Type: i32, pLeft: ?*i32, pTop: ?*i32, pRight: ?*i32, pBottom: ?*i32) HRESULT {
                return @as(*const ITextDocument2Old.VTable, @ptrCast(self.vtable)).GetClientRect(@as(*const ITextDocument2Old, @ptrCast(self)), Type, pLeft, pTop, pRight, pBottom);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextDocument2Old_GetSelection2(self: *const T, ppSel: ?*?*ITextSelection) HRESULT {
                return @as(*const ITextDocument2Old.VTable, @ptrCast(self.vtable)).GetSelection2(@as(*const ITextDocument2Old, @ptrCast(self)), ppSel);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextDocument2Old_GetWindow(self: *const T, phWnd: ?*i32) HRESULT {
                return @as(*const ITextDocument2Old.VTable, @ptrCast(self.vtable)).GetWindow(@as(*const ITextDocument2Old, @ptrCast(self)), phWnd);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextDocument2Old_GetFEFlags(self: *const T, pFlags: ?*i32) HRESULT {
                return @as(*const ITextDocument2Old.VTable, @ptrCast(self.vtable)).GetFEFlags(@as(*const ITextDocument2Old, @ptrCast(self)), pFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextDocument2Old_UpdateWindow(self: *const T) HRESULT {
                return @as(*const ITextDocument2Old.VTable, @ptrCast(self.vtable)).UpdateWindow(@as(*const ITextDocument2Old, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextDocument2Old_CheckTextLimit(self: *const T, cch: i32, pcch: ?*i32) HRESULT {
                return @as(*const ITextDocument2Old.VTable, @ptrCast(self.vtable)).CheckTextLimit(@as(*const ITextDocument2Old, @ptrCast(self)), cch, pcch);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextDocument2Old_IMEInProgress(self: *const T, Value: i32) HRESULT {
                return @as(*const ITextDocument2Old.VTable, @ptrCast(self.vtable)).IMEInProgress(@as(*const ITextDocument2Old, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextDocument2Old_SysBeep(self: *const T) HRESULT {
                return @as(*const ITextDocument2Old.VTable, @ptrCast(self.vtable)).SysBeep(@as(*const ITextDocument2Old, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextDocument2Old_Update(self: *const T, Mode: i32) HRESULT {
                return @as(*const ITextDocument2Old.VTable, @ptrCast(self.vtable)).Update(@as(*const ITextDocument2Old, @ptrCast(self)), Mode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextDocument2Old_Notify(self: *const T, Notify: i32) HRESULT {
                return @as(*const ITextDocument2Old.VTable, @ptrCast(self.vtable)).Notify(@as(*const ITextDocument2Old, @ptrCast(self)), Notify);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextDocument2Old_GetDocumentFont(self: *const T, ppITextFont: ?*?*ITextFont) HRESULT {
                return @as(*const ITextDocument2Old.VTable, @ptrCast(self.vtable)).GetDocumentFont(@as(*const ITextDocument2Old, @ptrCast(self)), ppITextFont);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextDocument2Old_GetDocumentPara(self: *const T, ppITextPara: ?*?*ITextPara) HRESULT {
                return @as(*const ITextDocument2Old.VTable, @ptrCast(self.vtable)).GetDocumentPara(@as(*const ITextDocument2Old, @ptrCast(self)), ppITextPara);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextDocument2Old_GetCallManager(self: *const T, ppVoid: ?*?*IUnknown) HRESULT {
                return @as(*const ITextDocument2Old.VTable, @ptrCast(self.vtable)).GetCallManager(@as(*const ITextDocument2Old, @ptrCast(self)), ppVoid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextDocument2Old_ReleaseCallManager(self: *const T, pVoid: ?*IUnknown) HRESULT {
                return @as(*const ITextDocument2Old.VTable, @ptrCast(self.vtable)).ReleaseCallManager(@as(*const ITextDocument2Old, @ptrCast(self)), pVoid);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

//--------------------------------------------------------------------------------
// Section: Functions (0)
//--------------------------------------------------------------------------------

//--------------------------------------------------------------------------------
// Section: Unicode Aliases (5)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../../zig.zig").unicode_mode) {
    .ansi => struct {
        pub const CHARFORMAT = thismodule.CHARFORMATA;
        pub const CHARFORMAT2 = thismodule.CHARFORMAT2A;
        pub const TEXTRANGE = thismodule.TEXTRANGEA;
        pub const FINDTEXT = thismodule.FINDTEXTA;
        pub const FINDTEXTEX = thismodule.FINDTEXTEXA;
    },
    .wide => struct {
        pub const CHARFORMAT = thismodule.CHARFORMATW;
        pub const CHARFORMAT2 = thismodule.CHARFORMAT2W;
        pub const TEXTRANGE = thismodule.TEXTRANGEW;
        pub const FINDTEXT = thismodule.FINDTEXTW;
        pub const FINDTEXTEX = thismodule.FINDTEXTEXW;
    },
    .unspecified => if (@import("builtin").is_test) struct {
        pub const CHARFORMAT = *opaque {};
        pub const CHARFORMAT2 = *opaque {};
        pub const TEXTRANGE = *opaque {};
        pub const FINDTEXT = *opaque {};
        pub const FINDTEXTEX = *opaque {};
    } else struct {
        pub const CHARFORMAT = @compileError("'CHARFORMAT' requires that UNICODE be set to true or false in the root module");
        pub const CHARFORMAT2 = @compileError("'CHARFORMAT2' requires that UNICODE be set to true or false in the root module");
        pub const TEXTRANGE = @compileError("'TEXTRANGE' requires that UNICODE be set to true or false in the root module");
        pub const FINDTEXT = @compileError("'FINDTEXT' requires that UNICODE be set to true or false in the root module");
        pub const FINDTEXTEX = @compileError("'FINDTEXTEX' requires that UNICODE be set to true or false in the root module");
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (43)
//--------------------------------------------------------------------------------
const Guid = @import("../../zig.zig").Guid;
const BOOL = @import("../../foundation.zig").BOOL;
const BSTR = @import("../../foundation.zig").BSTR;
const CHAR = @import("../../foundation.zig").CHAR;
const DVASPECT = @import("../../system/com.zig").DVASPECT;
const DVTARGETDEVICE = @import("../../system/com.zig").DVTARGETDEVICE;
const ENABLE_SCROLL_BAR_ARROWS = @import("../../ui/controls.zig").ENABLE_SCROLL_BAR_ARROWS;
const HANDLE = @import("../../foundation.zig").HANDLE;
const HBITMAP = @import("../../graphics/gdi.zig").HBITMAP;
const HCURSOR = @import("../../ui/windows_and_messaging.zig").HCURSOR;
const HDC = @import("../../graphics/gdi.zig").HDC;
const HIMC = @import("../../globalization.zig").HIMC;
const HMENU = @import("../../ui/windows_and_messaging.zig").HMENU;
const HPALETTE = @import("../../graphics/gdi.zig").HPALETTE;
const HRESULT = @import("../../foundation.zig").HRESULT;
const HRGN = @import("../../graphics/gdi.zig").HRGN;
const HWND = @import("../../foundation.zig").HWND;
const ID2D1RenderTarget = @import("../../graphics/direct2d.zig").ID2D1RenderTarget;
const IDataObject = @import("../../system/com.zig").IDataObject;
const IDispatch = @import("../../system/com.zig").IDispatch;
const IDropTarget = @import("../../system/ole.zig").IDropTarget;
const IOleClientSite = @import("../../system/ole.zig").IOleClientSite;
const IOleInPlaceFrame = @import("../../system/ole.zig").IOleInPlaceFrame;
const IOleInPlaceUIWindow = @import("../../system/ole.zig").IOleInPlaceUIWindow;
const IOleObject = @import("../../system/ole.zig").IOleObject;
const IStorage = @import("../../system/com/structured_storage.zig").IStorage;
const IStream = @import("../../system/com.zig").IStream;
const IUnknown = @import("../../system/com.zig").IUnknown;
const LPARAM = @import("../../foundation.zig").LPARAM;
const LRESULT = @import("../../foundation.zig").LRESULT;
const NMHDR = @import("../../ui/controls.zig").NMHDR;
const OIFI = @import("../../system/ole.zig").OIFI;
const POINT = @import("../../foundation.zig").POINT;
const PSTR = @import("../../foundation.zig").PSTR;
const PWSTR = @import("../../foundation.zig").PWSTR;
const RECT = @import("../../foundation.zig").RECT;
const RECTL = @import("../../foundation.zig").RECTL;
const SCROLLBAR_CONSTANTS = @import("../../ui/windows_and_messaging.zig").SCROLLBAR_CONSTANTS;
const SHOW_WINDOW_CMD = @import("../../ui/windows_and_messaging.zig").SHOW_WINDOW_CMD;
const SIZE = @import("../../foundation.zig").SIZE;
const TEXT_ALIGN_OPTIONS = @import("../../graphics/gdi.zig").TEXT_ALIGN_OPTIONS;
const VARIANT = @import("../../system/com.zig").VARIANT;
const WPARAM = @import("../../foundation.zig").WPARAM;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "AutoCorrectProc")) {
        _ = AutoCorrectProc;
    }
    if (@hasDecl(@This(), "EDITWORDBREAKPROCEX")) {
        _ = EDITWORDBREAKPROCEX;
    }
    if (@hasDecl(@This(), "EDITSTREAMCALLBACK")) {
        _ = EDITSTREAMCALLBACK;
    }
    if (@hasDecl(@This(), "PCreateTextServices")) {
        _ = PCreateTextServices;
    }
    if (@hasDecl(@This(), "PShutdownTextServices")) {
        _ = PShutdownTextServices;
    }

    @setEvalBranchQuota(comptime @import("std").meta.declarations(@This()).len * 3);

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        if (decl.is_pub) {
            _ = @field(@This(), decl.name);
        }
    }
}
