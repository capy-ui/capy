//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (268)
//--------------------------------------------------------------------------------
pub const MICROSOFT_URL_EXPERIENCE_PROPERTY = "Microsoft TIP URL Experience";
pub const MICROSOFT_TIP_NO_INSERT_BUTTON_PROPERTY = "Microsoft TIP No Insert Option";
pub const MICROSOFT_TIP_COMBOBOXLIST_PROPERTY = "Microsoft TIP ComboBox List Window Identifier";
pub const MICROSOFT_TIP_OPENING_MSG = "TabletInputPanelOpening";
pub const SAFE_PARTIAL = @as(u32, 1);
pub const BEST_COMPLETE = @as(u32, 2);
pub const MAX_VENDORNAME = @as(u32, 32);
pub const MAX_FRIENDLYNAME = @as(u32, 64);
pub const MAX_LANGUAGES = @as(u32, 64);
pub const CAC_FULL = @as(u32, 0);
pub const CAC_PREFIX = @as(u32, 1);
pub const CAC_RANDOM = @as(u32, 2);
pub const ASYNC_RECO_INTERRUPTED = @as(u32, 1);
pub const ASYNC_RECO_PROCESS_FAILED = @as(u32, 2);
pub const ASYNC_RECO_ADDSTROKE_FAILED = @as(u32, 4);
pub const ASYNC_RECO_SETCACMODE_FAILED = @as(u32, 8);
pub const ASYNC_RECO_RESETCONTEXT_FAILED = @as(u32, 16);
pub const ASYNC_RECO_SETGUIDE_FAILED = @as(u32, 32);
pub const ASYNC_RECO_SETFLAGS_FAILED = @as(u32, 64);
pub const ASYNC_RECO_SETFACTOID_FAILED = @as(u32, 128);
pub const ASYNC_RECO_SETTEXTCONTEXT_FAILED = @as(u32, 256);
pub const ASYNC_RECO_SETWORDLIST_FAILED = @as(u32, 512);
pub const RF_DONTCARE = @as(i32, 1);
pub const RF_OBJECT = @as(i32, 2);
pub const RF_FREE_INPUT = @as(i32, 4);
pub const RF_LINED_INPUT = @as(i32, 8);
pub const RF_BOXED_INPUT = @as(i32, 16);
pub const RF_CAC_INPUT = @as(i32, 32);
pub const RF_RIGHT_AND_DOWN = @as(i32, 64);
pub const RF_LEFT_AND_DOWN = @as(i32, 128);
pub const RF_DOWN_AND_LEFT = @as(i32, 256);
pub const RF_DOWN_AND_RIGHT = @as(i32, 512);
pub const RF_ARBITRARY_ANGLE = @as(i32, 1024);
pub const RF_LATTICE = @as(i32, 2048);
pub const RF_ADVISEINKCHANGE = @as(i32, 4096);
pub const RF_STROKEREORDER = @as(i32, 8192);
pub const RF_PERSONALIZABLE = @as(i32, 16384);
pub const RF_PERFORMSLINEBREAKING = @as(i32, 65536);
pub const RF_REQUIRESSEGMENTATIONBREAKING = @as(i32, 131072);
pub const FLICK_WM_HANDLED_MASK = @as(u32, 1);
pub const NUM_FLICK_DIRECTIONS = @as(u32, 8);
pub const WM_TABLET_DEFBASE = @as(u32, 704);
pub const WM_TABLET_MAXOFFSET = @as(u32, 32);
pub const WM_TABLET_ADDED = @as(u32, 712);
pub const WM_TABLET_DELETED = @as(u32, 713);
pub const WM_TABLET_FLICK = @as(u32, 715);
pub const WM_TABLET_QUERYSYSTEMGESTURESTATUS = @as(u32, 716);
pub const TABLET_DISABLE_PRESSANDHOLD = @as(u32, 1);
pub const TABLET_DISABLE_PENTAPFEEDBACK = @as(u32, 8);
pub const TABLET_DISABLE_PENBARRELFEEDBACK = @as(u32, 16);
pub const TABLET_DISABLE_TOUCHUIFORCEON = @as(u32, 256);
pub const TABLET_DISABLE_TOUCHUIFORCEOFF = @as(u32, 512);
pub const TABLET_DISABLE_TOUCHSWITCH = @as(u32, 32768);
pub const TABLET_DISABLE_FLICKS = @as(u32, 65536);
pub const TABLET_ENABLE_FLICKSONCONTEXT = @as(u32, 131072);
pub const TABLET_ENABLE_FLICKLEARNINGMODE = @as(u32, 262144);
pub const TABLET_DISABLE_SMOOTHSCROLLING = @as(u32, 524288);
pub const TABLET_DISABLE_FLICKFALLBACKKEYS = @as(u32, 1048576);
pub const TABLET_ENABLE_MULTITOUCHDATA = @as(u32, 16777216);
pub const MAX_PACKET_PROPERTY_COUNT = @as(u32, 32);
pub const MAX_PACKET_BUTTON_COUNT = @as(u32, 32);
pub const IP_CURSOR_DOWN = @as(u32, 1);
pub const IP_INVERTED = @as(u32, 2);
pub const IP_MARGIN = @as(u32, 4);
pub const IEC__BASE = @as(u32, 1536);
pub const EM_GETINKMODE = @as(u32, 1537);
pub const EM_SETINKMODE = @as(u32, 1538);
pub const EM_GETINKINSERTMODE = @as(u32, 1539);
pub const EM_SETINKINSERTMODE = @as(u32, 1540);
pub const EM_GETDRAWATTR = @as(u32, 1541);
pub const EM_SETDRAWATTR = @as(u32, 1542);
pub const EM_GETRECOTIMEOUT = @as(u32, 1543);
pub const EM_SETRECOTIMEOUT = @as(u32, 1544);
pub const EM_GETGESTURESTATUS = @as(u32, 1545);
pub const EM_SETGESTURESTATUS = @as(u32, 1546);
pub const EM_GETRECOGNIZER = @as(u32, 1547);
pub const EM_SETRECOGNIZER = @as(u32, 1548);
pub const EM_GETFACTOID = @as(u32, 1549);
pub const EM_SETFACTOID = @as(u32, 1550);
pub const EM_GETSELINK = @as(u32, 1551);
pub const EM_SETSELINK = @as(u32, 1552);
pub const EM_GETMOUSEICON = @as(u32, 1553);
pub const EM_SETMOUSEICON = @as(u32, 1554);
pub const EM_GETMOUSEPOINTER = @as(u32, 1555);
pub const EM_SETMOUSEPOINTER = @as(u32, 1556);
pub const EM_GETSTATUS = @as(u32, 1557);
pub const EM_RECOGNIZE = @as(u32, 1558);
pub const EM_GETUSEMOUSEFORINPUT = @as(u32, 1559);
pub const EM_SETUSEMOUSEFORINPUT = @as(u32, 1560);
pub const EM_SETSELINKDISPLAYMODE = @as(u32, 1561);
pub const EM_GETSELINKDISPLAYMODE = @as(u32, 1562);
pub const IECN__BASE = @as(u32, 2048);
pub const IECN_STROKE = @as(u32, 2049);
pub const IECN_GESTURE = @as(u32, 2050);
pub const IECN_RECOGNITIONRESULT = @as(u32, 2051);
pub const RECOFLAG_WORDMODE = @as(u32, 1);
pub const RECOFLAG_COERCE = @as(u32, 2);
pub const RECOFLAG_SINGLESEG = @as(u32, 4);
pub const RECOFLAG_PREFIXOK = @as(u32, 8);
pub const RECOFLAG_LINEMODE = @as(u32, 16);
pub const RECOFLAG_DISABLEPERSONALIZATION = @as(u32, 32);
pub const RECOFLAG_AUTOSPACE = @as(u32, 64);
pub const RECOCONF_LOWCONFIDENCE = @as(i32, -1);
pub const RECOCONF_MEDIUMCONFIDENCE = @as(u32, 0);
pub const RECOCONF_HIGHCONFIDENCE = @as(u32, 1);
pub const RECOCONF_NOTSET = @as(u32, 128);
pub const GESTURE_NULL = @as(u32, 61440);
pub const GESTURE_SCRATCHOUT = @as(u32, 61441);
pub const GESTURE_TRIANGLE = @as(u32, 61442);
pub const GESTURE_SQUARE = @as(u32, 61443);
pub const GESTURE_STAR = @as(u32, 61444);
pub const GESTURE_CHECK = @as(u32, 61445);
pub const GESTURE_INFINITY = @as(u32, 61446);
pub const GESTURE_CROSS = @as(u32, 61447);
pub const GESTURE_PARAGRAPH = @as(u32, 61448);
pub const GESTURE_SECTION = @as(u32, 61449);
pub const GESTURE_BULLET = @as(u32, 61450);
pub const GESTURE_BULLET_CROSS = @as(u32, 61451);
pub const GESTURE_SQUIGGLE = @as(u32, 61452);
pub const GESTURE_SWAP = @as(u32, 61453);
pub const GESTURE_OPENUP = @as(u32, 61454);
pub const GESTURE_CLOSEUP = @as(u32, 61455);
pub const GESTURE_CURLICUE = @as(u32, 61456);
pub const GESTURE_DOUBLE_CURLICUE = @as(u32, 61457);
pub const GESTURE_RECTANGLE = @as(u32, 61458);
pub const GESTURE_CIRCLE = @as(u32, 61472);
pub const GESTURE_DOUBLE_CIRCLE = @as(u32, 61473);
pub const GESTURE_CIRCLE_TAP = @as(u32, 61474);
pub const GESTURE_CIRCLE_CIRCLE = @as(u32, 61475);
pub const GESTURE_CIRCLE_CROSS = @as(u32, 61477);
pub const GESTURE_CIRCLE_LINE_VERT = @as(u32, 61478);
pub const GESTURE_CIRCLE_LINE_HORZ = @as(u32, 61479);
pub const GESTURE_SEMICIRCLE_LEFT = @as(u32, 61480);
pub const GESTURE_SEMICIRCLE_RIGHT = @as(u32, 61481);
pub const GESTURE_CHEVRON_UP = @as(u32, 61488);
pub const GESTURE_CHEVRON_DOWN = @as(u32, 61489);
pub const GESTURE_CHEVRON_LEFT = @as(u32, 61490);
pub const GESTURE_CHEVRON_RIGHT = @as(u32, 61491);
pub const GESTURE_ARROW_UP = @as(u32, 61496);
pub const GESTURE_ARROW_DOWN = @as(u32, 61497);
pub const GESTURE_ARROW_LEFT = @as(u32, 61498);
pub const GESTURE_ARROW_RIGHT = @as(u32, 61499);
pub const GESTURE_DOUBLE_ARROW_UP = @as(u32, 61500);
pub const GESTURE_DOUBLE_ARROW_DOWN = @as(u32, 61501);
pub const GESTURE_DOUBLE_ARROW_LEFT = @as(u32, 61502);
pub const GESTURE_DOUBLE_ARROW_RIGHT = @as(u32, 61503);
pub const GESTURE_UP_ARROW_LEFT = @as(u32, 61504);
pub const GESTURE_UP_ARROW_RIGHT = @as(u32, 61505);
pub const GESTURE_DOWN_ARROW_LEFT = @as(u32, 61506);
pub const GESTURE_DOWN_ARROW_RIGHT = @as(u32, 61507);
pub const GESTURE_LEFT_ARROW_UP = @as(u32, 61508);
pub const GESTURE_LEFT_ARROW_DOWN = @as(u32, 61509);
pub const GESTURE_RIGHT_ARROW_UP = @as(u32, 61510);
pub const GESTURE_RIGHT_ARROW_DOWN = @as(u32, 61511);
pub const GESTURE_UP = @as(u32, 61528);
pub const GESTURE_DOWN = @as(u32, 61529);
pub const GESTURE_LEFT = @as(u32, 61530);
pub const GESTURE_RIGHT = @as(u32, 61531);
pub const GESTURE_DIAGONAL_LEFTUP = @as(u32, 61532);
pub const GESTURE_DIAGONAL_RIGHTUP = @as(u32, 61533);
pub const GESTURE_DIAGONAL_LEFTDOWN = @as(u32, 61534);
pub const GESTURE_DIAGONAL_RIGHTDOWN = @as(u32, 61535);
pub const GESTURE_UP_DOWN = @as(u32, 61536);
pub const GESTURE_DOWN_UP = @as(u32, 61537);
pub const GESTURE_LEFT_RIGHT = @as(u32, 61538);
pub const GESTURE_RIGHT_LEFT = @as(u32, 61539);
pub const GESTURE_UP_LEFT_LONG = @as(u32, 61540);
pub const GESTURE_UP_RIGHT_LONG = @as(u32, 61541);
pub const GESTURE_DOWN_LEFT_LONG = @as(u32, 61542);
pub const GESTURE_DOWN_RIGHT_LONG = @as(u32, 61543);
pub const GESTURE_UP_LEFT = @as(u32, 61544);
pub const GESTURE_UP_RIGHT = @as(u32, 61545);
pub const GESTURE_DOWN_LEFT = @as(u32, 61546);
pub const GESTURE_DOWN_RIGHT = @as(u32, 61547);
pub const GESTURE_LEFT_UP = @as(u32, 61548);
pub const GESTURE_LEFT_DOWN = @as(u32, 61549);
pub const GESTURE_RIGHT_UP = @as(u32, 61550);
pub const GESTURE_RIGHT_DOWN = @as(u32, 61551);
pub const GESTURE_LETTER_A = @as(u32, 61568);
pub const GESTURE_LETTER_B = @as(u32, 61569);
pub const GESTURE_LETTER_C = @as(u32, 61570);
pub const GESTURE_LETTER_D = @as(u32, 61571);
pub const GESTURE_LETTER_E = @as(u32, 61572);
pub const GESTURE_LETTER_F = @as(u32, 61573);
pub const GESTURE_LETTER_G = @as(u32, 61574);
pub const GESTURE_LETTER_H = @as(u32, 61575);
pub const GESTURE_LETTER_I = @as(u32, 61576);
pub const GESTURE_LETTER_J = @as(u32, 61577);
pub const GESTURE_LETTER_K = @as(u32, 61578);
pub const GESTURE_LETTER_L = @as(u32, 61579);
pub const GESTURE_LETTER_M = @as(u32, 61580);
pub const GESTURE_LETTER_N = @as(u32, 61581);
pub const GESTURE_LETTER_O = @as(u32, 61582);
pub const GESTURE_LETTER_P = @as(u32, 61583);
pub const GESTURE_LETTER_Q = @as(u32, 61584);
pub const GESTURE_LETTER_R = @as(u32, 61585);
pub const GESTURE_LETTER_S = @as(u32, 61586);
pub const GESTURE_LETTER_T = @as(u32, 61587);
pub const GESTURE_LETTER_U = @as(u32, 61588);
pub const GESTURE_LETTER_V = @as(u32, 61589);
pub const GESTURE_LETTER_W = @as(u32, 61590);
pub const GESTURE_LETTER_X = @as(u32, 61591);
pub const GESTURE_LETTER_Y = @as(u32, 61592);
pub const GESTURE_LETTER_Z = @as(u32, 61593);
pub const GESTURE_DIGIT_0 = @as(u32, 61594);
pub const GESTURE_DIGIT_1 = @as(u32, 61595);
pub const GESTURE_DIGIT_2 = @as(u32, 61596);
pub const GESTURE_DIGIT_3 = @as(u32, 61597);
pub const GESTURE_DIGIT_4 = @as(u32, 61598);
pub const GESTURE_DIGIT_5 = @as(u32, 61599);
pub const GESTURE_DIGIT_6 = @as(u32, 61600);
pub const GESTURE_DIGIT_7 = @as(u32, 61601);
pub const GESTURE_DIGIT_8 = @as(u32, 61602);
pub const GESTURE_DIGIT_9 = @as(u32, 61603);
pub const GESTURE_EXCLAMATION = @as(u32, 61604);
pub const GESTURE_QUESTION = @as(u32, 61605);
pub const GESTURE_SHARP = @as(u32, 61606);
pub const GESTURE_DOLLAR = @as(u32, 61607);
pub const GESTURE_ASTERISK = @as(u32, 61608);
pub const GESTURE_PLUS = @as(u32, 61609);
pub const GESTURE_DOUBLE_UP = @as(u32, 61624);
pub const GESTURE_DOUBLE_DOWN = @as(u32, 61625);
pub const GESTURE_DOUBLE_LEFT = @as(u32, 61626);
pub const GESTURE_DOUBLE_RIGHT = @as(u32, 61627);
pub const GESTURE_TRIPLE_UP = @as(u32, 61628);
pub const GESTURE_TRIPLE_DOWN = @as(u32, 61629);
pub const GESTURE_TRIPLE_LEFT = @as(u32, 61630);
pub const GESTURE_TRIPLE_RIGHT = @as(u32, 61631);
pub const GESTURE_BRACKET_OVER = @as(u32, 61668);
pub const GESTURE_BRACKET_UNDER = @as(u32, 61669);
pub const GESTURE_BRACKET_LEFT = @as(u32, 61670);
pub const GESTURE_BRACKET_RIGHT = @as(u32, 61671);
pub const GESTURE_BRACE_OVER = @as(u32, 61672);
pub const GESTURE_BRACE_UNDER = @as(u32, 61673);
pub const GESTURE_BRACE_LEFT = @as(u32, 61674);
pub const GESTURE_BRACE_RIGHT = @as(u32, 61675);
pub const GESTURE_TAP = @as(u32, 61680);
pub const GESTURE_DOUBLE_TAP = @as(u32, 61681);
pub const GESTURE_TRIPLE_TAP = @as(u32, 61682);
pub const GESTURE_QUAD_TAP = @as(u32, 61683);
pub const FACILITY_INK = @as(u32, 40);
pub const GUID_PACKETPROPERTY_GUID_X = Guid.initString("598a6a8f-52c0-4ba0-93af-af357411a561");
pub const GUID_PACKETPROPERTY_GUID_Y = Guid.initString("b53f9f75-04e0-4498-a7ee-c30dbb5a9011");
pub const GUID_PACKETPROPERTY_GUID_Z = Guid.initString("735adb30-0ebb-4788-a0e4-0f316490055d");
pub const GUID_PACKETPROPERTY_GUID_PACKET_STATUS = Guid.initString("6e0e07bf-afe7-4cf7-87d1-af6446208418");
pub const GUID_PACKETPROPERTY_GUID_TIMER_TICK = Guid.initString("436510c5-fed3-45d1-8b76-71d3ea7a829d");
pub const GUID_PACKETPROPERTY_GUID_SERIAL_NUMBER = Guid.initString("78a81b56-0935-4493-baae-00541a8a16c4");
pub const GUID_PACKETPROPERTY_GUID_NORMAL_PRESSURE = Guid.initString("7307502d-f9f4-4e18-b3f2-2ce1b1a3610c");
pub const GUID_PACKETPROPERTY_GUID_TANGENT_PRESSURE = Guid.initString("6da4488b-5244-41ec-905b-32d89ab80809");
pub const GUID_PACKETPROPERTY_GUID_BUTTON_PRESSURE = Guid.initString("8b7fefc4-96aa-4bfe-ac26-8a5f0be07bf5");
pub const GUID_PACKETPROPERTY_GUID_X_TILT_ORIENTATION = Guid.initString("a8d07b3a-8bf0-40b0-95a9-b80a6bb787bf");
pub const GUID_PACKETPROPERTY_GUID_Y_TILT_ORIENTATION = Guid.initString("0e932389-1d77-43af-ac00-5b950d6d4b2d");
pub const GUID_PACKETPROPERTY_GUID_AZIMUTH_ORIENTATION = Guid.initString("029123b4-8828-410b-b250-a0536595e5dc");
pub const GUID_PACKETPROPERTY_GUID_ALTITUDE_ORIENTATION = Guid.initString("82dec5c7-f6ba-4906-894f-66d68dfc456c");
pub const GUID_PACKETPROPERTY_GUID_TWIST_ORIENTATION = Guid.initString("0d324960-13b2-41e4-ace6-7ae9d43d2d3b");
pub const GUID_PACKETPROPERTY_GUID_PITCH_ROTATION = Guid.initString("7f7e57b7-be37-4be1-a356-7a84160e1893");
pub const GUID_PACKETPROPERTY_GUID_ROLL_ROTATION = Guid.initString("5d5d5e56-6ba9-4c5b-9fb0-851c91714e56");
pub const GUID_PACKETPROPERTY_GUID_YAW_ROTATION = Guid.initString("6a849980-7c3a-45b7-aa82-90a262950e89");
pub const GUID_PACKETPROPERTY_GUID_WIDTH = Guid.initString("baabe94d-2712-48f5-be9d-8f8b5ea0711a");
pub const GUID_PACKETPROPERTY_GUID_HEIGHT = Guid.initString("e61858d2-e447-4218-9d3f-18865c203df4");
pub const GUID_PACKETPROPERTY_GUID_FINGERCONTACTCONFIDENCE = Guid.initString("e706c804-57f0-4f00-8a0c-853d57789be9");
pub const GUID_PACKETPROPERTY_GUID_DEVICE_CONTACT_ID = Guid.initString("02585b91-049b-4750-9615-df8948ab3c9c");
pub const InkMinTransparencyValue = @as(i32, 0);
pub const InkMaxTransparencyValue = @as(i32, 255);
pub const InkCollectorClipInkToMargin = @as(i32, 0);
pub const InkCollectorDefaultMargin = @as(i32, -2147483648);
pub const GUID_GESTURE_DATA = Guid.initString("41e4ec0f-26aa-455a-9aa5-2cd36cf63fb9");
pub const GUID_DYNAMIC_RENDERER_CACHED_DATA = Guid.initString("bf531b92-25bf-4a95-89ad-0e476b34b4f5");

//--------------------------------------------------------------------------------
// Section: Types (240)
//--------------------------------------------------------------------------------
pub const PfnRecoCallback = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        param0: u32,
        param1: ?*u8,
        param2: ?HRECOCONTEXT,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn (
        param0: u32,
        param1: ?*u8,
        param2: ?HRECOCONTEXT,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
};

pub const HRECOALT = *opaque {};

pub const HRECOCONTEXT = *opaque {};

pub const HRECOGNIZER = *opaque {};

pub const HRECOLATTICE = *opaque {};

pub const HRECOWORDLIST = *opaque {};

const CLSID_InkDisp_Value = Guid.initString("937c1a34-151d-4610-9ca6-a8cc9bdb5d83");
pub const CLSID_InkDisp = &CLSID_InkDisp_Value;

const CLSID_InkOverlay_Value = Guid.initString("65d00646-cde3-4a88-9163-6769f0f1a97d");
pub const CLSID_InkOverlay = &CLSID_InkOverlay_Value;

const CLSID_InkPicture_Value = Guid.initString("04a1e553-fe36-4fde-865e-344194e69424");
pub const CLSID_InkPicture = &CLSID_InkPicture_Value;

const CLSID_InkCollector_Value = Guid.initString("43fb1553-ad74-4ee8-88e4-3e6daac915db");
pub const CLSID_InkCollector = &CLSID_InkCollector_Value;

const CLSID_InkDrawingAttributes_Value = Guid.initString("d8bf32a2-05a5-44c3-b3aa-5e80ac7d2576");
pub const CLSID_InkDrawingAttributes = &CLSID_InkDrawingAttributes_Value;

const CLSID_InkRectangle_Value = Guid.initString("43b07326-aae0-4b62-a83d-5fd768b7353c");
pub const CLSID_InkRectangle = &CLSID_InkRectangle_Value;

const CLSID_InkRenderer_Value = Guid.initString("9c1cc6e4-d7eb-4eeb-9091-15a7c8791ed9");
pub const CLSID_InkRenderer = &CLSID_InkRenderer_Value;

const CLSID_InkTransform_Value = Guid.initString("e3d5d93c-1663-4a78-a1a7-22375dfebaee");
pub const CLSID_InkTransform = &CLSID_InkTransform_Value;

const CLSID_InkRecognizers_Value = Guid.initString("9fd4e808-f6e6-4e65-98d3-aa39054c1255");
pub const CLSID_InkRecognizers = &CLSID_InkRecognizers_Value;

const CLSID_InkRecognizerContext_Value = Guid.initString("aac46a37-9229-4fc0-8cce-4497569bf4d1");
pub const CLSID_InkRecognizerContext = &CLSID_InkRecognizerContext_Value;

const CLSID_InkRecognizerGuide_Value = Guid.initString("8770d941-a63a-4671-a375-2855a18eba73");
pub const CLSID_InkRecognizerGuide = &CLSID_InkRecognizerGuide_Value;

const CLSID_InkTablets_Value = Guid.initString("6e4fcb12-510a-4d40-9304-1da10ae9147c");
pub const CLSID_InkTablets = &CLSID_InkTablets_Value;

const CLSID_InkWordList_Value = Guid.initString("9de85094-f71f-44f1-8471-15a2fa76fcf3");
pub const CLSID_InkWordList = &CLSID_InkWordList_Value;

const CLSID_InkStrokes_Value = Guid.initString("48f491bc-240e-4860-b079-a1e94d3d2c86");
pub const CLSID_InkStrokes = &CLSID_InkStrokes_Value;

const CLSID_Ink_Value = Guid.initString("13de4a42-8d21-4c8e-bf9c-8f69cb068fca");
pub const CLSID_Ink = &CLSID_Ink_Value;

const CLSID_SketchInk_Value = Guid.initString("f0291081-e87c-4e07-97da-a0a03761e586");
pub const CLSID_SketchInk = &CLSID_SketchInk_Value;

pub const PROPERTY_UNITS = enum(i32) {
    DEFAULT = 0,
    INCHES = 1,
    CENTIMETERS = 2,
    DEGREES = 3,
    RADIANS = 4,
    SECONDS = 5,
    POUNDS = 6,
    GRAMS = 7,
    SILINEAR = 8,
    SIROTATION = 9,
    ENGLINEAR = 10,
    ENGROTATION = 11,
    SLUGS = 12,
    KELVIN = 13,
    FAHRENHEIT = 14,
    AMPERE = 15,
    CANDELA = 16,
};
pub const PROPERTY_UNITS_DEFAULT = PROPERTY_UNITS.DEFAULT;
pub const PROPERTY_UNITS_INCHES = PROPERTY_UNITS.INCHES;
pub const PROPERTY_UNITS_CENTIMETERS = PROPERTY_UNITS.CENTIMETERS;
pub const PROPERTY_UNITS_DEGREES = PROPERTY_UNITS.DEGREES;
pub const PROPERTY_UNITS_RADIANS = PROPERTY_UNITS.RADIANS;
pub const PROPERTY_UNITS_SECONDS = PROPERTY_UNITS.SECONDS;
pub const PROPERTY_UNITS_POUNDS = PROPERTY_UNITS.POUNDS;
pub const PROPERTY_UNITS_GRAMS = PROPERTY_UNITS.GRAMS;
pub const PROPERTY_UNITS_SILINEAR = PROPERTY_UNITS.SILINEAR;
pub const PROPERTY_UNITS_SIROTATION = PROPERTY_UNITS.SIROTATION;
pub const PROPERTY_UNITS_ENGLINEAR = PROPERTY_UNITS.ENGLINEAR;
pub const PROPERTY_UNITS_ENGROTATION = PROPERTY_UNITS.ENGROTATION;
pub const PROPERTY_UNITS_SLUGS = PROPERTY_UNITS.SLUGS;
pub const PROPERTY_UNITS_KELVIN = PROPERTY_UNITS.KELVIN;
pub const PROPERTY_UNITS_FAHRENHEIT = PROPERTY_UNITS.FAHRENHEIT;
pub const PROPERTY_UNITS_AMPERE = PROPERTY_UNITS.AMPERE;
pub const PROPERTY_UNITS_CANDELA = PROPERTY_UNITS.CANDELA;

pub const SYSTEM_EVENT_DATA = extern struct {
    bModifier: u8,
    wKey: u16,
    xPos: i32,
    yPos: i32,
    bCursorMode: u8,
    dwButtonState: u32,
};

pub const STROKE_RANGE = extern struct {
    iStrokeBegin: u32,
    iStrokeEnd: u32,
};

pub const PROPERTY_METRICS = extern struct {
    nLogicalMin: i32,
    nLogicalMax: i32,
    Units: PROPERTY_UNITS,
    fResolution: f32,
};

pub const PACKET_PROPERTY = extern struct {
    guid: Guid,
    PropertyMetrics: PROPERTY_METRICS,
};

pub const PACKET_DESCRIPTION = extern struct {
    cbPacketSize: u32,
    cPacketProperties: u32,
    pPacketProperties: ?*PACKET_PROPERTY,
    cButtons: u32,
    pguidButtons: ?*Guid,
};

pub const enumINKMETRIC_FLAGS = enum(i32) {
    FONT_SELECTED_IN_HDC = 1,
    ITALIC = 2,
    BOLD = 4,
};
pub const IMF_FONT_SELECTED_IN_HDC = enumINKMETRIC_FLAGS.FONT_SELECTED_IN_HDC;
pub const IMF_ITALIC = enumINKMETRIC_FLAGS.ITALIC;
pub const IMF_BOLD = enumINKMETRIC_FLAGS.BOLD;

pub const enumGetCandidateFlags = enum(i32) {
    ALLOW_RECOGNITION = 1,
    FORCE_RECOGNITION = 2,
};
pub const TCF_ALLOW_RECOGNITION = enumGetCandidateFlags.ALLOW_RECOGNITION;
pub const TCF_FORCE_RECOGNITION = enumGetCandidateFlags.FORCE_RECOGNITION;

pub const INKMETRIC = extern struct {
    iHeight: i32,
    iFontAscent: i32,
    iFontDescent: i32,
    dwFlags: u32,
    color: u32,
};

pub const InkSelectionConstants = enum(i32) {
    FirstElement = 0,
    AllElements = -1,
};
pub const ISC_FirstElement = InkSelectionConstants.FirstElement;
pub const ISC_AllElements = InkSelectionConstants.AllElements;

pub const InkBoundingBoxMode = enum(i32) {
    Default = 0,
    NoCurveFit = 1,
    CurveFit = 2,
    PointsOnly = 3,
    Union = 4,
};
pub const IBBM_Default = InkBoundingBoxMode.Default;
pub const IBBM_NoCurveFit = InkBoundingBoxMode.NoCurveFit;
pub const IBBM_CurveFit = InkBoundingBoxMode.CurveFit;
pub const IBBM_PointsOnly = InkBoundingBoxMode.PointsOnly;
pub const IBBM_Union = InkBoundingBoxMode.Union;

pub const InkExtractFlags = enum(i32) {
    CopyFromOriginal = 0,
    RemoveFromOriginal = 1,
    // Default = 1, this enum value conflicts with RemoveFromOriginal
};
pub const IEF_CopyFromOriginal = InkExtractFlags.CopyFromOriginal;
pub const IEF_RemoveFromOriginal = InkExtractFlags.RemoveFromOriginal;
pub const IEF_Default = InkExtractFlags.RemoveFromOriginal;

pub const InkPersistenceFormat = enum(i32) {
    InkSerializedFormat = 0,
    Base64InkSerializedFormat = 1,
    GIF = 2,
    Base64GIF = 3,
};
pub const IPF_InkSerializedFormat = InkPersistenceFormat.InkSerializedFormat;
pub const IPF_Base64InkSerializedFormat = InkPersistenceFormat.Base64InkSerializedFormat;
pub const IPF_GIF = InkPersistenceFormat.GIF;
pub const IPF_Base64GIF = InkPersistenceFormat.Base64GIF;

pub const InkPersistenceCompressionMode = enum(i32) {
    Default = 0,
    MaximumCompression = 1,
    NoCompression = 2,
};
pub const IPCM_Default = InkPersistenceCompressionMode.Default;
pub const IPCM_MaximumCompression = InkPersistenceCompressionMode.MaximumCompression;
pub const IPCM_NoCompression = InkPersistenceCompressionMode.NoCompression;

pub const InkPenTip = enum(i32) {
    Ball = 0,
    Rectangle = 1,
};
pub const IPT_Ball = InkPenTip.Ball;
pub const IPT_Rectangle = InkPenTip.Rectangle;

pub const InkRasterOperation = enum(i32) {
    Black = 1,
    NotMergePen = 2,
    MaskNotPen = 3,
    NotCopyPen = 4,
    MaskPenNot = 5,
    Not = 6,
    XOrPen = 7,
    NotMaskPen = 8,
    MaskPen = 9,
    NotXOrPen = 10,
    NoOperation = 11,
    MergeNotPen = 12,
    CopyPen = 13,
    MergePenNot = 14,
    MergePen = 15,
    White = 16,
};
pub const IRO_Black = InkRasterOperation.Black;
pub const IRO_NotMergePen = InkRasterOperation.NotMergePen;
pub const IRO_MaskNotPen = InkRasterOperation.MaskNotPen;
pub const IRO_NotCopyPen = InkRasterOperation.NotCopyPen;
pub const IRO_MaskPenNot = InkRasterOperation.MaskPenNot;
pub const IRO_Not = InkRasterOperation.Not;
pub const IRO_XOrPen = InkRasterOperation.XOrPen;
pub const IRO_NotMaskPen = InkRasterOperation.NotMaskPen;
pub const IRO_MaskPen = InkRasterOperation.MaskPen;
pub const IRO_NotXOrPen = InkRasterOperation.NotXOrPen;
pub const IRO_NoOperation = InkRasterOperation.NoOperation;
pub const IRO_MergeNotPen = InkRasterOperation.MergeNotPen;
pub const IRO_CopyPen = InkRasterOperation.CopyPen;
pub const IRO_MergePenNot = InkRasterOperation.MergePenNot;
pub const IRO_MergePen = InkRasterOperation.MergePen;
pub const IRO_White = InkRasterOperation.White;

pub const InkMousePointer = enum(i32) {
    Default = 0,
    Arrow = 1,
    Crosshair = 2,
    Ibeam = 3,
    SizeNESW = 4,
    SizeNS = 5,
    SizeNWSE = 6,
    SizeWE = 7,
    UpArrow = 8,
    Hourglass = 9,
    NoDrop = 10,
    ArrowHourglass = 11,
    ArrowQuestion = 12,
    SizeAll = 13,
    Hand = 14,
    Custom = 99,
};
pub const IMP_Default = InkMousePointer.Default;
pub const IMP_Arrow = InkMousePointer.Arrow;
pub const IMP_Crosshair = InkMousePointer.Crosshair;
pub const IMP_Ibeam = InkMousePointer.Ibeam;
pub const IMP_SizeNESW = InkMousePointer.SizeNESW;
pub const IMP_SizeNS = InkMousePointer.SizeNS;
pub const IMP_SizeNWSE = InkMousePointer.SizeNWSE;
pub const IMP_SizeWE = InkMousePointer.SizeWE;
pub const IMP_UpArrow = InkMousePointer.UpArrow;
pub const IMP_Hourglass = InkMousePointer.Hourglass;
pub const IMP_NoDrop = InkMousePointer.NoDrop;
pub const IMP_ArrowHourglass = InkMousePointer.ArrowHourglass;
pub const IMP_ArrowQuestion = InkMousePointer.ArrowQuestion;
pub const IMP_SizeAll = InkMousePointer.SizeAll;
pub const IMP_Hand = InkMousePointer.Hand;
pub const IMP_Custom = InkMousePointer.Custom;

pub const InkClipboardModes = enum(i32) {
    Copy = 0,
    Cut = 1,
    ExtractOnly = 48,
    DelayedCopy = 32,
    // Default = 0, this enum value conflicts with Copy
};
pub const ICB_Copy = InkClipboardModes.Copy;
pub const ICB_Cut = InkClipboardModes.Cut;
pub const ICB_ExtractOnly = InkClipboardModes.ExtractOnly;
pub const ICB_DelayedCopy = InkClipboardModes.DelayedCopy;
pub const ICB_Default = InkClipboardModes.Copy;

pub const InkClipboardFormats = enum(i32) {
    None = 0,
    InkSerializedFormat = 1,
    SketchInk = 2,
    TextInk = 6,
    EnhancedMetafile = 8,
    Metafile = 32,
    Bitmap = 64,
    PasteMask = 7,
    CopyMask = 127,
    // Default = 127, this enum value conflicts with CopyMask
};
pub const ICF_None = InkClipboardFormats.None;
pub const ICF_InkSerializedFormat = InkClipboardFormats.InkSerializedFormat;
pub const ICF_SketchInk = InkClipboardFormats.SketchInk;
pub const ICF_TextInk = InkClipboardFormats.TextInk;
pub const ICF_EnhancedMetafile = InkClipboardFormats.EnhancedMetafile;
pub const ICF_Metafile = InkClipboardFormats.Metafile;
pub const ICF_Bitmap = InkClipboardFormats.Bitmap;
pub const ICF_PasteMask = InkClipboardFormats.PasteMask;
pub const ICF_CopyMask = InkClipboardFormats.CopyMask;
pub const ICF_Default = InkClipboardFormats.CopyMask;

pub const SelectionHitResult = enum(i32) {
    None = 0,
    NW = 1,
    SE = 2,
    NE = 3,
    SW = 4,
    E = 5,
    W = 6,
    N = 7,
    S = 8,
    Selection = 9,
};
pub const SHR_None = SelectionHitResult.None;
pub const SHR_NW = SelectionHitResult.NW;
pub const SHR_SE = SelectionHitResult.SE;
pub const SHR_NE = SelectionHitResult.NE;
pub const SHR_SW = SelectionHitResult.SW;
pub const SHR_E = SelectionHitResult.E;
pub const SHR_W = SelectionHitResult.W;
pub const SHR_N = SelectionHitResult.N;
pub const SHR_S = SelectionHitResult.S;
pub const SHR_Selection = SelectionHitResult.Selection;

pub const InkRecognitionStatus = enum(i32) {
    NoError = 0,
    Interrupted = 1,
    ProcessFailed = 2,
    InkAddedFailed = 4,
    SetAutoCompletionModeFailed = 8,
    SetStrokesFailed = 16,
    SetGuideFailed = 32,
    SetFlagsFailed = 64,
    SetFactoidFailed = 128,
    SetPrefixSuffixFailed = 256,
    SetWordListFailed = 512,
};
pub const IRS_NoError = InkRecognitionStatus.NoError;
pub const IRS_Interrupted = InkRecognitionStatus.Interrupted;
pub const IRS_ProcessFailed = InkRecognitionStatus.ProcessFailed;
pub const IRS_InkAddedFailed = InkRecognitionStatus.InkAddedFailed;
pub const IRS_SetAutoCompletionModeFailed = InkRecognitionStatus.SetAutoCompletionModeFailed;
pub const IRS_SetStrokesFailed = InkRecognitionStatus.SetStrokesFailed;
pub const IRS_SetGuideFailed = InkRecognitionStatus.SetGuideFailed;
pub const IRS_SetFlagsFailed = InkRecognitionStatus.SetFlagsFailed;
pub const IRS_SetFactoidFailed = InkRecognitionStatus.SetFactoidFailed;
pub const IRS_SetPrefixSuffixFailed = InkRecognitionStatus.SetPrefixSuffixFailed;
pub const IRS_SetWordListFailed = InkRecognitionStatus.SetWordListFailed;

pub const DISPID_InkRectangle = enum(i32) {
    Top = 1,
    Left = 2,
    Bottom = 3,
    Right = 4,
    GetRectangle = 5,
    SetRectangle = 6,
    Data = 7,
};
pub const DISPID_IRTop = DISPID_InkRectangle.Top;
pub const DISPID_IRLeft = DISPID_InkRectangle.Left;
pub const DISPID_IRBottom = DISPID_InkRectangle.Bottom;
pub const DISPID_IRRight = DISPID_InkRectangle.Right;
pub const DISPID_IRGetRectangle = DISPID_InkRectangle.GetRectangle;
pub const DISPID_IRSetRectangle = DISPID_InkRectangle.SetRectangle;
pub const DISPID_IRData = DISPID_InkRectangle.Data;

pub const DISPID_InkExtendedProperty = enum(i32) {
    Guid = 1,
    Data = 2,
};
pub const DISPID_IEPGuid = DISPID_InkExtendedProperty.Guid;
pub const DISPID_IEPData = DISPID_InkExtendedProperty.Data;

pub const DISPID_InkExtendedProperties = enum(i32) {
    _NewEnum = -4,
    Item = 0,
    Count = 1,
    Add = 2,
    Remove = 3,
    Clear = 4,
    DoesPropertyExist = 5,
};
pub const DISPID_IEPs_NewEnum = DISPID_InkExtendedProperties._NewEnum;
pub const DISPID_IEPsItem = DISPID_InkExtendedProperties.Item;
pub const DISPID_IEPsCount = DISPID_InkExtendedProperties.Count;
pub const DISPID_IEPsAdd = DISPID_InkExtendedProperties.Add;
pub const DISPID_IEPsRemove = DISPID_InkExtendedProperties.Remove;
pub const DISPID_IEPsClear = DISPID_InkExtendedProperties.Clear;
pub const DISPID_IEPsDoesPropertyExist = DISPID_InkExtendedProperties.DoesPropertyExist;

pub const DISPID_InkDrawingAttributes = enum(i32) {
    Height = 1,
    Color = 2,
    Width = 3,
    FitToCurve = 4,
    IgnorePressure = 5,
    AntiAliased = 6,
    Transparency = 7,
    RasterOperation = 8,
    PenTip = 9,
    Clone = 10,
    ExtendedProperties = 11,
};
pub const DISPID_DAHeight = DISPID_InkDrawingAttributes.Height;
pub const DISPID_DAColor = DISPID_InkDrawingAttributes.Color;
pub const DISPID_DAWidth = DISPID_InkDrawingAttributes.Width;
pub const DISPID_DAFitToCurve = DISPID_InkDrawingAttributes.FitToCurve;
pub const DISPID_DAIgnorePressure = DISPID_InkDrawingAttributes.IgnorePressure;
pub const DISPID_DAAntiAliased = DISPID_InkDrawingAttributes.AntiAliased;
pub const DISPID_DATransparency = DISPID_InkDrawingAttributes.Transparency;
pub const DISPID_DARasterOperation = DISPID_InkDrawingAttributes.RasterOperation;
pub const DISPID_DAPenTip = DISPID_InkDrawingAttributes.PenTip;
pub const DISPID_DAClone = DISPID_InkDrawingAttributes.Clone;
pub const DISPID_DAExtendedProperties = DISPID_InkDrawingAttributes.ExtendedProperties;

pub const DISPID_InkTransform = enum(i32) {
    Reset = 1,
    Translate = 2,
    Rotate = 3,
    Reflect = 4,
    Shear = 5,
    Scale = 6,
    eM11 = 7,
    eM12 = 8,
    eM21 = 9,
    eM22 = 10,
    eDx = 11,
    eDy = 12,
    GetTransform = 13,
    SetTransform = 14,
    Data = 15,
};
pub const DISPID_ITReset = DISPID_InkTransform.Reset;
pub const DISPID_ITTranslate = DISPID_InkTransform.Translate;
pub const DISPID_ITRotate = DISPID_InkTransform.Rotate;
pub const DISPID_ITReflect = DISPID_InkTransform.Reflect;
pub const DISPID_ITShear = DISPID_InkTransform.Shear;
pub const DISPID_ITScale = DISPID_InkTransform.Scale;
pub const DISPID_ITeM11 = DISPID_InkTransform.eM11;
pub const DISPID_ITeM12 = DISPID_InkTransform.eM12;
pub const DISPID_ITeM21 = DISPID_InkTransform.eM21;
pub const DISPID_ITeM22 = DISPID_InkTransform.eM22;
pub const DISPID_ITeDx = DISPID_InkTransform.eDx;
pub const DISPID_ITeDy = DISPID_InkTransform.eDy;
pub const DISPID_ITGetTransform = DISPID_InkTransform.GetTransform;
pub const DISPID_ITSetTransform = DISPID_InkTransform.SetTransform;
pub const DISPID_ITData = DISPID_InkTransform.Data;

pub const InkApplicationGesture = enum(i32) {
    AllGestures = 0,
    NoGesture = 61440,
    Scratchout = 61441,
    Triangle = 61442,
    Square = 61443,
    Star = 61444,
    Check = 61445,
    Curlicue = 61456,
    DoubleCurlicue = 61457,
    Circle = 61472,
    DoubleCircle = 61473,
    SemiCircleLeft = 61480,
    SemiCircleRight = 61481,
    ChevronUp = 61488,
    ChevronDown = 61489,
    ChevronLeft = 61490,
    ChevronRight = 61491,
    ArrowUp = 61496,
    ArrowDown = 61497,
    ArrowLeft = 61498,
    ArrowRight = 61499,
    Up = 61528,
    Down = 61529,
    Left = 61530,
    Right = 61531,
    UpDown = 61536,
    DownUp = 61537,
    LeftRight = 61538,
    RightLeft = 61539,
    UpLeftLong = 61540,
    UpRightLong = 61541,
    DownLeftLong = 61542,
    DownRightLong = 61543,
    UpLeft = 61544,
    UpRight = 61545,
    DownLeft = 61546,
    DownRight = 61547,
    LeftUp = 61548,
    LeftDown = 61549,
    RightUp = 61550,
    RightDown = 61551,
    Exclamation = 61604,
    Tap = 61680,
    DoubleTap = 61681,
};
pub const IAG_AllGestures = InkApplicationGesture.AllGestures;
pub const IAG_NoGesture = InkApplicationGesture.NoGesture;
pub const IAG_Scratchout = InkApplicationGesture.Scratchout;
pub const IAG_Triangle = InkApplicationGesture.Triangle;
pub const IAG_Square = InkApplicationGesture.Square;
pub const IAG_Star = InkApplicationGesture.Star;
pub const IAG_Check = InkApplicationGesture.Check;
pub const IAG_Curlicue = InkApplicationGesture.Curlicue;
pub const IAG_DoubleCurlicue = InkApplicationGesture.DoubleCurlicue;
pub const IAG_Circle = InkApplicationGesture.Circle;
pub const IAG_DoubleCircle = InkApplicationGesture.DoubleCircle;
pub const IAG_SemiCircleLeft = InkApplicationGesture.SemiCircleLeft;
pub const IAG_SemiCircleRight = InkApplicationGesture.SemiCircleRight;
pub const IAG_ChevronUp = InkApplicationGesture.ChevronUp;
pub const IAG_ChevronDown = InkApplicationGesture.ChevronDown;
pub const IAG_ChevronLeft = InkApplicationGesture.ChevronLeft;
pub const IAG_ChevronRight = InkApplicationGesture.ChevronRight;
pub const IAG_ArrowUp = InkApplicationGesture.ArrowUp;
pub const IAG_ArrowDown = InkApplicationGesture.ArrowDown;
pub const IAG_ArrowLeft = InkApplicationGesture.ArrowLeft;
pub const IAG_ArrowRight = InkApplicationGesture.ArrowRight;
pub const IAG_Up = InkApplicationGesture.Up;
pub const IAG_Down = InkApplicationGesture.Down;
pub const IAG_Left = InkApplicationGesture.Left;
pub const IAG_Right = InkApplicationGesture.Right;
pub const IAG_UpDown = InkApplicationGesture.UpDown;
pub const IAG_DownUp = InkApplicationGesture.DownUp;
pub const IAG_LeftRight = InkApplicationGesture.LeftRight;
pub const IAG_RightLeft = InkApplicationGesture.RightLeft;
pub const IAG_UpLeftLong = InkApplicationGesture.UpLeftLong;
pub const IAG_UpRightLong = InkApplicationGesture.UpRightLong;
pub const IAG_DownLeftLong = InkApplicationGesture.DownLeftLong;
pub const IAG_DownRightLong = InkApplicationGesture.DownRightLong;
pub const IAG_UpLeft = InkApplicationGesture.UpLeft;
pub const IAG_UpRight = InkApplicationGesture.UpRight;
pub const IAG_DownLeft = InkApplicationGesture.DownLeft;
pub const IAG_DownRight = InkApplicationGesture.DownRight;
pub const IAG_LeftUp = InkApplicationGesture.LeftUp;
pub const IAG_LeftDown = InkApplicationGesture.LeftDown;
pub const IAG_RightUp = InkApplicationGesture.RightUp;
pub const IAG_RightDown = InkApplicationGesture.RightDown;
pub const IAG_Exclamation = InkApplicationGesture.Exclamation;
pub const IAG_Tap = InkApplicationGesture.Tap;
pub const IAG_DoubleTap = InkApplicationGesture.DoubleTap;

pub const InkSystemGesture = enum(i32) {
    Tap = 16,
    DoubleTap = 17,
    RightTap = 18,
    Drag = 19,
    RightDrag = 20,
    HoldEnter = 21,
    HoldLeave = 22,
    HoverEnter = 23,
    HoverLeave = 24,
    Flick = 31,
};
pub const ISG_Tap = InkSystemGesture.Tap;
pub const ISG_DoubleTap = InkSystemGesture.DoubleTap;
pub const ISG_RightTap = InkSystemGesture.RightTap;
pub const ISG_Drag = InkSystemGesture.Drag;
pub const ISG_RightDrag = InkSystemGesture.RightDrag;
pub const ISG_HoldEnter = InkSystemGesture.HoldEnter;
pub const ISG_HoldLeave = InkSystemGesture.HoldLeave;
pub const ISG_HoverEnter = InkSystemGesture.HoverEnter;
pub const ISG_HoverLeave = InkSystemGesture.HoverLeave;
pub const ISG_Flick = InkSystemGesture.Flick;

pub const InkRecognitionConfidence = enum(i32) {
    Strong = 0,
    Intermediate = 1,
    Poor = 2,
};
pub const IRC_Strong = InkRecognitionConfidence.Strong;
pub const IRC_Intermediate = InkRecognitionConfidence.Intermediate;
pub const IRC_Poor = InkRecognitionConfidence.Poor;

pub const DISPID_InkGesture = enum(i32) {
    Id = 0,
    GetHotPoint = 1,
    Confidence = 2,
};
pub const DISPID_IGId = DISPID_InkGesture.Id;
pub const DISPID_IGGetHotPoint = DISPID_InkGesture.GetHotPoint;
pub const DISPID_IGConfidence = DISPID_InkGesture.Confidence;

pub const DISPID_InkCursor = enum(i32) {
    Name = 0,
    Id = 1,
    DrawingAttributes = 2,
    Buttons = 3,
    Inverted = 4,
    Tablet = 5,
};
pub const DISPID_ICsrName = DISPID_InkCursor.Name;
pub const DISPID_ICsrId = DISPID_InkCursor.Id;
pub const DISPID_ICsrDrawingAttributes = DISPID_InkCursor.DrawingAttributes;
pub const DISPID_ICsrButtons = DISPID_InkCursor.Buttons;
pub const DISPID_ICsrInverted = DISPID_InkCursor.Inverted;
pub const DISPID_ICsrTablet = DISPID_InkCursor.Tablet;

pub const DISPID_InkCursors = enum(i32) {
    _NewEnum = -4,
    Item = 0,
    Count = 1,
};
pub const DISPID_ICs_NewEnum = DISPID_InkCursors._NewEnum;
pub const DISPID_ICsItem = DISPID_InkCursors.Item;
pub const DISPID_ICsCount = DISPID_InkCursors.Count;

pub const InkCursorButtonState = enum(i32) {
    Unavailable = 0,
    Up = 1,
    Down = 2,
};
pub const ICBS_Unavailable = InkCursorButtonState.Unavailable;
pub const ICBS_Up = InkCursorButtonState.Up;
pub const ICBS_Down = InkCursorButtonState.Down;

pub const DISPID_InkCursorButton = enum(i32) {
    Name = 0,
    Id = 1,
    State = 2,
};
pub const DISPID_ICBName = DISPID_InkCursorButton.Name;
pub const DISPID_ICBId = DISPID_InkCursorButton.Id;
pub const DISPID_ICBState = DISPID_InkCursorButton.State;

pub const DISPID_InkCursorButtons = enum(i32) {
    _NewEnum = -4,
    Item = 0,
    Count = 1,
};
pub const DISPID_ICBs_NewEnum = DISPID_InkCursorButtons._NewEnum;
pub const DISPID_ICBsItem = DISPID_InkCursorButtons.Item;
pub const DISPID_ICBsCount = DISPID_InkCursorButtons.Count;

pub const TabletHardwareCapabilities = enum(i32) {
    Integrated = 1,
    CursorMustTouch = 2,
    HardProximity = 4,
    CursorsHavePhysicalIds = 8,
};
pub const THWC_Integrated = TabletHardwareCapabilities.Integrated;
pub const THWC_CursorMustTouch = TabletHardwareCapabilities.CursorMustTouch;
pub const THWC_HardProximity = TabletHardwareCapabilities.HardProximity;
pub const THWC_CursorsHavePhysicalIds = TabletHardwareCapabilities.CursorsHavePhysicalIds;

pub const TabletPropertyMetricUnit = enum(i32) {
    Default = 0,
    Inches = 1,
    Centimeters = 2,
    Degrees = 3,
    Radians = 4,
    Seconds = 5,
    Pounds = 6,
    Grams = 7,
};
pub const TPMU_Default = TabletPropertyMetricUnit.Default;
pub const TPMU_Inches = TabletPropertyMetricUnit.Inches;
pub const TPMU_Centimeters = TabletPropertyMetricUnit.Centimeters;
pub const TPMU_Degrees = TabletPropertyMetricUnit.Degrees;
pub const TPMU_Radians = TabletPropertyMetricUnit.Radians;
pub const TPMU_Seconds = TabletPropertyMetricUnit.Seconds;
pub const TPMU_Pounds = TabletPropertyMetricUnit.Pounds;
pub const TPMU_Grams = TabletPropertyMetricUnit.Grams;

pub const DISPID_InkTablet = enum(i32) {
    Name = 0,
    PlugAndPlayId = 1,
    PropertyMetrics = 2,
    IsPacketPropertySupported = 3,
    MaximumInputRectangle = 4,
    HardwareCapabilities = 5,
};
pub const DISPID_ITName = DISPID_InkTablet.Name;
pub const DISPID_ITPlugAndPlayId = DISPID_InkTablet.PlugAndPlayId;
pub const DISPID_ITPropertyMetrics = DISPID_InkTablet.PropertyMetrics;
pub const DISPID_ITIsPacketPropertySupported = DISPID_InkTablet.IsPacketPropertySupported;
pub const DISPID_ITMaximumInputRectangle = DISPID_InkTablet.MaximumInputRectangle;
pub const DISPID_ITHardwareCapabilities = DISPID_InkTablet.HardwareCapabilities;

pub const TabletDeviceKind = enum(i32) {
    Mouse = 0,
    Pen = 1,
    Touch = 2,
};
pub const TDK_Mouse = TabletDeviceKind.Mouse;
pub const TDK_Pen = TabletDeviceKind.Pen;
pub const TDK_Touch = TabletDeviceKind.Touch;

pub const DISPID_InkTablet2 = enum(i32) {
    d = 0,
};
pub const DISPID_IT2DeviceKind = DISPID_InkTablet2.d;

pub const DISPID_InkTablet3 = enum(i32) {
    IsMultiTouch = 0,
    MaximumCursors = 1,
};
pub const DISPID_IT3IsMultiTouch = DISPID_InkTablet3.IsMultiTouch;
pub const DISPID_IT3MaximumCursors = DISPID_InkTablet3.MaximumCursors;

pub const DISPID_InkTablets = enum(i32) {
    _NewEnum = -4,
    Item = 0,
    DefaultTablet = 1,
    Count = 2,
    IsPacketPropertySupported = 3,
};
pub const DISPID_ITs_NewEnum = DISPID_InkTablets._NewEnum;
pub const DISPID_ITsItem = DISPID_InkTablets.Item;
pub const DISPID_ITsDefaultTablet = DISPID_InkTablets.DefaultTablet;
pub const DISPID_ITsCount = DISPID_InkTablets.Count;
pub const DISPID_ITsIsPacketPropertySupported = DISPID_InkTablets.IsPacketPropertySupported;

pub const DISPID_InkStrokeDisp = enum(i32) {
    InkIndex = 1,
    ID = 2,
    GetBoundingBox = 3,
    DrawingAttributes = 4,
    FindIntersections = 5,
    GetRectangleIntersections = 6,
    Clip = 7,
    HitTestCircle = 8,
    NearestPoint = 9,
    Split = 10,
    ExtendedProperties = 11,
    Ink = 12,
    BezierPoints = 13,
    PolylineCusps = 14,
    BezierCusps = 15,
    SelfIntersections = 16,
    PacketCount = 17,
    PacketSize = 18,
    PacketDescription = 19,
    Deleted = 20,
    GetPacketDescriptionPropertyMetrics = 21,
    GetPoints = 22,
    SetPoints = 23,
    GetPacketData = 24,
    GetPacketValuesByProperty = 25,
    SetPacketValuesByProperty = 26,
    GetFlattenedBezierPoints = 27,
    ScaleToRectangle = 28,
    Transform = 29,
    Move = 30,
    Rotate = 31,
    Shear = 32,
    Scale = 33,
};
pub const DISPID_ISDInkIndex = DISPID_InkStrokeDisp.InkIndex;
pub const DISPID_ISDID = DISPID_InkStrokeDisp.ID;
pub const DISPID_ISDGetBoundingBox = DISPID_InkStrokeDisp.GetBoundingBox;
pub const DISPID_ISDDrawingAttributes = DISPID_InkStrokeDisp.DrawingAttributes;
pub const DISPID_ISDFindIntersections = DISPID_InkStrokeDisp.FindIntersections;
pub const DISPID_ISDGetRectangleIntersections = DISPID_InkStrokeDisp.GetRectangleIntersections;
pub const DISPID_ISDClip = DISPID_InkStrokeDisp.Clip;
pub const DISPID_ISDHitTestCircle = DISPID_InkStrokeDisp.HitTestCircle;
pub const DISPID_ISDNearestPoint = DISPID_InkStrokeDisp.NearestPoint;
pub const DISPID_ISDSplit = DISPID_InkStrokeDisp.Split;
pub const DISPID_ISDExtendedProperties = DISPID_InkStrokeDisp.ExtendedProperties;
pub const DISPID_ISDInk = DISPID_InkStrokeDisp.Ink;
pub const DISPID_ISDBezierPoints = DISPID_InkStrokeDisp.BezierPoints;
pub const DISPID_ISDPolylineCusps = DISPID_InkStrokeDisp.PolylineCusps;
pub const DISPID_ISDBezierCusps = DISPID_InkStrokeDisp.BezierCusps;
pub const DISPID_ISDSelfIntersections = DISPID_InkStrokeDisp.SelfIntersections;
pub const DISPID_ISDPacketCount = DISPID_InkStrokeDisp.PacketCount;
pub const DISPID_ISDPacketSize = DISPID_InkStrokeDisp.PacketSize;
pub const DISPID_ISDPacketDescription = DISPID_InkStrokeDisp.PacketDescription;
pub const DISPID_ISDDeleted = DISPID_InkStrokeDisp.Deleted;
pub const DISPID_ISDGetPacketDescriptionPropertyMetrics = DISPID_InkStrokeDisp.GetPacketDescriptionPropertyMetrics;
pub const DISPID_ISDGetPoints = DISPID_InkStrokeDisp.GetPoints;
pub const DISPID_ISDSetPoints = DISPID_InkStrokeDisp.SetPoints;
pub const DISPID_ISDGetPacketData = DISPID_InkStrokeDisp.GetPacketData;
pub const DISPID_ISDGetPacketValuesByProperty = DISPID_InkStrokeDisp.GetPacketValuesByProperty;
pub const DISPID_ISDSetPacketValuesByProperty = DISPID_InkStrokeDisp.SetPacketValuesByProperty;
pub const DISPID_ISDGetFlattenedBezierPoints = DISPID_InkStrokeDisp.GetFlattenedBezierPoints;
pub const DISPID_ISDScaleToRectangle = DISPID_InkStrokeDisp.ScaleToRectangle;
pub const DISPID_ISDTransform = DISPID_InkStrokeDisp.Transform;
pub const DISPID_ISDMove = DISPID_InkStrokeDisp.Move;
pub const DISPID_ISDRotate = DISPID_InkStrokeDisp.Rotate;
pub const DISPID_ISDShear = DISPID_InkStrokeDisp.Shear;
pub const DISPID_ISDScale = DISPID_InkStrokeDisp.Scale;

pub const DISPID_InkStrokes = enum(i32) {
    _NewEnum = -4,
    Item = 0,
    Count = 1,
    Valid = 2,
    Ink = 3,
    Add = 4,
    AddStrokes = 5,
    Remove = 6,
    RemoveStrokes = 7,
    ToString = 8,
    ModifyDrawingAttributes = 9,
    GetBoundingBox = 10,
    ScaleToRectangle = 11,
    Transform = 12,
    Move = 13,
    Rotate = 14,
    Shear = 15,
    Scale = 16,
    Clip = 17,
    RecognitionResult = 18,
    RemoveRecognitionResult = 19,
};
pub const DISPID_ISs_NewEnum = DISPID_InkStrokes._NewEnum;
pub const DISPID_ISsItem = DISPID_InkStrokes.Item;
pub const DISPID_ISsCount = DISPID_InkStrokes.Count;
pub const DISPID_ISsValid = DISPID_InkStrokes.Valid;
pub const DISPID_ISsInk = DISPID_InkStrokes.Ink;
pub const DISPID_ISsAdd = DISPID_InkStrokes.Add;
pub const DISPID_ISsAddStrokes = DISPID_InkStrokes.AddStrokes;
pub const DISPID_ISsRemove = DISPID_InkStrokes.Remove;
pub const DISPID_ISsRemoveStrokes = DISPID_InkStrokes.RemoveStrokes;
pub const DISPID_ISsToString = DISPID_InkStrokes.ToString;
pub const DISPID_ISsModifyDrawingAttributes = DISPID_InkStrokes.ModifyDrawingAttributes;
pub const DISPID_ISsGetBoundingBox = DISPID_InkStrokes.GetBoundingBox;
pub const DISPID_ISsScaleToRectangle = DISPID_InkStrokes.ScaleToRectangle;
pub const DISPID_ISsTransform = DISPID_InkStrokes.Transform;
pub const DISPID_ISsMove = DISPID_InkStrokes.Move;
pub const DISPID_ISsRotate = DISPID_InkStrokes.Rotate;
pub const DISPID_ISsShear = DISPID_InkStrokes.Shear;
pub const DISPID_ISsScale = DISPID_InkStrokes.Scale;
pub const DISPID_ISsClip = DISPID_InkStrokes.Clip;
pub const DISPID_ISsRecognitionResult = DISPID_InkStrokes.RecognitionResult;
pub const DISPID_ISsRemoveRecognitionResult = DISPID_InkStrokes.RemoveRecognitionResult;

pub const DISPID_InkCustomStrokes = enum(i32) {
    _NewEnum = -4,
    Item = 0,
    Count = 1,
    Add = 2,
    Remove = 3,
    Clear = 4,
};
pub const DISPID_ICSs_NewEnum = DISPID_InkCustomStrokes._NewEnum;
pub const DISPID_ICSsItem = DISPID_InkCustomStrokes.Item;
pub const DISPID_ICSsCount = DISPID_InkCustomStrokes.Count;
pub const DISPID_ICSsAdd = DISPID_InkCustomStrokes.Add;
pub const DISPID_ICSsRemove = DISPID_InkCustomStrokes.Remove;
pub const DISPID_ICSsClear = DISPID_InkCustomStrokes.Clear;

pub const DISPID_StrokeEvent = enum(i32) {
    Added = 1,
    Removed = 2,
};
pub const DISPID_SEStrokesAdded = DISPID_StrokeEvent.Added;
pub const DISPID_SEStrokesRemoved = DISPID_StrokeEvent.Removed;

pub const DISPID_Ink = enum(i32) {
    Strokes = 1,
    ExtendedProperties = 2,
    GetBoundingBox = 3,
    DeleteStrokes = 4,
    DeleteStroke = 5,
    ExtractStrokes = 6,
    ExtractWithRectangle = 7,
    Dirty = 8,
    CustomStrokes = 9,
    Clone = 10,
    HitTestCircle = 11,
    HitTestWithRectangle = 12,
    HitTestWithLasso = 13,
    NearestPoint = 14,
    CreateStrokes = 15,
    CreateStroke = 16,
    AddStrokesAtRectangle = 17,
    Clip = 18,
    Save = 19,
    Load = 20,
    CreateStrokeFromPoints = 21,
    ClipboardCopyWithRectangle = 22,
    ClipboardCopy = 23,
    CanPaste = 24,
    ClipboardPaste = 25,
};
pub const DISPID_IStrokes = DISPID_Ink.Strokes;
pub const DISPID_IExtendedProperties = DISPID_Ink.ExtendedProperties;
pub const DISPID_IGetBoundingBox = DISPID_Ink.GetBoundingBox;
pub const DISPID_IDeleteStrokes = DISPID_Ink.DeleteStrokes;
pub const DISPID_IDeleteStroke = DISPID_Ink.DeleteStroke;
pub const DISPID_IExtractStrokes = DISPID_Ink.ExtractStrokes;
pub const DISPID_IExtractWithRectangle = DISPID_Ink.ExtractWithRectangle;
pub const DISPID_IDirty = DISPID_Ink.Dirty;
pub const DISPID_ICustomStrokes = DISPID_Ink.CustomStrokes;
pub const DISPID_IClone = DISPID_Ink.Clone;
pub const DISPID_IHitTestCircle = DISPID_Ink.HitTestCircle;
pub const DISPID_IHitTestWithRectangle = DISPID_Ink.HitTestWithRectangle;
pub const DISPID_IHitTestWithLasso = DISPID_Ink.HitTestWithLasso;
pub const DISPID_INearestPoint = DISPID_Ink.NearestPoint;
pub const DISPID_ICreateStrokes = DISPID_Ink.CreateStrokes;
pub const DISPID_ICreateStroke = DISPID_Ink.CreateStroke;
pub const DISPID_IAddStrokesAtRectangle = DISPID_Ink.AddStrokesAtRectangle;
pub const DISPID_IClip = DISPID_Ink.Clip;
pub const DISPID_ISave = DISPID_Ink.Save;
pub const DISPID_ILoad = DISPID_Ink.Load;
pub const DISPID_ICreateStrokeFromPoints = DISPID_Ink.CreateStrokeFromPoints;
pub const DISPID_IClipboardCopyWithRectangle = DISPID_Ink.ClipboardCopyWithRectangle;
pub const DISPID_IClipboardCopy = DISPID_Ink.ClipboardCopy;
pub const DISPID_ICanPaste = DISPID_Ink.CanPaste;
pub const DISPID_IClipboardPaste = DISPID_Ink.ClipboardPaste;

pub const DISPID_InkEvent = enum(i32) {
    Added = 1,
    Deleted = 2,
};
pub const DISPID_IEInkAdded = DISPID_InkEvent.Added;
pub const DISPID_IEInkDeleted = DISPID_InkEvent.Deleted;

pub const DISPID_InkRenderer = enum(i32) {
    GetViewTransform = 1,
    SetViewTransform = 2,
    GetObjectTransform = 3,
    SetObjectTransform = 4,
    Draw = 5,
    DrawStroke = 6,
    PixelToInkSpace = 7,
    InkSpaceToPixel = 8,
    PixelToInkSpaceFromPoints = 9,
    InkSpaceToPixelFromPoints = 10,
    Measure = 11,
    MeasureStroke = 12,
    Move = 13,
    Rotate = 14,
    Scale = 15,
};
pub const DISPID_IRGetViewTransform = DISPID_InkRenderer.GetViewTransform;
pub const DISPID_IRSetViewTransform = DISPID_InkRenderer.SetViewTransform;
pub const DISPID_IRGetObjectTransform = DISPID_InkRenderer.GetObjectTransform;
pub const DISPID_IRSetObjectTransform = DISPID_InkRenderer.SetObjectTransform;
pub const DISPID_IRDraw = DISPID_InkRenderer.Draw;
pub const DISPID_IRDrawStroke = DISPID_InkRenderer.DrawStroke;
pub const DISPID_IRPixelToInkSpace = DISPID_InkRenderer.PixelToInkSpace;
pub const DISPID_IRInkSpaceToPixel = DISPID_InkRenderer.InkSpaceToPixel;
pub const DISPID_IRPixelToInkSpaceFromPoints = DISPID_InkRenderer.PixelToInkSpaceFromPoints;
pub const DISPID_IRInkSpaceToPixelFromPoints = DISPID_InkRenderer.InkSpaceToPixelFromPoints;
pub const DISPID_IRMeasure = DISPID_InkRenderer.Measure;
pub const DISPID_IRMeasureStroke = DISPID_InkRenderer.MeasureStroke;
pub const DISPID_IRMove = DISPID_InkRenderer.Move;
pub const DISPID_IRRotate = DISPID_InkRenderer.Rotate;
pub const DISPID_IRScale = DISPID_InkRenderer.Scale;

pub const InkCollectorEventInterest = enum(i32) {
    DefaultEvents = -1,
    CursorDown = 0,
    Stroke = 1,
    NewPackets = 2,
    NewInAirPackets = 3,
    CursorButtonDown = 4,
    CursorButtonUp = 5,
    CursorInRange = 6,
    CursorOutOfRange = 7,
    SystemGesture = 8,
    TabletAdded = 9,
    TabletRemoved = 10,
    MouseDown = 11,
    MouseMove = 12,
    MouseUp = 13,
    MouseWheel = 14,
    DblClick = 15,
    AllEvents = 16,
};
pub const ICEI_DefaultEvents = InkCollectorEventInterest.DefaultEvents;
pub const ICEI_CursorDown = InkCollectorEventInterest.CursorDown;
pub const ICEI_Stroke = InkCollectorEventInterest.Stroke;
pub const ICEI_NewPackets = InkCollectorEventInterest.NewPackets;
pub const ICEI_NewInAirPackets = InkCollectorEventInterest.NewInAirPackets;
pub const ICEI_CursorButtonDown = InkCollectorEventInterest.CursorButtonDown;
pub const ICEI_CursorButtonUp = InkCollectorEventInterest.CursorButtonUp;
pub const ICEI_CursorInRange = InkCollectorEventInterest.CursorInRange;
pub const ICEI_CursorOutOfRange = InkCollectorEventInterest.CursorOutOfRange;
pub const ICEI_SystemGesture = InkCollectorEventInterest.SystemGesture;
pub const ICEI_TabletAdded = InkCollectorEventInterest.TabletAdded;
pub const ICEI_TabletRemoved = InkCollectorEventInterest.TabletRemoved;
pub const ICEI_MouseDown = InkCollectorEventInterest.MouseDown;
pub const ICEI_MouseMove = InkCollectorEventInterest.MouseMove;
pub const ICEI_MouseUp = InkCollectorEventInterest.MouseUp;
pub const ICEI_MouseWheel = InkCollectorEventInterest.MouseWheel;
pub const ICEI_DblClick = InkCollectorEventInterest.DblClick;
pub const ICEI_AllEvents = InkCollectorEventInterest.AllEvents;

pub const InkMouseButton = enum(i32) {
    Left = 1,
    Right = 2,
    Middle = 4,
};
pub const IMF_Left = InkMouseButton.Left;
pub const IMF_Right = InkMouseButton.Right;
pub const IMF_Middle = InkMouseButton.Middle;

pub const InkShiftKeyModifierFlags = enum(i32) {
    Shift = 1,
    Control = 2,
    Alt = 4,
};
pub const IKM_Shift = InkShiftKeyModifierFlags.Shift;
pub const IKM_Control = InkShiftKeyModifierFlags.Control;
pub const IKM_Alt = InkShiftKeyModifierFlags.Alt;

pub const DISPID_InkCollectorEvent = enum(i32) {
    CEStroke = 1,
    CECursorDown = 2,
    CENewPackets = 3,
    CENewInAirPackets = 4,
    CECursorButtonDown = 5,
    CECursorButtonUp = 6,
    CECursorInRange = 7,
    CECursorOutOfRange = 8,
    CESystemGesture = 9,
    CEGesture = 10,
    CETabletAdded = 11,
    CETabletRemoved = 12,
    OEPainting = 13,
    OEPainted = 14,
    OESelectionChanging = 15,
    OESelectionChanged = 16,
    OESelectionMoving = 17,
    OESelectionMoved = 18,
    OESelectionResizing = 19,
    OESelectionResized = 20,
    OEStrokesDeleting = 21,
    OEStrokesDeleted = 22,
    PEChangeUICues = 23,
    PEClick = 24,
    PEDblClick = 25,
    PEInvalidated = 26,
    PEMouseDown = 27,
    PEMouseEnter = 28,
    PEMouseHover = 29,
    PEMouseLeave = 30,
    PEMouseMove = 31,
    PEMouseUp = 32,
    PEMouseWheel = 33,
    PESizeModeChanged = 34,
    PEStyleChanged = 35,
    PESystemColorsChanged = 36,
    PEKeyDown = 37,
    PEKeyPress = 38,
    PEKeyUp = 39,
    PEResize = 40,
    PESizeChanged = 41,
};
pub const DISPID_ICEStroke = DISPID_InkCollectorEvent.CEStroke;
pub const DISPID_ICECursorDown = DISPID_InkCollectorEvent.CECursorDown;
pub const DISPID_ICENewPackets = DISPID_InkCollectorEvent.CENewPackets;
pub const DISPID_ICENewInAirPackets = DISPID_InkCollectorEvent.CENewInAirPackets;
pub const DISPID_ICECursorButtonDown = DISPID_InkCollectorEvent.CECursorButtonDown;
pub const DISPID_ICECursorButtonUp = DISPID_InkCollectorEvent.CECursorButtonUp;
pub const DISPID_ICECursorInRange = DISPID_InkCollectorEvent.CECursorInRange;
pub const DISPID_ICECursorOutOfRange = DISPID_InkCollectorEvent.CECursorOutOfRange;
pub const DISPID_ICESystemGesture = DISPID_InkCollectorEvent.CESystemGesture;
pub const DISPID_ICEGesture = DISPID_InkCollectorEvent.CEGesture;
pub const DISPID_ICETabletAdded = DISPID_InkCollectorEvent.CETabletAdded;
pub const DISPID_ICETabletRemoved = DISPID_InkCollectorEvent.CETabletRemoved;
pub const DISPID_IOEPainting = DISPID_InkCollectorEvent.OEPainting;
pub const DISPID_IOEPainted = DISPID_InkCollectorEvent.OEPainted;
pub const DISPID_IOESelectionChanging = DISPID_InkCollectorEvent.OESelectionChanging;
pub const DISPID_IOESelectionChanged = DISPID_InkCollectorEvent.OESelectionChanged;
pub const DISPID_IOESelectionMoving = DISPID_InkCollectorEvent.OESelectionMoving;
pub const DISPID_IOESelectionMoved = DISPID_InkCollectorEvent.OESelectionMoved;
pub const DISPID_IOESelectionResizing = DISPID_InkCollectorEvent.OESelectionResizing;
pub const DISPID_IOESelectionResized = DISPID_InkCollectorEvent.OESelectionResized;
pub const DISPID_IOEStrokesDeleting = DISPID_InkCollectorEvent.OEStrokesDeleting;
pub const DISPID_IOEStrokesDeleted = DISPID_InkCollectorEvent.OEStrokesDeleted;
pub const DISPID_IPEChangeUICues = DISPID_InkCollectorEvent.PEChangeUICues;
pub const DISPID_IPEClick = DISPID_InkCollectorEvent.PEClick;
pub const DISPID_IPEDblClick = DISPID_InkCollectorEvent.PEDblClick;
pub const DISPID_IPEInvalidated = DISPID_InkCollectorEvent.PEInvalidated;
pub const DISPID_IPEMouseDown = DISPID_InkCollectorEvent.PEMouseDown;
pub const DISPID_IPEMouseEnter = DISPID_InkCollectorEvent.PEMouseEnter;
pub const DISPID_IPEMouseHover = DISPID_InkCollectorEvent.PEMouseHover;
pub const DISPID_IPEMouseLeave = DISPID_InkCollectorEvent.PEMouseLeave;
pub const DISPID_IPEMouseMove = DISPID_InkCollectorEvent.PEMouseMove;
pub const DISPID_IPEMouseUp = DISPID_InkCollectorEvent.PEMouseUp;
pub const DISPID_IPEMouseWheel = DISPID_InkCollectorEvent.PEMouseWheel;
pub const DISPID_IPESizeModeChanged = DISPID_InkCollectorEvent.PESizeModeChanged;
pub const DISPID_IPEStyleChanged = DISPID_InkCollectorEvent.PEStyleChanged;
pub const DISPID_IPESystemColorsChanged = DISPID_InkCollectorEvent.PESystemColorsChanged;
pub const DISPID_IPEKeyDown = DISPID_InkCollectorEvent.PEKeyDown;
pub const DISPID_IPEKeyPress = DISPID_InkCollectorEvent.PEKeyPress;
pub const DISPID_IPEKeyUp = DISPID_InkCollectorEvent.PEKeyUp;
pub const DISPID_IPEResize = DISPID_InkCollectorEvent.PEResize;
pub const DISPID_IPESizeChanged = DISPID_InkCollectorEvent.PESizeChanged;

pub const InkOverlayEditingMode = enum(i32) {
    Ink = 0,
    Delete = 1,
    Select = 2,
};
pub const IOEM_Ink = InkOverlayEditingMode.Ink;
pub const IOEM_Delete = InkOverlayEditingMode.Delete;
pub const IOEM_Select = InkOverlayEditingMode.Select;

pub const InkOverlayAttachMode = enum(i32) {
    Behind = 0,
    InFront = 1,
};
pub const IOAM_Behind = InkOverlayAttachMode.Behind;
pub const IOAM_InFront = InkOverlayAttachMode.InFront;

pub const InkPictureSizeMode = enum(i32) {
    AutoSize = 0,
    CenterImage = 1,
    Normal = 2,
    StretchImage = 3,
};
pub const IPSM_AutoSize = InkPictureSizeMode.AutoSize;
pub const IPSM_CenterImage = InkPictureSizeMode.CenterImage;
pub const IPSM_Normal = InkPictureSizeMode.Normal;
pub const IPSM_StretchImage = InkPictureSizeMode.StretchImage;

pub const InkOverlayEraserMode = enum(i32) {
    StrokeErase = 0,
    PointErase = 1,
};
pub const IOERM_StrokeErase = InkOverlayEraserMode.StrokeErase;
pub const IOERM_PointErase = InkOverlayEraserMode.PointErase;

pub const InkCollectionMode = enum(i32) {
    InkOnly = 0,
    GestureOnly = 1,
    InkAndGesture = 2,
};
pub const ICM_InkOnly = InkCollectionMode.InkOnly;
pub const ICM_GestureOnly = InkCollectionMode.GestureOnly;
pub const ICM_InkAndGesture = InkCollectionMode.InkAndGesture;

pub const DISPID_InkCollector = enum(i32) {
    CEnabled = 1,
    CHwnd = 2,
    CPaint = 3,
    CText = 4,
    CDefaultDrawingAttributes = 5,
    CRenderer = 6,
    CInk = 7,
    CAutoRedraw = 8,
    CCollectingInk = 9,
    CSetEventInterest = 10,
    CGetEventInterest = 11,
    OEditingMode = 12,
    OSelection = 13,
    OAttachMode = 14,
    OHitTestSelection = 15,
    ODraw = 16,
    PPicture = 17,
    PSizeMode = 18,
    PBackColor = 19,
    CCursors = 20,
    CMarginX = 21,
    CMarginY = 22,
    CSetWindowInputRectangle = 23,
    CGetWindowInputRectangle = 24,
    CTablet = 25,
    CSetAllTabletsMode = 26,
    CSetSingleTabletIntegratedMode = 27,
    CCollectionMode = 28,
    CSetGestureStatus = 29,
    CGetGestureStatus = 30,
    CDynamicRendering = 31,
    CDesiredPacketDescription = 32,
    OEraserMode = 33,
    OEraserWidth = 34,
    CMouseIcon = 35,
    CMousePointer = 36,
    PInkEnabled = 37,
    CSupportHighContrastInk = 38,
    OSupportHighContrastSelectionUI = 39,
};
pub const DISPID_ICEnabled = DISPID_InkCollector.CEnabled;
pub const DISPID_ICHwnd = DISPID_InkCollector.CHwnd;
pub const DISPID_ICPaint = DISPID_InkCollector.CPaint;
pub const DISPID_ICText = DISPID_InkCollector.CText;
pub const DISPID_ICDefaultDrawingAttributes = DISPID_InkCollector.CDefaultDrawingAttributes;
pub const DISPID_ICRenderer = DISPID_InkCollector.CRenderer;
pub const DISPID_ICInk = DISPID_InkCollector.CInk;
pub const DISPID_ICAutoRedraw = DISPID_InkCollector.CAutoRedraw;
pub const DISPID_ICCollectingInk = DISPID_InkCollector.CCollectingInk;
pub const DISPID_ICSetEventInterest = DISPID_InkCollector.CSetEventInterest;
pub const DISPID_ICGetEventInterest = DISPID_InkCollector.CGetEventInterest;
pub const DISPID_IOEditingMode = DISPID_InkCollector.OEditingMode;
pub const DISPID_IOSelection = DISPID_InkCollector.OSelection;
pub const DISPID_IOAttachMode = DISPID_InkCollector.OAttachMode;
pub const DISPID_IOHitTestSelection = DISPID_InkCollector.OHitTestSelection;
pub const DISPID_IODraw = DISPID_InkCollector.ODraw;
pub const DISPID_IPPicture = DISPID_InkCollector.PPicture;
pub const DISPID_IPSizeMode = DISPID_InkCollector.PSizeMode;
pub const DISPID_IPBackColor = DISPID_InkCollector.PBackColor;
pub const DISPID_ICCursors = DISPID_InkCollector.CCursors;
pub const DISPID_ICMarginX = DISPID_InkCollector.CMarginX;
pub const DISPID_ICMarginY = DISPID_InkCollector.CMarginY;
pub const DISPID_ICSetWindowInputRectangle = DISPID_InkCollector.CSetWindowInputRectangle;
pub const DISPID_ICGetWindowInputRectangle = DISPID_InkCollector.CGetWindowInputRectangle;
pub const DISPID_ICTablet = DISPID_InkCollector.CTablet;
pub const DISPID_ICSetAllTabletsMode = DISPID_InkCollector.CSetAllTabletsMode;
pub const DISPID_ICSetSingleTabletIntegratedMode = DISPID_InkCollector.CSetSingleTabletIntegratedMode;
pub const DISPID_ICCollectionMode = DISPID_InkCollector.CCollectionMode;
pub const DISPID_ICSetGestureStatus = DISPID_InkCollector.CSetGestureStatus;
pub const DISPID_ICGetGestureStatus = DISPID_InkCollector.CGetGestureStatus;
pub const DISPID_ICDynamicRendering = DISPID_InkCollector.CDynamicRendering;
pub const DISPID_ICDesiredPacketDescription = DISPID_InkCollector.CDesiredPacketDescription;
pub const DISPID_IOEraserMode = DISPID_InkCollector.OEraserMode;
pub const DISPID_IOEraserWidth = DISPID_InkCollector.OEraserWidth;
pub const DISPID_ICMouseIcon = DISPID_InkCollector.CMouseIcon;
pub const DISPID_ICMousePointer = DISPID_InkCollector.CMousePointer;
pub const DISPID_IPInkEnabled = DISPID_InkCollector.PInkEnabled;
pub const DISPID_ICSupportHighContrastInk = DISPID_InkCollector.CSupportHighContrastInk;
pub const DISPID_IOSupportHighContrastSelectionUI = DISPID_InkCollector.OSupportHighContrastSelectionUI;

pub const DISPID_InkRecognizer = enum(i32) {
    Clsid = 1,
    Name = 2,
    Vendor = 3,
    Capabilities = 4,
    LanguageID = 5,
    PreferredPacketDescription = 6,
    CreateRecognizerContext = 7,
    SupportedProperties = 8,
};
pub const DISPID_RecoClsid = DISPID_InkRecognizer.Clsid;
pub const DISPID_RecoName = DISPID_InkRecognizer.Name;
pub const DISPID_RecoVendor = DISPID_InkRecognizer.Vendor;
pub const DISPID_RecoCapabilities = DISPID_InkRecognizer.Capabilities;
pub const DISPID_RecoLanguageID = DISPID_InkRecognizer.LanguageID;
pub const DISPID_RecoPreferredPacketDescription = DISPID_InkRecognizer.PreferredPacketDescription;
pub const DISPID_RecoCreateRecognizerContext = DISPID_InkRecognizer.CreateRecognizerContext;
pub const DISPID_RecoSupportedProperties = DISPID_InkRecognizer.SupportedProperties;

pub const InkRecognizerCapabilities = enum(i32) {
    DontCare = 1,
    Object = 2,
    FreeInput = 4,
    LinedInput = 8,
    BoxedInput = 16,
    CharacterAutoCompletionInput = 32,
    RightAndDown = 64,
    LeftAndDown = 128,
    DownAndLeft = 256,
    DownAndRight = 512,
    ArbitraryAngle = 1024,
    Lattice = 2048,
    AdviseInkChange = 4096,
    StrokeReorder = 8192,
    Personalizable = 16384,
    PrefersArbitraryAngle = 32768,
    PrefersParagraphBreaking = 65536,
    PrefersSegmentation = 131072,
    Cursive = 262144,
    TextPrediction = 524288,
    Alpha = 1048576,
    Beta = 2097152,
};
pub const IRC_DontCare = InkRecognizerCapabilities.DontCare;
pub const IRC_Object = InkRecognizerCapabilities.Object;
pub const IRC_FreeInput = InkRecognizerCapabilities.FreeInput;
pub const IRC_LinedInput = InkRecognizerCapabilities.LinedInput;
pub const IRC_BoxedInput = InkRecognizerCapabilities.BoxedInput;
pub const IRC_CharacterAutoCompletionInput = InkRecognizerCapabilities.CharacterAutoCompletionInput;
pub const IRC_RightAndDown = InkRecognizerCapabilities.RightAndDown;
pub const IRC_LeftAndDown = InkRecognizerCapabilities.LeftAndDown;
pub const IRC_DownAndLeft = InkRecognizerCapabilities.DownAndLeft;
pub const IRC_DownAndRight = InkRecognizerCapabilities.DownAndRight;
pub const IRC_ArbitraryAngle = InkRecognizerCapabilities.ArbitraryAngle;
pub const IRC_Lattice = InkRecognizerCapabilities.Lattice;
pub const IRC_AdviseInkChange = InkRecognizerCapabilities.AdviseInkChange;
pub const IRC_StrokeReorder = InkRecognizerCapabilities.StrokeReorder;
pub const IRC_Personalizable = InkRecognizerCapabilities.Personalizable;
pub const IRC_PrefersArbitraryAngle = InkRecognizerCapabilities.PrefersArbitraryAngle;
pub const IRC_PrefersParagraphBreaking = InkRecognizerCapabilities.PrefersParagraphBreaking;
pub const IRC_PrefersSegmentation = InkRecognizerCapabilities.PrefersSegmentation;
pub const IRC_Cursive = InkRecognizerCapabilities.Cursive;
pub const IRC_TextPrediction = InkRecognizerCapabilities.TextPrediction;
pub const IRC_Alpha = InkRecognizerCapabilities.Alpha;
pub const IRC_Beta = InkRecognizerCapabilities.Beta;

pub const DISPID_InkRecognizer2 = enum(i32) {
    Id = 0,
    UnicodeRanges = 1,
};
pub const DISPID_RecoId = DISPID_InkRecognizer2.Id;
pub const DISPID_RecoUnicodeRanges = DISPID_InkRecognizer2.UnicodeRanges;

pub const DISPID_InkRecognizers = enum(i32) {
    _NewEnum = -4,
    Item = 0,
    Count = 1,
    GetDefaultRecognizer = 2,
};
pub const DISPID_IRecos_NewEnum = DISPID_InkRecognizers._NewEnum;
pub const DISPID_IRecosItem = DISPID_InkRecognizers.Item;
pub const DISPID_IRecosCount = DISPID_InkRecognizers.Count;
pub const DISPID_IRecosGetDefaultRecognizer = DISPID_InkRecognizers.GetDefaultRecognizer;

pub const InkRecognizerCharacterAutoCompletionMode = enum(i32) {
    Full = 0,
    Prefix = 1,
    Random = 2,
};
pub const IRCACM_Full = InkRecognizerCharacterAutoCompletionMode.Full;
pub const IRCACM_Prefix = InkRecognizerCharacterAutoCompletionMode.Prefix;
pub const IRCACM_Random = InkRecognizerCharacterAutoCompletionMode.Random;

pub const InkRecognitionModes = enum(i32) {
    None = 0,
    WordModeOnly = 1,
    Coerce = 2,
    TopInkBreaksOnly = 4,
    PrefixOk = 8,
    LineMode = 16,
    DisablePersonalization = 32,
    AutoSpace = 64,
    Max = 128,
};
pub const IRM_None = InkRecognitionModes.None;
pub const IRM_WordModeOnly = InkRecognitionModes.WordModeOnly;
pub const IRM_Coerce = InkRecognitionModes.Coerce;
pub const IRM_TopInkBreaksOnly = InkRecognitionModes.TopInkBreaksOnly;
pub const IRM_PrefixOk = InkRecognitionModes.PrefixOk;
pub const IRM_LineMode = InkRecognitionModes.LineMode;
pub const IRM_DisablePersonalization = InkRecognitionModes.DisablePersonalization;
pub const IRM_AutoSpace = InkRecognitionModes.AutoSpace;
pub const IRM_Max = InkRecognitionModes.Max;

pub const DISPID_InkRecognitionEvent = enum(i32) {
    WithAlternates = 1,
    n = 2,
};
pub const DISPID_IRERecognitionWithAlternates = DISPID_InkRecognitionEvent.WithAlternates;
pub const DISPID_IRERecognition = DISPID_InkRecognitionEvent.n;

pub const DISPID_InkRecoContext = enum(i32) {
    Strokes = 1,
    CharacterAutoCompletionMode = 2,
    Factoid = 3,
    WordList = 4,
    Recognizer = 5,
    Guide = 6,
    Flags = 7,
    PrefixText = 8,
    SuffixText = 9,
    StopRecognition = 10,
    Clone = 11,
    Recognize = 12,
    StopBackgroundRecognition = 13,
    EndInkInput = 14,
    BackgroundRecognize = 15,
    BackgroundRecognizeWithAlternates = 16,
    IsStringSupported = 17,
};
pub const DISPID_IRecoCtx_Strokes = DISPID_InkRecoContext.Strokes;
pub const DISPID_IRecoCtx_CharacterAutoCompletionMode = DISPID_InkRecoContext.CharacterAutoCompletionMode;
pub const DISPID_IRecoCtx_Factoid = DISPID_InkRecoContext.Factoid;
pub const DISPID_IRecoCtx_WordList = DISPID_InkRecoContext.WordList;
pub const DISPID_IRecoCtx_Recognizer = DISPID_InkRecoContext.Recognizer;
pub const DISPID_IRecoCtx_Guide = DISPID_InkRecoContext.Guide;
pub const DISPID_IRecoCtx_Flags = DISPID_InkRecoContext.Flags;
pub const DISPID_IRecoCtx_PrefixText = DISPID_InkRecoContext.PrefixText;
pub const DISPID_IRecoCtx_SuffixText = DISPID_InkRecoContext.SuffixText;
pub const DISPID_IRecoCtx_StopRecognition = DISPID_InkRecoContext.StopRecognition;
pub const DISPID_IRecoCtx_Clone = DISPID_InkRecoContext.Clone;
pub const DISPID_IRecoCtx_Recognize = DISPID_InkRecoContext.Recognize;
pub const DISPID_IRecoCtx_StopBackgroundRecognition = DISPID_InkRecoContext.StopBackgroundRecognition;
pub const DISPID_IRecoCtx_EndInkInput = DISPID_InkRecoContext.EndInkInput;
pub const DISPID_IRecoCtx_BackgroundRecognize = DISPID_InkRecoContext.BackgroundRecognize;
pub const DISPID_IRecoCtx_BackgroundRecognizeWithAlternates = DISPID_InkRecoContext.BackgroundRecognizeWithAlternates;
pub const DISPID_IRecoCtx_IsStringSupported = DISPID_InkRecoContext.IsStringSupported;

pub const DISPID_InkRecoContext2 = enum(i32) {
    s = 0,
};
pub const DISPID_IRecoCtx2_EnabledUnicodeRanges = DISPID_InkRecoContext2.s;

pub const InkRecognitionAlternatesSelection = enum(i32) {
    Start = 0,
    DefaultCount = 10,
    All = -1,
};
pub const IRAS_Start = InkRecognitionAlternatesSelection.Start;
pub const IRAS_DefaultCount = InkRecognitionAlternatesSelection.DefaultCount;
pub const IRAS_All = InkRecognitionAlternatesSelection.All;

pub const DISPID_InkRecognitionResult = enum(i32) {
    TopString = 1,
    TopAlternate = 2,
    Strokes = 3,
    TopConfidence = 4,
    AlternatesFromSelection = 5,
    ModifyTopAlternate = 6,
    SetResultOnStrokes = 7,
};
pub const DISPID_InkRecognitionResult_TopString = DISPID_InkRecognitionResult.TopString;
pub const DISPID_InkRecognitionResult_TopAlternate = DISPID_InkRecognitionResult.TopAlternate;
pub const DISPID_InkRecognitionResult_Strokes = DISPID_InkRecognitionResult.Strokes;
pub const DISPID_InkRecognitionResult_TopConfidence = DISPID_InkRecognitionResult.TopConfidence;
pub const DISPID_InkRecognitionResult_AlternatesFromSelection = DISPID_InkRecognitionResult.AlternatesFromSelection;
pub const DISPID_InkRecognitionResult_ModifyTopAlternate = DISPID_InkRecognitionResult.ModifyTopAlternate;
pub const DISPID_InkRecognitionResult_SetResultOnStrokes = DISPID_InkRecognitionResult.SetResultOnStrokes;

pub const DISPID_InkRecoAlternate = enum(i32) {
    String = 1,
    LineNumber = 2,
    Baseline = 3,
    Midline = 4,
    Ascender = 5,
    Descender = 6,
    Confidence = 7,
    Strokes = 8,
    GetStrokesFromStrokeRanges = 9,
    GetStrokesFromTextRange = 10,
    GetTextRangeFromStrokes = 11,
    GetPropertyValue = 12,
    LineAlternates = 13,
    ConfidenceAlternates = 14,
    AlternatesWithConstantPropertyValues = 15,
};
pub const DISPID_InkRecoAlternate_String = DISPID_InkRecoAlternate.String;
pub const DISPID_InkRecoAlternate_LineNumber = DISPID_InkRecoAlternate.LineNumber;
pub const DISPID_InkRecoAlternate_Baseline = DISPID_InkRecoAlternate.Baseline;
pub const DISPID_InkRecoAlternate_Midline = DISPID_InkRecoAlternate.Midline;
pub const DISPID_InkRecoAlternate_Ascender = DISPID_InkRecoAlternate.Ascender;
pub const DISPID_InkRecoAlternate_Descender = DISPID_InkRecoAlternate.Descender;
pub const DISPID_InkRecoAlternate_Confidence = DISPID_InkRecoAlternate.Confidence;
pub const DISPID_InkRecoAlternate_Strokes = DISPID_InkRecoAlternate.Strokes;
pub const DISPID_InkRecoAlternate_GetStrokesFromStrokeRanges = DISPID_InkRecoAlternate.GetStrokesFromStrokeRanges;
pub const DISPID_InkRecoAlternate_GetStrokesFromTextRange = DISPID_InkRecoAlternate.GetStrokesFromTextRange;
pub const DISPID_InkRecoAlternate_GetTextRangeFromStrokes = DISPID_InkRecoAlternate.GetTextRangeFromStrokes;
pub const DISPID_InkRecoAlternate_GetPropertyValue = DISPID_InkRecoAlternate.GetPropertyValue;
pub const DISPID_InkRecoAlternate_LineAlternates = DISPID_InkRecoAlternate.LineAlternates;
pub const DISPID_InkRecoAlternate_ConfidenceAlternates = DISPID_InkRecoAlternate.ConfidenceAlternates;
pub const DISPID_InkRecoAlternate_AlternatesWithConstantPropertyValues = DISPID_InkRecoAlternate.AlternatesWithConstantPropertyValues;

pub const DISPID_InkRecognitionAlternates = enum(i32) {
    NewEnum = -4,
    Item = 0,
    Count = 1,
    Strokes = 2,
};
pub const DISPID_InkRecognitionAlternates_NewEnum = DISPID_InkRecognitionAlternates.NewEnum;
pub const DISPID_InkRecognitionAlternates_Item = DISPID_InkRecognitionAlternates.Item;
pub const DISPID_InkRecognitionAlternates_Count = DISPID_InkRecognitionAlternates.Count;
pub const DISPID_InkRecognitionAlternates_Strokes = DISPID_InkRecognitionAlternates.Strokes;

pub const InkRecoGuide = extern struct {
    rectWritingBox: RECT,
    rectDrawnBox: RECT,
    cRows: i32,
    cColumns: i32,
    midline: i32,
};

pub const DISPID_InkRecognizerGuide = enum(i32) {
    WritingBox = 1,
    DrawnBox = 2,
    Rows = 3,
    Columns = 4,
    Midline = 5,
    GuideData = 6,
};
pub const DISPID_IRGWritingBox = DISPID_InkRecognizerGuide.WritingBox;
pub const DISPID_IRGDrawnBox = DISPID_InkRecognizerGuide.DrawnBox;
pub const DISPID_IRGRows = DISPID_InkRecognizerGuide.Rows;
pub const DISPID_IRGColumns = DISPID_InkRecognizerGuide.Columns;
pub const DISPID_IRGMidline = DISPID_InkRecognizerGuide.Midline;
pub const DISPID_IRGGuideData = DISPID_InkRecognizerGuide.GuideData;

pub const DISPID_InkWordList = enum(i32) {
    AddWord = 0,
    RemoveWord = 1,
    Merge = 2,
};
pub const DISPID_InkWordList_AddWord = DISPID_InkWordList.AddWord;
pub const DISPID_InkWordList_RemoveWord = DISPID_InkWordList.RemoveWord;
pub const DISPID_InkWordList_Merge = DISPID_InkWordList.Merge;

pub const DISPID_InkWordList2 = enum(i32) {
    s = 3,
};
pub const DISPID_InkWordList2_AddWords = DISPID_InkWordList2.s;

const IID_IInkRectangle_Value = Guid.initString("9794ff82-6071-4717-8a8b-6ac7c64a686e");
pub const IID_IInkRectangle = &IID_IInkRectangle_Value;
pub const IInkRectangle = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Top: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkRectangle,
                Units: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkRectangle,
                Units: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Top: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkRectangle,
                Units: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkRectangle,
                Units: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Left: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkRectangle,
                Units: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkRectangle,
                Units: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Left: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkRectangle,
                Units: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkRectangle,
                Units: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Bottom: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkRectangle,
                Units: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkRectangle,
                Units: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Bottom: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkRectangle,
                Units: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkRectangle,
                Units: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Right: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkRectangle,
                Units: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkRectangle,
                Units: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Right: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkRectangle,
                Units: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkRectangle,
                Units: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Data: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkRectangle,
                Rect: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkRectangle,
                Rect: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Data: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkRectangle,
                Rect: RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkRectangle,
                Rect: RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRectangle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkRectangle,
                Top: ?*i32,
                Left: ?*i32,
                Bottom: ?*i32,
                Right: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkRectangle,
                Top: ?*i32,
                Left: ?*i32,
                Bottom: ?*i32,
                Right: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetRectangle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkRectangle,
                Top: i32,
                Left: i32,
                Bottom: i32,
                Right: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkRectangle,
                Top: i32,
                Left: i32,
                Bottom: i32,
                Right: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRectangle_get_Top(self: *const T, Units: ?*i32) HRESULT {
                return @as(*const IInkRectangle.VTable, @ptrCast(self.vtable)).get_Top(@as(*const IInkRectangle, @ptrCast(self)), Units);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRectangle_put_Top(self: *const T, Units: i32) HRESULT {
                return @as(*const IInkRectangle.VTable, @ptrCast(self.vtable)).put_Top(@as(*const IInkRectangle, @ptrCast(self)), Units);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRectangle_get_Left(self: *const T, Units: ?*i32) HRESULT {
                return @as(*const IInkRectangle.VTable, @ptrCast(self.vtable)).get_Left(@as(*const IInkRectangle, @ptrCast(self)), Units);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRectangle_put_Left(self: *const T, Units: i32) HRESULT {
                return @as(*const IInkRectangle.VTable, @ptrCast(self.vtable)).put_Left(@as(*const IInkRectangle, @ptrCast(self)), Units);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRectangle_get_Bottom(self: *const T, Units: ?*i32) HRESULT {
                return @as(*const IInkRectangle.VTable, @ptrCast(self.vtable)).get_Bottom(@as(*const IInkRectangle, @ptrCast(self)), Units);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRectangle_put_Bottom(self: *const T, Units: i32) HRESULT {
                return @as(*const IInkRectangle.VTable, @ptrCast(self.vtable)).put_Bottom(@as(*const IInkRectangle, @ptrCast(self)), Units);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRectangle_get_Right(self: *const T, Units: ?*i32) HRESULT {
                return @as(*const IInkRectangle.VTable, @ptrCast(self.vtable)).get_Right(@as(*const IInkRectangle, @ptrCast(self)), Units);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRectangle_put_Right(self: *const T, Units: i32) HRESULT {
                return @as(*const IInkRectangle.VTable, @ptrCast(self.vtable)).put_Right(@as(*const IInkRectangle, @ptrCast(self)), Units);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRectangle_get_Data(self: *const T, Rect: ?*RECT) HRESULT {
                return @as(*const IInkRectangle.VTable, @ptrCast(self.vtable)).get_Data(@as(*const IInkRectangle, @ptrCast(self)), Rect);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRectangle_put_Data(self: *const T, Rect: RECT) HRESULT {
                return @as(*const IInkRectangle.VTable, @ptrCast(self.vtable)).put_Data(@as(*const IInkRectangle, @ptrCast(self)), Rect);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRectangle_GetRectangle(self: *const T, Top: ?*i32, Left: ?*i32, Bottom: ?*i32, Right: ?*i32) HRESULT {
                return @as(*const IInkRectangle.VTable, @ptrCast(self.vtable)).GetRectangle(@as(*const IInkRectangle, @ptrCast(self)), Top, Left, Bottom, Right);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRectangle_SetRectangle(self: *const T, Top: i32, Left: i32, Bottom: i32, Right: i32) HRESULT {
                return @as(*const IInkRectangle.VTable, @ptrCast(self.vtable)).SetRectangle(@as(*const IInkRectangle, @ptrCast(self)), Top, Left, Bottom, Right);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IInkExtendedProperty_Value = Guid.initString("db489209-b7c3-411d-90f6-1548cfff271e");
pub const IID_IInkExtendedProperty = &IID_IInkExtendedProperty_Value;
pub const IInkExtendedProperty = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Guid: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkExtendedProperty,
                Guid: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkExtendedProperty,
                Guid: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Data: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkExtendedProperty,
                Data: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkExtendedProperty,
                Data: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Data: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkExtendedProperty,
                Data: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkExtendedProperty,
                Data: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkExtendedProperty_get_Guid(self: *const T, _param_Guid: ?*?BSTR) HRESULT {
                return @as(*const IInkExtendedProperty.VTable, @ptrCast(self.vtable)).get_Guid(@as(*const IInkExtendedProperty, @ptrCast(self)), _param_Guid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkExtendedProperty_get_Data(self: *const T, Data: ?*VARIANT) HRESULT {
                return @as(*const IInkExtendedProperty.VTable, @ptrCast(self.vtable)).get_Data(@as(*const IInkExtendedProperty, @ptrCast(self)), Data);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkExtendedProperty_put_Data(self: *const T, Data: VARIANT) HRESULT {
                return @as(*const IInkExtendedProperty.VTable, @ptrCast(self.vtable)).put_Data(@as(*const IInkExtendedProperty, @ptrCast(self)), Data);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IInkExtendedProperties_Value = Guid.initString("89f2a8be-95a9-4530-8b8f-88e971e3e25f");
pub const IID_IInkExtendedProperties = &IID_IInkExtendedProperties_Value;
pub const IInkExtendedProperties = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkExtendedProperties,
                Count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkExtendedProperties,
                Count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkExtendedProperties,
                _NewEnum: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkExtendedProperties,
                _NewEnum: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Item: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkExtendedProperties,
                Identifier: VARIANT,
                Item: ?*?*IInkExtendedProperty,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkExtendedProperties,
                Identifier: VARIANT,
                Item: ?*?*IInkExtendedProperty,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Add: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkExtendedProperties,
                Guid: ?BSTR,
                Data: VARIANT,
                InkExtendedProperty: ?*?*IInkExtendedProperty,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkExtendedProperties,
                Guid: ?BSTR,
                Data: VARIANT,
                InkExtendedProperty: ?*?*IInkExtendedProperty,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Remove: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkExtendedProperties,
                Identifier: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkExtendedProperties,
                Identifier: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clear: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkExtendedProperties,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkExtendedProperties,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DoesPropertyExist: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkExtendedProperties,
                Guid: ?BSTR,
                DoesPropertyExist: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkExtendedProperties,
                Guid: ?BSTR,
                DoesPropertyExist: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkExtendedProperties_get_Count(self: *const T, Count: ?*i32) HRESULT {
                return @as(*const IInkExtendedProperties.VTable, @ptrCast(self.vtable)).get_Count(@as(*const IInkExtendedProperties, @ptrCast(self)), Count);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkExtendedProperties_get__NewEnum(self: *const T, _NewEnum: ?*?*IUnknown) HRESULT {
                return @as(*const IInkExtendedProperties.VTable, @ptrCast(self.vtable)).get__NewEnum(@as(*const IInkExtendedProperties, @ptrCast(self)), _NewEnum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkExtendedProperties_Item(self: *const T, Identifier: VARIANT, Item: ?*?*IInkExtendedProperty) HRESULT {
                return @as(*const IInkExtendedProperties.VTable, @ptrCast(self.vtable)).Item(@as(*const IInkExtendedProperties, @ptrCast(self)), Identifier, Item);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkExtendedProperties_Add(self: *const T, _param_Guid: ?BSTR, Data: VARIANT, InkExtendedProperty: ?*?*IInkExtendedProperty) HRESULT {
                return @as(*const IInkExtendedProperties.VTable, @ptrCast(self.vtable)).Add(@as(*const IInkExtendedProperties, @ptrCast(self)), _param_Guid, Data, InkExtendedProperty);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkExtendedProperties_Remove(self: *const T, Identifier: VARIANT) HRESULT {
                return @as(*const IInkExtendedProperties.VTable, @ptrCast(self.vtable)).Remove(@as(*const IInkExtendedProperties, @ptrCast(self)), Identifier);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkExtendedProperties_Clear(self: *const T) HRESULT {
                return @as(*const IInkExtendedProperties.VTable, @ptrCast(self.vtable)).Clear(@as(*const IInkExtendedProperties, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkExtendedProperties_DoesPropertyExist(self: *const T, _param_Guid: ?BSTR, DoesPropertyExist: ?*i16) HRESULT {
                return @as(*const IInkExtendedProperties.VTable, @ptrCast(self.vtable)).DoesPropertyExist(@as(*const IInkExtendedProperties, @ptrCast(self)), _param_Guid, DoesPropertyExist);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IInkDrawingAttributes_Value = Guid.initString("bf519b75-0a15-4623-adc9-c00d436a8092");
pub const IID_IInkDrawingAttributes = &IID_IInkDrawingAttributes_Value;
pub const IInkDrawingAttributes = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Color: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkDrawingAttributes,
                CurrentColor: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkDrawingAttributes,
                CurrentColor: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Color: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkDrawingAttributes,
                NewColor: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkDrawingAttributes,
                NewColor: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Width: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkDrawingAttributes,
                CurrentWidth: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkDrawingAttributes,
                CurrentWidth: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Width: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkDrawingAttributes,
                NewWidth: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkDrawingAttributes,
                NewWidth: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Height: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkDrawingAttributes,
                CurrentHeight: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkDrawingAttributes,
                CurrentHeight: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Height: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkDrawingAttributes,
                NewHeight: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkDrawingAttributes,
                NewHeight: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FitToCurve: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkDrawingAttributes,
                Flag: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkDrawingAttributes,
                Flag: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_FitToCurve: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkDrawingAttributes,
                Flag: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkDrawingAttributes,
                Flag: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IgnorePressure: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkDrawingAttributes,
                Flag: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkDrawingAttributes,
                Flag: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_IgnorePressure: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkDrawingAttributes,
                Flag: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkDrawingAttributes,
                Flag: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AntiAliased: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkDrawingAttributes,
                Flag: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkDrawingAttributes,
                Flag: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AntiAliased: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkDrawingAttributes,
                Flag: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkDrawingAttributes,
                Flag: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Transparency: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkDrawingAttributes,
                CurrentTransparency: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkDrawingAttributes,
                CurrentTransparency: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Transparency: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkDrawingAttributes,
                NewTransparency: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkDrawingAttributes,
                NewTransparency: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RasterOperation: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkDrawingAttributes,
                CurrentRasterOperation: ?*InkRasterOperation,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkDrawingAttributes,
                CurrentRasterOperation: ?*InkRasterOperation,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_RasterOperation: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkDrawingAttributes,
                NewRasterOperation: InkRasterOperation,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkDrawingAttributes,
                NewRasterOperation: InkRasterOperation,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PenTip: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkDrawingAttributes,
                CurrentPenTip: ?*InkPenTip,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkDrawingAttributes,
                CurrentPenTip: ?*InkPenTip,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_PenTip: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkDrawingAttributes,
                NewPenTip: InkPenTip,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkDrawingAttributes,
                NewPenTip: InkPenTip,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ExtendedProperties: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkDrawingAttributes,
                Properties: ?*?*IInkExtendedProperties,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkDrawingAttributes,
                Properties: ?*?*IInkExtendedProperties,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkDrawingAttributes,
                DrawingAttributes: ?*?*IInkDrawingAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkDrawingAttributes,
                DrawingAttributes: ?*?*IInkDrawingAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkDrawingAttributes_get_Color(self: *const T, CurrentColor: ?*i32) HRESULT {
                return @as(*const IInkDrawingAttributes.VTable, @ptrCast(self.vtable)).get_Color(@as(*const IInkDrawingAttributes, @ptrCast(self)), CurrentColor);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkDrawingAttributes_put_Color(self: *const T, NewColor: i32) HRESULT {
                return @as(*const IInkDrawingAttributes.VTable, @ptrCast(self.vtable)).put_Color(@as(*const IInkDrawingAttributes, @ptrCast(self)), NewColor);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkDrawingAttributes_get_Width(self: *const T, CurrentWidth: ?*f32) HRESULT {
                return @as(*const IInkDrawingAttributes.VTable, @ptrCast(self.vtable)).get_Width(@as(*const IInkDrawingAttributes, @ptrCast(self)), CurrentWidth);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkDrawingAttributes_put_Width(self: *const T, NewWidth: f32) HRESULT {
                return @as(*const IInkDrawingAttributes.VTable, @ptrCast(self.vtable)).put_Width(@as(*const IInkDrawingAttributes, @ptrCast(self)), NewWidth);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkDrawingAttributes_get_Height(self: *const T, CurrentHeight: ?*f32) HRESULT {
                return @as(*const IInkDrawingAttributes.VTable, @ptrCast(self.vtable)).get_Height(@as(*const IInkDrawingAttributes, @ptrCast(self)), CurrentHeight);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkDrawingAttributes_put_Height(self: *const T, NewHeight: f32) HRESULT {
                return @as(*const IInkDrawingAttributes.VTable, @ptrCast(self.vtable)).put_Height(@as(*const IInkDrawingAttributes, @ptrCast(self)), NewHeight);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkDrawingAttributes_get_FitToCurve(self: *const T, Flag: ?*i16) HRESULT {
                return @as(*const IInkDrawingAttributes.VTable, @ptrCast(self.vtable)).get_FitToCurve(@as(*const IInkDrawingAttributes, @ptrCast(self)), Flag);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkDrawingAttributes_put_FitToCurve(self: *const T, Flag: i16) HRESULT {
                return @as(*const IInkDrawingAttributes.VTable, @ptrCast(self.vtable)).put_FitToCurve(@as(*const IInkDrawingAttributes, @ptrCast(self)), Flag);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkDrawingAttributes_get_IgnorePressure(self: *const T, Flag: ?*i16) HRESULT {
                return @as(*const IInkDrawingAttributes.VTable, @ptrCast(self.vtable)).get_IgnorePressure(@as(*const IInkDrawingAttributes, @ptrCast(self)), Flag);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkDrawingAttributes_put_IgnorePressure(self: *const T, Flag: i16) HRESULT {
                return @as(*const IInkDrawingAttributes.VTable, @ptrCast(self.vtable)).put_IgnorePressure(@as(*const IInkDrawingAttributes, @ptrCast(self)), Flag);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkDrawingAttributes_get_AntiAliased(self: *const T, Flag: ?*i16) HRESULT {
                return @as(*const IInkDrawingAttributes.VTable, @ptrCast(self.vtable)).get_AntiAliased(@as(*const IInkDrawingAttributes, @ptrCast(self)), Flag);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkDrawingAttributes_put_AntiAliased(self: *const T, Flag: i16) HRESULT {
                return @as(*const IInkDrawingAttributes.VTable, @ptrCast(self.vtable)).put_AntiAliased(@as(*const IInkDrawingAttributes, @ptrCast(self)), Flag);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkDrawingAttributes_get_Transparency(self: *const T, CurrentTransparency: ?*i32) HRESULT {
                return @as(*const IInkDrawingAttributes.VTable, @ptrCast(self.vtable)).get_Transparency(@as(*const IInkDrawingAttributes, @ptrCast(self)), CurrentTransparency);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkDrawingAttributes_put_Transparency(self: *const T, NewTransparency: i32) HRESULT {
                return @as(*const IInkDrawingAttributes.VTable, @ptrCast(self.vtable)).put_Transparency(@as(*const IInkDrawingAttributes, @ptrCast(self)), NewTransparency);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkDrawingAttributes_get_RasterOperation(self: *const T, CurrentRasterOperation: ?*InkRasterOperation) HRESULT {
                return @as(*const IInkDrawingAttributes.VTable, @ptrCast(self.vtable)).get_RasterOperation(@as(*const IInkDrawingAttributes, @ptrCast(self)), CurrentRasterOperation);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkDrawingAttributes_put_RasterOperation(self: *const T, NewRasterOperation: InkRasterOperation) HRESULT {
                return @as(*const IInkDrawingAttributes.VTable, @ptrCast(self.vtable)).put_RasterOperation(@as(*const IInkDrawingAttributes, @ptrCast(self)), NewRasterOperation);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkDrawingAttributes_get_PenTip(self: *const T, CurrentPenTip: ?*InkPenTip) HRESULT {
                return @as(*const IInkDrawingAttributes.VTable, @ptrCast(self.vtable)).get_PenTip(@as(*const IInkDrawingAttributes, @ptrCast(self)), CurrentPenTip);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkDrawingAttributes_put_PenTip(self: *const T, NewPenTip: InkPenTip) HRESULT {
                return @as(*const IInkDrawingAttributes.VTable, @ptrCast(self.vtable)).put_PenTip(@as(*const IInkDrawingAttributes, @ptrCast(self)), NewPenTip);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkDrawingAttributes_get_ExtendedProperties(self: *const T, Properties: ?*?*IInkExtendedProperties) HRESULT {
                return @as(*const IInkDrawingAttributes.VTable, @ptrCast(self.vtable)).get_ExtendedProperties(@as(*const IInkDrawingAttributes, @ptrCast(self)), Properties);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkDrawingAttributes_Clone(self: *const T, DrawingAttributes: ?*?*IInkDrawingAttributes) HRESULT {
                return @as(*const IInkDrawingAttributes.VTable, @ptrCast(self.vtable)).Clone(@as(*const IInkDrawingAttributes, @ptrCast(self)), DrawingAttributes);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IInkTransform_Value = Guid.initString("615f1d43-8703-4565-88e2-8201d2ecd7b7");
pub const IID_IInkTransform = &IID_IInkTransform_Value;
pub const IInkTransform = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkTransform,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkTransform,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Translate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkTransform,
                HorizontalComponent: f32,
                VerticalComponent: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkTransform,
                HorizontalComponent: f32,
                VerticalComponent: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Rotate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkTransform,
                Degrees: f32,
                x: f32,
                y: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkTransform,
                Degrees: f32,
                x: f32,
                y: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reflect: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkTransform,
                Horizontally: i16,
                Vertically: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkTransform,
                Horizontally: i16,
                Vertically: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Shear: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkTransform,
                HorizontalComponent: f32,
                VerticalComponent: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkTransform,
                HorizontalComponent: f32,
                VerticalComponent: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ScaleTransform: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkTransform,
                HorizontalMultiplier: f32,
                VerticalMultiplier: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkTransform,
                HorizontalMultiplier: f32,
                VerticalMultiplier: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTransform: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkTransform,
                eM11: ?*f32,
                eM12: ?*f32,
                eM21: ?*f32,
                eM22: ?*f32,
                eDx: ?*f32,
                eDy: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkTransform,
                eM11: ?*f32,
                eM12: ?*f32,
                eM21: ?*f32,
                eM22: ?*f32,
                eDx: ?*f32,
                eDy: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTransform: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkTransform,
                eM11: f32,
                eM12: f32,
                eM21: f32,
                eM22: f32,
                eDx: f32,
                eDy: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkTransform,
                eM11: f32,
                eM12: f32,
                eM21: f32,
                eM22: f32,
                eDx: f32,
                eDy: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_eM11: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkTransform,
                Value: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkTransform,
                Value: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_eM11: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkTransform,
                Value: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkTransform,
                Value: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_eM12: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkTransform,
                Value: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkTransform,
                Value: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_eM12: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkTransform,
                Value: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkTransform,
                Value: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_eM21: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkTransform,
                Value: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkTransform,
                Value: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_eM21: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkTransform,
                Value: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkTransform,
                Value: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_eM22: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkTransform,
                Value: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkTransform,
                Value: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_eM22: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkTransform,
                Value: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkTransform,
                Value: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_eDx: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkTransform,
                Value: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkTransform,
                Value: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_eDx: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkTransform,
                Value: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkTransform,
                Value: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_eDy: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkTransform,
                Value: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkTransform,
                Value: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_eDy: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkTransform,
                Value: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkTransform,
                Value: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Data: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkTransform,
                XForm: ?*XFORM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkTransform,
                XForm: ?*XFORM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Data: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkTransform,
                XForm: XFORM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkTransform,
                XForm: XFORM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkTransform_Reset(self: *const T) HRESULT {
                return @as(*const IInkTransform.VTable, @ptrCast(self.vtable)).Reset(@as(*const IInkTransform, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkTransform_Translate(self: *const T, HorizontalComponent: f32, VerticalComponent: f32) HRESULT {
                return @as(*const IInkTransform.VTable, @ptrCast(self.vtable)).Translate(@as(*const IInkTransform, @ptrCast(self)), HorizontalComponent, VerticalComponent);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkTransform_Rotate(self: *const T, Degrees: f32, x: f32, y: f32) HRESULT {
                return @as(*const IInkTransform.VTable, @ptrCast(self.vtable)).Rotate(@as(*const IInkTransform, @ptrCast(self)), Degrees, x, y);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkTransform_Reflect(self: *const T, Horizontally: i16, Vertically: i16) HRESULT {
                return @as(*const IInkTransform.VTable, @ptrCast(self.vtable)).Reflect(@as(*const IInkTransform, @ptrCast(self)), Horizontally, Vertically);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkTransform_Shear(self: *const T, HorizontalComponent: f32, VerticalComponent: f32) HRESULT {
                return @as(*const IInkTransform.VTable, @ptrCast(self.vtable)).Shear(@as(*const IInkTransform, @ptrCast(self)), HorizontalComponent, VerticalComponent);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkTransform_ScaleTransform(self: *const T, HorizontalMultiplier: f32, VerticalMultiplier: f32) HRESULT {
                return @as(*const IInkTransform.VTable, @ptrCast(self.vtable)).ScaleTransform(@as(*const IInkTransform, @ptrCast(self)), HorizontalMultiplier, VerticalMultiplier);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkTransform_GetTransform(self: *const T, eM11: ?*f32, eM12: ?*f32, eM21: ?*f32, eM22: ?*f32, eDx: ?*f32, eDy: ?*f32) HRESULT {
                return @as(*const IInkTransform.VTable, @ptrCast(self.vtable)).GetTransform(@as(*const IInkTransform, @ptrCast(self)), eM11, eM12, eM21, eM22, eDx, eDy);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkTransform_SetTransform(self: *const T, eM11: f32, eM12: f32, eM21: f32, eM22: f32, eDx: f32, eDy: f32) HRESULT {
                return @as(*const IInkTransform.VTable, @ptrCast(self.vtable)).SetTransform(@as(*const IInkTransform, @ptrCast(self)), eM11, eM12, eM21, eM22, eDx, eDy);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkTransform_get_eM11(self: *const T, Value: ?*f32) HRESULT {
                return @as(*const IInkTransform.VTable, @ptrCast(self.vtable)).get_eM11(@as(*const IInkTransform, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkTransform_put_eM11(self: *const T, Value: f32) HRESULT {
                return @as(*const IInkTransform.VTable, @ptrCast(self.vtable)).put_eM11(@as(*const IInkTransform, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkTransform_get_eM12(self: *const T, Value: ?*f32) HRESULT {
                return @as(*const IInkTransform.VTable, @ptrCast(self.vtable)).get_eM12(@as(*const IInkTransform, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkTransform_put_eM12(self: *const T, Value: f32) HRESULT {
                return @as(*const IInkTransform.VTable, @ptrCast(self.vtable)).put_eM12(@as(*const IInkTransform, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkTransform_get_eM21(self: *const T, Value: ?*f32) HRESULT {
                return @as(*const IInkTransform.VTable, @ptrCast(self.vtable)).get_eM21(@as(*const IInkTransform, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkTransform_put_eM21(self: *const T, Value: f32) HRESULT {
                return @as(*const IInkTransform.VTable, @ptrCast(self.vtable)).put_eM21(@as(*const IInkTransform, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkTransform_get_eM22(self: *const T, Value: ?*f32) HRESULT {
                return @as(*const IInkTransform.VTable, @ptrCast(self.vtable)).get_eM22(@as(*const IInkTransform, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkTransform_put_eM22(self: *const T, Value: f32) HRESULT {
                return @as(*const IInkTransform.VTable, @ptrCast(self.vtable)).put_eM22(@as(*const IInkTransform, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkTransform_get_eDx(self: *const T, Value: ?*f32) HRESULT {
                return @as(*const IInkTransform.VTable, @ptrCast(self.vtable)).get_eDx(@as(*const IInkTransform, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkTransform_put_eDx(self: *const T, Value: f32) HRESULT {
                return @as(*const IInkTransform.VTable, @ptrCast(self.vtable)).put_eDx(@as(*const IInkTransform, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkTransform_get_eDy(self: *const T, Value: ?*f32) HRESULT {
                return @as(*const IInkTransform.VTable, @ptrCast(self.vtable)).get_eDy(@as(*const IInkTransform, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkTransform_put_eDy(self: *const T, Value: f32) HRESULT {
                return @as(*const IInkTransform.VTable, @ptrCast(self.vtable)).put_eDy(@as(*const IInkTransform, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkTransform_get_Data(self: *const T, XForm: ?*XFORM) HRESULT {
                return @as(*const IInkTransform.VTable, @ptrCast(self.vtable)).get_Data(@as(*const IInkTransform, @ptrCast(self)), XForm);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkTransform_put_Data(self: *const T, XForm: XFORM) HRESULT {
                return @as(*const IInkTransform.VTable, @ptrCast(self.vtable)).put_Data(@as(*const IInkTransform, @ptrCast(self)), XForm);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IInkGesture_Value = Guid.initString("3bdc0a97-04e5-4e26-b813-18f052d41def");
pub const IID_IInkGesture = &IID_IInkGesture_Value;
pub const IInkGesture = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Confidence: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkGesture,
                Confidence: ?*InkRecognitionConfidence,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkGesture,
                Confidence: ?*InkRecognitionConfidence,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Id: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkGesture,
                Id: ?*InkApplicationGesture,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkGesture,
                Id: ?*InkApplicationGesture,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetHotPoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkGesture,
                X: ?*i32,
                Y: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkGesture,
                X: ?*i32,
                Y: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkGesture_get_Confidence(self: *const T, Confidence: ?*InkRecognitionConfidence) HRESULT {
                return @as(*const IInkGesture.VTable, @ptrCast(self.vtable)).get_Confidence(@as(*const IInkGesture, @ptrCast(self)), Confidence);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkGesture_get_Id(self: *const T, Id: ?*InkApplicationGesture) HRESULT {
                return @as(*const IInkGesture.VTable, @ptrCast(self.vtable)).get_Id(@as(*const IInkGesture, @ptrCast(self)), Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkGesture_GetHotPoint(self: *const T, X: ?*i32, Y: ?*i32) HRESULT {
                return @as(*const IInkGesture.VTable, @ptrCast(self.vtable)).GetHotPoint(@as(*const IInkGesture, @ptrCast(self)), X, Y);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IInkCursor_Value = Guid.initString("ad30c630-40c5-4350-8405-9c71012fc558");
pub const IID_IInkCursor = &IID_IInkCursor_Value;
pub const IInkCursor = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkCursor,
                Name: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkCursor,
                Name: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Id: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkCursor,
                Id: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkCursor,
                Id: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Inverted: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkCursor,
                Status: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkCursor,
                Status: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DrawingAttributes: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkCursor,
                Attributes: ?*?*IInkDrawingAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkCursor,
                Attributes: ?*?*IInkDrawingAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        putref_DrawingAttributes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkCursor,
                Attributes: ?*IInkDrawingAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkCursor,
                Attributes: ?*IInkDrawingAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Tablet: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkCursor,
                Tablet: ?*?*IInkTablet,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkCursor,
                Tablet: ?*?*IInkTablet,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Buttons: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkCursor,
                Buttons: ?*?*IInkCursorButtons,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkCursor,
                Buttons: ?*?*IInkCursorButtons,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkCursor_get_Name(self: *const T, Name: ?*?BSTR) HRESULT {
                return @as(*const IInkCursor.VTable, @ptrCast(self.vtable)).get_Name(@as(*const IInkCursor, @ptrCast(self)), Name);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkCursor_get_Id(self: *const T, Id: ?*i32) HRESULT {
                return @as(*const IInkCursor.VTable, @ptrCast(self.vtable)).get_Id(@as(*const IInkCursor, @ptrCast(self)), Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkCursor_get_Inverted(self: *const T, Status: ?*i16) HRESULT {
                return @as(*const IInkCursor.VTable, @ptrCast(self.vtable)).get_Inverted(@as(*const IInkCursor, @ptrCast(self)), Status);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkCursor_get_DrawingAttributes(self: *const T, Attributes: ?*?*IInkDrawingAttributes) HRESULT {
                return @as(*const IInkCursor.VTable, @ptrCast(self.vtable)).get_DrawingAttributes(@as(*const IInkCursor, @ptrCast(self)), Attributes);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkCursor_putref_DrawingAttributes(self: *const T, Attributes: ?*IInkDrawingAttributes) HRESULT {
                return @as(*const IInkCursor.VTable, @ptrCast(self.vtable)).putref_DrawingAttributes(@as(*const IInkCursor, @ptrCast(self)), Attributes);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkCursor_get_Tablet(self: *const T, Tablet: ?*?*IInkTablet) HRESULT {
                return @as(*const IInkCursor.VTable, @ptrCast(self.vtable)).get_Tablet(@as(*const IInkCursor, @ptrCast(self)), Tablet);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkCursor_get_Buttons(self: *const T, Buttons: ?*?*IInkCursorButtons) HRESULT {
                return @as(*const IInkCursor.VTable, @ptrCast(self.vtable)).get_Buttons(@as(*const IInkCursor, @ptrCast(self)), Buttons);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IInkCursors_Value = Guid.initString("a248c1ac-c698-4e06-9e5c-d57f77c7e647");
pub const IID_IInkCursors = &IID_IInkCursors_Value;
pub const IInkCursors = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkCursors,
                Count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkCursors,
                Count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkCursors,
                _NewEnum: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkCursors,
                _NewEnum: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Item: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkCursors,
                Index: i32,
                Cursor: ?*?*IInkCursor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkCursors,
                Index: i32,
                Cursor: ?*?*IInkCursor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkCursors_get_Count(self: *const T, Count: ?*i32) HRESULT {
                return @as(*const IInkCursors.VTable, @ptrCast(self.vtable)).get_Count(@as(*const IInkCursors, @ptrCast(self)), Count);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkCursors_get__NewEnum(self: *const T, _NewEnum: ?*?*IUnknown) HRESULT {
                return @as(*const IInkCursors.VTable, @ptrCast(self.vtable)).get__NewEnum(@as(*const IInkCursors, @ptrCast(self)), _NewEnum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkCursors_Item(self: *const T, Index: i32, Cursor: ?*?*IInkCursor) HRESULT {
                return @as(*const IInkCursors.VTable, @ptrCast(self.vtable)).Item(@as(*const IInkCursors, @ptrCast(self)), Index, Cursor);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IInkCursorButton_Value = Guid.initString("85ef9417-1d59-49b2-a13c-702c85430894");
pub const IID_IInkCursorButton = &IID_IInkCursorButton_Value;
pub const IInkCursorButton = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkCursorButton,
                Name: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkCursorButton,
                Name: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Id: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkCursorButton,
                Id: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkCursorButton,
                Id: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_State: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkCursorButton,
                CurrentState: ?*InkCursorButtonState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkCursorButton,
                CurrentState: ?*InkCursorButtonState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkCursorButton_get_Name(self: *const T, Name: ?*?BSTR) HRESULT {
                return @as(*const IInkCursorButton.VTable, @ptrCast(self.vtable)).get_Name(@as(*const IInkCursorButton, @ptrCast(self)), Name);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkCursorButton_get_Id(self: *const T, Id: ?*?BSTR) HRESULT {
                return @as(*const IInkCursorButton.VTable, @ptrCast(self.vtable)).get_Id(@as(*const IInkCursorButton, @ptrCast(self)), Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkCursorButton_get_State(self: *const T, CurrentState: ?*InkCursorButtonState) HRESULT {
                return @as(*const IInkCursorButton.VTable, @ptrCast(self.vtable)).get_State(@as(*const IInkCursorButton, @ptrCast(self)), CurrentState);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IInkCursorButtons_Value = Guid.initString("3671cc40-b624-4671-9fa0-db119d952d54");
pub const IID_IInkCursorButtons = &IID_IInkCursorButtons_Value;
pub const IInkCursorButtons = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkCursorButtons,
                Count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkCursorButtons,
                Count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkCursorButtons,
                _NewEnum: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkCursorButtons,
                _NewEnum: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Item: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkCursorButtons,
                Identifier: VARIANT,
                Button: ?*?*IInkCursorButton,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkCursorButtons,
                Identifier: VARIANT,
                Button: ?*?*IInkCursorButton,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkCursorButtons_get_Count(self: *const T, Count: ?*i32) HRESULT {
                return @as(*const IInkCursorButtons.VTable, @ptrCast(self.vtable)).get_Count(@as(*const IInkCursorButtons, @ptrCast(self)), Count);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkCursorButtons_get__NewEnum(self: *const T, _NewEnum: ?*?*IUnknown) HRESULT {
                return @as(*const IInkCursorButtons.VTable, @ptrCast(self.vtable)).get__NewEnum(@as(*const IInkCursorButtons, @ptrCast(self)), _NewEnum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkCursorButtons_Item(self: *const T, Identifier: VARIANT, Button: ?*?*IInkCursorButton) HRESULT {
                return @as(*const IInkCursorButtons.VTable, @ptrCast(self.vtable)).Item(@as(*const IInkCursorButtons, @ptrCast(self)), Identifier, Button);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IInkTablet_Value = Guid.initString("2de25eaa-6ef8-42d5-aee9-185bc81b912d");
pub const IID_IInkTablet = &IID_IInkTablet_Value;
pub const IInkTablet = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkTablet,
                Name: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkTablet,
                Name: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PlugAndPlayId: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkTablet,
                Id: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkTablet,
                Id: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MaximumInputRectangle: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkTablet,
                Rectangle: ?*?*IInkRectangle,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkTablet,
                Rectangle: ?*?*IInkRectangle,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HardwareCapabilities: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkTablet,
                Capabilities: ?*TabletHardwareCapabilities,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkTablet,
                Capabilities: ?*TabletHardwareCapabilities,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsPacketPropertySupported: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkTablet,
                packetPropertyName: ?BSTR,
                Supported: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkTablet,
                packetPropertyName: ?BSTR,
                Supported: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPropertyMetrics: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkTablet,
                propertyName: ?BSTR,
                Minimum: ?*i32,
                Maximum: ?*i32,
                Units: ?*TabletPropertyMetricUnit,
                Resolution: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkTablet,
                propertyName: ?BSTR,
                Minimum: ?*i32,
                Maximum: ?*i32,
                Units: ?*TabletPropertyMetricUnit,
                Resolution: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkTablet_get_Name(self: *const T, Name: ?*?BSTR) HRESULT {
                return @as(*const IInkTablet.VTable, @ptrCast(self.vtable)).get_Name(@as(*const IInkTablet, @ptrCast(self)), Name);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkTablet_get_PlugAndPlayId(self: *const T, Id: ?*?BSTR) HRESULT {
                return @as(*const IInkTablet.VTable, @ptrCast(self.vtable)).get_PlugAndPlayId(@as(*const IInkTablet, @ptrCast(self)), Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkTablet_get_MaximumInputRectangle(self: *const T, Rectangle: ?*?*IInkRectangle) HRESULT {
                return @as(*const IInkTablet.VTable, @ptrCast(self.vtable)).get_MaximumInputRectangle(@as(*const IInkTablet, @ptrCast(self)), Rectangle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkTablet_get_HardwareCapabilities(self: *const T, Capabilities: ?*TabletHardwareCapabilities) HRESULT {
                return @as(*const IInkTablet.VTable, @ptrCast(self.vtable)).get_HardwareCapabilities(@as(*const IInkTablet, @ptrCast(self)), Capabilities);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkTablet_IsPacketPropertySupported(self: *const T, packetPropertyName: ?BSTR, Supported: ?*i16) HRESULT {
                return @as(*const IInkTablet.VTable, @ptrCast(self.vtable)).IsPacketPropertySupported(@as(*const IInkTablet, @ptrCast(self)), packetPropertyName, Supported);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkTablet_GetPropertyMetrics(self: *const T, propertyName: ?BSTR, Minimum: ?*i32, Maximum: ?*i32, Units: ?*TabletPropertyMetricUnit, Resolution: ?*f32) HRESULT {
                return @as(*const IInkTablet.VTable, @ptrCast(self.vtable)).GetPropertyMetrics(@as(*const IInkTablet, @ptrCast(self)), propertyName, Minimum, Maximum, Units, Resolution);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IInkTablet2_Value = Guid.initString("90c91ad2-fa36-49d6-9516-ce8d570f6f85");
pub const IID_IInkTablet2 = &IID_IInkTablet2_Value;
pub const IInkTablet2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DeviceKind: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkTablet2,
                Kind: ?*TabletDeviceKind,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkTablet2,
                Kind: ?*TabletDeviceKind,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkTablet2_get_DeviceKind(self: *const T, Kind: ?*TabletDeviceKind) HRESULT {
                return @as(*const IInkTablet2.VTable, @ptrCast(self.vtable)).get_DeviceKind(@as(*const IInkTablet2, @ptrCast(self)), Kind);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IInkTablet3_Value = Guid.initString("7e313997-1327-41dd-8ca9-79f24be17250");
pub const IID_IInkTablet3 = &IID_IInkTablet3_Value;
pub const IInkTablet3 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsMultiTouch: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkTablet3,
                pIsMultiTouch: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkTablet3,
                pIsMultiTouch: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MaximumCursors: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkTablet3,
                pMaximumCursors: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkTablet3,
                pMaximumCursors: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkTablet3_get_IsMultiTouch(self: *const T, pIsMultiTouch: ?*i16) HRESULT {
                return @as(*const IInkTablet3.VTable, @ptrCast(self.vtable)).get_IsMultiTouch(@as(*const IInkTablet3, @ptrCast(self)), pIsMultiTouch);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkTablet3_get_MaximumCursors(self: *const T, pMaximumCursors: ?*u32) HRESULT {
                return @as(*const IInkTablet3.VTable, @ptrCast(self.vtable)).get_MaximumCursors(@as(*const IInkTablet3, @ptrCast(self)), pMaximumCursors);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IInkTablets_Value = Guid.initString("112086d9-7779-4535-a699-862b43ac1863");
pub const IID_IInkTablets = &IID_IInkTablets_Value;
pub const IInkTablets = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkTablets,
                Count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkTablets,
                Count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkTablets,
                _NewEnum: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkTablets,
                _NewEnum: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DefaultTablet: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkTablets,
                DefaultTablet: ?*?*IInkTablet,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkTablets,
                DefaultTablet: ?*?*IInkTablet,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Item: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkTablets,
                Index: i32,
                Tablet: ?*?*IInkTablet,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkTablets,
                Index: i32,
                Tablet: ?*?*IInkTablet,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsPacketPropertySupported: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkTablets,
                packetPropertyName: ?BSTR,
                Supported: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkTablets,
                packetPropertyName: ?BSTR,
                Supported: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkTablets_get_Count(self: *const T, Count: ?*i32) HRESULT {
                return @as(*const IInkTablets.VTable, @ptrCast(self.vtable)).get_Count(@as(*const IInkTablets, @ptrCast(self)), Count);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkTablets_get__NewEnum(self: *const T, _NewEnum: ?*?*IUnknown) HRESULT {
                return @as(*const IInkTablets.VTable, @ptrCast(self.vtable)).get__NewEnum(@as(*const IInkTablets, @ptrCast(self)), _NewEnum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkTablets_get_DefaultTablet(self: *const T, DefaultTablet: ?*?*IInkTablet) HRESULT {
                return @as(*const IInkTablets.VTable, @ptrCast(self.vtable)).get_DefaultTablet(@as(*const IInkTablets, @ptrCast(self)), DefaultTablet);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkTablets_Item(self: *const T, Index: i32, Tablet: ?*?*IInkTablet) HRESULT {
                return @as(*const IInkTablets.VTable, @ptrCast(self.vtable)).Item(@as(*const IInkTablets, @ptrCast(self)), Index, Tablet);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkTablets_IsPacketPropertySupported(self: *const T, packetPropertyName: ?BSTR, Supported: ?*i16) HRESULT {
                return @as(*const IInkTablets.VTable, @ptrCast(self.vtable)).IsPacketPropertySupported(@as(*const IInkTablets, @ptrCast(self)), packetPropertyName, Supported);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IInkStrokeDisp_Value = Guid.initString("43242fea-91d1-4a72-963e-fbb91829cfa2");
pub const IID_IInkStrokeDisp = &IID_IInkStrokeDisp_Value;
pub const IInkStrokeDisp = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ID: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkStrokeDisp,
                ID: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkStrokeDisp,
                ID: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BezierPoints: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkStrokeDisp,
                Points: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkStrokeDisp,
                Points: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DrawingAttributes: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkStrokeDisp,
                DrawAttrs: ?*?*IInkDrawingAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkStrokeDisp,
                DrawAttrs: ?*?*IInkDrawingAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        putref_DrawingAttributes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkStrokeDisp,
                DrawAttrs: ?*IInkDrawingAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkStrokeDisp,
                DrawAttrs: ?*IInkDrawingAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Ink: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkStrokeDisp,
                Ink: ?*?*IInkDisp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkStrokeDisp,
                Ink: ?*?*IInkDisp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ExtendedProperties: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkStrokeDisp,
                Properties: ?*?*IInkExtendedProperties,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkStrokeDisp,
                Properties: ?*?*IInkExtendedProperties,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PolylineCusps: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkStrokeDisp,
                Cusps: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkStrokeDisp,
                Cusps: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BezierCusps: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkStrokeDisp,
                Cusps: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkStrokeDisp,
                Cusps: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SelfIntersections: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkStrokeDisp,
                Intersections: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkStrokeDisp,
                Intersections: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PacketCount: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkStrokeDisp,
                plCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkStrokeDisp,
                plCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PacketSize: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkStrokeDisp,
                plSize: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkStrokeDisp,
                plSize: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PacketDescription: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkStrokeDisp,
                PacketDescription: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkStrokeDisp,
                PacketDescription: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Deleted: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkStrokeDisp,
                Deleted: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkStrokeDisp,
                Deleted: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBoundingBox: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkStrokeDisp,
                BoundingBoxMode: InkBoundingBoxMode,
                Rectangle: ?*?*IInkRectangle,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkStrokeDisp,
                BoundingBoxMode: InkBoundingBoxMode,
                Rectangle: ?*?*IInkRectangle,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindIntersections: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkStrokeDisp,
                Strokes: ?*IInkStrokes,
                Intersections: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkStrokeDisp,
                Strokes: ?*IInkStrokes,
                Intersections: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRectangleIntersections: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkStrokeDisp,
                Rectangle: ?*IInkRectangle,
                Intersections: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkStrokeDisp,
                Rectangle: ?*IInkRectangle,
                Intersections: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkStrokeDisp,
                Rectangle: ?*IInkRectangle,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkStrokeDisp,
                Rectangle: ?*IInkRectangle,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        HitTestCircle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkStrokeDisp,
                X: i32,
                Y: i32,
                Radius: f32,
                Intersects: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkStrokeDisp,
                X: i32,
                Y: i32,
                Radius: f32,
                Intersects: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NearestPoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkStrokeDisp,
                X: i32,
                Y: i32,
                Distance: ?*f32,
                Point: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkStrokeDisp,
                X: i32,
                Y: i32,
                Distance: ?*f32,
                Point: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Split: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkStrokeDisp,
                SplitAt: f32,
                NewStroke: ?*?*IInkStrokeDisp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkStrokeDisp,
                SplitAt: f32,
                NewStroke: ?*?*IInkStrokeDisp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPacketDescriptionPropertyMetrics: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkStrokeDisp,
                PropertyName: ?BSTR,
                Minimum: ?*i32,
                Maximum: ?*i32,
                Units: ?*TabletPropertyMetricUnit,
                Resolution: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkStrokeDisp,
                PropertyName: ?BSTR,
                Minimum: ?*i32,
                Maximum: ?*i32,
                Units: ?*TabletPropertyMetricUnit,
                Resolution: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPoints: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkStrokeDisp,
                Index: i32,
                Count: i32,
                Points: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkStrokeDisp,
                Index: i32,
                Count: i32,
                Points: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPoints: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkStrokeDisp,
                Points: VARIANT,
                Index: i32,
                Count: i32,
                NumberOfPointsSet: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkStrokeDisp,
                Points: VARIANT,
                Index: i32,
                Count: i32,
                NumberOfPointsSet: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPacketData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkStrokeDisp,
                Index: i32,
                Count: i32,
                PacketData: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkStrokeDisp,
                Index: i32,
                Count: i32,
                PacketData: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPacketValuesByProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkStrokeDisp,
                PropertyName: ?BSTR,
                Index: i32,
                Count: i32,
                PacketValues: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkStrokeDisp,
                PropertyName: ?BSTR,
                Index: i32,
                Count: i32,
                PacketValues: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPacketValuesByProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkStrokeDisp,
                bstrPropertyName: ?BSTR,
                PacketValues: VARIANT,
                Index: i32,
                Count: i32,
                NumberOfPacketsSet: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkStrokeDisp,
                bstrPropertyName: ?BSTR,
                PacketValues: VARIANT,
                Index: i32,
                Count: i32,
                NumberOfPacketsSet: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFlattenedBezierPoints: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkStrokeDisp,
                FittingError: i32,
                FlattenedBezierPoints: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkStrokeDisp,
                FittingError: i32,
                FlattenedBezierPoints: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Transform: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkStrokeDisp,
                Transform: ?*IInkTransform,
                ApplyOnPenWidth: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkStrokeDisp,
                Transform: ?*IInkTransform,
                ApplyOnPenWidth: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ScaleToRectangle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkStrokeDisp,
                Rectangle: ?*IInkRectangle,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkStrokeDisp,
                Rectangle: ?*IInkRectangle,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Move: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkStrokeDisp,
                HorizontalComponent: f32,
                VerticalComponent: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkStrokeDisp,
                HorizontalComponent: f32,
                VerticalComponent: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Rotate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkStrokeDisp,
                Degrees: f32,
                x: f32,
                y: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkStrokeDisp,
                Degrees: f32,
                x: f32,
                y: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Shear: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkStrokeDisp,
                HorizontalMultiplier: f32,
                VerticalMultiplier: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkStrokeDisp,
                HorizontalMultiplier: f32,
                VerticalMultiplier: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ScaleTransform: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkStrokeDisp,
                HorizontalMultiplier: f32,
                VerticalMultiplier: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkStrokeDisp,
                HorizontalMultiplier: f32,
                VerticalMultiplier: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkStrokeDisp_get_ID(self: *const T, ID: ?*i32) HRESULT {
                return @as(*const IInkStrokeDisp.VTable, @ptrCast(self.vtable)).get_ID(@as(*const IInkStrokeDisp, @ptrCast(self)), ID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkStrokeDisp_get_BezierPoints(self: *const T, Points: ?*VARIANT) HRESULT {
                return @as(*const IInkStrokeDisp.VTable, @ptrCast(self.vtable)).get_BezierPoints(@as(*const IInkStrokeDisp, @ptrCast(self)), Points);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkStrokeDisp_get_DrawingAttributes(self: *const T, DrawAttrs: ?*?*IInkDrawingAttributes) HRESULT {
                return @as(*const IInkStrokeDisp.VTable, @ptrCast(self.vtable)).get_DrawingAttributes(@as(*const IInkStrokeDisp, @ptrCast(self)), DrawAttrs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkStrokeDisp_putref_DrawingAttributes(self: *const T, DrawAttrs: ?*IInkDrawingAttributes) HRESULT {
                return @as(*const IInkStrokeDisp.VTable, @ptrCast(self.vtable)).putref_DrawingAttributes(@as(*const IInkStrokeDisp, @ptrCast(self)), DrawAttrs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkStrokeDisp_get_Ink(self: *const T, Ink: ?*?*IInkDisp) HRESULT {
                return @as(*const IInkStrokeDisp.VTable, @ptrCast(self.vtable)).get_Ink(@as(*const IInkStrokeDisp, @ptrCast(self)), Ink);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkStrokeDisp_get_ExtendedProperties(self: *const T, Properties: ?*?*IInkExtendedProperties) HRESULT {
                return @as(*const IInkStrokeDisp.VTable, @ptrCast(self.vtable)).get_ExtendedProperties(@as(*const IInkStrokeDisp, @ptrCast(self)), Properties);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkStrokeDisp_get_PolylineCusps(self: *const T, Cusps: ?*VARIANT) HRESULT {
                return @as(*const IInkStrokeDisp.VTable, @ptrCast(self.vtable)).get_PolylineCusps(@as(*const IInkStrokeDisp, @ptrCast(self)), Cusps);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkStrokeDisp_get_BezierCusps(self: *const T, Cusps: ?*VARIANT) HRESULT {
                return @as(*const IInkStrokeDisp.VTable, @ptrCast(self.vtable)).get_BezierCusps(@as(*const IInkStrokeDisp, @ptrCast(self)), Cusps);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkStrokeDisp_get_SelfIntersections(self: *const T, Intersections: ?*VARIANT) HRESULT {
                return @as(*const IInkStrokeDisp.VTable, @ptrCast(self.vtable)).get_SelfIntersections(@as(*const IInkStrokeDisp, @ptrCast(self)), Intersections);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkStrokeDisp_get_PacketCount(self: *const T, plCount: ?*i32) HRESULT {
                return @as(*const IInkStrokeDisp.VTable, @ptrCast(self.vtable)).get_PacketCount(@as(*const IInkStrokeDisp, @ptrCast(self)), plCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkStrokeDisp_get_PacketSize(self: *const T, plSize: ?*i32) HRESULT {
                return @as(*const IInkStrokeDisp.VTable, @ptrCast(self.vtable)).get_PacketSize(@as(*const IInkStrokeDisp, @ptrCast(self)), plSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkStrokeDisp_get_PacketDescription(self: *const T, PacketDescription: ?*VARIANT) HRESULT {
                return @as(*const IInkStrokeDisp.VTable, @ptrCast(self.vtable)).get_PacketDescription(@as(*const IInkStrokeDisp, @ptrCast(self)), PacketDescription);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkStrokeDisp_get_Deleted(self: *const T, Deleted: ?*i16) HRESULT {
                return @as(*const IInkStrokeDisp.VTable, @ptrCast(self.vtable)).get_Deleted(@as(*const IInkStrokeDisp, @ptrCast(self)), Deleted);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkStrokeDisp_GetBoundingBox(self: *const T, BoundingBoxMode: InkBoundingBoxMode, Rectangle: ?*?*IInkRectangle) HRESULT {
                return @as(*const IInkStrokeDisp.VTable, @ptrCast(self.vtable)).GetBoundingBox(@as(*const IInkStrokeDisp, @ptrCast(self)), BoundingBoxMode, Rectangle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkStrokeDisp_FindIntersections(self: *const T, Strokes: ?*IInkStrokes, Intersections: ?*VARIANT) HRESULT {
                return @as(*const IInkStrokeDisp.VTable, @ptrCast(self.vtable)).FindIntersections(@as(*const IInkStrokeDisp, @ptrCast(self)), Strokes, Intersections);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkStrokeDisp_GetRectangleIntersections(self: *const T, Rectangle: ?*IInkRectangle, Intersections: ?*VARIANT) HRESULT {
                return @as(*const IInkStrokeDisp.VTable, @ptrCast(self.vtable)).GetRectangleIntersections(@as(*const IInkStrokeDisp, @ptrCast(self)), Rectangle, Intersections);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkStrokeDisp_Clip(self: *const T, Rectangle: ?*IInkRectangle) HRESULT {
                return @as(*const IInkStrokeDisp.VTable, @ptrCast(self.vtable)).Clip(@as(*const IInkStrokeDisp, @ptrCast(self)), Rectangle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkStrokeDisp_HitTestCircle(self: *const T, X: i32, Y: i32, Radius: f32, Intersects: ?*i16) HRESULT {
                return @as(*const IInkStrokeDisp.VTable, @ptrCast(self.vtable)).HitTestCircle(@as(*const IInkStrokeDisp, @ptrCast(self)), X, Y, Radius, Intersects);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkStrokeDisp_NearestPoint(self: *const T, X: i32, Y: i32, Distance: ?*f32, Point: ?*f32) HRESULT {
                return @as(*const IInkStrokeDisp.VTable, @ptrCast(self.vtable)).NearestPoint(@as(*const IInkStrokeDisp, @ptrCast(self)), X, Y, Distance, Point);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkStrokeDisp_Split(self: *const T, SplitAt: f32, NewStroke: ?*?*IInkStrokeDisp) HRESULT {
                return @as(*const IInkStrokeDisp.VTable, @ptrCast(self.vtable)).Split(@as(*const IInkStrokeDisp, @ptrCast(self)), SplitAt, NewStroke);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkStrokeDisp_GetPacketDescriptionPropertyMetrics(self: *const T, PropertyName: ?BSTR, Minimum: ?*i32, Maximum: ?*i32, Units: ?*TabletPropertyMetricUnit, Resolution: ?*f32) HRESULT {
                return @as(*const IInkStrokeDisp.VTable, @ptrCast(self.vtable)).GetPacketDescriptionPropertyMetrics(@as(*const IInkStrokeDisp, @ptrCast(self)), PropertyName, Minimum, Maximum, Units, Resolution);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkStrokeDisp_GetPoints(self: *const T, Index: i32, Count: i32, Points: ?*VARIANT) HRESULT {
                return @as(*const IInkStrokeDisp.VTable, @ptrCast(self.vtable)).GetPoints(@as(*const IInkStrokeDisp, @ptrCast(self)), Index, Count, Points);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkStrokeDisp_SetPoints(self: *const T, Points: VARIANT, Index: i32, Count: i32, NumberOfPointsSet: ?*i32) HRESULT {
                return @as(*const IInkStrokeDisp.VTable, @ptrCast(self.vtable)).SetPoints(@as(*const IInkStrokeDisp, @ptrCast(self)), Points, Index, Count, NumberOfPointsSet);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkStrokeDisp_GetPacketData(self: *const T, Index: i32, Count: i32, PacketData: ?*VARIANT) HRESULT {
                return @as(*const IInkStrokeDisp.VTable, @ptrCast(self.vtable)).GetPacketData(@as(*const IInkStrokeDisp, @ptrCast(self)), Index, Count, PacketData);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkStrokeDisp_GetPacketValuesByProperty(self: *const T, PropertyName: ?BSTR, Index: i32, Count: i32, PacketValues: ?*VARIANT) HRESULT {
                return @as(*const IInkStrokeDisp.VTable, @ptrCast(self.vtable)).GetPacketValuesByProperty(@as(*const IInkStrokeDisp, @ptrCast(self)), PropertyName, Index, Count, PacketValues);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkStrokeDisp_SetPacketValuesByProperty(self: *const T, bstrPropertyName: ?BSTR, PacketValues: VARIANT, Index: i32, Count: i32, NumberOfPacketsSet: ?*i32) HRESULT {
                return @as(*const IInkStrokeDisp.VTable, @ptrCast(self.vtable)).SetPacketValuesByProperty(@as(*const IInkStrokeDisp, @ptrCast(self)), bstrPropertyName, PacketValues, Index, Count, NumberOfPacketsSet);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkStrokeDisp_GetFlattenedBezierPoints(self: *const T, FittingError: i32, FlattenedBezierPoints: ?*VARIANT) HRESULT {
                return @as(*const IInkStrokeDisp.VTable, @ptrCast(self.vtable)).GetFlattenedBezierPoints(@as(*const IInkStrokeDisp, @ptrCast(self)), FittingError, FlattenedBezierPoints);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkStrokeDisp_Transform(self: *const T, Transform: ?*IInkTransform, ApplyOnPenWidth: i16) HRESULT {
                return @as(*const IInkStrokeDisp.VTable, @ptrCast(self.vtable)).Transform(@as(*const IInkStrokeDisp, @ptrCast(self)), Transform, ApplyOnPenWidth);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkStrokeDisp_ScaleToRectangle(self: *const T, Rectangle: ?*IInkRectangle) HRESULT {
                return @as(*const IInkStrokeDisp.VTable, @ptrCast(self.vtable)).ScaleToRectangle(@as(*const IInkStrokeDisp, @ptrCast(self)), Rectangle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkStrokeDisp_Move(self: *const T, HorizontalComponent: f32, VerticalComponent: f32) HRESULT {
                return @as(*const IInkStrokeDisp.VTable, @ptrCast(self.vtable)).Move(@as(*const IInkStrokeDisp, @ptrCast(self)), HorizontalComponent, VerticalComponent);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkStrokeDisp_Rotate(self: *const T, Degrees: f32, x: f32, y: f32) HRESULT {
                return @as(*const IInkStrokeDisp.VTable, @ptrCast(self.vtable)).Rotate(@as(*const IInkStrokeDisp, @ptrCast(self)), Degrees, x, y);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkStrokeDisp_Shear(self: *const T, HorizontalMultiplier: f32, VerticalMultiplier: f32) HRESULT {
                return @as(*const IInkStrokeDisp.VTable, @ptrCast(self.vtable)).Shear(@as(*const IInkStrokeDisp, @ptrCast(self)), HorizontalMultiplier, VerticalMultiplier);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkStrokeDisp_ScaleTransform(self: *const T, HorizontalMultiplier: f32, VerticalMultiplier: f32) HRESULT {
                return @as(*const IInkStrokeDisp.VTable, @ptrCast(self.vtable)).ScaleTransform(@as(*const IInkStrokeDisp, @ptrCast(self)), HorizontalMultiplier, VerticalMultiplier);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IInkStrokes_Value = Guid.initString("f1f4c9d8-590a-4963-b3ae-1935671bb6f3");
pub const IID_IInkStrokes = &IID_IInkStrokes_Value;
pub const IInkStrokes = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkStrokes,
                Count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkStrokes,
                Count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkStrokes,
                _NewEnum: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkStrokes,
                _NewEnum: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Ink: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkStrokes,
                Ink: ?*?*IInkDisp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkStrokes,
                Ink: ?*?*IInkDisp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RecognitionResult: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkStrokes,
                RecognitionResult: ?*?*IInkRecognitionResult,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkStrokes,
                RecognitionResult: ?*?*IInkRecognitionResult,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ToString: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkStrokes,
                ToString: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkStrokes,
                ToString: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Item: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkStrokes,
                Index: i32,
                Stroke: ?*?*IInkStrokeDisp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkStrokes,
                Index: i32,
                Stroke: ?*?*IInkStrokeDisp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Add: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkStrokes,
                InkStroke: ?*IInkStrokeDisp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkStrokes,
                InkStroke: ?*IInkStrokeDisp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddStrokes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkStrokes,
                InkStrokes: ?*IInkStrokes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkStrokes,
                InkStrokes: ?*IInkStrokes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Remove: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkStrokes,
                InkStroke: ?*IInkStrokeDisp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkStrokes,
                InkStroke: ?*IInkStrokeDisp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveStrokes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkStrokes,
                InkStrokes: ?*IInkStrokes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkStrokes,
                InkStrokes: ?*IInkStrokes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ModifyDrawingAttributes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkStrokes,
                DrawAttrs: ?*IInkDrawingAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkStrokes,
                DrawAttrs: ?*IInkDrawingAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBoundingBox: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkStrokes,
                BoundingBoxMode: InkBoundingBoxMode,
                BoundingBox: ?*?*IInkRectangle,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkStrokes,
                BoundingBoxMode: InkBoundingBoxMode,
                BoundingBox: ?*?*IInkRectangle,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Transform: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkStrokes,
                Transform: ?*IInkTransform,
                ApplyOnPenWidth: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkStrokes,
                Transform: ?*IInkTransform,
                ApplyOnPenWidth: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ScaleToRectangle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkStrokes,
                Rectangle: ?*IInkRectangle,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkStrokes,
                Rectangle: ?*IInkRectangle,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Move: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkStrokes,
                HorizontalComponent: f32,
                VerticalComponent: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkStrokes,
                HorizontalComponent: f32,
                VerticalComponent: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Rotate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkStrokes,
                Degrees: f32,
                x: f32,
                y: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkStrokes,
                Degrees: f32,
                x: f32,
                y: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Shear: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkStrokes,
                HorizontalMultiplier: f32,
                VerticalMultiplier: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkStrokes,
                HorizontalMultiplier: f32,
                VerticalMultiplier: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ScaleTransform: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkStrokes,
                HorizontalMultiplier: f32,
                VerticalMultiplier: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkStrokes,
                HorizontalMultiplier: f32,
                VerticalMultiplier: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkStrokes,
                Rectangle: ?*IInkRectangle,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkStrokes,
                Rectangle: ?*IInkRectangle,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveRecognitionResult: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkStrokes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkStrokes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkStrokes_get_Count(self: *const T, Count: ?*i32) HRESULT {
                return @as(*const IInkStrokes.VTable, @ptrCast(self.vtable)).get_Count(@as(*const IInkStrokes, @ptrCast(self)), Count);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkStrokes_get__NewEnum(self: *const T, _NewEnum: ?*?*IUnknown) HRESULT {
                return @as(*const IInkStrokes.VTable, @ptrCast(self.vtable)).get__NewEnum(@as(*const IInkStrokes, @ptrCast(self)), _NewEnum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkStrokes_get_Ink(self: *const T, Ink: ?*?*IInkDisp) HRESULT {
                return @as(*const IInkStrokes.VTable, @ptrCast(self.vtable)).get_Ink(@as(*const IInkStrokes, @ptrCast(self)), Ink);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkStrokes_get_RecognitionResult(self: *const T, RecognitionResult: ?*?*IInkRecognitionResult) HRESULT {
                return @as(*const IInkStrokes.VTable, @ptrCast(self.vtable)).get_RecognitionResult(@as(*const IInkStrokes, @ptrCast(self)), RecognitionResult);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkStrokes_ToString(self: *const T, ToString: ?*?BSTR) HRESULT {
                return @as(*const IInkStrokes.VTable, @ptrCast(self.vtable)).ToString(@as(*const IInkStrokes, @ptrCast(self)), ToString);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkStrokes_Item(self: *const T, Index: i32, Stroke: ?*?*IInkStrokeDisp) HRESULT {
                return @as(*const IInkStrokes.VTable, @ptrCast(self.vtable)).Item(@as(*const IInkStrokes, @ptrCast(self)), Index, Stroke);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkStrokes_Add(self: *const T, InkStroke: ?*IInkStrokeDisp) HRESULT {
                return @as(*const IInkStrokes.VTable, @ptrCast(self.vtable)).Add(@as(*const IInkStrokes, @ptrCast(self)), InkStroke);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkStrokes_AddStrokes(self: *const T, InkStrokes: ?*IInkStrokes) HRESULT {
                return @as(*const IInkStrokes.VTable, @ptrCast(self.vtable)).AddStrokes(@as(*const IInkStrokes, @ptrCast(self)), InkStrokes);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkStrokes_Remove(self: *const T, InkStroke: ?*IInkStrokeDisp) HRESULT {
                return @as(*const IInkStrokes.VTable, @ptrCast(self.vtable)).Remove(@as(*const IInkStrokes, @ptrCast(self)), InkStroke);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkStrokes_RemoveStrokes(self: *const T, InkStrokes: ?*IInkStrokes) HRESULT {
                return @as(*const IInkStrokes.VTable, @ptrCast(self.vtable)).RemoveStrokes(@as(*const IInkStrokes, @ptrCast(self)), InkStrokes);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkStrokes_ModifyDrawingAttributes(self: *const T, DrawAttrs: ?*IInkDrawingAttributes) HRESULT {
                return @as(*const IInkStrokes.VTable, @ptrCast(self.vtable)).ModifyDrawingAttributes(@as(*const IInkStrokes, @ptrCast(self)), DrawAttrs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkStrokes_GetBoundingBox(self: *const T, BoundingBoxMode: InkBoundingBoxMode, BoundingBox: ?*?*IInkRectangle) HRESULT {
                return @as(*const IInkStrokes.VTable, @ptrCast(self.vtable)).GetBoundingBox(@as(*const IInkStrokes, @ptrCast(self)), BoundingBoxMode, BoundingBox);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkStrokes_Transform(self: *const T, Transform: ?*IInkTransform, ApplyOnPenWidth: i16) HRESULT {
                return @as(*const IInkStrokes.VTable, @ptrCast(self.vtable)).Transform(@as(*const IInkStrokes, @ptrCast(self)), Transform, ApplyOnPenWidth);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkStrokes_ScaleToRectangle(self: *const T, Rectangle: ?*IInkRectangle) HRESULT {
                return @as(*const IInkStrokes.VTable, @ptrCast(self.vtable)).ScaleToRectangle(@as(*const IInkStrokes, @ptrCast(self)), Rectangle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkStrokes_Move(self: *const T, HorizontalComponent: f32, VerticalComponent: f32) HRESULT {
                return @as(*const IInkStrokes.VTable, @ptrCast(self.vtable)).Move(@as(*const IInkStrokes, @ptrCast(self)), HorizontalComponent, VerticalComponent);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkStrokes_Rotate(self: *const T, Degrees: f32, x: f32, y: f32) HRESULT {
                return @as(*const IInkStrokes.VTable, @ptrCast(self.vtable)).Rotate(@as(*const IInkStrokes, @ptrCast(self)), Degrees, x, y);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkStrokes_Shear(self: *const T, HorizontalMultiplier: f32, VerticalMultiplier: f32) HRESULT {
                return @as(*const IInkStrokes.VTable, @ptrCast(self.vtable)).Shear(@as(*const IInkStrokes, @ptrCast(self)), HorizontalMultiplier, VerticalMultiplier);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkStrokes_ScaleTransform(self: *const T, HorizontalMultiplier: f32, VerticalMultiplier: f32) HRESULT {
                return @as(*const IInkStrokes.VTable, @ptrCast(self.vtable)).ScaleTransform(@as(*const IInkStrokes, @ptrCast(self)), HorizontalMultiplier, VerticalMultiplier);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkStrokes_Clip(self: *const T, Rectangle: ?*IInkRectangle) HRESULT {
                return @as(*const IInkStrokes.VTable, @ptrCast(self.vtable)).Clip(@as(*const IInkStrokes, @ptrCast(self)), Rectangle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkStrokes_RemoveRecognitionResult(self: *const T) HRESULT {
                return @as(*const IInkStrokes.VTable, @ptrCast(self.vtable)).RemoveRecognitionResult(@as(*const IInkStrokes, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IInkCustomStrokes_Value = Guid.initString("7e23a88f-c30e-420f-9bdb-28902543f0c1");
pub const IID_IInkCustomStrokes = &IID_IInkCustomStrokes_Value;
pub const IInkCustomStrokes = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkCustomStrokes,
                Count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkCustomStrokes,
                Count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkCustomStrokes,
                _NewEnum: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkCustomStrokes,
                _NewEnum: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Item: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkCustomStrokes,
                Identifier: VARIANT,
                Strokes: ?*?*IInkStrokes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkCustomStrokes,
                Identifier: VARIANT,
                Strokes: ?*?*IInkStrokes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Add: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkCustomStrokes,
                Name: ?BSTR,
                Strokes: ?*IInkStrokes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkCustomStrokes,
                Name: ?BSTR,
                Strokes: ?*IInkStrokes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Remove: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkCustomStrokes,
                Identifier: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkCustomStrokes,
                Identifier: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clear: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkCustomStrokes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkCustomStrokes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkCustomStrokes_get_Count(self: *const T, Count: ?*i32) HRESULT {
                return @as(*const IInkCustomStrokes.VTable, @ptrCast(self.vtable)).get_Count(@as(*const IInkCustomStrokes, @ptrCast(self)), Count);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkCustomStrokes_get__NewEnum(self: *const T, _NewEnum: ?*?*IUnknown) HRESULT {
                return @as(*const IInkCustomStrokes.VTable, @ptrCast(self.vtable)).get__NewEnum(@as(*const IInkCustomStrokes, @ptrCast(self)), _NewEnum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkCustomStrokes_Item(self: *const T, Identifier: VARIANT, Strokes: ?*?*IInkStrokes) HRESULT {
                return @as(*const IInkCustomStrokes.VTable, @ptrCast(self.vtable)).Item(@as(*const IInkCustomStrokes, @ptrCast(self)), Identifier, Strokes);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkCustomStrokes_Add(self: *const T, Name: ?BSTR, Strokes: ?*IInkStrokes) HRESULT {
                return @as(*const IInkCustomStrokes.VTable, @ptrCast(self.vtable)).Add(@as(*const IInkCustomStrokes, @ptrCast(self)), Name, Strokes);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkCustomStrokes_Remove(self: *const T, Identifier: VARIANT) HRESULT {
                return @as(*const IInkCustomStrokes.VTable, @ptrCast(self.vtable)).Remove(@as(*const IInkCustomStrokes, @ptrCast(self)), Identifier);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkCustomStrokes_Clear(self: *const T) HRESULT {
                return @as(*const IInkCustomStrokes.VTable, @ptrCast(self.vtable)).Clear(@as(*const IInkCustomStrokes, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID__IInkStrokesEvents_Value = Guid.initString("f33053ec-5d25-430a-928f-76a6491dde15");
pub const IID__IInkStrokesEvents = &IID__IInkStrokesEvents_Value;
pub const _IInkStrokesEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IInkDisp_Value = Guid.initString("9d398fa0-c4e2-4fcd-9973-975caaf47ea6");
pub const IID_IInkDisp = &IID_IInkDisp_Value;
pub const IInkDisp = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Strokes: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkDisp,
                Strokes: ?*?*IInkStrokes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkDisp,
                Strokes: ?*?*IInkStrokes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ExtendedProperties: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkDisp,
                Properties: ?*?*IInkExtendedProperties,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkDisp,
                Properties: ?*?*IInkExtendedProperties,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Dirty: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkDisp,
                Dirty: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkDisp,
                Dirty: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Dirty: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkDisp,
                Dirty: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkDisp,
                Dirty: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CustomStrokes: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkDisp,
                ppunkInkCustomStrokes: ?*?*IInkCustomStrokes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkDisp,
                ppunkInkCustomStrokes: ?*?*IInkCustomStrokes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBoundingBox: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkDisp,
                BoundingBoxMode: InkBoundingBoxMode,
                Rectangle: ?*?*IInkRectangle,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkDisp,
                BoundingBoxMode: InkBoundingBoxMode,
                Rectangle: ?*?*IInkRectangle,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeleteStrokes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkDisp,
                Strokes: ?*IInkStrokes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkDisp,
                Strokes: ?*IInkStrokes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeleteStroke: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkDisp,
                Stroke: ?*IInkStrokeDisp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkDisp,
                Stroke: ?*IInkStrokeDisp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExtractStrokes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkDisp,
                Strokes: ?*IInkStrokes,
                ExtractFlags: InkExtractFlags,
                ExtractedInk: ?*?*IInkDisp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkDisp,
                Strokes: ?*IInkStrokes,
                ExtractFlags: InkExtractFlags,
                ExtractedInk: ?*?*IInkDisp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExtractWithRectangle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkDisp,
                Rectangle: ?*IInkRectangle,
                extractFlags: InkExtractFlags,
                ExtractedInk: ?*?*IInkDisp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkDisp,
                Rectangle: ?*IInkRectangle,
                extractFlags: InkExtractFlags,
                ExtractedInk: ?*?*IInkDisp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkDisp,
                Rectangle: ?*IInkRectangle,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkDisp,
                Rectangle: ?*IInkRectangle,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkDisp,
                NewInk: ?*?*IInkDisp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkDisp,
                NewInk: ?*?*IInkDisp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        HitTestCircle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkDisp,
                X: i32,
                Y: i32,
                radius: f32,
                Strokes: ?*?*IInkStrokes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkDisp,
                X: i32,
                Y: i32,
                radius: f32,
                Strokes: ?*?*IInkStrokes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        HitTestWithRectangle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkDisp,
                SelectionRectangle: ?*IInkRectangle,
                IntersectPercent: f32,
                Strokes: ?*?*IInkStrokes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkDisp,
                SelectionRectangle: ?*IInkRectangle,
                IntersectPercent: f32,
                Strokes: ?*?*IInkStrokes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        HitTestWithLasso: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkDisp,
                Points: VARIANT,
                IntersectPercent: f32,
                LassoPoints: ?*VARIANT,
                Strokes: ?*?*IInkStrokes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkDisp,
                Points: VARIANT,
                IntersectPercent: f32,
                LassoPoints: ?*VARIANT,
                Strokes: ?*?*IInkStrokes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NearestPoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkDisp,
                X: i32,
                Y: i32,
                PointOnStroke: ?*f32,
                DistanceFromPacket: ?*f32,
                Stroke: ?*?*IInkStrokeDisp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkDisp,
                X: i32,
                Y: i32,
                PointOnStroke: ?*f32,
                DistanceFromPacket: ?*f32,
                Stroke: ?*?*IInkStrokeDisp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateStrokes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkDisp,
                StrokeIds: VARIANT,
                Strokes: ?*?*IInkStrokes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkDisp,
                StrokeIds: VARIANT,
                Strokes: ?*?*IInkStrokes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddStrokesAtRectangle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkDisp,
                SourceStrokes: ?*IInkStrokes,
                TargetRectangle: ?*IInkRectangle,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkDisp,
                SourceStrokes: ?*IInkStrokes,
                TargetRectangle: ?*IInkRectangle,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Save: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkDisp,
                PersistenceFormat: InkPersistenceFormat,
                CompressionMode: InkPersistenceCompressionMode,
                Data: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkDisp,
                PersistenceFormat: InkPersistenceFormat,
                CompressionMode: InkPersistenceCompressionMode,
                Data: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Load: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkDisp,
                Data: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkDisp,
                Data: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateStroke: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkDisp,
                PacketData: VARIANT,
                PacketDescription: VARIANT,
                Stroke: ?*?*IInkStrokeDisp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkDisp,
                PacketData: VARIANT,
                PacketDescription: VARIANT,
                Stroke: ?*?*IInkStrokeDisp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ClipboardCopyWithRectangle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkDisp,
                Rectangle: ?*IInkRectangle,
                ClipboardFormats: InkClipboardFormats,
                ClipboardModes: InkClipboardModes,
                DataObject: ?*?*IDataObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkDisp,
                Rectangle: ?*IInkRectangle,
                ClipboardFormats: InkClipboardFormats,
                ClipboardModes: InkClipboardModes,
                DataObject: ?*?*IDataObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ClipboardCopy: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkDisp,
                strokes: ?*IInkStrokes,
                ClipboardFormats: InkClipboardFormats,
                ClipboardModes: InkClipboardModes,
                DataObject: ?*?*IDataObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkDisp,
                strokes: ?*IInkStrokes,
                ClipboardFormats: InkClipboardFormats,
                ClipboardModes: InkClipboardModes,
                DataObject: ?*?*IDataObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CanPaste: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkDisp,
                DataObject: ?*IDataObject,
                CanPaste: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkDisp,
                DataObject: ?*IDataObject,
                CanPaste: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ClipboardPaste: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkDisp,
                x: i32,
                y: i32,
                DataObject: ?*IDataObject,
                Strokes: ?*?*IInkStrokes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkDisp,
                x: i32,
                y: i32,
                DataObject: ?*IDataObject,
                Strokes: ?*?*IInkStrokes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkDisp_get_Strokes(self: *const T, Strokes: ?*?*IInkStrokes) HRESULT {
                return @as(*const IInkDisp.VTable, @ptrCast(self.vtable)).get_Strokes(@as(*const IInkDisp, @ptrCast(self)), Strokes);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkDisp_get_ExtendedProperties(self: *const T, Properties: ?*?*IInkExtendedProperties) HRESULT {
                return @as(*const IInkDisp.VTable, @ptrCast(self.vtable)).get_ExtendedProperties(@as(*const IInkDisp, @ptrCast(self)), Properties);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkDisp_get_Dirty(self: *const T, Dirty: ?*i16) HRESULT {
                return @as(*const IInkDisp.VTable, @ptrCast(self.vtable)).get_Dirty(@as(*const IInkDisp, @ptrCast(self)), Dirty);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkDisp_put_Dirty(self: *const T, Dirty: i16) HRESULT {
                return @as(*const IInkDisp.VTable, @ptrCast(self.vtable)).put_Dirty(@as(*const IInkDisp, @ptrCast(self)), Dirty);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkDisp_get_CustomStrokes(self: *const T, ppunkInkCustomStrokes: ?*?*IInkCustomStrokes) HRESULT {
                return @as(*const IInkDisp.VTable, @ptrCast(self.vtable)).get_CustomStrokes(@as(*const IInkDisp, @ptrCast(self)), ppunkInkCustomStrokes);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkDisp_GetBoundingBox(self: *const T, BoundingBoxMode: InkBoundingBoxMode, Rectangle: ?*?*IInkRectangle) HRESULT {
                return @as(*const IInkDisp.VTable, @ptrCast(self.vtable)).GetBoundingBox(@as(*const IInkDisp, @ptrCast(self)), BoundingBoxMode, Rectangle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkDisp_DeleteStrokes(self: *const T, Strokes: ?*IInkStrokes) HRESULT {
                return @as(*const IInkDisp.VTable, @ptrCast(self.vtable)).DeleteStrokes(@as(*const IInkDisp, @ptrCast(self)), Strokes);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkDisp_DeleteStroke(self: *const T, Stroke: ?*IInkStrokeDisp) HRESULT {
                return @as(*const IInkDisp.VTable, @ptrCast(self.vtable)).DeleteStroke(@as(*const IInkDisp, @ptrCast(self)), Stroke);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkDisp_ExtractStrokes(self: *const T, Strokes: ?*IInkStrokes, ExtractFlags: InkExtractFlags, ExtractedInk: ?*?*IInkDisp) HRESULT {
                return @as(*const IInkDisp.VTable, @ptrCast(self.vtable)).ExtractStrokes(@as(*const IInkDisp, @ptrCast(self)), Strokes, ExtractFlags, ExtractedInk);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkDisp_ExtractWithRectangle(self: *const T, Rectangle: ?*IInkRectangle, extractFlags: InkExtractFlags, ExtractedInk: ?*?*IInkDisp) HRESULT {
                return @as(*const IInkDisp.VTable, @ptrCast(self.vtable)).ExtractWithRectangle(@as(*const IInkDisp, @ptrCast(self)), Rectangle, extractFlags, ExtractedInk);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkDisp_Clip(self: *const T, Rectangle: ?*IInkRectangle) HRESULT {
                return @as(*const IInkDisp.VTable, @ptrCast(self.vtable)).Clip(@as(*const IInkDisp, @ptrCast(self)), Rectangle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkDisp_Clone(self: *const T, NewInk: ?*?*IInkDisp) HRESULT {
                return @as(*const IInkDisp.VTable, @ptrCast(self.vtable)).Clone(@as(*const IInkDisp, @ptrCast(self)), NewInk);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkDisp_HitTestCircle(self: *const T, X: i32, Y: i32, radius: f32, Strokes: ?*?*IInkStrokes) HRESULT {
                return @as(*const IInkDisp.VTable, @ptrCast(self.vtable)).HitTestCircle(@as(*const IInkDisp, @ptrCast(self)), X, Y, radius, Strokes);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkDisp_HitTestWithRectangle(self: *const T, SelectionRectangle: ?*IInkRectangle, IntersectPercent: f32, Strokes: ?*?*IInkStrokes) HRESULT {
                return @as(*const IInkDisp.VTable, @ptrCast(self.vtable)).HitTestWithRectangle(@as(*const IInkDisp, @ptrCast(self)), SelectionRectangle, IntersectPercent, Strokes);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkDisp_HitTestWithLasso(self: *const T, Points: VARIANT, IntersectPercent: f32, LassoPoints: ?*VARIANT, Strokes: ?*?*IInkStrokes) HRESULT {
                return @as(*const IInkDisp.VTable, @ptrCast(self.vtable)).HitTestWithLasso(@as(*const IInkDisp, @ptrCast(self)), Points, IntersectPercent, LassoPoints, Strokes);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkDisp_NearestPoint(self: *const T, X: i32, Y: i32, PointOnStroke: ?*f32, DistanceFromPacket: ?*f32, Stroke: ?*?*IInkStrokeDisp) HRESULT {
                return @as(*const IInkDisp.VTable, @ptrCast(self.vtable)).NearestPoint(@as(*const IInkDisp, @ptrCast(self)), X, Y, PointOnStroke, DistanceFromPacket, Stroke);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkDisp_CreateStrokes(self: *const T, StrokeIds: VARIANT, Strokes: ?*?*IInkStrokes) HRESULT {
                return @as(*const IInkDisp.VTable, @ptrCast(self.vtable)).CreateStrokes(@as(*const IInkDisp, @ptrCast(self)), StrokeIds, Strokes);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkDisp_AddStrokesAtRectangle(self: *const T, SourceStrokes: ?*IInkStrokes, TargetRectangle: ?*IInkRectangle) HRESULT {
                return @as(*const IInkDisp.VTable, @ptrCast(self.vtable)).AddStrokesAtRectangle(@as(*const IInkDisp, @ptrCast(self)), SourceStrokes, TargetRectangle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkDisp_Save(self: *const T, PersistenceFormat: InkPersistenceFormat, CompressionMode: InkPersistenceCompressionMode, Data: ?*VARIANT) HRESULT {
                return @as(*const IInkDisp.VTable, @ptrCast(self.vtable)).Save(@as(*const IInkDisp, @ptrCast(self)), PersistenceFormat, CompressionMode, Data);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkDisp_Load(self: *const T, Data: VARIANT) HRESULT {
                return @as(*const IInkDisp.VTable, @ptrCast(self.vtable)).Load(@as(*const IInkDisp, @ptrCast(self)), Data);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkDisp_CreateStroke(self: *const T, PacketData: VARIANT, PacketDescription: VARIANT, Stroke: ?*?*IInkStrokeDisp) HRESULT {
                return @as(*const IInkDisp.VTable, @ptrCast(self.vtable)).CreateStroke(@as(*const IInkDisp, @ptrCast(self)), PacketData, PacketDescription, Stroke);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkDisp_ClipboardCopyWithRectangle(self: *const T, Rectangle: ?*IInkRectangle, ClipboardFormats: InkClipboardFormats, ClipboardModes: InkClipboardModes, DataObject: ?*?*IDataObject) HRESULT {
                return @as(*const IInkDisp.VTable, @ptrCast(self.vtable)).ClipboardCopyWithRectangle(@as(*const IInkDisp, @ptrCast(self)), Rectangle, ClipboardFormats, ClipboardModes, DataObject);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkDisp_ClipboardCopy(self: *const T, strokes: ?*IInkStrokes, ClipboardFormats: InkClipboardFormats, ClipboardModes: InkClipboardModes, DataObject: ?*?*IDataObject) HRESULT {
                return @as(*const IInkDisp.VTable, @ptrCast(self.vtable)).ClipboardCopy(@as(*const IInkDisp, @ptrCast(self)), strokes, ClipboardFormats, ClipboardModes, DataObject);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkDisp_CanPaste(self: *const T, DataObject: ?*IDataObject, CanPaste: ?*i16) HRESULT {
                return @as(*const IInkDisp.VTable, @ptrCast(self.vtable)).CanPaste(@as(*const IInkDisp, @ptrCast(self)), DataObject, CanPaste);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkDisp_ClipboardPaste(self: *const T, x: i32, y: i32, DataObject: ?*IDataObject, Strokes: ?*?*IInkStrokes) HRESULT {
                return @as(*const IInkDisp.VTable, @ptrCast(self.vtable)).ClipboardPaste(@as(*const IInkDisp, @ptrCast(self)), x, y, DataObject, Strokes);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID__IInkEvents_Value = Guid.initString("427b1865-ca3f-479a-83a9-0f420f2a0073");
pub const IID__IInkEvents = &IID__IInkEvents_Value;
pub const _IInkEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IInkRenderer_Value = Guid.initString("e6257a9c-b511-4f4c-a8b0-a7dbc9506b83");
pub const IID_IInkRenderer = &IID_IInkRenderer_Value;
pub const IInkRenderer = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        GetViewTransform: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkRenderer,
                ViewTransform: ?*IInkTransform,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkRenderer,
                ViewTransform: ?*IInkTransform,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetViewTransform: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkRenderer,
                ViewTransform: ?*IInkTransform,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkRenderer,
                ViewTransform: ?*IInkTransform,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetObjectTransform: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkRenderer,
                ObjectTransform: ?*IInkTransform,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkRenderer,
                ObjectTransform: ?*IInkTransform,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetObjectTransform: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkRenderer,
                ObjectTransform: ?*IInkTransform,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkRenderer,
                ObjectTransform: ?*IInkTransform,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Draw: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkRenderer,
                hDC: isize,
                Strokes: ?*IInkStrokes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkRenderer,
                hDC: isize,
                Strokes: ?*IInkStrokes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DrawStroke: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkRenderer,
                hDC: isize,
                Stroke: ?*IInkStrokeDisp,
                DrawingAttributes: ?*IInkDrawingAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkRenderer,
                hDC: isize,
                Stroke: ?*IInkStrokeDisp,
                DrawingAttributes: ?*IInkDrawingAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PixelToInkSpace: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkRenderer,
                hDC: isize,
                x: ?*i32,
                y: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkRenderer,
                hDC: isize,
                x: ?*i32,
                y: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InkSpaceToPixel: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkRenderer,
                hdcDisplay: isize,
                x: ?*i32,
                y: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkRenderer,
                hdcDisplay: isize,
                x: ?*i32,
                y: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PixelToInkSpaceFromPoints: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkRenderer,
                hDC: isize,
                Points: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkRenderer,
                hDC: isize,
                Points: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InkSpaceToPixelFromPoints: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkRenderer,
                hDC: isize,
                Points: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkRenderer,
                hDC: isize,
                Points: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Measure: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkRenderer,
                Strokes: ?*IInkStrokes,
                Rectangle: ?*?*IInkRectangle,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkRenderer,
                Strokes: ?*IInkStrokes,
                Rectangle: ?*?*IInkRectangle,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        MeasureStroke: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkRenderer,
                Stroke: ?*IInkStrokeDisp,
                DrawingAttributes: ?*IInkDrawingAttributes,
                Rectangle: ?*?*IInkRectangle,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkRenderer,
                Stroke: ?*IInkStrokeDisp,
                DrawingAttributes: ?*IInkDrawingAttributes,
                Rectangle: ?*?*IInkRectangle,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Move: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkRenderer,
                HorizontalComponent: f32,
                VerticalComponent: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkRenderer,
                HorizontalComponent: f32,
                VerticalComponent: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Rotate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkRenderer,
                Degrees: f32,
                x: f32,
                y: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkRenderer,
                Degrees: f32,
                x: f32,
                y: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ScaleTransform: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkRenderer,
                HorizontalMultiplier: f32,
                VerticalMultiplier: f32,
                ApplyOnPenWidth: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkRenderer,
                HorizontalMultiplier: f32,
                VerticalMultiplier: f32,
                ApplyOnPenWidth: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRenderer_GetViewTransform(self: *const T, ViewTransform: ?*IInkTransform) HRESULT {
                return @as(*const IInkRenderer.VTable, @ptrCast(self.vtable)).GetViewTransform(@as(*const IInkRenderer, @ptrCast(self)), ViewTransform);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRenderer_SetViewTransform(self: *const T, ViewTransform: ?*IInkTransform) HRESULT {
                return @as(*const IInkRenderer.VTable, @ptrCast(self.vtable)).SetViewTransform(@as(*const IInkRenderer, @ptrCast(self)), ViewTransform);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRenderer_GetObjectTransform(self: *const T, ObjectTransform: ?*IInkTransform) HRESULT {
                return @as(*const IInkRenderer.VTable, @ptrCast(self.vtable)).GetObjectTransform(@as(*const IInkRenderer, @ptrCast(self)), ObjectTransform);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRenderer_SetObjectTransform(self: *const T, ObjectTransform: ?*IInkTransform) HRESULT {
                return @as(*const IInkRenderer.VTable, @ptrCast(self.vtable)).SetObjectTransform(@as(*const IInkRenderer, @ptrCast(self)), ObjectTransform);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRenderer_Draw(self: *const T, hDC: isize, Strokes: ?*IInkStrokes) HRESULT {
                return @as(*const IInkRenderer.VTable, @ptrCast(self.vtable)).Draw(@as(*const IInkRenderer, @ptrCast(self)), hDC, Strokes);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRenderer_DrawStroke(self: *const T, hDC: isize, Stroke: ?*IInkStrokeDisp, DrawingAttributes: ?*IInkDrawingAttributes) HRESULT {
                return @as(*const IInkRenderer.VTable, @ptrCast(self.vtable)).DrawStroke(@as(*const IInkRenderer, @ptrCast(self)), hDC, Stroke, DrawingAttributes);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRenderer_PixelToInkSpace(self: *const T, hDC: isize, x: ?*i32, y: ?*i32) HRESULT {
                return @as(*const IInkRenderer.VTable, @ptrCast(self.vtable)).PixelToInkSpace(@as(*const IInkRenderer, @ptrCast(self)), hDC, x, y);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRenderer_InkSpaceToPixel(self: *const T, hdcDisplay: isize, x: ?*i32, y: ?*i32) HRESULT {
                return @as(*const IInkRenderer.VTable, @ptrCast(self.vtable)).InkSpaceToPixel(@as(*const IInkRenderer, @ptrCast(self)), hdcDisplay, x, y);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRenderer_PixelToInkSpaceFromPoints(self: *const T, hDC: isize, Points: ?*VARIANT) HRESULT {
                return @as(*const IInkRenderer.VTable, @ptrCast(self.vtable)).PixelToInkSpaceFromPoints(@as(*const IInkRenderer, @ptrCast(self)), hDC, Points);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRenderer_InkSpaceToPixelFromPoints(self: *const T, hDC: isize, Points: ?*VARIANT) HRESULT {
                return @as(*const IInkRenderer.VTable, @ptrCast(self.vtable)).InkSpaceToPixelFromPoints(@as(*const IInkRenderer, @ptrCast(self)), hDC, Points);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRenderer_Measure(self: *const T, Strokes: ?*IInkStrokes, Rectangle: ?*?*IInkRectangle) HRESULT {
                return @as(*const IInkRenderer.VTable, @ptrCast(self.vtable)).Measure(@as(*const IInkRenderer, @ptrCast(self)), Strokes, Rectangle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRenderer_MeasureStroke(self: *const T, Stroke: ?*IInkStrokeDisp, DrawingAttributes: ?*IInkDrawingAttributes, Rectangle: ?*?*IInkRectangle) HRESULT {
                return @as(*const IInkRenderer.VTable, @ptrCast(self.vtable)).MeasureStroke(@as(*const IInkRenderer, @ptrCast(self)), Stroke, DrawingAttributes, Rectangle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRenderer_Move(self: *const T, HorizontalComponent: f32, VerticalComponent: f32) HRESULT {
                return @as(*const IInkRenderer.VTable, @ptrCast(self.vtable)).Move(@as(*const IInkRenderer, @ptrCast(self)), HorizontalComponent, VerticalComponent);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRenderer_Rotate(self: *const T, Degrees: f32, x: f32, y: f32) HRESULT {
                return @as(*const IInkRenderer.VTable, @ptrCast(self.vtable)).Rotate(@as(*const IInkRenderer, @ptrCast(self)), Degrees, x, y);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRenderer_ScaleTransform(self: *const T, HorizontalMultiplier: f32, VerticalMultiplier: f32, ApplyOnPenWidth: i16) HRESULT {
                return @as(*const IInkRenderer.VTable, @ptrCast(self.vtable)).ScaleTransform(@as(*const IInkRenderer, @ptrCast(self)), HorizontalMultiplier, VerticalMultiplier, ApplyOnPenWidth);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IInkCollector_Value = Guid.initString("f0f060b5-8b1f-4a7c-89ec-880692588a4f");
pub const IID_IInkCollector = &IID_IInkCollector_Value;
pub const IInkCollector = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_hWnd: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkCollector,
                CurrentWindow: ?*isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkCollector,
                CurrentWindow: ?*isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_hWnd: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkCollector,
                NewWindow: isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkCollector,
                NewWindow: isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Enabled: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkCollector,
                Collecting: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkCollector,
                Collecting: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Enabled: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkCollector,
                Collecting: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkCollector,
                Collecting: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DefaultDrawingAttributes: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkCollector,
                CurrentAttributes: ?*?*IInkDrawingAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkCollector,
                CurrentAttributes: ?*?*IInkDrawingAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        putref_DefaultDrawingAttributes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkCollector,
                NewAttributes: ?*IInkDrawingAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkCollector,
                NewAttributes: ?*IInkDrawingAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Renderer: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkCollector,
                CurrentInkRenderer: ?*?*IInkRenderer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkCollector,
                CurrentInkRenderer: ?*?*IInkRenderer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        putref_Renderer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkCollector,
                NewInkRenderer: ?*IInkRenderer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkCollector,
                NewInkRenderer: ?*IInkRenderer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Ink: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkCollector,
                Ink: ?*?*IInkDisp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkCollector,
                Ink: ?*?*IInkDisp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        putref_Ink: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkCollector,
                NewInk: ?*IInkDisp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkCollector,
                NewInk: ?*IInkDisp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AutoRedraw: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkCollector,
                AutoRedraw: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkCollector,
                AutoRedraw: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AutoRedraw: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkCollector,
                AutoRedraw: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkCollector,
                AutoRedraw: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CollectingInk: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkCollector,
                Collecting: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkCollector,
                Collecting: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CollectionMode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkCollector,
                Mode: ?*InkCollectionMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkCollector,
                Mode: ?*InkCollectionMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_CollectionMode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkCollector,
                Mode: InkCollectionMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkCollector,
                Mode: InkCollectionMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DynamicRendering: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkCollector,
                Enabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkCollector,
                Enabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DynamicRendering: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkCollector,
                Enabled: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkCollector,
                Enabled: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DesiredPacketDescription: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkCollector,
                PacketGuids: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkCollector,
                PacketGuids: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DesiredPacketDescription: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkCollector,
                PacketGuids: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkCollector,
                PacketGuids: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MouseIcon: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkCollector,
                MouseIcon: ?*?*IPictureDisp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkCollector,
                MouseIcon: ?*?*IPictureDisp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MouseIcon: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkCollector,
                MouseIcon: ?*IPictureDisp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkCollector,
                MouseIcon: ?*IPictureDisp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        putref_MouseIcon: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkCollector,
                MouseIcon: ?*IPictureDisp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkCollector,
                MouseIcon: ?*IPictureDisp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MousePointer: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkCollector,
                MousePointer: ?*InkMousePointer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkCollector,
                MousePointer: ?*InkMousePointer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MousePointer: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkCollector,
                MousePointer: InkMousePointer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkCollector,
                MousePointer: InkMousePointer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Cursors: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkCollector,
                Cursors: ?*?*IInkCursors,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkCollector,
                Cursors: ?*?*IInkCursors,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MarginX: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkCollector,
                MarginX: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkCollector,
                MarginX: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MarginX: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkCollector,
                MarginX: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkCollector,
                MarginX: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MarginY: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkCollector,
                MarginY: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkCollector,
                MarginY: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MarginY: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkCollector,
                MarginY: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkCollector,
                MarginY: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Tablet: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkCollector,
                SingleTablet: ?*?*IInkTablet,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkCollector,
                SingleTablet: ?*?*IInkTablet,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SupportHighContrastInk: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkCollector,
                Support: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkCollector,
                Support: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SupportHighContrastInk: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkCollector,
                Support: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkCollector,
                Support: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetGestureStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkCollector,
                Gesture: InkApplicationGesture,
                Listen: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkCollector,
                Gesture: InkApplicationGesture,
                Listen: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetGestureStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkCollector,
                Gesture: InkApplicationGesture,
                Listening: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkCollector,
                Gesture: InkApplicationGesture,
                Listening: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetWindowInputRectangle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkCollector,
                WindowInputRectangle: ?*?*IInkRectangle,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkCollector,
                WindowInputRectangle: ?*?*IInkRectangle,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetWindowInputRectangle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkCollector,
                WindowInputRectangle: ?*IInkRectangle,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkCollector,
                WindowInputRectangle: ?*IInkRectangle,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetAllTabletsMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkCollector,
                UseMouseForInput: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkCollector,
                UseMouseForInput: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSingleTabletIntegratedMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkCollector,
                Tablet: ?*IInkTablet,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkCollector,
                Tablet: ?*IInkTablet,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventInterest: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkCollector,
                EventId: InkCollectorEventInterest,
                Listen: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkCollector,
                EventId: InkCollectorEventInterest,
                Listen: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEventInterest: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkCollector,
                EventId: InkCollectorEventInterest,
                Listen: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkCollector,
                EventId: InkCollectorEventInterest,
                Listen: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkCollector_get_hWnd(self: *const T, CurrentWindow: ?*isize) HRESULT {
                return @as(*const IInkCollector.VTable, @ptrCast(self.vtable)).get_hWnd(@as(*const IInkCollector, @ptrCast(self)), CurrentWindow);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkCollector_put_hWnd(self: *const T, NewWindow: isize) HRESULT {
                return @as(*const IInkCollector.VTable, @ptrCast(self.vtable)).put_hWnd(@as(*const IInkCollector, @ptrCast(self)), NewWindow);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkCollector_get_Enabled(self: *const T, Collecting: ?*i16) HRESULT {
                return @as(*const IInkCollector.VTable, @ptrCast(self.vtable)).get_Enabled(@as(*const IInkCollector, @ptrCast(self)), Collecting);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkCollector_put_Enabled(self: *const T, Collecting: i16) HRESULT {
                return @as(*const IInkCollector.VTable, @ptrCast(self.vtable)).put_Enabled(@as(*const IInkCollector, @ptrCast(self)), Collecting);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkCollector_get_DefaultDrawingAttributes(self: *const T, CurrentAttributes: ?*?*IInkDrawingAttributes) HRESULT {
                return @as(*const IInkCollector.VTable, @ptrCast(self.vtable)).get_DefaultDrawingAttributes(@as(*const IInkCollector, @ptrCast(self)), CurrentAttributes);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkCollector_putref_DefaultDrawingAttributes(self: *const T, NewAttributes: ?*IInkDrawingAttributes) HRESULT {
                return @as(*const IInkCollector.VTable, @ptrCast(self.vtable)).putref_DefaultDrawingAttributes(@as(*const IInkCollector, @ptrCast(self)), NewAttributes);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkCollector_get_Renderer(self: *const T, CurrentInkRenderer: ?*?*IInkRenderer) HRESULT {
                return @as(*const IInkCollector.VTable, @ptrCast(self.vtable)).get_Renderer(@as(*const IInkCollector, @ptrCast(self)), CurrentInkRenderer);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkCollector_putref_Renderer(self: *const T, NewInkRenderer: ?*IInkRenderer) HRESULT {
                return @as(*const IInkCollector.VTable, @ptrCast(self.vtable)).putref_Renderer(@as(*const IInkCollector, @ptrCast(self)), NewInkRenderer);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkCollector_get_Ink(self: *const T, Ink: ?*?*IInkDisp) HRESULT {
                return @as(*const IInkCollector.VTable, @ptrCast(self.vtable)).get_Ink(@as(*const IInkCollector, @ptrCast(self)), Ink);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkCollector_putref_Ink(self: *const T, NewInk: ?*IInkDisp) HRESULT {
                return @as(*const IInkCollector.VTable, @ptrCast(self.vtable)).putref_Ink(@as(*const IInkCollector, @ptrCast(self)), NewInk);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkCollector_get_AutoRedraw(self: *const T, AutoRedraw: ?*i16) HRESULT {
                return @as(*const IInkCollector.VTable, @ptrCast(self.vtable)).get_AutoRedraw(@as(*const IInkCollector, @ptrCast(self)), AutoRedraw);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkCollector_put_AutoRedraw(self: *const T, AutoRedraw: i16) HRESULT {
                return @as(*const IInkCollector.VTable, @ptrCast(self.vtable)).put_AutoRedraw(@as(*const IInkCollector, @ptrCast(self)), AutoRedraw);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkCollector_get_CollectingInk(self: *const T, Collecting: ?*i16) HRESULT {
                return @as(*const IInkCollector.VTable, @ptrCast(self.vtable)).get_CollectingInk(@as(*const IInkCollector, @ptrCast(self)), Collecting);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkCollector_get_CollectionMode(self: *const T, Mode: ?*InkCollectionMode) HRESULT {
                return @as(*const IInkCollector.VTable, @ptrCast(self.vtable)).get_CollectionMode(@as(*const IInkCollector, @ptrCast(self)), Mode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkCollector_put_CollectionMode(self: *const T, Mode: InkCollectionMode) HRESULT {
                return @as(*const IInkCollector.VTable, @ptrCast(self.vtable)).put_CollectionMode(@as(*const IInkCollector, @ptrCast(self)), Mode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkCollector_get_DynamicRendering(self: *const T, Enabled: ?*i16) HRESULT {
                return @as(*const IInkCollector.VTable, @ptrCast(self.vtable)).get_DynamicRendering(@as(*const IInkCollector, @ptrCast(self)), Enabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkCollector_put_DynamicRendering(self: *const T, Enabled: i16) HRESULT {
                return @as(*const IInkCollector.VTable, @ptrCast(self.vtable)).put_DynamicRendering(@as(*const IInkCollector, @ptrCast(self)), Enabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkCollector_get_DesiredPacketDescription(self: *const T, PacketGuids: ?*VARIANT) HRESULT {
                return @as(*const IInkCollector.VTable, @ptrCast(self.vtable)).get_DesiredPacketDescription(@as(*const IInkCollector, @ptrCast(self)), PacketGuids);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkCollector_put_DesiredPacketDescription(self: *const T, PacketGuids: VARIANT) HRESULT {
                return @as(*const IInkCollector.VTable, @ptrCast(self.vtable)).put_DesiredPacketDescription(@as(*const IInkCollector, @ptrCast(self)), PacketGuids);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkCollector_get_MouseIcon(self: *const T, MouseIcon: ?*?*IPictureDisp) HRESULT {
                return @as(*const IInkCollector.VTable, @ptrCast(self.vtable)).get_MouseIcon(@as(*const IInkCollector, @ptrCast(self)), MouseIcon);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkCollector_put_MouseIcon(self: *const T, MouseIcon: ?*IPictureDisp) HRESULT {
                return @as(*const IInkCollector.VTable, @ptrCast(self.vtable)).put_MouseIcon(@as(*const IInkCollector, @ptrCast(self)), MouseIcon);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkCollector_putref_MouseIcon(self: *const T, MouseIcon: ?*IPictureDisp) HRESULT {
                return @as(*const IInkCollector.VTable, @ptrCast(self.vtable)).putref_MouseIcon(@as(*const IInkCollector, @ptrCast(self)), MouseIcon);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkCollector_get_MousePointer(self: *const T, MousePointer: ?*InkMousePointer) HRESULT {
                return @as(*const IInkCollector.VTable, @ptrCast(self.vtable)).get_MousePointer(@as(*const IInkCollector, @ptrCast(self)), MousePointer);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkCollector_put_MousePointer(self: *const T, MousePointer: InkMousePointer) HRESULT {
                return @as(*const IInkCollector.VTable, @ptrCast(self.vtable)).put_MousePointer(@as(*const IInkCollector, @ptrCast(self)), MousePointer);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkCollector_get_Cursors(self: *const T, Cursors: ?*?*IInkCursors) HRESULT {
                return @as(*const IInkCollector.VTable, @ptrCast(self.vtable)).get_Cursors(@as(*const IInkCollector, @ptrCast(self)), Cursors);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkCollector_get_MarginX(self: *const T, MarginX: ?*i32) HRESULT {
                return @as(*const IInkCollector.VTable, @ptrCast(self.vtable)).get_MarginX(@as(*const IInkCollector, @ptrCast(self)), MarginX);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkCollector_put_MarginX(self: *const T, MarginX: i32) HRESULT {
                return @as(*const IInkCollector.VTable, @ptrCast(self.vtable)).put_MarginX(@as(*const IInkCollector, @ptrCast(self)), MarginX);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkCollector_get_MarginY(self: *const T, MarginY: ?*i32) HRESULT {
                return @as(*const IInkCollector.VTable, @ptrCast(self.vtable)).get_MarginY(@as(*const IInkCollector, @ptrCast(self)), MarginY);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkCollector_put_MarginY(self: *const T, MarginY: i32) HRESULT {
                return @as(*const IInkCollector.VTable, @ptrCast(self.vtable)).put_MarginY(@as(*const IInkCollector, @ptrCast(self)), MarginY);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkCollector_get_Tablet(self: *const T, SingleTablet: ?*?*IInkTablet) HRESULT {
                return @as(*const IInkCollector.VTable, @ptrCast(self.vtable)).get_Tablet(@as(*const IInkCollector, @ptrCast(self)), SingleTablet);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkCollector_get_SupportHighContrastInk(self: *const T, Support: ?*i16) HRESULT {
                return @as(*const IInkCollector.VTable, @ptrCast(self.vtable)).get_SupportHighContrastInk(@as(*const IInkCollector, @ptrCast(self)), Support);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkCollector_put_SupportHighContrastInk(self: *const T, Support: i16) HRESULT {
                return @as(*const IInkCollector.VTable, @ptrCast(self.vtable)).put_SupportHighContrastInk(@as(*const IInkCollector, @ptrCast(self)), Support);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkCollector_SetGestureStatus(self: *const T, Gesture: InkApplicationGesture, Listen: i16) HRESULT {
                return @as(*const IInkCollector.VTable, @ptrCast(self.vtable)).SetGestureStatus(@as(*const IInkCollector, @ptrCast(self)), Gesture, Listen);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkCollector_GetGestureStatus(self: *const T, Gesture: InkApplicationGesture, Listening: ?*i16) HRESULT {
                return @as(*const IInkCollector.VTable, @ptrCast(self.vtable)).GetGestureStatus(@as(*const IInkCollector, @ptrCast(self)), Gesture, Listening);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkCollector_GetWindowInputRectangle(self: *const T, WindowInputRectangle: ?*?*IInkRectangle) HRESULT {
                return @as(*const IInkCollector.VTable, @ptrCast(self.vtable)).GetWindowInputRectangle(@as(*const IInkCollector, @ptrCast(self)), WindowInputRectangle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkCollector_SetWindowInputRectangle(self: *const T, WindowInputRectangle: ?*IInkRectangle) HRESULT {
                return @as(*const IInkCollector.VTable, @ptrCast(self.vtable)).SetWindowInputRectangle(@as(*const IInkCollector, @ptrCast(self)), WindowInputRectangle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkCollector_SetAllTabletsMode(self: *const T, UseMouseForInput: i16) HRESULT {
                return @as(*const IInkCollector.VTable, @ptrCast(self.vtable)).SetAllTabletsMode(@as(*const IInkCollector, @ptrCast(self)), UseMouseForInput);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkCollector_SetSingleTabletIntegratedMode(self: *const T, Tablet: ?*IInkTablet) HRESULT {
                return @as(*const IInkCollector.VTable, @ptrCast(self.vtable)).SetSingleTabletIntegratedMode(@as(*const IInkCollector, @ptrCast(self)), Tablet);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkCollector_GetEventInterest(self: *const T, EventId: InkCollectorEventInterest, Listen: ?*i16) HRESULT {
                return @as(*const IInkCollector.VTable, @ptrCast(self.vtable)).GetEventInterest(@as(*const IInkCollector, @ptrCast(self)), EventId, Listen);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkCollector_SetEventInterest(self: *const T, EventId: InkCollectorEventInterest, Listen: i16) HRESULT {
                return @as(*const IInkCollector.VTable, @ptrCast(self.vtable)).SetEventInterest(@as(*const IInkCollector, @ptrCast(self)), EventId, Listen);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID__IInkCollectorEvents_Value = Guid.initString("11a583f2-712d-4fea-abcf-ab4af38ea06b");
pub const IID__IInkCollectorEvents = &IID__IInkCollectorEvents_Value;
pub const _IInkCollectorEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IInkOverlay_Value = Guid.initString("b82a463b-c1c5-45a3-997c-deab5651b67a");
pub const IID_IInkOverlay = &IID_IInkOverlay_Value;
pub const IInkOverlay = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_hWnd: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkOverlay,
                CurrentWindow: ?*isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkOverlay,
                CurrentWindow: ?*isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_hWnd: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkOverlay,
                NewWindow: isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkOverlay,
                NewWindow: isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Enabled: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkOverlay,
                Collecting: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkOverlay,
                Collecting: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Enabled: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkOverlay,
                Collecting: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkOverlay,
                Collecting: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DefaultDrawingAttributes: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkOverlay,
                CurrentAttributes: ?*?*IInkDrawingAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkOverlay,
                CurrentAttributes: ?*?*IInkDrawingAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        putref_DefaultDrawingAttributes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkOverlay,
                NewAttributes: ?*IInkDrawingAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkOverlay,
                NewAttributes: ?*IInkDrawingAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Renderer: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkOverlay,
                CurrentInkRenderer: ?*?*IInkRenderer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkOverlay,
                CurrentInkRenderer: ?*?*IInkRenderer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        putref_Renderer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkOverlay,
                NewInkRenderer: ?*IInkRenderer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkOverlay,
                NewInkRenderer: ?*IInkRenderer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Ink: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkOverlay,
                Ink: ?*?*IInkDisp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkOverlay,
                Ink: ?*?*IInkDisp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        putref_Ink: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkOverlay,
                NewInk: ?*IInkDisp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkOverlay,
                NewInk: ?*IInkDisp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AutoRedraw: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkOverlay,
                AutoRedraw: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkOverlay,
                AutoRedraw: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AutoRedraw: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkOverlay,
                AutoRedraw: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkOverlay,
                AutoRedraw: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CollectingInk: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkOverlay,
                Collecting: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkOverlay,
                Collecting: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CollectionMode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkOverlay,
                Mode: ?*InkCollectionMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkOverlay,
                Mode: ?*InkCollectionMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_CollectionMode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkOverlay,
                Mode: InkCollectionMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkOverlay,
                Mode: InkCollectionMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DynamicRendering: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkOverlay,
                Enabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkOverlay,
                Enabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DynamicRendering: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkOverlay,
                Enabled: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkOverlay,
                Enabled: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DesiredPacketDescription: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkOverlay,
                PacketGuids: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkOverlay,
                PacketGuids: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DesiredPacketDescription: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkOverlay,
                PacketGuids: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkOverlay,
                PacketGuids: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MouseIcon: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkOverlay,
                MouseIcon: ?*?*IPictureDisp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkOverlay,
                MouseIcon: ?*?*IPictureDisp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MouseIcon: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkOverlay,
                MouseIcon: ?*IPictureDisp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkOverlay,
                MouseIcon: ?*IPictureDisp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        putref_MouseIcon: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkOverlay,
                MouseIcon: ?*IPictureDisp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkOverlay,
                MouseIcon: ?*IPictureDisp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MousePointer: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkOverlay,
                MousePointer: ?*InkMousePointer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkOverlay,
                MousePointer: ?*InkMousePointer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MousePointer: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkOverlay,
                MousePointer: InkMousePointer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkOverlay,
                MousePointer: InkMousePointer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EditingMode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkOverlay,
                EditingMode: ?*InkOverlayEditingMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkOverlay,
                EditingMode: ?*InkOverlayEditingMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_EditingMode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkOverlay,
                EditingMode: InkOverlayEditingMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkOverlay,
                EditingMode: InkOverlayEditingMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Selection: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkOverlay,
                Selection: ?*?*IInkStrokes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkOverlay,
                Selection: ?*?*IInkStrokes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Selection: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkOverlay,
                Selection: ?*IInkStrokes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkOverlay,
                Selection: ?*IInkStrokes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EraserMode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkOverlay,
                EraserMode: ?*InkOverlayEraserMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkOverlay,
                EraserMode: ?*InkOverlayEraserMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_EraserMode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkOverlay,
                EraserMode: InkOverlayEraserMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkOverlay,
                EraserMode: InkOverlayEraserMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EraserWidth: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkOverlay,
                EraserWidth: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkOverlay,
                EraserWidth: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_EraserWidth: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkOverlay,
                newEraserWidth: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkOverlay,
                newEraserWidth: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AttachMode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkOverlay,
                AttachMode: ?*InkOverlayAttachMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkOverlay,
                AttachMode: ?*InkOverlayAttachMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AttachMode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkOverlay,
                AttachMode: InkOverlayAttachMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkOverlay,
                AttachMode: InkOverlayAttachMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Cursors: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkOverlay,
                Cursors: ?*?*IInkCursors,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkOverlay,
                Cursors: ?*?*IInkCursors,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MarginX: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkOverlay,
                MarginX: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkOverlay,
                MarginX: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MarginX: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkOverlay,
                MarginX: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkOverlay,
                MarginX: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MarginY: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkOverlay,
                MarginY: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkOverlay,
                MarginY: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MarginY: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkOverlay,
                MarginY: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkOverlay,
                MarginY: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Tablet: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkOverlay,
                SingleTablet: ?*?*IInkTablet,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkOverlay,
                SingleTablet: ?*?*IInkTablet,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SupportHighContrastInk: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkOverlay,
                Support: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkOverlay,
                Support: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SupportHighContrastInk: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkOverlay,
                Support: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkOverlay,
                Support: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SupportHighContrastSelectionUI: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkOverlay,
                Support: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkOverlay,
                Support: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SupportHighContrastSelectionUI: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkOverlay,
                Support: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkOverlay,
                Support: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        HitTestSelection: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkOverlay,
                x: i32,
                y: i32,
                SelArea: ?*SelectionHitResult,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkOverlay,
                x: i32,
                y: i32,
                SelArea: ?*SelectionHitResult,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Draw: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkOverlay,
                Rect: ?*IInkRectangle,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkOverlay,
                Rect: ?*IInkRectangle,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetGestureStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkOverlay,
                Gesture: InkApplicationGesture,
                Listen: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkOverlay,
                Gesture: InkApplicationGesture,
                Listen: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetGestureStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkOverlay,
                Gesture: InkApplicationGesture,
                Listening: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkOverlay,
                Gesture: InkApplicationGesture,
                Listening: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetWindowInputRectangle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkOverlay,
                WindowInputRectangle: ?*?*IInkRectangle,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkOverlay,
                WindowInputRectangle: ?*?*IInkRectangle,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetWindowInputRectangle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkOverlay,
                WindowInputRectangle: ?*IInkRectangle,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkOverlay,
                WindowInputRectangle: ?*IInkRectangle,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetAllTabletsMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkOverlay,
                UseMouseForInput: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkOverlay,
                UseMouseForInput: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSingleTabletIntegratedMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkOverlay,
                Tablet: ?*IInkTablet,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkOverlay,
                Tablet: ?*IInkTablet,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventInterest: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkOverlay,
                EventId: InkCollectorEventInterest,
                Listen: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkOverlay,
                EventId: InkCollectorEventInterest,
                Listen: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEventInterest: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkOverlay,
                EventId: InkCollectorEventInterest,
                Listen: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkOverlay,
                EventId: InkCollectorEventInterest,
                Listen: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkOverlay_get_hWnd(self: *const T, CurrentWindow: ?*isize) HRESULT {
                return @as(*const IInkOverlay.VTable, @ptrCast(self.vtable)).get_hWnd(@as(*const IInkOverlay, @ptrCast(self)), CurrentWindow);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkOverlay_put_hWnd(self: *const T, NewWindow: isize) HRESULT {
                return @as(*const IInkOverlay.VTable, @ptrCast(self.vtable)).put_hWnd(@as(*const IInkOverlay, @ptrCast(self)), NewWindow);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkOverlay_get_Enabled(self: *const T, Collecting: ?*i16) HRESULT {
                return @as(*const IInkOverlay.VTable, @ptrCast(self.vtable)).get_Enabled(@as(*const IInkOverlay, @ptrCast(self)), Collecting);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkOverlay_put_Enabled(self: *const T, Collecting: i16) HRESULT {
                return @as(*const IInkOverlay.VTable, @ptrCast(self.vtable)).put_Enabled(@as(*const IInkOverlay, @ptrCast(self)), Collecting);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkOverlay_get_DefaultDrawingAttributes(self: *const T, CurrentAttributes: ?*?*IInkDrawingAttributes) HRESULT {
                return @as(*const IInkOverlay.VTable, @ptrCast(self.vtable)).get_DefaultDrawingAttributes(@as(*const IInkOverlay, @ptrCast(self)), CurrentAttributes);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkOverlay_putref_DefaultDrawingAttributes(self: *const T, NewAttributes: ?*IInkDrawingAttributes) HRESULT {
                return @as(*const IInkOverlay.VTable, @ptrCast(self.vtable)).putref_DefaultDrawingAttributes(@as(*const IInkOverlay, @ptrCast(self)), NewAttributes);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkOverlay_get_Renderer(self: *const T, CurrentInkRenderer: ?*?*IInkRenderer) HRESULT {
                return @as(*const IInkOverlay.VTable, @ptrCast(self.vtable)).get_Renderer(@as(*const IInkOverlay, @ptrCast(self)), CurrentInkRenderer);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkOverlay_putref_Renderer(self: *const T, NewInkRenderer: ?*IInkRenderer) HRESULT {
                return @as(*const IInkOverlay.VTable, @ptrCast(self.vtable)).putref_Renderer(@as(*const IInkOverlay, @ptrCast(self)), NewInkRenderer);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkOverlay_get_Ink(self: *const T, Ink: ?*?*IInkDisp) HRESULT {
                return @as(*const IInkOverlay.VTable, @ptrCast(self.vtable)).get_Ink(@as(*const IInkOverlay, @ptrCast(self)), Ink);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkOverlay_putref_Ink(self: *const T, NewInk: ?*IInkDisp) HRESULT {
                return @as(*const IInkOverlay.VTable, @ptrCast(self.vtable)).putref_Ink(@as(*const IInkOverlay, @ptrCast(self)), NewInk);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkOverlay_get_AutoRedraw(self: *const T, AutoRedraw: ?*i16) HRESULT {
                return @as(*const IInkOverlay.VTable, @ptrCast(self.vtable)).get_AutoRedraw(@as(*const IInkOverlay, @ptrCast(self)), AutoRedraw);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkOverlay_put_AutoRedraw(self: *const T, AutoRedraw: i16) HRESULT {
                return @as(*const IInkOverlay.VTable, @ptrCast(self.vtable)).put_AutoRedraw(@as(*const IInkOverlay, @ptrCast(self)), AutoRedraw);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkOverlay_get_CollectingInk(self: *const T, Collecting: ?*i16) HRESULT {
                return @as(*const IInkOverlay.VTable, @ptrCast(self.vtable)).get_CollectingInk(@as(*const IInkOverlay, @ptrCast(self)), Collecting);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkOverlay_get_CollectionMode(self: *const T, Mode: ?*InkCollectionMode) HRESULT {
                return @as(*const IInkOverlay.VTable, @ptrCast(self.vtable)).get_CollectionMode(@as(*const IInkOverlay, @ptrCast(self)), Mode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkOverlay_put_CollectionMode(self: *const T, Mode: InkCollectionMode) HRESULT {
                return @as(*const IInkOverlay.VTable, @ptrCast(self.vtable)).put_CollectionMode(@as(*const IInkOverlay, @ptrCast(self)), Mode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkOverlay_get_DynamicRendering(self: *const T, Enabled: ?*i16) HRESULT {
                return @as(*const IInkOverlay.VTable, @ptrCast(self.vtable)).get_DynamicRendering(@as(*const IInkOverlay, @ptrCast(self)), Enabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkOverlay_put_DynamicRendering(self: *const T, Enabled: i16) HRESULT {
                return @as(*const IInkOverlay.VTable, @ptrCast(self.vtable)).put_DynamicRendering(@as(*const IInkOverlay, @ptrCast(self)), Enabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkOverlay_get_DesiredPacketDescription(self: *const T, PacketGuids: ?*VARIANT) HRESULT {
                return @as(*const IInkOverlay.VTable, @ptrCast(self.vtable)).get_DesiredPacketDescription(@as(*const IInkOverlay, @ptrCast(self)), PacketGuids);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkOverlay_put_DesiredPacketDescription(self: *const T, PacketGuids: VARIANT) HRESULT {
                return @as(*const IInkOverlay.VTable, @ptrCast(self.vtable)).put_DesiredPacketDescription(@as(*const IInkOverlay, @ptrCast(self)), PacketGuids);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkOverlay_get_MouseIcon(self: *const T, MouseIcon: ?*?*IPictureDisp) HRESULT {
                return @as(*const IInkOverlay.VTable, @ptrCast(self.vtable)).get_MouseIcon(@as(*const IInkOverlay, @ptrCast(self)), MouseIcon);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkOverlay_put_MouseIcon(self: *const T, MouseIcon: ?*IPictureDisp) HRESULT {
                return @as(*const IInkOverlay.VTable, @ptrCast(self.vtable)).put_MouseIcon(@as(*const IInkOverlay, @ptrCast(self)), MouseIcon);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkOverlay_putref_MouseIcon(self: *const T, MouseIcon: ?*IPictureDisp) HRESULT {
                return @as(*const IInkOverlay.VTable, @ptrCast(self.vtable)).putref_MouseIcon(@as(*const IInkOverlay, @ptrCast(self)), MouseIcon);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkOverlay_get_MousePointer(self: *const T, MousePointer: ?*InkMousePointer) HRESULT {
                return @as(*const IInkOverlay.VTable, @ptrCast(self.vtable)).get_MousePointer(@as(*const IInkOverlay, @ptrCast(self)), MousePointer);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkOverlay_put_MousePointer(self: *const T, MousePointer: InkMousePointer) HRESULT {
                return @as(*const IInkOverlay.VTable, @ptrCast(self.vtable)).put_MousePointer(@as(*const IInkOverlay, @ptrCast(self)), MousePointer);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkOverlay_get_EditingMode(self: *const T, EditingMode: ?*InkOverlayEditingMode) HRESULT {
                return @as(*const IInkOverlay.VTable, @ptrCast(self.vtable)).get_EditingMode(@as(*const IInkOverlay, @ptrCast(self)), EditingMode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkOverlay_put_EditingMode(self: *const T, EditingMode: InkOverlayEditingMode) HRESULT {
                return @as(*const IInkOverlay.VTable, @ptrCast(self.vtable)).put_EditingMode(@as(*const IInkOverlay, @ptrCast(self)), EditingMode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkOverlay_get_Selection(self: *const T, Selection: ?*?*IInkStrokes) HRESULT {
                return @as(*const IInkOverlay.VTable, @ptrCast(self.vtable)).get_Selection(@as(*const IInkOverlay, @ptrCast(self)), Selection);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkOverlay_put_Selection(self: *const T, Selection: ?*IInkStrokes) HRESULT {
                return @as(*const IInkOverlay.VTable, @ptrCast(self.vtable)).put_Selection(@as(*const IInkOverlay, @ptrCast(self)), Selection);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkOverlay_get_EraserMode(self: *const T, EraserMode: ?*InkOverlayEraserMode) HRESULT {
                return @as(*const IInkOverlay.VTable, @ptrCast(self.vtable)).get_EraserMode(@as(*const IInkOverlay, @ptrCast(self)), EraserMode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkOverlay_put_EraserMode(self: *const T, EraserMode: InkOverlayEraserMode) HRESULT {
                return @as(*const IInkOverlay.VTable, @ptrCast(self.vtable)).put_EraserMode(@as(*const IInkOverlay, @ptrCast(self)), EraserMode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkOverlay_get_EraserWidth(self: *const T, EraserWidth: ?*i32) HRESULT {
                return @as(*const IInkOverlay.VTable, @ptrCast(self.vtable)).get_EraserWidth(@as(*const IInkOverlay, @ptrCast(self)), EraserWidth);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkOverlay_put_EraserWidth(self: *const T, newEraserWidth: i32) HRESULT {
                return @as(*const IInkOverlay.VTable, @ptrCast(self.vtable)).put_EraserWidth(@as(*const IInkOverlay, @ptrCast(self)), newEraserWidth);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkOverlay_get_AttachMode(self: *const T, AttachMode: ?*InkOverlayAttachMode) HRESULT {
                return @as(*const IInkOverlay.VTable, @ptrCast(self.vtable)).get_AttachMode(@as(*const IInkOverlay, @ptrCast(self)), AttachMode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkOverlay_put_AttachMode(self: *const T, AttachMode: InkOverlayAttachMode) HRESULT {
                return @as(*const IInkOverlay.VTable, @ptrCast(self.vtable)).put_AttachMode(@as(*const IInkOverlay, @ptrCast(self)), AttachMode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkOverlay_get_Cursors(self: *const T, Cursors: ?*?*IInkCursors) HRESULT {
                return @as(*const IInkOverlay.VTable, @ptrCast(self.vtable)).get_Cursors(@as(*const IInkOverlay, @ptrCast(self)), Cursors);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkOverlay_get_MarginX(self: *const T, MarginX: ?*i32) HRESULT {
                return @as(*const IInkOverlay.VTable, @ptrCast(self.vtable)).get_MarginX(@as(*const IInkOverlay, @ptrCast(self)), MarginX);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkOverlay_put_MarginX(self: *const T, MarginX: i32) HRESULT {
                return @as(*const IInkOverlay.VTable, @ptrCast(self.vtable)).put_MarginX(@as(*const IInkOverlay, @ptrCast(self)), MarginX);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkOverlay_get_MarginY(self: *const T, MarginY: ?*i32) HRESULT {
                return @as(*const IInkOverlay.VTable, @ptrCast(self.vtable)).get_MarginY(@as(*const IInkOverlay, @ptrCast(self)), MarginY);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkOverlay_put_MarginY(self: *const T, MarginY: i32) HRESULT {
                return @as(*const IInkOverlay.VTable, @ptrCast(self.vtable)).put_MarginY(@as(*const IInkOverlay, @ptrCast(self)), MarginY);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkOverlay_get_Tablet(self: *const T, SingleTablet: ?*?*IInkTablet) HRESULT {
                return @as(*const IInkOverlay.VTable, @ptrCast(self.vtable)).get_Tablet(@as(*const IInkOverlay, @ptrCast(self)), SingleTablet);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkOverlay_get_SupportHighContrastInk(self: *const T, Support: ?*i16) HRESULT {
                return @as(*const IInkOverlay.VTable, @ptrCast(self.vtable)).get_SupportHighContrastInk(@as(*const IInkOverlay, @ptrCast(self)), Support);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkOverlay_put_SupportHighContrastInk(self: *const T, Support: i16) HRESULT {
                return @as(*const IInkOverlay.VTable, @ptrCast(self.vtable)).put_SupportHighContrastInk(@as(*const IInkOverlay, @ptrCast(self)), Support);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkOverlay_get_SupportHighContrastSelectionUI(self: *const T, Support: ?*i16) HRESULT {
                return @as(*const IInkOverlay.VTable, @ptrCast(self.vtable)).get_SupportHighContrastSelectionUI(@as(*const IInkOverlay, @ptrCast(self)), Support);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkOverlay_put_SupportHighContrastSelectionUI(self: *const T, Support: i16) HRESULT {
                return @as(*const IInkOverlay.VTable, @ptrCast(self.vtable)).put_SupportHighContrastSelectionUI(@as(*const IInkOverlay, @ptrCast(self)), Support);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkOverlay_HitTestSelection(self: *const T, x: i32, y: i32, SelArea: ?*SelectionHitResult) HRESULT {
                return @as(*const IInkOverlay.VTable, @ptrCast(self.vtable)).HitTestSelection(@as(*const IInkOverlay, @ptrCast(self)), x, y, SelArea);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkOverlay_Draw(self: *const T, Rect: ?*IInkRectangle) HRESULT {
                return @as(*const IInkOverlay.VTable, @ptrCast(self.vtable)).Draw(@as(*const IInkOverlay, @ptrCast(self)), Rect);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkOverlay_SetGestureStatus(self: *const T, Gesture: InkApplicationGesture, Listen: i16) HRESULT {
                return @as(*const IInkOverlay.VTable, @ptrCast(self.vtable)).SetGestureStatus(@as(*const IInkOverlay, @ptrCast(self)), Gesture, Listen);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkOverlay_GetGestureStatus(self: *const T, Gesture: InkApplicationGesture, Listening: ?*i16) HRESULT {
                return @as(*const IInkOverlay.VTable, @ptrCast(self.vtable)).GetGestureStatus(@as(*const IInkOverlay, @ptrCast(self)), Gesture, Listening);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkOverlay_GetWindowInputRectangle(self: *const T, WindowInputRectangle: ?*?*IInkRectangle) HRESULT {
                return @as(*const IInkOverlay.VTable, @ptrCast(self.vtable)).GetWindowInputRectangle(@as(*const IInkOverlay, @ptrCast(self)), WindowInputRectangle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkOverlay_SetWindowInputRectangle(self: *const T, WindowInputRectangle: ?*IInkRectangle) HRESULT {
                return @as(*const IInkOverlay.VTable, @ptrCast(self.vtable)).SetWindowInputRectangle(@as(*const IInkOverlay, @ptrCast(self)), WindowInputRectangle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkOverlay_SetAllTabletsMode(self: *const T, UseMouseForInput: i16) HRESULT {
                return @as(*const IInkOverlay.VTable, @ptrCast(self.vtable)).SetAllTabletsMode(@as(*const IInkOverlay, @ptrCast(self)), UseMouseForInput);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkOverlay_SetSingleTabletIntegratedMode(self: *const T, Tablet: ?*IInkTablet) HRESULT {
                return @as(*const IInkOverlay.VTable, @ptrCast(self.vtable)).SetSingleTabletIntegratedMode(@as(*const IInkOverlay, @ptrCast(self)), Tablet);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkOverlay_GetEventInterest(self: *const T, EventId: InkCollectorEventInterest, Listen: ?*i16) HRESULT {
                return @as(*const IInkOverlay.VTable, @ptrCast(self.vtable)).GetEventInterest(@as(*const IInkOverlay, @ptrCast(self)), EventId, Listen);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkOverlay_SetEventInterest(self: *const T, EventId: InkCollectorEventInterest, Listen: i16) HRESULT {
                return @as(*const IInkOverlay.VTable, @ptrCast(self.vtable)).SetEventInterest(@as(*const IInkOverlay, @ptrCast(self)), EventId, Listen);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID__IInkOverlayEvents_Value = Guid.initString("31179b69-e563-489e-b16f-712f1e8a0651");
pub const IID__IInkOverlayEvents = &IID__IInkOverlayEvents_Value;
pub const _IInkOverlayEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IInkPicture_Value = Guid.initString("e85662e0-379a-40d7-9b5c-757d233f9923");
pub const IID_IInkPicture = &IID_IInkPicture_Value;
pub const IInkPicture = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_hWnd: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkPicture,
                CurrentWindow: ?*isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkPicture,
                CurrentWindow: ?*isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DefaultDrawingAttributes: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkPicture,
                CurrentAttributes: ?*?*IInkDrawingAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkPicture,
                CurrentAttributes: ?*?*IInkDrawingAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        putref_DefaultDrawingAttributes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkPicture,
                NewAttributes: ?*IInkDrawingAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkPicture,
                NewAttributes: ?*IInkDrawingAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Renderer: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkPicture,
                CurrentInkRenderer: ?*?*IInkRenderer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkPicture,
                CurrentInkRenderer: ?*?*IInkRenderer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        putref_Renderer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkPicture,
                NewInkRenderer: ?*IInkRenderer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkPicture,
                NewInkRenderer: ?*IInkRenderer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Ink: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkPicture,
                Ink: ?*?*IInkDisp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkPicture,
                Ink: ?*?*IInkDisp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        putref_Ink: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkPicture,
                NewInk: ?*IInkDisp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkPicture,
                NewInk: ?*IInkDisp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AutoRedraw: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkPicture,
                AutoRedraw: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkPicture,
                AutoRedraw: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AutoRedraw: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkPicture,
                AutoRedraw: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkPicture,
                AutoRedraw: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CollectingInk: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkPicture,
                Collecting: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkPicture,
                Collecting: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CollectionMode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkPicture,
                Mode: ?*InkCollectionMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkPicture,
                Mode: ?*InkCollectionMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_CollectionMode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkPicture,
                Mode: InkCollectionMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkPicture,
                Mode: InkCollectionMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DynamicRendering: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkPicture,
                Enabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkPicture,
                Enabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DynamicRendering: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkPicture,
                Enabled: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkPicture,
                Enabled: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DesiredPacketDescription: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkPicture,
                PacketGuids: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkPicture,
                PacketGuids: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DesiredPacketDescription: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkPicture,
                PacketGuids: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkPicture,
                PacketGuids: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MouseIcon: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkPicture,
                MouseIcon: ?*?*IPictureDisp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkPicture,
                MouseIcon: ?*?*IPictureDisp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MouseIcon: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkPicture,
                MouseIcon: ?*IPictureDisp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkPicture,
                MouseIcon: ?*IPictureDisp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        putref_MouseIcon: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkPicture,
                MouseIcon: ?*IPictureDisp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkPicture,
                MouseIcon: ?*IPictureDisp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MousePointer: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkPicture,
                MousePointer: ?*InkMousePointer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkPicture,
                MousePointer: ?*InkMousePointer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MousePointer: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkPicture,
                MousePointer: InkMousePointer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkPicture,
                MousePointer: InkMousePointer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EditingMode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkPicture,
                EditingMode: ?*InkOverlayEditingMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkPicture,
                EditingMode: ?*InkOverlayEditingMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_EditingMode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkPicture,
                EditingMode: InkOverlayEditingMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkPicture,
                EditingMode: InkOverlayEditingMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Selection: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkPicture,
                Selection: ?*?*IInkStrokes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkPicture,
                Selection: ?*?*IInkStrokes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Selection: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkPicture,
                Selection: ?*IInkStrokes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkPicture,
                Selection: ?*IInkStrokes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EraserMode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkPicture,
                EraserMode: ?*InkOverlayEraserMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkPicture,
                EraserMode: ?*InkOverlayEraserMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_EraserMode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkPicture,
                EraserMode: InkOverlayEraserMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkPicture,
                EraserMode: InkOverlayEraserMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EraserWidth: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkPicture,
                EraserWidth: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkPicture,
                EraserWidth: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_EraserWidth: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkPicture,
                newEraserWidth: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkPicture,
                newEraserWidth: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        putref_Picture: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkPicture,
                pPicture: ?*IPictureDisp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkPicture,
                pPicture: ?*IPictureDisp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Picture: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkPicture,
                pPicture: ?*IPictureDisp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkPicture,
                pPicture: ?*IPictureDisp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Picture: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkPicture,
                ppPicture: ?*?*IPictureDisp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkPicture,
                ppPicture: ?*?*IPictureDisp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SizeMode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkPicture,
                smNewSizeMode: InkPictureSizeMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkPicture,
                smNewSizeMode: InkPictureSizeMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SizeMode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkPicture,
                smSizeMode: ?*InkPictureSizeMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkPicture,
                smSizeMode: ?*InkPictureSizeMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BackColor: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkPicture,
                newColor: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkPicture,
                newColor: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BackColor: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkPicture,
                pColor: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkPicture,
                pColor: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Cursors: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkPicture,
                Cursors: ?*?*IInkCursors,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkPicture,
                Cursors: ?*?*IInkCursors,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MarginX: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkPicture,
                MarginX: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkPicture,
                MarginX: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MarginX: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkPicture,
                MarginX: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkPicture,
                MarginX: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MarginY: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkPicture,
                MarginY: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkPicture,
                MarginY: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MarginY: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkPicture,
                MarginY: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkPicture,
                MarginY: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Tablet: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkPicture,
                SingleTablet: ?*?*IInkTablet,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkPicture,
                SingleTablet: ?*?*IInkTablet,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SupportHighContrastInk: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkPicture,
                Support: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkPicture,
                Support: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SupportHighContrastInk: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkPicture,
                Support: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkPicture,
                Support: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SupportHighContrastSelectionUI: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkPicture,
                Support: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkPicture,
                Support: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SupportHighContrastSelectionUI: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkPicture,
                Support: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkPicture,
                Support: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        HitTestSelection: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkPicture,
                x: i32,
                y: i32,
                SelArea: ?*SelectionHitResult,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkPicture,
                x: i32,
                y: i32,
                SelArea: ?*SelectionHitResult,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetGestureStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkPicture,
                Gesture: InkApplicationGesture,
                Listen: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkPicture,
                Gesture: InkApplicationGesture,
                Listen: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetGestureStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkPicture,
                Gesture: InkApplicationGesture,
                Listening: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkPicture,
                Gesture: InkApplicationGesture,
                Listening: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetWindowInputRectangle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkPicture,
                WindowInputRectangle: ?*?*IInkRectangle,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkPicture,
                WindowInputRectangle: ?*?*IInkRectangle,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetWindowInputRectangle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkPicture,
                WindowInputRectangle: ?*IInkRectangle,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkPicture,
                WindowInputRectangle: ?*IInkRectangle,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetAllTabletsMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkPicture,
                UseMouseForInput: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkPicture,
                UseMouseForInput: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSingleTabletIntegratedMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkPicture,
                Tablet: ?*IInkTablet,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkPicture,
                Tablet: ?*IInkTablet,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventInterest: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkPicture,
                EventId: InkCollectorEventInterest,
                Listen: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkPicture,
                EventId: InkCollectorEventInterest,
                Listen: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEventInterest: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkPicture,
                EventId: InkCollectorEventInterest,
                Listen: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkPicture,
                EventId: InkCollectorEventInterest,
                Listen: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InkEnabled: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkPicture,
                Collecting: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkPicture,
                Collecting: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_InkEnabled: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkPicture,
                Collecting: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkPicture,
                Collecting: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Enabled: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkPicture,
                pbool: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkPicture,
                pbool: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Enabled: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkPicture,
                vbool: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkPicture,
                vbool: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkPicture_get_hWnd(self: *const T, CurrentWindow: ?*isize) HRESULT {
                return @as(*const IInkPicture.VTable, @ptrCast(self.vtable)).get_hWnd(@as(*const IInkPicture, @ptrCast(self)), CurrentWindow);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkPicture_get_DefaultDrawingAttributes(self: *const T, CurrentAttributes: ?*?*IInkDrawingAttributes) HRESULT {
                return @as(*const IInkPicture.VTable, @ptrCast(self.vtable)).get_DefaultDrawingAttributes(@as(*const IInkPicture, @ptrCast(self)), CurrentAttributes);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkPicture_putref_DefaultDrawingAttributes(self: *const T, NewAttributes: ?*IInkDrawingAttributes) HRESULT {
                return @as(*const IInkPicture.VTable, @ptrCast(self.vtable)).putref_DefaultDrawingAttributes(@as(*const IInkPicture, @ptrCast(self)), NewAttributes);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkPicture_get_Renderer(self: *const T, CurrentInkRenderer: ?*?*IInkRenderer) HRESULT {
                return @as(*const IInkPicture.VTable, @ptrCast(self.vtable)).get_Renderer(@as(*const IInkPicture, @ptrCast(self)), CurrentInkRenderer);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkPicture_putref_Renderer(self: *const T, NewInkRenderer: ?*IInkRenderer) HRESULT {
                return @as(*const IInkPicture.VTable, @ptrCast(self.vtable)).putref_Renderer(@as(*const IInkPicture, @ptrCast(self)), NewInkRenderer);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkPicture_get_Ink(self: *const T, Ink: ?*?*IInkDisp) HRESULT {
                return @as(*const IInkPicture.VTable, @ptrCast(self.vtable)).get_Ink(@as(*const IInkPicture, @ptrCast(self)), Ink);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkPicture_putref_Ink(self: *const T, NewInk: ?*IInkDisp) HRESULT {
                return @as(*const IInkPicture.VTable, @ptrCast(self.vtable)).putref_Ink(@as(*const IInkPicture, @ptrCast(self)), NewInk);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkPicture_get_AutoRedraw(self: *const T, AutoRedraw: ?*i16) HRESULT {
                return @as(*const IInkPicture.VTable, @ptrCast(self.vtable)).get_AutoRedraw(@as(*const IInkPicture, @ptrCast(self)), AutoRedraw);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkPicture_put_AutoRedraw(self: *const T, AutoRedraw: i16) HRESULT {
                return @as(*const IInkPicture.VTable, @ptrCast(self.vtable)).put_AutoRedraw(@as(*const IInkPicture, @ptrCast(self)), AutoRedraw);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkPicture_get_CollectingInk(self: *const T, Collecting: ?*i16) HRESULT {
                return @as(*const IInkPicture.VTable, @ptrCast(self.vtable)).get_CollectingInk(@as(*const IInkPicture, @ptrCast(self)), Collecting);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkPicture_get_CollectionMode(self: *const T, Mode: ?*InkCollectionMode) HRESULT {
                return @as(*const IInkPicture.VTable, @ptrCast(self.vtable)).get_CollectionMode(@as(*const IInkPicture, @ptrCast(self)), Mode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkPicture_put_CollectionMode(self: *const T, Mode: InkCollectionMode) HRESULT {
                return @as(*const IInkPicture.VTable, @ptrCast(self.vtable)).put_CollectionMode(@as(*const IInkPicture, @ptrCast(self)), Mode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkPicture_get_DynamicRendering(self: *const T, Enabled: ?*i16) HRESULT {
                return @as(*const IInkPicture.VTable, @ptrCast(self.vtable)).get_DynamicRendering(@as(*const IInkPicture, @ptrCast(self)), Enabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkPicture_put_DynamicRendering(self: *const T, Enabled: i16) HRESULT {
                return @as(*const IInkPicture.VTable, @ptrCast(self.vtable)).put_DynamicRendering(@as(*const IInkPicture, @ptrCast(self)), Enabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkPicture_get_DesiredPacketDescription(self: *const T, PacketGuids: ?*VARIANT) HRESULT {
                return @as(*const IInkPicture.VTable, @ptrCast(self.vtable)).get_DesiredPacketDescription(@as(*const IInkPicture, @ptrCast(self)), PacketGuids);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkPicture_put_DesiredPacketDescription(self: *const T, PacketGuids: VARIANT) HRESULT {
                return @as(*const IInkPicture.VTable, @ptrCast(self.vtable)).put_DesiredPacketDescription(@as(*const IInkPicture, @ptrCast(self)), PacketGuids);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkPicture_get_MouseIcon(self: *const T, MouseIcon: ?*?*IPictureDisp) HRESULT {
                return @as(*const IInkPicture.VTable, @ptrCast(self.vtable)).get_MouseIcon(@as(*const IInkPicture, @ptrCast(self)), MouseIcon);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkPicture_put_MouseIcon(self: *const T, MouseIcon: ?*IPictureDisp) HRESULT {
                return @as(*const IInkPicture.VTable, @ptrCast(self.vtable)).put_MouseIcon(@as(*const IInkPicture, @ptrCast(self)), MouseIcon);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkPicture_putref_MouseIcon(self: *const T, MouseIcon: ?*IPictureDisp) HRESULT {
                return @as(*const IInkPicture.VTable, @ptrCast(self.vtable)).putref_MouseIcon(@as(*const IInkPicture, @ptrCast(self)), MouseIcon);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkPicture_get_MousePointer(self: *const T, MousePointer: ?*InkMousePointer) HRESULT {
                return @as(*const IInkPicture.VTable, @ptrCast(self.vtable)).get_MousePointer(@as(*const IInkPicture, @ptrCast(self)), MousePointer);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkPicture_put_MousePointer(self: *const T, MousePointer: InkMousePointer) HRESULT {
                return @as(*const IInkPicture.VTable, @ptrCast(self.vtable)).put_MousePointer(@as(*const IInkPicture, @ptrCast(self)), MousePointer);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkPicture_get_EditingMode(self: *const T, EditingMode: ?*InkOverlayEditingMode) HRESULT {
                return @as(*const IInkPicture.VTable, @ptrCast(self.vtable)).get_EditingMode(@as(*const IInkPicture, @ptrCast(self)), EditingMode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkPicture_put_EditingMode(self: *const T, EditingMode: InkOverlayEditingMode) HRESULT {
                return @as(*const IInkPicture.VTable, @ptrCast(self.vtable)).put_EditingMode(@as(*const IInkPicture, @ptrCast(self)), EditingMode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkPicture_get_Selection(self: *const T, Selection: ?*?*IInkStrokes) HRESULT {
                return @as(*const IInkPicture.VTable, @ptrCast(self.vtable)).get_Selection(@as(*const IInkPicture, @ptrCast(self)), Selection);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkPicture_put_Selection(self: *const T, Selection: ?*IInkStrokes) HRESULT {
                return @as(*const IInkPicture.VTable, @ptrCast(self.vtable)).put_Selection(@as(*const IInkPicture, @ptrCast(self)), Selection);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkPicture_get_EraserMode(self: *const T, EraserMode: ?*InkOverlayEraserMode) HRESULT {
                return @as(*const IInkPicture.VTable, @ptrCast(self.vtable)).get_EraserMode(@as(*const IInkPicture, @ptrCast(self)), EraserMode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkPicture_put_EraserMode(self: *const T, EraserMode: InkOverlayEraserMode) HRESULT {
                return @as(*const IInkPicture.VTable, @ptrCast(self.vtable)).put_EraserMode(@as(*const IInkPicture, @ptrCast(self)), EraserMode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkPicture_get_EraserWidth(self: *const T, EraserWidth: ?*i32) HRESULT {
                return @as(*const IInkPicture.VTable, @ptrCast(self.vtable)).get_EraserWidth(@as(*const IInkPicture, @ptrCast(self)), EraserWidth);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkPicture_put_EraserWidth(self: *const T, newEraserWidth: i32) HRESULT {
                return @as(*const IInkPicture.VTable, @ptrCast(self.vtable)).put_EraserWidth(@as(*const IInkPicture, @ptrCast(self)), newEraserWidth);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkPicture_putref_Picture(self: *const T, pPicture: ?*IPictureDisp) HRESULT {
                return @as(*const IInkPicture.VTable, @ptrCast(self.vtable)).putref_Picture(@as(*const IInkPicture, @ptrCast(self)), pPicture);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkPicture_put_Picture(self: *const T, pPicture: ?*IPictureDisp) HRESULT {
                return @as(*const IInkPicture.VTable, @ptrCast(self.vtable)).put_Picture(@as(*const IInkPicture, @ptrCast(self)), pPicture);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkPicture_get_Picture(self: *const T, ppPicture: ?*?*IPictureDisp) HRESULT {
                return @as(*const IInkPicture.VTable, @ptrCast(self.vtable)).get_Picture(@as(*const IInkPicture, @ptrCast(self)), ppPicture);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkPicture_put_SizeMode(self: *const T, smNewSizeMode: InkPictureSizeMode) HRESULT {
                return @as(*const IInkPicture.VTable, @ptrCast(self.vtable)).put_SizeMode(@as(*const IInkPicture, @ptrCast(self)), smNewSizeMode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkPicture_get_SizeMode(self: *const T, smSizeMode: ?*InkPictureSizeMode) HRESULT {
                return @as(*const IInkPicture.VTable, @ptrCast(self.vtable)).get_SizeMode(@as(*const IInkPicture, @ptrCast(self)), smSizeMode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkPicture_put_BackColor(self: *const T, newColor: u32) HRESULT {
                return @as(*const IInkPicture.VTable, @ptrCast(self.vtable)).put_BackColor(@as(*const IInkPicture, @ptrCast(self)), newColor);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkPicture_get_BackColor(self: *const T, pColor: ?*u32) HRESULT {
                return @as(*const IInkPicture.VTable, @ptrCast(self.vtable)).get_BackColor(@as(*const IInkPicture, @ptrCast(self)), pColor);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkPicture_get_Cursors(self: *const T, Cursors: ?*?*IInkCursors) HRESULT {
                return @as(*const IInkPicture.VTable, @ptrCast(self.vtable)).get_Cursors(@as(*const IInkPicture, @ptrCast(self)), Cursors);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkPicture_get_MarginX(self: *const T, MarginX: ?*i32) HRESULT {
                return @as(*const IInkPicture.VTable, @ptrCast(self.vtable)).get_MarginX(@as(*const IInkPicture, @ptrCast(self)), MarginX);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkPicture_put_MarginX(self: *const T, MarginX: i32) HRESULT {
                return @as(*const IInkPicture.VTable, @ptrCast(self.vtable)).put_MarginX(@as(*const IInkPicture, @ptrCast(self)), MarginX);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkPicture_get_MarginY(self: *const T, MarginY: ?*i32) HRESULT {
                return @as(*const IInkPicture.VTable, @ptrCast(self.vtable)).get_MarginY(@as(*const IInkPicture, @ptrCast(self)), MarginY);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkPicture_put_MarginY(self: *const T, MarginY: i32) HRESULT {
                return @as(*const IInkPicture.VTable, @ptrCast(self.vtable)).put_MarginY(@as(*const IInkPicture, @ptrCast(self)), MarginY);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkPicture_get_Tablet(self: *const T, SingleTablet: ?*?*IInkTablet) HRESULT {
                return @as(*const IInkPicture.VTable, @ptrCast(self.vtable)).get_Tablet(@as(*const IInkPicture, @ptrCast(self)), SingleTablet);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkPicture_get_SupportHighContrastInk(self: *const T, Support: ?*i16) HRESULT {
                return @as(*const IInkPicture.VTable, @ptrCast(self.vtable)).get_SupportHighContrastInk(@as(*const IInkPicture, @ptrCast(self)), Support);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkPicture_put_SupportHighContrastInk(self: *const T, Support: i16) HRESULT {
                return @as(*const IInkPicture.VTable, @ptrCast(self.vtable)).put_SupportHighContrastInk(@as(*const IInkPicture, @ptrCast(self)), Support);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkPicture_get_SupportHighContrastSelectionUI(self: *const T, Support: ?*i16) HRESULT {
                return @as(*const IInkPicture.VTable, @ptrCast(self.vtable)).get_SupportHighContrastSelectionUI(@as(*const IInkPicture, @ptrCast(self)), Support);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkPicture_put_SupportHighContrastSelectionUI(self: *const T, Support: i16) HRESULT {
                return @as(*const IInkPicture.VTable, @ptrCast(self.vtable)).put_SupportHighContrastSelectionUI(@as(*const IInkPicture, @ptrCast(self)), Support);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkPicture_HitTestSelection(self: *const T, x: i32, y: i32, SelArea: ?*SelectionHitResult) HRESULT {
                return @as(*const IInkPicture.VTable, @ptrCast(self.vtable)).HitTestSelection(@as(*const IInkPicture, @ptrCast(self)), x, y, SelArea);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkPicture_SetGestureStatus(self: *const T, Gesture: InkApplicationGesture, Listen: i16) HRESULT {
                return @as(*const IInkPicture.VTable, @ptrCast(self.vtable)).SetGestureStatus(@as(*const IInkPicture, @ptrCast(self)), Gesture, Listen);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkPicture_GetGestureStatus(self: *const T, Gesture: InkApplicationGesture, Listening: ?*i16) HRESULT {
                return @as(*const IInkPicture.VTable, @ptrCast(self.vtable)).GetGestureStatus(@as(*const IInkPicture, @ptrCast(self)), Gesture, Listening);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkPicture_GetWindowInputRectangle(self: *const T, WindowInputRectangle: ?*?*IInkRectangle) HRESULT {
                return @as(*const IInkPicture.VTable, @ptrCast(self.vtable)).GetWindowInputRectangle(@as(*const IInkPicture, @ptrCast(self)), WindowInputRectangle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkPicture_SetWindowInputRectangle(self: *const T, WindowInputRectangle: ?*IInkRectangle) HRESULT {
                return @as(*const IInkPicture.VTable, @ptrCast(self.vtable)).SetWindowInputRectangle(@as(*const IInkPicture, @ptrCast(self)), WindowInputRectangle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkPicture_SetAllTabletsMode(self: *const T, UseMouseForInput: i16) HRESULT {
                return @as(*const IInkPicture.VTable, @ptrCast(self.vtable)).SetAllTabletsMode(@as(*const IInkPicture, @ptrCast(self)), UseMouseForInput);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkPicture_SetSingleTabletIntegratedMode(self: *const T, Tablet: ?*IInkTablet) HRESULT {
                return @as(*const IInkPicture.VTable, @ptrCast(self.vtable)).SetSingleTabletIntegratedMode(@as(*const IInkPicture, @ptrCast(self)), Tablet);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkPicture_GetEventInterest(self: *const T, EventId: InkCollectorEventInterest, Listen: ?*i16) HRESULT {
                return @as(*const IInkPicture.VTable, @ptrCast(self.vtable)).GetEventInterest(@as(*const IInkPicture, @ptrCast(self)), EventId, Listen);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkPicture_SetEventInterest(self: *const T, EventId: InkCollectorEventInterest, Listen: i16) HRESULT {
                return @as(*const IInkPicture.VTable, @ptrCast(self.vtable)).SetEventInterest(@as(*const IInkPicture, @ptrCast(self)), EventId, Listen);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkPicture_get_InkEnabled(self: *const T, Collecting: ?*i16) HRESULT {
                return @as(*const IInkPicture.VTable, @ptrCast(self.vtable)).get_InkEnabled(@as(*const IInkPicture, @ptrCast(self)), Collecting);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkPicture_put_InkEnabled(self: *const T, Collecting: i16) HRESULT {
                return @as(*const IInkPicture.VTable, @ptrCast(self.vtable)).put_InkEnabled(@as(*const IInkPicture, @ptrCast(self)), Collecting);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkPicture_get_Enabled(self: *const T, pbool: ?*i16) HRESULT {
                return @as(*const IInkPicture.VTable, @ptrCast(self.vtable)).get_Enabled(@as(*const IInkPicture, @ptrCast(self)), pbool);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkPicture_put_Enabled(self: *const T, vbool: i16) HRESULT {
                return @as(*const IInkPicture.VTable, @ptrCast(self.vtable)).put_Enabled(@as(*const IInkPicture, @ptrCast(self)), vbool);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID__IInkPictureEvents_Value = Guid.initString("60ff4fee-22ff-4484-acc1-d308d9cd7ea3");
pub const IID__IInkPictureEvents = &IID__IInkPictureEvents_Value;
pub const _IInkPictureEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IInkRecognizer_Value = Guid.initString("782bf7cf-034b-4396-8a32-3a1833cf6b56");
pub const IID_IInkRecognizer = &IID_IInkRecognizer_Value;
pub const IInkRecognizer = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkRecognizer,
                Name: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkRecognizer,
                Name: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Vendor: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkRecognizer,
                Vendor: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkRecognizer,
                Vendor: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Capabilities: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkRecognizer,
                CapabilitiesFlags: ?*InkRecognizerCapabilities,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkRecognizer,
                CapabilitiesFlags: ?*InkRecognizerCapabilities,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Languages: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkRecognizer,
                Languages: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkRecognizer,
                Languages: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SupportedProperties: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkRecognizer,
                SupportedProperties: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkRecognizer,
                SupportedProperties: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PreferredPacketDescription: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkRecognizer,
                PreferredPacketDescription: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkRecognizer,
                PreferredPacketDescription: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateRecognizerContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkRecognizer,
                Context: ?*?*IInkRecognizerContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkRecognizer,
                Context: ?*?*IInkRecognizerContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRecognizer_get_Name(self: *const T, Name: ?*?BSTR) HRESULT {
                return @as(*const IInkRecognizer.VTable, @ptrCast(self.vtable)).get_Name(@as(*const IInkRecognizer, @ptrCast(self)), Name);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRecognizer_get_Vendor(self: *const T, Vendor: ?*?BSTR) HRESULT {
                return @as(*const IInkRecognizer.VTable, @ptrCast(self.vtable)).get_Vendor(@as(*const IInkRecognizer, @ptrCast(self)), Vendor);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRecognizer_get_Capabilities(self: *const T, CapabilitiesFlags: ?*InkRecognizerCapabilities) HRESULT {
                return @as(*const IInkRecognizer.VTable, @ptrCast(self.vtable)).get_Capabilities(@as(*const IInkRecognizer, @ptrCast(self)), CapabilitiesFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRecognizer_get_Languages(self: *const T, Languages: ?*VARIANT) HRESULT {
                return @as(*const IInkRecognizer.VTable, @ptrCast(self.vtable)).get_Languages(@as(*const IInkRecognizer, @ptrCast(self)), Languages);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRecognizer_get_SupportedProperties(self: *const T, SupportedProperties: ?*VARIANT) HRESULT {
                return @as(*const IInkRecognizer.VTable, @ptrCast(self.vtable)).get_SupportedProperties(@as(*const IInkRecognizer, @ptrCast(self)), SupportedProperties);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRecognizer_get_PreferredPacketDescription(self: *const T, PreferredPacketDescription: ?*VARIANT) HRESULT {
                return @as(*const IInkRecognizer.VTable, @ptrCast(self.vtable)).get_PreferredPacketDescription(@as(*const IInkRecognizer, @ptrCast(self)), PreferredPacketDescription);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRecognizer_CreateRecognizerContext(self: *const T, Context: ?*?*IInkRecognizerContext) HRESULT {
                return @as(*const IInkRecognizer.VTable, @ptrCast(self.vtable)).CreateRecognizerContext(@as(*const IInkRecognizer, @ptrCast(self)), Context);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IInkRecognizer2_Value = Guid.initString("6110118a-3a75-4ad6-b2aa-04b2b72bbe65");
pub const IID_IInkRecognizer2 = &IID_IInkRecognizer2_Value;
pub const IInkRecognizer2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Id: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkRecognizer2,
                pbstrId: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkRecognizer2,
                pbstrId: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UnicodeRanges: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkRecognizer2,
                UnicodeRanges: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkRecognizer2,
                UnicodeRanges: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRecognizer2_get_Id(self: *const T, pbstrId: ?*?BSTR) HRESULT {
                return @as(*const IInkRecognizer2.VTable, @ptrCast(self.vtable)).get_Id(@as(*const IInkRecognizer2, @ptrCast(self)), pbstrId);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRecognizer2_get_UnicodeRanges(self: *const T, UnicodeRanges: ?*VARIANT) HRESULT {
                return @as(*const IInkRecognizer2.VTable, @ptrCast(self.vtable)).get_UnicodeRanges(@as(*const IInkRecognizer2, @ptrCast(self)), UnicodeRanges);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IInkRecognizers_Value = Guid.initString("9ccc4f12-b0b7-4a8b-bf58-4aeca4e8cefd");
pub const IID_IInkRecognizers = &IID_IInkRecognizers_Value;
pub const IInkRecognizers = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkRecognizers,
                Count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkRecognizers,
                Count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkRecognizers,
                _NewEnum: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkRecognizers,
                _NewEnum: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDefaultRecognizer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkRecognizers,
                lcid: i32,
                DefaultRecognizer: ?*?*IInkRecognizer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkRecognizers,
                lcid: i32,
                DefaultRecognizer: ?*?*IInkRecognizer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Item: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkRecognizers,
                Index: i32,
                InkRecognizer: ?*?*IInkRecognizer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkRecognizers,
                Index: i32,
                InkRecognizer: ?*?*IInkRecognizer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRecognizers_get_Count(self: *const T, Count: ?*i32) HRESULT {
                return @as(*const IInkRecognizers.VTable, @ptrCast(self.vtable)).get_Count(@as(*const IInkRecognizers, @ptrCast(self)), Count);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRecognizers_get__NewEnum(self: *const T, _NewEnum: ?*?*IUnknown) HRESULT {
                return @as(*const IInkRecognizers.VTable, @ptrCast(self.vtable)).get__NewEnum(@as(*const IInkRecognizers, @ptrCast(self)), _NewEnum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRecognizers_GetDefaultRecognizer(self: *const T, lcid: i32, DefaultRecognizer: ?*?*IInkRecognizer) HRESULT {
                return @as(*const IInkRecognizers.VTable, @ptrCast(self.vtable)).GetDefaultRecognizer(@as(*const IInkRecognizers, @ptrCast(self)), lcid, DefaultRecognizer);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRecognizers_Item(self: *const T, Index: i32, InkRecognizer: ?*?*IInkRecognizer) HRESULT {
                return @as(*const IInkRecognizers.VTable, @ptrCast(self.vtable)).Item(@as(*const IInkRecognizers, @ptrCast(self)), Index, InkRecognizer);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID__IInkRecognitionEvents_Value = Guid.initString("17bce92f-2e21-47fd-9d33-3c6afbfd8c59");
pub const IID__IInkRecognitionEvents = &IID__IInkRecognitionEvents_Value;
pub const _IInkRecognitionEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IInkRecognizerContext_Value = Guid.initString("c68f52f9-32a3-4625-906c-44fc23b40958");
pub const IID_IInkRecognizerContext = &IID_IInkRecognizerContext_Value;
pub const IInkRecognizerContext = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Strokes: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkRecognizerContext,
                Strokes: ?*?*IInkStrokes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkRecognizerContext,
                Strokes: ?*?*IInkStrokes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        putref_Strokes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkRecognizerContext,
                Strokes: ?*IInkStrokes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkRecognizerContext,
                Strokes: ?*IInkStrokes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CharacterAutoCompletionMode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkRecognizerContext,
                Mode: ?*InkRecognizerCharacterAutoCompletionMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkRecognizerContext,
                Mode: ?*InkRecognizerCharacterAutoCompletionMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_CharacterAutoCompletionMode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkRecognizerContext,
                Mode: InkRecognizerCharacterAutoCompletionMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkRecognizerContext,
                Mode: InkRecognizerCharacterAutoCompletionMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Factoid: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkRecognizerContext,
                Factoid: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkRecognizerContext,
                Factoid: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Factoid: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkRecognizerContext,
                factoid: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkRecognizerContext,
                factoid: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Guide: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkRecognizerContext,
                RecognizerGuide: ?*?*IInkRecognizerGuide,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkRecognizerContext,
                RecognizerGuide: ?*?*IInkRecognizerGuide,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        putref_Guide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkRecognizerContext,
                RecognizerGuide: ?*IInkRecognizerGuide,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkRecognizerContext,
                RecognizerGuide: ?*IInkRecognizerGuide,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PrefixText: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkRecognizerContext,
                Prefix: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkRecognizerContext,
                Prefix: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_PrefixText: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkRecognizerContext,
                Prefix: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkRecognizerContext,
                Prefix: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SuffixText: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkRecognizerContext,
                Suffix: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkRecognizerContext,
                Suffix: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SuffixText: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkRecognizerContext,
                Suffix: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkRecognizerContext,
                Suffix: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RecognitionFlags: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkRecognizerContext,
                Modes: ?*InkRecognitionModes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkRecognizerContext,
                Modes: ?*InkRecognitionModes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_RecognitionFlags: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkRecognizerContext,
                Modes: InkRecognitionModes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkRecognizerContext,
                Modes: InkRecognitionModes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_WordList: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkRecognizerContext,
                WordList: ?*?*IInkWordList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkRecognizerContext,
                WordList: ?*?*IInkWordList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        putref_WordList: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkRecognizerContext,
                WordList: ?*IInkWordList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkRecognizerContext,
                WordList: ?*IInkWordList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Recognizer: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkRecognizerContext,
                Recognizer: ?*?*IInkRecognizer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkRecognizerContext,
                Recognizer: ?*?*IInkRecognizer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Recognize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkRecognizerContext,
                RecognitionStatus: ?*InkRecognitionStatus,
                RecognitionResult: ?*?*IInkRecognitionResult,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkRecognizerContext,
                RecognitionStatus: ?*InkRecognitionStatus,
                RecognitionResult: ?*?*IInkRecognitionResult,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StopBackgroundRecognition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkRecognizerContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkRecognizerContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndInkInput: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkRecognizerContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkRecognizerContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BackgroundRecognize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkRecognizerContext,
                CustomData: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkRecognizerContext,
                CustomData: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BackgroundRecognizeWithAlternates: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkRecognizerContext,
                CustomData: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkRecognizerContext,
                CustomData: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkRecognizerContext,
                RecoContext: ?*?*IInkRecognizerContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkRecognizerContext,
                RecoContext: ?*?*IInkRecognizerContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsStringSupported: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkRecognizerContext,
                String: ?BSTR,
                Supported: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkRecognizerContext,
                String: ?BSTR,
                Supported: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRecognizerContext_get_Strokes(self: *const T, Strokes: ?*?*IInkStrokes) HRESULT {
                return @as(*const IInkRecognizerContext.VTable, @ptrCast(self.vtable)).get_Strokes(@as(*const IInkRecognizerContext, @ptrCast(self)), Strokes);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRecognizerContext_putref_Strokes(self: *const T, Strokes: ?*IInkStrokes) HRESULT {
                return @as(*const IInkRecognizerContext.VTable, @ptrCast(self.vtable)).putref_Strokes(@as(*const IInkRecognizerContext, @ptrCast(self)), Strokes);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRecognizerContext_get_CharacterAutoCompletionMode(self: *const T, Mode: ?*InkRecognizerCharacterAutoCompletionMode) HRESULT {
                return @as(*const IInkRecognizerContext.VTable, @ptrCast(self.vtable)).get_CharacterAutoCompletionMode(@as(*const IInkRecognizerContext, @ptrCast(self)), Mode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRecognizerContext_put_CharacterAutoCompletionMode(self: *const T, Mode: InkRecognizerCharacterAutoCompletionMode) HRESULT {
                return @as(*const IInkRecognizerContext.VTable, @ptrCast(self.vtable)).put_CharacterAutoCompletionMode(@as(*const IInkRecognizerContext, @ptrCast(self)), Mode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRecognizerContext_get_Factoid(self: *const T, Factoid: ?*?BSTR) HRESULT {
                return @as(*const IInkRecognizerContext.VTable, @ptrCast(self.vtable)).get_Factoid(@as(*const IInkRecognizerContext, @ptrCast(self)), Factoid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRecognizerContext_put_Factoid(self: *const T, factoid: ?BSTR) HRESULT {
                return @as(*const IInkRecognizerContext.VTable, @ptrCast(self.vtable)).put_Factoid(@as(*const IInkRecognizerContext, @ptrCast(self)), factoid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRecognizerContext_get_Guide(self: *const T, RecognizerGuide: ?*?*IInkRecognizerGuide) HRESULT {
                return @as(*const IInkRecognizerContext.VTable, @ptrCast(self.vtable)).get_Guide(@as(*const IInkRecognizerContext, @ptrCast(self)), RecognizerGuide);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRecognizerContext_putref_Guide(self: *const T, RecognizerGuide: ?*IInkRecognizerGuide) HRESULT {
                return @as(*const IInkRecognizerContext.VTable, @ptrCast(self.vtable)).putref_Guide(@as(*const IInkRecognizerContext, @ptrCast(self)), RecognizerGuide);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRecognizerContext_get_PrefixText(self: *const T, Prefix: ?*?BSTR) HRESULT {
                return @as(*const IInkRecognizerContext.VTable, @ptrCast(self.vtable)).get_PrefixText(@as(*const IInkRecognizerContext, @ptrCast(self)), Prefix);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRecognizerContext_put_PrefixText(self: *const T, Prefix: ?BSTR) HRESULT {
                return @as(*const IInkRecognizerContext.VTable, @ptrCast(self.vtable)).put_PrefixText(@as(*const IInkRecognizerContext, @ptrCast(self)), Prefix);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRecognizerContext_get_SuffixText(self: *const T, Suffix: ?*?BSTR) HRESULT {
                return @as(*const IInkRecognizerContext.VTable, @ptrCast(self.vtable)).get_SuffixText(@as(*const IInkRecognizerContext, @ptrCast(self)), Suffix);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRecognizerContext_put_SuffixText(self: *const T, Suffix: ?BSTR) HRESULT {
                return @as(*const IInkRecognizerContext.VTable, @ptrCast(self.vtable)).put_SuffixText(@as(*const IInkRecognizerContext, @ptrCast(self)), Suffix);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRecognizerContext_get_RecognitionFlags(self: *const T, Modes: ?*InkRecognitionModes) HRESULT {
                return @as(*const IInkRecognizerContext.VTable, @ptrCast(self.vtable)).get_RecognitionFlags(@as(*const IInkRecognizerContext, @ptrCast(self)), Modes);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRecognizerContext_put_RecognitionFlags(self: *const T, Modes: InkRecognitionModes) HRESULT {
                return @as(*const IInkRecognizerContext.VTable, @ptrCast(self.vtable)).put_RecognitionFlags(@as(*const IInkRecognizerContext, @ptrCast(self)), Modes);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRecognizerContext_get_WordList(self: *const T, WordList: ?*?*IInkWordList) HRESULT {
                return @as(*const IInkRecognizerContext.VTable, @ptrCast(self.vtable)).get_WordList(@as(*const IInkRecognizerContext, @ptrCast(self)), WordList);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRecognizerContext_putref_WordList(self: *const T, WordList: ?*IInkWordList) HRESULT {
                return @as(*const IInkRecognizerContext.VTable, @ptrCast(self.vtable)).putref_WordList(@as(*const IInkRecognizerContext, @ptrCast(self)), WordList);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRecognizerContext_get_Recognizer(self: *const T, Recognizer: ?*?*IInkRecognizer) HRESULT {
                return @as(*const IInkRecognizerContext.VTable, @ptrCast(self.vtable)).get_Recognizer(@as(*const IInkRecognizerContext, @ptrCast(self)), Recognizer);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRecognizerContext_Recognize(self: *const T, RecognitionStatus: ?*InkRecognitionStatus, RecognitionResult: ?*?*IInkRecognitionResult) HRESULT {
                return @as(*const IInkRecognizerContext.VTable, @ptrCast(self.vtable)).Recognize(@as(*const IInkRecognizerContext, @ptrCast(self)), RecognitionStatus, RecognitionResult);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRecognizerContext_StopBackgroundRecognition(self: *const T) HRESULT {
                return @as(*const IInkRecognizerContext.VTable, @ptrCast(self.vtable)).StopBackgroundRecognition(@as(*const IInkRecognizerContext, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRecognizerContext_EndInkInput(self: *const T) HRESULT {
                return @as(*const IInkRecognizerContext.VTable, @ptrCast(self.vtable)).EndInkInput(@as(*const IInkRecognizerContext, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRecognizerContext_BackgroundRecognize(self: *const T, CustomData: VARIANT) HRESULT {
                return @as(*const IInkRecognizerContext.VTable, @ptrCast(self.vtable)).BackgroundRecognize(@as(*const IInkRecognizerContext, @ptrCast(self)), CustomData);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRecognizerContext_BackgroundRecognizeWithAlternates(self: *const T, CustomData: VARIANT) HRESULT {
                return @as(*const IInkRecognizerContext.VTable, @ptrCast(self.vtable)).BackgroundRecognizeWithAlternates(@as(*const IInkRecognizerContext, @ptrCast(self)), CustomData);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRecognizerContext_Clone(self: *const T, RecoContext: ?*?*IInkRecognizerContext) HRESULT {
                return @as(*const IInkRecognizerContext.VTable, @ptrCast(self.vtable)).Clone(@as(*const IInkRecognizerContext, @ptrCast(self)), RecoContext);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRecognizerContext_IsStringSupported(self: *const T, String: ?BSTR, Supported: ?*i16) HRESULT {
                return @as(*const IInkRecognizerContext.VTable, @ptrCast(self.vtable)).IsStringSupported(@as(*const IInkRecognizerContext, @ptrCast(self)), String, Supported);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IInkRecognizerContext2_Value = Guid.initString("d6f0e32f-73d8-408e-8e9f-5fea592c363f");
pub const IID_IInkRecognizerContext2 = &IID_IInkRecognizerContext2_Value;
pub const IInkRecognizerContext2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EnabledUnicodeRanges: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkRecognizerContext2,
                UnicodeRanges: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkRecognizerContext2,
                UnicodeRanges: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_EnabledUnicodeRanges: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkRecognizerContext2,
                UnicodeRanges: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkRecognizerContext2,
                UnicodeRanges: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRecognizerContext2_get_EnabledUnicodeRanges(self: *const T, UnicodeRanges: ?*VARIANT) HRESULT {
                return @as(*const IInkRecognizerContext2.VTable, @ptrCast(self.vtable)).get_EnabledUnicodeRanges(@as(*const IInkRecognizerContext2, @ptrCast(self)), UnicodeRanges);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRecognizerContext2_put_EnabledUnicodeRanges(self: *const T, UnicodeRanges: VARIANT) HRESULT {
                return @as(*const IInkRecognizerContext2.VTable, @ptrCast(self.vtable)).put_EnabledUnicodeRanges(@as(*const IInkRecognizerContext2, @ptrCast(self)), UnicodeRanges);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IInkRecognitionResult_Value = Guid.initString("3bc129a8-86cd-45ad-bde8-e0d32d61c16d");
pub const IID_IInkRecognitionResult = &IID_IInkRecognitionResult_Value;
pub const IInkRecognitionResult = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TopString: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkRecognitionResult,
                TopString: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkRecognitionResult,
                TopString: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TopAlternate: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkRecognitionResult,
                TopAlternate: ?*?*IInkRecognitionAlternate,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkRecognitionResult,
                TopAlternate: ?*?*IInkRecognitionAlternate,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TopConfidence: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkRecognitionResult,
                TopConfidence: ?*InkRecognitionConfidence,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkRecognitionResult,
                TopConfidence: ?*InkRecognitionConfidence,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Strokes: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkRecognitionResult,
                Strokes: ?*?*IInkStrokes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkRecognitionResult,
                Strokes: ?*?*IInkStrokes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AlternatesFromSelection: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkRecognitionResult,
                selectionStart: i32,
                selectionLength: i32,
                maximumAlternates: i32,
                AlternatesFromSelection: ?*?*IInkRecognitionAlternates,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkRecognitionResult,
                selectionStart: i32,
                selectionLength: i32,
                maximumAlternates: i32,
                AlternatesFromSelection: ?*?*IInkRecognitionAlternates,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ModifyTopAlternate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkRecognitionResult,
                Alternate: ?*IInkRecognitionAlternate,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkRecognitionResult,
                Alternate: ?*IInkRecognitionAlternate,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetResultOnStrokes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkRecognitionResult,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkRecognitionResult,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRecognitionResult_get_TopString(self: *const T, TopString: ?*?BSTR) HRESULT {
                return @as(*const IInkRecognitionResult.VTable, @ptrCast(self.vtable)).get_TopString(@as(*const IInkRecognitionResult, @ptrCast(self)), TopString);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRecognitionResult_get_TopAlternate(self: *const T, TopAlternate: ?*?*IInkRecognitionAlternate) HRESULT {
                return @as(*const IInkRecognitionResult.VTable, @ptrCast(self.vtable)).get_TopAlternate(@as(*const IInkRecognitionResult, @ptrCast(self)), TopAlternate);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRecognitionResult_get_TopConfidence(self: *const T, TopConfidence: ?*InkRecognitionConfidence) HRESULT {
                return @as(*const IInkRecognitionResult.VTable, @ptrCast(self.vtable)).get_TopConfidence(@as(*const IInkRecognitionResult, @ptrCast(self)), TopConfidence);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRecognitionResult_get_Strokes(self: *const T, Strokes: ?*?*IInkStrokes) HRESULT {
                return @as(*const IInkRecognitionResult.VTable, @ptrCast(self.vtable)).get_Strokes(@as(*const IInkRecognitionResult, @ptrCast(self)), Strokes);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRecognitionResult_AlternatesFromSelection(self: *const T, selectionStart: i32, selectionLength: i32, maximumAlternates: i32, AlternatesFromSelection: ?*?*IInkRecognitionAlternates) HRESULT {
                return @as(*const IInkRecognitionResult.VTable, @ptrCast(self.vtable)).AlternatesFromSelection(@as(*const IInkRecognitionResult, @ptrCast(self)), selectionStart, selectionLength, maximumAlternates, AlternatesFromSelection);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRecognitionResult_ModifyTopAlternate(self: *const T, Alternate: ?*IInkRecognitionAlternate) HRESULT {
                return @as(*const IInkRecognitionResult.VTable, @ptrCast(self.vtable)).ModifyTopAlternate(@as(*const IInkRecognitionResult, @ptrCast(self)), Alternate);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRecognitionResult_SetResultOnStrokes(self: *const T) HRESULT {
                return @as(*const IInkRecognitionResult.VTable, @ptrCast(self.vtable)).SetResultOnStrokes(@as(*const IInkRecognitionResult, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IInkRecognitionAlternate_Value = Guid.initString("b7e660ad-77e4-429b-adda-873780d1fc4a");
pub const IID_IInkRecognitionAlternate = &IID_IInkRecognitionAlternate_Value;
pub const IInkRecognitionAlternate = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_String: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkRecognitionAlternate,
                RecoString: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkRecognitionAlternate,
                RecoString: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Confidence: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkRecognitionAlternate,
                Confidence: ?*InkRecognitionConfidence,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkRecognitionAlternate,
                Confidence: ?*InkRecognitionConfidence,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Baseline: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkRecognitionAlternate,
                Baseline: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkRecognitionAlternate,
                Baseline: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Midline: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkRecognitionAlternate,
                Midline: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkRecognitionAlternate,
                Midline: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Ascender: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkRecognitionAlternate,
                Ascender: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkRecognitionAlternate,
                Ascender: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Descender: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkRecognitionAlternate,
                Descender: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkRecognitionAlternate,
                Descender: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LineNumber: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkRecognitionAlternate,
                LineNumber: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkRecognitionAlternate,
                LineNumber: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Strokes: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkRecognitionAlternate,
                Strokes: ?*?*IInkStrokes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkRecognitionAlternate,
                Strokes: ?*?*IInkStrokes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LineAlternates: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkRecognitionAlternate,
                LineAlternates: ?*?*IInkRecognitionAlternates,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkRecognitionAlternate,
                LineAlternates: ?*?*IInkRecognitionAlternates,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ConfidenceAlternates: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkRecognitionAlternate,
                ConfidenceAlternates: ?*?*IInkRecognitionAlternates,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkRecognitionAlternate,
                ConfidenceAlternates: ?*?*IInkRecognitionAlternates,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStrokesFromStrokeRanges: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkRecognitionAlternate,
                Strokes: ?*IInkStrokes,
                GetStrokesFromStrokeRanges: ?*?*IInkStrokes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkRecognitionAlternate,
                Strokes: ?*IInkStrokes,
                GetStrokesFromStrokeRanges: ?*?*IInkStrokes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStrokesFromTextRange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkRecognitionAlternate,
                selectionStart: ?*i32,
                selectionLength: ?*i32,
                GetStrokesFromTextRange: ?*?*IInkStrokes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkRecognitionAlternate,
                selectionStart: ?*i32,
                selectionLength: ?*i32,
                GetStrokesFromTextRange: ?*?*IInkStrokes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTextRangeFromStrokes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkRecognitionAlternate,
                Strokes: ?*IInkStrokes,
                selectionStart: ?*i32,
                selectionLength: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkRecognitionAlternate,
                Strokes: ?*IInkStrokes,
                selectionStart: ?*i32,
                selectionLength: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AlternatesWithConstantPropertyValues: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkRecognitionAlternate,
                PropertyType: ?BSTR,
                AlternatesWithConstantPropertyValues: ?*?*IInkRecognitionAlternates,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkRecognitionAlternate,
                PropertyType: ?BSTR,
                AlternatesWithConstantPropertyValues: ?*?*IInkRecognitionAlternates,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPropertyValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkRecognitionAlternate,
                PropertyType: ?BSTR,
                PropertyValue: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkRecognitionAlternate,
                PropertyType: ?BSTR,
                PropertyValue: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRecognitionAlternate_get_String(self: *const T, RecoString: ?*?BSTR) HRESULT {
                return @as(*const IInkRecognitionAlternate.VTable, @ptrCast(self.vtable)).get_String(@as(*const IInkRecognitionAlternate, @ptrCast(self)), RecoString);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRecognitionAlternate_get_Confidence(self: *const T, Confidence: ?*InkRecognitionConfidence) HRESULT {
                return @as(*const IInkRecognitionAlternate.VTable, @ptrCast(self.vtable)).get_Confidence(@as(*const IInkRecognitionAlternate, @ptrCast(self)), Confidence);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRecognitionAlternate_get_Baseline(self: *const T, Baseline: ?*VARIANT) HRESULT {
                return @as(*const IInkRecognitionAlternate.VTable, @ptrCast(self.vtable)).get_Baseline(@as(*const IInkRecognitionAlternate, @ptrCast(self)), Baseline);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRecognitionAlternate_get_Midline(self: *const T, Midline: ?*VARIANT) HRESULT {
                return @as(*const IInkRecognitionAlternate.VTable, @ptrCast(self.vtable)).get_Midline(@as(*const IInkRecognitionAlternate, @ptrCast(self)), Midline);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRecognitionAlternate_get_Ascender(self: *const T, Ascender: ?*VARIANT) HRESULT {
                return @as(*const IInkRecognitionAlternate.VTable, @ptrCast(self.vtable)).get_Ascender(@as(*const IInkRecognitionAlternate, @ptrCast(self)), Ascender);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRecognitionAlternate_get_Descender(self: *const T, Descender: ?*VARIANT) HRESULT {
                return @as(*const IInkRecognitionAlternate.VTable, @ptrCast(self.vtable)).get_Descender(@as(*const IInkRecognitionAlternate, @ptrCast(self)), Descender);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRecognitionAlternate_get_LineNumber(self: *const T, LineNumber: ?*i32) HRESULT {
                return @as(*const IInkRecognitionAlternate.VTable, @ptrCast(self.vtable)).get_LineNumber(@as(*const IInkRecognitionAlternate, @ptrCast(self)), LineNumber);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRecognitionAlternate_get_Strokes(self: *const T, Strokes: ?*?*IInkStrokes) HRESULT {
                return @as(*const IInkRecognitionAlternate.VTable, @ptrCast(self.vtable)).get_Strokes(@as(*const IInkRecognitionAlternate, @ptrCast(self)), Strokes);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRecognitionAlternate_get_LineAlternates(self: *const T, LineAlternates: ?*?*IInkRecognitionAlternates) HRESULT {
                return @as(*const IInkRecognitionAlternate.VTable, @ptrCast(self.vtable)).get_LineAlternates(@as(*const IInkRecognitionAlternate, @ptrCast(self)), LineAlternates);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRecognitionAlternate_get_ConfidenceAlternates(self: *const T, ConfidenceAlternates: ?*?*IInkRecognitionAlternates) HRESULT {
                return @as(*const IInkRecognitionAlternate.VTable, @ptrCast(self.vtable)).get_ConfidenceAlternates(@as(*const IInkRecognitionAlternate, @ptrCast(self)), ConfidenceAlternates);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRecognitionAlternate_GetStrokesFromStrokeRanges(self: *const T, Strokes: ?*IInkStrokes, GetStrokesFromStrokeRanges: ?*?*IInkStrokes) HRESULT {
                return @as(*const IInkRecognitionAlternate.VTable, @ptrCast(self.vtable)).GetStrokesFromStrokeRanges(@as(*const IInkRecognitionAlternate, @ptrCast(self)), Strokes, GetStrokesFromStrokeRanges);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRecognitionAlternate_GetStrokesFromTextRange(self: *const T, selectionStart: ?*i32, selectionLength: ?*i32, GetStrokesFromTextRange: ?*?*IInkStrokes) HRESULT {
                return @as(*const IInkRecognitionAlternate.VTable, @ptrCast(self.vtable)).GetStrokesFromTextRange(@as(*const IInkRecognitionAlternate, @ptrCast(self)), selectionStart, selectionLength, GetStrokesFromTextRange);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRecognitionAlternate_GetTextRangeFromStrokes(self: *const T, Strokes: ?*IInkStrokes, selectionStart: ?*i32, selectionLength: ?*i32) HRESULT {
                return @as(*const IInkRecognitionAlternate.VTable, @ptrCast(self.vtable)).GetTextRangeFromStrokes(@as(*const IInkRecognitionAlternate, @ptrCast(self)), Strokes, selectionStart, selectionLength);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRecognitionAlternate_AlternatesWithConstantPropertyValues(self: *const T, PropertyType: ?BSTR, AlternatesWithConstantPropertyValues: ?*?*IInkRecognitionAlternates) HRESULT {
                return @as(*const IInkRecognitionAlternate.VTable, @ptrCast(self.vtable)).AlternatesWithConstantPropertyValues(@as(*const IInkRecognitionAlternate, @ptrCast(self)), PropertyType, AlternatesWithConstantPropertyValues);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRecognitionAlternate_GetPropertyValue(self: *const T, PropertyType: ?BSTR, PropertyValue: ?*VARIANT) HRESULT {
                return @as(*const IInkRecognitionAlternate.VTable, @ptrCast(self.vtable)).GetPropertyValue(@as(*const IInkRecognitionAlternate, @ptrCast(self)), PropertyType, PropertyValue);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IInkRecognitionAlternates_Value = Guid.initString("286a167f-9f19-4c61-9d53-4f07be622b84");
pub const IID_IInkRecognitionAlternates = &IID_IInkRecognitionAlternates_Value;
pub const IInkRecognitionAlternates = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkRecognitionAlternates,
                Count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkRecognitionAlternates,
                Count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkRecognitionAlternates,
                _NewEnum: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkRecognitionAlternates,
                _NewEnum: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Strokes: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkRecognitionAlternates,
                Strokes: ?*?*IInkStrokes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkRecognitionAlternates,
                Strokes: ?*?*IInkStrokes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Item: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkRecognitionAlternates,
                Index: i32,
                InkRecoAlternate: ?*?*IInkRecognitionAlternate,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkRecognitionAlternates,
                Index: i32,
                InkRecoAlternate: ?*?*IInkRecognitionAlternate,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRecognitionAlternates_get_Count(self: *const T, Count: ?*i32) HRESULT {
                return @as(*const IInkRecognitionAlternates.VTable, @ptrCast(self.vtable)).get_Count(@as(*const IInkRecognitionAlternates, @ptrCast(self)), Count);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRecognitionAlternates_get__NewEnum(self: *const T, _NewEnum: ?*?*IUnknown) HRESULT {
                return @as(*const IInkRecognitionAlternates.VTable, @ptrCast(self.vtable)).get__NewEnum(@as(*const IInkRecognitionAlternates, @ptrCast(self)), _NewEnum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRecognitionAlternates_get_Strokes(self: *const T, Strokes: ?*?*IInkStrokes) HRESULT {
                return @as(*const IInkRecognitionAlternates.VTable, @ptrCast(self.vtable)).get_Strokes(@as(*const IInkRecognitionAlternates, @ptrCast(self)), Strokes);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRecognitionAlternates_Item(self: *const T, Index: i32, InkRecoAlternate: ?*?*IInkRecognitionAlternate) HRESULT {
                return @as(*const IInkRecognitionAlternates.VTable, @ptrCast(self.vtable)).Item(@as(*const IInkRecognitionAlternates, @ptrCast(self)), Index, InkRecoAlternate);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IInkRecognizerGuide_Value = Guid.initString("d934be07-7b84-4208-9136-83c20994e905");
pub const IID_IInkRecognizerGuide = &IID_IInkRecognizerGuide_Value;
pub const IInkRecognizerGuide = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_WritingBox: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkRecognizerGuide,
                Rectangle: ?*?*IInkRectangle,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkRecognizerGuide,
                Rectangle: ?*?*IInkRectangle,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_WritingBox: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkRecognizerGuide,
                Rectangle: ?*IInkRectangle,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkRecognizerGuide,
                Rectangle: ?*IInkRectangle,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DrawnBox: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkRecognizerGuide,
                Rectangle: ?*?*IInkRectangle,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkRecognizerGuide,
                Rectangle: ?*?*IInkRectangle,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DrawnBox: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkRecognizerGuide,
                Rectangle: ?*IInkRectangle,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkRecognizerGuide,
                Rectangle: ?*IInkRectangle,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Rows: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkRecognizerGuide,
                Units: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkRecognizerGuide,
                Units: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Rows: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkRecognizerGuide,
                Units: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkRecognizerGuide,
                Units: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Columns: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkRecognizerGuide,
                Units: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkRecognizerGuide,
                Units: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Columns: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkRecognizerGuide,
                Units: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkRecognizerGuide,
                Units: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Midline: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkRecognizerGuide,
                Units: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkRecognizerGuide,
                Units: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Midline: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkRecognizerGuide,
                Units: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkRecognizerGuide,
                Units: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_GuideData: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkRecognizerGuide,
                pRecoGuide: ?*InkRecoGuide,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkRecognizerGuide,
                pRecoGuide: ?*InkRecoGuide,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_GuideData: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkRecognizerGuide,
                recoGuide: InkRecoGuide,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkRecognizerGuide,
                recoGuide: InkRecoGuide,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRecognizerGuide_get_WritingBox(self: *const T, Rectangle: ?*?*IInkRectangle) HRESULT {
                return @as(*const IInkRecognizerGuide.VTable, @ptrCast(self.vtable)).get_WritingBox(@as(*const IInkRecognizerGuide, @ptrCast(self)), Rectangle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRecognizerGuide_put_WritingBox(self: *const T, Rectangle: ?*IInkRectangle) HRESULT {
                return @as(*const IInkRecognizerGuide.VTable, @ptrCast(self.vtable)).put_WritingBox(@as(*const IInkRecognizerGuide, @ptrCast(self)), Rectangle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRecognizerGuide_get_DrawnBox(self: *const T, Rectangle: ?*?*IInkRectangle) HRESULT {
                return @as(*const IInkRecognizerGuide.VTable, @ptrCast(self.vtable)).get_DrawnBox(@as(*const IInkRecognizerGuide, @ptrCast(self)), Rectangle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRecognizerGuide_put_DrawnBox(self: *const T, Rectangle: ?*IInkRectangle) HRESULT {
                return @as(*const IInkRecognizerGuide.VTable, @ptrCast(self.vtable)).put_DrawnBox(@as(*const IInkRecognizerGuide, @ptrCast(self)), Rectangle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRecognizerGuide_get_Rows(self: *const T, Units: ?*i32) HRESULT {
                return @as(*const IInkRecognizerGuide.VTable, @ptrCast(self.vtable)).get_Rows(@as(*const IInkRecognizerGuide, @ptrCast(self)), Units);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRecognizerGuide_put_Rows(self: *const T, Units: i32) HRESULT {
                return @as(*const IInkRecognizerGuide.VTable, @ptrCast(self.vtable)).put_Rows(@as(*const IInkRecognizerGuide, @ptrCast(self)), Units);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRecognizerGuide_get_Columns(self: *const T, Units: ?*i32) HRESULT {
                return @as(*const IInkRecognizerGuide.VTable, @ptrCast(self.vtable)).get_Columns(@as(*const IInkRecognizerGuide, @ptrCast(self)), Units);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRecognizerGuide_put_Columns(self: *const T, Units: i32) HRESULT {
                return @as(*const IInkRecognizerGuide.VTable, @ptrCast(self.vtable)).put_Columns(@as(*const IInkRecognizerGuide, @ptrCast(self)), Units);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRecognizerGuide_get_Midline(self: *const T, Units: ?*i32) HRESULT {
                return @as(*const IInkRecognizerGuide.VTable, @ptrCast(self.vtable)).get_Midline(@as(*const IInkRecognizerGuide, @ptrCast(self)), Units);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRecognizerGuide_put_Midline(self: *const T, Units: i32) HRESULT {
                return @as(*const IInkRecognizerGuide.VTable, @ptrCast(self.vtable)).put_Midline(@as(*const IInkRecognizerGuide, @ptrCast(self)), Units);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRecognizerGuide_get_GuideData(self: *const T, pRecoGuide: ?*InkRecoGuide) HRESULT {
                return @as(*const IInkRecognizerGuide.VTable, @ptrCast(self.vtable)).get_GuideData(@as(*const IInkRecognizerGuide, @ptrCast(self)), pRecoGuide);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkRecognizerGuide_put_GuideData(self: *const T, recoGuide: InkRecoGuide) HRESULT {
                return @as(*const IInkRecognizerGuide.VTable, @ptrCast(self.vtable)).put_GuideData(@as(*const IInkRecognizerGuide, @ptrCast(self)), recoGuide);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IInkWordList_Value = Guid.initString("76ba3491-cb2f-406b-9961-0e0c4cdaaef2");
pub const IID_IInkWordList = &IID_IInkWordList_Value;
pub const IInkWordList = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        AddWord: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkWordList,
                NewWord: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkWordList,
                NewWord: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveWord: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkWordList,
                RemoveWord: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkWordList,
                RemoveWord: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Merge: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkWordList,
                MergeWordList: ?*IInkWordList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkWordList,
                MergeWordList: ?*IInkWordList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkWordList_AddWord(self: *const T, NewWord: ?BSTR) HRESULT {
                return @as(*const IInkWordList.VTable, @ptrCast(self.vtable)).AddWord(@as(*const IInkWordList, @ptrCast(self)), NewWord);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkWordList_RemoveWord(self: *const T, RemoveWord: ?BSTR) HRESULT {
                return @as(*const IInkWordList.VTable, @ptrCast(self.vtable)).RemoveWord(@as(*const IInkWordList, @ptrCast(self)), RemoveWord);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkWordList_Merge(self: *const T, MergeWordList: ?*IInkWordList) HRESULT {
                return @as(*const IInkWordList.VTable, @ptrCast(self.vtable)).Merge(@as(*const IInkWordList, @ptrCast(self)), MergeWordList);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IInkWordList2_Value = Guid.initString("14542586-11bf-4f5f-b6e7-49d0744aab6e");
pub const IID_IInkWordList2 = &IID_IInkWordList2_Value;
pub const IInkWordList2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        AddWords: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkWordList2,
                NewWords: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkWordList2,
                NewWords: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkWordList2_AddWords(self: *const T, NewWords: ?BSTR) HRESULT {
                return @as(*const IInkWordList2.VTable, @ptrCast(self.vtable)).AddWords(@as(*const IInkWordList2, @ptrCast(self)), NewWords);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IInk_Value = Guid.initString("03f8e511-43a1-11d3-8bb6-0080c7d6bad5");
pub const IID_IInk = &IID_IInk_Value;
pub const IInk = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IInkLineInfo_Value = Guid.initString("9c1c5ad6-f22f-4de4-b453-a2cc482e7c33");
pub const IID_IInkLineInfo = &IID_IInkLineInfo_Value;
pub const IInkLineInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetFormat: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkLineInfo,
                pim: ?*INKMETRIC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkLineInfo,
                pim: ?*INKMETRIC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFormat: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkLineInfo,
                pim: ?*INKMETRIC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkLineInfo,
                pim: ?*INKMETRIC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInkExtent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkLineInfo,
                pim: ?*INKMETRIC,
                pnWidth: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkLineInfo,
                pim: ?*INKMETRIC,
                pnWidth: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCandidate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkLineInfo,
                nCandidateNum: u32,
                pwcRecogWord: ?PWSTR,
                pcwcRecogWord: ?*u32,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkLineInfo,
                nCandidateNum: u32,
                pwcRecogWord: ?PWSTR,
                pcwcRecogWord: ?*u32,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCandidate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkLineInfo,
                nCandidateNum: u32,
                strRecogWord: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkLineInfo,
                nCandidateNum: u32,
                strRecogWord: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Recognize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkLineInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkLineInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkLineInfo_SetFormat(self: *const T, pim: ?*INKMETRIC) HRESULT {
                return @as(*const IInkLineInfo.VTable, @ptrCast(self.vtable)).SetFormat(@as(*const IInkLineInfo, @ptrCast(self)), pim);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkLineInfo_GetFormat(self: *const T, pim: ?*INKMETRIC) HRESULT {
                return @as(*const IInkLineInfo.VTable, @ptrCast(self.vtable)).GetFormat(@as(*const IInkLineInfo, @ptrCast(self)), pim);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkLineInfo_GetInkExtent(self: *const T, pim: ?*INKMETRIC, pnWidth: ?*u32) HRESULT {
                return @as(*const IInkLineInfo.VTable, @ptrCast(self.vtable)).GetInkExtent(@as(*const IInkLineInfo, @ptrCast(self)), pim, pnWidth);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkLineInfo_GetCandidate(self: *const T, nCandidateNum: u32, pwcRecogWord: ?PWSTR, pcwcRecogWord: ?*u32, dwFlags: u32) HRESULT {
                return @as(*const IInkLineInfo.VTable, @ptrCast(self.vtable)).GetCandidate(@as(*const IInkLineInfo, @ptrCast(self)), nCandidateNum, pwcRecogWord, pcwcRecogWord, dwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkLineInfo_SetCandidate(self: *const T, nCandidateNum: u32, strRecogWord: ?PWSTR) HRESULT {
                return @as(*const IInkLineInfo.VTable, @ptrCast(self.vtable)).SetCandidate(@as(*const IInkLineInfo, @ptrCast(self)), nCandidateNum, strRecogWord);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkLineInfo_Recognize(self: *const T) HRESULT {
                return @as(*const IInkLineInfo.VTable, @ptrCast(self.vtable)).Recognize(@as(*const IInkLineInfo, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISketchInk_Value = Guid.initString("b4563688-98eb-4646-b279-44da14d45748");
pub const IID_ISketchInk = &IID_ISketchInk_Value;
pub const ISketchInk = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const CLSID_InkDivider_Value = Guid.initString("8854f6a0-4683-4ae7-9191-752fe64612c3");
pub const CLSID_InkDivider = &CLSID_InkDivider_Value;

pub const InkDivisionType = enum(i32) {
    Segment = 0,
    Line = 1,
    Paragraph = 2,
    Drawing = 3,
};
pub const IDT_Segment = InkDivisionType.Segment;
pub const IDT_Line = InkDivisionType.Line;
pub const IDT_Paragraph = InkDivisionType.Paragraph;
pub const IDT_Drawing = InkDivisionType.Drawing;

pub const DISPID_InkDivider = enum(i32) {
    Strokes = 1,
    RecognizerContext = 2,
    LineHeight = 3,
    Divide = 4,
};
pub const DISPID_IInkDivider_Strokes = DISPID_InkDivider.Strokes;
pub const DISPID_IInkDivider_RecognizerContext = DISPID_InkDivider.RecognizerContext;
pub const DISPID_IInkDivider_LineHeight = DISPID_InkDivider.LineHeight;
pub const DISPID_IInkDivider_Divide = DISPID_InkDivider.Divide;

pub const DISPID_InkDivisionResult = enum(i32) {
    Strokes = 1,
    ResultByType = 2,
};
pub const DISPID_IInkDivisionResult_Strokes = DISPID_InkDivisionResult.Strokes;
pub const DISPID_IInkDivisionResult_ResultByType = DISPID_InkDivisionResult.ResultByType;

pub const DISPID_InkDivisionUnit = enum(i32) {
    Strokes = 1,
    DivisionType = 2,
    RecognizedString = 3,
    RotationTransform = 4,
};
pub const DISPID_IInkDivisionUnit_Strokes = DISPID_InkDivisionUnit.Strokes;
pub const DISPID_IInkDivisionUnit_DivisionType = DISPID_InkDivisionUnit.DivisionType;
pub const DISPID_IInkDivisionUnit_RecognizedString = DISPID_InkDivisionUnit.RecognizedString;
pub const DISPID_IInkDivisionUnit_RotationTransform = DISPID_InkDivisionUnit.RotationTransform;

pub const DISPID_InkDivisionUnits = enum(i32) {
    NewEnum = -4,
    Item = 0,
    Count = 1,
};
pub const DISPID_IInkDivisionUnits_NewEnum = DISPID_InkDivisionUnits.NewEnum;
pub const DISPID_IInkDivisionUnits_Item = DISPID_InkDivisionUnits.Item;
pub const DISPID_IInkDivisionUnits_Count = DISPID_InkDivisionUnits.Count;

const IID_IInkDivider_Value = Guid.initString("5de00405-f9a4-4651-b0c5-c317defd58b9");
pub const IID_IInkDivider = &IID_IInkDivider_Value;
pub const IInkDivider = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Strokes: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkDivider,
                Strokes: ?*?*IInkStrokes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkDivider,
                Strokes: ?*?*IInkStrokes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        putref_Strokes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkDivider,
                Strokes: ?*IInkStrokes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkDivider,
                Strokes: ?*IInkStrokes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RecognizerContext: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkDivider,
                RecognizerContext: ?*?*IInkRecognizerContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkDivider,
                RecognizerContext: ?*?*IInkRecognizerContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        putref_RecognizerContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkDivider,
                RecognizerContext: ?*IInkRecognizerContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkDivider,
                RecognizerContext: ?*IInkRecognizerContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LineHeight: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkDivider,
                LineHeight: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkDivider,
                LineHeight: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_LineHeight: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkDivider,
                LineHeight: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkDivider,
                LineHeight: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Divide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkDivider,
                InkDivisionResult: ?*?*IInkDivisionResult,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkDivider,
                InkDivisionResult: ?*?*IInkDivisionResult,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkDivider_get_Strokes(self: *const T, Strokes: ?*?*IInkStrokes) HRESULT {
                return @as(*const IInkDivider.VTable, @ptrCast(self.vtable)).get_Strokes(@as(*const IInkDivider, @ptrCast(self)), Strokes);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkDivider_putref_Strokes(self: *const T, Strokes: ?*IInkStrokes) HRESULT {
                return @as(*const IInkDivider.VTable, @ptrCast(self.vtable)).putref_Strokes(@as(*const IInkDivider, @ptrCast(self)), Strokes);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkDivider_get_RecognizerContext(self: *const T, RecognizerContext: ?*?*IInkRecognizerContext) HRESULT {
                return @as(*const IInkDivider.VTable, @ptrCast(self.vtable)).get_RecognizerContext(@as(*const IInkDivider, @ptrCast(self)), RecognizerContext);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkDivider_putref_RecognizerContext(self: *const T, RecognizerContext: ?*IInkRecognizerContext) HRESULT {
                return @as(*const IInkDivider.VTable, @ptrCast(self.vtable)).putref_RecognizerContext(@as(*const IInkDivider, @ptrCast(self)), RecognizerContext);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkDivider_get_LineHeight(self: *const T, LineHeight: ?*i32) HRESULT {
                return @as(*const IInkDivider.VTable, @ptrCast(self.vtable)).get_LineHeight(@as(*const IInkDivider, @ptrCast(self)), LineHeight);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkDivider_put_LineHeight(self: *const T, LineHeight: i32) HRESULT {
                return @as(*const IInkDivider.VTable, @ptrCast(self.vtable)).put_LineHeight(@as(*const IInkDivider, @ptrCast(self)), LineHeight);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkDivider_Divide(self: *const T, InkDivisionResult: ?*?*IInkDivisionResult) HRESULT {
                return @as(*const IInkDivider.VTable, @ptrCast(self.vtable)).Divide(@as(*const IInkDivider, @ptrCast(self)), InkDivisionResult);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IInkDivisionResult_Value = Guid.initString("2dbec0a7-74c7-4b38-81eb-aa8ef0c24900");
pub const IID_IInkDivisionResult = &IID_IInkDivisionResult_Value;
pub const IInkDivisionResult = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Strokes: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkDivisionResult,
                Strokes: ?*?*IInkStrokes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkDivisionResult,
                Strokes: ?*?*IInkStrokes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ResultByType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkDivisionResult,
                divisionType: InkDivisionType,
                InkDivisionUnits: ?*?*IInkDivisionUnits,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkDivisionResult,
                divisionType: InkDivisionType,
                InkDivisionUnits: ?*?*IInkDivisionUnits,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkDivisionResult_get_Strokes(self: *const T, Strokes: ?*?*IInkStrokes) HRESULT {
                return @as(*const IInkDivisionResult.VTable, @ptrCast(self.vtable)).get_Strokes(@as(*const IInkDivisionResult, @ptrCast(self)), Strokes);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkDivisionResult_ResultByType(self: *const T, divisionType: InkDivisionType, InkDivisionUnits: ?*?*IInkDivisionUnits) HRESULT {
                return @as(*const IInkDivisionResult.VTable, @ptrCast(self.vtable)).ResultByType(@as(*const IInkDivisionResult, @ptrCast(self)), divisionType, InkDivisionUnits);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IInkDivisionUnit_Value = Guid.initString("85aee342-48b0-4244-9dd5-1ed435410fab");
pub const IID_IInkDivisionUnit = &IID_IInkDivisionUnit_Value;
pub const IInkDivisionUnit = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Strokes: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkDivisionUnit,
                Strokes: ?*?*IInkStrokes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkDivisionUnit,
                Strokes: ?*?*IInkStrokes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DivisionType: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkDivisionUnit,
                divisionType: ?*InkDivisionType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkDivisionUnit,
                divisionType: ?*InkDivisionType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RecognizedString: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkDivisionUnit,
                RecoString: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkDivisionUnit,
                RecoString: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RotationTransform: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkDivisionUnit,
                RotationTransform: ?*?*IInkTransform,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkDivisionUnit,
                RotationTransform: ?*?*IInkTransform,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkDivisionUnit_get_Strokes(self: *const T, Strokes: ?*?*IInkStrokes) HRESULT {
                return @as(*const IInkDivisionUnit.VTable, @ptrCast(self.vtable)).get_Strokes(@as(*const IInkDivisionUnit, @ptrCast(self)), Strokes);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkDivisionUnit_get_DivisionType(self: *const T, divisionType: ?*InkDivisionType) HRESULT {
                return @as(*const IInkDivisionUnit.VTable, @ptrCast(self.vtable)).get_DivisionType(@as(*const IInkDivisionUnit, @ptrCast(self)), divisionType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkDivisionUnit_get_RecognizedString(self: *const T, RecoString: ?*?BSTR) HRESULT {
                return @as(*const IInkDivisionUnit.VTable, @ptrCast(self.vtable)).get_RecognizedString(@as(*const IInkDivisionUnit, @ptrCast(self)), RecoString);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkDivisionUnit_get_RotationTransform(self: *const T, RotationTransform: ?*?*IInkTransform) HRESULT {
                return @as(*const IInkDivisionUnit.VTable, @ptrCast(self.vtable)).get_RotationTransform(@as(*const IInkDivisionUnit, @ptrCast(self)), RotationTransform);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IInkDivisionUnits_Value = Guid.initString("1bb5ddc2-31cc-4135-ab82-2c66c9f00c41");
pub const IID_IInkDivisionUnits = &IID_IInkDivisionUnits_Value;
pub const IInkDivisionUnits = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkDivisionUnits,
                Count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkDivisionUnits,
                Count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkDivisionUnits,
                _NewEnum: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkDivisionUnits,
                _NewEnum: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Item: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkDivisionUnits,
                Index: i32,
                InkDivisionUnit: ?*?*IInkDivisionUnit,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkDivisionUnits,
                Index: i32,
                InkDivisionUnit: ?*?*IInkDivisionUnit,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkDivisionUnits_get_Count(self: *const T, Count: ?*i32) HRESULT {
                return @as(*const IInkDivisionUnits.VTable, @ptrCast(self.vtable)).get_Count(@as(*const IInkDivisionUnits, @ptrCast(self)), Count);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkDivisionUnits_get__NewEnum(self: *const T, _NewEnum: ?*?*IUnknown) HRESULT {
                return @as(*const IInkDivisionUnits.VTable, @ptrCast(self.vtable)).get__NewEnum(@as(*const IInkDivisionUnits, @ptrCast(self)), _NewEnum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkDivisionUnits_Item(self: *const T, Index: i32, InkDivisionUnit: ?*?*IInkDivisionUnit) HRESULT {
                return @as(*const IInkDivisionUnits.VTable, @ptrCast(self.vtable)).Item(@as(*const IInkDivisionUnits, @ptrCast(self)), Index, InkDivisionUnit);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const CLSID_HandwrittenTextInsertion_Value = Guid.initString("9f074ee2-e6e9-4d8a-a047-eb5b5c3c55da");
pub const CLSID_HandwrittenTextInsertion = &CLSID_HandwrittenTextInsertion_Value;

const CLSID_PenInputPanel_Value = Guid.initString("f744e496-1b5a-489e-81dc-fbd7ac6298a8");
pub const CLSID_PenInputPanel = &CLSID_PenInputPanel_Value;

const CLSID_TextInputPanel_Value = Guid.initString("f9b189d7-228b-4f2b-8650-b97f59e02c8c");
pub const CLSID_TextInputPanel = &CLSID_TextInputPanel_Value;

const CLSID_PenInputPanel_Internal_Value = Guid.initString("802b1fb9-056b-4720-b0cc-80d23b71171e");
pub const CLSID_PenInputPanel_Internal = &CLSID_PenInputPanel_Internal_Value;

pub const DISPID_PenInputPanel = enum(i32) {
    AttachedEditWindow = 0,
    Factoid = 1,
    CurrentPanel = 2,
    DefaultPanel = 3,
    Visible = 4,
    Top = 5,
    Left = 6,
    Width = 7,
    Height = 8,
    MoveTo = 9,
    CommitPendingInput = 10,
    Refresh = 11,
    Busy = 12,
    VerticalOffset = 13,
    HorizontalOffset = 14,
    EnableTsf = 15,
    AutoShow = 16,
};
pub const DISPID_PIPAttachedEditWindow = DISPID_PenInputPanel.AttachedEditWindow;
pub const DISPID_PIPFactoid = DISPID_PenInputPanel.Factoid;
pub const DISPID_PIPCurrentPanel = DISPID_PenInputPanel.CurrentPanel;
pub const DISPID_PIPDefaultPanel = DISPID_PenInputPanel.DefaultPanel;
pub const DISPID_PIPVisible = DISPID_PenInputPanel.Visible;
pub const DISPID_PIPTop = DISPID_PenInputPanel.Top;
pub const DISPID_PIPLeft = DISPID_PenInputPanel.Left;
pub const DISPID_PIPWidth = DISPID_PenInputPanel.Width;
pub const DISPID_PIPHeight = DISPID_PenInputPanel.Height;
pub const DISPID_PIPMoveTo = DISPID_PenInputPanel.MoveTo;
pub const DISPID_PIPCommitPendingInput = DISPID_PenInputPanel.CommitPendingInput;
pub const DISPID_PIPRefresh = DISPID_PenInputPanel.Refresh;
pub const DISPID_PIPBusy = DISPID_PenInputPanel.Busy;
pub const DISPID_PIPVerticalOffset = DISPID_PenInputPanel.VerticalOffset;
pub const DISPID_PIPHorizontalOffset = DISPID_PenInputPanel.HorizontalOffset;
pub const DISPID_PIPEnableTsf = DISPID_PenInputPanel.EnableTsf;
pub const DISPID_PIPAutoShow = DISPID_PenInputPanel.AutoShow;

pub const DISPID_PenInputPanelEvents = enum(i32) {
    VisibleChanged = 0,
    PanelChanged = 1,
    InputFailed = 2,
    PanelMoving = 3,
};
pub const DISPID_PIPEVisibleChanged = DISPID_PenInputPanelEvents.VisibleChanged;
pub const DISPID_PIPEPanelChanged = DISPID_PenInputPanelEvents.PanelChanged;
pub const DISPID_PIPEInputFailed = DISPID_PenInputPanelEvents.InputFailed;
pub const DISPID_PIPEPanelMoving = DISPID_PenInputPanelEvents.PanelMoving;

pub const VisualState = enum(i32) {
    InPlace = 0,
    Floating = 1,
    DockedTop = 2,
    DockedBottom = 3,
    Closed = 4,
};
pub const InPlace = VisualState.InPlace;
pub const Floating = VisualState.Floating;
pub const DockedTop = VisualState.DockedTop;
pub const DockedBottom = VisualState.DockedBottom;
pub const Closed = VisualState.Closed;

pub const InteractionMode = enum(i32) {
    InPlace = 0,
    Floating = 1,
    DockedTop = 2,
    DockedBottom = 3,
};
pub const InteractionMode_InPlace = InteractionMode.InPlace;
pub const InteractionMode_Floating = InteractionMode.Floating;
pub const InteractionMode_DockedTop = InteractionMode.DockedTop;
pub const InteractionMode_DockedBottom = InteractionMode.DockedBottom;

pub const InPlaceState = enum(i32) {
    Auto = 0,
    HoverTarget = 1,
    Expanded = 2,
};
pub const InPlaceState_Auto = InPlaceState.Auto;
pub const InPlaceState_HoverTarget = InPlaceState.HoverTarget;
pub const InPlaceState_Expanded = InPlaceState.Expanded;

pub const PanelInputArea = enum(i32) {
    Auto = 0,
    Keyboard = 1,
    WritingPad = 2,
    CharacterPad = 3,
};
pub const PanelInputArea_Auto = PanelInputArea.Auto;
pub const PanelInputArea_Keyboard = PanelInputArea.Keyboard;
pub const PanelInputArea_WritingPad = PanelInputArea.WritingPad;
pub const PanelInputArea_CharacterPad = PanelInputArea.CharacterPad;

pub const CorrectionMode = enum(i32) {
    NotVisible = 0,
    PreInsertion = 1,
    PostInsertionCollapsed = 2,
    PostInsertionExpanded = 3,
};
pub const CorrectionMode_NotVisible = CorrectionMode.NotVisible;
pub const CorrectionMode_PreInsertion = CorrectionMode.PreInsertion;
pub const CorrectionMode_PostInsertionCollapsed = CorrectionMode.PostInsertionCollapsed;
pub const CorrectionMode_PostInsertionExpanded = CorrectionMode.PostInsertionExpanded;

pub const CorrectionPosition = enum(i32) {
    Auto = 0,
    Bottom = 1,
    Top = 2,
};
pub const CorrectionPosition_Auto = CorrectionPosition.Auto;
pub const CorrectionPosition_Bottom = CorrectionPosition.Bottom;
pub const CorrectionPosition_Top = CorrectionPosition.Top;

pub const InPlaceDirection = enum(i32) {
    Auto = 0,
    Bottom = 1,
    Top = 2,
};
pub const InPlaceDirection_Auto = InPlaceDirection.Auto;
pub const InPlaceDirection_Bottom = InPlaceDirection.Bottom;
pub const InPlaceDirection_Top = InPlaceDirection.Top;

pub const EventMask = enum(i32) {
    InPlaceStateChanging = 1,
    InPlaceStateChanged = 2,
    InPlaceSizeChanging = 4,
    InPlaceSizeChanged = 8,
    InputAreaChanging = 16,
    InputAreaChanged = 32,
    CorrectionModeChanging = 64,
    CorrectionModeChanged = 128,
    InPlaceVisibilityChanging = 256,
    InPlaceVisibilityChanged = 512,
    TextInserting = 1024,
    TextInserted = 2048,
    All = 4095,
};
pub const EventMask_InPlaceStateChanging = EventMask.InPlaceStateChanging;
pub const EventMask_InPlaceStateChanged = EventMask.InPlaceStateChanged;
pub const EventMask_InPlaceSizeChanging = EventMask.InPlaceSizeChanging;
pub const EventMask_InPlaceSizeChanged = EventMask.InPlaceSizeChanged;
pub const EventMask_InputAreaChanging = EventMask.InputAreaChanging;
pub const EventMask_InputAreaChanged = EventMask.InputAreaChanged;
pub const EventMask_CorrectionModeChanging = EventMask.CorrectionModeChanging;
pub const EventMask_CorrectionModeChanged = EventMask.CorrectionModeChanged;
pub const EventMask_InPlaceVisibilityChanging = EventMask.InPlaceVisibilityChanging;
pub const EventMask_InPlaceVisibilityChanged = EventMask.InPlaceVisibilityChanged;
pub const EventMask_TextInserting = EventMask.TextInserting;
pub const EventMask_TextInserted = EventMask.TextInserted;
pub const EventMask_All = EventMask.All;

pub const PanelType = enum(i32) {
    Default = 0,
    Inactive = 1,
    Handwriting = 2,
    Keyboard = 3,
};
pub const PT_Default = PanelType.Default;
pub const PT_Inactive = PanelType.Inactive;
pub const PT_Handwriting = PanelType.Handwriting;
pub const PT_Keyboard = PanelType.Keyboard;

const IID_IPenInputPanel_Value = Guid.initString("fa7a4083-5747-4040-a182-0b0e9fd4fac7");
pub const IID_IPenInputPanel = &IID_IPenInputPanel_Value;
pub const IPenInputPanel = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Busy: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IPenInputPanel,
                Busy: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IPenInputPanel,
                Busy: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Factoid: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IPenInputPanel,
                Factoid: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IPenInputPanel,
                Factoid: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Factoid: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IPenInputPanel,
                Factoid: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IPenInputPanel,
                Factoid: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AttachedEditWindow: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IPenInputPanel,
                AttachedEditWindow: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IPenInputPanel,
                AttachedEditWindow: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AttachedEditWindow: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IPenInputPanel,
                AttachedEditWindow: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IPenInputPanel,
                AttachedEditWindow: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentPanel: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IPenInputPanel,
                CurrentPanel: ?*PanelType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IPenInputPanel,
                CurrentPanel: ?*PanelType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_CurrentPanel: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IPenInputPanel,
                CurrentPanel: PanelType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IPenInputPanel,
                CurrentPanel: PanelType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DefaultPanel: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IPenInputPanel,
                pDefaultPanel: ?*PanelType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IPenInputPanel,
                pDefaultPanel: ?*PanelType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DefaultPanel: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IPenInputPanel,
                DefaultPanel: PanelType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IPenInputPanel,
                DefaultPanel: PanelType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Visible: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IPenInputPanel,
                Visible: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IPenInputPanel,
                Visible: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Visible: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IPenInputPanel,
                Visible: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IPenInputPanel,
                Visible: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Top: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IPenInputPanel,
                Top: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IPenInputPanel,
                Top: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Left: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IPenInputPanel,
                Left: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IPenInputPanel,
                Left: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Width: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IPenInputPanel,
                Width: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IPenInputPanel,
                Width: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Height: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IPenInputPanel,
                Height: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IPenInputPanel,
                Height: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_VerticalOffset: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IPenInputPanel,
                VerticalOffset: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IPenInputPanel,
                VerticalOffset: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_VerticalOffset: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IPenInputPanel,
                VerticalOffset: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IPenInputPanel,
                VerticalOffset: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HorizontalOffset: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IPenInputPanel,
                HorizontalOffset: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IPenInputPanel,
                HorizontalOffset: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_HorizontalOffset: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IPenInputPanel,
                HorizontalOffset: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IPenInputPanel,
                HorizontalOffset: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AutoShow: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IPenInputPanel,
                pAutoShow: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IPenInputPanel,
                pAutoShow: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AutoShow: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IPenInputPanel,
                AutoShow: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IPenInputPanel,
                AutoShow: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        MoveTo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPenInputPanel,
                Left: i32,
                Top: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPenInputPanel,
                Left: i32,
                Top: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CommitPendingInput: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPenInputPanel,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPenInputPanel,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Refresh: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPenInputPanel,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPenInputPanel,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnableTsf: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPenInputPanel,
                Enable: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPenInputPanel,
                Enable: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPenInputPanel_get_Busy(self: *const T, Busy: ?*i16) HRESULT {
                return @as(*const IPenInputPanel.VTable, @ptrCast(self.vtable)).get_Busy(@as(*const IPenInputPanel, @ptrCast(self)), Busy);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPenInputPanel_get_Factoid(self: *const T, Factoid: ?*?BSTR) HRESULT {
                return @as(*const IPenInputPanel.VTable, @ptrCast(self.vtable)).get_Factoid(@as(*const IPenInputPanel, @ptrCast(self)), Factoid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPenInputPanel_put_Factoid(self: *const T, Factoid: ?BSTR) HRESULT {
                return @as(*const IPenInputPanel.VTable, @ptrCast(self.vtable)).put_Factoid(@as(*const IPenInputPanel, @ptrCast(self)), Factoid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPenInputPanel_get_AttachedEditWindow(self: *const T, AttachedEditWindow: ?*i32) HRESULT {
                return @as(*const IPenInputPanel.VTable, @ptrCast(self.vtable)).get_AttachedEditWindow(@as(*const IPenInputPanel, @ptrCast(self)), AttachedEditWindow);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPenInputPanel_put_AttachedEditWindow(self: *const T, AttachedEditWindow: i32) HRESULT {
                return @as(*const IPenInputPanel.VTable, @ptrCast(self.vtable)).put_AttachedEditWindow(@as(*const IPenInputPanel, @ptrCast(self)), AttachedEditWindow);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPenInputPanel_get_CurrentPanel(self: *const T, CurrentPanel: ?*PanelType) HRESULT {
                return @as(*const IPenInputPanel.VTable, @ptrCast(self.vtable)).get_CurrentPanel(@as(*const IPenInputPanel, @ptrCast(self)), CurrentPanel);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPenInputPanel_put_CurrentPanel(self: *const T, CurrentPanel: PanelType) HRESULT {
                return @as(*const IPenInputPanel.VTable, @ptrCast(self.vtable)).put_CurrentPanel(@as(*const IPenInputPanel, @ptrCast(self)), CurrentPanel);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPenInputPanel_get_DefaultPanel(self: *const T, pDefaultPanel: ?*PanelType) HRESULT {
                return @as(*const IPenInputPanel.VTable, @ptrCast(self.vtable)).get_DefaultPanel(@as(*const IPenInputPanel, @ptrCast(self)), pDefaultPanel);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPenInputPanel_put_DefaultPanel(self: *const T, DefaultPanel: PanelType) HRESULT {
                return @as(*const IPenInputPanel.VTable, @ptrCast(self.vtable)).put_DefaultPanel(@as(*const IPenInputPanel, @ptrCast(self)), DefaultPanel);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPenInputPanel_get_Visible(self: *const T, Visible: ?*i16) HRESULT {
                return @as(*const IPenInputPanel.VTable, @ptrCast(self.vtable)).get_Visible(@as(*const IPenInputPanel, @ptrCast(self)), Visible);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPenInputPanel_put_Visible(self: *const T, Visible: i16) HRESULT {
                return @as(*const IPenInputPanel.VTable, @ptrCast(self.vtable)).put_Visible(@as(*const IPenInputPanel, @ptrCast(self)), Visible);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPenInputPanel_get_Top(self: *const T, Top: ?*i32) HRESULT {
                return @as(*const IPenInputPanel.VTable, @ptrCast(self.vtable)).get_Top(@as(*const IPenInputPanel, @ptrCast(self)), Top);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPenInputPanel_get_Left(self: *const T, Left: ?*i32) HRESULT {
                return @as(*const IPenInputPanel.VTable, @ptrCast(self.vtable)).get_Left(@as(*const IPenInputPanel, @ptrCast(self)), Left);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPenInputPanel_get_Width(self: *const T, Width: ?*i32) HRESULT {
                return @as(*const IPenInputPanel.VTable, @ptrCast(self.vtable)).get_Width(@as(*const IPenInputPanel, @ptrCast(self)), Width);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPenInputPanel_get_Height(self: *const T, Height: ?*i32) HRESULT {
                return @as(*const IPenInputPanel.VTable, @ptrCast(self.vtable)).get_Height(@as(*const IPenInputPanel, @ptrCast(self)), Height);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPenInputPanel_get_VerticalOffset(self: *const T, VerticalOffset: ?*i32) HRESULT {
                return @as(*const IPenInputPanel.VTable, @ptrCast(self.vtable)).get_VerticalOffset(@as(*const IPenInputPanel, @ptrCast(self)), VerticalOffset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPenInputPanel_put_VerticalOffset(self: *const T, VerticalOffset: i32) HRESULT {
                return @as(*const IPenInputPanel.VTable, @ptrCast(self.vtable)).put_VerticalOffset(@as(*const IPenInputPanel, @ptrCast(self)), VerticalOffset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPenInputPanel_get_HorizontalOffset(self: *const T, HorizontalOffset: ?*i32) HRESULT {
                return @as(*const IPenInputPanel.VTable, @ptrCast(self.vtable)).get_HorizontalOffset(@as(*const IPenInputPanel, @ptrCast(self)), HorizontalOffset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPenInputPanel_put_HorizontalOffset(self: *const T, HorizontalOffset: i32) HRESULT {
                return @as(*const IPenInputPanel.VTable, @ptrCast(self.vtable)).put_HorizontalOffset(@as(*const IPenInputPanel, @ptrCast(self)), HorizontalOffset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPenInputPanel_get_AutoShow(self: *const T, pAutoShow: ?*i16) HRESULT {
                return @as(*const IPenInputPanel.VTable, @ptrCast(self.vtable)).get_AutoShow(@as(*const IPenInputPanel, @ptrCast(self)), pAutoShow);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPenInputPanel_put_AutoShow(self: *const T, AutoShow: i16) HRESULT {
                return @as(*const IPenInputPanel.VTable, @ptrCast(self.vtable)).put_AutoShow(@as(*const IPenInputPanel, @ptrCast(self)), AutoShow);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPenInputPanel_MoveTo(self: *const T, Left: i32, Top: i32) HRESULT {
                return @as(*const IPenInputPanel.VTable, @ptrCast(self.vtable)).MoveTo(@as(*const IPenInputPanel, @ptrCast(self)), Left, Top);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPenInputPanel_CommitPendingInput(self: *const T) HRESULT {
                return @as(*const IPenInputPanel.VTable, @ptrCast(self.vtable)).CommitPendingInput(@as(*const IPenInputPanel, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPenInputPanel_Refresh(self: *const T) HRESULT {
                return @as(*const IPenInputPanel.VTable, @ptrCast(self.vtable)).Refresh(@as(*const IPenInputPanel, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPenInputPanel_EnableTsf(self: *const T, Enable: i16) HRESULT {
                return @as(*const IPenInputPanel.VTable, @ptrCast(self.vtable)).EnableTsf(@as(*const IPenInputPanel, @ptrCast(self)), Enable);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID__IPenInputPanelEvents_Value = Guid.initString("b7e489da-3719-439f-848f-e7acbd820f17");
pub const IID__IPenInputPanelEvents = &IID__IPenInputPanelEvents_Value;
pub const _IPenInputPanelEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IHandwrittenTextInsertion_Value = Guid.initString("56fdea97-ecd6-43e7-aa3a-816be7785860");
pub const IID_IHandwrittenTextInsertion = &IID_IHandwrittenTextInsertion_Value;
pub const IHandwrittenTextInsertion = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        InsertRecognitionResultsArray: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IHandwrittenTextInsertion,
                psaAlternates: ?*SAFEARRAY,
                locale: u32,
                fAlternateContainsAutoSpacingInformation: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IHandwrittenTextInsertion,
                psaAlternates: ?*SAFEARRAY,
                locale: u32,
                fAlternateContainsAutoSpacingInformation: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InsertInkRecognitionResult: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IHandwrittenTextInsertion,
                pIInkRecoResult: ?*IInkRecognitionResult,
                locale: u32,
                fAlternateContainsAutoSpacingInformation: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IHandwrittenTextInsertion,
                pIInkRecoResult: ?*IInkRecognitionResult,
                locale: u32,
                fAlternateContainsAutoSpacingInformation: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IHandwrittenTextInsertion_InsertRecognitionResultsArray(self: *const T, psaAlternates: ?*SAFEARRAY, locale: u32, fAlternateContainsAutoSpacingInformation: BOOL) HRESULT {
                return @as(*const IHandwrittenTextInsertion.VTable, @ptrCast(self.vtable)).InsertRecognitionResultsArray(@as(*const IHandwrittenTextInsertion, @ptrCast(self)), psaAlternates, locale, fAlternateContainsAutoSpacingInformation);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IHandwrittenTextInsertion_InsertInkRecognitionResult(self: *const T, pIInkRecoResult: ?*IInkRecognitionResult, locale: u32, fAlternateContainsAutoSpacingInformation: BOOL) HRESULT {
                return @as(*const IHandwrittenTextInsertion.VTable, @ptrCast(self.vtable)).InsertInkRecognitionResult(@as(*const IHandwrittenTextInsertion, @ptrCast(self)), pIInkRecoResult, locale, fAlternateContainsAutoSpacingInformation);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ITextInputPanelEventSink_Value = Guid.initString("27560408-8e64-4fe1-804e-421201584b31");
pub const IID_ITextInputPanelEventSink = &IID_ITextInputPanelEventSink_Value;
pub const ITextInputPanelEventSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        InPlaceStateChanging: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextInputPanelEventSink,
                oldInPlaceState: InPlaceState,
                newInPlaceState: InPlaceState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextInputPanelEventSink,
                oldInPlaceState: InPlaceState,
                newInPlaceState: InPlaceState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InPlaceStateChanged: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextInputPanelEventSink,
                oldInPlaceState: InPlaceState,
                newInPlaceState: InPlaceState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextInputPanelEventSink,
                oldInPlaceState: InPlaceState,
                newInPlaceState: InPlaceState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InPlaceSizeChanging: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextInputPanelEventSink,
                oldBoundingRectangle: RECT,
                newBoundingRectangle: RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextInputPanelEventSink,
                oldBoundingRectangle: RECT,
                newBoundingRectangle: RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InPlaceSizeChanged: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextInputPanelEventSink,
                oldBoundingRectangle: RECT,
                newBoundingRectangle: RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextInputPanelEventSink,
                oldBoundingRectangle: RECT,
                newBoundingRectangle: RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InputAreaChanging: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextInputPanelEventSink,
                oldInputArea: PanelInputArea,
                newInputArea: PanelInputArea,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextInputPanelEventSink,
                oldInputArea: PanelInputArea,
                newInputArea: PanelInputArea,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InputAreaChanged: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextInputPanelEventSink,
                oldInputArea: PanelInputArea,
                newInputArea: PanelInputArea,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextInputPanelEventSink,
                oldInputArea: PanelInputArea,
                newInputArea: PanelInputArea,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CorrectionModeChanging: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextInputPanelEventSink,
                oldCorrectionMode: CorrectionMode,
                newCorrectionMode: CorrectionMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextInputPanelEventSink,
                oldCorrectionMode: CorrectionMode,
                newCorrectionMode: CorrectionMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CorrectionModeChanged: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextInputPanelEventSink,
                oldCorrectionMode: CorrectionMode,
                newCorrectionMode: CorrectionMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextInputPanelEventSink,
                oldCorrectionMode: CorrectionMode,
                newCorrectionMode: CorrectionMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InPlaceVisibilityChanging: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextInputPanelEventSink,
                oldVisible: BOOL,
                newVisible: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextInputPanelEventSink,
                oldVisible: BOOL,
                newVisible: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InPlaceVisibilityChanged: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextInputPanelEventSink,
                oldVisible: BOOL,
                newVisible: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextInputPanelEventSink,
                oldVisible: BOOL,
                newVisible: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TextInserting: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextInputPanelEventSink,
                Ink: ?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextInputPanelEventSink,
                Ink: ?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TextInserted: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextInputPanelEventSink,
                Ink: ?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextInputPanelEventSink,
                Ink: ?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextInputPanelEventSink_InPlaceStateChanging(self: *const T, oldInPlaceState: InPlaceState, newInPlaceState: InPlaceState) HRESULT {
                return @as(*const ITextInputPanelEventSink.VTable, @ptrCast(self.vtable)).InPlaceStateChanging(@as(*const ITextInputPanelEventSink, @ptrCast(self)), oldInPlaceState, newInPlaceState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextInputPanelEventSink_InPlaceStateChanged(self: *const T, oldInPlaceState: InPlaceState, newInPlaceState: InPlaceState) HRESULT {
                return @as(*const ITextInputPanelEventSink.VTable, @ptrCast(self.vtable)).InPlaceStateChanged(@as(*const ITextInputPanelEventSink, @ptrCast(self)), oldInPlaceState, newInPlaceState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextInputPanelEventSink_InPlaceSizeChanging(self: *const T, oldBoundingRectangle: RECT, newBoundingRectangle: RECT) HRESULT {
                return @as(*const ITextInputPanelEventSink.VTable, @ptrCast(self.vtable)).InPlaceSizeChanging(@as(*const ITextInputPanelEventSink, @ptrCast(self)), oldBoundingRectangle, newBoundingRectangle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextInputPanelEventSink_InPlaceSizeChanged(self: *const T, oldBoundingRectangle: RECT, newBoundingRectangle: RECT) HRESULT {
                return @as(*const ITextInputPanelEventSink.VTable, @ptrCast(self.vtable)).InPlaceSizeChanged(@as(*const ITextInputPanelEventSink, @ptrCast(self)), oldBoundingRectangle, newBoundingRectangle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextInputPanelEventSink_InputAreaChanging(self: *const T, oldInputArea: PanelInputArea, newInputArea: PanelInputArea) HRESULT {
                return @as(*const ITextInputPanelEventSink.VTable, @ptrCast(self.vtable)).InputAreaChanging(@as(*const ITextInputPanelEventSink, @ptrCast(self)), oldInputArea, newInputArea);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextInputPanelEventSink_InputAreaChanged(self: *const T, oldInputArea: PanelInputArea, newInputArea: PanelInputArea) HRESULT {
                return @as(*const ITextInputPanelEventSink.VTable, @ptrCast(self.vtable)).InputAreaChanged(@as(*const ITextInputPanelEventSink, @ptrCast(self)), oldInputArea, newInputArea);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextInputPanelEventSink_CorrectionModeChanging(self: *const T, oldCorrectionMode: CorrectionMode, newCorrectionMode: CorrectionMode) HRESULT {
                return @as(*const ITextInputPanelEventSink.VTable, @ptrCast(self.vtable)).CorrectionModeChanging(@as(*const ITextInputPanelEventSink, @ptrCast(self)), oldCorrectionMode, newCorrectionMode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextInputPanelEventSink_CorrectionModeChanged(self: *const T, oldCorrectionMode: CorrectionMode, newCorrectionMode: CorrectionMode) HRESULT {
                return @as(*const ITextInputPanelEventSink.VTable, @ptrCast(self.vtable)).CorrectionModeChanged(@as(*const ITextInputPanelEventSink, @ptrCast(self)), oldCorrectionMode, newCorrectionMode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextInputPanelEventSink_InPlaceVisibilityChanging(self: *const T, oldVisible: BOOL, newVisible: BOOL) HRESULT {
                return @as(*const ITextInputPanelEventSink.VTable, @ptrCast(self.vtable)).InPlaceVisibilityChanging(@as(*const ITextInputPanelEventSink, @ptrCast(self)), oldVisible, newVisible);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextInputPanelEventSink_InPlaceVisibilityChanged(self: *const T, oldVisible: BOOL, newVisible: BOOL) HRESULT {
                return @as(*const ITextInputPanelEventSink.VTable, @ptrCast(self.vtable)).InPlaceVisibilityChanged(@as(*const ITextInputPanelEventSink, @ptrCast(self)), oldVisible, newVisible);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextInputPanelEventSink_TextInserting(self: *const T, Ink: ?*SAFEARRAY) HRESULT {
                return @as(*const ITextInputPanelEventSink.VTable, @ptrCast(self.vtable)).TextInserting(@as(*const ITextInputPanelEventSink, @ptrCast(self)), Ink);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextInputPanelEventSink_TextInserted(self: *const T, Ink: ?*SAFEARRAY) HRESULT {
                return @as(*const ITextInputPanelEventSink.VTable, @ptrCast(self.vtable)).TextInserted(@as(*const ITextInputPanelEventSink, @ptrCast(self)), Ink);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ITextInputPanel_Value = Guid.initString("6b6a65a5-6af3-46c2-b6ea-56cd1f80df71");
pub const IID_ITextInputPanel = &IID_ITextInputPanel_Value;
pub const ITextInputPanel = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AttachedEditWindow: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITextInputPanel,
                AttachedEditWindow: ?*?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITextInputPanel,
                AttachedEditWindow: ?*?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AttachedEditWindow: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITextInputPanel,
                AttachedEditWindow: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITextInputPanel,
                AttachedEditWindow: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentInteractionMode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITextInputPanel,
                CurrentInteractionMode: ?*InteractionMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITextInputPanel,
                CurrentInteractionMode: ?*InteractionMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DefaultInPlaceState: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITextInputPanel,
                State: ?*InPlaceState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITextInputPanel,
                State: ?*InPlaceState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DefaultInPlaceState: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITextInputPanel,
                State: InPlaceState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITextInputPanel,
                State: InPlaceState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentInPlaceState: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITextInputPanel,
                State: ?*InPlaceState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITextInputPanel,
                State: ?*InPlaceState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DefaultInputArea: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITextInputPanel,
                Area: ?*PanelInputArea,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITextInputPanel,
                Area: ?*PanelInputArea,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DefaultInputArea: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITextInputPanel,
                Area: PanelInputArea,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITextInputPanel,
                Area: PanelInputArea,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentInputArea: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITextInputPanel,
                Area: ?*PanelInputArea,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITextInputPanel,
                Area: ?*PanelInputArea,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentCorrectionMode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITextInputPanel,
                Mode: ?*CorrectionMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITextInputPanel,
                Mode: ?*CorrectionMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PreferredInPlaceDirection: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITextInputPanel,
                Direction: ?*InPlaceDirection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITextInputPanel,
                Direction: ?*InPlaceDirection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_PreferredInPlaceDirection: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITextInputPanel,
                Direction: InPlaceDirection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITextInputPanel,
                Direction: InPlaceDirection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ExpandPostInsertionCorrection: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITextInputPanel,
                Expand: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITextInputPanel,
                Expand: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ExpandPostInsertionCorrection: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITextInputPanel,
                Expand: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITextInputPanel,
                Expand: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InPlaceVisibleOnFocus: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITextInputPanel,
                Visible: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITextInputPanel,
                Visible: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_InPlaceVisibleOnFocus: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITextInputPanel,
                Visible: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITextInputPanel,
                Visible: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InPlaceBoundingRectangle: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITextInputPanel,
                BoundingRectangle: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITextInputPanel,
                BoundingRectangle: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PopUpCorrectionHeight: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITextInputPanel,
                Height: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITextInputPanel,
                Height: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PopDownCorrectionHeight: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const ITextInputPanel,
                Height: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const ITextInputPanel,
                Height: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CommitPendingInput: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextInputPanel,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextInputPanel,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetInPlaceVisibility: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextInputPanel,
                Visible: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextInputPanel,
                Visible: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetInPlacePosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextInputPanel,
                xPosition: i32,
                yPosition: i32,
                position: CorrectionPosition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextInputPanel,
                xPosition: i32,
                yPosition: i32,
                position: CorrectionPosition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetInPlaceHoverTargetPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextInputPanel,
                xPosition: i32,
                yPosition: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextInputPanel,
                xPosition: i32,
                yPosition: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Advise: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextInputPanel,
                EventSink: ?*ITextInputPanelEventSink,
                EventMask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextInputPanel,
                EventSink: ?*ITextInputPanelEventSink,
                EventMask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Unadvise: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextInputPanel,
                EventSink: ?*ITextInputPanelEventSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextInputPanel,
                EventSink: ?*ITextInputPanelEventSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextInputPanel_get_AttachedEditWindow(self: *const T, AttachedEditWindow: ?*?HWND) HRESULT {
                return @as(*const ITextInputPanel.VTable, @ptrCast(self.vtable)).get_AttachedEditWindow(@as(*const ITextInputPanel, @ptrCast(self)), AttachedEditWindow);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextInputPanel_put_AttachedEditWindow(self: *const T, AttachedEditWindow: ?HWND) HRESULT {
                return @as(*const ITextInputPanel.VTable, @ptrCast(self.vtable)).put_AttachedEditWindow(@as(*const ITextInputPanel, @ptrCast(self)), AttachedEditWindow);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextInputPanel_get_CurrentInteractionMode(self: *const T, CurrentInteractionMode: ?*InteractionMode) HRESULT {
                return @as(*const ITextInputPanel.VTable, @ptrCast(self.vtable)).get_CurrentInteractionMode(@as(*const ITextInputPanel, @ptrCast(self)), CurrentInteractionMode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextInputPanel_get_DefaultInPlaceState(self: *const T, State: ?*InPlaceState) HRESULT {
                return @as(*const ITextInputPanel.VTable, @ptrCast(self.vtable)).get_DefaultInPlaceState(@as(*const ITextInputPanel, @ptrCast(self)), State);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextInputPanel_put_DefaultInPlaceState(self: *const T, State: InPlaceState) HRESULT {
                return @as(*const ITextInputPanel.VTable, @ptrCast(self.vtable)).put_DefaultInPlaceState(@as(*const ITextInputPanel, @ptrCast(self)), State);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextInputPanel_get_CurrentInPlaceState(self: *const T, State: ?*InPlaceState) HRESULT {
                return @as(*const ITextInputPanel.VTable, @ptrCast(self.vtable)).get_CurrentInPlaceState(@as(*const ITextInputPanel, @ptrCast(self)), State);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextInputPanel_get_DefaultInputArea(self: *const T, Area: ?*PanelInputArea) HRESULT {
                return @as(*const ITextInputPanel.VTable, @ptrCast(self.vtable)).get_DefaultInputArea(@as(*const ITextInputPanel, @ptrCast(self)), Area);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextInputPanel_put_DefaultInputArea(self: *const T, Area: PanelInputArea) HRESULT {
                return @as(*const ITextInputPanel.VTable, @ptrCast(self.vtable)).put_DefaultInputArea(@as(*const ITextInputPanel, @ptrCast(self)), Area);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextInputPanel_get_CurrentInputArea(self: *const T, Area: ?*PanelInputArea) HRESULT {
                return @as(*const ITextInputPanel.VTable, @ptrCast(self.vtable)).get_CurrentInputArea(@as(*const ITextInputPanel, @ptrCast(self)), Area);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextInputPanel_get_CurrentCorrectionMode(self: *const T, Mode: ?*CorrectionMode) HRESULT {
                return @as(*const ITextInputPanel.VTable, @ptrCast(self.vtable)).get_CurrentCorrectionMode(@as(*const ITextInputPanel, @ptrCast(self)), Mode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextInputPanel_get_PreferredInPlaceDirection(self: *const T, Direction: ?*InPlaceDirection) HRESULT {
                return @as(*const ITextInputPanel.VTable, @ptrCast(self.vtable)).get_PreferredInPlaceDirection(@as(*const ITextInputPanel, @ptrCast(self)), Direction);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextInputPanel_put_PreferredInPlaceDirection(self: *const T, Direction: InPlaceDirection) HRESULT {
                return @as(*const ITextInputPanel.VTable, @ptrCast(self.vtable)).put_PreferredInPlaceDirection(@as(*const ITextInputPanel, @ptrCast(self)), Direction);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextInputPanel_get_ExpandPostInsertionCorrection(self: *const T, Expand: ?*BOOL) HRESULT {
                return @as(*const ITextInputPanel.VTable, @ptrCast(self.vtable)).get_ExpandPostInsertionCorrection(@as(*const ITextInputPanel, @ptrCast(self)), Expand);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextInputPanel_put_ExpandPostInsertionCorrection(self: *const T, Expand: BOOL) HRESULT {
                return @as(*const ITextInputPanel.VTable, @ptrCast(self.vtable)).put_ExpandPostInsertionCorrection(@as(*const ITextInputPanel, @ptrCast(self)), Expand);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextInputPanel_get_InPlaceVisibleOnFocus(self: *const T, Visible: ?*BOOL) HRESULT {
                return @as(*const ITextInputPanel.VTable, @ptrCast(self.vtable)).get_InPlaceVisibleOnFocus(@as(*const ITextInputPanel, @ptrCast(self)), Visible);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextInputPanel_put_InPlaceVisibleOnFocus(self: *const T, Visible: BOOL) HRESULT {
                return @as(*const ITextInputPanel.VTable, @ptrCast(self.vtable)).put_InPlaceVisibleOnFocus(@as(*const ITextInputPanel, @ptrCast(self)), Visible);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextInputPanel_get_InPlaceBoundingRectangle(self: *const T, BoundingRectangle: ?*RECT) HRESULT {
                return @as(*const ITextInputPanel.VTable, @ptrCast(self.vtable)).get_InPlaceBoundingRectangle(@as(*const ITextInputPanel, @ptrCast(self)), BoundingRectangle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextInputPanel_get_PopUpCorrectionHeight(self: *const T, Height: ?*i32) HRESULT {
                return @as(*const ITextInputPanel.VTable, @ptrCast(self.vtable)).get_PopUpCorrectionHeight(@as(*const ITextInputPanel, @ptrCast(self)), Height);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextInputPanel_get_PopDownCorrectionHeight(self: *const T, Height: ?*i32) HRESULT {
                return @as(*const ITextInputPanel.VTable, @ptrCast(self.vtable)).get_PopDownCorrectionHeight(@as(*const ITextInputPanel, @ptrCast(self)), Height);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextInputPanel_CommitPendingInput(self: *const T) HRESULT {
                return @as(*const ITextInputPanel.VTable, @ptrCast(self.vtable)).CommitPendingInput(@as(*const ITextInputPanel, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextInputPanel_SetInPlaceVisibility(self: *const T, Visible: BOOL) HRESULT {
                return @as(*const ITextInputPanel.VTable, @ptrCast(self.vtable)).SetInPlaceVisibility(@as(*const ITextInputPanel, @ptrCast(self)), Visible);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextInputPanel_SetInPlacePosition(self: *const T, xPosition: i32, yPosition: i32, position: CorrectionPosition) HRESULT {
                return @as(*const ITextInputPanel.VTable, @ptrCast(self.vtable)).SetInPlacePosition(@as(*const ITextInputPanel, @ptrCast(self)), xPosition, yPosition, position);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextInputPanel_SetInPlaceHoverTargetPosition(self: *const T, xPosition: i32, yPosition: i32) HRESULT {
                return @as(*const ITextInputPanel.VTable, @ptrCast(self.vtable)).SetInPlaceHoverTargetPosition(@as(*const ITextInputPanel, @ptrCast(self)), xPosition, yPosition);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextInputPanel_Advise(self: *const T, EventSink: ?*ITextInputPanelEventSink, _param_EventMask: u32) HRESULT {
                return @as(*const ITextInputPanel.VTable, @ptrCast(self.vtable)).Advise(@as(*const ITextInputPanel, @ptrCast(self)), EventSink, _param_EventMask);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextInputPanel_Unadvise(self: *const T, EventSink: ?*ITextInputPanelEventSink) HRESULT {
                return @as(*const ITextInputPanel.VTable, @ptrCast(self.vtable)).Unadvise(@as(*const ITextInputPanel, @ptrCast(self)), EventSink);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IInputPanelWindowHandle_Value = Guid.initString("4af81847-fdc4-4fc3-ad0b-422479c1b935");
pub const IID_IInputPanelWindowHandle = &IID_IInputPanelWindowHandle_Value;
pub const IInputPanelWindowHandle = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AttachedEditWindow32: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInputPanelWindowHandle,
                AttachedEditWindow: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInputPanelWindowHandle,
                AttachedEditWindow: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AttachedEditWindow32: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInputPanelWindowHandle,
                AttachedEditWindow: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInputPanelWindowHandle,
                AttachedEditWindow: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AttachedEditWindow64: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInputPanelWindowHandle,
                AttachedEditWindow: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInputPanelWindowHandle,
                AttachedEditWindow: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AttachedEditWindow64: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInputPanelWindowHandle,
                AttachedEditWindow: i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInputPanelWindowHandle,
                AttachedEditWindow: i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInputPanelWindowHandle_get_AttachedEditWindow32(self: *const T, AttachedEditWindow: ?*i32) HRESULT {
                return @as(*const IInputPanelWindowHandle.VTable, @ptrCast(self.vtable)).get_AttachedEditWindow32(@as(*const IInputPanelWindowHandle, @ptrCast(self)), AttachedEditWindow);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInputPanelWindowHandle_put_AttachedEditWindow32(self: *const T, AttachedEditWindow: i32) HRESULT {
                return @as(*const IInputPanelWindowHandle.VTable, @ptrCast(self.vtable)).put_AttachedEditWindow32(@as(*const IInputPanelWindowHandle, @ptrCast(self)), AttachedEditWindow);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInputPanelWindowHandle_get_AttachedEditWindow64(self: *const T, AttachedEditWindow: ?*i64) HRESULT {
                return @as(*const IInputPanelWindowHandle.VTable, @ptrCast(self.vtable)).get_AttachedEditWindow64(@as(*const IInputPanelWindowHandle, @ptrCast(self)), AttachedEditWindow);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInputPanelWindowHandle_put_AttachedEditWindow64(self: *const T, AttachedEditWindow: i64) HRESULT {
                return @as(*const IInputPanelWindowHandle.VTable, @ptrCast(self.vtable)).put_AttachedEditWindow64(@as(*const IInputPanelWindowHandle, @ptrCast(self)), AttachedEditWindow);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ITextInputPanelRunInfo_Value = Guid.initString("9f424568-1920-48cc-9811-a993cbf5adba");
pub const IID_ITextInputPanelRunInfo = &IID_ITextInputPanelRunInfo_Value;
pub const ITextInputPanelRunInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IsTipRunning: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITextInputPanelRunInfo,
                pfRunning: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITextInputPanelRunInfo,
                pfRunning: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITextInputPanelRunInfo_IsTipRunning(self: *const T, pfRunning: ?*BOOL) HRESULT {
                return @as(*const ITextInputPanelRunInfo.VTable, @ptrCast(self.vtable)).IsTipRunning(@as(*const ITextInputPanelRunInfo, @ptrCast(self)), pfRunning);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const FLICKDIRECTION = enum(i32) {
    MIN = 0,
    // RIGHT = 0, this enum value conflicts with MIN
    UPRIGHT = 1,
    UP = 2,
    UPLEFT = 3,
    LEFT = 4,
    DOWNLEFT = 5,
    DOWN = 6,
    DOWNRIGHT = 7,
    INVALID = 8,
};
pub const FLICKDIRECTION_MIN = FLICKDIRECTION.MIN;
pub const FLICKDIRECTION_RIGHT = FLICKDIRECTION.MIN;
pub const FLICKDIRECTION_UPRIGHT = FLICKDIRECTION.UPRIGHT;
pub const FLICKDIRECTION_UP = FLICKDIRECTION.UP;
pub const FLICKDIRECTION_UPLEFT = FLICKDIRECTION.UPLEFT;
pub const FLICKDIRECTION_LEFT = FLICKDIRECTION.LEFT;
pub const FLICKDIRECTION_DOWNLEFT = FLICKDIRECTION.DOWNLEFT;
pub const FLICKDIRECTION_DOWN = FLICKDIRECTION.DOWN;
pub const FLICKDIRECTION_DOWNRIGHT = FLICKDIRECTION.DOWNRIGHT;
pub const FLICKDIRECTION_INVALID = FLICKDIRECTION.INVALID;

pub const FLICKMODE = enum(i32) {
    MIN = 0,
    // OFF = 0, this enum value conflicts with MIN
    ON = 1,
    LEARNING = 2,
    // MAX = 2, this enum value conflicts with LEARNING
    // DEFAULT = 1, this enum value conflicts with ON
};
pub const FLICKMODE_MIN = FLICKMODE.MIN;
pub const FLICKMODE_OFF = FLICKMODE.MIN;
pub const FLICKMODE_ON = FLICKMODE.ON;
pub const FLICKMODE_LEARNING = FLICKMODE.LEARNING;
pub const FLICKMODE_MAX = FLICKMODE.LEARNING;
pub const FLICKMODE_DEFAULT = FLICKMODE.ON;

pub const FLICKACTION_COMMANDCODE = enum(i32) {
    NULL = 0,
    SCROLL = 1,
    APPCOMMAND = 2,
    CUSTOMKEY = 3,
    KEYMODIFIER = 4,
};
pub const FLICKACTION_COMMANDCODE_NULL = FLICKACTION_COMMANDCODE.NULL;
pub const FLICKACTION_COMMANDCODE_SCROLL = FLICKACTION_COMMANDCODE.SCROLL;
pub const FLICKACTION_COMMANDCODE_APPCOMMAND = FLICKACTION_COMMANDCODE.APPCOMMAND;
pub const FLICKACTION_COMMANDCODE_CUSTOMKEY = FLICKACTION_COMMANDCODE.CUSTOMKEY;
pub const FLICKACTION_COMMANDCODE_KEYMODIFIER = FLICKACTION_COMMANDCODE.KEYMODIFIER;

pub const FLICK_POINT = extern struct {
    _bitfield: i32,
};

pub const FLICK_DATA = extern struct {
    _bitfield: i32,
};

pub const SCROLLDIRECTION = enum(i32) {
    UP = 0,
    DOWN = 1,
};
pub const SCROLLDIRECTION_UP = SCROLLDIRECTION.UP;
pub const SCROLLDIRECTION_DOWN = SCROLLDIRECTION.DOWN;

pub const KEYMODIFIER = enum(i32) {
    CONTROL = 1,
    MENU = 2,
    SHIFT = 4,
    WIN = 8,
    ALTGR = 16,
    EXT = 32,
};
pub const KEYMODIFIER_CONTROL = KEYMODIFIER.CONTROL;
pub const KEYMODIFIER_MENU = KEYMODIFIER.MENU;
pub const KEYMODIFIER_SHIFT = KEYMODIFIER.SHIFT;
pub const KEYMODIFIER_WIN = KEYMODIFIER.WIN;
pub const KEYMODIFIER_ALTGR = KEYMODIFIER.ALTGR;
pub const KEYMODIFIER_EXT = KEYMODIFIER.EXT;

const CLSID_InkEdit_Value = Guid.initString("e5ca59f5-57c4-4dd8-9bd6-1deeedd27af4");
pub const CLSID_InkEdit = &CLSID_InkEdit_Value;

pub const IEC_STROKEINFO = extern struct {
    nmhdr: NMHDR,
    Cursor: ?*IInkCursor,
    Stroke: ?*IInkStrokeDisp,
};

pub const IEC_GESTUREINFO = extern struct {
    nmhdr: NMHDR,
    Cursor: ?*IInkCursor,
    Strokes: ?*IInkStrokes,
    Gestures: VARIANT,
};

pub const IEC_RECOGNITIONRESULTINFO = extern struct {
    nmhdr: NMHDR,
    RecognitionResult: ?*IInkRecognitionResult,
};

pub const MouseButton = enum(i32) {
    NO_BUTTON = 0,
    LEFT_BUTTON = 1,
    RIGHT_BUTTON = 2,
    MIDDLE_BUTTON = 4,
};
pub const NO_BUTTON = MouseButton.NO_BUTTON;
pub const LEFT_BUTTON = MouseButton.LEFT_BUTTON;
pub const RIGHT_BUTTON = MouseButton.RIGHT_BUTTON;
pub const MIDDLE_BUTTON = MouseButton.MIDDLE_BUTTON;

pub const SelAlignmentConstants = enum(i32) {
    Left = 0,
    Right = 1,
    Center = 2,
};
pub const rtfLeft = SelAlignmentConstants.Left;
pub const rtfRight = SelAlignmentConstants.Right;
pub const rtfCenter = SelAlignmentConstants.Center;

pub const DISPID_InkEdit = enum(i32) {
    Text = 0,
    TextRTF = 1,
    Hwnd = 2,
    DisableNoScroll = 3,
    Locked = 4,
    Enabled = 5,
    MaxLength = 6,
    MultiLine = 7,
    ScrollBars = 8,
    RTSelStart = 9,
    RTSelLength = 10,
    RTSelText = 11,
    SelAlignment = 12,
    SelBold = 13,
    SelCharOffset = 14,
    SelColor = 15,
    SelFontName = 16,
    SelFontSize = 17,
    SelItalic = 18,
    SelRTF = 19,
    SelUnderline = 20,
    DragIcon = 21,
    Status = 22,
    UseMouseForInput = 23,
    InkMode = 24,
    InkInsertMode = 25,
    RecoTimeout = 26,
    DrawAttr = 27,
    Recognizer = 28,
    Factoid = 29,
    SelInk = 30,
    SelInksDisplayMode = 31,
    Recognize = 32,
    GetGestStatus = 33,
    SetGestStatus = 34,
    Refresh = 35,
};
pub const DISPID_Text = DISPID_InkEdit.Text;
pub const DISPID_TextRTF = DISPID_InkEdit.TextRTF;
pub const DISPID_Hwnd = DISPID_InkEdit.Hwnd;
pub const DISPID_DisableNoScroll = DISPID_InkEdit.DisableNoScroll;
pub const DISPID_Locked = DISPID_InkEdit.Locked;
pub const DISPID_Enabled = DISPID_InkEdit.Enabled;
pub const DISPID_MaxLength = DISPID_InkEdit.MaxLength;
pub const DISPID_MultiLine = DISPID_InkEdit.MultiLine;
pub const DISPID_ScrollBars = DISPID_InkEdit.ScrollBars;
pub const DISPID_RTSelStart = DISPID_InkEdit.RTSelStart;
pub const DISPID_RTSelLength = DISPID_InkEdit.RTSelLength;
pub const DISPID_RTSelText = DISPID_InkEdit.RTSelText;
pub const DISPID_SelAlignment = DISPID_InkEdit.SelAlignment;
pub const DISPID_SelBold = DISPID_InkEdit.SelBold;
pub const DISPID_SelCharOffset = DISPID_InkEdit.SelCharOffset;
pub const DISPID_SelColor = DISPID_InkEdit.SelColor;
pub const DISPID_SelFontName = DISPID_InkEdit.SelFontName;
pub const DISPID_SelFontSize = DISPID_InkEdit.SelFontSize;
pub const DISPID_SelItalic = DISPID_InkEdit.SelItalic;
pub const DISPID_SelRTF = DISPID_InkEdit.SelRTF;
pub const DISPID_SelUnderline = DISPID_InkEdit.SelUnderline;
pub const DISPID_DragIcon = DISPID_InkEdit.DragIcon;
pub const DISPID_Status = DISPID_InkEdit.Status;
pub const DISPID_UseMouseForInput = DISPID_InkEdit.UseMouseForInput;
pub const DISPID_InkMode = DISPID_InkEdit.InkMode;
pub const DISPID_InkInsertMode = DISPID_InkEdit.InkInsertMode;
pub const DISPID_RecoTimeout = DISPID_InkEdit.RecoTimeout;
pub const DISPID_DrawAttr = DISPID_InkEdit.DrawAttr;
pub const DISPID_Recognizer = DISPID_InkEdit.Recognizer;
pub const DISPID_Factoid = DISPID_InkEdit.Factoid;
pub const DISPID_SelInk = DISPID_InkEdit.SelInk;
pub const DISPID_SelInksDisplayMode = DISPID_InkEdit.SelInksDisplayMode;
pub const DISPID_Recognize = DISPID_InkEdit.Recognize;
pub const DISPID_GetGestStatus = DISPID_InkEdit.GetGestStatus;
pub const DISPID_SetGestStatus = DISPID_InkEdit.SetGestStatus;
pub const DISPID_Refresh = DISPID_InkEdit.Refresh;

pub const DISPID_InkEditEvents = enum(i32) {
    Change = 1,
    SelChange = 2,
    KeyDown = 3,
    KeyUp = 4,
    MouseUp = 5,
    MouseDown = 6,
    KeyPress = 7,
    DblClick = 8,
    Click = 9,
    MouseMove = 10,
    CursorDown = 21,
    Stroke = 22,
    Gesture = 23,
    RecognitionResult = 24,
};
pub const DISPID_IeeChange = DISPID_InkEditEvents.Change;
pub const DISPID_IeeSelChange = DISPID_InkEditEvents.SelChange;
pub const DISPID_IeeKeyDown = DISPID_InkEditEvents.KeyDown;
pub const DISPID_IeeKeyUp = DISPID_InkEditEvents.KeyUp;
pub const DISPID_IeeMouseUp = DISPID_InkEditEvents.MouseUp;
pub const DISPID_IeeMouseDown = DISPID_InkEditEvents.MouseDown;
pub const DISPID_IeeKeyPress = DISPID_InkEditEvents.KeyPress;
pub const DISPID_IeeDblClick = DISPID_InkEditEvents.DblClick;
pub const DISPID_IeeClick = DISPID_InkEditEvents.Click;
pub const DISPID_IeeMouseMove = DISPID_InkEditEvents.MouseMove;
pub const DISPID_IeeCursorDown = DISPID_InkEditEvents.CursorDown;
pub const DISPID_IeeStroke = DISPID_InkEditEvents.Stroke;
pub const DISPID_IeeGesture = DISPID_InkEditEvents.Gesture;
pub const DISPID_IeeRecognitionResult = DISPID_InkEditEvents.RecognitionResult;

pub const InkMode = enum(i32) {
    Disabled = 0,
    Ink = 1,
    InkAndGesture = 2,
};
pub const IEM_Disabled = InkMode.Disabled;
pub const IEM_Ink = InkMode.Ink;
pub const IEM_InkAndGesture = InkMode.InkAndGesture;

pub const InkInsertMode = enum(i32) {
    Text = 0,
    Ink = 1,
};
pub const IEM_InsertText = InkInsertMode.Text;
pub const IEM_InsertInk = InkInsertMode.Ink;

pub const InkEditStatus = enum(i32) {
    Idle = 0,
    Collecting = 1,
    Recognizing = 2,
};
pub const IES_Idle = InkEditStatus.Idle;
pub const IES_Collecting = InkEditStatus.Collecting;
pub const IES_Recognizing = InkEditStatus.Recognizing;

pub const InkDisplayMode = enum(i32) {
    Ink = 0,
    Text = 1,
};
pub const IDM_Ink = InkDisplayMode.Ink;
pub const IDM_Text = InkDisplayMode.Text;

pub const AppearanceConstants = enum(i32) {
    Flat = 0,
    ThreeD = 1,
};
pub const rtfFlat = AppearanceConstants.Flat;
pub const rtfThreeD = AppearanceConstants.ThreeD;

pub const BorderStyleConstants = enum(i32) {
    NoBorder = 0,
    FixedSingle = 1,
};
pub const rtfNoBorder = BorderStyleConstants.NoBorder;
pub const rtfFixedSingle = BorderStyleConstants.FixedSingle;

pub const ScrollBarsConstants = enum(i32) {
    None = 0,
    Horizontal = 1,
    Vertical = 2,
    Both = 3,
};
pub const rtfNone = ScrollBarsConstants.None;
pub const rtfHorizontal = ScrollBarsConstants.Horizontal;
pub const rtfVertical = ScrollBarsConstants.Vertical;
pub const rtfBoth = ScrollBarsConstants.Both;

const IID_IInkEdit_Value = Guid.initString("f2127a19-fbfb-4aed-8464-3f36d78cfefb");
pub const IID_IInkEdit = &IID_IInkEdit_Value;
pub const IInkEdit = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Status: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkEdit,
                pStatus: ?*InkEditStatus,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkEdit,
                pStatus: ?*InkEditStatus,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UseMouseForInput: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkEdit,
                pVal: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkEdit,
                pVal: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_UseMouseForInput: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkEdit,
                newVal: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkEdit,
                newVal: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InkMode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkEdit,
                pVal: ?*InkMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkEdit,
                pVal: ?*InkMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_InkMode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkEdit,
                newVal: InkMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkEdit,
                newVal: InkMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InkInsertMode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkEdit,
                pVal: ?*InkInsertMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkEdit,
                pVal: ?*InkInsertMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_InkInsertMode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkEdit,
                newVal: InkInsertMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkEdit,
                newVal: InkInsertMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DrawingAttributes: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkEdit,
                pVal: ?*?*IInkDrawingAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkEdit,
                pVal: ?*?*IInkDrawingAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        putref_DrawingAttributes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkEdit,
                newVal: ?*IInkDrawingAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkEdit,
                newVal: ?*IInkDrawingAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RecognitionTimeout: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkEdit,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkEdit,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_RecognitionTimeout: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkEdit,
                newVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkEdit,
                newVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Recognizer: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkEdit,
                pVal: ?*?*IInkRecognizer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkEdit,
                pVal: ?*?*IInkRecognizer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        putref_Recognizer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkEdit,
                newVal: ?*IInkRecognizer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkEdit,
                newVal: ?*IInkRecognizer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Factoid: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkEdit,
                pVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkEdit,
                pVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Factoid: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkEdit,
                newVal: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkEdit,
                newVal: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SelInks: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkEdit,
                pSelInk: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkEdit,
                pSelInk: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SelInks: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkEdit,
                SelInk: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkEdit,
                SelInk: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SelInksDisplayMode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkEdit,
                pInkDisplayMode: ?*InkDisplayMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkEdit,
                pInkDisplayMode: ?*InkDisplayMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SelInksDisplayMode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkEdit,
                InkDisplayMode: InkDisplayMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkEdit,
                InkDisplayMode: InkDisplayMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Recognize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkEdit,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkEdit,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetGestureStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkEdit,
                Gesture: InkApplicationGesture,
                pListen: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkEdit,
                Gesture: InkApplicationGesture,
                pListen: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetGestureStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkEdit,
                Gesture: InkApplicationGesture,
                Listen: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkEdit,
                Gesture: InkApplicationGesture,
                Listen: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BackColor: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkEdit,
                clr: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkEdit,
                clr: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BackColor: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkEdit,
                pclr: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkEdit,
                pclr: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Appearance: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkEdit,
                pAppearance: ?*AppearanceConstants,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkEdit,
                pAppearance: ?*AppearanceConstants,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Appearance: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkEdit,
                pAppearance: AppearanceConstants,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkEdit,
                pAppearance: AppearanceConstants,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BorderStyle: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkEdit,
                pBorderStyle: ?*BorderStyleConstants,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkEdit,
                pBorderStyle: ?*BorderStyleConstants,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BorderStyle: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkEdit,
                pBorderStyle: BorderStyleConstants,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkEdit,
                pBorderStyle: BorderStyleConstants,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Hwnd: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkEdit,
                pohHwnd: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkEdit,
                pohHwnd: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Font: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkEdit,
                ppFont: ?*?*IFontDisp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkEdit,
                ppFont: ?*?*IFontDisp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        putref_Font: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkEdit,
                ppFont: ?*IFontDisp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkEdit,
                ppFont: ?*IFontDisp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Text: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkEdit,
                pbstrText: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkEdit,
                pbstrText: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Text: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkEdit,
                pbstrText: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkEdit,
                pbstrText: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MouseIcon: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkEdit,
                MouseIcon: ?*?*IPictureDisp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkEdit,
                MouseIcon: ?*?*IPictureDisp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MouseIcon: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkEdit,
                MouseIcon: ?*IPictureDisp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkEdit,
                MouseIcon: ?*IPictureDisp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        putref_MouseIcon: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkEdit,
                MouseIcon: ?*IPictureDisp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkEdit,
                MouseIcon: ?*IPictureDisp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MousePointer: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkEdit,
                MousePointer: ?*InkMousePointer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkEdit,
                MousePointer: ?*InkMousePointer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MousePointer: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkEdit,
                MousePointer: InkMousePointer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkEdit,
                MousePointer: InkMousePointer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Locked: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkEdit,
                pVal: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkEdit,
                pVal: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Locked: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkEdit,
                newVal: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkEdit,
                newVal: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Enabled: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkEdit,
                pVal: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkEdit,
                pVal: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Enabled: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkEdit,
                newVal: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkEdit,
                newVal: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MaxLength: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkEdit,
                plMaxLength: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkEdit,
                plMaxLength: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MaxLength: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkEdit,
                lMaxLength: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkEdit,
                lMaxLength: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MultiLine: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkEdit,
                pVal: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkEdit,
                pVal: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MultiLine: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkEdit,
                newVal: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkEdit,
                newVal: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ScrollBars: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkEdit,
                pVal: ?*ScrollBarsConstants,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkEdit,
                pVal: ?*ScrollBarsConstants,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ScrollBars: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkEdit,
                newVal: ScrollBarsConstants,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkEdit,
                newVal: ScrollBarsConstants,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DisableNoScroll: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkEdit,
                pVal: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkEdit,
                pVal: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DisableNoScroll: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkEdit,
                newVal: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkEdit,
                newVal: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SelAlignment: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkEdit,
                pvarSelAlignment: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkEdit,
                pvarSelAlignment: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SelAlignment: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkEdit,
                pvarSelAlignment: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkEdit,
                pvarSelAlignment: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SelBold: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkEdit,
                pvarSelBold: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkEdit,
                pvarSelBold: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SelBold: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkEdit,
                pvarSelBold: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkEdit,
                pvarSelBold: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SelItalic: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkEdit,
                pvarSelItalic: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkEdit,
                pvarSelItalic: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SelItalic: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkEdit,
                pvarSelItalic: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkEdit,
                pvarSelItalic: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SelUnderline: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkEdit,
                pvarSelUnderline: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkEdit,
                pvarSelUnderline: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SelUnderline: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkEdit,
                pvarSelUnderline: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkEdit,
                pvarSelUnderline: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SelColor: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkEdit,
                pvarSelColor: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkEdit,
                pvarSelColor: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SelColor: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkEdit,
                pvarSelColor: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkEdit,
                pvarSelColor: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SelFontName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkEdit,
                pvarSelFontName: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkEdit,
                pvarSelFontName: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SelFontName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkEdit,
                pvarSelFontName: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkEdit,
                pvarSelFontName: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SelFontSize: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkEdit,
                pvarSelFontSize: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkEdit,
                pvarSelFontSize: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SelFontSize: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkEdit,
                pvarSelFontSize: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkEdit,
                pvarSelFontSize: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SelCharOffset: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkEdit,
                pvarSelCharOffset: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkEdit,
                pvarSelCharOffset: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SelCharOffset: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkEdit,
                pvarSelCharOffset: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkEdit,
                pvarSelCharOffset: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TextRTF: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkEdit,
                pbstrTextRTF: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkEdit,
                pbstrTextRTF: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_TextRTF: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkEdit,
                pbstrTextRTF: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkEdit,
                pbstrTextRTF: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SelStart: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkEdit,
                plSelStart: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkEdit,
                plSelStart: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SelStart: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkEdit,
                plSelStart: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkEdit,
                plSelStart: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SelLength: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkEdit,
                plSelLength: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkEdit,
                plSelLength: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SelLength: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkEdit,
                plSelLength: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkEdit,
                plSelLength: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SelText: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkEdit,
                pbstrSelText: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkEdit,
                pbstrSelText: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SelText: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkEdit,
                pbstrSelText: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkEdit,
                pbstrSelText: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SelRTF: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkEdit,
                pbstrSelRTF: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkEdit,
                pbstrSelRTF: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SelRTF: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IInkEdit,
                pbstrSelRTF: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IInkEdit,
                pbstrSelRTF: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Refresh: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInkEdit,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInkEdit,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkEdit_get_Status(self: *const T, pStatus: ?*InkEditStatus) HRESULT {
                return @as(*const IInkEdit.VTable, @ptrCast(self.vtable)).get_Status(@as(*const IInkEdit, @ptrCast(self)), pStatus);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkEdit_get_UseMouseForInput(self: *const T, pVal: ?*i16) HRESULT {
                return @as(*const IInkEdit.VTable, @ptrCast(self.vtable)).get_UseMouseForInput(@as(*const IInkEdit, @ptrCast(self)), pVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkEdit_put_UseMouseForInput(self: *const T, newVal: i16) HRESULT {
                return @as(*const IInkEdit.VTable, @ptrCast(self.vtable)).put_UseMouseForInput(@as(*const IInkEdit, @ptrCast(self)), newVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkEdit_get_InkMode(self: *const T, pVal: ?*InkMode) HRESULT {
                return @as(*const IInkEdit.VTable, @ptrCast(self.vtable)).get_InkMode(@as(*const IInkEdit, @ptrCast(self)), pVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkEdit_put_InkMode(self: *const T, newVal: InkMode) HRESULT {
                return @as(*const IInkEdit.VTable, @ptrCast(self.vtable)).put_InkMode(@as(*const IInkEdit, @ptrCast(self)), newVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkEdit_get_InkInsertMode(self: *const T, pVal: ?*InkInsertMode) HRESULT {
                return @as(*const IInkEdit.VTable, @ptrCast(self.vtable)).get_InkInsertMode(@as(*const IInkEdit, @ptrCast(self)), pVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkEdit_put_InkInsertMode(self: *const T, newVal: InkInsertMode) HRESULT {
                return @as(*const IInkEdit.VTable, @ptrCast(self.vtable)).put_InkInsertMode(@as(*const IInkEdit, @ptrCast(self)), newVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkEdit_get_DrawingAttributes(self: *const T, pVal: ?*?*IInkDrawingAttributes) HRESULT {
                return @as(*const IInkEdit.VTable, @ptrCast(self.vtable)).get_DrawingAttributes(@as(*const IInkEdit, @ptrCast(self)), pVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkEdit_putref_DrawingAttributes(self: *const T, newVal: ?*IInkDrawingAttributes) HRESULT {
                return @as(*const IInkEdit.VTable, @ptrCast(self.vtable)).putref_DrawingAttributes(@as(*const IInkEdit, @ptrCast(self)), newVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkEdit_get_RecognitionTimeout(self: *const T, pVal: ?*i32) HRESULT {
                return @as(*const IInkEdit.VTable, @ptrCast(self.vtable)).get_RecognitionTimeout(@as(*const IInkEdit, @ptrCast(self)), pVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkEdit_put_RecognitionTimeout(self: *const T, newVal: i32) HRESULT {
                return @as(*const IInkEdit.VTable, @ptrCast(self.vtable)).put_RecognitionTimeout(@as(*const IInkEdit, @ptrCast(self)), newVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkEdit_get_Recognizer(self: *const T, pVal: ?*?*IInkRecognizer) HRESULT {
                return @as(*const IInkEdit.VTable, @ptrCast(self.vtable)).get_Recognizer(@as(*const IInkEdit, @ptrCast(self)), pVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkEdit_putref_Recognizer(self: *const T, newVal: ?*IInkRecognizer) HRESULT {
                return @as(*const IInkEdit.VTable, @ptrCast(self.vtable)).putref_Recognizer(@as(*const IInkEdit, @ptrCast(self)), newVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkEdit_get_Factoid(self: *const T, pVal: ?*?BSTR) HRESULT {
                return @as(*const IInkEdit.VTable, @ptrCast(self.vtable)).get_Factoid(@as(*const IInkEdit, @ptrCast(self)), pVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkEdit_put_Factoid(self: *const T, newVal: ?BSTR) HRESULT {
                return @as(*const IInkEdit.VTable, @ptrCast(self.vtable)).put_Factoid(@as(*const IInkEdit, @ptrCast(self)), newVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkEdit_get_SelInks(self: *const T, pSelInk: ?*VARIANT) HRESULT {
                return @as(*const IInkEdit.VTable, @ptrCast(self.vtable)).get_SelInks(@as(*const IInkEdit, @ptrCast(self)), pSelInk);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkEdit_put_SelInks(self: *const T, SelInk: VARIANT) HRESULT {
                return @as(*const IInkEdit.VTable, @ptrCast(self.vtable)).put_SelInks(@as(*const IInkEdit, @ptrCast(self)), SelInk);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkEdit_get_SelInksDisplayMode(self: *const T, pInkDisplayMode: ?*InkDisplayMode) HRESULT {
                return @as(*const IInkEdit.VTable, @ptrCast(self.vtable)).get_SelInksDisplayMode(@as(*const IInkEdit, @ptrCast(self)), pInkDisplayMode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkEdit_put_SelInksDisplayMode(self: *const T, _param_InkDisplayMode: InkDisplayMode) HRESULT {
                return @as(*const IInkEdit.VTable, @ptrCast(self.vtable)).put_SelInksDisplayMode(@as(*const IInkEdit, @ptrCast(self)), _param_InkDisplayMode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkEdit_Recognize(self: *const T) HRESULT {
                return @as(*const IInkEdit.VTable, @ptrCast(self.vtable)).Recognize(@as(*const IInkEdit, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkEdit_GetGestureStatus(self: *const T, Gesture: InkApplicationGesture, pListen: ?*i16) HRESULT {
                return @as(*const IInkEdit.VTable, @ptrCast(self.vtable)).GetGestureStatus(@as(*const IInkEdit, @ptrCast(self)), Gesture, pListen);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkEdit_SetGestureStatus(self: *const T, Gesture: InkApplicationGesture, Listen: i16) HRESULT {
                return @as(*const IInkEdit.VTable, @ptrCast(self.vtable)).SetGestureStatus(@as(*const IInkEdit, @ptrCast(self)), Gesture, Listen);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkEdit_put_BackColor(self: *const T, clr: u32) HRESULT {
                return @as(*const IInkEdit.VTable, @ptrCast(self.vtable)).put_BackColor(@as(*const IInkEdit, @ptrCast(self)), clr);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkEdit_get_BackColor(self: *const T, pclr: ?*u32) HRESULT {
                return @as(*const IInkEdit.VTable, @ptrCast(self.vtable)).get_BackColor(@as(*const IInkEdit, @ptrCast(self)), pclr);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkEdit_get_Appearance(self: *const T, pAppearance: ?*AppearanceConstants) HRESULT {
                return @as(*const IInkEdit.VTable, @ptrCast(self.vtable)).get_Appearance(@as(*const IInkEdit, @ptrCast(self)), pAppearance);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkEdit_put_Appearance(self: *const T, pAppearance: AppearanceConstants) HRESULT {
                return @as(*const IInkEdit.VTable, @ptrCast(self.vtable)).put_Appearance(@as(*const IInkEdit, @ptrCast(self)), pAppearance);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkEdit_get_BorderStyle(self: *const T, pBorderStyle: ?*BorderStyleConstants) HRESULT {
                return @as(*const IInkEdit.VTable, @ptrCast(self.vtable)).get_BorderStyle(@as(*const IInkEdit, @ptrCast(self)), pBorderStyle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkEdit_put_BorderStyle(self: *const T, pBorderStyle: BorderStyleConstants) HRESULT {
                return @as(*const IInkEdit.VTable, @ptrCast(self.vtable)).put_BorderStyle(@as(*const IInkEdit, @ptrCast(self)), pBorderStyle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkEdit_get_Hwnd(self: *const T, pohHwnd: ?*u32) HRESULT {
                return @as(*const IInkEdit.VTable, @ptrCast(self.vtable)).get_Hwnd(@as(*const IInkEdit, @ptrCast(self)), pohHwnd);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkEdit_get_Font(self: *const T, ppFont: ?*?*IFontDisp) HRESULT {
                return @as(*const IInkEdit.VTable, @ptrCast(self.vtable)).get_Font(@as(*const IInkEdit, @ptrCast(self)), ppFont);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkEdit_putref_Font(self: *const T, ppFont: ?*IFontDisp) HRESULT {
                return @as(*const IInkEdit.VTable, @ptrCast(self.vtable)).putref_Font(@as(*const IInkEdit, @ptrCast(self)), ppFont);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkEdit_get_Text(self: *const T, pbstrText: ?*?BSTR) HRESULT {
                return @as(*const IInkEdit.VTable, @ptrCast(self.vtable)).get_Text(@as(*const IInkEdit, @ptrCast(self)), pbstrText);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkEdit_put_Text(self: *const T, pbstrText: ?BSTR) HRESULT {
                return @as(*const IInkEdit.VTable, @ptrCast(self.vtable)).put_Text(@as(*const IInkEdit, @ptrCast(self)), pbstrText);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkEdit_get_MouseIcon(self: *const T, MouseIcon: ?*?*IPictureDisp) HRESULT {
                return @as(*const IInkEdit.VTable, @ptrCast(self.vtable)).get_MouseIcon(@as(*const IInkEdit, @ptrCast(self)), MouseIcon);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkEdit_put_MouseIcon(self: *const T, MouseIcon: ?*IPictureDisp) HRESULT {
                return @as(*const IInkEdit.VTable, @ptrCast(self.vtable)).put_MouseIcon(@as(*const IInkEdit, @ptrCast(self)), MouseIcon);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkEdit_putref_MouseIcon(self: *const T, MouseIcon: ?*IPictureDisp) HRESULT {
                return @as(*const IInkEdit.VTable, @ptrCast(self.vtable)).putref_MouseIcon(@as(*const IInkEdit, @ptrCast(self)), MouseIcon);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkEdit_get_MousePointer(self: *const T, MousePointer: ?*InkMousePointer) HRESULT {
                return @as(*const IInkEdit.VTable, @ptrCast(self.vtable)).get_MousePointer(@as(*const IInkEdit, @ptrCast(self)), MousePointer);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkEdit_put_MousePointer(self: *const T, MousePointer: InkMousePointer) HRESULT {
                return @as(*const IInkEdit.VTable, @ptrCast(self.vtable)).put_MousePointer(@as(*const IInkEdit, @ptrCast(self)), MousePointer);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkEdit_get_Locked(self: *const T, pVal: ?*i16) HRESULT {
                return @as(*const IInkEdit.VTable, @ptrCast(self.vtable)).get_Locked(@as(*const IInkEdit, @ptrCast(self)), pVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkEdit_put_Locked(self: *const T, newVal: i16) HRESULT {
                return @as(*const IInkEdit.VTable, @ptrCast(self.vtable)).put_Locked(@as(*const IInkEdit, @ptrCast(self)), newVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkEdit_get_Enabled(self: *const T, pVal: ?*i16) HRESULT {
                return @as(*const IInkEdit.VTable, @ptrCast(self.vtable)).get_Enabled(@as(*const IInkEdit, @ptrCast(self)), pVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkEdit_put_Enabled(self: *const T, newVal: i16) HRESULT {
                return @as(*const IInkEdit.VTable, @ptrCast(self.vtable)).put_Enabled(@as(*const IInkEdit, @ptrCast(self)), newVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkEdit_get_MaxLength(self: *const T, plMaxLength: ?*i32) HRESULT {
                return @as(*const IInkEdit.VTable, @ptrCast(self.vtable)).get_MaxLength(@as(*const IInkEdit, @ptrCast(self)), plMaxLength);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkEdit_put_MaxLength(self: *const T, lMaxLength: i32) HRESULT {
                return @as(*const IInkEdit.VTable, @ptrCast(self.vtable)).put_MaxLength(@as(*const IInkEdit, @ptrCast(self)), lMaxLength);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkEdit_get_MultiLine(self: *const T, pVal: ?*i16) HRESULT {
                return @as(*const IInkEdit.VTable, @ptrCast(self.vtable)).get_MultiLine(@as(*const IInkEdit, @ptrCast(self)), pVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkEdit_put_MultiLine(self: *const T, newVal: i16) HRESULT {
                return @as(*const IInkEdit.VTable, @ptrCast(self.vtable)).put_MultiLine(@as(*const IInkEdit, @ptrCast(self)), newVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkEdit_get_ScrollBars(self: *const T, pVal: ?*ScrollBarsConstants) HRESULT {
                return @as(*const IInkEdit.VTable, @ptrCast(self.vtable)).get_ScrollBars(@as(*const IInkEdit, @ptrCast(self)), pVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkEdit_put_ScrollBars(self: *const T, newVal: ScrollBarsConstants) HRESULT {
                return @as(*const IInkEdit.VTable, @ptrCast(self.vtable)).put_ScrollBars(@as(*const IInkEdit, @ptrCast(self)), newVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkEdit_get_DisableNoScroll(self: *const T, pVal: ?*i16) HRESULT {
                return @as(*const IInkEdit.VTable, @ptrCast(self.vtable)).get_DisableNoScroll(@as(*const IInkEdit, @ptrCast(self)), pVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkEdit_put_DisableNoScroll(self: *const T, newVal: i16) HRESULT {
                return @as(*const IInkEdit.VTable, @ptrCast(self.vtable)).put_DisableNoScroll(@as(*const IInkEdit, @ptrCast(self)), newVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkEdit_get_SelAlignment(self: *const T, pvarSelAlignment: ?*VARIANT) HRESULT {
                return @as(*const IInkEdit.VTable, @ptrCast(self.vtable)).get_SelAlignment(@as(*const IInkEdit, @ptrCast(self)), pvarSelAlignment);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkEdit_put_SelAlignment(self: *const T, pvarSelAlignment: VARIANT) HRESULT {
                return @as(*const IInkEdit.VTable, @ptrCast(self.vtable)).put_SelAlignment(@as(*const IInkEdit, @ptrCast(self)), pvarSelAlignment);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkEdit_get_SelBold(self: *const T, pvarSelBold: ?*VARIANT) HRESULT {
                return @as(*const IInkEdit.VTable, @ptrCast(self.vtable)).get_SelBold(@as(*const IInkEdit, @ptrCast(self)), pvarSelBold);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkEdit_put_SelBold(self: *const T, pvarSelBold: VARIANT) HRESULT {
                return @as(*const IInkEdit.VTable, @ptrCast(self.vtable)).put_SelBold(@as(*const IInkEdit, @ptrCast(self)), pvarSelBold);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkEdit_get_SelItalic(self: *const T, pvarSelItalic: ?*VARIANT) HRESULT {
                return @as(*const IInkEdit.VTable, @ptrCast(self.vtable)).get_SelItalic(@as(*const IInkEdit, @ptrCast(self)), pvarSelItalic);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkEdit_put_SelItalic(self: *const T, pvarSelItalic: VARIANT) HRESULT {
                return @as(*const IInkEdit.VTable, @ptrCast(self.vtable)).put_SelItalic(@as(*const IInkEdit, @ptrCast(self)), pvarSelItalic);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkEdit_get_SelUnderline(self: *const T, pvarSelUnderline: ?*VARIANT) HRESULT {
                return @as(*const IInkEdit.VTable, @ptrCast(self.vtable)).get_SelUnderline(@as(*const IInkEdit, @ptrCast(self)), pvarSelUnderline);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkEdit_put_SelUnderline(self: *const T, pvarSelUnderline: VARIANT) HRESULT {
                return @as(*const IInkEdit.VTable, @ptrCast(self.vtable)).put_SelUnderline(@as(*const IInkEdit, @ptrCast(self)), pvarSelUnderline);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkEdit_get_SelColor(self: *const T, pvarSelColor: ?*VARIANT) HRESULT {
                return @as(*const IInkEdit.VTable, @ptrCast(self.vtable)).get_SelColor(@as(*const IInkEdit, @ptrCast(self)), pvarSelColor);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkEdit_put_SelColor(self: *const T, pvarSelColor: VARIANT) HRESULT {
                return @as(*const IInkEdit.VTable, @ptrCast(self.vtable)).put_SelColor(@as(*const IInkEdit, @ptrCast(self)), pvarSelColor);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkEdit_get_SelFontName(self: *const T, pvarSelFontName: ?*VARIANT) HRESULT {
                return @as(*const IInkEdit.VTable, @ptrCast(self.vtable)).get_SelFontName(@as(*const IInkEdit, @ptrCast(self)), pvarSelFontName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkEdit_put_SelFontName(self: *const T, pvarSelFontName: VARIANT) HRESULT {
                return @as(*const IInkEdit.VTable, @ptrCast(self.vtable)).put_SelFontName(@as(*const IInkEdit, @ptrCast(self)), pvarSelFontName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkEdit_get_SelFontSize(self: *const T, pvarSelFontSize: ?*VARIANT) HRESULT {
                return @as(*const IInkEdit.VTable, @ptrCast(self.vtable)).get_SelFontSize(@as(*const IInkEdit, @ptrCast(self)), pvarSelFontSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkEdit_put_SelFontSize(self: *const T, pvarSelFontSize: VARIANT) HRESULT {
                return @as(*const IInkEdit.VTable, @ptrCast(self.vtable)).put_SelFontSize(@as(*const IInkEdit, @ptrCast(self)), pvarSelFontSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkEdit_get_SelCharOffset(self: *const T, pvarSelCharOffset: ?*VARIANT) HRESULT {
                return @as(*const IInkEdit.VTable, @ptrCast(self.vtable)).get_SelCharOffset(@as(*const IInkEdit, @ptrCast(self)), pvarSelCharOffset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkEdit_put_SelCharOffset(self: *const T, pvarSelCharOffset: VARIANT) HRESULT {
                return @as(*const IInkEdit.VTable, @ptrCast(self.vtable)).put_SelCharOffset(@as(*const IInkEdit, @ptrCast(self)), pvarSelCharOffset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkEdit_get_TextRTF(self: *const T, pbstrTextRTF: ?*?BSTR) HRESULT {
                return @as(*const IInkEdit.VTable, @ptrCast(self.vtable)).get_TextRTF(@as(*const IInkEdit, @ptrCast(self)), pbstrTextRTF);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkEdit_put_TextRTF(self: *const T, pbstrTextRTF: ?BSTR) HRESULT {
                return @as(*const IInkEdit.VTable, @ptrCast(self.vtable)).put_TextRTF(@as(*const IInkEdit, @ptrCast(self)), pbstrTextRTF);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkEdit_get_SelStart(self: *const T, plSelStart: ?*i32) HRESULT {
                return @as(*const IInkEdit.VTable, @ptrCast(self.vtable)).get_SelStart(@as(*const IInkEdit, @ptrCast(self)), plSelStart);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkEdit_put_SelStart(self: *const T, plSelStart: i32) HRESULT {
                return @as(*const IInkEdit.VTable, @ptrCast(self.vtable)).put_SelStart(@as(*const IInkEdit, @ptrCast(self)), plSelStart);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkEdit_get_SelLength(self: *const T, plSelLength: ?*i32) HRESULT {
                return @as(*const IInkEdit.VTable, @ptrCast(self.vtable)).get_SelLength(@as(*const IInkEdit, @ptrCast(self)), plSelLength);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkEdit_put_SelLength(self: *const T, plSelLength: i32) HRESULT {
                return @as(*const IInkEdit.VTable, @ptrCast(self.vtable)).put_SelLength(@as(*const IInkEdit, @ptrCast(self)), plSelLength);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkEdit_get_SelText(self: *const T, pbstrSelText: ?*?BSTR) HRESULT {
                return @as(*const IInkEdit.VTable, @ptrCast(self.vtable)).get_SelText(@as(*const IInkEdit, @ptrCast(self)), pbstrSelText);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkEdit_put_SelText(self: *const T, pbstrSelText: ?BSTR) HRESULT {
                return @as(*const IInkEdit.VTable, @ptrCast(self.vtable)).put_SelText(@as(*const IInkEdit, @ptrCast(self)), pbstrSelText);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkEdit_get_SelRTF(self: *const T, pbstrSelRTF: ?*?BSTR) HRESULT {
                return @as(*const IInkEdit.VTable, @ptrCast(self.vtable)).get_SelRTF(@as(*const IInkEdit, @ptrCast(self)), pbstrSelRTF);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkEdit_put_SelRTF(self: *const T, pbstrSelRTF: ?BSTR) HRESULT {
                return @as(*const IInkEdit.VTable, @ptrCast(self.vtable)).put_SelRTF(@as(*const IInkEdit, @ptrCast(self)), pbstrSelRTF);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInkEdit_Refresh(self: *const T) HRESULT {
                return @as(*const IInkEdit.VTable, @ptrCast(self.vtable)).Refresh(@as(*const IInkEdit, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID__IInkEditEvents_Value = Guid.initString("e3b0b797-a72e-46db-a0d7-6c9eba8e9bbc");
pub const IID__IInkEditEvents = &IID__IInkEditEvents_Value;
pub const _IInkEditEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const CLSID_MathInputControl_Value = Guid.initString("c561816c-14d8-4090-830c-98d994b21c7b");
pub const CLSID_MathInputControl = &CLSID_MathInputControl_Value;

pub const MICUIELEMENT = enum(i32) {
    BUTTON_WRITE = 1,
    BUTTON_ERASE = 2,
    BUTTON_CORRECT = 4,
    BUTTON_CLEAR = 8,
    BUTTON_UNDO = 16,
    BUTTON_REDO = 32,
    BUTTON_INSERT = 64,
    BUTTON_CANCEL = 128,
    INKPANEL_BACKGROUND = 256,
    RESULTPANEL_BACKGROUND = 512,
};
pub const MICUIELEMENT_BUTTON_WRITE = MICUIELEMENT.BUTTON_WRITE;
pub const MICUIELEMENT_BUTTON_ERASE = MICUIELEMENT.BUTTON_ERASE;
pub const MICUIELEMENT_BUTTON_CORRECT = MICUIELEMENT.BUTTON_CORRECT;
pub const MICUIELEMENT_BUTTON_CLEAR = MICUIELEMENT.BUTTON_CLEAR;
pub const MICUIELEMENT_BUTTON_UNDO = MICUIELEMENT.BUTTON_UNDO;
pub const MICUIELEMENT_BUTTON_REDO = MICUIELEMENT.BUTTON_REDO;
pub const MICUIELEMENT_BUTTON_INSERT = MICUIELEMENT.BUTTON_INSERT;
pub const MICUIELEMENT_BUTTON_CANCEL = MICUIELEMENT.BUTTON_CANCEL;
pub const MICUIELEMENT_INKPANEL_BACKGROUND = MICUIELEMENT.INKPANEL_BACKGROUND;
pub const MICUIELEMENT_RESULTPANEL_BACKGROUND = MICUIELEMENT.RESULTPANEL_BACKGROUND;

pub const MICUIELEMENTSTATE = enum(i32) {
    NORMAL = 1,
    HOT = 2,
    PRESSED = 3,
    DISABLED = 4,
};
pub const MICUIELEMENTSTATE_NORMAL = MICUIELEMENTSTATE.NORMAL;
pub const MICUIELEMENTSTATE_HOT = MICUIELEMENTSTATE.HOT;
pub const MICUIELEMENTSTATE_PRESSED = MICUIELEMENTSTATE.PRESSED;
pub const MICUIELEMENTSTATE_DISABLED = MICUIELEMENTSTATE.DISABLED;

pub const DISPID_MathInputControlEvents = enum(i32) {
    Insert = 0,
    Close = 1,
    Paint = 2,
    Clear = 3,
};
pub const DISPID_MICInsert = DISPID_MathInputControlEvents.Insert;
pub const DISPID_MICClose = DISPID_MathInputControlEvents.Close;
pub const DISPID_MICPaint = DISPID_MathInputControlEvents.Paint;
pub const DISPID_MICClear = DISPID_MathInputControlEvents.Clear;

const IID_IMathInputControl_Value = Guid.initString("eba615aa-fac6-4738-ba5f-ff09e9fe473e");
pub const IID_IMathInputControl = &IID_IMathInputControl_Value;
pub const IMathInputControl = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Show: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMathInputControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMathInputControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Hide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMathInputControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMathInputControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsVisible: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMathInputControl,
                pvbShown: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMathInputControl,
                pvbShown: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMathInputControl,
                Left: ?*i32,
                Top: ?*i32,
                Right: ?*i32,
                Bottom: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMathInputControl,
                Left: ?*i32,
                Top: ?*i32,
                Right: ?*i32,
                Bottom: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMathInputControl,
                Left: i32,
                Top: i32,
                Right: i32,
                Bottom: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMathInputControl,
                Left: i32,
                Top: i32,
                Right: i32,
                Bottom: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clear: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMathInputControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMathInputControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCustomPaint: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMathInputControl,
                Element: i32,
                Paint: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMathInputControl,
                Element: i32,
                Paint: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCaptionText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMathInputControl,
                CaptionText: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMathInputControl,
                CaptionText: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LoadInk: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMathInputControl,
                Ink: ?*IInkDisp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMathInputControl,
                Ink: ?*IInkDisp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOwnerWindow: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMathInputControl,
                OwnerWindow: isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMathInputControl,
                OwnerWindow: isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnableExtendedButtons: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMathInputControl,
                Extended: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMathInputControl,
                Extended: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPreviewHeight: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMathInputControl,
                Height: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMathInputControl,
                Height: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPreviewHeight: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMathInputControl,
                Height: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMathInputControl,
                Height: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnableAutoGrow: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMathInputControl,
                AutoGrow: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMathInputControl,
                AutoGrow: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddFunctionName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMathInputControl,
                FunctionName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMathInputControl,
                FunctionName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveFunctionName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMathInputControl,
                FunctionName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMathInputControl,
                FunctionName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetHoverIcon: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMathInputControl,
                HoverImage: ?*?*IPictureDisp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMathInputControl,
                HoverImage: ?*?*IPictureDisp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMathInputControl_Show(self: *const T) HRESULT {
                return @as(*const IMathInputControl.VTable, @ptrCast(self.vtable)).Show(@as(*const IMathInputControl, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMathInputControl_Hide(self: *const T) HRESULT {
                return @as(*const IMathInputControl.VTable, @ptrCast(self.vtable)).Hide(@as(*const IMathInputControl, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMathInputControl_IsVisible(self: *const T, pvbShown: ?*i16) HRESULT {
                return @as(*const IMathInputControl.VTable, @ptrCast(self.vtable)).IsVisible(@as(*const IMathInputControl, @ptrCast(self)), pvbShown);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMathInputControl_GetPosition(self: *const T, Left: ?*i32, Top: ?*i32, Right: ?*i32, Bottom: ?*i32) HRESULT {
                return @as(*const IMathInputControl.VTable, @ptrCast(self.vtable)).GetPosition(@as(*const IMathInputControl, @ptrCast(self)), Left, Top, Right, Bottom);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMathInputControl_SetPosition(self: *const T, Left: i32, Top: i32, Right: i32, Bottom: i32) HRESULT {
                return @as(*const IMathInputControl.VTable, @ptrCast(self.vtable)).SetPosition(@as(*const IMathInputControl, @ptrCast(self)), Left, Top, Right, Bottom);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMathInputControl_Clear(self: *const T) HRESULT {
                return @as(*const IMathInputControl.VTable, @ptrCast(self.vtable)).Clear(@as(*const IMathInputControl, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMathInputControl_SetCustomPaint(self: *const T, Element: i32, Paint: i16) HRESULT {
                return @as(*const IMathInputControl.VTable, @ptrCast(self.vtable)).SetCustomPaint(@as(*const IMathInputControl, @ptrCast(self)), Element, Paint);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMathInputControl_SetCaptionText(self: *const T, CaptionText: ?BSTR) HRESULT {
                return @as(*const IMathInputControl.VTable, @ptrCast(self.vtable)).SetCaptionText(@as(*const IMathInputControl, @ptrCast(self)), CaptionText);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMathInputControl_LoadInk(self: *const T, Ink: ?*IInkDisp) HRESULT {
                return @as(*const IMathInputControl.VTable, @ptrCast(self.vtable)).LoadInk(@as(*const IMathInputControl, @ptrCast(self)), Ink);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMathInputControl_SetOwnerWindow(self: *const T, OwnerWindow: isize) HRESULT {
                return @as(*const IMathInputControl.VTable, @ptrCast(self.vtable)).SetOwnerWindow(@as(*const IMathInputControl, @ptrCast(self)), OwnerWindow);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMathInputControl_EnableExtendedButtons(self: *const T, Extended: i16) HRESULT {
                return @as(*const IMathInputControl.VTable, @ptrCast(self.vtable)).EnableExtendedButtons(@as(*const IMathInputControl, @ptrCast(self)), Extended);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMathInputControl_GetPreviewHeight(self: *const T, Height: ?*i32) HRESULT {
                return @as(*const IMathInputControl.VTable, @ptrCast(self.vtable)).GetPreviewHeight(@as(*const IMathInputControl, @ptrCast(self)), Height);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMathInputControl_SetPreviewHeight(self: *const T, Height: i32) HRESULT {
                return @as(*const IMathInputControl.VTable, @ptrCast(self.vtable)).SetPreviewHeight(@as(*const IMathInputControl, @ptrCast(self)), Height);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMathInputControl_EnableAutoGrow(self: *const T, AutoGrow: i16) HRESULT {
                return @as(*const IMathInputControl.VTable, @ptrCast(self.vtable)).EnableAutoGrow(@as(*const IMathInputControl, @ptrCast(self)), AutoGrow);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMathInputControl_AddFunctionName(self: *const T, FunctionName: ?BSTR) HRESULT {
                return @as(*const IMathInputControl.VTable, @ptrCast(self.vtable)).AddFunctionName(@as(*const IMathInputControl, @ptrCast(self)), FunctionName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMathInputControl_RemoveFunctionName(self: *const T, FunctionName: ?BSTR) HRESULT {
                return @as(*const IMathInputControl.VTable, @ptrCast(self.vtable)).RemoveFunctionName(@as(*const IMathInputControl, @ptrCast(self)), FunctionName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMathInputControl_GetHoverIcon(self: *const T, HoverImage: ?*?*IPictureDisp) HRESULT {
                return @as(*const IMathInputControl.VTable, @ptrCast(self.vtable)).GetHoverIcon(@as(*const IMathInputControl, @ptrCast(self)), HoverImage);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID__IMathInputControlEvents_Value = Guid.initString("683336b5-a47d-4358-96f9-875a472ae70a");
pub const IID__IMathInputControlEvents = &IID__IMathInputControlEvents_Value;
pub const _IMathInputControlEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const CLSID_RealTimeStylus_Value = Guid.initString("e26b366d-f998-43ce-836f-cb6d904432b0");
pub const CLSID_RealTimeStylus = &CLSID_RealTimeStylus_Value;

const CLSID_DynamicRenderer_Value = Guid.initString("ecd32aea-746f-4dcb-bf68-082757faff18");
pub const CLSID_DynamicRenderer = &CLSID_DynamicRenderer_Value;

const CLSID_GestureRecognizer_Value = Guid.initString("ea30c654-c62c-441f-ac00-95f9a196782c");
pub const CLSID_GestureRecognizer = &CLSID_GestureRecognizer_Value;

const CLSID_StrokeBuilder_Value = Guid.initString("e810cee7-6e51-4cb0-aa3a-0b985b70daf7");
pub const CLSID_StrokeBuilder = &CLSID_StrokeBuilder_Value;

pub const RealTimeStylusDataInterest = enum(i32) {
    AllData = -1,
    None = 0,
    Error = 1,
    RealTimeStylusEnabled = 2,
    RealTimeStylusDisabled = 4,
    StylusNew = 8,
    StylusInRange = 16,
    InAirPackets = 32,
    StylusOutOfRange = 64,
    StylusDown = 128,
    Packets = 256,
    StylusUp = 512,
    StylusButtonUp = 1024,
    StylusButtonDown = 2048,
    SystemEvents = 4096,
    TabletAdded = 8192,
    TabletRemoved = 16384,
    CustomStylusDataAdded = 32768,
    UpdateMapping = 65536,
    DefaultEvents = 37766,
};
pub const RTSDI_AllData = RealTimeStylusDataInterest.AllData;
pub const RTSDI_None = RealTimeStylusDataInterest.None;
pub const RTSDI_Error = RealTimeStylusDataInterest.Error;
pub const RTSDI_RealTimeStylusEnabled = RealTimeStylusDataInterest.RealTimeStylusEnabled;
pub const RTSDI_RealTimeStylusDisabled = RealTimeStylusDataInterest.RealTimeStylusDisabled;
pub const RTSDI_StylusNew = RealTimeStylusDataInterest.StylusNew;
pub const RTSDI_StylusInRange = RealTimeStylusDataInterest.StylusInRange;
pub const RTSDI_InAirPackets = RealTimeStylusDataInterest.InAirPackets;
pub const RTSDI_StylusOutOfRange = RealTimeStylusDataInterest.StylusOutOfRange;
pub const RTSDI_StylusDown = RealTimeStylusDataInterest.StylusDown;
pub const RTSDI_Packets = RealTimeStylusDataInterest.Packets;
pub const RTSDI_StylusUp = RealTimeStylusDataInterest.StylusUp;
pub const RTSDI_StylusButtonUp = RealTimeStylusDataInterest.StylusButtonUp;
pub const RTSDI_StylusButtonDown = RealTimeStylusDataInterest.StylusButtonDown;
pub const RTSDI_SystemEvents = RealTimeStylusDataInterest.SystemEvents;
pub const RTSDI_TabletAdded = RealTimeStylusDataInterest.TabletAdded;
pub const RTSDI_TabletRemoved = RealTimeStylusDataInterest.TabletRemoved;
pub const RTSDI_CustomStylusDataAdded = RealTimeStylusDataInterest.CustomStylusDataAdded;
pub const RTSDI_UpdateMapping = RealTimeStylusDataInterest.UpdateMapping;
pub const RTSDI_DefaultEvents = RealTimeStylusDataInterest.DefaultEvents;

pub const StylusInfo = extern struct {
    tcid: u32,
    cid: u32,
    bIsInvertedCursor: BOOL,
};

pub const StylusQueue = enum(i32) {
    SyncStylusQueue = 1,
    AsyncStylusQueueImmediate = 2,
    AsyncStylusQueue = 3,
};
pub const SyncStylusQueue = StylusQueue.SyncStylusQueue;
pub const AsyncStylusQueueImmediate = StylusQueue.AsyncStylusQueueImmediate;
pub const AsyncStylusQueue = StylusQueue.AsyncStylusQueue;

pub const RealTimeStylusLockType = enum(i32) {
    ObjLock = 1,
    SyncEventLock = 2,
    AsyncEventLock = 4,
    ExcludeCallback = 8,
    SyncObjLock = 11,
    AsyncObjLock = 13,
};
pub const RTSLT_ObjLock = RealTimeStylusLockType.ObjLock;
pub const RTSLT_SyncEventLock = RealTimeStylusLockType.SyncEventLock;
pub const RTSLT_AsyncEventLock = RealTimeStylusLockType.AsyncEventLock;
pub const RTSLT_ExcludeCallback = RealTimeStylusLockType.ExcludeCallback;
pub const RTSLT_SyncObjLock = RealTimeStylusLockType.SyncObjLock;
pub const RTSLT_AsyncObjLock = RealTimeStylusLockType.AsyncObjLock;

pub const GESTURE_DATA = extern struct {
    gestureId: i32,
    recoConfidence: i32,
    strokeCount: i32,
};

pub const DYNAMIC_RENDERER_CACHED_DATA = extern struct {
    strokeId: i32,
    dynamicRenderer: ?*IDynamicRenderer,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IRealTimeStylus_Value = Guid.initString("a8bb5d22-3144-4a7b-93cd-f34a16be513a");
pub const IID_IRealTimeStylus = &IID_IRealTimeStylus_Value;
pub const IRealTimeStylus = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Enabled: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRealTimeStylus,
                pfEnable: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRealTimeStylus,
                pfEnable: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Enabled: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRealTimeStylus,
                fEnable: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRealTimeStylus,
                fEnable: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HWND: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRealTimeStylus,
                phwnd: ?*HANDLE_PTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRealTimeStylus,
                phwnd: ?*HANDLE_PTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_HWND: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRealTimeStylus,
                hwnd: HANDLE_PTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRealTimeStylus,
                hwnd: HANDLE_PTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_WindowInputRectangle: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRealTimeStylus,
                prcWndInputRect: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRealTimeStylus,
                prcWndInputRect: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_WindowInputRectangle: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRealTimeStylus,
                prcWndInputRect: ?*const RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRealTimeStylus,
                prcWndInputRect: ?*const RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddStylusSyncPlugin: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRealTimeStylus,
                iIndex: u32,
                piPlugin: ?*IStylusSyncPlugin,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRealTimeStylus,
                iIndex: u32,
                piPlugin: ?*IStylusSyncPlugin,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveStylusSyncPlugin: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRealTimeStylus,
                iIndex: u32,
                ppiPlugin: ?*?*IStylusSyncPlugin,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRealTimeStylus,
                iIndex: u32,
                ppiPlugin: ?*?*IStylusSyncPlugin,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveAllStylusSyncPlugins: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRealTimeStylus,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRealTimeStylus,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStylusSyncPlugin: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRealTimeStylus,
                iIndex: u32,
                ppiPlugin: ?*?*IStylusSyncPlugin,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRealTimeStylus,
                iIndex: u32,
                ppiPlugin: ?*?*IStylusSyncPlugin,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStylusSyncPluginCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRealTimeStylus,
                pcPlugins: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRealTimeStylus,
                pcPlugins: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddStylusAsyncPlugin: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRealTimeStylus,
                iIndex: u32,
                piPlugin: ?*IStylusAsyncPlugin,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRealTimeStylus,
                iIndex: u32,
                piPlugin: ?*IStylusAsyncPlugin,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveStylusAsyncPlugin: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRealTimeStylus,
                iIndex: u32,
                ppiPlugin: ?*?*IStylusAsyncPlugin,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRealTimeStylus,
                iIndex: u32,
                ppiPlugin: ?*?*IStylusAsyncPlugin,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveAllStylusAsyncPlugins: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRealTimeStylus,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRealTimeStylus,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStylusAsyncPlugin: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRealTimeStylus,
                iIndex: u32,
                ppiPlugin: ?*?*IStylusAsyncPlugin,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRealTimeStylus,
                iIndex: u32,
                ppiPlugin: ?*?*IStylusAsyncPlugin,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStylusAsyncPluginCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRealTimeStylus,
                pcPlugins: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRealTimeStylus,
                pcPlugins: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ChildRealTimeStylusPlugin: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRealTimeStylus,
                ppiRTS: ?*?*IRealTimeStylus,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRealTimeStylus,
                ppiRTS: ?*?*IRealTimeStylus,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        putref_ChildRealTimeStylusPlugin: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRealTimeStylus,
                piRTS: ?*IRealTimeStylus,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRealTimeStylus,
                piRTS: ?*IRealTimeStylus,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddCustomStylusDataToQueue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRealTimeStylus,
                sq: StylusQueue,
                pGuidId: ?*const Guid,
                cbData: u32,
                pbData: ?[*:0]u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRealTimeStylus,
                sq: StylusQueue,
                pGuidId: ?*const Guid,
                cbData: u32,
                pbData: ?[*:0]u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ClearStylusQueues: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRealTimeStylus,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRealTimeStylus,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetAllTabletsMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRealTimeStylus,
                fUseMouseForInput: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRealTimeStylus,
                fUseMouseForInput: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSingleTabletMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRealTimeStylus,
                piTablet: ?*IInkTablet,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRealTimeStylus,
                piTablet: ?*IInkTablet,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTablet: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRealTimeStylus,
                ppiSingleTablet: ?*?*IInkTablet,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRealTimeStylus,
                ppiSingleTablet: ?*?*IInkTablet,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTabletContextIdFromTablet: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRealTimeStylus,
                piTablet: ?*IInkTablet,
                ptcid: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRealTimeStylus,
                piTablet: ?*IInkTablet,
                ptcid: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTabletFromTabletContextId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRealTimeStylus,
                tcid: u32,
                ppiTablet: ?*?*IInkTablet,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRealTimeStylus,
                tcid: u32,
                ppiTablet: ?*?*IInkTablet,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAllTabletContextIds: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRealTimeStylus,
                pcTcidCount: ?*u32,
                ppTcids: ?[*]?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRealTimeStylus,
                pcTcidCount: ?*u32,
                ppTcids: ?[*]?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStyluses: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRealTimeStylus,
                ppiInkCursors: ?*?*IInkCursors,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRealTimeStylus,
                ppiInkCursors: ?*?*IInkCursors,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStylusForId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRealTimeStylus,
                sid: u32,
                ppiInkCursor: ?*?*IInkCursor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRealTimeStylus,
                sid: u32,
                ppiInkCursor: ?*?*IInkCursor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDesiredPacketDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRealTimeStylus,
                cProperties: u32,
                pPropertyGuids: [*]const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRealTimeStylus,
                cProperties: u32,
                pPropertyGuids: [*]const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDesiredPacketDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRealTimeStylus,
                pcProperties: ?*u32,
                ppPropertyGuids: ?[*]?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRealTimeStylus,
                pcProperties: ?*u32,
                ppPropertyGuids: ?[*]?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPacketDescriptionData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRealTimeStylus,
                tcid: u32,
                pfInkToDeviceScaleX: ?*f32,
                pfInkToDeviceScaleY: ?*f32,
                pcPacketProperties: ?*u32,
                ppPacketProperties: ?[*]?*PACKET_PROPERTY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRealTimeStylus,
                tcid: u32,
                pfInkToDeviceScaleX: ?*f32,
                pfInkToDeviceScaleY: ?*f32,
                pcPacketProperties: ?*u32,
                ppPacketProperties: ?[*]?*PACKET_PROPERTY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRealTimeStylus_get_Enabled(self: *const T, pfEnable: ?*BOOL) HRESULT {
                return @as(*const IRealTimeStylus.VTable, @ptrCast(self.vtable)).get_Enabled(@as(*const IRealTimeStylus, @ptrCast(self)), pfEnable);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRealTimeStylus_put_Enabled(self: *const T, fEnable: BOOL) HRESULT {
                return @as(*const IRealTimeStylus.VTable, @ptrCast(self.vtable)).put_Enabled(@as(*const IRealTimeStylus, @ptrCast(self)), fEnable);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRealTimeStylus_get_HWND(self: *const T, phwnd: ?*HANDLE_PTR) HRESULT {
                return @as(*const IRealTimeStylus.VTable, @ptrCast(self.vtable)).get_HWND(@as(*const IRealTimeStylus, @ptrCast(self)), phwnd);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRealTimeStylus_put_HWND(self: *const T, hwnd: HANDLE_PTR) HRESULT {
                return @as(*const IRealTimeStylus.VTable, @ptrCast(self.vtable)).put_HWND(@as(*const IRealTimeStylus, @ptrCast(self)), hwnd);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRealTimeStylus_get_WindowInputRectangle(self: *const T, prcWndInputRect: ?*RECT) HRESULT {
                return @as(*const IRealTimeStylus.VTable, @ptrCast(self.vtable)).get_WindowInputRectangle(@as(*const IRealTimeStylus, @ptrCast(self)), prcWndInputRect);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRealTimeStylus_put_WindowInputRectangle(self: *const T, prcWndInputRect: ?*const RECT) HRESULT {
                return @as(*const IRealTimeStylus.VTable, @ptrCast(self.vtable)).put_WindowInputRectangle(@as(*const IRealTimeStylus, @ptrCast(self)), prcWndInputRect);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRealTimeStylus_AddStylusSyncPlugin(self: *const T, iIndex: u32, piPlugin: ?*IStylusSyncPlugin) HRESULT {
                return @as(*const IRealTimeStylus.VTable, @ptrCast(self.vtable)).AddStylusSyncPlugin(@as(*const IRealTimeStylus, @ptrCast(self)), iIndex, piPlugin);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRealTimeStylus_RemoveStylusSyncPlugin(self: *const T, iIndex: u32, ppiPlugin: ?*?*IStylusSyncPlugin) HRESULT {
                return @as(*const IRealTimeStylus.VTable, @ptrCast(self.vtable)).RemoveStylusSyncPlugin(@as(*const IRealTimeStylus, @ptrCast(self)), iIndex, ppiPlugin);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRealTimeStylus_RemoveAllStylusSyncPlugins(self: *const T) HRESULT {
                return @as(*const IRealTimeStylus.VTable, @ptrCast(self.vtable)).RemoveAllStylusSyncPlugins(@as(*const IRealTimeStylus, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRealTimeStylus_GetStylusSyncPlugin(self: *const T, iIndex: u32, ppiPlugin: ?*?*IStylusSyncPlugin) HRESULT {
                return @as(*const IRealTimeStylus.VTable, @ptrCast(self.vtable)).GetStylusSyncPlugin(@as(*const IRealTimeStylus, @ptrCast(self)), iIndex, ppiPlugin);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRealTimeStylus_GetStylusSyncPluginCount(self: *const T, pcPlugins: ?*u32) HRESULT {
                return @as(*const IRealTimeStylus.VTable, @ptrCast(self.vtable)).GetStylusSyncPluginCount(@as(*const IRealTimeStylus, @ptrCast(self)), pcPlugins);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRealTimeStylus_AddStylusAsyncPlugin(self: *const T, iIndex: u32, piPlugin: ?*IStylusAsyncPlugin) HRESULT {
                return @as(*const IRealTimeStylus.VTable, @ptrCast(self.vtable)).AddStylusAsyncPlugin(@as(*const IRealTimeStylus, @ptrCast(self)), iIndex, piPlugin);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRealTimeStylus_RemoveStylusAsyncPlugin(self: *const T, iIndex: u32, ppiPlugin: ?*?*IStylusAsyncPlugin) HRESULT {
                return @as(*const IRealTimeStylus.VTable, @ptrCast(self.vtable)).RemoveStylusAsyncPlugin(@as(*const IRealTimeStylus, @ptrCast(self)), iIndex, ppiPlugin);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRealTimeStylus_RemoveAllStylusAsyncPlugins(self: *const T) HRESULT {
                return @as(*const IRealTimeStylus.VTable, @ptrCast(self.vtable)).RemoveAllStylusAsyncPlugins(@as(*const IRealTimeStylus, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRealTimeStylus_GetStylusAsyncPlugin(self: *const T, iIndex: u32, ppiPlugin: ?*?*IStylusAsyncPlugin) HRESULT {
                return @as(*const IRealTimeStylus.VTable, @ptrCast(self.vtable)).GetStylusAsyncPlugin(@as(*const IRealTimeStylus, @ptrCast(self)), iIndex, ppiPlugin);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRealTimeStylus_GetStylusAsyncPluginCount(self: *const T, pcPlugins: ?*u32) HRESULT {
                return @as(*const IRealTimeStylus.VTable, @ptrCast(self.vtable)).GetStylusAsyncPluginCount(@as(*const IRealTimeStylus, @ptrCast(self)), pcPlugins);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRealTimeStylus_get_ChildRealTimeStylusPlugin(self: *const T, ppiRTS: ?*?*IRealTimeStylus) HRESULT {
                return @as(*const IRealTimeStylus.VTable, @ptrCast(self.vtable)).get_ChildRealTimeStylusPlugin(@as(*const IRealTimeStylus, @ptrCast(self)), ppiRTS);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRealTimeStylus_putref_ChildRealTimeStylusPlugin(self: *const T, piRTS: ?*IRealTimeStylus) HRESULT {
                return @as(*const IRealTimeStylus.VTable, @ptrCast(self.vtable)).putref_ChildRealTimeStylusPlugin(@as(*const IRealTimeStylus, @ptrCast(self)), piRTS);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRealTimeStylus_AddCustomStylusDataToQueue(self: *const T, sq: StylusQueue, pGuidId: ?*const Guid, cbData: u32, pbData: ?[*:0]u8) HRESULT {
                return @as(*const IRealTimeStylus.VTable, @ptrCast(self.vtable)).AddCustomStylusDataToQueue(@as(*const IRealTimeStylus, @ptrCast(self)), sq, pGuidId, cbData, pbData);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRealTimeStylus_ClearStylusQueues(self: *const T) HRESULT {
                return @as(*const IRealTimeStylus.VTable, @ptrCast(self.vtable)).ClearStylusQueues(@as(*const IRealTimeStylus, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRealTimeStylus_SetAllTabletsMode(self: *const T, fUseMouseForInput: BOOL) HRESULT {
                return @as(*const IRealTimeStylus.VTable, @ptrCast(self.vtable)).SetAllTabletsMode(@as(*const IRealTimeStylus, @ptrCast(self)), fUseMouseForInput);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRealTimeStylus_SetSingleTabletMode(self: *const T, piTablet: ?*IInkTablet) HRESULT {
                return @as(*const IRealTimeStylus.VTable, @ptrCast(self.vtable)).SetSingleTabletMode(@as(*const IRealTimeStylus, @ptrCast(self)), piTablet);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRealTimeStylus_GetTablet(self: *const T, ppiSingleTablet: ?*?*IInkTablet) HRESULT {
                return @as(*const IRealTimeStylus.VTable, @ptrCast(self.vtable)).GetTablet(@as(*const IRealTimeStylus, @ptrCast(self)), ppiSingleTablet);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRealTimeStylus_GetTabletContextIdFromTablet(self: *const T, piTablet: ?*IInkTablet, ptcid: ?*u32) HRESULT {
                return @as(*const IRealTimeStylus.VTable, @ptrCast(self.vtable)).GetTabletContextIdFromTablet(@as(*const IRealTimeStylus, @ptrCast(self)), piTablet, ptcid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRealTimeStylus_GetTabletFromTabletContextId(self: *const T, tcid: u32, ppiTablet: ?*?*IInkTablet) HRESULT {
                return @as(*const IRealTimeStylus.VTable, @ptrCast(self.vtable)).GetTabletFromTabletContextId(@as(*const IRealTimeStylus, @ptrCast(self)), tcid, ppiTablet);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRealTimeStylus_GetAllTabletContextIds(self: *const T, pcTcidCount: ?*u32, ppTcids: ?[*]?*u32) HRESULT {
                return @as(*const IRealTimeStylus.VTable, @ptrCast(self.vtable)).GetAllTabletContextIds(@as(*const IRealTimeStylus, @ptrCast(self)), pcTcidCount, ppTcids);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRealTimeStylus_GetStyluses(self: *const T, ppiInkCursors: ?*?*IInkCursors) HRESULT {
                return @as(*const IRealTimeStylus.VTable, @ptrCast(self.vtable)).GetStyluses(@as(*const IRealTimeStylus, @ptrCast(self)), ppiInkCursors);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRealTimeStylus_GetStylusForId(self: *const T, sid: u32, ppiInkCursor: ?*?*IInkCursor) HRESULT {
                return @as(*const IRealTimeStylus.VTable, @ptrCast(self.vtable)).GetStylusForId(@as(*const IRealTimeStylus, @ptrCast(self)), sid, ppiInkCursor);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRealTimeStylus_SetDesiredPacketDescription(self: *const T, cProperties: u32, pPropertyGuids: [*]const Guid) HRESULT {
                return @as(*const IRealTimeStylus.VTable, @ptrCast(self.vtable)).SetDesiredPacketDescription(@as(*const IRealTimeStylus, @ptrCast(self)), cProperties, pPropertyGuids);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRealTimeStylus_GetDesiredPacketDescription(self: *const T, pcProperties: ?*u32, ppPropertyGuids: ?[*]?*Guid) HRESULT {
                return @as(*const IRealTimeStylus.VTable, @ptrCast(self.vtable)).GetDesiredPacketDescription(@as(*const IRealTimeStylus, @ptrCast(self)), pcProperties, ppPropertyGuids);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRealTimeStylus_GetPacketDescriptionData(self: *const T, tcid: u32, pfInkToDeviceScaleX: ?*f32, pfInkToDeviceScaleY: ?*f32, pcPacketProperties: ?*u32, ppPacketProperties: ?[*]?*PACKET_PROPERTY) HRESULT {
                return @as(*const IRealTimeStylus.VTable, @ptrCast(self.vtable)).GetPacketDescriptionData(@as(*const IRealTimeStylus, @ptrCast(self)), tcid, pfInkToDeviceScaleX, pfInkToDeviceScaleY, pcPacketProperties, ppPacketProperties);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IRealTimeStylus2_Value = Guid.initString("b5f2a6cd-3179-4a3e-b9c4-bb5865962be2");
pub const IID_IRealTimeStylus2 = &IID_IRealTimeStylus2_Value;
pub const IRealTimeStylus2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FlicksEnabled: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRealTimeStylus2,
                pfEnable: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRealTimeStylus2,
                pfEnable: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_FlicksEnabled: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRealTimeStylus2,
                fEnable: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRealTimeStylus2,
                fEnable: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRealTimeStylus2_get_FlicksEnabled(self: *const T, pfEnable: ?*BOOL) HRESULT {
                return @as(*const IRealTimeStylus2.VTable, @ptrCast(self.vtable)).get_FlicksEnabled(@as(*const IRealTimeStylus2, @ptrCast(self)), pfEnable);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRealTimeStylus2_put_FlicksEnabled(self: *const T, fEnable: BOOL) HRESULT {
                return @as(*const IRealTimeStylus2.VTable, @ptrCast(self.vtable)).put_FlicksEnabled(@as(*const IRealTimeStylus2, @ptrCast(self)), fEnable);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IRealTimeStylus3_Value = Guid.initString("d70230a3-6986-4051-b57a-1cf69f4d9db5");
pub const IID_IRealTimeStylus3 = &IID_IRealTimeStylus3_Value;
pub const IRealTimeStylus3 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MultiTouchEnabled: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRealTimeStylus3,
                pfEnable: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRealTimeStylus3,
                pfEnable: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MultiTouchEnabled: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IRealTimeStylus3,
                fEnable: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IRealTimeStylus3,
                fEnable: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRealTimeStylus3_get_MultiTouchEnabled(self: *const T, pfEnable: ?*BOOL) HRESULT {
                return @as(*const IRealTimeStylus3.VTable, @ptrCast(self.vtable)).get_MultiTouchEnabled(@as(*const IRealTimeStylus3, @ptrCast(self)), pfEnable);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRealTimeStylus3_put_MultiTouchEnabled(self: *const T, fEnable: BOOL) HRESULT {
                return @as(*const IRealTimeStylus3.VTable, @ptrCast(self.vtable)).put_MultiTouchEnabled(@as(*const IRealTimeStylus3, @ptrCast(self)), fEnable);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IRealTimeStylusSynchronization_Value = Guid.initString("aa87eab8-ab4a-4cea-b5cb-46d84c6a2509");
pub const IID_IRealTimeStylusSynchronization = &IID_IRealTimeStylusSynchronization_Value;
pub const IRealTimeStylusSynchronization = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AcquireLock: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRealTimeStylusSynchronization,
                lock: RealTimeStylusLockType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRealTimeStylusSynchronization,
                lock: RealTimeStylusLockType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReleaseLock: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRealTimeStylusSynchronization,
                lock: RealTimeStylusLockType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRealTimeStylusSynchronization,
                lock: RealTimeStylusLockType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRealTimeStylusSynchronization_AcquireLock(self: *const T, lock: RealTimeStylusLockType) HRESULT {
                return @as(*const IRealTimeStylusSynchronization.VTable, @ptrCast(self.vtable)).AcquireLock(@as(*const IRealTimeStylusSynchronization, @ptrCast(self)), lock);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRealTimeStylusSynchronization_ReleaseLock(self: *const T, lock: RealTimeStylusLockType) HRESULT {
                return @as(*const IRealTimeStylusSynchronization.VTable, @ptrCast(self.vtable)).ReleaseLock(@as(*const IRealTimeStylusSynchronization, @ptrCast(self)), lock);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IStrokeBuilder_Value = Guid.initString("a5fd4e2d-c44b-4092-9177-260905eb672b");
pub const IID_IStrokeBuilder = &IID_IStrokeBuilder_Value;
pub const IStrokeBuilder = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateStroke: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IStrokeBuilder,
                cPktBuffLength: u32,
                pPackets: [*]const i32,
                cPacketProperties: u32,
                pPacketProperties: [*]const PACKET_PROPERTY,
                fInkToDeviceScaleX: f32,
                fInkToDeviceScaleY: f32,
                ppIInkStroke: ?*?*IInkStrokeDisp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IStrokeBuilder,
                cPktBuffLength: u32,
                pPackets: [*]const i32,
                cPacketProperties: u32,
                pPacketProperties: [*]const PACKET_PROPERTY,
                fInkToDeviceScaleX: f32,
                fInkToDeviceScaleY: f32,
                ppIInkStroke: ?*?*IInkStrokeDisp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BeginStroke: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IStrokeBuilder,
                tcid: u32,
                sid: u32,
                pPacket: ?*const i32,
                cPacketProperties: u32,
                pPacketProperties: [*]PACKET_PROPERTY,
                fInkToDeviceScaleX: f32,
                fInkToDeviceScaleY: f32,
                ppIInkStroke: ?*?*IInkStrokeDisp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IStrokeBuilder,
                tcid: u32,
                sid: u32,
                pPacket: ?*const i32,
                cPacketProperties: u32,
                pPacketProperties: [*]PACKET_PROPERTY,
                fInkToDeviceScaleX: f32,
                fInkToDeviceScaleY: f32,
                ppIInkStroke: ?*?*IInkStrokeDisp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AppendPackets: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IStrokeBuilder,
                tcid: u32,
                sid: u32,
                cPktBuffLength: u32,
                pPackets: [*]const i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IStrokeBuilder,
                tcid: u32,
                sid: u32,
                cPktBuffLength: u32,
                pPackets: [*]const i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndStroke: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IStrokeBuilder,
                tcid: u32,
                sid: u32,
                ppIInkStroke: ?*?*IInkStrokeDisp,
                pDirtyRect: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IStrokeBuilder,
                tcid: u32,
                sid: u32,
                ppIInkStroke: ?*?*IInkStrokeDisp,
                pDirtyRect: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Ink: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IStrokeBuilder,
                ppiInkObj: ?*?*IInkDisp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IStrokeBuilder,
                ppiInkObj: ?*?*IInkDisp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        putref_Ink: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IStrokeBuilder,
                piInkObj: ?*IInkDisp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IStrokeBuilder,
                piInkObj: ?*IInkDisp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IStrokeBuilder_CreateStroke(self: *const T, cPktBuffLength: u32, pPackets: [*]const i32, cPacketProperties: u32, pPacketProperties: [*]const PACKET_PROPERTY, fInkToDeviceScaleX: f32, fInkToDeviceScaleY: f32, ppIInkStroke: ?*?*IInkStrokeDisp) HRESULT {
                return @as(*const IStrokeBuilder.VTable, @ptrCast(self.vtable)).CreateStroke(@as(*const IStrokeBuilder, @ptrCast(self)), cPktBuffLength, pPackets, cPacketProperties, pPacketProperties, fInkToDeviceScaleX, fInkToDeviceScaleY, ppIInkStroke);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IStrokeBuilder_BeginStroke(self: *const T, tcid: u32, sid: u32, pPacket: ?*const i32, cPacketProperties: u32, pPacketProperties: [*]PACKET_PROPERTY, fInkToDeviceScaleX: f32, fInkToDeviceScaleY: f32, ppIInkStroke: ?*?*IInkStrokeDisp) HRESULT {
                return @as(*const IStrokeBuilder.VTable, @ptrCast(self.vtable)).BeginStroke(@as(*const IStrokeBuilder, @ptrCast(self)), tcid, sid, pPacket, cPacketProperties, pPacketProperties, fInkToDeviceScaleX, fInkToDeviceScaleY, ppIInkStroke);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IStrokeBuilder_AppendPackets(self: *const T, tcid: u32, sid: u32, cPktBuffLength: u32, pPackets: [*]const i32) HRESULT {
                return @as(*const IStrokeBuilder.VTable, @ptrCast(self.vtable)).AppendPackets(@as(*const IStrokeBuilder, @ptrCast(self)), tcid, sid, cPktBuffLength, pPackets);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IStrokeBuilder_EndStroke(self: *const T, tcid: u32, sid: u32, ppIInkStroke: ?*?*IInkStrokeDisp, pDirtyRect: ?*RECT) HRESULT {
                return @as(*const IStrokeBuilder.VTable, @ptrCast(self.vtable)).EndStroke(@as(*const IStrokeBuilder, @ptrCast(self)), tcid, sid, ppIInkStroke, pDirtyRect);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IStrokeBuilder_get_Ink(self: *const T, ppiInkObj: ?*?*IInkDisp) HRESULT {
                return @as(*const IStrokeBuilder.VTable, @ptrCast(self.vtable)).get_Ink(@as(*const IStrokeBuilder, @ptrCast(self)), ppiInkObj);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IStrokeBuilder_putref_Ink(self: *const T, piInkObj: ?*IInkDisp) HRESULT {
                return @as(*const IStrokeBuilder.VTable, @ptrCast(self.vtable)).putref_Ink(@as(*const IStrokeBuilder, @ptrCast(self)), piInkObj);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IStylusPlugin_Value = Guid.initString("a81436d8-4757-4fd1-a185-133f97c6c545");
pub const IID_IStylusPlugin = &IID_IStylusPlugin_Value;
pub const IStylusPlugin = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RealTimeStylusEnabled: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IStylusPlugin,
                piRtsSrc: ?*IRealTimeStylus,
                cTcidCount: u32,
                pTcids: [*]const u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IStylusPlugin,
                piRtsSrc: ?*IRealTimeStylus,
                cTcidCount: u32,
                pTcids: [*]const u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RealTimeStylusDisabled: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IStylusPlugin,
                piRtsSrc: ?*IRealTimeStylus,
                cTcidCount: u32,
                pTcids: [*]const u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IStylusPlugin,
                piRtsSrc: ?*IRealTimeStylus,
                cTcidCount: u32,
                pTcids: [*]const u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StylusInRange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IStylusPlugin,
                piRtsSrc: ?*IRealTimeStylus,
                tcid: u32,
                sid: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IStylusPlugin,
                piRtsSrc: ?*IRealTimeStylus,
                tcid: u32,
                sid: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StylusOutOfRange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IStylusPlugin,
                piRtsSrc: ?*IRealTimeStylus,
                tcid: u32,
                sid: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IStylusPlugin,
                piRtsSrc: ?*IRealTimeStylus,
                tcid: u32,
                sid: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StylusDown: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IStylusPlugin,
                piRtsSrc: ?*IRealTimeStylus,
                pStylusInfo: ?*const StylusInfo,
                cPropCountPerPkt: u32,
                pPacket: [*]i32,
                ppInOutPkt: ?*?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IStylusPlugin,
                piRtsSrc: ?*IRealTimeStylus,
                pStylusInfo: ?*const StylusInfo,
                cPropCountPerPkt: u32,
                pPacket: [*]i32,
                ppInOutPkt: ?*?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StylusUp: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IStylusPlugin,
                piRtsSrc: ?*IRealTimeStylus,
                pStylusInfo: ?*const StylusInfo,
                cPropCountPerPkt: u32,
                pPacket: [*]i32,
                ppInOutPkt: ?*?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IStylusPlugin,
                piRtsSrc: ?*IRealTimeStylus,
                pStylusInfo: ?*const StylusInfo,
                cPropCountPerPkt: u32,
                pPacket: [*]i32,
                ppInOutPkt: ?*?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StylusButtonDown: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IStylusPlugin,
                piRtsSrc: ?*IRealTimeStylus,
                sid: u32,
                pGuidStylusButton: ?*const Guid,
                pStylusPos: ?*POINT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IStylusPlugin,
                piRtsSrc: ?*IRealTimeStylus,
                sid: u32,
                pGuidStylusButton: ?*const Guid,
                pStylusPos: ?*POINT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StylusButtonUp: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IStylusPlugin,
                piRtsSrc: ?*IRealTimeStylus,
                sid: u32,
                pGuidStylusButton: ?*const Guid,
                pStylusPos: ?*POINT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IStylusPlugin,
                piRtsSrc: ?*IRealTimeStylus,
                sid: u32,
                pGuidStylusButton: ?*const Guid,
                pStylusPos: ?*POINT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InAirPackets: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IStylusPlugin,
                piRtsSrc: ?*IRealTimeStylus,
                pStylusInfo: ?*const StylusInfo,
                cPktCount: u32,
                cPktBuffLength: u32,
                pPackets: [*]i32,
                pcInOutPkts: ?*u32,
                ppInOutPkts: ?*?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IStylusPlugin,
                piRtsSrc: ?*IRealTimeStylus,
                pStylusInfo: ?*const StylusInfo,
                cPktCount: u32,
                cPktBuffLength: u32,
                pPackets: [*]i32,
                pcInOutPkts: ?*u32,
                ppInOutPkts: ?*?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Packets: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IStylusPlugin,
                piRtsSrc: ?*IRealTimeStylus,
                pStylusInfo: ?*const StylusInfo,
                cPktCount: u32,
                cPktBuffLength: u32,
                pPackets: [*]i32,
                pcInOutPkts: ?*u32,
                ppInOutPkts: ?*?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IStylusPlugin,
                piRtsSrc: ?*IRealTimeStylus,
                pStylusInfo: ?*const StylusInfo,
                cPktCount: u32,
                cPktBuffLength: u32,
                pPackets: [*]i32,
                pcInOutPkts: ?*u32,
                ppInOutPkts: ?*?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CustomStylusDataAdded: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IStylusPlugin,
                piRtsSrc: ?*IRealTimeStylus,
                pGuidId: ?*const Guid,
                cbData: u32,
                pbData: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IStylusPlugin,
                piRtsSrc: ?*IRealTimeStylus,
                pGuidId: ?*const Guid,
                cbData: u32,
                pbData: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SystemEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IStylusPlugin,
                piRtsSrc: ?*IRealTimeStylus,
                tcid: u32,
                sid: u32,
                event: u16,
                eventdata: SYSTEM_EVENT_DATA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IStylusPlugin,
                piRtsSrc: ?*IRealTimeStylus,
                tcid: u32,
                sid: u32,
                event: u16,
                eventdata: SYSTEM_EVENT_DATA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TabletAdded: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IStylusPlugin,
                piRtsSrc: ?*IRealTimeStylus,
                piTablet: ?*IInkTablet,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IStylusPlugin,
                piRtsSrc: ?*IRealTimeStylus,
                piTablet: ?*IInkTablet,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TabletRemoved: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IStylusPlugin,
                piRtsSrc: ?*IRealTimeStylus,
                iTabletIndex: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IStylusPlugin,
                piRtsSrc: ?*IRealTimeStylus,
                iTabletIndex: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Error: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IStylusPlugin,
                piRtsSrc: ?*IRealTimeStylus,
                piPlugin: ?*IStylusPlugin,
                dataInterest: RealTimeStylusDataInterest,
                hrErrorCode: HRESULT,
                lptrKey: ?*isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IStylusPlugin,
                piRtsSrc: ?*IRealTimeStylus,
                piPlugin: ?*IStylusPlugin,
                dataInterest: RealTimeStylusDataInterest,
                hrErrorCode: HRESULT,
                lptrKey: ?*isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UpdateMapping: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IStylusPlugin,
                piRtsSrc: ?*IRealTimeStylus,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IStylusPlugin,
                piRtsSrc: ?*IRealTimeStylus,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DataInterest: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IStylusPlugin,
                pDataInterest: ?*RealTimeStylusDataInterest,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IStylusPlugin,
                pDataInterest: ?*RealTimeStylusDataInterest,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IStylusPlugin_RealTimeStylusEnabled(self: *const T, piRtsSrc: ?*IRealTimeStylus, cTcidCount: u32, pTcids: [*]const u32) HRESULT {
                return @as(*const IStylusPlugin.VTable, @ptrCast(self.vtable)).RealTimeStylusEnabled(@as(*const IStylusPlugin, @ptrCast(self)), piRtsSrc, cTcidCount, pTcids);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IStylusPlugin_RealTimeStylusDisabled(self: *const T, piRtsSrc: ?*IRealTimeStylus, cTcidCount: u32, pTcids: [*]const u32) HRESULT {
                return @as(*const IStylusPlugin.VTable, @ptrCast(self.vtable)).RealTimeStylusDisabled(@as(*const IStylusPlugin, @ptrCast(self)), piRtsSrc, cTcidCount, pTcids);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IStylusPlugin_StylusInRange(self: *const T, piRtsSrc: ?*IRealTimeStylus, tcid: u32, sid: u32) HRESULT {
                return @as(*const IStylusPlugin.VTable, @ptrCast(self.vtable)).StylusInRange(@as(*const IStylusPlugin, @ptrCast(self)), piRtsSrc, tcid, sid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IStylusPlugin_StylusOutOfRange(self: *const T, piRtsSrc: ?*IRealTimeStylus, tcid: u32, sid: u32) HRESULT {
                return @as(*const IStylusPlugin.VTable, @ptrCast(self.vtable)).StylusOutOfRange(@as(*const IStylusPlugin, @ptrCast(self)), piRtsSrc, tcid, sid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IStylusPlugin_StylusDown(self: *const T, piRtsSrc: ?*IRealTimeStylus, pStylusInfo: ?*const StylusInfo, cPropCountPerPkt: u32, pPacket: [*]i32, ppInOutPkt: ?*?*i32) HRESULT {
                return @as(*const IStylusPlugin.VTable, @ptrCast(self.vtable)).StylusDown(@as(*const IStylusPlugin, @ptrCast(self)), piRtsSrc, pStylusInfo, cPropCountPerPkt, pPacket, ppInOutPkt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IStylusPlugin_StylusUp(self: *const T, piRtsSrc: ?*IRealTimeStylus, pStylusInfo: ?*const StylusInfo, cPropCountPerPkt: u32, pPacket: [*]i32, ppInOutPkt: ?*?*i32) HRESULT {
                return @as(*const IStylusPlugin.VTable, @ptrCast(self.vtable)).StylusUp(@as(*const IStylusPlugin, @ptrCast(self)), piRtsSrc, pStylusInfo, cPropCountPerPkt, pPacket, ppInOutPkt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IStylusPlugin_StylusButtonDown(self: *const T, piRtsSrc: ?*IRealTimeStylus, sid: u32, pGuidStylusButton: ?*const Guid, pStylusPos: ?*POINT) HRESULT {
                return @as(*const IStylusPlugin.VTable, @ptrCast(self.vtable)).StylusButtonDown(@as(*const IStylusPlugin, @ptrCast(self)), piRtsSrc, sid, pGuidStylusButton, pStylusPos);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IStylusPlugin_StylusButtonUp(self: *const T, piRtsSrc: ?*IRealTimeStylus, sid: u32, pGuidStylusButton: ?*const Guid, pStylusPos: ?*POINT) HRESULT {
                return @as(*const IStylusPlugin.VTable, @ptrCast(self.vtable)).StylusButtonUp(@as(*const IStylusPlugin, @ptrCast(self)), piRtsSrc, sid, pGuidStylusButton, pStylusPos);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IStylusPlugin_InAirPackets(self: *const T, piRtsSrc: ?*IRealTimeStylus, pStylusInfo: ?*const StylusInfo, cPktCount: u32, cPktBuffLength: u32, pPackets: [*]i32, pcInOutPkts: ?*u32, ppInOutPkts: ?*?*i32) HRESULT {
                return @as(*const IStylusPlugin.VTable, @ptrCast(self.vtable)).InAirPackets(@as(*const IStylusPlugin, @ptrCast(self)), piRtsSrc, pStylusInfo, cPktCount, cPktBuffLength, pPackets, pcInOutPkts, ppInOutPkts);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IStylusPlugin_Packets(self: *const T, piRtsSrc: ?*IRealTimeStylus, pStylusInfo: ?*const StylusInfo, cPktCount: u32, cPktBuffLength: u32, pPackets: [*]i32, pcInOutPkts: ?*u32, ppInOutPkts: ?*?*i32) HRESULT {
                return @as(*const IStylusPlugin.VTable, @ptrCast(self.vtable)).Packets(@as(*const IStylusPlugin, @ptrCast(self)), piRtsSrc, pStylusInfo, cPktCount, cPktBuffLength, pPackets, pcInOutPkts, ppInOutPkts);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IStylusPlugin_CustomStylusDataAdded(self: *const T, piRtsSrc: ?*IRealTimeStylus, pGuidId: ?*const Guid, cbData: u32, pbData: ?[*:0]const u8) HRESULT {
                return @as(*const IStylusPlugin.VTable, @ptrCast(self.vtable)).CustomStylusDataAdded(@as(*const IStylusPlugin, @ptrCast(self)), piRtsSrc, pGuidId, cbData, pbData);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IStylusPlugin_SystemEvent(self: *const T, piRtsSrc: ?*IRealTimeStylus, tcid: u32, sid: u32, event: u16, eventdata: SYSTEM_EVENT_DATA) HRESULT {
                return @as(*const IStylusPlugin.VTable, @ptrCast(self.vtable)).SystemEvent(@as(*const IStylusPlugin, @ptrCast(self)), piRtsSrc, tcid, sid, event, eventdata);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IStylusPlugin_TabletAdded(self: *const T, piRtsSrc: ?*IRealTimeStylus, piTablet: ?*IInkTablet) HRESULT {
                return @as(*const IStylusPlugin.VTable, @ptrCast(self.vtable)).TabletAdded(@as(*const IStylusPlugin, @ptrCast(self)), piRtsSrc, piTablet);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IStylusPlugin_TabletRemoved(self: *const T, piRtsSrc: ?*IRealTimeStylus, iTabletIndex: i32) HRESULT {
                return @as(*const IStylusPlugin.VTable, @ptrCast(self.vtable)).TabletRemoved(@as(*const IStylusPlugin, @ptrCast(self)), piRtsSrc, iTabletIndex);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IStylusPlugin_Error(self: *const T, piRtsSrc: ?*IRealTimeStylus, piPlugin: ?*IStylusPlugin, dataInterest: RealTimeStylusDataInterest, hrErrorCode: HRESULT, lptrKey: ?*isize) HRESULT {
                return @as(*const IStylusPlugin.VTable, @ptrCast(self.vtable)).Error(@as(*const IStylusPlugin, @ptrCast(self)), piRtsSrc, piPlugin, dataInterest, hrErrorCode, lptrKey);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IStylusPlugin_UpdateMapping(self: *const T, piRtsSrc: ?*IRealTimeStylus) HRESULT {
                return @as(*const IStylusPlugin.VTable, @ptrCast(self.vtable)).UpdateMapping(@as(*const IStylusPlugin, @ptrCast(self)), piRtsSrc);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IStylusPlugin_DataInterest(self: *const T, pDataInterest: ?*RealTimeStylusDataInterest) HRESULT {
                return @as(*const IStylusPlugin.VTable, @ptrCast(self.vtable)).DataInterest(@as(*const IStylusPlugin, @ptrCast(self)), pDataInterest);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IStylusSyncPlugin_Value = Guid.initString("a157b174-482f-4d71-a3f6-3a41ddd11be9");
pub const IID_IStylusSyncPlugin = &IID_IStylusSyncPlugin_Value;
pub const IStylusSyncPlugin = extern struct {
    pub const VTable = extern struct {
        base: IStylusPlugin.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IStylusPlugin.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IStylusAsyncPlugin_Value = Guid.initString("a7cca85a-31bc-4cd2-aadc-3289a3af11c8");
pub const IID_IStylusAsyncPlugin = &IID_IStylusAsyncPlugin_Value;
pub const IStylusAsyncPlugin = extern struct {
    pub const VTable = extern struct {
        base: IStylusPlugin.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IStylusPlugin.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IDynamicRenderer_Value = Guid.initString("a079468e-7165-46f9-b7af-98ad01a93009");
pub const IID_IDynamicRenderer = &IID_IDynamicRenderer_Value;
pub const IDynamicRenderer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Enabled: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IDynamicRenderer,
                bEnabled: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IDynamicRenderer,
                bEnabled: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Enabled: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IDynamicRenderer,
                bEnabled: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IDynamicRenderer,
                bEnabled: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HWND: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IDynamicRenderer,
                hwnd: ?*HANDLE_PTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IDynamicRenderer,
                hwnd: ?*HANDLE_PTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_HWND: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IDynamicRenderer,
                hwnd: HANDLE_PTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IDynamicRenderer,
                hwnd: HANDLE_PTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ClipRectangle: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IDynamicRenderer,
                prcClipRect: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IDynamicRenderer,
                prcClipRect: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ClipRectangle: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IDynamicRenderer,
                prcClipRect: ?*const RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IDynamicRenderer,
                prcClipRect: ?*const RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ClipRegion: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IDynamicRenderer,
                phClipRgn: ?*HANDLE_PTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IDynamicRenderer,
                phClipRgn: ?*HANDLE_PTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ClipRegion: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IDynamicRenderer,
                hClipRgn: HANDLE_PTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IDynamicRenderer,
                hClipRgn: HANDLE_PTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DrawingAttributes: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IDynamicRenderer,
                ppiDA: ?*?*IInkDrawingAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IDynamicRenderer,
                ppiDA: ?*?*IInkDrawingAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        putref_DrawingAttributes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDynamicRenderer,
                piDA: ?*IInkDrawingAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDynamicRenderer,
                piDA: ?*IInkDrawingAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DataCacheEnabled: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IDynamicRenderer,
                pfCacheData: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IDynamicRenderer,
                pfCacheData: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DataCacheEnabled: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IDynamicRenderer,
                fCacheData: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IDynamicRenderer,
                fCacheData: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReleaseCachedData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDynamicRenderer,
                strokeId: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDynamicRenderer,
                strokeId: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Refresh: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDynamicRenderer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDynamicRenderer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Draw: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDynamicRenderer,
                hDC: HANDLE_PTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDynamicRenderer,
                hDC: HANDLE_PTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDynamicRenderer_get_Enabled(self: *const T, bEnabled: ?*BOOL) HRESULT {
                return @as(*const IDynamicRenderer.VTable, @ptrCast(self.vtable)).get_Enabled(@as(*const IDynamicRenderer, @ptrCast(self)), bEnabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDynamicRenderer_put_Enabled(self: *const T, bEnabled: BOOL) HRESULT {
                return @as(*const IDynamicRenderer.VTable, @ptrCast(self.vtable)).put_Enabled(@as(*const IDynamicRenderer, @ptrCast(self)), bEnabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDynamicRenderer_get_HWND(self: *const T, hwnd: ?*HANDLE_PTR) HRESULT {
                return @as(*const IDynamicRenderer.VTable, @ptrCast(self.vtable)).get_HWND(@as(*const IDynamicRenderer, @ptrCast(self)), hwnd);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDynamicRenderer_put_HWND(self: *const T, hwnd: HANDLE_PTR) HRESULT {
                return @as(*const IDynamicRenderer.VTable, @ptrCast(self.vtable)).put_HWND(@as(*const IDynamicRenderer, @ptrCast(self)), hwnd);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDynamicRenderer_get_ClipRectangle(self: *const T, prcClipRect: ?*RECT) HRESULT {
                return @as(*const IDynamicRenderer.VTable, @ptrCast(self.vtable)).get_ClipRectangle(@as(*const IDynamicRenderer, @ptrCast(self)), prcClipRect);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDynamicRenderer_put_ClipRectangle(self: *const T, prcClipRect: ?*const RECT) HRESULT {
                return @as(*const IDynamicRenderer.VTable, @ptrCast(self.vtable)).put_ClipRectangle(@as(*const IDynamicRenderer, @ptrCast(self)), prcClipRect);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDynamicRenderer_get_ClipRegion(self: *const T, phClipRgn: ?*HANDLE_PTR) HRESULT {
                return @as(*const IDynamicRenderer.VTable, @ptrCast(self.vtable)).get_ClipRegion(@as(*const IDynamicRenderer, @ptrCast(self)), phClipRgn);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDynamicRenderer_put_ClipRegion(self: *const T, hClipRgn: HANDLE_PTR) HRESULT {
                return @as(*const IDynamicRenderer.VTable, @ptrCast(self.vtable)).put_ClipRegion(@as(*const IDynamicRenderer, @ptrCast(self)), hClipRgn);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDynamicRenderer_get_DrawingAttributes(self: *const T, ppiDA: ?*?*IInkDrawingAttributes) HRESULT {
                return @as(*const IDynamicRenderer.VTable, @ptrCast(self.vtable)).get_DrawingAttributes(@as(*const IDynamicRenderer, @ptrCast(self)), ppiDA);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDynamicRenderer_putref_DrawingAttributes(self: *const T, piDA: ?*IInkDrawingAttributes) HRESULT {
                return @as(*const IDynamicRenderer.VTable, @ptrCast(self.vtable)).putref_DrawingAttributes(@as(*const IDynamicRenderer, @ptrCast(self)), piDA);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDynamicRenderer_get_DataCacheEnabled(self: *const T, pfCacheData: ?*BOOL) HRESULT {
                return @as(*const IDynamicRenderer.VTable, @ptrCast(self.vtable)).get_DataCacheEnabled(@as(*const IDynamicRenderer, @ptrCast(self)), pfCacheData);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDynamicRenderer_put_DataCacheEnabled(self: *const T, fCacheData: BOOL) HRESULT {
                return @as(*const IDynamicRenderer.VTable, @ptrCast(self.vtable)).put_DataCacheEnabled(@as(*const IDynamicRenderer, @ptrCast(self)), fCacheData);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDynamicRenderer_ReleaseCachedData(self: *const T, strokeId: u32) HRESULT {
                return @as(*const IDynamicRenderer.VTable, @ptrCast(self.vtable)).ReleaseCachedData(@as(*const IDynamicRenderer, @ptrCast(self)), strokeId);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDynamicRenderer_Refresh(self: *const T) HRESULT {
                return @as(*const IDynamicRenderer.VTable, @ptrCast(self.vtable)).Refresh(@as(*const IDynamicRenderer, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDynamicRenderer_Draw(self: *const T, hDC: HANDLE_PTR) HRESULT {
                return @as(*const IDynamicRenderer.VTable, @ptrCast(self.vtable)).Draw(@as(*const IDynamicRenderer, @ptrCast(self)), hDC);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IGestureRecognizer_Value = Guid.initString("ae9ef86b-7054-45e3-ae22-3174dc8811b7");
pub const IID_IGestureRecognizer = &IID_IGestureRecognizer_Value;
pub const IGestureRecognizer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Enabled: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IGestureRecognizer,
                pfEnabled: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IGestureRecognizer,
                pfEnabled: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Enabled: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IGestureRecognizer,
                fEnabled: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IGestureRecognizer,
                fEnabled: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MaxStrokeCount: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IGestureRecognizer,
                pcStrokes: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IGestureRecognizer,
                pcStrokes: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MaxStrokeCount: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IGestureRecognizer,
                cStrokes: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IGestureRecognizer,
                cStrokes: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnableGestures: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IGestureRecognizer,
                cGestures: u32,
                pGestures: [*]const i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IGestureRecognizer,
                cGestures: u32,
                pGestures: [*]const i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IGestureRecognizer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IGestureRecognizer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IGestureRecognizer_get_Enabled(self: *const T, pfEnabled: ?*BOOL) HRESULT {
                return @as(*const IGestureRecognizer.VTable, @ptrCast(self.vtable)).get_Enabled(@as(*const IGestureRecognizer, @ptrCast(self)), pfEnabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IGestureRecognizer_put_Enabled(self: *const T, fEnabled: BOOL) HRESULT {
                return @as(*const IGestureRecognizer.VTable, @ptrCast(self.vtable)).put_Enabled(@as(*const IGestureRecognizer, @ptrCast(self)), fEnabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IGestureRecognizer_get_MaxStrokeCount(self: *const T, pcStrokes: ?*i32) HRESULT {
                return @as(*const IGestureRecognizer.VTable, @ptrCast(self.vtable)).get_MaxStrokeCount(@as(*const IGestureRecognizer, @ptrCast(self)), pcStrokes);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IGestureRecognizer_put_MaxStrokeCount(self: *const T, cStrokes: i32) HRESULT {
                return @as(*const IGestureRecognizer.VTable, @ptrCast(self.vtable)).put_MaxStrokeCount(@as(*const IGestureRecognizer, @ptrCast(self)), cStrokes);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IGestureRecognizer_EnableGestures(self: *const T, cGestures: u32, pGestures: [*]const i32) HRESULT {
                return @as(*const IGestureRecognizer.VTable, @ptrCast(self.vtable)).EnableGestures(@as(*const IGestureRecognizer, @ptrCast(self)), cGestures, pGestures);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IGestureRecognizer_Reset(self: *const T) HRESULT {
                return @as(*const IGestureRecognizer.VTable, @ptrCast(self.vtable)).Reset(@as(*const IGestureRecognizer, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const RECO_GUIDE = extern struct {
    xOrigin: i32,
    yOrigin: i32,
    cxBox: i32,
    cyBox: i32,
    cxBase: i32,
    cyBase: i32,
    cHorzBox: i32,
    cVertBox: i32,
    cyMid: i32,
};

pub const RECO_ATTRS = extern struct {
    dwRecoCapabilityFlags: u32,
    awcVendorName: [32]u16,
    awcFriendlyName: [64]u16,
    awLanguageId: [64]u16,
};

pub const RECO_RANGE = extern struct {
    iwcBegin: u32,
    cCount: u32,
};

pub const LINE_SEGMENT = extern struct {
    PtA: POINT,
    PtB: POINT,
};

pub const LATTICE_METRICS = extern struct {
    lsBaseline: LINE_SEGMENT,
    iMidlineOffset: i16,
};

pub const LINE_METRICS = enum(i32) {
    BASELINE = 0,
    MIDLINE = 1,
    ASCENDER = 2,
    DESCENDER = 3,
};
pub const LM_BASELINE = LINE_METRICS.BASELINE;
pub const LM_MIDLINE = LINE_METRICS.MIDLINE;
pub const LM_ASCENDER = LINE_METRICS.ASCENDER;
pub const LM_DESCENDER = LINE_METRICS.DESCENDER;

pub const CONFIDENCE_LEVEL = enum(i32) {
    STRONG = 0,
    INTERMEDIATE = 1,
    POOR = 2,
};
pub const CFL_STRONG = CONFIDENCE_LEVEL.STRONG;
pub const CFL_INTERMEDIATE = CONFIDENCE_LEVEL.INTERMEDIATE;
pub const CFL_POOR = CONFIDENCE_LEVEL.POOR;

pub const ALT_BREAKS = enum(i32) {
    SAME = 0,
    UNIQUE = 1,
    FULL = 2,
};
pub const ALT_BREAKS_SAME = ALT_BREAKS.SAME;
pub const ALT_BREAKS_UNIQUE = ALT_BREAKS.UNIQUE;
pub const ALT_BREAKS_FULL = ALT_BREAKS.FULL;

pub const enumRECO_TYPE = enum(i32) {
    STRING = 0,
    CHAR = 1,
};
pub const RECO_TYPE_WSTRING = enumRECO_TYPE.STRING;
pub const RECO_TYPE_WCHAR = enumRECO_TYPE.CHAR;

pub const RECO_LATTICE_PROPERTY = extern struct {
    guidProperty: Guid,
    cbPropertyValue: u16,
    pPropertyValue: ?*u8,
};

pub const RECO_LATTICE_PROPERTIES = extern struct {
    cProperties: u32,
    apProps: ?*?*RECO_LATTICE_PROPERTY,
};

pub const RECO_LATTICE_ELEMENT = extern struct {
    score: i32,
    type: u16,
    pData: ?*u8,
    ulNextColumn: u32,
    ulStrokeNumber: u32,
    epProp: RECO_LATTICE_PROPERTIES,
};

pub const RECO_LATTICE_COLUMN = extern struct {
    key: u32,
    cpProp: RECO_LATTICE_PROPERTIES,
    cStrokes: u32,
    pStrokes: ?*u32,
    cLatticeElements: u32,
    pLatticeElements: ?*RECO_LATTICE_ELEMENT,
};

pub const RECO_LATTICE = extern struct {
    ulColumnCount: u32,
    pLatticeColumns: ?*RECO_LATTICE_COLUMN,
    ulPropertyCount: u32,
    pGuidProperties: ?*Guid,
    ulBestResultColumnCount: u32,
    pulBestResultColumns: ?*u32,
    pulBestResultIndexes: ?*u32,
};

pub const CHARACTER_RANGE = extern struct {
    wcLow: u16,
    cChars: u16,
};

const CLSID_TipAutoCompleteClient_Value = Guid.initString("807c1e6c-1d00-453f-b920-b61bb7cdd997");
pub const CLSID_TipAutoCompleteClient = &CLSID_TipAutoCompleteClient_Value;

const IID_ITipAutoCompleteProvider_Value = Guid.initString("7c6cf46d-8404-46b9-ad33-f5b6036d4007");
pub const IID_ITipAutoCompleteProvider = &IID_ITipAutoCompleteProvider_Value;
pub const ITipAutoCompleteProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        UpdatePendingText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITipAutoCompleteProvider,
                bstrPendingText: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITipAutoCompleteProvider,
                bstrPendingText: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Show: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITipAutoCompleteProvider,
                fShow: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITipAutoCompleteProvider,
                fShow: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITipAutoCompleteProvider_UpdatePendingText(self: *const T, bstrPendingText: ?BSTR) HRESULT {
                return @as(*const ITipAutoCompleteProvider.VTable, @ptrCast(self.vtable)).UpdatePendingText(@as(*const ITipAutoCompleteProvider, @ptrCast(self)), bstrPendingText);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITipAutoCompleteProvider_Show(self: *const T, fShow: BOOL) HRESULT {
                return @as(*const ITipAutoCompleteProvider.VTable, @ptrCast(self.vtable)).Show(@as(*const ITipAutoCompleteProvider, @ptrCast(self)), fShow);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITipAutoCompleteClient_Value = Guid.initString("5e078e03-8265-4bbe-9487-d242edbef910");
pub const IID_ITipAutoCompleteClient = &IID_ITipAutoCompleteClient_Value;
pub const ITipAutoCompleteClient = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AdviseProvider: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITipAutoCompleteClient,
                hWndField: ?HWND,
                pIProvider: ?*ITipAutoCompleteProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITipAutoCompleteClient,
                hWndField: ?HWND,
                pIProvider: ?*ITipAutoCompleteProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnadviseProvider: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITipAutoCompleteClient,
                hWndField: ?HWND,
                pIProvider: ?*ITipAutoCompleteProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITipAutoCompleteClient,
                hWndField: ?HWND,
                pIProvider: ?*ITipAutoCompleteProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UserSelection: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITipAutoCompleteClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITipAutoCompleteClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PreferredRects: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITipAutoCompleteClient,
                prcACList: ?*RECT,
                prcField: ?*RECT,
                prcModifiedACList: ?*RECT,
                pfShownAboveTip: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITipAutoCompleteClient,
                prcACList: ?*RECT,
                prcField: ?*RECT,
                prcModifiedACList: ?*RECT,
                pfShownAboveTip: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RequestShowUI: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITipAutoCompleteClient,
                hWndList: ?HWND,
                pfAllowShowing: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITipAutoCompleteClient,
                hWndList: ?HWND,
                pfAllowShowing: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITipAutoCompleteClient_AdviseProvider(self: *const T, hWndField: ?HWND, pIProvider: ?*ITipAutoCompleteProvider) HRESULT {
                return @as(*const ITipAutoCompleteClient.VTable, @ptrCast(self.vtable)).AdviseProvider(@as(*const ITipAutoCompleteClient, @ptrCast(self)), hWndField, pIProvider);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITipAutoCompleteClient_UnadviseProvider(self: *const T, hWndField: ?HWND, pIProvider: ?*ITipAutoCompleteProvider) HRESULT {
                return @as(*const ITipAutoCompleteClient.VTable, @ptrCast(self.vtable)).UnadviseProvider(@as(*const ITipAutoCompleteClient, @ptrCast(self)), hWndField, pIProvider);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITipAutoCompleteClient_UserSelection(self: *const T) HRESULT {
                return @as(*const ITipAutoCompleteClient.VTable, @ptrCast(self.vtable)).UserSelection(@as(*const ITipAutoCompleteClient, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITipAutoCompleteClient_PreferredRects(self: *const T, prcACList: ?*RECT, prcField: ?*RECT, prcModifiedACList: ?*RECT, pfShownAboveTip: ?*BOOL) HRESULT {
                return @as(*const ITipAutoCompleteClient.VTable, @ptrCast(self.vtable)).PreferredRects(@as(*const ITipAutoCompleteClient, @ptrCast(self)), prcACList, prcField, prcModifiedACList, pfShownAboveTip);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITipAutoCompleteClient_RequestShowUI(self: *const T, hWndList: ?HWND, pfAllowShowing: ?*BOOL) HRESULT {
                return @as(*const ITipAutoCompleteClient.VTable, @ptrCast(self.vtable)).RequestShowUI(@as(*const ITipAutoCompleteClient, @ptrCast(self)), hWndList, pfAllowShowing);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

//--------------------------------------------------------------------------------
// Section: Functions (27)
//--------------------------------------------------------------------------------
// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "inkobjcore" fn CreateRecognizer(
    pCLSID: ?*Guid,
    phrec: ?*?HRECOGNIZER,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "inkobjcore" fn DestroyRecognizer(
    hrec: ?HRECOGNIZER,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "inkobjcore" fn GetRecoAttributes(
    hrec: ?HRECOGNIZER,
    pRecoAttrs: ?*RECO_ATTRS,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "inkobjcore" fn CreateContext(
    hrec: ?HRECOGNIZER,
    phrc: ?*?HRECOCONTEXT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "inkobjcore" fn DestroyContext(
    hrc: ?HRECOCONTEXT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "inkobjcore" fn GetResultPropertyList(
    hrec: ?HRECOGNIZER,
    pPropertyCount: ?*u32,
    pPropertyGuid: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "inkobjcore" fn GetUnicodeRanges(
    hrec: ?HRECOGNIZER,
    pcRanges: ?*u32,
    pcr: ?*CHARACTER_RANGE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "inkobjcore" fn AddStroke(
    hrc: ?HRECOCONTEXT,
    pPacketDesc: ?*const PACKET_DESCRIPTION,
    cbPacket: u32,
    pPacket: ?*const u8,
    pXForm: ?*const XFORM,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "inkobjcore" fn GetBestResultString(
    hrc: ?HRECOCONTEXT,
    pcSize: ?*u32,
    pwcBestResult: ?[*:0]u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "inkobjcore" fn SetGuide(
    hrc: ?HRECOCONTEXT,
    pGuide: ?*const RECO_GUIDE,
    iIndex: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "inkobjcore" fn AdviseInkChange(
    hrc: ?HRECOCONTEXT,
    bNewStroke: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "inkobjcore" fn EndInkInput(
    hrc: ?HRECOCONTEXT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "inkobjcore" fn Process(
    hrc: ?HRECOCONTEXT,
    pbPartialProcessing: ?*BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "inkobjcore" fn SetFactoid(
    hrc: ?HRECOCONTEXT,
    cwcFactoid: u32,
    pwcFactoid: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "inkobjcore" fn SetFlags(
    hrc: ?HRECOCONTEXT,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "inkobjcore" fn GetLatticePtr(
    hrc: ?HRECOCONTEXT,
    ppLattice: ?*?*RECO_LATTICE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "inkobjcore" fn SetTextContext(
    hrc: ?HRECOCONTEXT,
    cwcBefore: u32,
    pwcBefore: [*:0]const u16,
    cwcAfter: u32,
    pwcAfter: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "inkobjcore" fn SetEnabledUnicodeRanges(
    hrc: ?HRECOCONTEXT,
    cRanges: u32,
    pcr: ?*CHARACTER_RANGE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "inkobjcore" fn IsStringSupported(
    hrc: ?HRECOCONTEXT,
    wcString: u32,
    pwcString: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "inkobjcore" fn SetWordList(
    hrc: ?HRECOCONTEXT,
    hwl: ?HRECOWORDLIST,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "inkobjcore" fn GetRightSeparator(
    hrc: ?HRECOCONTEXT,
    pcSize: ?*u32,
    pwcRightSeparator: [*:0]u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "inkobjcore" fn GetLeftSeparator(
    hrc: ?HRECOCONTEXT,
    pcSize: ?*u32,
    pwcLeftSeparator: [*:0]u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "inkobjcore" fn DestroyWordList(
    hwl: ?HRECOWORDLIST,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "inkobjcore" fn AddWordsToWordList(
    hwl: ?HRECOWORDLIST,
    pwcWords: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "inkobjcore" fn MakeWordList(
    hrec: ?HRECOGNIZER,
    pBuffer: ?PWSTR,
    phwl: ?*?HRECOWORDLIST,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "inkobjcore" fn GetAllRecognizers(
    recognizerClsids: ?*?*Guid,
    count: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "inkobjcore" fn LoadCachedAttributes(
    clsid: Guid,
    pRecoAttributes: ?*RECO_ATTRS,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {},
    .wide => struct {},
    .unspecified => if (@import("builtin").is_test) struct {} else struct {},
};
//--------------------------------------------------------------------------------
// Section: Imports (18)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const BOOL = @import("../foundation.zig").BOOL;
const BSTR = @import("../foundation.zig").BSTR;
const HANDLE_PTR = @import("../foundation.zig").HANDLE_PTR;
const HRESULT = @import("../foundation.zig").HRESULT;
const HWND = @import("../foundation.zig").HWND;
const IDataObject = @import("../system/com.zig").IDataObject;
const IDispatch = @import("../system/com.zig").IDispatch;
const IFontDisp = @import("../system/ole.zig").IFontDisp;
const IPictureDisp = @import("../system/ole.zig").IPictureDisp;
const IUnknown = @import("../system/com.zig").IUnknown;
const NMHDR = @import("../ui/controls.zig").NMHDR;
const POINT = @import("../foundation.zig").POINT;
const PWSTR = @import("../foundation.zig").PWSTR;
const RECT = @import("../foundation.zig").RECT;
const SAFEARRAY = @import("../system/com.zig").SAFEARRAY;
const VARIANT = @import("../system/com.zig").VARIANT;
const XFORM = @import("../graphics/gdi.zig").XFORM;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "PfnRecoCallback")) {
        _ = PfnRecoCallback;
    }

    @setEvalBranchQuota(comptime @import("std").meta.declarations(@This()).len * 3);

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        if (decl.is_pub) {
            _ = @field(@This(), decl.name);
        }
    }
}
