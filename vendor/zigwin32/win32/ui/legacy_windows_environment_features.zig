//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (19)
//--------------------------------------------------------------------------------
pub const EVCF_HASSETTINGS = @as(u32, 1);
pub const EVCF_ENABLEBYDEFAULT = @as(u32, 2);
pub const EVCF_REMOVEFROMLIST = @as(u32, 4);
pub const EVCF_ENABLEBYDEFAULT_AUTO = @as(u32, 8);
pub const EVCF_DONTSHOWIFZERO = @as(u32, 16);
pub const EVCF_SETTINGSMODE = @as(u32, 32);
pub const EVCF_OUTOFDISKSPACE = @as(u32, 64);
pub const EVCF_USERCONSENTOBTAINED = @as(u32, 128);
pub const EVCF_SYSTEMAUTORUN = @as(u32, 256);
pub const EVCCBF_LASTNOTIFICATION = @as(u32, 1);
pub const STATEBITS_FLAT = @as(u32, 1);
pub const REC_S_IDIDTHEUPDATES = @import("../zig.zig").typedConst(HRESULT, @as(i32, 266240));
pub const REC_S_NOTCOMPLETE = @import("../zig.zig").typedConst(HRESULT, @as(i32, 266241));
pub const REC_S_NOTCOMPLETEBUTPROPAGATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, 266242));
pub const REC_E_ABORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217408));
pub const REC_E_NOCALLBACK = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217407));
pub const REC_E_NORESIDUES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217406));
pub const REC_E_TOODIFFERENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217405));
pub const REC_E_INEEDTODOTHEUPDATES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217404));

//--------------------------------------------------------------------------------
// Section: Types (9)
//--------------------------------------------------------------------------------
// TODO: this type is limited to platform 'windows5.0'
const IID_IEmptyVolumeCacheCallBack_Value = Guid.initString("6e793361-73c6-11d0-8469-00aa00442901");
pub const IID_IEmptyVolumeCacheCallBack = &IID_IEmptyVolumeCacheCallBack_Value;
pub const IEmptyVolumeCacheCallBack = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ScanProgress: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEmptyVolumeCacheCallBack,
                dwlSpaceUsed: u64,
                dwFlags: u32,
                pcwszStatus: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEmptyVolumeCacheCallBack,
                dwlSpaceUsed: u64,
                dwFlags: u32,
                pcwszStatus: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PurgeProgress: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEmptyVolumeCacheCallBack,
                dwlSpaceFreed: u64,
                dwlSpaceToFree: u64,
                dwFlags: u32,
                pcwszStatus: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEmptyVolumeCacheCallBack,
                dwlSpaceFreed: u64,
                dwlSpaceToFree: u64,
                dwFlags: u32,
                pcwszStatus: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEmptyVolumeCacheCallBack_ScanProgress(self: *const T, dwlSpaceUsed: u64, dwFlags: u32, pcwszStatus: ?[*:0]const u16) HRESULT {
                return @as(*const IEmptyVolumeCacheCallBack.VTable, @ptrCast(self.vtable)).ScanProgress(@as(*const IEmptyVolumeCacheCallBack, @ptrCast(self)), dwlSpaceUsed, dwFlags, pcwszStatus);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEmptyVolumeCacheCallBack_PurgeProgress(self: *const T, dwlSpaceFreed: u64, dwlSpaceToFree: u64, dwFlags: u32, pcwszStatus: ?[*:0]const u16) HRESULT {
                return @as(*const IEmptyVolumeCacheCallBack.VTable, @ptrCast(self.vtable)).PurgeProgress(@as(*const IEmptyVolumeCacheCallBack, @ptrCast(self)), dwlSpaceFreed, dwlSpaceToFree, dwFlags, pcwszStatus);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEmptyVolumeCache_Value = Guid.initString("8fce5227-04da-11d1-a004-00805f8abe06");
pub const IID_IEmptyVolumeCache = &IID_IEmptyVolumeCache_Value;
pub const IEmptyVolumeCache = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEmptyVolumeCache,
                hkRegKey: ?HKEY,
                pcwszVolume: ?[*:0]const u16,
                ppwszDisplayName: ?*?PWSTR,
                ppwszDescription: ?*?PWSTR,
                pdwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEmptyVolumeCache,
                hkRegKey: ?HKEY,
                pcwszVolume: ?[*:0]const u16,
                ppwszDisplayName: ?*?PWSTR,
                ppwszDescription: ?*?PWSTR,
                pdwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSpaceUsed: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEmptyVolumeCache,
                pdwlSpaceUsed: ?*u64,
                picb: ?*IEmptyVolumeCacheCallBack,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEmptyVolumeCache,
                pdwlSpaceUsed: ?*u64,
                picb: ?*IEmptyVolumeCacheCallBack,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Purge: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEmptyVolumeCache,
                dwlSpaceToFree: u64,
                picb: ?*IEmptyVolumeCacheCallBack,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEmptyVolumeCache,
                dwlSpaceToFree: u64,
                picb: ?*IEmptyVolumeCacheCallBack,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ShowProperties: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEmptyVolumeCache,
                hwnd: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEmptyVolumeCache,
                hwnd: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Deactivate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEmptyVolumeCache,
                pdwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEmptyVolumeCache,
                pdwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEmptyVolumeCache_Initialize(self: *const T, hkRegKey: ?HKEY, pcwszVolume: ?[*:0]const u16, ppwszDisplayName: ?*?PWSTR, ppwszDescription: ?*?PWSTR, pdwFlags: ?*u32) HRESULT {
                return @as(*const IEmptyVolumeCache.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IEmptyVolumeCache, @ptrCast(self)), hkRegKey, pcwszVolume, ppwszDisplayName, ppwszDescription, pdwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEmptyVolumeCache_GetSpaceUsed(self: *const T, pdwlSpaceUsed: ?*u64, picb: ?*IEmptyVolumeCacheCallBack) HRESULT {
                return @as(*const IEmptyVolumeCache.VTable, @ptrCast(self.vtable)).GetSpaceUsed(@as(*const IEmptyVolumeCache, @ptrCast(self)), pdwlSpaceUsed, picb);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEmptyVolumeCache_Purge(self: *const T, dwlSpaceToFree: u64, picb: ?*IEmptyVolumeCacheCallBack) HRESULT {
                return @as(*const IEmptyVolumeCache.VTable, @ptrCast(self.vtable)).Purge(@as(*const IEmptyVolumeCache, @ptrCast(self)), dwlSpaceToFree, picb);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEmptyVolumeCache_ShowProperties(self: *const T, hwnd: ?HWND) HRESULT {
                return @as(*const IEmptyVolumeCache.VTable, @ptrCast(self.vtable)).ShowProperties(@as(*const IEmptyVolumeCache, @ptrCast(self)), hwnd);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEmptyVolumeCache_Deactivate(self: *const T, pdwFlags: ?*u32) HRESULT {
                return @as(*const IEmptyVolumeCache.VTable, @ptrCast(self.vtable)).Deactivate(@as(*const IEmptyVolumeCache, @ptrCast(self)), pdwFlags);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEmptyVolumeCache2_Value = Guid.initString("02b7e3ba-4db3-11d2-b2d9-00c04f8eec8c");
pub const IID_IEmptyVolumeCache2 = &IID_IEmptyVolumeCache2_Value;
pub const IEmptyVolumeCache2 = extern struct {
    pub const VTable = extern struct {
        base: IEmptyVolumeCache.VTable,
        InitializeEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEmptyVolumeCache2,
                hkRegKey: ?HKEY,
                pcwszVolume: ?[*:0]const u16,
                pcwszKeyName: ?[*:0]const u16,
                ppwszDisplayName: ?*?PWSTR,
                ppwszDescription: ?*?PWSTR,
                ppwszBtnText: ?*?PWSTR,
                pdwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEmptyVolumeCache2,
                hkRegKey: ?HKEY,
                pcwszVolume: ?[*:0]const u16,
                pcwszKeyName: ?[*:0]const u16,
                ppwszDisplayName: ?*?PWSTR,
                ppwszDescription: ?*?PWSTR,
                ppwszBtnText: ?*?PWSTR,
                pdwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IEmptyVolumeCache.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEmptyVolumeCache2_InitializeEx(self: *const T, hkRegKey: ?HKEY, pcwszVolume: ?[*:0]const u16, pcwszKeyName: ?[*:0]const u16, ppwszDisplayName: ?*?PWSTR, ppwszDescription: ?*?PWSTR, ppwszBtnText: ?*?PWSTR, pdwFlags: ?*u32) HRESULT {
                return @as(*const IEmptyVolumeCache2.VTable, @ptrCast(self.vtable)).InitializeEx(@as(*const IEmptyVolumeCache2, @ptrCast(self)), hkRegKey, pcwszVolume, pcwszKeyName, ppwszDisplayName, ppwszDescription, ppwszBtnText, pdwFlags);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IReconcileInitiator_Value = Guid.initString("99180161-da16-101a-935c-444553540000");
pub const IID_IReconcileInitiator = &IID_IReconcileInitiator_Value;
pub const IReconcileInitiator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetAbortCallback: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IReconcileInitiator,
                punkForAbort: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IReconcileInitiator,
                punkForAbort: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetProgressFeedback: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IReconcileInitiator,
                ulProgress: u32,
                ulProgressMax: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IReconcileInitiator,
                ulProgress: u32,
                ulProgressMax: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IReconcileInitiator_SetAbortCallback(self: *const T, punkForAbort: ?*IUnknown) HRESULT {
                return @as(*const IReconcileInitiator.VTable, @ptrCast(self.vtable)).SetAbortCallback(@as(*const IReconcileInitiator, @ptrCast(self)), punkForAbort);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IReconcileInitiator_SetProgressFeedback(self: *const T, ulProgress: u32, ulProgressMax: u32) HRESULT {
                return @as(*const IReconcileInitiator.VTable, @ptrCast(self.vtable)).SetProgressFeedback(@as(*const IReconcileInitiator, @ptrCast(self)), ulProgress, ulProgressMax);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const _reconcilef = enum(i32) {
    RECONCILEF_MAYBOTHERUSER = 1,
    RECONCILEF_FEEDBACKWINDOWVALID = 2,
    RECONCILEF_NORESIDUESOK = 4,
    RECONCILEF_OMITSELFRESIDUE = 8,
    RECONCILEF_RESUMERECONCILIATION = 16,
    RECONCILEF_YOUMAYDOTHEUPDATES = 32,
    RECONCILEF_ONLYYOUWERECHANGED = 64,
    ALL_RECONCILE_FLAGS = 127,
};
pub const RECONCILEF_MAYBOTHERUSER = _reconcilef.RECONCILEF_MAYBOTHERUSER;
pub const RECONCILEF_FEEDBACKWINDOWVALID = _reconcilef.RECONCILEF_FEEDBACKWINDOWVALID;
pub const RECONCILEF_NORESIDUESOK = _reconcilef.RECONCILEF_NORESIDUESOK;
pub const RECONCILEF_OMITSELFRESIDUE = _reconcilef.RECONCILEF_OMITSELFRESIDUE;
pub const RECONCILEF_RESUMERECONCILIATION = _reconcilef.RECONCILEF_RESUMERECONCILIATION;
pub const RECONCILEF_YOUMAYDOTHEUPDATES = _reconcilef.RECONCILEF_YOUMAYDOTHEUPDATES;
pub const RECONCILEF_ONLYYOUWERECHANGED = _reconcilef.RECONCILEF_ONLYYOUWERECHANGED;
pub const ALL_RECONCILE_FLAGS = _reconcilef.ALL_RECONCILE_FLAGS;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IReconcilableObject_Value = Guid.initString("99180162-da16-101a-935c-444553540000");
pub const IID_IReconcilableObject = &IID_IReconcilableObject_Value;
pub const IReconcilableObject = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Reconcile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IReconcilableObject,
                pInitiator: ?*IReconcileInitiator,
                dwFlags: u32,
                hwndOwner: ?HWND,
                hwndProgressFeedback: ?HWND,
                ulcInput: u32,
                rgpmkOtherInput: [*]?*IMoniker,
                plOutIndex: ?*i32,
                pstgNewResidues: ?*IStorage,
                pvReserved: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IReconcilableObject,
                pInitiator: ?*IReconcileInitiator,
                dwFlags: u32,
                hwndOwner: ?HWND,
                hwndProgressFeedback: ?HWND,
                ulcInput: u32,
                rgpmkOtherInput: [*]?*IMoniker,
                plOutIndex: ?*i32,
                pstgNewResidues: ?*IStorage,
                pvReserved: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProgressFeedbackMaxEstimate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IReconcilableObject,
                pulProgressMax: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IReconcilableObject,
                pulProgressMax: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IReconcilableObject_Reconcile(self: *const T, pInitiator: ?*IReconcileInitiator, dwFlags: u32, hwndOwner: ?HWND, hwndProgressFeedback: ?HWND, ulcInput: u32, rgpmkOtherInput: [*]?*IMoniker, plOutIndex: ?*i32, pstgNewResidues: ?*IStorage, pvReserved: ?*anyopaque) HRESULT {
                return @as(*const IReconcilableObject.VTable, @ptrCast(self.vtable)).Reconcile(@as(*const IReconcilableObject, @ptrCast(self)), pInitiator, dwFlags, hwndOwner, hwndProgressFeedback, ulcInput, rgpmkOtherInput, plOutIndex, pstgNewResidues, pvReserved);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IReconcilableObject_GetProgressFeedbackMaxEstimate(self: *const T, pulProgressMax: ?*u32) HRESULT {
                return @as(*const IReconcilableObject.VTable, @ptrCast(self.vtable)).GetProgressFeedbackMaxEstimate(@as(*const IReconcilableObject, @ptrCast(self)), pulProgressMax);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IBriefcaseInitiator_Value = Guid.initString("99180164-da16-101a-935c-444553540000");
pub const IID_IBriefcaseInitiator = &IID_IBriefcaseInitiator_Value;
pub const IBriefcaseInitiator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IsMonikerInBriefcase: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBriefcaseInitiator,
                pmk: ?*IMoniker,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBriefcaseInitiator,
                pmk: ?*IMoniker,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBriefcaseInitiator_IsMonikerInBriefcase(self: *const T, pmk: ?*IMoniker) HRESULT {
                return @as(*const IBriefcaseInitiator.VTable, @ptrCast(self.vtable)).IsMonikerInBriefcase(@as(*const IBriefcaseInitiator, @ptrCast(self)), pmk);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IActiveDesktopP_Value = Guid.initString("52502ee0-ec80-11d0-89ab-00c04fc2972d");
pub const IID_IActiveDesktopP = &IID_IActiveDesktopP_Value;
pub const IActiveDesktopP = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetSafeMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveDesktopP,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveDesktopP,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnsureUpdateHTML: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveDesktopP,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveDesktopP,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetScheme: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveDesktopP,
                pwszSchemeName: ?[*:0]const u16,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveDesktopP,
                pwszSchemeName: ?[*:0]const u16,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetScheme: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveDesktopP,
                pwszSchemeName: [*:0]u16,
                pdwcchBuffer: ?*u32,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveDesktopP,
                pwszSchemeName: [*:0]u16,
                pdwcchBuffer: ?*u32,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveDesktopP_SetSafeMode(self: *const T, dwFlags: u32) HRESULT {
                return @as(*const IActiveDesktopP.VTable, @ptrCast(self.vtable)).SetSafeMode(@as(*const IActiveDesktopP, @ptrCast(self)), dwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveDesktopP_EnsureUpdateHTML(self: *const T) HRESULT {
                return @as(*const IActiveDesktopP.VTable, @ptrCast(self.vtable)).EnsureUpdateHTML(@as(*const IActiveDesktopP, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveDesktopP_SetScheme(self: *const T, pwszSchemeName: ?[*:0]const u16, dwFlags: u32) HRESULT {
                return @as(*const IActiveDesktopP.VTable, @ptrCast(self.vtable)).SetScheme(@as(*const IActiveDesktopP, @ptrCast(self)), pwszSchemeName, dwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveDesktopP_GetScheme(self: *const T, pwszSchemeName: [*:0]u16, pdwcchBuffer: ?*u32, dwFlags: u32) HRESULT {
                return @as(*const IActiveDesktopP.VTable, @ptrCast(self.vtable)).GetScheme(@as(*const IActiveDesktopP, @ptrCast(self)), pwszSchemeName, pdwcchBuffer, dwFlags);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IADesktopP2_Value = Guid.initString("b22754e2-4574-11d1-9888-006097deacf9");
pub const IID_IADesktopP2 = &IID_IADesktopP2_Value;
pub const IADesktopP2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ReReadWallpaper: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IADesktopP2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IADesktopP2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetADObjectFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IADesktopP2,
                pdwFlags: ?*u32,
                dwMask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IADesktopP2,
                pdwFlags: ?*u32,
                dwMask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UpdateAllDesktopSubscriptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IADesktopP2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IADesktopP2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        MakeDynamicChanges: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IADesktopP2,
                pOleObj: ?*IOleObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IADesktopP2,
                pOleObj: ?*IOleObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IADesktopP2_ReReadWallpaper(self: *const T) HRESULT {
                return @as(*const IADesktopP2.VTable, @ptrCast(self.vtable)).ReReadWallpaper(@as(*const IADesktopP2, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IADesktopP2_GetADObjectFlags(self: *const T, pdwFlags: ?*u32, dwMask: u32) HRESULT {
                return @as(*const IADesktopP2.VTable, @ptrCast(self.vtable)).GetADObjectFlags(@as(*const IADesktopP2, @ptrCast(self)), pdwFlags, dwMask);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IADesktopP2_UpdateAllDesktopSubscriptions(self: *const T) HRESULT {
                return @as(*const IADesktopP2.VTable, @ptrCast(self.vtable)).UpdateAllDesktopSubscriptions(@as(*const IADesktopP2, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IADesktopP2_MakeDynamicChanges(self: *const T, pOleObj: ?*IOleObject) HRESULT {
                return @as(*const IADesktopP2.VTable, @ptrCast(self.vtable)).MakeDynamicChanges(@as(*const IADesktopP2, @ptrCast(self)), pOleObj);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

//--------------------------------------------------------------------------------
// Section: Functions (0)
//--------------------------------------------------------------------------------

//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {},
    .wide => struct {},
    .unspecified => if (@import("builtin").is_test) struct {} else struct {},
};
//--------------------------------------------------------------------------------
// Section: Imports (9)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const HKEY = @import("../system/registry.zig").HKEY;
const HRESULT = @import("../foundation.zig").HRESULT;
const HWND = @import("../foundation.zig").HWND;
const IMoniker = @import("../system/com.zig").IMoniker;
const IOleObject = @import("../system/ole.zig").IOleObject;
const IStorage = @import("../system/com/structured_storage.zig").IStorage;
const IUnknown = @import("../system/com.zig").IUnknown;
const PWSTR = @import("../foundation.zig").PWSTR;

test {
    @setEvalBranchQuota(comptime @import("std").meta.declarations(@This()).len * 3);

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        if (decl.is_pub) {
            _ = @field(@This(), decl.name);
        }
    }
}
