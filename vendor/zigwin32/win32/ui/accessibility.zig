//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (922)
//--------------------------------------------------------------------------------
pub const LIBID_Accessibility = Guid.initString("1ea4dbf0-3c3b-11cf-810c-00aa00389b71");
pub const CLSID_AccPropServices = Guid.initString("b5f8350b-0548-48b1-a6ee-88bd00b4a5e7");
pub const IIS_IsOleaccProxy = Guid.initString("902697fa-80e4-4560-802a-a13f22a64709");
pub const IIS_ControlAccessible = Guid.initString("38c682a6-9731-43f2-9fae-e901e641b101");
pub const ANRUS_PRIORITY_AUDIO_DYNAMIC_DUCK = @as(u32, 16);
pub const MSAA_MENU_SIG = @as(i32, -1441927155);
pub const PROPID_ACC_NAME = Guid.initString("608d3df8-8128-4aa7-a428-f55e49267291");
pub const PROPID_ACC_VALUE = Guid.initString("123fe443-211a-4615-9527-c45a7e93717a");
pub const PROPID_ACC_DESCRIPTION = Guid.initString("4d48dfe4-bd3f-491f-a648-492d6f20c588");
pub const PROPID_ACC_ROLE = Guid.initString("cb905ff2-7bd1-4c05-b3c8-e6c241364d70");
pub const PROPID_ACC_STATE = Guid.initString("a8d4d5b0-0a21-42d0-a5c0-514e984f457b");
pub const PROPID_ACC_HELP = Guid.initString("c831e11f-44db-4a99-9768-cb8f978b7231");
pub const PROPID_ACC_KEYBOARDSHORTCUT = Guid.initString("7d9bceee-7d1e-4979-9382-5180f4172c34");
pub const PROPID_ACC_DEFAULTACTION = Guid.initString("180c072b-c27f-43c7-9922-f63562a4632b");
pub const PROPID_ACC_HELPTOPIC = Guid.initString("787d1379-8ede-440b-8aec-11f7bf9030b3");
pub const PROPID_ACC_FOCUS = Guid.initString("6eb335df-1c29-4127-b12c-dee9fd157f2b");
pub const PROPID_ACC_SELECTION = Guid.initString("b99d073c-d731-405b-9061-d95e8f842984");
pub const PROPID_ACC_PARENT = Guid.initString("474c22b6-ffc2-467a-b1b5-e958b4657330");
pub const PROPID_ACC_NAV_UP = Guid.initString("016e1a2b-1a4e-4767-8612-3386f66935ec");
pub const PROPID_ACC_NAV_DOWN = Guid.initString("031670ed-3cdf-48d2-9613-138f2dd8a668");
pub const PROPID_ACC_NAV_LEFT = Guid.initString("228086cb-82f1-4a39-8705-dcdc0fff92f5");
pub const PROPID_ACC_NAV_RIGHT = Guid.initString("cd211d9f-e1cb-4fe5-a77c-920b884d095b");
pub const PROPID_ACC_NAV_PREV = Guid.initString("776d3891-c73b-4480-b3f6-076a16a15af6");
pub const PROPID_ACC_NAV_NEXT = Guid.initString("1cdc5455-8cd9-4c92-a371-3939a2fe3eee");
pub const PROPID_ACC_NAV_FIRSTCHILD = Guid.initString("cfd02558-557b-4c67-84f9-2a09fce40749");
pub const PROPID_ACC_NAV_LASTCHILD = Guid.initString("302ecaa5-48d5-4f8d-b671-1a8d20a77832");
pub const PROPID_ACC_ROLEMAP = Guid.initString("f79acda2-140d-4fe6-8914-208476328269");
pub const PROPID_ACC_VALUEMAP = Guid.initString("da1c3d79-fc5c-420e-b399-9d1533549e75");
pub const PROPID_ACC_STATEMAP = Guid.initString("43946c5e-0ac0-4042-b525-07bbdbe17fa7");
pub const PROPID_ACC_DESCRIPTIONMAP = Guid.initString("1ff1435f-8a14-477b-b226-a0abe279975d");
pub const PROPID_ACC_DODEFAULTACTION = Guid.initString("1ba09523-2e3b-49a6-a059-59682a3c48fd");
pub const DISPID_ACC_PARENT = @as(i32, -5000);
pub const DISPID_ACC_CHILDCOUNT = @as(i32, -5001);
pub const DISPID_ACC_CHILD = @as(i32, -5002);
pub const DISPID_ACC_NAME = @as(i32, -5003);
pub const DISPID_ACC_VALUE = @as(i32, -5004);
pub const DISPID_ACC_DESCRIPTION = @as(i32, -5005);
pub const DISPID_ACC_ROLE = @as(i32, -5006);
pub const DISPID_ACC_STATE = @as(i32, -5007);
pub const DISPID_ACC_HELP = @as(i32, -5008);
pub const DISPID_ACC_HELPTOPIC = @as(i32, -5009);
pub const DISPID_ACC_KEYBOARDSHORTCUT = @as(i32, -5010);
pub const DISPID_ACC_FOCUS = @as(i32, -5011);
pub const DISPID_ACC_SELECTION = @as(i32, -5012);
pub const DISPID_ACC_DEFAULTACTION = @as(i32, -5013);
pub const DISPID_ACC_SELECT = @as(i32, -5014);
pub const DISPID_ACC_LOCATION = @as(i32, -5015);
pub const DISPID_ACC_NAVIGATE = @as(i32, -5016);
pub const DISPID_ACC_HITTEST = @as(i32, -5017);
pub const DISPID_ACC_DODEFAULTACTION = @as(i32, -5018);
pub const NAVDIR_MIN = @as(u32, 0);
pub const NAVDIR_UP = @as(u32, 1);
pub const NAVDIR_DOWN = @as(u32, 2);
pub const NAVDIR_LEFT = @as(u32, 3);
pub const NAVDIR_RIGHT = @as(u32, 4);
pub const NAVDIR_NEXT = @as(u32, 5);
pub const NAVDIR_PREVIOUS = @as(u32, 6);
pub const NAVDIR_FIRSTCHILD = @as(u32, 7);
pub const NAVDIR_LASTCHILD = @as(u32, 8);
pub const NAVDIR_MAX = @as(u32, 9);
pub const SELFLAG_NONE = @as(u32, 0);
pub const SELFLAG_TAKEFOCUS = @as(u32, 1);
pub const SELFLAG_TAKESELECTION = @as(u32, 2);
pub const SELFLAG_EXTENDSELECTION = @as(u32, 4);
pub const SELFLAG_ADDSELECTION = @as(u32, 8);
pub const SELFLAG_REMOVESELECTION = @as(u32, 16);
pub const SELFLAG_VALID = @as(u32, 31);
pub const STATE_SYSTEM_NORMAL = @as(u32, 0);
pub const STATE_SYSTEM_HASPOPUP = @as(u32, 1073741824);
pub const ROLE_SYSTEM_TITLEBAR = @as(u32, 1);
pub const ROLE_SYSTEM_MENUBAR = @as(u32, 2);
pub const ROLE_SYSTEM_SCROLLBAR = @as(u32, 3);
pub const ROLE_SYSTEM_GRIP = @as(u32, 4);
pub const ROLE_SYSTEM_SOUND = @as(u32, 5);
pub const ROLE_SYSTEM_CURSOR = @as(u32, 6);
pub const ROLE_SYSTEM_CARET = @as(u32, 7);
pub const ROLE_SYSTEM_ALERT = @as(u32, 8);
pub const ROLE_SYSTEM_WINDOW = @as(u32, 9);
pub const ROLE_SYSTEM_CLIENT = @as(u32, 10);
pub const ROLE_SYSTEM_MENUPOPUP = @as(u32, 11);
pub const ROLE_SYSTEM_MENUITEM = @as(u32, 12);
pub const ROLE_SYSTEM_TOOLTIP = @as(u32, 13);
pub const ROLE_SYSTEM_APPLICATION = @as(u32, 14);
pub const ROLE_SYSTEM_DOCUMENT = @as(u32, 15);
pub const ROLE_SYSTEM_PANE = @as(u32, 16);
pub const ROLE_SYSTEM_CHART = @as(u32, 17);
pub const ROLE_SYSTEM_DIALOG = @as(u32, 18);
pub const ROLE_SYSTEM_BORDER = @as(u32, 19);
pub const ROLE_SYSTEM_GROUPING = @as(u32, 20);
pub const ROLE_SYSTEM_SEPARATOR = @as(u32, 21);
pub const ROLE_SYSTEM_TOOLBAR = @as(u32, 22);
pub const ROLE_SYSTEM_STATUSBAR = @as(u32, 23);
pub const ROLE_SYSTEM_TABLE = @as(u32, 24);
pub const ROLE_SYSTEM_COLUMNHEADER = @as(u32, 25);
pub const ROLE_SYSTEM_ROWHEADER = @as(u32, 26);
pub const ROLE_SYSTEM_COLUMN = @as(u32, 27);
pub const ROLE_SYSTEM_ROW = @as(u32, 28);
pub const ROLE_SYSTEM_CELL = @as(u32, 29);
pub const ROLE_SYSTEM_LINK = @as(u32, 30);
pub const ROLE_SYSTEM_HELPBALLOON = @as(u32, 31);
pub const ROLE_SYSTEM_CHARACTER = @as(u32, 32);
pub const ROLE_SYSTEM_LIST = @as(u32, 33);
pub const ROLE_SYSTEM_LISTITEM = @as(u32, 34);
pub const ROLE_SYSTEM_OUTLINE = @as(u32, 35);
pub const ROLE_SYSTEM_OUTLINEITEM = @as(u32, 36);
pub const ROLE_SYSTEM_PAGETAB = @as(u32, 37);
pub const ROLE_SYSTEM_PROPERTYPAGE = @as(u32, 38);
pub const ROLE_SYSTEM_INDICATOR = @as(u32, 39);
pub const ROLE_SYSTEM_GRAPHIC = @as(u32, 40);
pub const ROLE_SYSTEM_STATICTEXT = @as(u32, 41);
pub const ROLE_SYSTEM_TEXT = @as(u32, 42);
pub const ROLE_SYSTEM_PUSHBUTTON = @as(u32, 43);
pub const ROLE_SYSTEM_CHECKBUTTON = @as(u32, 44);
pub const ROLE_SYSTEM_RADIOBUTTON = @as(u32, 45);
pub const ROLE_SYSTEM_COMBOBOX = @as(u32, 46);
pub const ROLE_SYSTEM_DROPLIST = @as(u32, 47);
pub const ROLE_SYSTEM_PROGRESSBAR = @as(u32, 48);
pub const ROLE_SYSTEM_DIAL = @as(u32, 49);
pub const ROLE_SYSTEM_HOTKEYFIELD = @as(u32, 50);
pub const ROLE_SYSTEM_SLIDER = @as(u32, 51);
pub const ROLE_SYSTEM_SPINBUTTON = @as(u32, 52);
pub const ROLE_SYSTEM_DIAGRAM = @as(u32, 53);
pub const ROLE_SYSTEM_ANIMATION = @as(u32, 54);
pub const ROLE_SYSTEM_EQUATION = @as(u32, 55);
pub const ROLE_SYSTEM_BUTTONDROPDOWN = @as(u32, 56);
pub const ROLE_SYSTEM_BUTTONMENU = @as(u32, 57);
pub const ROLE_SYSTEM_BUTTONDROPDOWNGRID = @as(u32, 58);
pub const ROLE_SYSTEM_WHITESPACE = @as(u32, 59);
pub const ROLE_SYSTEM_PAGETABLIST = @as(u32, 60);
pub const ROLE_SYSTEM_CLOCK = @as(u32, 61);
pub const ROLE_SYSTEM_SPLITBUTTON = @as(u32, 62);
pub const ROLE_SYSTEM_IPADDRESS = @as(u32, 63);
pub const ROLE_SYSTEM_OUTLINEBUTTON = @as(u32, 64);
pub const UIA_E_ELEMENTNOTENABLED = @as(u32, 2147746304);
pub const UIA_E_ELEMENTNOTAVAILABLE = @as(u32, 2147746305);
pub const UIA_E_NOCLICKABLEPOINT = @as(u32, 2147746306);
pub const UIA_E_PROXYASSEMBLYNOTLOADED = @as(u32, 2147746307);
pub const UIA_E_NOTSUPPORTED = @as(u32, 2147746308);
pub const UIA_E_INVALIDOPERATION = @as(u32, 2148734217);
pub const UIA_E_TIMEOUT = @as(u32, 2148734213);
pub const UiaAppendRuntimeId = @as(u32, 3);
pub const UiaRootObjectId = @as(i32, -25);
pub const RuntimeId_Property_GUID = Guid.initString("a39eebfa-7fba-4c89-b4d4-b99e2de7d160");
pub const BoundingRectangle_Property_GUID = Guid.initString("7bbfe8b2-3bfc-48dd-b729-c794b846e9a1");
pub const ProcessId_Property_GUID = Guid.initString("40499998-9c31-4245-a403-87320e59eaf6");
pub const ControlType_Property_GUID = Guid.initString("ca774fea-28ac-4bc2-94ca-acec6d6c10a3");
pub const LocalizedControlType_Property_GUID = Guid.initString("8763404f-a1bd-452a-89c4-3f01d3833806");
pub const Name_Property_GUID = Guid.initString("c3a6921b-4a99-44f1-bca6-61187052c431");
pub const AcceleratorKey_Property_GUID = Guid.initString("514865df-2557-4cb9-aeed-6ced084ce52c");
pub const AccessKey_Property_GUID = Guid.initString("06827b12-a7f9-4a15-917c-ffa5ad3eb0a7");
pub const HasKeyboardFocus_Property_GUID = Guid.initString("cf8afd39-3f46-4800-9656-b2bf12529905");
pub const IsKeyboardFocusable_Property_GUID = Guid.initString("f7b8552a-0859-4b37-b9cb-51e72092f29f");
pub const IsEnabled_Property_GUID = Guid.initString("2109427f-da60-4fed-bf1b-264bdce6eb3a");
pub const AutomationId_Property_GUID = Guid.initString("c82c0500-b60e-4310-a267-303c531f8ee5");
pub const ClassName_Property_GUID = Guid.initString("157b7215-894f-4b65-84e2-aac0da08b16b");
pub const HelpText_Property_GUID = Guid.initString("08555685-0977-45c7-a7a6-abaf5684121a");
pub const ClickablePoint_Property_GUID = Guid.initString("0196903b-b203-4818-a9f3-f08e675f2341");
pub const Culture_Property_GUID = Guid.initString("e2d74f27-3d79-4dc2-b88b-3044963a8afb");
pub const IsControlElement_Property_GUID = Guid.initString("95f35085-abcc-4afd-a5f4-dbb46c230fdb");
pub const IsContentElement_Property_GUID = Guid.initString("4bda64a8-f5d8-480b-8155-ef2e89adb672");
pub const LabeledBy_Property_GUID = Guid.initString("e5b8924b-fc8a-4a35-8031-cf78ac43e55e");
pub const IsPassword_Property_GUID = Guid.initString("e8482eb1-687c-497b-bebc-03be53ec1454");
pub const NewNativeWindowHandle_Property_GUID = Guid.initString("5196b33b-380a-4982-95e1-91f3ef60e024");
pub const ItemType_Property_GUID = Guid.initString("cdda434d-6222-413b-a68a-325dd1d40f39");
pub const IsOffscreen_Property_GUID = Guid.initString("03c3d160-db79-42db-a2ef-1c231eede507");
pub const Orientation_Property_GUID = Guid.initString("a01eee62-3884-4415-887e-678ec21e39ba");
pub const FrameworkId_Property_GUID = Guid.initString("dbfd9900-7e1a-4f58-b61b-7063120f773b");
pub const IsRequiredForForm_Property_GUID = Guid.initString("4f5f43cf-59fb-4bde-a270-602e5e1141e9");
pub const ItemStatus_Property_GUID = Guid.initString("51de0321-3973-43e7-8913-0b08e813c37f");
pub const AriaRole_Property_GUID = Guid.initString("dd207b95-be4a-4e0d-b727-63ace94b6916");
pub const AriaProperties_Property_GUID = Guid.initString("4213678c-e025-4922-beb5-e43ba08e6221");
pub const IsDataValidForForm_Property_GUID = Guid.initString("445ac684-c3fc-4dd9-acf8-845a579296ba");
pub const ControllerFor_Property_GUID = Guid.initString("51124c8a-a5d2-4f13-9be6-7fa8ba9d3a90");
pub const DescribedBy_Property_GUID = Guid.initString("7c5865b8-9992-40fd-8db0-6bf1d317f998");
pub const FlowsTo_Property_GUID = Guid.initString("e4f33d20-559a-47fb-a830-f9cb4ff1a70a");
pub const ProviderDescription_Property_GUID = Guid.initString("dca5708a-c16b-4cd9-b889-beb16a804904");
pub const OptimizeForVisualContent_Property_GUID = Guid.initString("6a852250-c75a-4e5d-b858-e381b0f78861");
pub const IsDockPatternAvailable_Property_GUID = Guid.initString("2600a4c4-2ff8-4c96-ae31-8fe619a13c6c");
pub const IsExpandCollapsePatternAvailable_Property_GUID = Guid.initString("929d3806-5287-4725-aa16-222afc63d595");
pub const IsGridItemPatternAvailable_Property_GUID = Guid.initString("5a43e524-f9a2-4b12-84c8-b48a3efedd34");
pub const IsGridPatternAvailable_Property_GUID = Guid.initString("5622c26c-f0ef-4f3b-97cb-714c0868588b");
pub const IsInvokePatternAvailable_Property_GUID = Guid.initString("4e725738-8364-4679-aa6c-f3f41931f750");
pub const IsMultipleViewPatternAvailable_Property_GUID = Guid.initString("ff0a31eb-8e25-469d-8d6e-e771a27c1b90");
pub const IsRangeValuePatternAvailable_Property_GUID = Guid.initString("fda4244a-eb4d-43ff-b5ad-ed36d373ec4c");
pub const IsScrollPatternAvailable_Property_GUID = Guid.initString("3ebb7b4a-828a-4b57-9d22-2fea1632ed0d");
pub const IsScrollItemPatternAvailable_Property_GUID = Guid.initString("1cad1a05-0927-4b76-97e1-0fcdb209b98a");
pub const IsSelectionItemPatternAvailable_Property_GUID = Guid.initString("8becd62d-0bc3-4109-bee2-8e6715290e68");
pub const IsSelectionPatternAvailable_Property_GUID = Guid.initString("f588acbe-c769-4838-9a60-2686dc1188c4");
pub const IsTablePatternAvailable_Property_GUID = Guid.initString("cb83575f-45c2-4048-9c76-159715a139df");
pub const IsTableItemPatternAvailable_Property_GUID = Guid.initString("eb36b40d-8ea4-489b-a013-e60d5951fe34");
pub const IsTextPatternAvailable_Property_GUID = Guid.initString("fbe2d69d-aff6-4a45-82e2-fc92a82f5917");
pub const IsTogglePatternAvailable_Property_GUID = Guid.initString("78686d53-fcd0-4b83-9b78-5832ce63bb5b");
pub const IsTransformPatternAvailable_Property_GUID = Guid.initString("a7f78804-d68b-4077-a5c6-7a5ea1ac31c5");
pub const IsValuePatternAvailable_Property_GUID = Guid.initString("0b5020a7-2119-473b-be37-5ceb98bbfb22");
pub const IsWindowPatternAvailable_Property_GUID = Guid.initString("e7a57bb1-5888-4155-98dc-b422fd57f2bc");
pub const IsLegacyIAccessiblePatternAvailable_Property_GUID = Guid.initString("d8ebd0c7-929a-4ee7-8d3a-d3d94413027b");
pub const IsItemContainerPatternAvailable_Property_GUID = Guid.initString("624b5ca7-fe40-4957-a019-20c4cf11920f");
pub const IsVirtualizedItemPatternAvailable_Property_GUID = Guid.initString("302cb151-2ac8-45d6-977b-d2b3a5a53f20");
pub const IsSynchronizedInputPatternAvailable_Property_GUID = Guid.initString("75d69cc5-d2bf-4943-876e-b45b62a6cc66");
pub const IsObjectModelPatternAvailable_Property_GUID = Guid.initString("6b21d89b-2841-412f-8ef2-15ca952318ba");
pub const IsAnnotationPatternAvailable_Property_GUID = Guid.initString("0b5b3238-6d5c-41b6-bcc4-5e807f6551c4");
pub const IsTextPattern2Available_Property_GUID = Guid.initString("41cf921d-e3f1-4b22-9c81-e1c3ed331c22");
pub const IsTextEditPatternAvailable_Property_GUID = Guid.initString("7843425c-8b32-484c-9ab5-e3200571ffda");
pub const IsCustomNavigationPatternAvailable_Property_GUID = Guid.initString("8f8e80d4-2351-48e0-874a-54aa7313889a");
pub const IsStylesPatternAvailable_Property_GUID = Guid.initString("27f353d3-459c-4b59-a490-50611dacafb5");
pub const IsSpreadsheetPatternAvailable_Property_GUID = Guid.initString("6ff43732-e4b4-4555-97bc-ecdbbc4d1888");
pub const IsSpreadsheetItemPatternAvailable_Property_GUID = Guid.initString("9fe79b2a-2f94-43fd-996b-549e316f4acd");
pub const IsTransformPattern2Available_Property_GUID = Guid.initString("25980b4b-be04-4710-ab4a-fda31dbd2895");
pub const IsTextChildPatternAvailable_Property_GUID = Guid.initString("559e65df-30ff-43b5-b5ed-5b283b80c7e9");
pub const IsDragPatternAvailable_Property_GUID = Guid.initString("e997a7b7-1d39-4ca7-be0f-277fcf5605cc");
pub const IsDropTargetPatternAvailable_Property_GUID = Guid.initString("0686b62e-8e19-4aaf-873d-384f6d3b92be");
pub const IsStructuredMarkupPatternAvailable_Property_GUID = Guid.initString("b0d4c196-2c0b-489c-b165-a405928c6f3d");
pub const IsPeripheral_Property_GUID = Guid.initString("da758276-7ed5-49d4-8e68-ecc9a2d300dd");
pub const PositionInSet_Property_GUID = Guid.initString("33d1dc54-641e-4d76-a6b1-13f341c1f896");
pub const SizeOfSet_Property_GUID = Guid.initString("1600d33c-3b9f-4369-9431-aa293f344cf1");
pub const Level_Property_GUID = Guid.initString("242ac529-cd36-400f-aad9-7876ef3af627");
pub const AnnotationTypes_Property_GUID = Guid.initString("64b71f76-53c4-4696-a219-20e940c9a176");
pub const AnnotationObjects_Property_GUID = Guid.initString("310910c8-7c6e-4f20-becd-4aaf6d191156");
pub const LandmarkType_Property_GUID = Guid.initString("454045f2-6f61-49f7-a4f8-b5f0cf82da1e");
pub const LocalizedLandmarkType_Property_GUID = Guid.initString("7ac81980-eafb-4fb2-bf91-f485bef5e8e1");
pub const FullDescription_Property_GUID = Guid.initString("0d4450ff-6aef-4f33-95dd-7befa72a4391");
pub const Value_Value_Property_GUID = Guid.initString("e95f5e64-269f-4a85-ba99-4092c3ea2986");
pub const Value_IsReadOnly_Property_GUID = Guid.initString("eb090f30-e24c-4799-a705-0d247bc037f8");
pub const RangeValue_Value_Property_GUID = Guid.initString("131f5d98-c50c-489d-abe5-ae220898c5f7");
pub const RangeValue_IsReadOnly_Property_GUID = Guid.initString("25fa1055-debf-4373-a79e-1f1a1908d3c4");
pub const RangeValue_Minimum_Property_GUID = Guid.initString("78cbd3b2-684d-4860-af93-d1f95cb022fd");
pub const RangeValue_Maximum_Property_GUID = Guid.initString("19319914-f979-4b35-a1a6-d37e05433473");
pub const RangeValue_LargeChange_Property_GUID = Guid.initString("a1f96325-3a3d-4b44-8e1f-4a46d9844019");
pub const RangeValue_SmallChange_Property_GUID = Guid.initString("81c2c457-3941-4107-9975-139760f7c072");
pub const Scroll_HorizontalScrollPercent_Property_GUID = Guid.initString("c7c13c0e-eb21-47ff-acc4-b5a3350f5191");
pub const Scroll_HorizontalViewSize_Property_GUID = Guid.initString("70c2e5d4-fcb0-4713-a9aa-af92ff79e4cd");
pub const Scroll_VerticalScrollPercent_Property_GUID = Guid.initString("6c8d7099-b2a8-4948-bff7-3cf9058bfefb");
pub const Scroll_VerticalViewSize_Property_GUID = Guid.initString("de6a2e22-d8c7-40c5-83ba-e5f681d53108");
pub const Scroll_HorizontallyScrollable_Property_GUID = Guid.initString("8b925147-28cd-49ae-bd63-f44118d2e719");
pub const Scroll_VerticallyScrollable_Property_GUID = Guid.initString("89164798-0068-4315-b89a-1e7cfbbc3dfc");
pub const Selection_Selection_Property_GUID = Guid.initString("aa6dc2a2-0e2b-4d38-96d5-34e470b81853");
pub const Selection_CanSelectMultiple_Property_GUID = Guid.initString("49d73da5-c883-4500-883d-8fcf8daf6cbe");
pub const Selection_IsSelectionRequired_Property_GUID = Guid.initString("b1ae4422-63fe-44e7-a5a5-a738c829b19a");
pub const Grid_RowCount_Property_GUID = Guid.initString("2a9505bf-c2eb-4fb6-b356-8245ae53703e");
pub const Grid_ColumnCount_Property_GUID = Guid.initString("fe96f375-44aa-4536-ac7a-2a75d71a3efc");
pub const GridItem_Row_Property_GUID = Guid.initString("6223972a-c945-4563-9329-fdc974af2553");
pub const GridItem_Column_Property_GUID = Guid.initString("c774c15c-62c0-4519-8bdc-47be573c8ad5");
pub const GridItem_RowSpan_Property_GUID = Guid.initString("4582291c-466b-4e93-8e83-3d1715ec0c5e");
pub const GridItem_ColumnSpan_Property_GUID = Guid.initString("583ea3f5-86d0-4b08-a6ec-2c5463ffc109");
pub const GridItem_Parent_Property_GUID = Guid.initString("9d912252-b97f-4ecc-8510-ea0e33427c72");
pub const Dock_DockPosition_Property_GUID = Guid.initString("6d67f02e-c0b0-4b10-b5b9-18d6ecf98760");
pub const ExpandCollapse_ExpandCollapseState_Property_GUID = Guid.initString("275a4c48-85a7-4f69-aba0-af157610002b");
pub const MultipleView_CurrentView_Property_GUID = Guid.initString("7a81a67a-b94f-4875-918b-65c8d2f998e5");
pub const MultipleView_SupportedViews_Property_GUID = Guid.initString("8d5db9fd-ce3c-4ae7-b788-400a3c645547");
pub const Window_CanMaximize_Property_GUID = Guid.initString("64fff53f-635d-41c1-950c-cb5adfbe28e3");
pub const Window_CanMinimize_Property_GUID = Guid.initString("b73b4625-5988-4b97-b4c2-a6fe6e78c8c6");
pub const Window_WindowVisualState_Property_GUID = Guid.initString("4ab7905f-e860-453e-a30a-f6431e5daad5");
pub const Window_WindowInteractionState_Property_GUID = Guid.initString("4fed26a4-0455-4fa2-b21c-c4da2db1ff9c");
pub const Window_IsModal_Property_GUID = Guid.initString("ff4e6892-37b9-4fca-8532-ffe674ecfeed");
pub const Window_IsTopmost_Property_GUID = Guid.initString("ef7d85d3-0937-4962-9241-b62345f24041");
pub const SelectionItem_IsSelected_Property_GUID = Guid.initString("f122835f-cd5f-43df-b79d-4b849e9e6020");
pub const SelectionItem_SelectionContainer_Property_GUID = Guid.initString("a4365b6e-9c1e-4b63-8b53-c2421dd1e8fb");
pub const Table_RowHeaders_Property_GUID = Guid.initString("d9e35b87-6eb8-4562-aac6-a8a9075236a8");
pub const Table_ColumnHeaders_Property_GUID = Guid.initString("aff1d72b-968d-42b1-b459-150b299da664");
pub const Table_RowOrColumnMajor_Property_GUID = Guid.initString("83be75c3-29fe-4a30-85e1-2a6277fd106e");
pub const TableItem_RowHeaderItems_Property_GUID = Guid.initString("b3f853a0-0574-4cd8-bcd7-ed5923572d97");
pub const TableItem_ColumnHeaderItems_Property_GUID = Guid.initString("967a56a3-74b6-431e-8de6-99c411031c58");
pub const Toggle_ToggleState_Property_GUID = Guid.initString("b23cdc52-22c2-4c6c-9ded-f5c422479ede");
pub const Transform_CanMove_Property_GUID = Guid.initString("1b75824d-208b-4fdf-bccd-f1f4e5741f4f");
pub const Transform_CanResize_Property_GUID = Guid.initString("bb98dca5-4c1a-41d4-a4f6-ebc128644180");
pub const Transform_CanRotate_Property_GUID = Guid.initString("10079b48-3849-476f-ac96-44a95c8440d9");
pub const LegacyIAccessible_ChildId_Property_GUID = Guid.initString("9a191b5d-9ef2-4787-a459-dcde885dd4e8");
pub const LegacyIAccessible_Name_Property_GUID = Guid.initString("caeb063d-40ae-4869-aa5a-1b8e5d666739");
pub const LegacyIAccessible_Value_Property_GUID = Guid.initString("b5c5b0b6-8217-4a77-97a5-190a85ed0156");
pub const LegacyIAccessible_Description_Property_GUID = Guid.initString("46448418-7d70-4ea9-9d27-b7e775cf2ad7");
pub const LegacyIAccessible_Role_Property_GUID = Guid.initString("6856e59f-cbaf-4e31-93e8-bcbf6f7e491c");
pub const LegacyIAccessible_State_Property_GUID = Guid.initString("df985854-2281-4340-ab9c-c60e2c5803f6");
pub const LegacyIAccessible_Help_Property_GUID = Guid.initString("94402352-161c-4b77-a98d-a872cc33947a");
pub const LegacyIAccessible_KeyboardShortcut_Property_GUID = Guid.initString("8f6909ac-00b8-4259-a41c-966266d43a8a");
pub const LegacyIAccessible_Selection_Property_GUID = Guid.initString("8aa8b1e0-0891-40cc-8b06-90d7d4166219");
pub const LegacyIAccessible_DefaultAction_Property_GUID = Guid.initString("3b331729-eaad-4502-b85f-92615622913c");
pub const Annotation_AnnotationTypeId_Property_GUID = Guid.initString("20ae484f-69ef-4c48-8f5b-c4938b206ac7");
pub const Annotation_AnnotationTypeName_Property_GUID = Guid.initString("9b818892-5ac9-4af9-aa96-f58a77b058e3");
pub const Annotation_Author_Property_GUID = Guid.initString("7a528462-9c5c-4a03-a974-8b307a9937f2");
pub const Annotation_DateTime_Property_GUID = Guid.initString("99b5ca5d-1acf-414b-a4d0-6b350b047578");
pub const Annotation_Target_Property_GUID = Guid.initString("b71b302d-2104-44ad-9c5c-092b4907d70f");
pub const Styles_StyleId_Property_GUID = Guid.initString("da82852f-3817-4233-82af-02279e72cc77");
pub const Styles_StyleName_Property_GUID = Guid.initString("1c12b035-05d1-4f55-9e8e-1489f3ff550d");
pub const Styles_FillColor_Property_GUID = Guid.initString("63eff97a-a1c5-4b1d-84eb-b765f2edd632");
pub const Styles_FillPatternStyle_Property_GUID = Guid.initString("81cf651f-482b-4451-a30a-e1545e554fb8");
pub const Styles_Shape_Property_GUID = Guid.initString("c71a23f8-778c-400d-8458-3b543e526984");
pub const Styles_FillPatternColor_Property_GUID = Guid.initString("939a59fe-8fbd-4e75-a271-ac4595195163");
pub const Styles_ExtendedProperties_Property_GUID = Guid.initString("f451cda0-ba0a-4681-b0b0-0dbdb53e58f3");
pub const SpreadsheetItem_Formula_Property_GUID = Guid.initString("e602e47d-1b47-4bea-87cf-3b0b0b5c15b6");
pub const SpreadsheetItem_AnnotationObjects_Property_GUID = Guid.initString("a3194c38-c9bc-4604-9396-ae3f9f457f7b");
pub const SpreadsheetItem_AnnotationTypes_Property_GUID = Guid.initString("c70c51d0-d602-4b45-afbc-b4712b96d72b");
pub const Transform2_CanZoom_Property_GUID = Guid.initString("f357e890-a756-4359-9ca6-86702bf8f381");
pub const LiveSetting_Property_GUID = Guid.initString("c12bcd8e-2a8e-4950-8ae7-3625111d58eb");
pub const Drag_IsGrabbed_Property_GUID = Guid.initString("45f206f3-75cc-4cca-a9b9-fcdfb982d8a2");
pub const Drag_GrabbedItems_Property_GUID = Guid.initString("77c1562c-7b86-4b21-9ed7-3cefda6f4c43");
pub const Drag_DropEffect_Property_GUID = Guid.initString("646f2779-48d3-4b23-8902-4bf100005df3");
pub const Drag_DropEffects_Property_GUID = Guid.initString("f5d61156-7ce6-49be-a836-9269dcec920f");
pub const DropTarget_DropTargetEffect_Property_GUID = Guid.initString("8bb75975-a0ca-4981-b818-87fc66e9509d");
pub const DropTarget_DropTargetEffects_Property_GUID = Guid.initString("bc1dd4ed-cb89-45f1-a592-e03b08ae790f");
pub const Transform2_ZoomLevel_Property_GUID = Guid.initString("eee29f1a-f4a2-4b5b-ac65-95cf93283387");
pub const Transform2_ZoomMinimum_Property_GUID = Guid.initString("742ccc16-4ad1-4e07-96fe-b122c6e6b22b");
pub const Transform2_ZoomMaximum_Property_GUID = Guid.initString("42ab6b77-ceb0-4eca-b82a-6cfa5fa1fc08");
pub const FlowsFrom_Property_GUID = Guid.initString("05c6844f-19de-48f8-95fa-880d5b0fd615");
pub const FillColor_Property_GUID = Guid.initString("6e0ec4d0-e2a8-4a56-9de7-953389933b39");
pub const OutlineColor_Property_GUID = Guid.initString("c395d6c0-4b55-4762-a073-fd303a634f52");
pub const FillType_Property_GUID = Guid.initString("c6fc74e4-8cb9-429c-a9e1-9bc4ac372b62");
pub const VisualEffects_Property_GUID = Guid.initString("e61a8565-aad9-46d7-9e70-4e8a8420d420");
pub const OutlineThickness_Property_GUID = Guid.initString("13e67cc7-dac2-4888-bdd3-375c62fa9618");
pub const CenterPoint_Property_GUID = Guid.initString("0cb00c08-540c-4edb-9445-26359ea69785");
pub const Rotation_Property_GUID = Guid.initString("767cdc7d-aec0-4110-ad32-30edd403492e");
pub const Size_Property_GUID = Guid.initString("2b5f761d-f885-4404-973f-9b1d98e36d8f");
pub const ToolTipOpened_Event_GUID = Guid.initString("3f4b97ff-2edc-451d-bca4-95a3188d5b03");
pub const ToolTipClosed_Event_GUID = Guid.initString("276d71ef-24a9-49b6-8e97-da98b401bbcd");
pub const StructureChanged_Event_GUID = Guid.initString("59977961-3edd-4b11-b13b-676b2a2a6ca9");
pub const MenuOpened_Event_GUID = Guid.initString("ebe2e945-66ca-4ed1-9ff8-2ad7df0a1b08");
pub const AutomationPropertyChanged_Event_GUID = Guid.initString("2527fba1-8d7a-4630-a4cc-e66315942f52");
pub const AutomationFocusChanged_Event_GUID = Guid.initString("b68a1f17-f60d-41a7-a3cc-b05292155fe0");
pub const ActiveTextPositionChanged_Event_GUID = Guid.initString("a5c09e9c-c77d-4f25-b491-e5bb7017cbd4");
pub const AsyncContentLoaded_Event_GUID = Guid.initString("5fdee11c-d2fa-4fb9-904e-5cbee894d5ef");
pub const MenuClosed_Event_GUID = Guid.initString("3cf1266e-1582-4041-acd7-88a35a965297");
pub const LayoutInvalidated_Event_GUID = Guid.initString("ed7d6544-a6bd-4595-9bae-3d28946cc715");
pub const Invoke_Invoked_Event_GUID = Guid.initString("dfd699f0-c915-49dd-b422-dde785c3d24b");
pub const SelectionItem_ElementAddedToSelectionEvent_Event_GUID = Guid.initString("3c822dd1-c407-4dba-91dd-79d4aed0aec6");
pub const SelectionItem_ElementRemovedFromSelectionEvent_Event_GUID = Guid.initString("097fa8a9-7079-41af-8b9c-0934d8305e5c");
pub const SelectionItem_ElementSelectedEvent_Event_GUID = Guid.initString("b9c7dbfb-4ebe-4532-aaf4-008cf647233c");
pub const Selection_InvalidatedEvent_Event_GUID = Guid.initString("cac14904-16b4-4b53-8e47-4cb1df267bb7");
pub const Text_TextSelectionChangedEvent_Event_GUID = Guid.initString("918edaa1-71b3-49ae-9741-79beb8d358f3");
pub const Text_TextChangedEvent_Event_GUID = Guid.initString("4a342082-f483-48c4-ac11-a84b435e2a84");
pub const Window_WindowOpened_Event_GUID = Guid.initString("d3e81d06-de45-4f2f-9633-de9e02fb65af");
pub const Window_WindowClosed_Event_GUID = Guid.initString("edf141f8-fa67-4e22-bbf7-944e05735ee2");
pub const MenuModeStart_Event_GUID = Guid.initString("18d7c631-166a-4ac9-ae3b-ef4b5420e681");
pub const MenuModeEnd_Event_GUID = Guid.initString("9ecd4c9f-80dd-47b8-8267-5aec06bb2cff");
pub const InputReachedTarget_Event_GUID = Guid.initString("93ed549a-0549-40f0-bedb-28e44f7de2a3");
pub const InputReachedOtherElement_Event_GUID = Guid.initString("ed201d8a-4e6c-415e-a874-2460c9b66ba8");
pub const InputDiscarded_Event_GUID = Guid.initString("7f36c367-7b18-417c-97e3-9d58ddc944ab");
pub const SystemAlert_Event_GUID = Guid.initString("d271545d-7a3a-47a7-8474-81d29a2451c9");
pub const LiveRegionChanged_Event_GUID = Guid.initString("102d5e90-e6a9-41b6-b1c5-a9b1929d9510");
pub const HostedFragmentRootsInvalidated_Event_GUID = Guid.initString("e6bdb03e-0921-4ec5-8dcf-eae877b0426b");
pub const Drag_DragStart_Event_GUID = Guid.initString("883a480b-3aa9-429d-95e4-d9c8d011f0dd");
pub const Drag_DragCancel_Event_GUID = Guid.initString("c3ede6fa-3451-4e0f-9e71-df9c280a4657");
pub const Drag_DragComplete_Event_GUID = Guid.initString("38e96188-ef1f-463e-91ca-3a7792c29caf");
pub const DropTarget_DragEnter_Event_GUID = Guid.initString("aad9319b-032c-4a88-961d-1cf579581e34");
pub const DropTarget_DragLeave_Event_GUID = Guid.initString("0f82eb15-24a2-4988-9217-de162aee272b");
pub const DropTarget_Dropped_Event_GUID = Guid.initString("622cead8-1edb-4a3d-abbc-be2211ff68b5");
pub const StructuredMarkup_CompositionComplete_Event_GUID = Guid.initString("c48a3c17-677a-4047-a68d-fc1257528aef");
pub const StructuredMarkup_Deleted_Event_GUID = Guid.initString("f9d0a020-e1c1-4ecf-b9aa-52efde7e41e1");
pub const StructuredMarkup_SelectionChanged_Event_GUID = Guid.initString("a7c815f7-ff9f-41c7-a3a7-ab6cbfdb4903");
pub const Invoke_Pattern_GUID = Guid.initString("d976c2fc-66ea-4a6e-b28f-c24c7546ad37");
pub const Selection_Pattern_GUID = Guid.initString("66e3b7e8-d821-4d25-8761-435d2c8b253f");
pub const Value_Pattern_GUID = Guid.initString("17faad9e-c877-475b-b933-77332779b637");
pub const RangeValue_Pattern_GUID = Guid.initString("18b00d87-b1c9-476a-bfbd-5f0bdb926f63");
pub const Scroll_Pattern_GUID = Guid.initString("895fa4b4-759d-4c50-8e15-03460672003c");
pub const ExpandCollapse_Pattern_GUID = Guid.initString("ae05efa2-f9d1-428a-834c-53a5c52f9b8b");
pub const Grid_Pattern_GUID = Guid.initString("260a2ccb-93a8-4e44-a4c1-3df397f2b02b");
pub const GridItem_Pattern_GUID = Guid.initString("f2d5c877-a462-4957-a2a5-2c96b303bc63");
pub const MultipleView_Pattern_GUID = Guid.initString("547a6ae4-113f-47c4-850f-db4dfa466b1d");
pub const Window_Pattern_GUID = Guid.initString("27901735-c760-4994-ad11-5919e606b110");
pub const SelectionItem_Pattern_GUID = Guid.initString("9bc64eeb-87c7-4b28-94bb-4d9fa437b6ef");
pub const Dock_Pattern_GUID = Guid.initString("9cbaa846-83c8-428d-827f-7e6063fe0620");
pub const Table_Pattern_GUID = Guid.initString("c415218e-a028-461e-aa92-8f925cf79351");
pub const TableItem_Pattern_GUID = Guid.initString("df1343bd-1888-4a29-a50c-b92e6de37f6f");
pub const Text_Pattern_GUID = Guid.initString("8615f05d-7de5-44fd-a679-2ca4b46033a8");
pub const Toggle_Pattern_GUID = Guid.initString("0b419760-e2f4-43ff-8c5f-9457c82b56e9");
pub const Transform_Pattern_GUID = Guid.initString("24b46fdb-587e-49f1-9c4a-d8e98b664b7b");
pub const ScrollItem_Pattern_GUID = Guid.initString("4591d005-a803-4d5c-b4d5-8d2800f906a7");
pub const LegacyIAccessible_Pattern_GUID = Guid.initString("54cc0a9f-3395-48af-ba8d-73f85690f3e0");
pub const ItemContainer_Pattern_GUID = Guid.initString("3d13da0f-8b9a-4a99-85fa-c5c9a69f1ed4");
pub const VirtualizedItem_Pattern_GUID = Guid.initString("f510173e-2e71-45e9-a6e5-62f6ed8289d5");
pub const SynchronizedInput_Pattern_GUID = Guid.initString("05c288a6-c47b-488b-b653-33977a551b8b");
pub const ObjectModel_Pattern_GUID = Guid.initString("3e04acfe-08fc-47ec-96bc-353fa3b34aa7");
pub const Annotation_Pattern_GUID = Guid.initString("f6c72ad7-356c-4850-9291-316f608a8c84");
pub const Text_Pattern2_GUID = Guid.initString("498479a2-5b22-448d-b6e4-647490860698");
pub const TextEdit_Pattern_GUID = Guid.initString("69f3ff89-5af9-4c75-9340-f2de292e4591");
pub const CustomNavigation_Pattern_GUID = Guid.initString("afea938a-621e-4054-bb2c-2f46114dac3f");
pub const Styles_Pattern_GUID = Guid.initString("1ae62655-da72-4d60-a153-e5aa6988e3bf");
pub const Spreadsheet_Pattern_GUID = Guid.initString("6a5b24c9-9d1e-4b85-9e44-c02e3169b10b");
pub const SpreadsheetItem_Pattern_GUID = Guid.initString("32cf83ff-f1a8-4a8c-8658-d47ba74e20ba");
pub const Tranform_Pattern2_GUID = Guid.initString("8afcfd07-a369-44de-988b-2f7ff49fb8a8");
pub const TextChild_Pattern_GUID = Guid.initString("7533cab7-3bfe-41ef-9e85-e2638cbe169e");
pub const Drag_Pattern_GUID = Guid.initString("c0bee21f-ccb3-4fed-995b-114f6e3d2728");
pub const DropTarget_Pattern_GUID = Guid.initString("0bcbec56-bd34-4b7b-9fd5-2659905ea3dc");
pub const StructuredMarkup_Pattern_GUID = Guid.initString("abbd0878-8665-4f5c-94fc-36e7d8bb706b");
pub const Button_Control_GUID = Guid.initString("5a78e369-c6a1-4f33-a9d7-79f20d0c788e");
pub const Calendar_Control_GUID = Guid.initString("8913eb88-00e5-46bc-8e4e-14a786e165a1");
pub const CheckBox_Control_GUID = Guid.initString("fb50f922-a3db-49c0-8bc3-06dad55778e2");
pub const ComboBox_Control_GUID = Guid.initString("54cb426c-2f33-4fff-aaa1-aef60dac5deb");
pub const Edit_Control_GUID = Guid.initString("6504a5c8-2c86-4f87-ae7b-1abddc810cf9");
pub const Hyperlink_Control_GUID = Guid.initString("8a56022c-b00d-4d15-8ff0-5b6b266e5e02");
pub const Image_Control_GUID = Guid.initString("2d3736e4-6b16-4c57-a962-f93260a75243");
pub const ListItem_Control_GUID = Guid.initString("7b3717f2-44d1-4a58-98a8-f12a9b8f78e2");
pub const List_Control_GUID = Guid.initString("9b149ee1-7cca-4cfc-9af1-cac7bddd3031");
pub const Menu_Control_GUID = Guid.initString("2e9b1440-0ea8-41fd-b374-c1ea6f503cd1");
pub const MenuBar_Control_GUID = Guid.initString("cc384250-0e7b-4ae8-95ae-a08f261b52ee");
pub const MenuItem_Control_GUID = Guid.initString("f45225d3-d0a0-49d8-9834-9a000d2aeddc");
pub const ProgressBar_Control_GUID = Guid.initString("228c9f86-c36c-47bb-9fb6-a5834bfc53a4");
pub const RadioButton_Control_GUID = Guid.initString("3bdb49db-fe2c-4483-b3e1-e57f219440c6");
pub const ScrollBar_Control_GUID = Guid.initString("daf34b36-5065-4946-b22f-92595fc0751a");
pub const Slider_Control_GUID = Guid.initString("b033c24b-3b35-4cea-b609-763682fa660b");
pub const Spinner_Control_GUID = Guid.initString("60cc4b38-3cb1-4161-b442-c6b726c17825");
pub const StatusBar_Control_GUID = Guid.initString("d45e7d1b-5873-475f-95a4-0433e1f1b00a");
pub const Tab_Control_GUID = Guid.initString("38cd1f2d-337a-4bd2-a5e3-adb469e30bd3");
pub const TabItem_Control_GUID = Guid.initString("2c6a634f-921b-4e6e-b26e-08fcb0798f4c");
pub const Text_Control_GUID = Guid.initString("ae9772dc-d331-4f09-be20-7e6dfaf07b0a");
pub const ToolBar_Control_GUID = Guid.initString("8f06b751-e182-4e98-8893-2284543a7dce");
pub const ToolTip_Control_GUID = Guid.initString("05ddc6d1-2137-4768-98ea-73f52f7134f3");
pub const Tree_Control_GUID = Guid.initString("7561349c-d241-43f4-9908-b5f091bee611");
pub const TreeItem_Control_GUID = Guid.initString("62c9feb9-8ffc-4878-a3a4-96b030315c18");
pub const Custom_Control_GUID = Guid.initString("f29ea0c3-adb7-430a-ba90-e52c7313e6ed");
pub const Group_Control_GUID = Guid.initString("ad50aa1c-e8c8-4774-ae1b-dd86df0b3bdc");
pub const Thumb_Control_GUID = Guid.initString("701ca877-e310-4dd6-b644-797e4faea213");
pub const DataGrid_Control_GUID = Guid.initString("84b783af-d103-4b0a-8415-e73942410f4b");
pub const DataItem_Control_GUID = Guid.initString("a0177842-d94f-42a5-814b-6068addc8da5");
pub const Document_Control_GUID = Guid.initString("3cd6bb6f-6f08-4562-b229-e4e2fc7a9eb4");
pub const SplitButton_Control_GUID = Guid.initString("7011f01f-4ace-4901-b461-920a6f1ca650");
pub const Window_Control_GUID = Guid.initString("e13a7242-f462-4f4d-aec1-53b28d6c3290");
pub const Pane_Control_GUID = Guid.initString("5c2b3f5b-9182-42a3-8dec-8c04c1ee634d");
pub const Header_Control_GUID = Guid.initString("5b90cbce-78fb-4614-82b6-554d74718e67");
pub const HeaderItem_Control_GUID = Guid.initString("e6bc12cb-7c8e-49cf-b168-4a93a32bebb0");
pub const Table_Control_GUID = Guid.initString("773bfa0e-5bc4-4deb-921b-de7b3206229e");
pub const TitleBar_Control_GUID = Guid.initString("98aa55bf-3bb0-4b65-836e-2ea30dbc171f");
pub const Separator_Control_GUID = Guid.initString("8767eba3-2a63-4ab0-ac8d-aa50e23de978");
pub const SemanticZoom_Control_GUID = Guid.initString("5fd34a43-061e-42c8-b589-9dccf74bc43a");
pub const AppBar_Control_GUID = Guid.initString("6114908d-cc02-4d37-875b-b530c7139554");
pub const Text_AnimationStyle_Attribute_GUID = Guid.initString("628209f0-7c9a-4d57-be64-1f1836571ff5");
pub const Text_BackgroundColor_Attribute_GUID = Guid.initString("fdc49a07-583d-4f17-ad27-77fc832a3c0b");
pub const Text_BulletStyle_Attribute_GUID = Guid.initString("c1097c90-d5c4-4237-9781-3bec8ba54e48");
pub const Text_CapStyle_Attribute_GUID = Guid.initString("fb059c50-92cc-49a5-ba8f-0aa872bba2f3");
pub const Text_Culture_Attribute_GUID = Guid.initString("c2025af9-a42d-4ced-a1fb-c6746315222e");
pub const Text_FontName_Attribute_GUID = Guid.initString("64e63ba8-f2e5-476e-a477-1734feaaf726");
pub const Text_FontSize_Attribute_GUID = Guid.initString("dc5eeeff-0506-4673-93f2-377e4a8e01f1");
pub const Text_FontWeight_Attribute_GUID = Guid.initString("6fc02359-b316-4f5f-b401-f1ce55741853");
pub const Text_ForegroundColor_Attribute_GUID = Guid.initString("72d1c95d-5e60-471a-96b1-6c1b3b77a436");
pub const Text_HorizontalTextAlignment_Attribute_GUID = Guid.initString("04ea6161-fba3-477a-952a-bb326d026a5b");
pub const Text_IndentationFirstLine_Attribute_GUID = Guid.initString("206f9ad5-c1d3-424a-8182-6da9a7f3d632");
pub const Text_IndentationLeading_Attribute_GUID = Guid.initString("5cf66bac-2d45-4a4b-b6c9-f7221d2815b0");
pub const Text_IndentationTrailing_Attribute_GUID = Guid.initString("97ff6c0f-1ce4-408a-b67b-94d83eb69bf2");
pub const Text_IsHidden_Attribute_GUID = Guid.initString("360182fb-bdd7-47f6-ab69-19e33f8a3344");
pub const Text_IsItalic_Attribute_GUID = Guid.initString("fce12a56-1336-4a34-9663-1bab47239320");
pub const Text_IsReadOnly_Attribute_GUID = Guid.initString("a738156b-ca3e-495e-9514-833c440feb11");
pub const Text_IsSubscript_Attribute_GUID = Guid.initString("f0ead858-8f53-413c-873f-1a7d7f5e0de4");
pub const Text_IsSuperscript_Attribute_GUID = Guid.initString("da706ee4-b3aa-4645-a41f-cd25157dea76");
pub const Text_MarginBottom_Attribute_GUID = Guid.initString("7ee593c4-72b4-4cac-9271-3ed24b0e4d42");
pub const Text_MarginLeading_Attribute_GUID = Guid.initString("9e9242d0-5ed0-4900-8e8a-eecc03835afc");
pub const Text_MarginTop_Attribute_GUID = Guid.initString("683d936f-c9b9-4a9a-b3d9-d20d33311e2a");
pub const Text_MarginTrailing_Attribute_GUID = Guid.initString("af522f98-999d-40af-a5b2-0169d0342002");
pub const Text_OutlineStyles_Attribute_GUID = Guid.initString("5b675b27-db89-46fe-970c-614d523bb97d");
pub const Text_OverlineColor_Attribute_GUID = Guid.initString("83ab383a-fd43-40da-ab3e-ecf8165cbb6d");
pub const Text_OverlineStyle_Attribute_GUID = Guid.initString("0a234d66-617e-427f-871d-e1ff1e0c213f");
pub const Text_StrikethroughColor_Attribute_GUID = Guid.initString("bfe15a18-8c41-4c5a-9a0b-04af0e07f487");
pub const Text_StrikethroughStyle_Attribute_GUID = Guid.initString("72913ef1-da00-4f01-899c-ac5a8577a307");
pub const Text_Tabs_Attribute_GUID = Guid.initString("2e68d00b-92fe-42d8-899a-a784aa4454a1");
pub const Text_TextFlowDirections_Attribute_GUID = Guid.initString("8bdf8739-f420-423e-af77-20a5d973a907");
pub const Text_UnderlineColor_Attribute_GUID = Guid.initString("bfa12c73-fde2-4473-bf64-1036d6aa0f45");
pub const Text_UnderlineStyle_Attribute_GUID = Guid.initString("5f3b21c0-ede4-44bd-9c36-3853038cbfeb");
pub const Text_AnnotationTypes_Attribute_GUID = Guid.initString("ad2eb431-ee4e-4be1-a7ba-5559155a73ef");
pub const Text_AnnotationObjects_Attribute_GUID = Guid.initString("ff41cf68-e7ab-40b9-8c72-72a8ed94017d");
pub const Text_StyleName_Attribute_GUID = Guid.initString("22c9e091-4d66-45d8-a828-737bab4c98a7");
pub const Text_StyleId_Attribute_GUID = Guid.initString("14c300de-c32b-449b-ab7c-b0e0789aea5d");
pub const Text_Link_Attribute_GUID = Guid.initString("b38ef51d-9e8d-4e46-9144-56ebe177329b");
pub const Text_IsActive_Attribute_GUID = Guid.initString("f5a4e533-e1b8-436b-935d-b57aa3f558c4");
pub const Text_SelectionActiveEnd_Attribute_GUID = Guid.initString("1f668cc3-9bbf-416b-b0a2-f89f86f6612c");
pub const Text_CaretPosition_Attribute_GUID = Guid.initString("b227b131-9889-4752-a91b-733efdc5c5a0");
pub const Text_CaretBidiMode_Attribute_GUID = Guid.initString("929ee7a6-51d3-4715-96dc-b694fa24a168");
pub const Text_BeforeParagraphSpacing_Attribute_GUID = Guid.initString("be7b0ab1-c822-4a24-85e9-c8f2650fc79c");
pub const Text_AfterParagraphSpacing_Attribute_GUID = Guid.initString("588cbb38-e62f-497c-b5d1-ccdf0ee823d8");
pub const Text_LineSpacing_Attribute_GUID = Guid.initString("63ff70ae-d943-4b47-8ab7-a7a033d3214b");
pub const Text_BeforeSpacing_Attribute_GUID = Guid.initString("be7b0ab1-c822-4a24-85e9-c8f2650fc79c");
pub const Text_AfterSpacing_Attribute_GUID = Guid.initString("588cbb38-e62f-497c-b5d1-ccdf0ee823d8");
pub const Text_SayAsInterpretAs_Attribute_GUID = Guid.initString("b38ad6ac-eee1-4b6e-88cc-014cefa93fcb");
pub const TextEdit_TextChanged_Event_GUID = Guid.initString("120b0308-ec22-4eb8-9c98-9867cda1b165");
pub const TextEdit_ConversionTargetChanged_Event_GUID = Guid.initString("3388c183-ed4f-4c8b-9baa-364d51d8847f");
pub const Changes_Event_GUID = Guid.initString("7df26714-614f-4e05-9488-716c5ba19436");
pub const Annotation_Custom_GUID = Guid.initString("9ec82750-3931-4952-85bc-1dbff78a43e3");
pub const Annotation_SpellingError_GUID = Guid.initString("ae85567e-9ece-423f-81b7-96c43d53e50e");
pub const Annotation_GrammarError_GUID = Guid.initString("757a048d-4518-41c6-854c-dc009b7cfb53");
pub const Annotation_Comment_GUID = Guid.initString("fd2fda30-26b3-4c06-8bc7-98f1532e46fd");
pub const Annotation_FormulaError_GUID = Guid.initString("95611982-0cab-46d5-a2f0-e30d1905f8bf");
pub const Annotation_TrackChanges_GUID = Guid.initString("21e6e888-dc14-4016-ac27-190553c8c470");
pub const Annotation_Header_GUID = Guid.initString("867b409b-b216-4472-a219-525e310681f8");
pub const Annotation_Footer_GUID = Guid.initString("cceab046-1833-47aa-8080-701ed0b0c832");
pub const Annotation_Highlighted_GUID = Guid.initString("757c884e-8083-4081-8b9c-e87f5072f0e4");
pub const Annotation_Endnote_GUID = Guid.initString("7565725c-2d99-4839-960d-33d3b866aba5");
pub const Annotation_Footnote_GUID = Guid.initString("3de10e21-4125-42db-8620-be8083080624");
pub const Annotation_InsertionChange_GUID = Guid.initString("0dbeb3a6-df15-4164-a3c0-e21a8ce931c4");
pub const Annotation_DeletionChange_GUID = Guid.initString("be3d5b05-951d-42e7-901d-adc8c2cf34d0");
pub const Annotation_MoveChange_GUID = Guid.initString("9da587eb-23e5-4490-b385-1a22ddc8b187");
pub const Annotation_FormatChange_GUID = Guid.initString("eb247345-d4f1-41ce-8e52-f79b69635e48");
pub const Annotation_UnsyncedChange_GUID = Guid.initString("1851116a-0e47-4b30-8cb5-d7dae4fbcd1b");
pub const Annotation_EditingLockedChange_GUID = Guid.initString("c31f3e1c-7423-4dac-8348-41f099ff6f64");
pub const Annotation_ExternalChange_GUID = Guid.initString("75a05b31-5f11-42fd-887d-dfa010db2392");
pub const Annotation_ConflictingChange_GUID = Guid.initString("98af8802-517c-459f-af13-016d3fab877e");
pub const Annotation_Author_GUID = Guid.initString("f161d3a7-f81b-4128-b17f-71f690914520");
pub const Annotation_AdvancedProofingIssue_GUID = Guid.initString("dac7b72c-c0f2-4b84-b90d-5fafc0f0ef1c");
pub const Annotation_DataValidationError_GUID = Guid.initString("c8649fa8-9775-437e-ad46-e709d93c2343");
pub const Annotation_CircularReferenceError_GUID = Guid.initString("25bd9cf4-1745-4659-ba67-727f0318c616");
pub const Annotation_Mathematics_GUID = Guid.initString("eaab634b-26d0-40c1-8073-57ca1c633c9b");
pub const Annotation_Sensitive_GUID = Guid.initString("37f4c04f-0f12-4464-929c-828fd15292e3");
pub const Changes_Summary_GUID = Guid.initString("313d65a6-e60f-4d62-9861-55afd728d207");
pub const StyleId_Custom_GUID = Guid.initString("ef2edd3e-a999-4b7c-a378-09bbd52a3516");
pub const StyleId_Heading1_GUID = Guid.initString("7f7e8f69-6866-4621-930c-9a5d0ca5961c");
pub const StyleId_Heading2_GUID = Guid.initString("baa9b241-5c69-469d-85ad-474737b52b14");
pub const StyleId_Heading3_GUID = Guid.initString("bf8be9d2-d8b8-4ec5-8c52-9cfb0d035970");
pub const StyleId_Heading4_GUID = Guid.initString("8436ffc0-9578-45fc-83a4-ff40053315dd");
pub const StyleId_Heading5_GUID = Guid.initString("909f424d-0dbf-406e-97bb-4e773d9798f7");
pub const StyleId_Heading6_GUID = Guid.initString("89d23459-5d5b-4824-a420-11d3ed82e40f");
pub const StyleId_Heading7_GUID = Guid.initString("a3790473-e9ae-422d-b8e3-3b675c6181a4");
pub const StyleId_Heading8_GUID = Guid.initString("2bc14145-a40c-4881-84ae-f2235685380c");
pub const StyleId_Heading9_GUID = Guid.initString("c70d9133-bb2a-43d3-8ac6-33657884b0f0");
pub const StyleId_Title_GUID = Guid.initString("15d8201a-ffcf-481f-b0a1-30b63be98f07");
pub const StyleId_Subtitle_GUID = Guid.initString("b5d9fc17-5d6f-4420-b439-7cb19ad434e2");
pub const StyleId_Normal_GUID = Guid.initString("cd14d429-e45e-4475-a1c5-7f9e6be96eba");
pub const StyleId_Emphasis_GUID = Guid.initString("ca6e7dbe-355e-4820-95a0-925f041d3470");
pub const StyleId_Quote_GUID = Guid.initString("5d1c21ea-8195-4f6c-87ea-5dabece64c1d");
pub const StyleId_BulletedList_GUID = Guid.initString("5963ed64-6426-4632-8caf-a32ad402d91a");
pub const StyleId_NumberedList_GUID = Guid.initString("1e96dbd5-64c3-43d0-b1ee-b53b06e3eddf");
pub const Notification_Event_GUID = Guid.initString("72c5a2f7-9788-480f-b8eb-4dee00f6186f");
pub const SID_IsUIAutomationObject = Guid.initString("b96fdb85-7204-4724-842b-c7059dedb9d0");
pub const SID_ControlElementProvider = Guid.initString("f4791d68-e254-4ba3-9a53-26a5c5497946");
pub const IsSelectionPattern2Available_Property_GUID = Guid.initString("490806fb-6e89-4a47-8319-d266e511f021");
pub const Selection2_FirstSelectedItem_Property_GUID = Guid.initString("cc24ea67-369c-4e55-9ff7-38da69540c29");
pub const Selection2_LastSelectedItem_Property_GUID = Guid.initString("cf7bda90-2d83-49f8-860c-9ce394cf89b4");
pub const Selection2_CurrentSelectedItem_Property_GUID = Guid.initString("34257c26-83b5-41a6-939c-ae841c136236");
pub const Selection2_ItemCount_Property_GUID = Guid.initString("bb49eb9f-456d-4048-b591-9c2026b84636");
pub const Selection_Pattern2_GUID = Guid.initString("fba25cab-ab98-49f7-a7dc-fe539dc15be7");
pub const HeadingLevel_Property_GUID = Guid.initString("29084272-aaaf-4a30-8796-3c12f62b6bbb");
pub const IsDialog_Property_GUID = Guid.initString("9d0dfb9b-8436-4501-bbbb-e534a4fb3b3f");
pub const UIA_IAFP_DEFAULT = @as(u32, 0);
pub const UIA_IAFP_UNWRAP_BRIDGE = @as(u32, 1);
pub const UIA_PFIA_DEFAULT = @as(u32, 0);
pub const UIA_PFIA_UNWRAP_BRIDGE = @as(u32, 1);
pub const UIA_ScrollPatternNoScroll = @as(f64, -1);
pub const UIA_InvokePatternId = @as(i32, 10000);
pub const UIA_SelectionPatternId = @as(i32, 10001);
pub const UIA_ValuePatternId = @as(i32, 10002);
pub const UIA_RangeValuePatternId = @as(i32, 10003);
pub const UIA_ScrollPatternId = @as(i32, 10004);
pub const UIA_ExpandCollapsePatternId = @as(i32, 10005);
pub const UIA_GridPatternId = @as(i32, 10006);
pub const UIA_GridItemPatternId = @as(i32, 10007);
pub const UIA_MultipleViewPatternId = @as(i32, 10008);
pub const UIA_WindowPatternId = @as(i32, 10009);
pub const UIA_SelectionItemPatternId = @as(i32, 10010);
pub const UIA_DockPatternId = @as(i32, 10011);
pub const UIA_TablePatternId = @as(i32, 10012);
pub const UIA_TableItemPatternId = @as(i32, 10013);
pub const UIA_TextPatternId = @as(i32, 10014);
pub const UIA_TogglePatternId = @as(i32, 10015);
pub const UIA_TransformPatternId = @as(i32, 10016);
pub const UIA_ScrollItemPatternId = @as(i32, 10017);
pub const UIA_LegacyIAccessiblePatternId = @as(i32, 10018);
pub const UIA_ItemContainerPatternId = @as(i32, 10019);
pub const UIA_VirtualizedItemPatternId = @as(i32, 10020);
pub const UIA_SynchronizedInputPatternId = @as(i32, 10021);
pub const UIA_ObjectModelPatternId = @as(i32, 10022);
pub const UIA_AnnotationPatternId = @as(i32, 10023);
pub const UIA_TextPattern2Id = @as(i32, 10024);
pub const UIA_StylesPatternId = @as(i32, 10025);
pub const UIA_SpreadsheetPatternId = @as(i32, 10026);
pub const UIA_SpreadsheetItemPatternId = @as(i32, 10027);
pub const UIA_TransformPattern2Id = @as(i32, 10028);
pub const UIA_TextChildPatternId = @as(i32, 10029);
pub const UIA_DragPatternId = @as(i32, 10030);
pub const UIA_DropTargetPatternId = @as(i32, 10031);
pub const UIA_TextEditPatternId = @as(i32, 10032);
pub const UIA_CustomNavigationPatternId = @as(i32, 10033);
pub const UIA_SelectionPattern2Id = @as(i32, 10034);
pub const UIA_ToolTipOpenedEventId = @as(i32, 20000);
pub const UIA_ToolTipClosedEventId = @as(i32, 20001);
pub const UIA_StructureChangedEventId = @as(i32, 20002);
pub const UIA_MenuOpenedEventId = @as(i32, 20003);
pub const UIA_AutomationPropertyChangedEventId = @as(i32, 20004);
pub const UIA_AutomationFocusChangedEventId = @as(i32, 20005);
pub const UIA_AsyncContentLoadedEventId = @as(i32, 20006);
pub const UIA_MenuClosedEventId = @as(i32, 20007);
pub const UIA_LayoutInvalidatedEventId = @as(i32, 20008);
pub const UIA_Invoke_InvokedEventId = @as(i32, 20009);
pub const UIA_SelectionItem_ElementAddedToSelectionEventId = @as(i32, 20010);
pub const UIA_SelectionItem_ElementRemovedFromSelectionEventId = @as(i32, 20011);
pub const UIA_SelectionItem_ElementSelectedEventId = @as(i32, 20012);
pub const UIA_Selection_InvalidatedEventId = @as(i32, 20013);
pub const UIA_Text_TextSelectionChangedEventId = @as(i32, 20014);
pub const UIA_Text_TextChangedEventId = @as(i32, 20015);
pub const UIA_Window_WindowOpenedEventId = @as(i32, 20016);
pub const UIA_Window_WindowClosedEventId = @as(i32, 20017);
pub const UIA_MenuModeStartEventId = @as(i32, 20018);
pub const UIA_MenuModeEndEventId = @as(i32, 20019);
pub const UIA_InputReachedTargetEventId = @as(i32, 20020);
pub const UIA_InputReachedOtherElementEventId = @as(i32, 20021);
pub const UIA_InputDiscardedEventId = @as(i32, 20022);
pub const UIA_SystemAlertEventId = @as(i32, 20023);
pub const UIA_LiveRegionChangedEventId = @as(i32, 20024);
pub const UIA_HostedFragmentRootsInvalidatedEventId = @as(i32, 20025);
pub const UIA_Drag_DragStartEventId = @as(i32, 20026);
pub const UIA_Drag_DragCancelEventId = @as(i32, 20027);
pub const UIA_Drag_DragCompleteEventId = @as(i32, 20028);
pub const UIA_DropTarget_DragEnterEventId = @as(i32, 20029);
pub const UIA_DropTarget_DragLeaveEventId = @as(i32, 20030);
pub const UIA_DropTarget_DroppedEventId = @as(i32, 20031);
pub const UIA_TextEdit_TextChangedEventId = @as(i32, 20032);
pub const UIA_TextEdit_ConversionTargetChangedEventId = @as(i32, 20033);
pub const UIA_ChangesEventId = @as(i32, 20034);
pub const UIA_NotificationEventId = @as(i32, 20035);
pub const UIA_ActiveTextPositionChangedEventId = @as(i32, 20036);
pub const UIA_RuntimeIdPropertyId = @as(i32, 30000);
pub const UIA_BoundingRectanglePropertyId = @as(i32, 30001);
pub const UIA_ProcessIdPropertyId = @as(i32, 30002);
pub const UIA_ControlTypePropertyId = @as(i32, 30003);
pub const UIA_LocalizedControlTypePropertyId = @as(i32, 30004);
pub const UIA_NamePropertyId = @as(i32, 30005);
pub const UIA_AcceleratorKeyPropertyId = @as(i32, 30006);
pub const UIA_AccessKeyPropertyId = @as(i32, 30007);
pub const UIA_HasKeyboardFocusPropertyId = @as(i32, 30008);
pub const UIA_IsKeyboardFocusablePropertyId = @as(i32, 30009);
pub const UIA_IsEnabledPropertyId = @as(i32, 30010);
pub const UIA_AutomationIdPropertyId = @as(i32, 30011);
pub const UIA_ClassNamePropertyId = @as(i32, 30012);
pub const UIA_HelpTextPropertyId = @as(i32, 30013);
pub const UIA_ClickablePointPropertyId = @as(i32, 30014);
pub const UIA_CulturePropertyId = @as(i32, 30015);
pub const UIA_IsControlElementPropertyId = @as(i32, 30016);
pub const UIA_IsContentElementPropertyId = @as(i32, 30017);
pub const UIA_LabeledByPropertyId = @as(i32, 30018);
pub const UIA_IsPasswordPropertyId = @as(i32, 30019);
pub const UIA_NativeWindowHandlePropertyId = @as(i32, 30020);
pub const UIA_ItemTypePropertyId = @as(i32, 30021);
pub const UIA_IsOffscreenPropertyId = @as(i32, 30022);
pub const UIA_OrientationPropertyId = @as(i32, 30023);
pub const UIA_FrameworkIdPropertyId = @as(i32, 30024);
pub const UIA_IsRequiredForFormPropertyId = @as(i32, 30025);
pub const UIA_ItemStatusPropertyId = @as(i32, 30026);
pub const UIA_IsDockPatternAvailablePropertyId = @as(i32, 30027);
pub const UIA_IsExpandCollapsePatternAvailablePropertyId = @as(i32, 30028);
pub const UIA_IsGridItemPatternAvailablePropertyId = @as(i32, 30029);
pub const UIA_IsGridPatternAvailablePropertyId = @as(i32, 30030);
pub const UIA_IsInvokePatternAvailablePropertyId = @as(i32, 30031);
pub const UIA_IsMultipleViewPatternAvailablePropertyId = @as(i32, 30032);
pub const UIA_IsRangeValuePatternAvailablePropertyId = @as(i32, 30033);
pub const UIA_IsScrollPatternAvailablePropertyId = @as(i32, 30034);
pub const UIA_IsScrollItemPatternAvailablePropertyId = @as(i32, 30035);
pub const UIA_IsSelectionItemPatternAvailablePropertyId = @as(i32, 30036);
pub const UIA_IsSelectionPatternAvailablePropertyId = @as(i32, 30037);
pub const UIA_IsTablePatternAvailablePropertyId = @as(i32, 30038);
pub const UIA_IsTableItemPatternAvailablePropertyId = @as(i32, 30039);
pub const UIA_IsTextPatternAvailablePropertyId = @as(i32, 30040);
pub const UIA_IsTogglePatternAvailablePropertyId = @as(i32, 30041);
pub const UIA_IsTransformPatternAvailablePropertyId = @as(i32, 30042);
pub const UIA_IsValuePatternAvailablePropertyId = @as(i32, 30043);
pub const UIA_IsWindowPatternAvailablePropertyId = @as(i32, 30044);
pub const UIA_ValueValuePropertyId = @as(i32, 30045);
pub const UIA_ValueIsReadOnlyPropertyId = @as(i32, 30046);
pub const UIA_RangeValueValuePropertyId = @as(i32, 30047);
pub const UIA_RangeValueIsReadOnlyPropertyId = @as(i32, 30048);
pub const UIA_RangeValueMinimumPropertyId = @as(i32, 30049);
pub const UIA_RangeValueMaximumPropertyId = @as(i32, 30050);
pub const UIA_RangeValueLargeChangePropertyId = @as(i32, 30051);
pub const UIA_RangeValueSmallChangePropertyId = @as(i32, 30052);
pub const UIA_ScrollHorizontalScrollPercentPropertyId = @as(i32, 30053);
pub const UIA_ScrollHorizontalViewSizePropertyId = @as(i32, 30054);
pub const UIA_ScrollVerticalScrollPercentPropertyId = @as(i32, 30055);
pub const UIA_ScrollVerticalViewSizePropertyId = @as(i32, 30056);
pub const UIA_ScrollHorizontallyScrollablePropertyId = @as(i32, 30057);
pub const UIA_ScrollVerticallyScrollablePropertyId = @as(i32, 30058);
pub const UIA_SelectionSelectionPropertyId = @as(i32, 30059);
pub const UIA_SelectionCanSelectMultiplePropertyId = @as(i32, 30060);
pub const UIA_SelectionIsSelectionRequiredPropertyId = @as(i32, 30061);
pub const UIA_GridRowCountPropertyId = @as(i32, 30062);
pub const UIA_GridColumnCountPropertyId = @as(i32, 30063);
pub const UIA_GridItemRowPropertyId = @as(i32, 30064);
pub const UIA_GridItemColumnPropertyId = @as(i32, 30065);
pub const UIA_GridItemRowSpanPropertyId = @as(i32, 30066);
pub const UIA_GridItemColumnSpanPropertyId = @as(i32, 30067);
pub const UIA_GridItemContainingGridPropertyId = @as(i32, 30068);
pub const UIA_DockDockPositionPropertyId = @as(i32, 30069);
pub const UIA_ExpandCollapseExpandCollapseStatePropertyId = @as(i32, 30070);
pub const UIA_MultipleViewCurrentViewPropertyId = @as(i32, 30071);
pub const UIA_MultipleViewSupportedViewsPropertyId = @as(i32, 30072);
pub const UIA_WindowCanMaximizePropertyId = @as(i32, 30073);
pub const UIA_WindowCanMinimizePropertyId = @as(i32, 30074);
pub const UIA_WindowWindowVisualStatePropertyId = @as(i32, 30075);
pub const UIA_WindowWindowInteractionStatePropertyId = @as(i32, 30076);
pub const UIA_WindowIsModalPropertyId = @as(i32, 30077);
pub const UIA_WindowIsTopmostPropertyId = @as(i32, 30078);
pub const UIA_SelectionItemIsSelectedPropertyId = @as(i32, 30079);
pub const UIA_SelectionItemSelectionContainerPropertyId = @as(i32, 30080);
pub const UIA_TableRowHeadersPropertyId = @as(i32, 30081);
pub const UIA_TableColumnHeadersPropertyId = @as(i32, 30082);
pub const UIA_TableRowOrColumnMajorPropertyId = @as(i32, 30083);
pub const UIA_TableItemRowHeaderItemsPropertyId = @as(i32, 30084);
pub const UIA_TableItemColumnHeaderItemsPropertyId = @as(i32, 30085);
pub const UIA_ToggleToggleStatePropertyId = @as(i32, 30086);
pub const UIA_TransformCanMovePropertyId = @as(i32, 30087);
pub const UIA_TransformCanResizePropertyId = @as(i32, 30088);
pub const UIA_TransformCanRotatePropertyId = @as(i32, 30089);
pub const UIA_IsLegacyIAccessiblePatternAvailablePropertyId = @as(i32, 30090);
pub const UIA_LegacyIAccessibleChildIdPropertyId = @as(i32, 30091);
pub const UIA_LegacyIAccessibleNamePropertyId = @as(i32, 30092);
pub const UIA_LegacyIAccessibleValuePropertyId = @as(i32, 30093);
pub const UIA_LegacyIAccessibleDescriptionPropertyId = @as(i32, 30094);
pub const UIA_LegacyIAccessibleRolePropertyId = @as(i32, 30095);
pub const UIA_LegacyIAccessibleStatePropertyId = @as(i32, 30096);
pub const UIA_LegacyIAccessibleHelpPropertyId = @as(i32, 30097);
pub const UIA_LegacyIAccessibleKeyboardShortcutPropertyId = @as(i32, 30098);
pub const UIA_LegacyIAccessibleSelectionPropertyId = @as(i32, 30099);
pub const UIA_LegacyIAccessibleDefaultActionPropertyId = @as(i32, 30100);
pub const UIA_AriaRolePropertyId = @as(i32, 30101);
pub const UIA_AriaPropertiesPropertyId = @as(i32, 30102);
pub const UIA_IsDataValidForFormPropertyId = @as(i32, 30103);
pub const UIA_ControllerForPropertyId = @as(i32, 30104);
pub const UIA_DescribedByPropertyId = @as(i32, 30105);
pub const UIA_FlowsToPropertyId = @as(i32, 30106);
pub const UIA_ProviderDescriptionPropertyId = @as(i32, 30107);
pub const UIA_IsItemContainerPatternAvailablePropertyId = @as(i32, 30108);
pub const UIA_IsVirtualizedItemPatternAvailablePropertyId = @as(i32, 30109);
pub const UIA_IsSynchronizedInputPatternAvailablePropertyId = @as(i32, 30110);
pub const UIA_OptimizeForVisualContentPropertyId = @as(i32, 30111);
pub const UIA_IsObjectModelPatternAvailablePropertyId = @as(i32, 30112);
pub const UIA_AnnotationAnnotationTypeIdPropertyId = @as(i32, 30113);
pub const UIA_AnnotationAnnotationTypeNamePropertyId = @as(i32, 30114);
pub const UIA_AnnotationAuthorPropertyId = @as(i32, 30115);
pub const UIA_AnnotationDateTimePropertyId = @as(i32, 30116);
pub const UIA_AnnotationTargetPropertyId = @as(i32, 30117);
pub const UIA_IsAnnotationPatternAvailablePropertyId = @as(i32, 30118);
pub const UIA_IsTextPattern2AvailablePropertyId = @as(i32, 30119);
pub const UIA_StylesStyleIdPropertyId = @as(i32, 30120);
pub const UIA_StylesStyleNamePropertyId = @as(i32, 30121);
pub const UIA_StylesFillColorPropertyId = @as(i32, 30122);
pub const UIA_StylesFillPatternStylePropertyId = @as(i32, 30123);
pub const UIA_StylesShapePropertyId = @as(i32, 30124);
pub const UIA_StylesFillPatternColorPropertyId = @as(i32, 30125);
pub const UIA_StylesExtendedPropertiesPropertyId = @as(i32, 30126);
pub const UIA_IsStylesPatternAvailablePropertyId = @as(i32, 30127);
pub const UIA_IsSpreadsheetPatternAvailablePropertyId = @as(i32, 30128);
pub const UIA_SpreadsheetItemFormulaPropertyId = @as(i32, 30129);
pub const UIA_SpreadsheetItemAnnotationObjectsPropertyId = @as(i32, 30130);
pub const UIA_SpreadsheetItemAnnotationTypesPropertyId = @as(i32, 30131);
pub const UIA_IsSpreadsheetItemPatternAvailablePropertyId = @as(i32, 30132);
pub const UIA_Transform2CanZoomPropertyId = @as(i32, 30133);
pub const UIA_IsTransformPattern2AvailablePropertyId = @as(i32, 30134);
pub const UIA_LiveSettingPropertyId = @as(i32, 30135);
pub const UIA_IsTextChildPatternAvailablePropertyId = @as(i32, 30136);
pub const UIA_IsDragPatternAvailablePropertyId = @as(i32, 30137);
pub const UIA_DragIsGrabbedPropertyId = @as(i32, 30138);
pub const UIA_DragDropEffectPropertyId = @as(i32, 30139);
pub const UIA_DragDropEffectsPropertyId = @as(i32, 30140);
pub const UIA_IsDropTargetPatternAvailablePropertyId = @as(i32, 30141);
pub const UIA_DropTargetDropTargetEffectPropertyId = @as(i32, 30142);
pub const UIA_DropTargetDropTargetEffectsPropertyId = @as(i32, 30143);
pub const UIA_DragGrabbedItemsPropertyId = @as(i32, 30144);
pub const UIA_Transform2ZoomLevelPropertyId = @as(i32, 30145);
pub const UIA_Transform2ZoomMinimumPropertyId = @as(i32, 30146);
pub const UIA_Transform2ZoomMaximumPropertyId = @as(i32, 30147);
pub const UIA_FlowsFromPropertyId = @as(i32, 30148);
pub const UIA_IsTextEditPatternAvailablePropertyId = @as(i32, 30149);
pub const UIA_IsPeripheralPropertyId = @as(i32, 30150);
pub const UIA_IsCustomNavigationPatternAvailablePropertyId = @as(i32, 30151);
pub const UIA_PositionInSetPropertyId = @as(i32, 30152);
pub const UIA_SizeOfSetPropertyId = @as(i32, 30153);
pub const UIA_LevelPropertyId = @as(i32, 30154);
pub const UIA_AnnotationTypesPropertyId = @as(i32, 30155);
pub const UIA_AnnotationObjectsPropertyId = @as(i32, 30156);
pub const UIA_LandmarkTypePropertyId = @as(i32, 30157);
pub const UIA_LocalizedLandmarkTypePropertyId = @as(i32, 30158);
pub const UIA_FullDescriptionPropertyId = @as(i32, 30159);
pub const UIA_FillColorPropertyId = @as(i32, 30160);
pub const UIA_OutlineColorPropertyId = @as(i32, 30161);
pub const UIA_FillTypePropertyId = @as(i32, 30162);
pub const UIA_VisualEffectsPropertyId = @as(i32, 30163);
pub const UIA_OutlineThicknessPropertyId = @as(i32, 30164);
pub const UIA_CenterPointPropertyId = @as(i32, 30165);
pub const UIA_RotationPropertyId = @as(i32, 30166);
pub const UIA_SizePropertyId = @as(i32, 30167);
pub const UIA_IsSelectionPattern2AvailablePropertyId = @as(i32, 30168);
pub const UIA_Selection2FirstSelectedItemPropertyId = @as(i32, 30169);
pub const UIA_Selection2LastSelectedItemPropertyId = @as(i32, 30170);
pub const UIA_Selection2CurrentSelectedItemPropertyId = @as(i32, 30171);
pub const UIA_Selection2ItemCountPropertyId = @as(i32, 30172);
pub const UIA_HeadingLevelPropertyId = @as(i32, 30173);
pub const UIA_IsDialogPropertyId = @as(i32, 30174);
pub const UIA_AnimationStyleAttributeId = @as(i32, 40000);
pub const UIA_BackgroundColorAttributeId = @as(i32, 40001);
pub const UIA_BulletStyleAttributeId = @as(i32, 40002);
pub const UIA_CapStyleAttributeId = @as(i32, 40003);
pub const UIA_CultureAttributeId = @as(i32, 40004);
pub const UIA_FontNameAttributeId = @as(i32, 40005);
pub const UIA_FontSizeAttributeId = @as(i32, 40006);
pub const UIA_FontWeightAttributeId = @as(i32, 40007);
pub const UIA_ForegroundColorAttributeId = @as(i32, 40008);
pub const UIA_HorizontalTextAlignmentAttributeId = @as(i32, 40009);
pub const UIA_IndentationFirstLineAttributeId = @as(i32, 40010);
pub const UIA_IndentationLeadingAttributeId = @as(i32, 40011);
pub const UIA_IndentationTrailingAttributeId = @as(i32, 40012);
pub const UIA_IsHiddenAttributeId = @as(i32, 40013);
pub const UIA_IsItalicAttributeId = @as(i32, 40014);
pub const UIA_IsReadOnlyAttributeId = @as(i32, 40015);
pub const UIA_IsSubscriptAttributeId = @as(i32, 40016);
pub const UIA_IsSuperscriptAttributeId = @as(i32, 40017);
pub const UIA_MarginBottomAttributeId = @as(i32, 40018);
pub const UIA_MarginLeadingAttributeId = @as(i32, 40019);
pub const UIA_MarginTopAttributeId = @as(i32, 40020);
pub const UIA_MarginTrailingAttributeId = @as(i32, 40021);
pub const UIA_OutlineStylesAttributeId = @as(i32, 40022);
pub const UIA_OverlineColorAttributeId = @as(i32, 40023);
pub const UIA_OverlineStyleAttributeId = @as(i32, 40024);
pub const UIA_StrikethroughColorAttributeId = @as(i32, 40025);
pub const UIA_StrikethroughStyleAttributeId = @as(i32, 40026);
pub const UIA_TabsAttributeId = @as(i32, 40027);
pub const UIA_TextFlowDirectionsAttributeId = @as(i32, 40028);
pub const UIA_UnderlineColorAttributeId = @as(i32, 40029);
pub const UIA_UnderlineStyleAttributeId = @as(i32, 40030);
pub const UIA_AnnotationTypesAttributeId = @as(i32, 40031);
pub const UIA_AnnotationObjectsAttributeId = @as(i32, 40032);
pub const UIA_StyleNameAttributeId = @as(i32, 40033);
pub const UIA_StyleIdAttributeId = @as(i32, 40034);
pub const UIA_LinkAttributeId = @as(i32, 40035);
pub const UIA_IsActiveAttributeId = @as(i32, 40036);
pub const UIA_SelectionActiveEndAttributeId = @as(i32, 40037);
pub const UIA_CaretPositionAttributeId = @as(i32, 40038);
pub const UIA_CaretBidiModeAttributeId = @as(i32, 40039);
pub const UIA_LineSpacingAttributeId = @as(i32, 40040);
pub const UIA_BeforeParagraphSpacingAttributeId = @as(i32, 40041);
pub const UIA_AfterParagraphSpacingAttributeId = @as(i32, 40042);
pub const UIA_SayAsInterpretAsAttributeId = @as(i32, 40043);
pub const UIA_ButtonControlTypeId = @as(i32, 50000);
pub const UIA_CalendarControlTypeId = @as(i32, 50001);
pub const UIA_CheckBoxControlTypeId = @as(i32, 50002);
pub const UIA_ComboBoxControlTypeId = @as(i32, 50003);
pub const UIA_EditControlTypeId = @as(i32, 50004);
pub const UIA_HyperlinkControlTypeId = @as(i32, 50005);
pub const UIA_ImageControlTypeId = @as(i32, 50006);
pub const UIA_ListItemControlTypeId = @as(i32, 50007);
pub const UIA_ListControlTypeId = @as(i32, 50008);
pub const UIA_MenuControlTypeId = @as(i32, 50009);
pub const UIA_MenuBarControlTypeId = @as(i32, 50010);
pub const UIA_MenuItemControlTypeId = @as(i32, 50011);
pub const UIA_ProgressBarControlTypeId = @as(i32, 50012);
pub const UIA_RadioButtonControlTypeId = @as(i32, 50013);
pub const UIA_ScrollBarControlTypeId = @as(i32, 50014);
pub const UIA_SliderControlTypeId = @as(i32, 50015);
pub const UIA_SpinnerControlTypeId = @as(i32, 50016);
pub const UIA_StatusBarControlTypeId = @as(i32, 50017);
pub const UIA_TabControlTypeId = @as(i32, 50018);
pub const UIA_TabItemControlTypeId = @as(i32, 50019);
pub const UIA_TextControlTypeId = @as(i32, 50020);
pub const UIA_ToolBarControlTypeId = @as(i32, 50021);
pub const UIA_ToolTipControlTypeId = @as(i32, 50022);
pub const UIA_TreeControlTypeId = @as(i32, 50023);
pub const UIA_TreeItemControlTypeId = @as(i32, 50024);
pub const UIA_CustomControlTypeId = @as(i32, 50025);
pub const UIA_GroupControlTypeId = @as(i32, 50026);
pub const UIA_ThumbControlTypeId = @as(i32, 50027);
pub const UIA_DataGridControlTypeId = @as(i32, 50028);
pub const UIA_DataItemControlTypeId = @as(i32, 50029);
pub const UIA_DocumentControlTypeId = @as(i32, 50030);
pub const UIA_SplitButtonControlTypeId = @as(i32, 50031);
pub const UIA_WindowControlTypeId = @as(i32, 50032);
pub const UIA_PaneControlTypeId = @as(i32, 50033);
pub const UIA_HeaderControlTypeId = @as(i32, 50034);
pub const UIA_HeaderItemControlTypeId = @as(i32, 50035);
pub const UIA_TableControlTypeId = @as(i32, 50036);
pub const UIA_TitleBarControlTypeId = @as(i32, 50037);
pub const UIA_SeparatorControlTypeId = @as(i32, 50038);
pub const UIA_SemanticZoomControlTypeId = @as(i32, 50039);
pub const UIA_AppBarControlTypeId = @as(i32, 50040);
pub const AnnotationType_Unknown = @as(i32, 60000);
pub const AnnotationType_SpellingError = @as(i32, 60001);
pub const AnnotationType_GrammarError = @as(i32, 60002);
pub const AnnotationType_Comment = @as(i32, 60003);
pub const AnnotationType_FormulaError = @as(i32, 60004);
pub const AnnotationType_TrackChanges = @as(i32, 60005);
pub const AnnotationType_Header = @as(i32, 60006);
pub const AnnotationType_Footer = @as(i32, 60007);
pub const AnnotationType_Highlighted = @as(i32, 60008);
pub const AnnotationType_Endnote = @as(i32, 60009);
pub const AnnotationType_Footnote = @as(i32, 60010);
pub const AnnotationType_InsertionChange = @as(i32, 60011);
pub const AnnotationType_DeletionChange = @as(i32, 60012);
pub const AnnotationType_MoveChange = @as(i32, 60013);
pub const AnnotationType_FormatChange = @as(i32, 60014);
pub const AnnotationType_UnsyncedChange = @as(i32, 60015);
pub const AnnotationType_EditingLockedChange = @as(i32, 60016);
pub const AnnotationType_ExternalChange = @as(i32, 60017);
pub const AnnotationType_ConflictingChange = @as(i32, 60018);
pub const AnnotationType_Author = @as(i32, 60019);
pub const AnnotationType_AdvancedProofingIssue = @as(i32, 60020);
pub const AnnotationType_DataValidationError = @as(i32, 60021);
pub const AnnotationType_CircularReferenceError = @as(i32, 60022);
pub const AnnotationType_Mathematics = @as(i32, 60023);
pub const AnnotationType_Sensitive = @as(i32, 60024);
pub const StyleId_Custom = @as(i32, 70000);
pub const StyleId_Heading1 = @as(i32, 70001);
pub const StyleId_Heading2 = @as(i32, 70002);
pub const StyleId_Heading3 = @as(i32, 70003);
pub const StyleId_Heading4 = @as(i32, 70004);
pub const StyleId_Heading5 = @as(i32, 70005);
pub const StyleId_Heading6 = @as(i32, 70006);
pub const StyleId_Heading7 = @as(i32, 70007);
pub const StyleId_Heading8 = @as(i32, 70008);
pub const StyleId_Heading9 = @as(i32, 70009);
pub const StyleId_Title = @as(i32, 70010);
pub const StyleId_Subtitle = @as(i32, 70011);
pub const StyleId_Normal = @as(i32, 70012);
pub const StyleId_Emphasis = @as(i32, 70013);
pub const StyleId_Quote = @as(i32, 70014);
pub const StyleId_BulletedList = @as(i32, 70015);
pub const StyleId_NumberedList = @as(i32, 70016);
pub const UIA_CustomLandmarkTypeId = @as(i32, 80000);
pub const UIA_FormLandmarkTypeId = @as(i32, 80001);
pub const UIA_MainLandmarkTypeId = @as(i32, 80002);
pub const UIA_NavigationLandmarkTypeId = @as(i32, 80003);
pub const UIA_SearchLandmarkTypeId = @as(i32, 80004);
pub const HeadingLevel_None = @as(i32, 80050);
pub const HeadingLevel1 = @as(i32, 80051);
pub const HeadingLevel2 = @as(i32, 80052);
pub const HeadingLevel3 = @as(i32, 80053);
pub const HeadingLevel4 = @as(i32, 80054);
pub const HeadingLevel5 = @as(i32, 80055);
pub const HeadingLevel6 = @as(i32, 80056);
pub const HeadingLevel7 = @as(i32, 80057);
pub const HeadingLevel8 = @as(i32, 80058);
pub const HeadingLevel9 = @as(i32, 80059);
pub const UIA_SummaryChangeId = @as(i32, 90000);
pub const UIA_SayAsInterpretAsMetadataId = @as(i32, 100000);

//--------------------------------------------------------------------------------
// Section: Types (243)
//--------------------------------------------------------------------------------
pub const STICKYKEYS_FLAGS = enum(u32) {
    STICKYKEYSON = 1,
    AVAILABLE = 2,
    HOTKEYACTIVE = 4,
    CONFIRMHOTKEY = 8,
    HOTKEYSOUND = 16,
    INDICATOR = 32,
    AUDIBLEFEEDBACK = 64,
    TRISTATE = 128,
    TWOKEYSOFF = 256,
    LALTLATCHED = 268435456,
    LCTLLATCHED = 67108864,
    LSHIFTLATCHED = 16777216,
    RALTLATCHED = 536870912,
    RCTLLATCHED = 134217728,
    RSHIFTLATCHED = 33554432,
    LWINLATCHED = 1073741824,
    RWINLATCHED = 2147483648,
    LALTLOCKED = 1048576,
    LCTLLOCKED = 262144,
    LSHIFTLOCKED = 65536,
    RALTLOCKED = 2097152,
    RCTLLOCKED = 524288,
    RSHIFTLOCKED = 131072,
    LWINLOCKED = 4194304,
    RWINLOCKED = 8388608,
    _,
    pub fn initFlags(o: struct {
        STICKYKEYSON: u1 = 0,
        AVAILABLE: u1 = 0,
        HOTKEYACTIVE: u1 = 0,
        CONFIRMHOTKEY: u1 = 0,
        HOTKEYSOUND: u1 = 0,
        INDICATOR: u1 = 0,
        AUDIBLEFEEDBACK: u1 = 0,
        TRISTATE: u1 = 0,
        TWOKEYSOFF: u1 = 0,
        LALTLATCHED: u1 = 0,
        LCTLLATCHED: u1 = 0,
        LSHIFTLATCHED: u1 = 0,
        RALTLATCHED: u1 = 0,
        RCTLLATCHED: u1 = 0,
        RSHIFTLATCHED: u1 = 0,
        LWINLATCHED: u1 = 0,
        RWINLATCHED: u1 = 0,
        LALTLOCKED: u1 = 0,
        LCTLLOCKED: u1 = 0,
        LSHIFTLOCKED: u1 = 0,
        RALTLOCKED: u1 = 0,
        RCTLLOCKED: u1 = 0,
        RSHIFTLOCKED: u1 = 0,
        LWINLOCKED: u1 = 0,
        RWINLOCKED: u1 = 0,
    }) STICKYKEYS_FLAGS {
        return @intToEnum(STICKYKEYS_FLAGS,
              (if (o.STICKYKEYSON == 1) @enumToInt(STICKYKEYS_FLAGS.STICKYKEYSON) else 0)
            | (if (o.AVAILABLE == 1) @enumToInt(STICKYKEYS_FLAGS.AVAILABLE) else 0)
            | (if (o.HOTKEYACTIVE == 1) @enumToInt(STICKYKEYS_FLAGS.HOTKEYACTIVE) else 0)
            | (if (o.CONFIRMHOTKEY == 1) @enumToInt(STICKYKEYS_FLAGS.CONFIRMHOTKEY) else 0)
            | (if (o.HOTKEYSOUND == 1) @enumToInt(STICKYKEYS_FLAGS.HOTKEYSOUND) else 0)
            | (if (o.INDICATOR == 1) @enumToInt(STICKYKEYS_FLAGS.INDICATOR) else 0)
            | (if (o.AUDIBLEFEEDBACK == 1) @enumToInt(STICKYKEYS_FLAGS.AUDIBLEFEEDBACK) else 0)
            | (if (o.TRISTATE == 1) @enumToInt(STICKYKEYS_FLAGS.TRISTATE) else 0)
            | (if (o.TWOKEYSOFF == 1) @enumToInt(STICKYKEYS_FLAGS.TWOKEYSOFF) else 0)
            | (if (o.LALTLATCHED == 1) @enumToInt(STICKYKEYS_FLAGS.LALTLATCHED) else 0)
            | (if (o.LCTLLATCHED == 1) @enumToInt(STICKYKEYS_FLAGS.LCTLLATCHED) else 0)
            | (if (o.LSHIFTLATCHED == 1) @enumToInt(STICKYKEYS_FLAGS.LSHIFTLATCHED) else 0)
            | (if (o.RALTLATCHED == 1) @enumToInt(STICKYKEYS_FLAGS.RALTLATCHED) else 0)
            | (if (o.RCTLLATCHED == 1) @enumToInt(STICKYKEYS_FLAGS.RCTLLATCHED) else 0)
            | (if (o.RSHIFTLATCHED == 1) @enumToInt(STICKYKEYS_FLAGS.RSHIFTLATCHED) else 0)
            | (if (o.LWINLATCHED == 1) @enumToInt(STICKYKEYS_FLAGS.LWINLATCHED) else 0)
            | (if (o.RWINLATCHED == 1) @enumToInt(STICKYKEYS_FLAGS.RWINLATCHED) else 0)
            | (if (o.LALTLOCKED == 1) @enumToInt(STICKYKEYS_FLAGS.LALTLOCKED) else 0)
            | (if (o.LCTLLOCKED == 1) @enumToInt(STICKYKEYS_FLAGS.LCTLLOCKED) else 0)
            | (if (o.LSHIFTLOCKED == 1) @enumToInt(STICKYKEYS_FLAGS.LSHIFTLOCKED) else 0)
            | (if (o.RALTLOCKED == 1) @enumToInt(STICKYKEYS_FLAGS.RALTLOCKED) else 0)
            | (if (o.RCTLLOCKED == 1) @enumToInt(STICKYKEYS_FLAGS.RCTLLOCKED) else 0)
            | (if (o.RSHIFTLOCKED == 1) @enumToInt(STICKYKEYS_FLAGS.RSHIFTLOCKED) else 0)
            | (if (o.LWINLOCKED == 1) @enumToInt(STICKYKEYS_FLAGS.LWINLOCKED) else 0)
            | (if (o.RWINLOCKED == 1) @enumToInt(STICKYKEYS_FLAGS.RWINLOCKED) else 0)
        );
    }
};
pub const SKF_STICKYKEYSON = STICKYKEYS_FLAGS.STICKYKEYSON;
pub const SKF_AVAILABLE = STICKYKEYS_FLAGS.AVAILABLE;
pub const SKF_HOTKEYACTIVE = STICKYKEYS_FLAGS.HOTKEYACTIVE;
pub const SKF_CONFIRMHOTKEY = STICKYKEYS_FLAGS.CONFIRMHOTKEY;
pub const SKF_HOTKEYSOUND = STICKYKEYS_FLAGS.HOTKEYSOUND;
pub const SKF_INDICATOR = STICKYKEYS_FLAGS.INDICATOR;
pub const SKF_AUDIBLEFEEDBACK = STICKYKEYS_FLAGS.AUDIBLEFEEDBACK;
pub const SKF_TRISTATE = STICKYKEYS_FLAGS.TRISTATE;
pub const SKF_TWOKEYSOFF = STICKYKEYS_FLAGS.TWOKEYSOFF;
pub const SKF_LALTLATCHED = STICKYKEYS_FLAGS.LALTLATCHED;
pub const SKF_LCTLLATCHED = STICKYKEYS_FLAGS.LCTLLATCHED;
pub const SKF_LSHIFTLATCHED = STICKYKEYS_FLAGS.LSHIFTLATCHED;
pub const SKF_RALTLATCHED = STICKYKEYS_FLAGS.RALTLATCHED;
pub const SKF_RCTLLATCHED = STICKYKEYS_FLAGS.RCTLLATCHED;
pub const SKF_RSHIFTLATCHED = STICKYKEYS_FLAGS.RSHIFTLATCHED;
pub const SKF_LWINLATCHED = STICKYKEYS_FLAGS.LWINLATCHED;
pub const SKF_RWINLATCHED = STICKYKEYS_FLAGS.RWINLATCHED;
pub const SKF_LALTLOCKED = STICKYKEYS_FLAGS.LALTLOCKED;
pub const SKF_LCTLLOCKED = STICKYKEYS_FLAGS.LCTLLOCKED;
pub const SKF_LSHIFTLOCKED = STICKYKEYS_FLAGS.LSHIFTLOCKED;
pub const SKF_RALTLOCKED = STICKYKEYS_FLAGS.RALTLOCKED;
pub const SKF_RCTLLOCKED = STICKYKEYS_FLAGS.RCTLLOCKED;
pub const SKF_RSHIFTLOCKED = STICKYKEYS_FLAGS.RSHIFTLOCKED;
pub const SKF_LWINLOCKED = STICKYKEYS_FLAGS.LWINLOCKED;
pub const SKF_RWINLOCKED = STICKYKEYS_FLAGS.RWINLOCKED;

pub const SOUNDSENTRY_FLAGS = enum(u32) {
    SOUNDSENTRYON = 1,
    AVAILABLE = 2,
    INDICATOR = 4,
    _,
    pub fn initFlags(o: struct {
        SOUNDSENTRYON: u1 = 0,
        AVAILABLE: u1 = 0,
        INDICATOR: u1 = 0,
    }) SOUNDSENTRY_FLAGS {
        return @intToEnum(SOUNDSENTRY_FLAGS,
              (if (o.SOUNDSENTRYON == 1) @enumToInt(SOUNDSENTRY_FLAGS.SOUNDSENTRYON) else 0)
            | (if (o.AVAILABLE == 1) @enumToInt(SOUNDSENTRY_FLAGS.AVAILABLE) else 0)
            | (if (o.INDICATOR == 1) @enumToInt(SOUNDSENTRY_FLAGS.INDICATOR) else 0)
        );
    }
};
pub const SSF_SOUNDSENTRYON = SOUNDSENTRY_FLAGS.SOUNDSENTRYON;
pub const SSF_AVAILABLE = SOUNDSENTRY_FLAGS.AVAILABLE;
pub const SSF_INDICATOR = SOUNDSENTRY_FLAGS.INDICATOR;

pub const ACC_UTILITY_STATE_FLAGS = enum(u32) {
    ON_SCREEN_KEYBOARD_ACTIVE = 1,
    TOUCH_MODIFICATION_ACTIVE = 2,
    PRIORITY_AUDIO_ACTIVE = 4,
    PRIORITY_AUDIO_ACTIVE_NODUCK = 8,
    _,
    pub fn initFlags(o: struct {
        ON_SCREEN_KEYBOARD_ACTIVE: u1 = 0,
        TOUCH_MODIFICATION_ACTIVE: u1 = 0,
        PRIORITY_AUDIO_ACTIVE: u1 = 0,
        PRIORITY_AUDIO_ACTIVE_NODUCK: u1 = 0,
    }) ACC_UTILITY_STATE_FLAGS {
        return @intToEnum(ACC_UTILITY_STATE_FLAGS,
              (if (o.ON_SCREEN_KEYBOARD_ACTIVE == 1) @enumToInt(ACC_UTILITY_STATE_FLAGS.ON_SCREEN_KEYBOARD_ACTIVE) else 0)
            | (if (o.TOUCH_MODIFICATION_ACTIVE == 1) @enumToInt(ACC_UTILITY_STATE_FLAGS.TOUCH_MODIFICATION_ACTIVE) else 0)
            | (if (o.PRIORITY_AUDIO_ACTIVE == 1) @enumToInt(ACC_UTILITY_STATE_FLAGS.PRIORITY_AUDIO_ACTIVE) else 0)
            | (if (o.PRIORITY_AUDIO_ACTIVE_NODUCK == 1) @enumToInt(ACC_UTILITY_STATE_FLAGS.PRIORITY_AUDIO_ACTIVE_NODUCK) else 0)
        );
    }
};
pub const ANRUS_ON_SCREEN_KEYBOARD_ACTIVE = ACC_UTILITY_STATE_FLAGS.ON_SCREEN_KEYBOARD_ACTIVE;
pub const ANRUS_TOUCH_MODIFICATION_ACTIVE = ACC_UTILITY_STATE_FLAGS.TOUCH_MODIFICATION_ACTIVE;
pub const ANRUS_PRIORITY_AUDIO_ACTIVE = ACC_UTILITY_STATE_FLAGS.PRIORITY_AUDIO_ACTIVE;
pub const ANRUS_PRIORITY_AUDIO_ACTIVE_NODUCK = ACC_UTILITY_STATE_FLAGS.PRIORITY_AUDIO_ACTIVE_NODUCK;

pub const SOUND_SENTRY_GRAPHICS_EFFECT = enum(u32) {
    DISPLAY = 3,
    NONE = 0,
};
pub const SSGF_DISPLAY = SOUND_SENTRY_GRAPHICS_EFFECT.DISPLAY;
pub const SSGF_NONE = SOUND_SENTRY_GRAPHICS_EFFECT.NONE;

pub const SERIALKEYS_FLAGS = enum(u32) {
    AVAILABLE = 2,
    INDICATOR = 4,
    SERIALKEYSON = 1,
    _,
    pub fn initFlags(o: struct {
        AVAILABLE: u1 = 0,
        INDICATOR: u1 = 0,
        SERIALKEYSON: u1 = 0,
    }) SERIALKEYS_FLAGS {
        return @intToEnum(SERIALKEYS_FLAGS,
              (if (o.AVAILABLE == 1) @enumToInt(SERIALKEYS_FLAGS.AVAILABLE) else 0)
            | (if (o.INDICATOR == 1) @enumToInt(SERIALKEYS_FLAGS.INDICATOR) else 0)
            | (if (o.SERIALKEYSON == 1) @enumToInt(SERIALKEYS_FLAGS.SERIALKEYSON) else 0)
        );
    }
};
pub const SERKF_AVAILABLE = SERIALKEYS_FLAGS.AVAILABLE;
pub const SERKF_INDICATOR = SERIALKEYS_FLAGS.INDICATOR;
pub const SERKF_SERIALKEYSON = SERIALKEYS_FLAGS.SERIALKEYSON;

pub const HIGHCONTRASTW_FLAGS = enum(u32) {
    HIGHCONTRASTON = 1,
    AVAILABLE = 2,
    HOTKEYACTIVE = 4,
    CONFIRMHOTKEY = 8,
    HOTKEYSOUND = 16,
    INDICATOR = 32,
    HOTKEYAVAILABLE = 64,
    OPTION_NOTHEMECHANGE = 4096,
    _,
    pub fn initFlags(o: struct {
        HIGHCONTRASTON: u1 = 0,
        AVAILABLE: u1 = 0,
        HOTKEYACTIVE: u1 = 0,
        CONFIRMHOTKEY: u1 = 0,
        HOTKEYSOUND: u1 = 0,
        INDICATOR: u1 = 0,
        HOTKEYAVAILABLE: u1 = 0,
        OPTION_NOTHEMECHANGE: u1 = 0,
    }) HIGHCONTRASTW_FLAGS {
        return @intToEnum(HIGHCONTRASTW_FLAGS,
              (if (o.HIGHCONTRASTON == 1) @enumToInt(HIGHCONTRASTW_FLAGS.HIGHCONTRASTON) else 0)
            | (if (o.AVAILABLE == 1) @enumToInt(HIGHCONTRASTW_FLAGS.AVAILABLE) else 0)
            | (if (o.HOTKEYACTIVE == 1) @enumToInt(HIGHCONTRASTW_FLAGS.HOTKEYACTIVE) else 0)
            | (if (o.CONFIRMHOTKEY == 1) @enumToInt(HIGHCONTRASTW_FLAGS.CONFIRMHOTKEY) else 0)
            | (if (o.HOTKEYSOUND == 1) @enumToInt(HIGHCONTRASTW_FLAGS.HOTKEYSOUND) else 0)
            | (if (o.INDICATOR == 1) @enumToInt(HIGHCONTRASTW_FLAGS.INDICATOR) else 0)
            | (if (o.HOTKEYAVAILABLE == 1) @enumToInt(HIGHCONTRASTW_FLAGS.HOTKEYAVAILABLE) else 0)
            | (if (o.OPTION_NOTHEMECHANGE == 1) @enumToInt(HIGHCONTRASTW_FLAGS.OPTION_NOTHEMECHANGE) else 0)
        );
    }
};
pub const HCF_HIGHCONTRASTON = HIGHCONTRASTW_FLAGS.HIGHCONTRASTON;
pub const HCF_AVAILABLE = HIGHCONTRASTW_FLAGS.AVAILABLE;
pub const HCF_HOTKEYACTIVE = HIGHCONTRASTW_FLAGS.HOTKEYACTIVE;
pub const HCF_CONFIRMHOTKEY = HIGHCONTRASTW_FLAGS.CONFIRMHOTKEY;
pub const HCF_HOTKEYSOUND = HIGHCONTRASTW_FLAGS.HOTKEYSOUND;
pub const HCF_INDICATOR = HIGHCONTRASTW_FLAGS.INDICATOR;
pub const HCF_HOTKEYAVAILABLE = HIGHCONTRASTW_FLAGS.HOTKEYAVAILABLE;
pub const HCF_OPTION_NOTHEMECHANGE = HIGHCONTRASTW_FLAGS.OPTION_NOTHEMECHANGE;

pub const SOUNDSENTRY_TEXT_EFFECT = enum(u32) {
    BORDER = 2,
    CHARS = 1,
    DISPLAY = 3,
    NONE = 0,
};
pub const SSTF_BORDER = SOUNDSENTRY_TEXT_EFFECT.BORDER;
pub const SSTF_CHARS = SOUNDSENTRY_TEXT_EFFECT.CHARS;
pub const SSTF_DISPLAY = SOUNDSENTRY_TEXT_EFFECT.DISPLAY;
pub const SSTF_NONE = SOUNDSENTRY_TEXT_EFFECT.NONE;

pub const SOUNDSENTRY_WINDOWS_EFFECT = enum(u32) {
    CUSTOM = 4,
    DISPLAY = 3,
    NONE = 0,
    TITLE = 1,
    WINDOW = 2,
};
pub const SSWF_CUSTOM = SOUNDSENTRY_WINDOWS_EFFECT.CUSTOM;
pub const SSWF_DISPLAY = SOUNDSENTRY_WINDOWS_EFFECT.DISPLAY;
pub const SSWF_NONE = SOUNDSENTRY_WINDOWS_EFFECT.NONE;
pub const SSWF_TITLE = SOUNDSENTRY_WINDOWS_EFFECT.TITLE;
pub const SSWF_WINDOW = SOUNDSENTRY_WINDOWS_EFFECT.WINDOW;

// TODO: this type has a FreeFunc 'UnhookWinEvent', what can Zig do with this information?
pub const HWINEVENTHOOK = *opaque{};

pub const HUIANODE = *opaque{};

pub const HUIAPATTERNOBJECT = *opaque{};

pub const HUIATEXTRANGE = *opaque{};

pub const HUIAEVENT = *opaque{};

// TODO: this type is limited to platform 'windows8.0'
pub const IRicheditWindowlessAccessibility = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateProvider: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRicheditWindowlessAccessibility,
                pSite: ?*IRawElementProviderWindowlessSite,
                ppProvider: ?*?*IRawElementProviderSimple,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRicheditWindowlessAccessibility,
                pSite: ?*IRawElementProviderWindowlessSite,
                ppProvider: ?*?*IRawElementProviderSimple,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRicheditWindowlessAccessibility_CreateProvider(self: *const T, pSite: ?*IRawElementProviderWindowlessSite, ppProvider: ?*?*IRawElementProviderSimple) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRicheditWindowlessAccessibility.VTable, self.vtable).CreateProvider(@ptrCast(*const IRicheditWindowlessAccessibility, self), pSite, ppProvider);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
pub const IRichEditUiaInformation = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetBoundaryRectangle: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRichEditUiaInformation,
                pUiaRect: ?*UiaRect,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRichEditUiaInformation,
                pUiaRect: ?*UiaRect,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsVisible: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRichEditUiaInformation,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRichEditUiaInformation,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditUiaInformation_GetBoundaryRectangle(self: *const T, pUiaRect: ?*UiaRect) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditUiaInformation.VTable, self.vtable).GetBoundaryRectangle(@ptrCast(*const IRichEditUiaInformation, self), pUiaRect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditUiaInformation_IsVisible(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditUiaInformation.VTable, self.vtable).IsVisible(@ptrCast(*const IRichEditUiaInformation, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const CLSID_CAccPropServices_Value = Guid.initString("b5f8350b-0548-48b1-a6ee-88bd00b4a5e7");
pub const CLSID_CAccPropServices = &CLSID_CAccPropServices_Value;

pub const LPFNLRESULTFROMOBJECT = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        riid: ?*const Guid,
        wParam: WPARAM,
        punk: ?*IUnknown,
    ) callconv(@import("std").os.windows.WINAPI) LRESULT,
    else => *const fn(
        riid: ?*const Guid,
        wParam: WPARAM,
        punk: ?*IUnknown,
    ) callconv(@import("std").os.windows.WINAPI) LRESULT,
} ;

pub const LPFNOBJECTFROMLRESULT = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        lResult: LRESULT,
        riid: ?*const Guid,
        wParam: WPARAM,
        ppvObject: ?*?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
        lResult: LRESULT,
        riid: ?*const Guid,
        wParam: WPARAM,
        ppvObject: ?*?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const LPFNACCESSIBLEOBJECTFROMWINDOW = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        hwnd: ?HWND,
        dwId: u32,
        riid: ?*const Guid,
        ppvObject: ?*?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
        hwnd: ?HWND,
        dwId: u32,
        riid: ?*const Guid,
        ppvObject: ?*?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const LPFNACCESSIBLEOBJECTFROMPOINT = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        ptScreen: POINT,
        ppacc: ?*?*IAccessible,
        pvarChild: ?*VARIANT,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
        ptScreen: POINT,
        ppacc: ?*?*IAccessible,
        pvarChild: ?*VARIANT,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const LPFNCREATESTDACCESSIBLEOBJECT = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        hwnd: ?HWND,
        idObject: i32,
        riid: ?*const Guid,
        ppvObject: ?*?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
        hwnd: ?HWND,
        idObject: i32,
        riid: ?*const Guid,
        ppvObject: ?*?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const LPFNACCESSIBLECHILDREN = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        paccContainer: ?*IAccessible,
        iChildStart: i32,
        cChildren: i32,
        rgvarChildren: ?*VARIANT,
        pcObtained: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
        paccContainer: ?*IAccessible,
        iChildStart: i32,
        cChildren: i32,
        rgvarChildren: ?*VARIANT,
        pcObtained: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const MSAAMENUINFO = extern struct {
    dwMSAASignature: u32,
    cchWText: u32,
    pszWText: ?PWSTR,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAccessible_Value = Guid.initString("618736e0-3c3d-11cf-810c-00aa00389b71");
pub const IID_IAccessible = &IID_IAccessible_Value;
pub const IAccessible = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_accParent: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAccessible,
                ppdispParent: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAccessible,
                ppdispParent: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_accChildCount: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAccessible,
                pcountChildren: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAccessible,
                pcountChildren: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_accChild: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAccessible,
                varChild: VARIANT,
                ppdispChild: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAccessible,
                varChild: VARIANT,
                ppdispChild: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_accName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAccessible,
                varChild: VARIANT,
                pszName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAccessible,
                varChild: VARIANT,
                pszName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_accValue: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAccessible,
                varChild: VARIANT,
                pszValue: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAccessible,
                varChild: VARIANT,
                pszValue: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_accDescription: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAccessible,
                varChild: VARIANT,
                pszDescription: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAccessible,
                varChild: VARIANT,
                pszDescription: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_accRole: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAccessible,
                varChild: VARIANT,
                pvarRole: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAccessible,
                varChild: VARIANT,
                pvarRole: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_accState: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAccessible,
                varChild: VARIANT,
                pvarState: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAccessible,
                varChild: VARIANT,
                pvarState: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_accHelp: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAccessible,
                varChild: VARIANT,
                pszHelp: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAccessible,
                varChild: VARIANT,
                pszHelp: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_accHelpTopic: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAccessible,
                pszHelpFile: ?*?BSTR,
                varChild: VARIANT,
                pidTopic: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAccessible,
                pszHelpFile: ?*?BSTR,
                varChild: VARIANT,
                pidTopic: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_accKeyboardShortcut: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAccessible,
                varChild: VARIANT,
                pszKeyboardShortcut: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAccessible,
                varChild: VARIANT,
                pszKeyboardShortcut: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_accFocus: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAccessible,
                pvarChild: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAccessible,
                pvarChild: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_accSelection: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAccessible,
                pvarChildren: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAccessible,
                pvarChildren: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_accDefaultAction: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAccessible,
                varChild: VARIANT,
                pszDefaultAction: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAccessible,
                varChild: VARIANT,
                pszDefaultAction: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        accSelect: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAccessible,
                flagsSelect: i32,
                varChild: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAccessible,
                flagsSelect: i32,
                varChild: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        accLocation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAccessible,
                pxLeft: ?*i32,
                pyTop: ?*i32,
                pcxWidth: ?*i32,
                pcyHeight: ?*i32,
                varChild: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAccessible,
                pxLeft: ?*i32,
                pyTop: ?*i32,
                pcxWidth: ?*i32,
                pcyHeight: ?*i32,
                varChild: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        accNavigate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAccessible,
                navDir: i32,
                varStart: VARIANT,
                pvarEndUpAt: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAccessible,
                navDir: i32,
                varStart: VARIANT,
                pvarEndUpAt: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        accHitTest: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAccessible,
                xLeft: i32,
                yTop: i32,
                pvarChild: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAccessible,
                xLeft: i32,
                yTop: i32,
                pvarChild: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        accDoDefaultAction: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAccessible,
                varChild: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAccessible,
                varChild: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_accName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAccessible,
                varChild: VARIANT,
                szName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAccessible,
                varChild: VARIANT,
                szName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_accValue: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAccessible,
                varChild: VARIANT,
                szValue: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAccessible,
                varChild: VARIANT,
                szValue: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccessible_get_accParent(self: *const T, ppdispParent: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccessible.VTable, self.vtable).get_accParent(@ptrCast(*const IAccessible, self), ppdispParent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccessible_get_accChildCount(self: *const T, pcountChildren: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccessible.VTable, self.vtable).get_accChildCount(@ptrCast(*const IAccessible, self), pcountChildren);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccessible_get_accChild(self: *const T, varChild: VARIANT, ppdispChild: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccessible.VTable, self.vtable).get_accChild(@ptrCast(*const IAccessible, self), varChild, ppdispChild);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccessible_get_accName(self: *const T, varChild: VARIANT, pszName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccessible.VTable, self.vtable).get_accName(@ptrCast(*const IAccessible, self), varChild, pszName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccessible_get_accValue(self: *const T, varChild: VARIANT, pszValue: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccessible.VTable, self.vtable).get_accValue(@ptrCast(*const IAccessible, self), varChild, pszValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccessible_get_accDescription(self: *const T, varChild: VARIANT, pszDescription: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccessible.VTable, self.vtable).get_accDescription(@ptrCast(*const IAccessible, self), varChild, pszDescription);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccessible_get_accRole(self: *const T, varChild: VARIANT, pvarRole: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccessible.VTable, self.vtable).get_accRole(@ptrCast(*const IAccessible, self), varChild, pvarRole);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccessible_get_accState(self: *const T, varChild: VARIANT, pvarState: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccessible.VTable, self.vtable).get_accState(@ptrCast(*const IAccessible, self), varChild, pvarState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccessible_get_accHelp(self: *const T, varChild: VARIANT, pszHelp: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccessible.VTable, self.vtable).get_accHelp(@ptrCast(*const IAccessible, self), varChild, pszHelp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccessible_get_accHelpTopic(self: *const T, pszHelpFile: ?*?BSTR, varChild: VARIANT, pidTopic: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccessible.VTable, self.vtable).get_accHelpTopic(@ptrCast(*const IAccessible, self), pszHelpFile, varChild, pidTopic);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccessible_get_accKeyboardShortcut(self: *const T, varChild: VARIANT, pszKeyboardShortcut: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccessible.VTable, self.vtable).get_accKeyboardShortcut(@ptrCast(*const IAccessible, self), varChild, pszKeyboardShortcut);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccessible_get_accFocus(self: *const T, pvarChild: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccessible.VTable, self.vtable).get_accFocus(@ptrCast(*const IAccessible, self), pvarChild);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccessible_get_accSelection(self: *const T, pvarChildren: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccessible.VTable, self.vtable).get_accSelection(@ptrCast(*const IAccessible, self), pvarChildren);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccessible_get_accDefaultAction(self: *const T, varChild: VARIANT, pszDefaultAction: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccessible.VTable, self.vtable).get_accDefaultAction(@ptrCast(*const IAccessible, self), varChild, pszDefaultAction);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccessible_accSelect(self: *const T, flagsSelect: i32, varChild: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccessible.VTable, self.vtable).accSelect(@ptrCast(*const IAccessible, self), flagsSelect, varChild);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccessible_accLocation(self: *const T, pxLeft: ?*i32, pyTop: ?*i32, pcxWidth: ?*i32, pcyHeight: ?*i32, varChild: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccessible.VTable, self.vtable).accLocation(@ptrCast(*const IAccessible, self), pxLeft, pyTop, pcxWidth, pcyHeight, varChild);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccessible_accNavigate(self: *const T, navDir: i32, varStart: VARIANT, pvarEndUpAt: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccessible.VTable, self.vtable).accNavigate(@ptrCast(*const IAccessible, self), navDir, varStart, pvarEndUpAt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccessible_accHitTest(self: *const T, xLeft: i32, yTop: i32, pvarChild: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccessible.VTable, self.vtable).accHitTest(@ptrCast(*const IAccessible, self), xLeft, yTop, pvarChild);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccessible_accDoDefaultAction(self: *const T, varChild: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccessible.VTable, self.vtable).accDoDefaultAction(@ptrCast(*const IAccessible, self), varChild);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccessible_put_accName(self: *const T, varChild: VARIANT, szName: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccessible.VTable, self.vtable).put_accName(@ptrCast(*const IAccessible, self), varChild, szName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccessible_put_accValue(self: *const T, varChild: VARIANT, szValue: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccessible.VTable, self.vtable).put_accValue(@ptrCast(*const IAccessible, self), varChild, szValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IAccessibleHandler_Value = Guid.initString("03022430-abc4-11d0-bde2-00aa001a1953");
pub const IID_IAccessibleHandler = &IID_IAccessibleHandler_Value;
pub const IAccessibleHandler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AccessibleObjectFromID: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAccessibleHandler,
                hwnd: i32,
                lObjectID: i32,
                pIAccessible: ?*?*IAccessible,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAccessibleHandler,
                hwnd: i32,
                lObjectID: i32,
                pIAccessible: ?*?*IAccessible,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccessibleHandler_AccessibleObjectFromID(self: *const T, hwnd: i32, lObjectID: i32, pIAccessible: ?*?*IAccessible) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccessibleHandler.VTable, self.vtable).AccessibleObjectFromID(@ptrCast(*const IAccessibleHandler, self), hwnd, lObjectID, pIAccessible);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IAccessibleWindowlessSite_Value = Guid.initString("bf3abd9c-76da-4389-9eb6-1427d25abab7");
pub const IID_IAccessibleWindowlessSite = &IID_IAccessibleWindowlessSite_Value;
pub const IAccessibleWindowlessSite = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AcquireObjectIdRange: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAccessibleWindowlessSite,
                rangeSize: i32,
                pRangeOwner: ?*IAccessibleHandler,
                pRangeBase: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAccessibleWindowlessSite,
                rangeSize: i32,
                pRangeOwner: ?*IAccessibleHandler,
                pRangeBase: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReleaseObjectIdRange: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAccessibleWindowlessSite,
                rangeBase: i32,
                pRangeOwner: ?*IAccessibleHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAccessibleWindowlessSite,
                rangeBase: i32,
                pRangeOwner: ?*IAccessibleHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryObjectIdRanges: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAccessibleWindowlessSite,
                pRangesOwner: ?*IAccessibleHandler,
                psaRanges: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAccessibleWindowlessSite,
                pRangesOwner: ?*IAccessibleHandler,
                psaRanges: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetParentAccessible: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAccessibleWindowlessSite,
                ppParent: ?*?*IAccessible,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAccessibleWindowlessSite,
                ppParent: ?*?*IAccessible,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccessibleWindowlessSite_AcquireObjectIdRange(self: *const T, rangeSize: i32, pRangeOwner: ?*IAccessibleHandler, pRangeBase: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccessibleWindowlessSite.VTable, self.vtable).AcquireObjectIdRange(@ptrCast(*const IAccessibleWindowlessSite, self), rangeSize, pRangeOwner, pRangeBase);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccessibleWindowlessSite_ReleaseObjectIdRange(self: *const T, rangeBase: i32, pRangeOwner: ?*IAccessibleHandler) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccessibleWindowlessSite.VTable, self.vtable).ReleaseObjectIdRange(@ptrCast(*const IAccessibleWindowlessSite, self), rangeBase, pRangeOwner);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccessibleWindowlessSite_QueryObjectIdRanges(self: *const T, pRangesOwner: ?*IAccessibleHandler, psaRanges: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccessibleWindowlessSite.VTable, self.vtable).QueryObjectIdRanges(@ptrCast(*const IAccessibleWindowlessSite, self), pRangesOwner, psaRanges);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccessibleWindowlessSite_GetParentAccessible(self: *const T, ppParent: ?*?*IAccessible) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccessibleWindowlessSite.VTable, self.vtable).GetParentAccessible(@ptrCast(*const IAccessibleWindowlessSite, self), ppParent);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const AnnoScope = enum(i32) {
    THIS = 0,
    CONTAINER = 1,
};
pub const ANNO_THIS = AnnoScope.THIS;
pub const ANNO_CONTAINER = AnnoScope.CONTAINER;

// TODO: this type is limited to platform 'windows5.0'
const IID_IAccIdentity_Value = Guid.initString("7852b78d-1cfd-41c1-a615-9c0c85960b5f");
pub const IID_IAccIdentity = &IID_IAccIdentity_Value;
pub const IAccIdentity = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetIdentityString: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAccIdentity,
                dwIDChild: u32,
                ppIDString: [*]?*u8,
                pdwIDStringLen: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAccIdentity,
                dwIDChild: u32,
                ppIDString: [*]?*u8,
                pdwIDStringLen: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccIdentity_GetIdentityString(self: *const T, dwIDChild: u32, ppIDString: [*]?*u8, pdwIDStringLen: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccIdentity.VTable, self.vtable).GetIdentityString(@ptrCast(*const IAccIdentity, self), dwIDChild, ppIDString, pdwIDStringLen);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IAccPropServer_Value = Guid.initString("76c0dbbb-15e0-4e7b-b61b-20eeea2001e0");
pub const IID_IAccPropServer = &IID_IAccPropServer_Value;
pub const IAccPropServer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPropValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAccPropServer,
                pIDString: [*:0]const u8,
                dwIDStringLen: u32,
                idProp: Guid,
                pvarValue: ?*VARIANT,
                pfHasProp: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAccPropServer,
                pIDString: [*:0]const u8,
                dwIDStringLen: u32,
                idProp: Guid,
                pvarValue: ?*VARIANT,
                pfHasProp: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccPropServer_GetPropValue(self: *const T, pIDString: [*:0]const u8, dwIDStringLen: u32, idProp: Guid, pvarValue: ?*VARIANT, pfHasProp: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccPropServer.VTable, self.vtable).GetPropValue(@ptrCast(*const IAccPropServer, self), pIDString, dwIDStringLen, idProp, pvarValue, pfHasProp);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IAccPropServices_Value = Guid.initString("6e26e776-04f0-495d-80e4-3330352e3169");
pub const IID_IAccPropServices = &IID_IAccPropServices_Value;
pub const IAccPropServices = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetPropValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAccPropServices,
                pIDString: [*:0]const u8,
                dwIDStringLen: u32,
                idProp: Guid,
                @"var": VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAccPropServices,
                pIDString: [*:0]const u8,
                dwIDStringLen: u32,
                idProp: Guid,
                @"var": VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPropServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAccPropServices,
                pIDString: [*:0]const u8,
                dwIDStringLen: u32,
                paProps: [*]const Guid,
                cProps: i32,
                pServer: ?*IAccPropServer,
                annoScope: AnnoScope,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAccPropServices,
                pIDString: [*:0]const u8,
                dwIDStringLen: u32,
                paProps: [*]const Guid,
                cProps: i32,
                pServer: ?*IAccPropServer,
                annoScope: AnnoScope,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ClearProps: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAccPropServices,
                pIDString: [*:0]const u8,
                dwIDStringLen: u32,
                paProps: [*]const Guid,
                cProps: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAccPropServices,
                pIDString: [*:0]const u8,
                dwIDStringLen: u32,
                paProps: [*]const Guid,
                cProps: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetHwndProp: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAccPropServices,
                hwnd: ?HWND,
                idObject: u32,
                idChild: u32,
                idProp: Guid,
                @"var": VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAccPropServices,
                hwnd: ?HWND,
                idObject: u32,
                idChild: u32,
                idProp: Guid,
                @"var": VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetHwndPropStr: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAccPropServices,
                hwnd: ?HWND,
                idObject: u32,
                idChild: u32,
                idProp: Guid,
                str: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAccPropServices,
                hwnd: ?HWND,
                idObject: u32,
                idChild: u32,
                idProp: Guid,
                str: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetHwndPropServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAccPropServices,
                hwnd: ?HWND,
                idObject: u32,
                idChild: u32,
                paProps: [*]const Guid,
                cProps: i32,
                pServer: ?*IAccPropServer,
                annoScope: AnnoScope,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAccPropServices,
                hwnd: ?HWND,
                idObject: u32,
                idChild: u32,
                paProps: [*]const Guid,
                cProps: i32,
                pServer: ?*IAccPropServer,
                annoScope: AnnoScope,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ClearHwndProps: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAccPropServices,
                hwnd: ?HWND,
                idObject: u32,
                idChild: u32,
                paProps: [*]const Guid,
                cProps: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAccPropServices,
                hwnd: ?HWND,
                idObject: u32,
                idChild: u32,
                paProps: [*]const Guid,
                cProps: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ComposeHwndIdentityString: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAccPropServices,
                hwnd: ?HWND,
                idObject: u32,
                idChild: u32,
                ppIDString: [*]?*u8,
                pdwIDStringLen: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAccPropServices,
                hwnd: ?HWND,
                idObject: u32,
                idChild: u32,
                ppIDString: [*]?*u8,
                pdwIDStringLen: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DecomposeHwndIdentityString: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAccPropServices,
                pIDString: [*:0]const u8,
                dwIDStringLen: u32,
                phwnd: ?*?HWND,
                pidObject: ?*u32,
                pidChild: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAccPropServices,
                pIDString: [*:0]const u8,
                dwIDStringLen: u32,
                phwnd: ?*?HWND,
                pidObject: ?*u32,
                pidChild: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetHmenuProp: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAccPropServices,
                hmenu: ?HMENU,
                idChild: u32,
                idProp: Guid,
                @"var": VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAccPropServices,
                hmenu: ?HMENU,
                idChild: u32,
                idProp: Guid,
                @"var": VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetHmenuPropStr: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAccPropServices,
                hmenu: ?HMENU,
                idChild: u32,
                idProp: Guid,
                str: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAccPropServices,
                hmenu: ?HMENU,
                idChild: u32,
                idProp: Guid,
                str: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetHmenuPropServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAccPropServices,
                hmenu: ?HMENU,
                idChild: u32,
                paProps: [*]const Guid,
                cProps: i32,
                pServer: ?*IAccPropServer,
                annoScope: AnnoScope,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAccPropServices,
                hmenu: ?HMENU,
                idChild: u32,
                paProps: [*]const Guid,
                cProps: i32,
                pServer: ?*IAccPropServer,
                annoScope: AnnoScope,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ClearHmenuProps: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAccPropServices,
                hmenu: ?HMENU,
                idChild: u32,
                paProps: [*]const Guid,
                cProps: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAccPropServices,
                hmenu: ?HMENU,
                idChild: u32,
                paProps: [*]const Guid,
                cProps: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ComposeHmenuIdentityString: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAccPropServices,
                hmenu: ?HMENU,
                idChild: u32,
                ppIDString: [*]?*u8,
                pdwIDStringLen: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAccPropServices,
                hmenu: ?HMENU,
                idChild: u32,
                ppIDString: [*]?*u8,
                pdwIDStringLen: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DecomposeHmenuIdentityString: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAccPropServices,
                pIDString: [*:0]const u8,
                dwIDStringLen: u32,
                phmenu: ?*?HMENU,
                pidChild: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAccPropServices,
                pIDString: [*:0]const u8,
                dwIDStringLen: u32,
                phmenu: ?*?HMENU,
                pidChild: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccPropServices_SetPropValue(self: *const T, pIDString: [*:0]const u8, dwIDStringLen: u32, idProp: Guid, @"var": VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccPropServices.VTable, self.vtable).SetPropValue(@ptrCast(*const IAccPropServices, self), pIDString, dwIDStringLen, idProp, @"var");
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccPropServices_SetPropServer(self: *const T, pIDString: [*:0]const u8, dwIDStringLen: u32, paProps: [*]const Guid, cProps: i32, pServer: ?*IAccPropServer, annoScope: AnnoScope) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccPropServices.VTable, self.vtable).SetPropServer(@ptrCast(*const IAccPropServices, self), pIDString, dwIDStringLen, paProps, cProps, pServer, annoScope);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccPropServices_ClearProps(self: *const T, pIDString: [*:0]const u8, dwIDStringLen: u32, paProps: [*]const Guid, cProps: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccPropServices.VTable, self.vtable).ClearProps(@ptrCast(*const IAccPropServices, self), pIDString, dwIDStringLen, paProps, cProps);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccPropServices_SetHwndProp(self: *const T, hwnd: ?HWND, idObject: u32, idChild: u32, idProp: Guid, @"var": VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccPropServices.VTable, self.vtable).SetHwndProp(@ptrCast(*const IAccPropServices, self), hwnd, idObject, idChild, idProp, @"var");
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccPropServices_SetHwndPropStr(self: *const T, hwnd: ?HWND, idObject: u32, idChild: u32, idProp: Guid, str: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccPropServices.VTable, self.vtable).SetHwndPropStr(@ptrCast(*const IAccPropServices, self), hwnd, idObject, idChild, idProp, str);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccPropServices_SetHwndPropServer(self: *const T, hwnd: ?HWND, idObject: u32, idChild: u32, paProps: [*]const Guid, cProps: i32, pServer: ?*IAccPropServer, annoScope: AnnoScope) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccPropServices.VTable, self.vtable).SetHwndPropServer(@ptrCast(*const IAccPropServices, self), hwnd, idObject, idChild, paProps, cProps, pServer, annoScope);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccPropServices_ClearHwndProps(self: *const T, hwnd: ?HWND, idObject: u32, idChild: u32, paProps: [*]const Guid, cProps: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccPropServices.VTable, self.vtable).ClearHwndProps(@ptrCast(*const IAccPropServices, self), hwnd, idObject, idChild, paProps, cProps);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccPropServices_ComposeHwndIdentityString(self: *const T, hwnd: ?HWND, idObject: u32, idChild: u32, ppIDString: [*]?*u8, pdwIDStringLen: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccPropServices.VTable, self.vtable).ComposeHwndIdentityString(@ptrCast(*const IAccPropServices, self), hwnd, idObject, idChild, ppIDString, pdwIDStringLen);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccPropServices_DecomposeHwndIdentityString(self: *const T, pIDString: [*:0]const u8, dwIDStringLen: u32, phwnd: ?*?HWND, pidObject: ?*u32, pidChild: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccPropServices.VTable, self.vtable).DecomposeHwndIdentityString(@ptrCast(*const IAccPropServices, self), pIDString, dwIDStringLen, phwnd, pidObject, pidChild);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccPropServices_SetHmenuProp(self: *const T, hmenu: ?HMENU, idChild: u32, idProp: Guid, @"var": VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccPropServices.VTable, self.vtable).SetHmenuProp(@ptrCast(*const IAccPropServices, self), hmenu, idChild, idProp, @"var");
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccPropServices_SetHmenuPropStr(self: *const T, hmenu: ?HMENU, idChild: u32, idProp: Guid, str: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccPropServices.VTable, self.vtable).SetHmenuPropStr(@ptrCast(*const IAccPropServices, self), hmenu, idChild, idProp, str);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccPropServices_SetHmenuPropServer(self: *const T, hmenu: ?HMENU, idChild: u32, paProps: [*]const Guid, cProps: i32, pServer: ?*IAccPropServer, annoScope: AnnoScope) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccPropServices.VTable, self.vtable).SetHmenuPropServer(@ptrCast(*const IAccPropServices, self), hmenu, idChild, paProps, cProps, pServer, annoScope);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccPropServices_ClearHmenuProps(self: *const T, hmenu: ?HMENU, idChild: u32, paProps: [*]const Guid, cProps: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccPropServices.VTable, self.vtable).ClearHmenuProps(@ptrCast(*const IAccPropServices, self), hmenu, idChild, paProps, cProps);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccPropServices_ComposeHmenuIdentityString(self: *const T, hmenu: ?HMENU, idChild: u32, ppIDString: [*]?*u8, pdwIDStringLen: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccPropServices.VTable, self.vtable).ComposeHmenuIdentityString(@ptrCast(*const IAccPropServices, self), hmenu, idChild, ppIDString, pdwIDStringLen);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccPropServices_DecomposeHmenuIdentityString(self: *const T, pIDString: [*:0]const u8, dwIDStringLen: u32, phmenu: ?*?HMENU, pidChild: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccPropServices.VTable, self.vtable).DecomposeHmenuIdentityString(@ptrCast(*const IAccPropServices, self), pIDString, dwIDStringLen, phmenu, pidChild);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const CLSID_CUIAutomation_Value = Guid.initString("ff48dba4-60ef-4201-aa87-54103eef594e");
pub const CLSID_CUIAutomation = &CLSID_CUIAutomation_Value;

const CLSID_CUIAutomation8_Value = Guid.initString("e22ad333-b25f-460c-83d0-0581107395c9");
pub const CLSID_CUIAutomation8 = &CLSID_CUIAutomation8_Value;

const CLSID_CUIAutomationRegistrar_Value = Guid.initString("6e29fabf-9977-42d1-8d0e-ca7e61ad87e6");
pub const CLSID_CUIAutomationRegistrar = &CLSID_CUIAutomationRegistrar_Value;

pub const NavigateDirection = enum(i32) {
    Parent = 0,
    NextSibling = 1,
    PreviousSibling = 2,
    FirstChild = 3,
    LastChild = 4,
};
pub const NavigateDirection_Parent = NavigateDirection.Parent;
pub const NavigateDirection_NextSibling = NavigateDirection.NextSibling;
pub const NavigateDirection_PreviousSibling = NavigateDirection.PreviousSibling;
pub const NavigateDirection_FirstChild = NavigateDirection.FirstChild;
pub const NavigateDirection_LastChild = NavigateDirection.LastChild;

pub const ProviderOptions = enum(i32) {
    ClientSideProvider = 1,
    ServerSideProvider = 2,
    NonClientAreaProvider = 4,
    OverrideProvider = 8,
    ProviderOwnsSetFocus = 16,
    UseComThreading = 32,
    RefuseNonClientSupport = 64,
    HasNativeIAccessible = 128,
    UseClientCoordinates = 256,
};
pub const ProviderOptions_ClientSideProvider = ProviderOptions.ClientSideProvider;
pub const ProviderOptions_ServerSideProvider = ProviderOptions.ServerSideProvider;
pub const ProviderOptions_NonClientAreaProvider = ProviderOptions.NonClientAreaProvider;
pub const ProviderOptions_OverrideProvider = ProviderOptions.OverrideProvider;
pub const ProviderOptions_ProviderOwnsSetFocus = ProviderOptions.ProviderOwnsSetFocus;
pub const ProviderOptions_UseComThreading = ProviderOptions.UseComThreading;
pub const ProviderOptions_RefuseNonClientSupport = ProviderOptions.RefuseNonClientSupport;
pub const ProviderOptions_HasNativeIAccessible = ProviderOptions.HasNativeIAccessible;
pub const ProviderOptions_UseClientCoordinates = ProviderOptions.UseClientCoordinates;

pub const StructureChangeType = enum(i32) {
    Added = 0,
    Removed = 1,
    renInvalidated = 2,
    renBulkAdded = 3,
    renBulkRemoved = 4,
    renReordered = 5,
};
pub const StructureChangeType_ChildAdded = StructureChangeType.Added;
pub const StructureChangeType_ChildRemoved = StructureChangeType.Removed;
pub const StructureChangeType_ChildrenInvalidated = StructureChangeType.renInvalidated;
pub const StructureChangeType_ChildrenBulkAdded = StructureChangeType.renBulkAdded;
pub const StructureChangeType_ChildrenBulkRemoved = StructureChangeType.renBulkRemoved;
pub const StructureChangeType_ChildrenReordered = StructureChangeType.renReordered;

pub const TextEditChangeType = enum(i32) {
    None = 0,
    AutoCorrect = 1,
    Composition = 2,
    CompositionFinalized = 3,
    AutoComplete = 4,
};
pub const TextEditChangeType_None = TextEditChangeType.None;
pub const TextEditChangeType_AutoCorrect = TextEditChangeType.AutoCorrect;
pub const TextEditChangeType_Composition = TextEditChangeType.Composition;
pub const TextEditChangeType_CompositionFinalized = TextEditChangeType.CompositionFinalized;
pub const TextEditChangeType_AutoComplete = TextEditChangeType.AutoComplete;

pub const OrientationType = enum(i32) {
    None = 0,
    Horizontal = 1,
    Vertical = 2,
};
pub const OrientationType_None = OrientationType.None;
pub const OrientationType_Horizontal = OrientationType.Horizontal;
pub const OrientationType_Vertical = OrientationType.Vertical;

pub const DockPosition = enum(i32) {
    Top = 0,
    Left = 1,
    Bottom = 2,
    Right = 3,
    Fill = 4,
    None = 5,
};
pub const DockPosition_Top = DockPosition.Top;
pub const DockPosition_Left = DockPosition.Left;
pub const DockPosition_Bottom = DockPosition.Bottom;
pub const DockPosition_Right = DockPosition.Right;
pub const DockPosition_Fill = DockPosition.Fill;
pub const DockPosition_None = DockPosition.None;

pub const ExpandCollapseState = enum(i32) {
    Collapsed = 0,
    Expanded = 1,
    PartiallyExpanded = 2,
    LeafNode = 3,
};
pub const ExpandCollapseState_Collapsed = ExpandCollapseState.Collapsed;
pub const ExpandCollapseState_Expanded = ExpandCollapseState.Expanded;
pub const ExpandCollapseState_PartiallyExpanded = ExpandCollapseState.PartiallyExpanded;
pub const ExpandCollapseState_LeafNode = ExpandCollapseState.LeafNode;

pub const ScrollAmount = enum(i32) {
    LargeDecrement = 0,
    SmallDecrement = 1,
    NoAmount = 2,
    LargeIncrement = 3,
    SmallIncrement = 4,
};
pub const ScrollAmount_LargeDecrement = ScrollAmount.LargeDecrement;
pub const ScrollAmount_SmallDecrement = ScrollAmount.SmallDecrement;
pub const ScrollAmount_NoAmount = ScrollAmount.NoAmount;
pub const ScrollAmount_LargeIncrement = ScrollAmount.LargeIncrement;
pub const ScrollAmount_SmallIncrement = ScrollAmount.SmallIncrement;

pub const RowOrColumnMajor = enum(i32) {
    RowMajor = 0,
    ColumnMajor = 1,
    Indeterminate = 2,
};
pub const RowOrColumnMajor_RowMajor = RowOrColumnMajor.RowMajor;
pub const RowOrColumnMajor_ColumnMajor = RowOrColumnMajor.ColumnMajor;
pub const RowOrColumnMajor_Indeterminate = RowOrColumnMajor.Indeterminate;

pub const ToggleState = enum(i32) {
    Off = 0,
    On = 1,
    Indeterminate = 2,
};
pub const ToggleState_Off = ToggleState.Off;
pub const ToggleState_On = ToggleState.On;
pub const ToggleState_Indeterminate = ToggleState.Indeterminate;

pub const WindowVisualState = enum(i32) {
    Normal = 0,
    Maximized = 1,
    Minimized = 2,
};
pub const WindowVisualState_Normal = WindowVisualState.Normal;
pub const WindowVisualState_Maximized = WindowVisualState.Maximized;
pub const WindowVisualState_Minimized = WindowVisualState.Minimized;

pub const SynchronizedInputType = enum(i32) {
    KeyUp = 1,
    KeyDown = 2,
    LeftMouseUp = 4,
    LeftMouseDown = 8,
    RightMouseUp = 16,
    RightMouseDown = 32,
};
pub const SynchronizedInputType_KeyUp = SynchronizedInputType.KeyUp;
pub const SynchronizedInputType_KeyDown = SynchronizedInputType.KeyDown;
pub const SynchronizedInputType_LeftMouseUp = SynchronizedInputType.LeftMouseUp;
pub const SynchronizedInputType_LeftMouseDown = SynchronizedInputType.LeftMouseDown;
pub const SynchronizedInputType_RightMouseUp = SynchronizedInputType.RightMouseUp;
pub const SynchronizedInputType_RightMouseDown = SynchronizedInputType.RightMouseDown;

pub const WindowInteractionState = enum(i32) {
    Running = 0,
    Closing = 1,
    ReadyForUserInteraction = 2,
    BlockedByModalWindow = 3,
    NotResponding = 4,
};
pub const WindowInteractionState_Running = WindowInteractionState.Running;
pub const WindowInteractionState_Closing = WindowInteractionState.Closing;
pub const WindowInteractionState_ReadyForUserInteraction = WindowInteractionState.ReadyForUserInteraction;
pub const WindowInteractionState_BlockedByModalWindow = WindowInteractionState.BlockedByModalWindow;
pub const WindowInteractionState_NotResponding = WindowInteractionState.NotResponding;

pub const SayAsInterpretAs = enum(i32) {
    None = 0,
    Spell = 1,
    Cardinal = 2,
    Ordinal = 3,
    Number = 4,
    Date = 5,
    Time = 6,
    Telephone = 7,
    Currency = 8,
    Net = 9,
    Url = 10,
    Address = 11,
    Alphanumeric = 12,
    Name = 13,
    Media = 14,
    Date_MonthDayYear = 15,
    Date_DayMonthYear = 16,
    Date_YearMonthDay = 17,
    Date_YearMonth = 18,
    Date_MonthYear = 19,
    Date_DayMonth = 20,
    Date_MonthDay = 21,
    Date_Year = 22,
    Time_HoursMinutesSeconds12 = 23,
    Time_HoursMinutes12 = 24,
    Time_HoursMinutesSeconds24 = 25,
    Time_HoursMinutes24 = 26,
};
pub const SayAsInterpretAs_None = SayAsInterpretAs.None;
pub const SayAsInterpretAs_Spell = SayAsInterpretAs.Spell;
pub const SayAsInterpretAs_Cardinal = SayAsInterpretAs.Cardinal;
pub const SayAsInterpretAs_Ordinal = SayAsInterpretAs.Ordinal;
pub const SayAsInterpretAs_Number = SayAsInterpretAs.Number;
pub const SayAsInterpretAs_Date = SayAsInterpretAs.Date;
pub const SayAsInterpretAs_Time = SayAsInterpretAs.Time;
pub const SayAsInterpretAs_Telephone = SayAsInterpretAs.Telephone;
pub const SayAsInterpretAs_Currency = SayAsInterpretAs.Currency;
pub const SayAsInterpretAs_Net = SayAsInterpretAs.Net;
pub const SayAsInterpretAs_Url = SayAsInterpretAs.Url;
pub const SayAsInterpretAs_Address = SayAsInterpretAs.Address;
pub const SayAsInterpretAs_Alphanumeric = SayAsInterpretAs.Alphanumeric;
pub const SayAsInterpretAs_Name = SayAsInterpretAs.Name;
pub const SayAsInterpretAs_Media = SayAsInterpretAs.Media;
pub const SayAsInterpretAs_Date_MonthDayYear = SayAsInterpretAs.Date_MonthDayYear;
pub const SayAsInterpretAs_Date_DayMonthYear = SayAsInterpretAs.Date_DayMonthYear;
pub const SayAsInterpretAs_Date_YearMonthDay = SayAsInterpretAs.Date_YearMonthDay;
pub const SayAsInterpretAs_Date_YearMonth = SayAsInterpretAs.Date_YearMonth;
pub const SayAsInterpretAs_Date_MonthYear = SayAsInterpretAs.Date_MonthYear;
pub const SayAsInterpretAs_Date_DayMonth = SayAsInterpretAs.Date_DayMonth;
pub const SayAsInterpretAs_Date_MonthDay = SayAsInterpretAs.Date_MonthDay;
pub const SayAsInterpretAs_Date_Year = SayAsInterpretAs.Date_Year;
pub const SayAsInterpretAs_Time_HoursMinutesSeconds12 = SayAsInterpretAs.Time_HoursMinutesSeconds12;
pub const SayAsInterpretAs_Time_HoursMinutes12 = SayAsInterpretAs.Time_HoursMinutes12;
pub const SayAsInterpretAs_Time_HoursMinutesSeconds24 = SayAsInterpretAs.Time_HoursMinutesSeconds24;
pub const SayAsInterpretAs_Time_HoursMinutes24 = SayAsInterpretAs.Time_HoursMinutes24;

pub const TextUnit = enum(i32) {
    Character = 0,
    Format = 1,
    Word = 2,
    Line = 3,
    Paragraph = 4,
    Page = 5,
    Document = 6,
};
pub const TextUnit_Character = TextUnit.Character;
pub const TextUnit_Format = TextUnit.Format;
pub const TextUnit_Word = TextUnit.Word;
pub const TextUnit_Line = TextUnit.Line;
pub const TextUnit_Paragraph = TextUnit.Paragraph;
pub const TextUnit_Page = TextUnit.Page;
pub const TextUnit_Document = TextUnit.Document;

pub const TextPatternRangeEndpoint = enum(i32) {
    Start = 0,
    End = 1,
};
pub const TextPatternRangeEndpoint_Start = TextPatternRangeEndpoint.Start;
pub const TextPatternRangeEndpoint_End = TextPatternRangeEndpoint.End;

pub const SupportedTextSelection = enum(i32) {
    None = 0,
    Single = 1,
    Multiple = 2,
};
pub const SupportedTextSelection_None = SupportedTextSelection.None;
pub const SupportedTextSelection_Single = SupportedTextSelection.Single;
pub const SupportedTextSelection_Multiple = SupportedTextSelection.Multiple;

pub const LiveSetting = enum(i32) {
    Off = 0,
    Polite = 1,
    Assertive = 2,
};
pub const Off = LiveSetting.Off;
pub const Polite = LiveSetting.Polite;
pub const Assertive = LiveSetting.Assertive;

pub const ActiveEnd = enum(i32) {
    None = 0,
    Start = 1,
    End = 2,
};
pub const ActiveEnd_None = ActiveEnd.None;
pub const ActiveEnd_Start = ActiveEnd.Start;
pub const ActiveEnd_End = ActiveEnd.End;

pub const CaretPosition = enum(i32) {
    Unknown = 0,
    EndOfLine = 1,
    BeginningOfLine = 2,
};
pub const CaretPosition_Unknown = CaretPosition.Unknown;
pub const CaretPosition_EndOfLine = CaretPosition.EndOfLine;
pub const CaretPosition_BeginningOfLine = CaretPosition.BeginningOfLine;

pub const CaretBidiMode = enum(i32) {
    LTR = 0,
    RTL = 1,
};
pub const CaretBidiMode_LTR = CaretBidiMode.LTR;
pub const CaretBidiMode_RTL = CaretBidiMode.RTL;

pub const ZoomUnit = enum(i32) {
    NoAmount = 0,
    LargeDecrement = 1,
    SmallDecrement = 2,
    LargeIncrement = 3,
    SmallIncrement = 4,
};
pub const ZoomUnit_NoAmount = ZoomUnit.NoAmount;
pub const ZoomUnit_LargeDecrement = ZoomUnit.LargeDecrement;
pub const ZoomUnit_SmallDecrement = ZoomUnit.SmallDecrement;
pub const ZoomUnit_LargeIncrement = ZoomUnit.LargeIncrement;
pub const ZoomUnit_SmallIncrement = ZoomUnit.SmallIncrement;

pub const AnimationStyle = enum(i32) {
    None = 0,
    LasVegasLights = 1,
    BlinkingBackground = 2,
    SparkleText = 3,
    MarchingBlackAnts = 4,
    MarchingRedAnts = 5,
    Shimmer = 6,
    Other = -1,
};
pub const AnimationStyle_None = AnimationStyle.None;
pub const AnimationStyle_LasVegasLights = AnimationStyle.LasVegasLights;
pub const AnimationStyle_BlinkingBackground = AnimationStyle.BlinkingBackground;
pub const AnimationStyle_SparkleText = AnimationStyle.SparkleText;
pub const AnimationStyle_MarchingBlackAnts = AnimationStyle.MarchingBlackAnts;
pub const AnimationStyle_MarchingRedAnts = AnimationStyle.MarchingRedAnts;
pub const AnimationStyle_Shimmer = AnimationStyle.Shimmer;
pub const AnimationStyle_Other = AnimationStyle.Other;

pub const BulletStyle = enum(i32) {
    None = 0,
    HollowRoundBullet = 1,
    FilledRoundBullet = 2,
    HollowSquareBullet = 3,
    FilledSquareBullet = 4,
    DashBullet = 5,
    Other = -1,
};
pub const BulletStyle_None = BulletStyle.None;
pub const BulletStyle_HollowRoundBullet = BulletStyle.HollowRoundBullet;
pub const BulletStyle_FilledRoundBullet = BulletStyle.FilledRoundBullet;
pub const BulletStyle_HollowSquareBullet = BulletStyle.HollowSquareBullet;
pub const BulletStyle_FilledSquareBullet = BulletStyle.FilledSquareBullet;
pub const BulletStyle_DashBullet = BulletStyle.DashBullet;
pub const BulletStyle_Other = BulletStyle.Other;

pub const CapStyle = enum(i32) {
    None = 0,
    SmallCap = 1,
    AllCap = 2,
    AllPetiteCaps = 3,
    PetiteCaps = 4,
    Unicase = 5,
    Titling = 6,
    Other = -1,
};
pub const CapStyle_None = CapStyle.None;
pub const CapStyle_SmallCap = CapStyle.SmallCap;
pub const CapStyle_AllCap = CapStyle.AllCap;
pub const CapStyle_AllPetiteCaps = CapStyle.AllPetiteCaps;
pub const CapStyle_PetiteCaps = CapStyle.PetiteCaps;
pub const CapStyle_Unicase = CapStyle.Unicase;
pub const CapStyle_Titling = CapStyle.Titling;
pub const CapStyle_Other = CapStyle.Other;

pub const FillType = enum(i32) {
    None = 0,
    Color = 1,
    Gradient = 2,
    Picture = 3,
    Pattern = 4,
};
pub const FillType_None = FillType.None;
pub const FillType_Color = FillType.Color;
pub const FillType_Gradient = FillType.Gradient;
pub const FillType_Picture = FillType.Picture;
pub const FillType_Pattern = FillType.Pattern;

pub const FlowDirections = enum(i32) {
    Default = 0,
    RightToLeft = 1,
    BottomToTop = 2,
    Vertical = 4,
};
pub const FlowDirections_Default = FlowDirections.Default;
pub const FlowDirections_RightToLeft = FlowDirections.RightToLeft;
pub const FlowDirections_BottomToTop = FlowDirections.BottomToTop;
pub const FlowDirections_Vertical = FlowDirections.Vertical;

pub const HorizontalTextAlignment = enum(i32) {
    Left = 0,
    Centered = 1,
    Right = 2,
    Justified = 3,
};
pub const HorizontalTextAlignment_Left = HorizontalTextAlignment.Left;
pub const HorizontalTextAlignment_Centered = HorizontalTextAlignment.Centered;
pub const HorizontalTextAlignment_Right = HorizontalTextAlignment.Right;
pub const HorizontalTextAlignment_Justified = HorizontalTextAlignment.Justified;

pub const OutlineStyles = enum(i32) {
    None = 0,
    Outline = 1,
    Shadow = 2,
    Engraved = 4,
    Embossed = 8,
};
pub const OutlineStyles_None = OutlineStyles.None;
pub const OutlineStyles_Outline = OutlineStyles.Outline;
pub const OutlineStyles_Shadow = OutlineStyles.Shadow;
pub const OutlineStyles_Engraved = OutlineStyles.Engraved;
pub const OutlineStyles_Embossed = OutlineStyles.Embossed;

pub const TextDecorationLineStyle = enum(i32) {
    None = 0,
    Single = 1,
    WordsOnly = 2,
    Double = 3,
    Dot = 4,
    Dash = 5,
    DashDot = 6,
    DashDotDot = 7,
    Wavy = 8,
    ThickSingle = 9,
    DoubleWavy = 11,
    ThickWavy = 12,
    LongDash = 13,
    ThickDash = 14,
    ThickDashDot = 15,
    ThickDashDotDot = 16,
    ThickDot = 17,
    ThickLongDash = 18,
    Other = -1,
};
pub const TextDecorationLineStyle_None = TextDecorationLineStyle.None;
pub const TextDecorationLineStyle_Single = TextDecorationLineStyle.Single;
pub const TextDecorationLineStyle_WordsOnly = TextDecorationLineStyle.WordsOnly;
pub const TextDecorationLineStyle_Double = TextDecorationLineStyle.Double;
pub const TextDecorationLineStyle_Dot = TextDecorationLineStyle.Dot;
pub const TextDecorationLineStyle_Dash = TextDecorationLineStyle.Dash;
pub const TextDecorationLineStyle_DashDot = TextDecorationLineStyle.DashDot;
pub const TextDecorationLineStyle_DashDotDot = TextDecorationLineStyle.DashDotDot;
pub const TextDecorationLineStyle_Wavy = TextDecorationLineStyle.Wavy;
pub const TextDecorationLineStyle_ThickSingle = TextDecorationLineStyle.ThickSingle;
pub const TextDecorationLineStyle_DoubleWavy = TextDecorationLineStyle.DoubleWavy;
pub const TextDecorationLineStyle_ThickWavy = TextDecorationLineStyle.ThickWavy;
pub const TextDecorationLineStyle_LongDash = TextDecorationLineStyle.LongDash;
pub const TextDecorationLineStyle_ThickDash = TextDecorationLineStyle.ThickDash;
pub const TextDecorationLineStyle_ThickDashDot = TextDecorationLineStyle.ThickDashDot;
pub const TextDecorationLineStyle_ThickDashDotDot = TextDecorationLineStyle.ThickDashDotDot;
pub const TextDecorationLineStyle_ThickDot = TextDecorationLineStyle.ThickDot;
pub const TextDecorationLineStyle_ThickLongDash = TextDecorationLineStyle.ThickLongDash;
pub const TextDecorationLineStyle_Other = TextDecorationLineStyle.Other;

pub const VisualEffects = enum(i32) {
    None = 0,
    Shadow = 1,
    Reflection = 2,
    Glow = 4,
    SoftEdges = 8,
    Bevel = 16,
};
pub const VisualEffects_None = VisualEffects.None;
pub const VisualEffects_Shadow = VisualEffects.Shadow;
pub const VisualEffects_Reflection = VisualEffects.Reflection;
pub const VisualEffects_Glow = VisualEffects.Glow;
pub const VisualEffects_SoftEdges = VisualEffects.SoftEdges;
pub const VisualEffects_Bevel = VisualEffects.Bevel;

pub const NotificationProcessing = enum(i32) {
    ImportantAll = 0,
    ImportantMostRecent = 1,
    All = 2,
    MostRecent = 3,
    CurrentThenMostRecent = 4,
};
pub const NotificationProcessing_ImportantAll = NotificationProcessing.ImportantAll;
pub const NotificationProcessing_ImportantMostRecent = NotificationProcessing.ImportantMostRecent;
pub const NotificationProcessing_All = NotificationProcessing.All;
pub const NotificationProcessing_MostRecent = NotificationProcessing.MostRecent;
pub const NotificationProcessing_CurrentThenMostRecent = NotificationProcessing.CurrentThenMostRecent;

pub const NotificationKind = enum(i32) {
    ItemAdded = 0,
    ItemRemoved = 1,
    ActionCompleted = 2,
    ActionAborted = 3,
    Other = 4,
};
pub const NotificationKind_ItemAdded = NotificationKind.ItemAdded;
pub const NotificationKind_ItemRemoved = NotificationKind.ItemRemoved;
pub const NotificationKind_ActionCompleted = NotificationKind.ActionCompleted;
pub const NotificationKind_ActionAborted = NotificationKind.ActionAborted;
pub const NotificationKind_Other = NotificationKind.Other;

pub const UiaRect = extern struct {
    left: f64,
    top: f64,
    width: f64,
    height: f64,
};

pub const UiaPoint = extern struct {
    x: f64,
    y: f64,
};

pub const UiaChangeInfo = extern struct {
    uiaId: i32,
    payload: VARIANT,
    extraInfo: VARIANT,
};

pub const UIAutomationType = enum(i32) {
    Int = 1,
    Bool = 2,
    String = 3,
    Double = 4,
    Point = 5,
    Rect = 6,
    Element = 7,
    Array = 65536,
    Out = 131072,
    IntArray = 65537,
    BoolArray = 65538,
    StringArray = 65539,
    DoubleArray = 65540,
    PointArray = 65541,
    RectArray = 65542,
    ElementArray = 65543,
    OutInt = 131073,
    OutBool = 131074,
    OutString = 131075,
    OutDouble = 131076,
    OutPoint = 131077,
    OutRect = 131078,
    OutElement = 131079,
    OutIntArray = 196609,
    OutBoolArray = 196610,
    OutStringArray = 196611,
    OutDoubleArray = 196612,
    OutPointArray = 196613,
    OutRectArray = 196614,
    OutElementArray = 196615,
};
pub const UIAutomationType_Int = UIAutomationType.Int;
pub const UIAutomationType_Bool = UIAutomationType.Bool;
pub const UIAutomationType_String = UIAutomationType.String;
pub const UIAutomationType_Double = UIAutomationType.Double;
pub const UIAutomationType_Point = UIAutomationType.Point;
pub const UIAutomationType_Rect = UIAutomationType.Rect;
pub const UIAutomationType_Element = UIAutomationType.Element;
pub const UIAutomationType_Array = UIAutomationType.Array;
pub const UIAutomationType_Out = UIAutomationType.Out;
pub const UIAutomationType_IntArray = UIAutomationType.IntArray;
pub const UIAutomationType_BoolArray = UIAutomationType.BoolArray;
pub const UIAutomationType_StringArray = UIAutomationType.StringArray;
pub const UIAutomationType_DoubleArray = UIAutomationType.DoubleArray;
pub const UIAutomationType_PointArray = UIAutomationType.PointArray;
pub const UIAutomationType_RectArray = UIAutomationType.RectArray;
pub const UIAutomationType_ElementArray = UIAutomationType.ElementArray;
pub const UIAutomationType_OutInt = UIAutomationType.OutInt;
pub const UIAutomationType_OutBool = UIAutomationType.OutBool;
pub const UIAutomationType_OutString = UIAutomationType.OutString;
pub const UIAutomationType_OutDouble = UIAutomationType.OutDouble;
pub const UIAutomationType_OutPoint = UIAutomationType.OutPoint;
pub const UIAutomationType_OutRect = UIAutomationType.OutRect;
pub const UIAutomationType_OutElement = UIAutomationType.OutElement;
pub const UIAutomationType_OutIntArray = UIAutomationType.OutIntArray;
pub const UIAutomationType_OutBoolArray = UIAutomationType.OutBoolArray;
pub const UIAutomationType_OutStringArray = UIAutomationType.OutStringArray;
pub const UIAutomationType_OutDoubleArray = UIAutomationType.OutDoubleArray;
pub const UIAutomationType_OutPointArray = UIAutomationType.OutPointArray;
pub const UIAutomationType_OutRectArray = UIAutomationType.OutRectArray;
pub const UIAutomationType_OutElementArray = UIAutomationType.OutElementArray;

pub const UIAutomationParameter = extern struct {
    type: UIAutomationType,
    pData: ?*anyopaque,
};

pub const UIAutomationPropertyInfo = extern struct {
    guid: Guid,
    pProgrammaticName: ?[*:0]const u16,
    type: UIAutomationType,
};

pub const UIAutomationEventInfo = extern struct {
    guid: Guid,
    pProgrammaticName: ?[*:0]const u16,
};

pub const UIAutomationMethodInfo = extern struct {
    pProgrammaticName: ?[*:0]const u16,
    doSetFocus: BOOL,
    cInParameters: u32,
    cOutParameters: u32,
    pParameterTypes: ?*UIAutomationType,
    pParameterNames: ?*?PWSTR,
};

pub const UIAutomationPatternInfo = extern struct {
    guid: Guid,
    pProgrammaticName: ?[*:0]const u16,
    providerInterfaceId: Guid,
    clientInterfaceId: Guid,
    cProperties: u32,
    pProperties: ?*UIAutomationPropertyInfo,
    cMethods: u32,
    pMethods: ?*UIAutomationMethodInfo,
    cEvents: u32,
    pEvents: ?*UIAutomationEventInfo,
    pPatternHandler: ?*IUIAutomationPatternHandler,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IRawElementProviderSimple_Value = Guid.initString("d6dd68d1-86fd-4332-8666-9abedea2d24c");
pub const IID_IRawElementProviderSimple = &IID_IRawElementProviderSimple_Value;
pub const IRawElementProviderSimple = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ProviderOptions: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IRawElementProviderSimple,
                pRetVal: ?*ProviderOptions,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IRawElementProviderSimple,
                pRetVal: ?*ProviderOptions,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPatternProvider: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRawElementProviderSimple,
                patternId: i32,
                pRetVal: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRawElementProviderSimple,
                patternId: i32,
                pRetVal: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPropertyValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRawElementProviderSimple,
                propertyId: i32,
                pRetVal: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRawElementProviderSimple,
                propertyId: i32,
                pRetVal: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HostRawElementProvider: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IRawElementProviderSimple,
                pRetVal: ?*?*IRawElementProviderSimple,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IRawElementProviderSimple,
                pRetVal: ?*?*IRawElementProviderSimple,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawElementProviderSimple_get_ProviderOptions(self: *const T, pRetVal: ?*ProviderOptions) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRawElementProviderSimple.VTable, self.vtable).get_ProviderOptions(@ptrCast(*const IRawElementProviderSimple, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawElementProviderSimple_GetPatternProvider(self: *const T, patternId: i32, pRetVal: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRawElementProviderSimple.VTable, self.vtable).GetPatternProvider(@ptrCast(*const IRawElementProviderSimple, self), patternId, pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawElementProviderSimple_GetPropertyValue(self: *const T, propertyId: i32, pRetVal: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRawElementProviderSimple.VTable, self.vtable).GetPropertyValue(@ptrCast(*const IRawElementProviderSimple, self), propertyId, pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawElementProviderSimple_get_HostRawElementProvider(self: *const T, pRetVal: ?*?*IRawElementProviderSimple) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRawElementProviderSimple.VTable, self.vtable).get_HostRawElementProvider(@ptrCast(*const IRawElementProviderSimple, self), pRetVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IAccessibleEx_Value = Guid.initString("f8b80ada-2c44-48d0-89be-5ff23c9cd875");
pub const IID_IAccessibleEx = &IID_IAccessibleEx_Value;
pub const IAccessibleEx = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetObjectForChild: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAccessibleEx,
                idChild: i32,
                pRetVal: ?*?*IAccessibleEx,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAccessibleEx,
                idChild: i32,
                pRetVal: ?*?*IAccessibleEx,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIAccessiblePair: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAccessibleEx,
                ppAcc: ?*?*IAccessible,
                pidChild: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAccessibleEx,
                ppAcc: ?*?*IAccessible,
                pidChild: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRuntimeId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAccessibleEx,
                pRetVal: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAccessibleEx,
                pRetVal: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ConvertReturnedElement: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAccessibleEx,
                pIn: ?*IRawElementProviderSimple,
                ppRetValOut: ?*?*IAccessibleEx,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAccessibleEx,
                pIn: ?*IRawElementProviderSimple,
                ppRetValOut: ?*?*IAccessibleEx,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccessibleEx_GetObjectForChild(self: *const T, idChild: i32, pRetVal: ?*?*IAccessibleEx) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccessibleEx.VTable, self.vtable).GetObjectForChild(@ptrCast(*const IAccessibleEx, self), idChild, pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccessibleEx_GetIAccessiblePair(self: *const T, ppAcc: ?*?*IAccessible, pidChild: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccessibleEx.VTable, self.vtable).GetIAccessiblePair(@ptrCast(*const IAccessibleEx, self), ppAcc, pidChild);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccessibleEx_GetRuntimeId(self: *const T, pRetVal: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccessibleEx.VTable, self.vtable).GetRuntimeId(@ptrCast(*const IAccessibleEx, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccessibleEx_ConvertReturnedElement(self: *const T, pIn: ?*IRawElementProviderSimple, ppRetValOut: ?*?*IAccessibleEx) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccessibleEx.VTable, self.vtable).ConvertReturnedElement(@ptrCast(*const IAccessibleEx, self), pIn, ppRetValOut);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.1'
const IID_IRawElementProviderSimple2_Value = Guid.initString("a0a839a9-8da1-4a82-806a-8e0d44e79f56");
pub const IID_IRawElementProviderSimple2 = &IID_IRawElementProviderSimple2_Value;
pub const IRawElementProviderSimple2 = extern struct {
    pub const VTable = extern struct {
        base: IRawElementProviderSimple.VTable,
        ShowContextMenu: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRawElementProviderSimple2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRawElementProviderSimple2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IRawElementProviderSimple.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawElementProviderSimple2_ShowContextMenu(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRawElementProviderSimple2.VTable, self.vtable).ShowContextMenu(@ptrCast(*const IRawElementProviderSimple2, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.15063'
const IID_IRawElementProviderSimple3_Value = Guid.initString("fcf5d820-d7ec-4613-bdf6-42a84ce7daaf");
pub const IID_IRawElementProviderSimple3 = &IID_IRawElementProviderSimple3_Value;
pub const IRawElementProviderSimple3 = extern struct {
    pub const VTable = extern struct {
        base: IRawElementProviderSimple2.VTable,
        GetMetadataValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRawElementProviderSimple3,
                targetId: i32,
                metadataId: i32,
                returnVal: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRawElementProviderSimple3,
                targetId: i32,
                metadataId: i32,
                returnVal: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IRawElementProviderSimple2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawElementProviderSimple3_GetMetadataValue(self: *const T, targetId: i32, metadataId: i32, returnVal: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRawElementProviderSimple3.VTable, self.vtable).GetMetadataValue(@ptrCast(*const IRawElementProviderSimple3, self), targetId, metadataId, returnVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IRawElementProviderFragmentRoot_Value = Guid.initString("620ce2a5-ab8f-40a9-86cb-de3c75599b58");
pub const IID_IRawElementProviderFragmentRoot = &IID_IRawElementProviderFragmentRoot_Value;
pub const IRawElementProviderFragmentRoot = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ElementProviderFromPoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRawElementProviderFragmentRoot,
                x: f64,
                y: f64,
                pRetVal: ?*?*IRawElementProviderFragment,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRawElementProviderFragmentRoot,
                x: f64,
                y: f64,
                pRetVal: ?*?*IRawElementProviderFragment,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFocus: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRawElementProviderFragmentRoot,
                pRetVal: ?*?*IRawElementProviderFragment,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRawElementProviderFragmentRoot,
                pRetVal: ?*?*IRawElementProviderFragment,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawElementProviderFragmentRoot_ElementProviderFromPoint(self: *const T, x: f64, y: f64, pRetVal: ?*?*IRawElementProviderFragment) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRawElementProviderFragmentRoot.VTable, self.vtable).ElementProviderFromPoint(@ptrCast(*const IRawElementProviderFragmentRoot, self), x, y, pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawElementProviderFragmentRoot_GetFocus(self: *const T, pRetVal: ?*?*IRawElementProviderFragment) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRawElementProviderFragmentRoot.VTable, self.vtable).GetFocus(@ptrCast(*const IRawElementProviderFragmentRoot, self), pRetVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IRawElementProviderFragment_Value = Guid.initString("f7063da8-8359-439c-9297-bbc5299a7d87");
pub const IID_IRawElementProviderFragment = &IID_IRawElementProviderFragment_Value;
pub const IRawElementProviderFragment = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Navigate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRawElementProviderFragment,
                direction: NavigateDirection,
                pRetVal: ?*?*IRawElementProviderFragment,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRawElementProviderFragment,
                direction: NavigateDirection,
                pRetVal: ?*?*IRawElementProviderFragment,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRuntimeId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRawElementProviderFragment,
                pRetVal: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRawElementProviderFragment,
                pRetVal: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BoundingRectangle: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IRawElementProviderFragment,
                pRetVal: ?*UiaRect,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IRawElementProviderFragment,
                pRetVal: ?*UiaRect,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEmbeddedFragmentRoots: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRawElementProviderFragment,
                pRetVal: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRawElementProviderFragment,
                pRetVal: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFocus: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRawElementProviderFragment,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRawElementProviderFragment,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FragmentRoot: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IRawElementProviderFragment,
                pRetVal: ?*?*IRawElementProviderFragmentRoot,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IRawElementProviderFragment,
                pRetVal: ?*?*IRawElementProviderFragmentRoot,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawElementProviderFragment_Navigate(self: *const T, direction: NavigateDirection, pRetVal: ?*?*IRawElementProviderFragment) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRawElementProviderFragment.VTable, self.vtable).Navigate(@ptrCast(*const IRawElementProviderFragment, self), direction, pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawElementProviderFragment_GetRuntimeId(self: *const T, pRetVal: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRawElementProviderFragment.VTable, self.vtable).GetRuntimeId(@ptrCast(*const IRawElementProviderFragment, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawElementProviderFragment_get_BoundingRectangle(self: *const T, pRetVal: ?*UiaRect) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRawElementProviderFragment.VTable, self.vtable).get_BoundingRectangle(@ptrCast(*const IRawElementProviderFragment, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawElementProviderFragment_GetEmbeddedFragmentRoots(self: *const T, pRetVal: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRawElementProviderFragment.VTable, self.vtable).GetEmbeddedFragmentRoots(@ptrCast(*const IRawElementProviderFragment, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawElementProviderFragment_SetFocus(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRawElementProviderFragment.VTable, self.vtable).SetFocus(@ptrCast(*const IRawElementProviderFragment, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawElementProviderFragment_get_FragmentRoot(self: *const T, pRetVal: ?*?*IRawElementProviderFragmentRoot) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRawElementProviderFragment.VTable, self.vtable).get_FragmentRoot(@ptrCast(*const IRawElementProviderFragment, self), pRetVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IRawElementProviderAdviseEvents_Value = Guid.initString("a407b27b-0f6d-4427-9292-473c7bf93258");
pub const IID_IRawElementProviderAdviseEvents = &IID_IRawElementProviderAdviseEvents_Value;
pub const IRawElementProviderAdviseEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AdviseEventAdded: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRawElementProviderAdviseEvents,
                eventId: i32,
                propertyIDs: ?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRawElementProviderAdviseEvents,
                eventId: i32,
                propertyIDs: ?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AdviseEventRemoved: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRawElementProviderAdviseEvents,
                eventId: i32,
                propertyIDs: ?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRawElementProviderAdviseEvents,
                eventId: i32,
                propertyIDs: ?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawElementProviderAdviseEvents_AdviseEventAdded(self: *const T, eventId: i32, propertyIDs: ?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRawElementProviderAdviseEvents.VTable, self.vtable).AdviseEventAdded(@ptrCast(*const IRawElementProviderAdviseEvents, self), eventId, propertyIDs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawElementProviderAdviseEvents_AdviseEventRemoved(self: *const T, eventId: i32, propertyIDs: ?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRawElementProviderAdviseEvents.VTable, self.vtable).AdviseEventRemoved(@ptrCast(*const IRawElementProviderAdviseEvents, self), eventId, propertyIDs);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IRawElementProviderHwndOverride_Value = Guid.initString("1d5df27c-8947-4425-b8d9-79787bb460b8");
pub const IID_IRawElementProviderHwndOverride = &IID_IRawElementProviderHwndOverride_Value;
pub const IRawElementProviderHwndOverride = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetOverrideProviderForHwnd: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRawElementProviderHwndOverride,
                hwnd: ?HWND,
                pRetVal: ?*?*IRawElementProviderSimple,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRawElementProviderHwndOverride,
                hwnd: ?HWND,
                pRetVal: ?*?*IRawElementProviderSimple,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawElementProviderHwndOverride_GetOverrideProviderForHwnd(self: *const T, hwnd: ?HWND, pRetVal: ?*?*IRawElementProviderSimple) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRawElementProviderHwndOverride.VTable, self.vtable).GetOverrideProviderForHwnd(@ptrCast(*const IRawElementProviderHwndOverride, self), hwnd, pRetVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IProxyProviderWinEventSink_Value = Guid.initString("4fd82b78-a43e-46ac-9803-0a6969c7c183");
pub const IID_IProxyProviderWinEventSink = &IID_IProxyProviderWinEventSink_Value;
pub const IProxyProviderWinEventSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddAutomationPropertyChangedEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IProxyProviderWinEventSink,
                pProvider: ?*IRawElementProviderSimple,
                id: i32,
                newValue: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IProxyProviderWinEventSink,
                pProvider: ?*IRawElementProviderSimple,
                id: i32,
                newValue: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddAutomationEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IProxyProviderWinEventSink,
                pProvider: ?*IRawElementProviderSimple,
                id: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IProxyProviderWinEventSink,
                pProvider: ?*IRawElementProviderSimple,
                id: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddStructureChangedEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IProxyProviderWinEventSink,
                pProvider: ?*IRawElementProviderSimple,
                structureChangeType: StructureChangeType,
                runtimeId: ?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IProxyProviderWinEventSink,
                pProvider: ?*IRawElementProviderSimple,
                structureChangeType: StructureChangeType,
                runtimeId: ?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProxyProviderWinEventSink_AddAutomationPropertyChangedEvent(self: *const T, pProvider: ?*IRawElementProviderSimple, id: i32, newValue: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProxyProviderWinEventSink.VTable, self.vtable).AddAutomationPropertyChangedEvent(@ptrCast(*const IProxyProviderWinEventSink, self), pProvider, id, newValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProxyProviderWinEventSink_AddAutomationEvent(self: *const T, pProvider: ?*IRawElementProviderSimple, id: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProxyProviderWinEventSink.VTable, self.vtable).AddAutomationEvent(@ptrCast(*const IProxyProviderWinEventSink, self), pProvider, id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProxyProviderWinEventSink_AddStructureChangedEvent(self: *const T, pProvider: ?*IRawElementProviderSimple, structureChangeType: StructureChangeType, runtimeId: ?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProxyProviderWinEventSink.VTable, self.vtable).AddStructureChangedEvent(@ptrCast(*const IProxyProviderWinEventSink, self), pProvider, structureChangeType, runtimeId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IProxyProviderWinEventHandler_Value = Guid.initString("89592ad4-f4e0-43d5-a3b6-bad7e111b435");
pub const IID_IProxyProviderWinEventHandler = &IID_IProxyProviderWinEventHandler_Value;
pub const IProxyProviderWinEventHandler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RespondToWinEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IProxyProviderWinEventHandler,
                idWinEvent: u32,
                hwnd: ?HWND,
                idObject: i32,
                idChild: i32,
                pSink: ?*IProxyProviderWinEventSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IProxyProviderWinEventHandler,
                idWinEvent: u32,
                hwnd: ?HWND,
                idObject: i32,
                idChild: i32,
                pSink: ?*IProxyProviderWinEventSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProxyProviderWinEventHandler_RespondToWinEvent(self: *const T, idWinEvent: u32, hwnd: ?HWND, idObject: i32, idChild: i32, pSink: ?*IProxyProviderWinEventSink) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProxyProviderWinEventHandler.VTable, self.vtable).RespondToWinEvent(@ptrCast(*const IProxyProviderWinEventHandler, self), idWinEvent, hwnd, idObject, idChild, pSink);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IRawElementProviderWindowlessSite_Value = Guid.initString("0a2a93cc-bfad-42ac-9b2e-0991fb0d3ea0");
pub const IID_IRawElementProviderWindowlessSite = &IID_IRawElementProviderWindowlessSite_Value;
pub const IRawElementProviderWindowlessSite = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetAdjacentFragment: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRawElementProviderWindowlessSite,
                direction: NavigateDirection,
                ppParent: ?*?*IRawElementProviderFragment,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRawElementProviderWindowlessSite,
                direction: NavigateDirection,
                ppParent: ?*?*IRawElementProviderFragment,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRuntimeIdPrefix: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRawElementProviderWindowlessSite,
                pRetVal: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRawElementProviderWindowlessSite,
                pRetVal: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawElementProviderWindowlessSite_GetAdjacentFragment(self: *const T, direction: NavigateDirection, ppParent: ?*?*IRawElementProviderFragment) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRawElementProviderWindowlessSite.VTable, self.vtable).GetAdjacentFragment(@ptrCast(*const IRawElementProviderWindowlessSite, self), direction, ppParent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawElementProviderWindowlessSite_GetRuntimeIdPrefix(self: *const T, pRetVal: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRawElementProviderWindowlessSite.VTable, self.vtable).GetRuntimeIdPrefix(@ptrCast(*const IRawElementProviderWindowlessSite, self), pRetVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IAccessibleHostingElementProviders_Value = Guid.initString("33ac331b-943e-4020-b295-db37784974a3");
pub const IID_IAccessibleHostingElementProviders = &IID_IAccessibleHostingElementProviders_Value;
pub const IAccessibleHostingElementProviders = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetEmbeddedFragmentRoots: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAccessibleHostingElementProviders,
                pRetVal: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAccessibleHostingElementProviders,
                pRetVal: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetObjectIdForProvider: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAccessibleHostingElementProviders,
                pProvider: ?*IRawElementProviderSimple,
                pidObject: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAccessibleHostingElementProviders,
                pProvider: ?*IRawElementProviderSimple,
                pidObject: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccessibleHostingElementProviders_GetEmbeddedFragmentRoots(self: *const T, pRetVal: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccessibleHostingElementProviders.VTable, self.vtable).GetEmbeddedFragmentRoots(@ptrCast(*const IAccessibleHostingElementProviders, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccessibleHostingElementProviders_GetObjectIdForProvider(self: *const T, pProvider: ?*IRawElementProviderSimple, pidObject: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccessibleHostingElementProviders.VTable, self.vtable).GetObjectIdForProvider(@ptrCast(*const IAccessibleHostingElementProviders, self), pProvider, pidObject);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IRawElementProviderHostingAccessibles_Value = Guid.initString("24be0b07-d37d-487a-98cf-a13ed465e9b3");
pub const IID_IRawElementProviderHostingAccessibles = &IID_IRawElementProviderHostingAccessibles_Value;
pub const IRawElementProviderHostingAccessibles = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetEmbeddedAccessibles: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRawElementProviderHostingAccessibles,
                pRetVal: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRawElementProviderHostingAccessibles,
                pRetVal: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawElementProviderHostingAccessibles_GetEmbeddedAccessibles(self: *const T, pRetVal: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRawElementProviderHostingAccessibles.VTable, self.vtable).GetEmbeddedAccessibles(@ptrCast(*const IRawElementProviderHostingAccessibles, self), pRetVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IDockProvider_Value = Guid.initString("159bc72c-4ad3-485e-9637-d7052edf0146");
pub const IID_IDockProvider = &IID_IDockProvider_Value;
pub const IDockProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetDockPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDockProvider,
                dockPosition: DockPosition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDockProvider,
                dockPosition: DockPosition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DockPosition: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDockProvider,
                pRetVal: ?*DockPosition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDockProvider,
                pRetVal: ?*DockPosition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDockProvider_SetDockPosition(self: *const T, dockPosition: DockPosition) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDockProvider.VTable, self.vtable).SetDockPosition(@ptrCast(*const IDockProvider, self), dockPosition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDockProvider_get_DockPosition(self: *const T, pRetVal: ?*DockPosition) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDockProvider.VTable, self.vtable).get_DockPosition(@ptrCast(*const IDockProvider, self), pRetVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IExpandCollapseProvider_Value = Guid.initString("d847d3a5-cab0-4a98-8c32-ecb45c59ad24");
pub const IID_IExpandCollapseProvider = &IID_IExpandCollapseProvider_Value;
pub const IExpandCollapseProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Expand: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IExpandCollapseProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IExpandCollapseProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Collapse: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IExpandCollapseProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IExpandCollapseProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ExpandCollapseState: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IExpandCollapseProvider,
                pRetVal: ?*ExpandCollapseState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IExpandCollapseProvider,
                pRetVal: ?*ExpandCollapseState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExpandCollapseProvider_Expand(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExpandCollapseProvider.VTable, self.vtable).Expand(@ptrCast(*const IExpandCollapseProvider, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExpandCollapseProvider_Collapse(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExpandCollapseProvider.VTable, self.vtable).Collapse(@ptrCast(*const IExpandCollapseProvider, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExpandCollapseProvider_get_ExpandCollapseState(self: *const T, pRetVal: ?*ExpandCollapseState) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExpandCollapseProvider.VTable, self.vtable).get_ExpandCollapseState(@ptrCast(*const IExpandCollapseProvider, self), pRetVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IGridProvider_Value = Guid.initString("b17d6187-0907-464b-a168-0ef17a1572b1");
pub const IID_IGridProvider = &IID_IGridProvider_Value;
pub const IGridProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGridProvider,
                row: i32,
                column: i32,
                pRetVal: ?*?*IRawElementProviderSimple,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IGridProvider,
                row: i32,
                column: i32,
                pRetVal: ?*?*IRawElementProviderSimple,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RowCount: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IGridProvider,
                pRetVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IGridProvider,
                pRetVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ColumnCount: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IGridProvider,
                pRetVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IGridProvider,
                pRetVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGridProvider_GetItem(self: *const T, row: i32, column: i32, pRetVal: ?*?*IRawElementProviderSimple) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGridProvider.VTable, self.vtable).GetItem(@ptrCast(*const IGridProvider, self), row, column, pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGridProvider_get_RowCount(self: *const T, pRetVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGridProvider.VTable, self.vtable).get_RowCount(@ptrCast(*const IGridProvider, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGridProvider_get_ColumnCount(self: *const T, pRetVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGridProvider.VTable, self.vtable).get_ColumnCount(@ptrCast(*const IGridProvider, self), pRetVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IGridItemProvider_Value = Guid.initString("d02541f1-fb81-4d64-ae32-f520f8a6dbd1");
pub const IID_IGridItemProvider = &IID_IGridItemProvider_Value;
pub const IGridItemProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Row: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IGridItemProvider,
                pRetVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IGridItemProvider,
                pRetVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Column: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IGridItemProvider,
                pRetVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IGridItemProvider,
                pRetVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RowSpan: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IGridItemProvider,
                pRetVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IGridItemProvider,
                pRetVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ColumnSpan: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IGridItemProvider,
                pRetVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IGridItemProvider,
                pRetVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ContainingGrid: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IGridItemProvider,
                pRetVal: ?*?*IRawElementProviderSimple,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IGridItemProvider,
                pRetVal: ?*?*IRawElementProviderSimple,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGridItemProvider_get_Row(self: *const T, pRetVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGridItemProvider.VTable, self.vtable).get_Row(@ptrCast(*const IGridItemProvider, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGridItemProvider_get_Column(self: *const T, pRetVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGridItemProvider.VTable, self.vtable).get_Column(@ptrCast(*const IGridItemProvider, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGridItemProvider_get_RowSpan(self: *const T, pRetVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGridItemProvider.VTable, self.vtable).get_RowSpan(@ptrCast(*const IGridItemProvider, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGridItemProvider_get_ColumnSpan(self: *const T, pRetVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGridItemProvider.VTable, self.vtable).get_ColumnSpan(@ptrCast(*const IGridItemProvider, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGridItemProvider_get_ContainingGrid(self: *const T, pRetVal: ?*?*IRawElementProviderSimple) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGridItemProvider.VTable, self.vtable).get_ContainingGrid(@ptrCast(*const IGridItemProvider, self), pRetVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IInvokeProvider_Value = Guid.initString("54fcb24b-e18e-47a2-b4d3-eccbe77599a2");
pub const IID_IInvokeProvider = &IID_IInvokeProvider_Value;
pub const IInvokeProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Invoke: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IInvokeProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IInvokeProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInvokeProvider_Invoke(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInvokeProvider.VTable, self.vtable).Invoke(@ptrCast(*const IInvokeProvider, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMultipleViewProvider_Value = Guid.initString("6278cab1-b556-4a1a-b4e0-418acc523201");
pub const IID_IMultipleViewProvider = &IID_IMultipleViewProvider_Value;
pub const IMultipleViewProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetViewName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMultipleViewProvider,
                viewId: i32,
                pRetVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMultipleViewProvider,
                viewId: i32,
                pRetVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCurrentView: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMultipleViewProvider,
                viewId: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMultipleViewProvider,
                viewId: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentView: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMultipleViewProvider,
                pRetVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMultipleViewProvider,
                pRetVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSupportedViews: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMultipleViewProvider,
                pRetVal: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMultipleViewProvider,
                pRetVal: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMultipleViewProvider_GetViewName(self: *const T, viewId: i32, pRetVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMultipleViewProvider.VTable, self.vtable).GetViewName(@ptrCast(*const IMultipleViewProvider, self), viewId, pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMultipleViewProvider_SetCurrentView(self: *const T, viewId: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMultipleViewProvider.VTable, self.vtable).SetCurrentView(@ptrCast(*const IMultipleViewProvider, self), viewId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMultipleViewProvider_get_CurrentView(self: *const T, pRetVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMultipleViewProvider.VTable, self.vtable).get_CurrentView(@ptrCast(*const IMultipleViewProvider, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMultipleViewProvider_GetSupportedViews(self: *const T, pRetVal: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMultipleViewProvider.VTable, self.vtable).GetSupportedViews(@ptrCast(*const IMultipleViewProvider, self), pRetVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IRangeValueProvider_Value = Guid.initString("36dc7aef-33e6-4691-afe1-2be7274b3d33");
pub const IID_IRangeValueProvider = &IID_IRangeValueProvider_Value;
pub const IRangeValueProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRangeValueProvider,
                val: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRangeValueProvider,
                val: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Value: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IRangeValueProvider,
                pRetVal: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IRangeValueProvider,
                pRetVal: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsReadOnly: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IRangeValueProvider,
                pRetVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IRangeValueProvider,
                pRetVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Maximum: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IRangeValueProvider,
                pRetVal: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IRangeValueProvider,
                pRetVal: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Minimum: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IRangeValueProvider,
                pRetVal: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IRangeValueProvider,
                pRetVal: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LargeChange: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IRangeValueProvider,
                pRetVal: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IRangeValueProvider,
                pRetVal: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SmallChange: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IRangeValueProvider,
                pRetVal: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IRangeValueProvider,
                pRetVal: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRangeValueProvider_SetValue(self: *const T, val: f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRangeValueProvider.VTable, self.vtable).SetValue(@ptrCast(*const IRangeValueProvider, self), val);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRangeValueProvider_get_Value(self: *const T, pRetVal: ?*f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRangeValueProvider.VTable, self.vtable).get_Value(@ptrCast(*const IRangeValueProvider, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRangeValueProvider_get_IsReadOnly(self: *const T, pRetVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRangeValueProvider.VTable, self.vtable).get_IsReadOnly(@ptrCast(*const IRangeValueProvider, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRangeValueProvider_get_Maximum(self: *const T, pRetVal: ?*f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRangeValueProvider.VTable, self.vtable).get_Maximum(@ptrCast(*const IRangeValueProvider, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRangeValueProvider_get_Minimum(self: *const T, pRetVal: ?*f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRangeValueProvider.VTable, self.vtable).get_Minimum(@ptrCast(*const IRangeValueProvider, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRangeValueProvider_get_LargeChange(self: *const T, pRetVal: ?*f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRangeValueProvider.VTable, self.vtable).get_LargeChange(@ptrCast(*const IRangeValueProvider, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRangeValueProvider_get_SmallChange(self: *const T, pRetVal: ?*f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRangeValueProvider.VTable, self.vtable).get_SmallChange(@ptrCast(*const IRangeValueProvider, self), pRetVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IScrollItemProvider_Value = Guid.initString("2360c714-4bf1-4b26-ba65-9b21316127eb");
pub const IID_IScrollItemProvider = &IID_IScrollItemProvider_Value;
pub const IScrollItemProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ScrollIntoView: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IScrollItemProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IScrollItemProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScrollItemProvider_ScrollIntoView(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScrollItemProvider.VTable, self.vtable).ScrollIntoView(@ptrCast(*const IScrollItemProvider, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ISelectionProvider_Value = Guid.initString("fb8b03af-3bdf-48d4-bd36-1a65793be168");
pub const IID_ISelectionProvider = &IID_ISelectionProvider_Value;
pub const ISelectionProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSelection: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISelectionProvider,
                pRetVal: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISelectionProvider,
                pRetVal: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CanSelectMultiple: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISelectionProvider,
                pRetVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISelectionProvider,
                pRetVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsSelectionRequired: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISelectionProvider,
                pRetVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISelectionProvider,
                pRetVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISelectionProvider_GetSelection(self: *const T, pRetVal: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISelectionProvider.VTable, self.vtable).GetSelection(@ptrCast(*const ISelectionProvider, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISelectionProvider_get_CanSelectMultiple(self: *const T, pRetVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISelectionProvider.VTable, self.vtable).get_CanSelectMultiple(@ptrCast(*const ISelectionProvider, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISelectionProvider_get_IsSelectionRequired(self: *const T, pRetVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISelectionProvider.VTable, self.vtable).get_IsSelectionRequired(@ptrCast(*const ISelectionProvider, self), pRetVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.16299'
const IID_ISelectionProvider2_Value = Guid.initString("14f68475-ee1c-44f6-a869-d239381f0fe7");
pub const IID_ISelectionProvider2 = &IID_ISelectionProvider2_Value;
pub const ISelectionProvider2 = extern struct {
    pub const VTable = extern struct {
        base: ISelectionProvider.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FirstSelectedItem: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISelectionProvider2,
                retVal: ?*?*IRawElementProviderSimple,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISelectionProvider2,
                retVal: ?*?*IRawElementProviderSimple,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LastSelectedItem: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISelectionProvider2,
                retVal: ?*?*IRawElementProviderSimple,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISelectionProvider2,
                retVal: ?*?*IRawElementProviderSimple,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentSelectedItem: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISelectionProvider2,
                retVal: ?*?*IRawElementProviderSimple,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISelectionProvider2,
                retVal: ?*?*IRawElementProviderSimple,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ItemCount: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISelectionProvider2,
                retVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISelectionProvider2,
                retVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISelectionProvider.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISelectionProvider2_get_FirstSelectedItem(self: *const T, retVal: ?*?*IRawElementProviderSimple) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISelectionProvider2.VTable, self.vtable).get_FirstSelectedItem(@ptrCast(*const ISelectionProvider2, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISelectionProvider2_get_LastSelectedItem(self: *const T, retVal: ?*?*IRawElementProviderSimple) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISelectionProvider2.VTable, self.vtable).get_LastSelectedItem(@ptrCast(*const ISelectionProvider2, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISelectionProvider2_get_CurrentSelectedItem(self: *const T, retVal: ?*?*IRawElementProviderSimple) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISelectionProvider2.VTable, self.vtable).get_CurrentSelectedItem(@ptrCast(*const ISelectionProvider2, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISelectionProvider2_get_ItemCount(self: *const T, retVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISelectionProvider2.VTable, self.vtable).get_ItemCount(@ptrCast(*const ISelectionProvider2, self), retVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IScrollProvider_Value = Guid.initString("b38b8077-1fc3-42a5-8cae-d40c2215055a");
pub const IID_IScrollProvider = &IID_IScrollProvider_Value;
pub const IScrollProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Scroll: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IScrollProvider,
                horizontalAmount: ScrollAmount,
                verticalAmount: ScrollAmount,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IScrollProvider,
                horizontalAmount: ScrollAmount,
                verticalAmount: ScrollAmount,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetScrollPercent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IScrollProvider,
                horizontalPercent: f64,
                verticalPercent: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IScrollProvider,
                horizontalPercent: f64,
                verticalPercent: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HorizontalScrollPercent: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IScrollProvider,
                pRetVal: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IScrollProvider,
                pRetVal: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_VerticalScrollPercent: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IScrollProvider,
                pRetVal: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IScrollProvider,
                pRetVal: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HorizontalViewSize: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IScrollProvider,
                pRetVal: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IScrollProvider,
                pRetVal: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_VerticalViewSize: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IScrollProvider,
                pRetVal: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IScrollProvider,
                pRetVal: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HorizontallyScrollable: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IScrollProvider,
                pRetVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IScrollProvider,
                pRetVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_VerticallyScrollable: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IScrollProvider,
                pRetVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IScrollProvider,
                pRetVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScrollProvider_Scroll(self: *const T, horizontalAmount: ScrollAmount, verticalAmount: ScrollAmount) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScrollProvider.VTable, self.vtable).Scroll(@ptrCast(*const IScrollProvider, self), horizontalAmount, verticalAmount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScrollProvider_SetScrollPercent(self: *const T, horizontalPercent: f64, verticalPercent: f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScrollProvider.VTable, self.vtable).SetScrollPercent(@ptrCast(*const IScrollProvider, self), horizontalPercent, verticalPercent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScrollProvider_get_HorizontalScrollPercent(self: *const T, pRetVal: ?*f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScrollProvider.VTable, self.vtable).get_HorizontalScrollPercent(@ptrCast(*const IScrollProvider, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScrollProvider_get_VerticalScrollPercent(self: *const T, pRetVal: ?*f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScrollProvider.VTable, self.vtable).get_VerticalScrollPercent(@ptrCast(*const IScrollProvider, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScrollProvider_get_HorizontalViewSize(self: *const T, pRetVal: ?*f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScrollProvider.VTable, self.vtable).get_HorizontalViewSize(@ptrCast(*const IScrollProvider, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScrollProvider_get_VerticalViewSize(self: *const T, pRetVal: ?*f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScrollProvider.VTable, self.vtable).get_VerticalViewSize(@ptrCast(*const IScrollProvider, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScrollProvider_get_HorizontallyScrollable(self: *const T, pRetVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScrollProvider.VTable, self.vtable).get_HorizontallyScrollable(@ptrCast(*const IScrollProvider, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScrollProvider_get_VerticallyScrollable(self: *const T, pRetVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScrollProvider.VTable, self.vtable).get_VerticallyScrollable(@ptrCast(*const IScrollProvider, self), pRetVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ISelectionItemProvider_Value = Guid.initString("2acad808-b2d4-452d-a407-91ff1ad167b2");
pub const IID_ISelectionItemProvider = &IID_ISelectionItemProvider_Value;
pub const ISelectionItemProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Select: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISelectionItemProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISelectionItemProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddToSelection: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISelectionItemProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISelectionItemProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveFromSelection: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISelectionItemProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISelectionItemProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsSelected: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISelectionItemProvider,
                pRetVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISelectionItemProvider,
                pRetVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SelectionContainer: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISelectionItemProvider,
                pRetVal: ?*?*IRawElementProviderSimple,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISelectionItemProvider,
                pRetVal: ?*?*IRawElementProviderSimple,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISelectionItemProvider_Select(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISelectionItemProvider.VTable, self.vtable).Select(@ptrCast(*const ISelectionItemProvider, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISelectionItemProvider_AddToSelection(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISelectionItemProvider.VTable, self.vtable).AddToSelection(@ptrCast(*const ISelectionItemProvider, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISelectionItemProvider_RemoveFromSelection(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISelectionItemProvider.VTable, self.vtable).RemoveFromSelection(@ptrCast(*const ISelectionItemProvider, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISelectionItemProvider_get_IsSelected(self: *const T, pRetVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISelectionItemProvider.VTable, self.vtable).get_IsSelected(@ptrCast(*const ISelectionItemProvider, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISelectionItemProvider_get_SelectionContainer(self: *const T, pRetVal: ?*?*IRawElementProviderSimple) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISelectionItemProvider.VTable, self.vtable).get_SelectionContainer(@ptrCast(*const ISelectionItemProvider, self), pRetVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ISynchronizedInputProvider_Value = Guid.initString("29db1a06-02ce-4cf7-9b42-565d4fab20ee");
pub const IID_ISynchronizedInputProvider = &IID_ISynchronizedInputProvider_Value;
pub const ISynchronizedInputProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        StartListening: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISynchronizedInputProvider,
                inputType: SynchronizedInputType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISynchronizedInputProvider,
                inputType: SynchronizedInputType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Cancel: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISynchronizedInputProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISynchronizedInputProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISynchronizedInputProvider_StartListening(self: *const T, inputType: SynchronizedInputType) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISynchronizedInputProvider.VTable, self.vtable).StartListening(@ptrCast(*const ISynchronizedInputProvider, self), inputType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISynchronizedInputProvider_Cancel(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISynchronizedInputProvider.VTable, self.vtable).Cancel(@ptrCast(*const ISynchronizedInputProvider, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ITableProvider_Value = Guid.initString("9c860395-97b3-490a-b52a-858cc22af166");
pub const IID_ITableProvider = &IID_ITableProvider_Value;
pub const ITableProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetRowHeaders: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITableProvider,
                pRetVal: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITableProvider,
                pRetVal: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetColumnHeaders: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITableProvider,
                pRetVal: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITableProvider,
                pRetVal: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RowOrColumnMajor: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITableProvider,
                pRetVal: ?*RowOrColumnMajor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITableProvider,
                pRetVal: ?*RowOrColumnMajor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITableProvider_GetRowHeaders(self: *const T, pRetVal: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITableProvider.VTable, self.vtable).GetRowHeaders(@ptrCast(*const ITableProvider, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITableProvider_GetColumnHeaders(self: *const T, pRetVal: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITableProvider.VTable, self.vtable).GetColumnHeaders(@ptrCast(*const ITableProvider, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITableProvider_get_RowOrColumnMajor(self: *const T, pRetVal: ?*RowOrColumnMajor) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITableProvider.VTable, self.vtable).get_RowOrColumnMajor(@ptrCast(*const ITableProvider, self), pRetVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ITableItemProvider_Value = Guid.initString("b9734fa6-771f-4d78-9c90-2517999349cd");
pub const IID_ITableItemProvider = &IID_ITableItemProvider_Value;
pub const ITableItemProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetRowHeaderItems: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITableItemProvider,
                pRetVal: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITableItemProvider,
                pRetVal: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetColumnHeaderItems: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITableItemProvider,
                pRetVal: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITableItemProvider,
                pRetVal: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITableItemProvider_GetRowHeaderItems(self: *const T, pRetVal: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITableItemProvider.VTable, self.vtable).GetRowHeaderItems(@ptrCast(*const ITableItemProvider, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITableItemProvider_GetColumnHeaderItems(self: *const T, pRetVal: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITableItemProvider.VTable, self.vtable).GetColumnHeaderItems(@ptrCast(*const ITableItemProvider, self), pRetVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IToggleProvider_Value = Guid.initString("56d00bd0-c4f4-433c-a836-1a52a57e0892");
pub const IID_IToggleProvider = &IID_IToggleProvider_Value;
pub const IToggleProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Toggle: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IToggleProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IToggleProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ToggleState: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IToggleProvider,
                pRetVal: ?*ToggleState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IToggleProvider,
                pRetVal: ?*ToggleState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IToggleProvider_Toggle(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IToggleProvider.VTable, self.vtable).Toggle(@ptrCast(*const IToggleProvider, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IToggleProvider_get_ToggleState(self: *const T, pRetVal: ?*ToggleState) callconv(.Inline) HRESULT {
            return @ptrCast(*const IToggleProvider.VTable, self.vtable).get_ToggleState(@ptrCast(*const IToggleProvider, self), pRetVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ITransformProvider_Value = Guid.initString("6829ddc4-4f91-4ffa-b86f-bd3e2987cb4c");
pub const IID_ITransformProvider = &IID_ITransformProvider_Value;
pub const ITransformProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Move: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITransformProvider,
                x: f64,
                y: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITransformProvider,
                x: f64,
                y: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Resize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITransformProvider,
                width: f64,
                height: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITransformProvider,
                width: f64,
                height: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Rotate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITransformProvider,
                degrees: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITransformProvider,
                degrees: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CanMove: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITransformProvider,
                pRetVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITransformProvider,
                pRetVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CanResize: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITransformProvider,
                pRetVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITransformProvider,
                pRetVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CanRotate: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITransformProvider,
                pRetVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITransformProvider,
                pRetVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITransformProvider_Move(self: *const T, x: f64, y: f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITransformProvider.VTable, self.vtable).Move(@ptrCast(*const ITransformProvider, self), x, y);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITransformProvider_Resize(self: *const T, width: f64, height: f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITransformProvider.VTable, self.vtable).Resize(@ptrCast(*const ITransformProvider, self), width, height);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITransformProvider_Rotate(self: *const T, degrees: f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITransformProvider.VTable, self.vtable).Rotate(@ptrCast(*const ITransformProvider, self), degrees);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITransformProvider_get_CanMove(self: *const T, pRetVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITransformProvider.VTable, self.vtable).get_CanMove(@ptrCast(*const ITransformProvider, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITransformProvider_get_CanResize(self: *const T, pRetVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITransformProvider.VTable, self.vtable).get_CanResize(@ptrCast(*const ITransformProvider, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITransformProvider_get_CanRotate(self: *const T, pRetVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITransformProvider.VTable, self.vtable).get_CanRotate(@ptrCast(*const ITransformProvider, self), pRetVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IValueProvider_Value = Guid.initString("c7935180-6fb3-4201-b174-7df73adbf64a");
pub const IID_IValueProvider = &IID_IValueProvider_Value;
pub const IValueProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IValueProvider,
                val: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IValueProvider,
                val: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Value: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IValueProvider,
                pRetVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IValueProvider,
                pRetVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsReadOnly: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IValueProvider,
                pRetVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IValueProvider,
                pRetVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IValueProvider_SetValue(self: *const T, val: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IValueProvider.VTable, self.vtable).SetValue(@ptrCast(*const IValueProvider, self), val);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IValueProvider_get_Value(self: *const T, pRetVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IValueProvider.VTable, self.vtable).get_Value(@ptrCast(*const IValueProvider, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IValueProvider_get_IsReadOnly(self: *const T, pRetVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IValueProvider.VTable, self.vtable).get_IsReadOnly(@ptrCast(*const IValueProvider, self), pRetVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IWindowProvider_Value = Guid.initString("987df77b-db06-4d77-8f8a-86a9c3bb90b9");
pub const IID_IWindowProvider = &IID_IWindowProvider_Value;
pub const IWindowProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetVisualState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWindowProvider,
                state: WindowVisualState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWindowProvider,
                state: WindowVisualState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Close: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWindowProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWindowProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WaitForInputIdle: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWindowProvider,
                milliseconds: i32,
                pRetVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWindowProvider,
                milliseconds: i32,
                pRetVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CanMaximize: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IWindowProvider,
                pRetVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IWindowProvider,
                pRetVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CanMinimize: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IWindowProvider,
                pRetVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IWindowProvider,
                pRetVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsModal: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IWindowProvider,
                pRetVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IWindowProvider,
                pRetVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_WindowVisualState: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IWindowProvider,
                pRetVal: ?*WindowVisualState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IWindowProvider,
                pRetVal: ?*WindowVisualState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_WindowInteractionState: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IWindowProvider,
                pRetVal: ?*WindowInteractionState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IWindowProvider,
                pRetVal: ?*WindowInteractionState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsTopmost: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IWindowProvider,
                pRetVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IWindowProvider,
                pRetVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWindowProvider_SetVisualState(self: *const T, state: WindowVisualState) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWindowProvider.VTable, self.vtable).SetVisualState(@ptrCast(*const IWindowProvider, self), state);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWindowProvider_Close(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWindowProvider.VTable, self.vtable).Close(@ptrCast(*const IWindowProvider, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWindowProvider_WaitForInputIdle(self: *const T, milliseconds: i32, pRetVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWindowProvider.VTable, self.vtable).WaitForInputIdle(@ptrCast(*const IWindowProvider, self), milliseconds, pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWindowProvider_get_CanMaximize(self: *const T, pRetVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWindowProvider.VTable, self.vtable).get_CanMaximize(@ptrCast(*const IWindowProvider, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWindowProvider_get_CanMinimize(self: *const T, pRetVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWindowProvider.VTable, self.vtable).get_CanMinimize(@ptrCast(*const IWindowProvider, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWindowProvider_get_IsModal(self: *const T, pRetVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWindowProvider.VTable, self.vtable).get_IsModal(@ptrCast(*const IWindowProvider, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWindowProvider_get_WindowVisualState(self: *const T, pRetVal: ?*WindowVisualState) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWindowProvider.VTable, self.vtable).get_WindowVisualState(@ptrCast(*const IWindowProvider, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWindowProvider_get_WindowInteractionState(self: *const T, pRetVal: ?*WindowInteractionState) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWindowProvider.VTable, self.vtable).get_WindowInteractionState(@ptrCast(*const IWindowProvider, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWindowProvider_get_IsTopmost(self: *const T, pRetVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWindowProvider.VTable, self.vtable).get_IsTopmost(@ptrCast(*const IWindowProvider, self), pRetVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ILegacyIAccessibleProvider_Value = Guid.initString("e44c3566-915d-4070-99c6-047bff5a08f5");
pub const IID_ILegacyIAccessibleProvider = &IID_ILegacyIAccessibleProvider_Value;
pub const ILegacyIAccessibleProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Select: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ILegacyIAccessibleProvider,
                flagsSelect: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ILegacyIAccessibleProvider,
                flagsSelect: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DoDefaultAction: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ILegacyIAccessibleProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ILegacyIAccessibleProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ILegacyIAccessibleProvider,
                szValue: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ILegacyIAccessibleProvider,
                szValue: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIAccessible: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ILegacyIAccessibleProvider,
                ppAccessible: ?*?*IAccessible,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ILegacyIAccessibleProvider,
                ppAccessible: ?*?*IAccessible,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ChildId: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ILegacyIAccessibleProvider,
                pRetVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ILegacyIAccessibleProvider,
                pRetVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ILegacyIAccessibleProvider,
                pszName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ILegacyIAccessibleProvider,
                pszName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Value: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ILegacyIAccessibleProvider,
                pszValue: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ILegacyIAccessibleProvider,
                pszValue: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Description: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ILegacyIAccessibleProvider,
                pszDescription: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ILegacyIAccessibleProvider,
                pszDescription: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Role: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ILegacyIAccessibleProvider,
                pdwRole: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ILegacyIAccessibleProvider,
                pdwRole: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_State: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ILegacyIAccessibleProvider,
                pdwState: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ILegacyIAccessibleProvider,
                pdwState: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Help: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ILegacyIAccessibleProvider,
                pszHelp: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ILegacyIAccessibleProvider,
                pszHelp: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_KeyboardShortcut: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ILegacyIAccessibleProvider,
                pszKeyboardShortcut: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ILegacyIAccessibleProvider,
                pszKeyboardShortcut: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSelection: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ILegacyIAccessibleProvider,
                pvarSelectedChildren: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ILegacyIAccessibleProvider,
                pvarSelectedChildren: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DefaultAction: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ILegacyIAccessibleProvider,
                pszDefaultAction: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ILegacyIAccessibleProvider,
                pszDefaultAction: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILegacyIAccessibleProvider_Select(self: *const T, flagsSelect: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILegacyIAccessibleProvider.VTable, self.vtable).Select(@ptrCast(*const ILegacyIAccessibleProvider, self), flagsSelect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILegacyIAccessibleProvider_DoDefaultAction(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILegacyIAccessibleProvider.VTable, self.vtable).DoDefaultAction(@ptrCast(*const ILegacyIAccessibleProvider, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILegacyIAccessibleProvider_SetValue(self: *const T, szValue: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILegacyIAccessibleProvider.VTable, self.vtable).SetValue(@ptrCast(*const ILegacyIAccessibleProvider, self), szValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILegacyIAccessibleProvider_GetIAccessible(self: *const T, ppAccessible: ?*?*IAccessible) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILegacyIAccessibleProvider.VTable, self.vtable).GetIAccessible(@ptrCast(*const ILegacyIAccessibleProvider, self), ppAccessible);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILegacyIAccessibleProvider_get_ChildId(self: *const T, pRetVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILegacyIAccessibleProvider.VTable, self.vtable).get_ChildId(@ptrCast(*const ILegacyIAccessibleProvider, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILegacyIAccessibleProvider_get_Name(self: *const T, pszName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILegacyIAccessibleProvider.VTable, self.vtable).get_Name(@ptrCast(*const ILegacyIAccessibleProvider, self), pszName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILegacyIAccessibleProvider_get_Value(self: *const T, pszValue: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILegacyIAccessibleProvider.VTable, self.vtable).get_Value(@ptrCast(*const ILegacyIAccessibleProvider, self), pszValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILegacyIAccessibleProvider_get_Description(self: *const T, pszDescription: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILegacyIAccessibleProvider.VTable, self.vtable).get_Description(@ptrCast(*const ILegacyIAccessibleProvider, self), pszDescription);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILegacyIAccessibleProvider_get_Role(self: *const T, pdwRole: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILegacyIAccessibleProvider.VTable, self.vtable).get_Role(@ptrCast(*const ILegacyIAccessibleProvider, self), pdwRole);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILegacyIAccessibleProvider_get_State(self: *const T, pdwState: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILegacyIAccessibleProvider.VTable, self.vtable).get_State(@ptrCast(*const ILegacyIAccessibleProvider, self), pdwState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILegacyIAccessibleProvider_get_Help(self: *const T, pszHelp: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILegacyIAccessibleProvider.VTable, self.vtable).get_Help(@ptrCast(*const ILegacyIAccessibleProvider, self), pszHelp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILegacyIAccessibleProvider_get_KeyboardShortcut(self: *const T, pszKeyboardShortcut: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILegacyIAccessibleProvider.VTable, self.vtable).get_KeyboardShortcut(@ptrCast(*const ILegacyIAccessibleProvider, self), pszKeyboardShortcut);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILegacyIAccessibleProvider_GetSelection(self: *const T, pvarSelectedChildren: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILegacyIAccessibleProvider.VTable, self.vtable).GetSelection(@ptrCast(*const ILegacyIAccessibleProvider, self), pvarSelectedChildren);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILegacyIAccessibleProvider_get_DefaultAction(self: *const T, pszDefaultAction: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILegacyIAccessibleProvider.VTable, self.vtable).get_DefaultAction(@ptrCast(*const ILegacyIAccessibleProvider, self), pszDefaultAction);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IItemContainerProvider_Value = Guid.initString("e747770b-39ce-4382-ab30-d8fb3f336f24");
pub const IID_IItemContainerProvider = &IID_IItemContainerProvider_Value;
pub const IItemContainerProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        FindItemByProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IItemContainerProvider,
                pStartAfter: ?*IRawElementProviderSimple,
                propertyId: i32,
                value: VARIANT,
                pFound: ?*?*IRawElementProviderSimple,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IItemContainerProvider,
                pStartAfter: ?*IRawElementProviderSimple,
                propertyId: i32,
                value: VARIANT,
                pFound: ?*?*IRawElementProviderSimple,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IItemContainerProvider_FindItemByProperty(self: *const T, pStartAfter: ?*IRawElementProviderSimple, propertyId: i32, value: VARIANT, pFound: ?*?*IRawElementProviderSimple) callconv(.Inline) HRESULT {
            return @ptrCast(*const IItemContainerProvider.VTable, self.vtable).FindItemByProperty(@ptrCast(*const IItemContainerProvider, self), pStartAfter, propertyId, value, pFound);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IVirtualizedItemProvider_Value = Guid.initString("cb98b665-2d35-4fac-ad35-f3c60d0c0b8b");
pub const IID_IVirtualizedItemProvider = &IID_IVirtualizedItemProvider_Value;
pub const IVirtualizedItemProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Realize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVirtualizedItemProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVirtualizedItemProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVirtualizedItemProvider_Realize(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVirtualizedItemProvider.VTable, self.vtable).Realize(@ptrCast(*const IVirtualizedItemProvider, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IObjectModelProvider_Value = Guid.initString("3ad86ebd-f5ef-483d-bb18-b1042a475d64");
pub const IID_IObjectModelProvider = &IID_IObjectModelProvider_Value;
pub const IObjectModelProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetUnderlyingObjectModel: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IObjectModelProvider,
                ppUnknown: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IObjectModelProvider,
                ppUnknown: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IObjectModelProvider_GetUnderlyingObjectModel(self: *const T, ppUnknown: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IObjectModelProvider.VTable, self.vtable).GetUnderlyingObjectModel(@ptrCast(*const IObjectModelProvider, self), ppUnknown);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IAnnotationProvider_Value = Guid.initString("f95c7e80-bd63-4601-9782-445ebff011fc");
pub const IID_IAnnotationProvider = &IID_IAnnotationProvider_Value;
pub const IAnnotationProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AnnotationTypeId: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAnnotationProvider,
                retVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAnnotationProvider,
                retVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AnnotationTypeName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAnnotationProvider,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAnnotationProvider,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Author: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAnnotationProvider,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAnnotationProvider,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DateTime: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAnnotationProvider,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAnnotationProvider,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Target: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAnnotationProvider,
                retVal: ?*?*IRawElementProviderSimple,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAnnotationProvider,
                retVal: ?*?*IRawElementProviderSimple,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAnnotationProvider_get_AnnotationTypeId(self: *const T, retVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAnnotationProvider.VTable, self.vtable).get_AnnotationTypeId(@ptrCast(*const IAnnotationProvider, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAnnotationProvider_get_AnnotationTypeName(self: *const T, retVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAnnotationProvider.VTable, self.vtable).get_AnnotationTypeName(@ptrCast(*const IAnnotationProvider, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAnnotationProvider_get_Author(self: *const T, retVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAnnotationProvider.VTable, self.vtable).get_Author(@ptrCast(*const IAnnotationProvider, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAnnotationProvider_get_DateTime(self: *const T, retVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAnnotationProvider.VTable, self.vtable).get_DateTime(@ptrCast(*const IAnnotationProvider, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAnnotationProvider_get_Target(self: *const T, retVal: ?*?*IRawElementProviderSimple) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAnnotationProvider.VTable, self.vtable).get_Target(@ptrCast(*const IAnnotationProvider, self), retVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IStylesProvider_Value = Guid.initString("19b6b649-f5d7-4a6d-bdcb-129252be588a");
pub const IID_IStylesProvider = &IID_IStylesProvider_Value;
pub const IStylesProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StyleId: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IStylesProvider,
                retVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IStylesProvider,
                retVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StyleName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IStylesProvider,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IStylesProvider,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FillColor: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IStylesProvider,
                retVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IStylesProvider,
                retVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FillPatternStyle: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IStylesProvider,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IStylesProvider,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Shape: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IStylesProvider,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IStylesProvider,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FillPatternColor: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IStylesProvider,
                retVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IStylesProvider,
                retVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ExtendedProperties: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IStylesProvider,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IStylesProvider,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStylesProvider_get_StyleId(self: *const T, retVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStylesProvider.VTable, self.vtable).get_StyleId(@ptrCast(*const IStylesProvider, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStylesProvider_get_StyleName(self: *const T, retVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStylesProvider.VTable, self.vtable).get_StyleName(@ptrCast(*const IStylesProvider, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStylesProvider_get_FillColor(self: *const T, retVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStylesProvider.VTable, self.vtable).get_FillColor(@ptrCast(*const IStylesProvider, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStylesProvider_get_FillPatternStyle(self: *const T, retVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStylesProvider.VTable, self.vtable).get_FillPatternStyle(@ptrCast(*const IStylesProvider, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStylesProvider_get_Shape(self: *const T, retVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStylesProvider.VTable, self.vtable).get_Shape(@ptrCast(*const IStylesProvider, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStylesProvider_get_FillPatternColor(self: *const T, retVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStylesProvider.VTable, self.vtable).get_FillPatternColor(@ptrCast(*const IStylesProvider, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStylesProvider_get_ExtendedProperties(self: *const T, retVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStylesProvider.VTable, self.vtable).get_ExtendedProperties(@ptrCast(*const IStylesProvider, self), retVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ISpreadsheetProvider_Value = Guid.initString("6f6b5d35-5525-4f80-b758-85473832ffc7");
pub const IID_ISpreadsheetProvider = &IID_ISpreadsheetProvider_Value;
pub const ISpreadsheetProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetItemByName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpreadsheetProvider,
                name: ?[*:0]const u16,
                pRetVal: ?*?*IRawElementProviderSimple,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpreadsheetProvider,
                name: ?[*:0]const u16,
                pRetVal: ?*?*IRawElementProviderSimple,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpreadsheetProvider_GetItemByName(self: *const T, name: ?[*:0]const u16, pRetVal: ?*?*IRawElementProviderSimple) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpreadsheetProvider.VTable, self.vtable).GetItemByName(@ptrCast(*const ISpreadsheetProvider, self), name, pRetVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ISpreadsheetItemProvider_Value = Guid.initString("eaed4660-7b3d-4879-a2e6-365ce603f3d0");
pub const IID_ISpreadsheetItemProvider = &IID_ISpreadsheetItemProvider_Value;
pub const ISpreadsheetItemProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Formula: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpreadsheetItemProvider,
                pRetVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpreadsheetItemProvider,
                pRetVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAnnotationObjects: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpreadsheetItemProvider,
                pRetVal: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpreadsheetItemProvider,
                pRetVal: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAnnotationTypes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpreadsheetItemProvider,
                pRetVal: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpreadsheetItemProvider,
                pRetVal: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpreadsheetItemProvider_get_Formula(self: *const T, pRetVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpreadsheetItemProvider.VTable, self.vtable).get_Formula(@ptrCast(*const ISpreadsheetItemProvider, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpreadsheetItemProvider_GetAnnotationObjects(self: *const T, pRetVal: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpreadsheetItemProvider.VTable, self.vtable).GetAnnotationObjects(@ptrCast(*const ISpreadsheetItemProvider, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpreadsheetItemProvider_GetAnnotationTypes(self: *const T, pRetVal: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpreadsheetItemProvider.VTable, self.vtable).GetAnnotationTypes(@ptrCast(*const ISpreadsheetItemProvider, self), pRetVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ITransformProvider2_Value = Guid.initString("4758742f-7ac2-460c-bc48-09fc09308a93");
pub const IID_ITransformProvider2 = &IID_ITransformProvider2_Value;
pub const ITransformProvider2 = extern struct {
    pub const VTable = extern struct {
        base: ITransformProvider.VTable,
        Zoom: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITransformProvider2,
                zoom: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITransformProvider2,
                zoom: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CanZoom: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITransformProvider2,
                pRetVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITransformProvider2,
                pRetVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ZoomLevel: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITransformProvider2,
                pRetVal: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITransformProvider2,
                pRetVal: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ZoomMinimum: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITransformProvider2,
                pRetVal: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITransformProvider2,
                pRetVal: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ZoomMaximum: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITransformProvider2,
                pRetVal: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITransformProvider2,
                pRetVal: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ZoomByUnit: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITransformProvider2,
                zoomUnit: ZoomUnit,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITransformProvider2,
                zoomUnit: ZoomUnit,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITransformProvider.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITransformProvider2_Zoom(self: *const T, zoom: f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITransformProvider2.VTable, self.vtable).Zoom(@ptrCast(*const ITransformProvider2, self), zoom);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITransformProvider2_get_CanZoom(self: *const T, pRetVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITransformProvider2.VTable, self.vtable).get_CanZoom(@ptrCast(*const ITransformProvider2, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITransformProvider2_get_ZoomLevel(self: *const T, pRetVal: ?*f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITransformProvider2.VTable, self.vtable).get_ZoomLevel(@ptrCast(*const ITransformProvider2, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITransformProvider2_get_ZoomMinimum(self: *const T, pRetVal: ?*f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITransformProvider2.VTable, self.vtable).get_ZoomMinimum(@ptrCast(*const ITransformProvider2, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITransformProvider2_get_ZoomMaximum(self: *const T, pRetVal: ?*f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITransformProvider2.VTable, self.vtable).get_ZoomMaximum(@ptrCast(*const ITransformProvider2, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITransformProvider2_ZoomByUnit(self: *const T, zoomUnit: ZoomUnit) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITransformProvider2.VTable, self.vtable).ZoomByUnit(@ptrCast(*const ITransformProvider2, self), zoomUnit);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IDragProvider_Value = Guid.initString("6aa7bbbb-7ff9-497d-904f-d20b897929d8");
pub const IID_IDragProvider = &IID_IDragProvider_Value;
pub const IDragProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsGrabbed: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDragProvider,
                pRetVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDragProvider,
                pRetVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DropEffect: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDragProvider,
                pRetVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDragProvider,
                pRetVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DropEffects: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDragProvider,
                pRetVal: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDragProvider,
                pRetVal: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetGrabbedItems: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDragProvider,
                pRetVal: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDragProvider,
                pRetVal: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDragProvider_get_IsGrabbed(self: *const T, pRetVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDragProvider.VTable, self.vtable).get_IsGrabbed(@ptrCast(*const IDragProvider, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDragProvider_get_DropEffect(self: *const T, pRetVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDragProvider.VTable, self.vtable).get_DropEffect(@ptrCast(*const IDragProvider, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDragProvider_get_DropEffects(self: *const T, pRetVal: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDragProvider.VTable, self.vtable).get_DropEffects(@ptrCast(*const IDragProvider, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDragProvider_GetGrabbedItems(self: *const T, pRetVal: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDragProvider.VTable, self.vtable).GetGrabbedItems(@ptrCast(*const IDragProvider, self), pRetVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IDropTargetProvider_Value = Guid.initString("bae82bfd-358a-481c-85a0-d8b4d90a5d61");
pub const IID_IDropTargetProvider = &IID_IDropTargetProvider_Value;
pub const IDropTargetProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DropTargetEffect: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDropTargetProvider,
                pRetVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDropTargetProvider,
                pRetVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DropTargetEffects: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDropTargetProvider,
                pRetVal: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDropTargetProvider,
                pRetVal: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDropTargetProvider_get_DropTargetEffect(self: *const T, pRetVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDropTargetProvider.VTable, self.vtable).get_DropTargetEffect(@ptrCast(*const IDropTargetProvider, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDropTargetProvider_get_DropTargetEffects(self: *const T, pRetVal: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDropTargetProvider.VTable, self.vtable).get_DropTargetEffects(@ptrCast(*const IDropTargetProvider, self), pRetVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ITextRangeProvider_Value = Guid.initString("5347ad7b-c355-46f8-aff5-909033582f63");
pub const IID_ITextRangeProvider = &IID_ITextRangeProvider_Value;
pub const ITextRangeProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITextRangeProvider,
                pRetVal: ?*?*ITextRangeProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITextRangeProvider,
                pRetVal: ?*?*ITextRangeProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Compare: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITextRangeProvider,
                range: ?*ITextRangeProvider,
                pRetVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITextRangeProvider,
                range: ?*ITextRangeProvider,
                pRetVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CompareEndpoints: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITextRangeProvider,
                endpoint: TextPatternRangeEndpoint,
                targetRange: ?*ITextRangeProvider,
                targetEndpoint: TextPatternRangeEndpoint,
                pRetVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITextRangeProvider,
                endpoint: TextPatternRangeEndpoint,
                targetRange: ?*ITextRangeProvider,
                targetEndpoint: TextPatternRangeEndpoint,
                pRetVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExpandToEnclosingUnit: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITextRangeProvider,
                unit: TextUnit,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITextRangeProvider,
                unit: TextUnit,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindAttribute: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITextRangeProvider,
                attributeId: i32,
                val: VARIANT,
                backward: BOOL,
                pRetVal: ?*?*ITextRangeProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITextRangeProvider,
                attributeId: i32,
                val: VARIANT,
                backward: BOOL,
                pRetVal: ?*?*ITextRangeProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindText: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITextRangeProvider,
                text: ?BSTR,
                backward: BOOL,
                ignoreCase: BOOL,
                pRetVal: ?*?*ITextRangeProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITextRangeProvider,
                text: ?BSTR,
                backward: BOOL,
                ignoreCase: BOOL,
                pRetVal: ?*?*ITextRangeProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAttributeValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITextRangeProvider,
                attributeId: i32,
                pRetVal: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITextRangeProvider,
                attributeId: i32,
                pRetVal: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBoundingRectangles: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITextRangeProvider,
                pRetVal: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITextRangeProvider,
                pRetVal: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEnclosingElement: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITextRangeProvider,
                pRetVal: ?*?*IRawElementProviderSimple,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITextRangeProvider,
                pRetVal: ?*?*IRawElementProviderSimple,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetText: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITextRangeProvider,
                maxLength: i32,
                pRetVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITextRangeProvider,
                maxLength: i32,
                pRetVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Move: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITextRangeProvider,
                unit: TextUnit,
                count: i32,
                pRetVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITextRangeProvider,
                unit: TextUnit,
                count: i32,
                pRetVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        MoveEndpointByUnit: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITextRangeProvider,
                endpoint: TextPatternRangeEndpoint,
                unit: TextUnit,
                count: i32,
                pRetVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITextRangeProvider,
                endpoint: TextPatternRangeEndpoint,
                unit: TextUnit,
                count: i32,
                pRetVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        MoveEndpointByRange: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITextRangeProvider,
                endpoint: TextPatternRangeEndpoint,
                targetRange: ?*ITextRangeProvider,
                targetEndpoint: TextPatternRangeEndpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITextRangeProvider,
                endpoint: TextPatternRangeEndpoint,
                targetRange: ?*ITextRangeProvider,
                targetEndpoint: TextPatternRangeEndpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Select: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITextRangeProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITextRangeProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddToSelection: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITextRangeProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITextRangeProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveFromSelection: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITextRangeProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITextRangeProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ScrollIntoView: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITextRangeProvider,
                alignToTop: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITextRangeProvider,
                alignToTop: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetChildren: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITextRangeProvider,
                pRetVal: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITextRangeProvider,
                pRetVal: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRangeProvider_Clone(self: *const T, pRetVal: ?*?*ITextRangeProvider) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRangeProvider.VTable, self.vtable).Clone(@ptrCast(*const ITextRangeProvider, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRangeProvider_Compare(self: *const T, range: ?*ITextRangeProvider, pRetVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRangeProvider.VTable, self.vtable).Compare(@ptrCast(*const ITextRangeProvider, self), range, pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRangeProvider_CompareEndpoints(self: *const T, endpoint: TextPatternRangeEndpoint, targetRange: ?*ITextRangeProvider, targetEndpoint: TextPatternRangeEndpoint, pRetVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRangeProvider.VTable, self.vtable).CompareEndpoints(@ptrCast(*const ITextRangeProvider, self), endpoint, targetRange, targetEndpoint, pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRangeProvider_ExpandToEnclosingUnit(self: *const T, unit: TextUnit) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRangeProvider.VTable, self.vtable).ExpandToEnclosingUnit(@ptrCast(*const ITextRangeProvider, self), unit);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRangeProvider_FindAttribute(self: *const T, attributeId: i32, val: VARIANT, backward: BOOL, pRetVal: ?*?*ITextRangeProvider) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRangeProvider.VTable, self.vtable).FindAttribute(@ptrCast(*const ITextRangeProvider, self), attributeId, val, backward, pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRangeProvider_FindText(self: *const T, text: ?BSTR, backward: BOOL, ignoreCase: BOOL, pRetVal: ?*?*ITextRangeProvider) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRangeProvider.VTable, self.vtable).FindText(@ptrCast(*const ITextRangeProvider, self), text, backward, ignoreCase, pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRangeProvider_GetAttributeValue(self: *const T, attributeId: i32, pRetVal: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRangeProvider.VTable, self.vtable).GetAttributeValue(@ptrCast(*const ITextRangeProvider, self), attributeId, pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRangeProvider_GetBoundingRectangles(self: *const T, pRetVal: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRangeProvider.VTable, self.vtable).GetBoundingRectangles(@ptrCast(*const ITextRangeProvider, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRangeProvider_GetEnclosingElement(self: *const T, pRetVal: ?*?*IRawElementProviderSimple) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRangeProvider.VTable, self.vtable).GetEnclosingElement(@ptrCast(*const ITextRangeProvider, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRangeProvider_GetText(self: *const T, maxLength: i32, pRetVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRangeProvider.VTable, self.vtable).GetText(@ptrCast(*const ITextRangeProvider, self), maxLength, pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRangeProvider_Move(self: *const T, unit: TextUnit, count: i32, pRetVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRangeProvider.VTable, self.vtable).Move(@ptrCast(*const ITextRangeProvider, self), unit, count, pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRangeProvider_MoveEndpointByUnit(self: *const T, endpoint: TextPatternRangeEndpoint, unit: TextUnit, count: i32, pRetVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRangeProvider.VTable, self.vtable).MoveEndpointByUnit(@ptrCast(*const ITextRangeProvider, self), endpoint, unit, count, pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRangeProvider_MoveEndpointByRange(self: *const T, endpoint: TextPatternRangeEndpoint, targetRange: ?*ITextRangeProvider, targetEndpoint: TextPatternRangeEndpoint) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRangeProvider.VTable, self.vtable).MoveEndpointByRange(@ptrCast(*const ITextRangeProvider, self), endpoint, targetRange, targetEndpoint);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRangeProvider_Select(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRangeProvider.VTable, self.vtable).Select(@ptrCast(*const ITextRangeProvider, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRangeProvider_AddToSelection(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRangeProvider.VTable, self.vtable).AddToSelection(@ptrCast(*const ITextRangeProvider, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRangeProvider_RemoveFromSelection(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRangeProvider.VTable, self.vtable).RemoveFromSelection(@ptrCast(*const ITextRangeProvider, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRangeProvider_ScrollIntoView(self: *const T, alignToTop: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRangeProvider.VTable, self.vtable).ScrollIntoView(@ptrCast(*const ITextRangeProvider, self), alignToTop);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRangeProvider_GetChildren(self: *const T, pRetVal: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRangeProvider.VTable, self.vtable).GetChildren(@ptrCast(*const ITextRangeProvider, self), pRetVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ITextProvider_Value = Guid.initString("3589c92c-63f3-4367-99bb-ada653b77cf2");
pub const IID_ITextProvider = &IID_ITextProvider_Value;
pub const ITextProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSelection: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITextProvider,
                pRetVal: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITextProvider,
                pRetVal: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVisibleRanges: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITextProvider,
                pRetVal: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITextProvider,
                pRetVal: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RangeFromChild: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITextProvider,
                childElement: ?*IRawElementProviderSimple,
                pRetVal: ?*?*ITextRangeProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITextProvider,
                childElement: ?*IRawElementProviderSimple,
                pRetVal: ?*?*ITextRangeProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RangeFromPoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITextProvider,
                point: UiaPoint,
                pRetVal: ?*?*ITextRangeProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITextProvider,
                point: UiaPoint,
                pRetVal: ?*?*ITextRangeProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DocumentRange: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITextProvider,
                pRetVal: ?*?*ITextRangeProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITextProvider,
                pRetVal: ?*?*ITextRangeProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SupportedTextSelection: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITextProvider,
                pRetVal: ?*SupportedTextSelection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITextProvider,
                pRetVal: ?*SupportedTextSelection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextProvider_GetSelection(self: *const T, pRetVal: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextProvider.VTable, self.vtable).GetSelection(@ptrCast(*const ITextProvider, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextProvider_GetVisibleRanges(self: *const T, pRetVal: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextProvider.VTable, self.vtable).GetVisibleRanges(@ptrCast(*const ITextProvider, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextProvider_RangeFromChild(self: *const T, childElement: ?*IRawElementProviderSimple, pRetVal: ?*?*ITextRangeProvider) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextProvider.VTable, self.vtable).RangeFromChild(@ptrCast(*const ITextProvider, self), childElement, pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextProvider_RangeFromPoint(self: *const T, point: UiaPoint, pRetVal: ?*?*ITextRangeProvider) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextProvider.VTable, self.vtable).RangeFromPoint(@ptrCast(*const ITextProvider, self), point, pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextProvider_get_DocumentRange(self: *const T, pRetVal: ?*?*ITextRangeProvider) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextProvider.VTable, self.vtable).get_DocumentRange(@ptrCast(*const ITextProvider, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextProvider_get_SupportedTextSelection(self: *const T, pRetVal: ?*SupportedTextSelection) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextProvider.VTable, self.vtable).get_SupportedTextSelection(@ptrCast(*const ITextProvider, self), pRetVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ITextProvider2_Value = Guid.initString("0dc5e6ed-3e16-4bf1-8f9a-a979878bc195");
pub const IID_ITextProvider2 = &IID_ITextProvider2_Value;
pub const ITextProvider2 = extern struct {
    pub const VTable = extern struct {
        base: ITextProvider.VTable,
        RangeFromAnnotation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITextProvider2,
                annotationElement: ?*IRawElementProviderSimple,
                pRetVal: ?*?*ITextRangeProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITextProvider2,
                annotationElement: ?*IRawElementProviderSimple,
                pRetVal: ?*?*ITextRangeProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCaretRange: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITextProvider2,
                isActive: ?*BOOL,
                pRetVal: ?*?*ITextRangeProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITextProvider2,
                isActive: ?*BOOL,
                pRetVal: ?*?*ITextRangeProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITextProvider.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextProvider2_RangeFromAnnotation(self: *const T, annotationElement: ?*IRawElementProviderSimple, pRetVal: ?*?*ITextRangeProvider) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextProvider2.VTable, self.vtable).RangeFromAnnotation(@ptrCast(*const ITextProvider2, self), annotationElement, pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextProvider2_GetCaretRange(self: *const T, isActive: ?*BOOL, pRetVal: ?*?*ITextRangeProvider) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextProvider2.VTable, self.vtable).GetCaretRange(@ptrCast(*const ITextProvider2, self), isActive, pRetVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.1'
const IID_ITextEditProvider_Value = Guid.initString("ea3605b4-3a05-400e-b5f9-4e91b40f6176");
pub const IID_ITextEditProvider = &IID_ITextEditProvider_Value;
pub const ITextEditProvider = extern struct {
    pub const VTable = extern struct {
        base: ITextProvider.VTable,
        GetActiveComposition: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITextEditProvider,
                pRetVal: ?*?*ITextRangeProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITextEditProvider,
                pRetVal: ?*?*ITextRangeProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetConversionTarget: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITextEditProvider,
                pRetVal: ?*?*ITextRangeProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITextEditProvider,
                pRetVal: ?*?*ITextRangeProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITextProvider.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextEditProvider_GetActiveComposition(self: *const T, pRetVal: ?*?*ITextRangeProvider) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextEditProvider.VTable, self.vtable).GetActiveComposition(@ptrCast(*const ITextEditProvider, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextEditProvider_GetConversionTarget(self: *const T, pRetVal: ?*?*ITextRangeProvider) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextEditProvider.VTable, self.vtable).GetConversionTarget(@ptrCast(*const ITextEditProvider, self), pRetVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.1'
const IID_ITextRangeProvider2_Value = Guid.initString("9bbce42c-1921-4f18-89ca-dba1910a0386");
pub const IID_ITextRangeProvider2 = &IID_ITextRangeProvider2_Value;
pub const ITextRangeProvider2 = extern struct {
    pub const VTable = extern struct {
        base: ITextRangeProvider.VTable,
        ShowContextMenu: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITextRangeProvider2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITextRangeProvider2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITextRangeProvider.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRangeProvider2_ShowContextMenu(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRangeProvider2.VTable, self.vtable).ShowContextMenu(@ptrCast(*const ITextRangeProvider2, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ITextChildProvider_Value = Guid.initString("4c2de2b9-c88f-4f88-a111-f1d336b7d1a9");
pub const IID_ITextChildProvider = &IID_ITextChildProvider_Value;
pub const ITextChildProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TextContainer: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITextChildProvider,
                pRetVal: ?*?*IRawElementProviderSimple,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITextChildProvider,
                pRetVal: ?*?*IRawElementProviderSimple,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TextRange: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITextChildProvider,
                pRetVal: ?*?*ITextRangeProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITextChildProvider,
                pRetVal: ?*?*ITextRangeProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextChildProvider_get_TextContainer(self: *const T, pRetVal: ?*?*IRawElementProviderSimple) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextChildProvider.VTable, self.vtable).get_TextContainer(@ptrCast(*const ITextChildProvider, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextChildProvider_get_TextRange(self: *const T, pRetVal: ?*?*ITextRangeProvider) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextChildProvider.VTable, self.vtable).get_TextRange(@ptrCast(*const ITextChildProvider, self), pRetVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICustomNavigationProvider_Value = Guid.initString("2062a28a-8c07-4b94-8e12-7037c622aeb8");
pub const IID_ICustomNavigationProvider = &IID_ICustomNavigationProvider_Value;
pub const ICustomNavigationProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Navigate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICustomNavigationProvider,
                direction: NavigateDirection,
                pRetVal: ?*?*IRawElementProviderSimple,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICustomNavigationProvider,
                direction: NavigateDirection,
                pRetVal: ?*?*IRawElementProviderSimple,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICustomNavigationProvider_Navigate(self: *const T, direction: NavigateDirection, pRetVal: ?*?*IRawElementProviderSimple) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICustomNavigationProvider.VTable, self.vtable).Navigate(@ptrCast(*const ICustomNavigationProvider, self), direction, pRetVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IUIAutomationPatternInstance_Value = Guid.initString("c03a7fe4-9431-409f-bed8-ae7c2299bc8d");
pub const IID_IUIAutomationPatternInstance = &IID_IUIAutomationPatternInstance_Value;
pub const IUIAutomationPatternInstance = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationPatternInstance,
                index: u32,
                cached: BOOL,
                type: UIAutomationType,
                pPtr: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationPatternInstance,
                index: u32,
                cached: BOOL,
                type: UIAutomationType,
                pPtr: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CallMethod: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationPatternInstance,
                index: u32,
                pParams: ?*const UIAutomationParameter,
                cParams: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationPatternInstance,
                index: u32,
                pParams: ?*const UIAutomationParameter,
                cParams: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationPatternInstance_GetProperty(self: *const T, index: u32, cached: BOOL, type_: UIAutomationType, pPtr: ?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationPatternInstance.VTable, self.vtable).GetProperty(@ptrCast(*const IUIAutomationPatternInstance, self), index, cached, type_, pPtr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationPatternInstance_CallMethod(self: *const T, index: u32, pParams: ?*const UIAutomationParameter, cParams: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationPatternInstance.VTable, self.vtable).CallMethod(@ptrCast(*const IUIAutomationPatternInstance, self), index, pParams, cParams);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IUIAutomationPatternHandler_Value = Guid.initString("d97022f3-a947-465e-8b2a-ac4315fa54e8");
pub const IID_IUIAutomationPatternHandler = &IID_IUIAutomationPatternHandler_Value;
pub const IUIAutomationPatternHandler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateClientWrapper: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationPatternHandler,
                pPatternInstance: ?*IUIAutomationPatternInstance,
                pClientWrapper: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationPatternHandler,
                pPatternInstance: ?*IUIAutomationPatternInstance,
                pClientWrapper: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Dispatch: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationPatternHandler,
                pTarget: ?*IUnknown,
                index: u32,
                pParams: ?*const UIAutomationParameter,
                cParams: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationPatternHandler,
                pTarget: ?*IUnknown,
                index: u32,
                pParams: ?*const UIAutomationParameter,
                cParams: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationPatternHandler_CreateClientWrapper(self: *const T, pPatternInstance: ?*IUIAutomationPatternInstance, pClientWrapper: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationPatternHandler.VTable, self.vtable).CreateClientWrapper(@ptrCast(*const IUIAutomationPatternHandler, self), pPatternInstance, pClientWrapper);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationPatternHandler_Dispatch(self: *const T, pTarget: ?*IUnknown, index: u32, pParams: ?*const UIAutomationParameter, cParams: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationPatternHandler.VTable, self.vtable).Dispatch(@ptrCast(*const IUIAutomationPatternHandler, self), pTarget, index, pParams, cParams);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IUIAutomationRegistrar_Value = Guid.initString("8609c4ec-4a1a-4d88-a357-5a66e060e1cf");
pub const IID_IUIAutomationRegistrar = &IID_IUIAutomationRegistrar_Value;
pub const IUIAutomationRegistrar = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RegisterProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationRegistrar,
                property: ?*const UIAutomationPropertyInfo,
                propertyId: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationRegistrar,
                property: ?*const UIAutomationPropertyInfo,
                propertyId: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RegisterEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationRegistrar,
                event: ?*const UIAutomationEventInfo,
                eventId: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationRegistrar,
                event: ?*const UIAutomationEventInfo,
                eventId: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RegisterPattern: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationRegistrar,
                pattern: ?*const UIAutomationPatternInfo,
                pPatternId: ?*i32,
                pPatternAvailablePropertyId: ?*i32,
                propertyIdCount: u32,
                pPropertyIds: [*]i32,
                eventIdCount: u32,
                pEventIds: [*]i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationRegistrar,
                pattern: ?*const UIAutomationPatternInfo,
                pPatternId: ?*i32,
                pPatternAvailablePropertyId: ?*i32,
                propertyIdCount: u32,
                pPropertyIds: [*]i32,
                eventIdCount: u32,
                pEventIds: [*]i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationRegistrar_RegisterProperty(self: *const T, property: ?*const UIAutomationPropertyInfo, propertyId: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationRegistrar.VTable, self.vtable).RegisterProperty(@ptrCast(*const IUIAutomationRegistrar, self), property, propertyId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationRegistrar_RegisterEvent(self: *const T, event: ?*const UIAutomationEventInfo, eventId: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationRegistrar.VTable, self.vtable).RegisterEvent(@ptrCast(*const IUIAutomationRegistrar, self), event, eventId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationRegistrar_RegisterPattern(self: *const T, pattern: ?*const UIAutomationPatternInfo, pPatternId: ?*i32, pPatternAvailablePropertyId: ?*i32, propertyIdCount: u32, pPropertyIds: [*]i32, eventIdCount: u32, pEventIds: [*]i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationRegistrar.VTable, self.vtable).RegisterPattern(@ptrCast(*const IUIAutomationRegistrar, self), pattern, pPatternId, pPatternAvailablePropertyId, propertyIdCount, pPropertyIds, eventIdCount, pEventIds);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const TreeScope = enum(i32) {
    None = 0,
    Element = 1,
    Children = 2,
    Descendants = 4,
    Parent = 8,
    Ancestors = 16,
    Subtree = 7,
};
pub const TreeScope_None = TreeScope.None;
pub const TreeScope_Element = TreeScope.Element;
pub const TreeScope_Children = TreeScope.Children;
pub const TreeScope_Descendants = TreeScope.Descendants;
pub const TreeScope_Parent = TreeScope.Parent;
pub const TreeScope_Ancestors = TreeScope.Ancestors;
pub const TreeScope_Subtree = TreeScope.Subtree;

pub const PropertyConditionFlags = enum(i32) {
    None = 0,
    IgnoreCase = 1,
    MatchSubstring = 2,
};
pub const PropertyConditionFlags_None = PropertyConditionFlags.None;
pub const PropertyConditionFlags_IgnoreCase = PropertyConditionFlags.IgnoreCase;
pub const PropertyConditionFlags_MatchSubstring = PropertyConditionFlags.MatchSubstring;

pub const AutomationElementMode = enum(i32) {
    None = 0,
    Full = 1,
};
pub const AutomationElementMode_None = AutomationElementMode.None;
pub const AutomationElementMode_Full = AutomationElementMode.Full;

pub const TreeTraversalOptions = enum(i32) {
    Default = 0,
    PostOrder = 1,
    LastToFirstOrder = 2,
};
pub const TreeTraversalOptions_Default = TreeTraversalOptions.Default;
pub const TreeTraversalOptions_PostOrder = TreeTraversalOptions.PostOrder;
pub const TreeTraversalOptions_LastToFirstOrder = TreeTraversalOptions.LastToFirstOrder;

pub const ConnectionRecoveryBehaviorOptions = enum(i32) {
    Disabled = 0,
    Enabled = 1,
};
pub const ConnectionRecoveryBehaviorOptions_Disabled = ConnectionRecoveryBehaviorOptions.Disabled;
pub const ConnectionRecoveryBehaviorOptions_Enabled = ConnectionRecoveryBehaviorOptions.Enabled;

pub const CoalesceEventsOptions = enum(i32) {
    Disabled = 0,
    Enabled = 1,
};
pub const CoalesceEventsOptions_Disabled = CoalesceEventsOptions.Disabled;
pub const CoalesceEventsOptions_Enabled = CoalesceEventsOptions.Enabled;

pub const ExtendedProperty = extern struct {
    PropertyName: ?BSTR,
    PropertyValue: ?BSTR,
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IUIAutomationElement_Value = Guid.initString("d22108aa-8ac5-49a5-837b-37bbb3d7591e");
pub const IID_IUIAutomationElement = &IID_IUIAutomationElement_Value;
pub const IUIAutomationElement = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetFocus: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRuntimeId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationElement,
                runtimeId: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationElement,
                runtimeId: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindFirst: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationElement,
                scope: TreeScope,
                condition: ?*IUIAutomationCondition,
                found: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationElement,
                scope: TreeScope,
                condition: ?*IUIAutomationCondition,
                found: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindAll: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationElement,
                scope: TreeScope,
                condition: ?*IUIAutomationCondition,
                found: ?*?*IUIAutomationElementArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationElement,
                scope: TreeScope,
                condition: ?*IUIAutomationCondition,
                found: ?*?*IUIAutomationElementArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindFirstBuildCache: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationElement,
                scope: TreeScope,
                condition: ?*IUIAutomationCondition,
                cacheRequest: ?*IUIAutomationCacheRequest,
                found: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationElement,
                scope: TreeScope,
                condition: ?*IUIAutomationCondition,
                cacheRequest: ?*IUIAutomationCacheRequest,
                found: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindAllBuildCache: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationElement,
                scope: TreeScope,
                condition: ?*IUIAutomationCondition,
                cacheRequest: ?*IUIAutomationCacheRequest,
                found: ?*?*IUIAutomationElementArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationElement,
                scope: TreeScope,
                condition: ?*IUIAutomationCondition,
                cacheRequest: ?*IUIAutomationCacheRequest,
                found: ?*?*IUIAutomationElementArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BuildUpdatedCache: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationElement,
                cacheRequest: ?*IUIAutomationCacheRequest,
                updatedElement: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationElement,
                cacheRequest: ?*IUIAutomationCacheRequest,
                updatedElement: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentPropertyValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationElement,
                propertyId: i32,
                retVal: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationElement,
                propertyId: i32,
                retVal: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentPropertyValueEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationElement,
                propertyId: i32,
                ignoreDefaultValue: BOOL,
                retVal: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationElement,
                propertyId: i32,
                ignoreDefaultValue: BOOL,
                retVal: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCachedPropertyValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationElement,
                propertyId: i32,
                retVal: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationElement,
                propertyId: i32,
                retVal: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCachedPropertyValueEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationElement,
                propertyId: i32,
                ignoreDefaultValue: BOOL,
                retVal: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationElement,
                propertyId: i32,
                ignoreDefaultValue: BOOL,
                retVal: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentPatternAs: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationElement,
                patternId: i32,
                riid: ?*const Guid,
                patternObject: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationElement,
                patternId: i32,
                riid: ?*const Guid,
                patternObject: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCachedPatternAs: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationElement,
                patternId: i32,
                riid: ?*const Guid,
                patternObject: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationElement,
                patternId: i32,
                riid: ?*const Guid,
                patternObject: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentPattern: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationElement,
                patternId: i32,
                patternObject: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationElement,
                patternId: i32,
                patternObject: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCachedPattern: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationElement,
                patternId: i32,
                patternObject: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationElement,
                patternId: i32,
                patternObject: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCachedParent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationElement,
                parent: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationElement,
                parent: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCachedChildren: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationElement,
                children: ?*?*IUIAutomationElementArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationElement,
                children: ?*?*IUIAutomationElementArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentProcessId: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement,
                retVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement,
                retVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentControlType: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement,
                retVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement,
                retVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentLocalizedControlType: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentAcceleratorKey: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentAccessKey: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentHasKeyboardFocus: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentIsKeyboardFocusable: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentIsEnabled: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentAutomationId: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentClassName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentHelpText: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentCulture: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement,
                retVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement,
                retVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentIsControlElement: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentIsContentElement: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentIsPassword: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentNativeWindowHandle: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement,
                retVal: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement,
                retVal: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentItemType: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentIsOffscreen: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentOrientation: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement,
                retVal: ?*OrientationType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement,
                retVal: ?*OrientationType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentFrameworkId: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentIsRequiredForForm: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentItemStatus: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentBoundingRectangle: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement,
                retVal: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement,
                retVal: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentLabeledBy: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement,
                retVal: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement,
                retVal: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentAriaRole: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentAriaProperties: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentIsDataValidForForm: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentControllerFor: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement,
                retVal: ?*?*IUIAutomationElementArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement,
                retVal: ?*?*IUIAutomationElementArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentDescribedBy: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement,
                retVal: ?*?*IUIAutomationElementArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement,
                retVal: ?*?*IUIAutomationElementArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentFlowsTo: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement,
                retVal: ?*?*IUIAutomationElementArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement,
                retVal: ?*?*IUIAutomationElementArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentProviderDescription: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedProcessId: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement,
                retVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement,
                retVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedControlType: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement,
                retVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement,
                retVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedLocalizedControlType: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedAcceleratorKey: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedAccessKey: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedHasKeyboardFocus: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedIsKeyboardFocusable: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedIsEnabled: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedAutomationId: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedClassName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedHelpText: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedCulture: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement,
                retVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement,
                retVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedIsControlElement: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedIsContentElement: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedIsPassword: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedNativeWindowHandle: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement,
                retVal: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement,
                retVal: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedItemType: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedIsOffscreen: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedOrientation: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement,
                retVal: ?*OrientationType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement,
                retVal: ?*OrientationType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedFrameworkId: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedIsRequiredForForm: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedItemStatus: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedBoundingRectangle: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement,
                retVal: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement,
                retVal: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedLabeledBy: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement,
                retVal: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement,
                retVal: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedAriaRole: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedAriaProperties: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedIsDataValidForForm: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedControllerFor: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement,
                retVal: ?*?*IUIAutomationElementArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement,
                retVal: ?*?*IUIAutomationElementArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedDescribedBy: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement,
                retVal: ?*?*IUIAutomationElementArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement,
                retVal: ?*?*IUIAutomationElementArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedFlowsTo: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement,
                retVal: ?*?*IUIAutomationElementArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement,
                retVal: ?*?*IUIAutomationElementArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedProviderDescription: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetClickablePoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationElement,
                clickable: ?*POINT,
                gotClickable: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationElement,
                clickable: ?*POINT,
                gotClickable: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_SetFocus(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).SetFocus(@ptrCast(*const IUIAutomationElement, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_GetRuntimeId(self: *const T, runtimeId: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).GetRuntimeId(@ptrCast(*const IUIAutomationElement, self), runtimeId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_FindFirst(self: *const T, scope: TreeScope, condition: ?*IUIAutomationCondition, found: ?*?*IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).FindFirst(@ptrCast(*const IUIAutomationElement, self), scope, condition, found);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_FindAll(self: *const T, scope: TreeScope, condition: ?*IUIAutomationCondition, found: ?*?*IUIAutomationElementArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).FindAll(@ptrCast(*const IUIAutomationElement, self), scope, condition, found);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_FindFirstBuildCache(self: *const T, scope: TreeScope, condition: ?*IUIAutomationCondition, cacheRequest: ?*IUIAutomationCacheRequest, found: ?*?*IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).FindFirstBuildCache(@ptrCast(*const IUIAutomationElement, self), scope, condition, cacheRequest, found);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_FindAllBuildCache(self: *const T, scope: TreeScope, condition: ?*IUIAutomationCondition, cacheRequest: ?*IUIAutomationCacheRequest, found: ?*?*IUIAutomationElementArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).FindAllBuildCache(@ptrCast(*const IUIAutomationElement, self), scope, condition, cacheRequest, found);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_BuildUpdatedCache(self: *const T, cacheRequest: ?*IUIAutomationCacheRequest, updatedElement: ?*?*IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).BuildUpdatedCache(@ptrCast(*const IUIAutomationElement, self), cacheRequest, updatedElement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_GetCurrentPropertyValue(self: *const T, propertyId: i32, retVal: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).GetCurrentPropertyValue(@ptrCast(*const IUIAutomationElement, self), propertyId, retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_GetCurrentPropertyValueEx(self: *const T, propertyId: i32, ignoreDefaultValue: BOOL, retVal: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).GetCurrentPropertyValueEx(@ptrCast(*const IUIAutomationElement, self), propertyId, ignoreDefaultValue, retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_GetCachedPropertyValue(self: *const T, propertyId: i32, retVal: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).GetCachedPropertyValue(@ptrCast(*const IUIAutomationElement, self), propertyId, retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_GetCachedPropertyValueEx(self: *const T, propertyId: i32, ignoreDefaultValue: BOOL, retVal: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).GetCachedPropertyValueEx(@ptrCast(*const IUIAutomationElement, self), propertyId, ignoreDefaultValue, retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_GetCurrentPatternAs(self: *const T, patternId: i32, riid: ?*const Guid, patternObject: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).GetCurrentPatternAs(@ptrCast(*const IUIAutomationElement, self), patternId, riid, patternObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_GetCachedPatternAs(self: *const T, patternId: i32, riid: ?*const Guid, patternObject: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).GetCachedPatternAs(@ptrCast(*const IUIAutomationElement, self), patternId, riid, patternObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_GetCurrentPattern(self: *const T, patternId: i32, patternObject: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).GetCurrentPattern(@ptrCast(*const IUIAutomationElement, self), patternId, patternObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_GetCachedPattern(self: *const T, patternId: i32, patternObject: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).GetCachedPattern(@ptrCast(*const IUIAutomationElement, self), patternId, patternObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_GetCachedParent(self: *const T, parent: ?*?*IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).GetCachedParent(@ptrCast(*const IUIAutomationElement, self), parent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_GetCachedChildren(self: *const T, children: ?*?*IUIAutomationElementArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).GetCachedChildren(@ptrCast(*const IUIAutomationElement, self), children);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CurrentProcessId(self: *const T, retVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CurrentProcessId(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CurrentControlType(self: *const T, retVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CurrentControlType(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CurrentLocalizedControlType(self: *const T, retVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CurrentLocalizedControlType(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CurrentName(self: *const T, retVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CurrentName(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CurrentAcceleratorKey(self: *const T, retVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CurrentAcceleratorKey(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CurrentAccessKey(self: *const T, retVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CurrentAccessKey(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CurrentHasKeyboardFocus(self: *const T, retVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CurrentHasKeyboardFocus(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CurrentIsKeyboardFocusable(self: *const T, retVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CurrentIsKeyboardFocusable(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CurrentIsEnabled(self: *const T, retVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CurrentIsEnabled(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CurrentAutomationId(self: *const T, retVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CurrentAutomationId(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CurrentClassName(self: *const T, retVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CurrentClassName(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CurrentHelpText(self: *const T, retVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CurrentHelpText(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CurrentCulture(self: *const T, retVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CurrentCulture(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CurrentIsControlElement(self: *const T, retVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CurrentIsControlElement(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CurrentIsContentElement(self: *const T, retVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CurrentIsContentElement(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CurrentIsPassword(self: *const T, retVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CurrentIsPassword(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CurrentNativeWindowHandle(self: *const T, retVal: ?HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CurrentNativeWindowHandle(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CurrentItemType(self: *const T, retVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CurrentItemType(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CurrentIsOffscreen(self: *const T, retVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CurrentIsOffscreen(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CurrentOrientation(self: *const T, retVal: ?*OrientationType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CurrentOrientation(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CurrentFrameworkId(self: *const T, retVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CurrentFrameworkId(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CurrentIsRequiredForForm(self: *const T, retVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CurrentIsRequiredForForm(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CurrentItemStatus(self: *const T, retVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CurrentItemStatus(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CurrentBoundingRectangle(self: *const T, retVal: ?*RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CurrentBoundingRectangle(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CurrentLabeledBy(self: *const T, retVal: ?*?*IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CurrentLabeledBy(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CurrentAriaRole(self: *const T, retVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CurrentAriaRole(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CurrentAriaProperties(self: *const T, retVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CurrentAriaProperties(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CurrentIsDataValidForForm(self: *const T, retVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CurrentIsDataValidForForm(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CurrentControllerFor(self: *const T, retVal: ?*?*IUIAutomationElementArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CurrentControllerFor(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CurrentDescribedBy(self: *const T, retVal: ?*?*IUIAutomationElementArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CurrentDescribedBy(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CurrentFlowsTo(self: *const T, retVal: ?*?*IUIAutomationElementArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CurrentFlowsTo(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CurrentProviderDescription(self: *const T, retVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CurrentProviderDescription(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CachedProcessId(self: *const T, retVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CachedProcessId(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CachedControlType(self: *const T, retVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CachedControlType(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CachedLocalizedControlType(self: *const T, retVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CachedLocalizedControlType(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CachedName(self: *const T, retVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CachedName(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CachedAcceleratorKey(self: *const T, retVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CachedAcceleratorKey(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CachedAccessKey(self: *const T, retVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CachedAccessKey(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CachedHasKeyboardFocus(self: *const T, retVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CachedHasKeyboardFocus(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CachedIsKeyboardFocusable(self: *const T, retVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CachedIsKeyboardFocusable(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CachedIsEnabled(self: *const T, retVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CachedIsEnabled(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CachedAutomationId(self: *const T, retVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CachedAutomationId(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CachedClassName(self: *const T, retVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CachedClassName(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CachedHelpText(self: *const T, retVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CachedHelpText(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CachedCulture(self: *const T, retVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CachedCulture(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CachedIsControlElement(self: *const T, retVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CachedIsControlElement(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CachedIsContentElement(self: *const T, retVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CachedIsContentElement(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CachedIsPassword(self: *const T, retVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CachedIsPassword(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CachedNativeWindowHandle(self: *const T, retVal: ?HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CachedNativeWindowHandle(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CachedItemType(self: *const T, retVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CachedItemType(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CachedIsOffscreen(self: *const T, retVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CachedIsOffscreen(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CachedOrientation(self: *const T, retVal: ?*OrientationType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CachedOrientation(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CachedFrameworkId(self: *const T, retVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CachedFrameworkId(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CachedIsRequiredForForm(self: *const T, retVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CachedIsRequiredForForm(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CachedItemStatus(self: *const T, retVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CachedItemStatus(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CachedBoundingRectangle(self: *const T, retVal: ?*RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CachedBoundingRectangle(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CachedLabeledBy(self: *const T, retVal: ?*?*IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CachedLabeledBy(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CachedAriaRole(self: *const T, retVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CachedAriaRole(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CachedAriaProperties(self: *const T, retVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CachedAriaProperties(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CachedIsDataValidForForm(self: *const T, retVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CachedIsDataValidForForm(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CachedControllerFor(self: *const T, retVal: ?*?*IUIAutomationElementArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CachedControllerFor(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CachedDescribedBy(self: *const T, retVal: ?*?*IUIAutomationElementArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CachedDescribedBy(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CachedFlowsTo(self: *const T, retVal: ?*?*IUIAutomationElementArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CachedFlowsTo(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CachedProviderDescription(self: *const T, retVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CachedProviderDescription(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_GetClickablePoint(self: *const T, clickable: ?*POINT, gotClickable: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).GetClickablePoint(@ptrCast(*const IUIAutomationElement, self), clickable, gotClickable);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IUIAutomationElementArray_Value = Guid.initString("14314595-b4bc-4055-95f2-58f2e42c9855");
pub const IID_IUIAutomationElementArray = &IID_IUIAutomationElementArray_Value;
pub const IUIAutomationElementArray = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Length: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElementArray,
                length: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElementArray,
                length: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetElement: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationElementArray,
                index: i32,
                element: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationElementArray,
                index: i32,
                element: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElementArray_get_Length(self: *const T, length: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElementArray.VTable, self.vtable).get_Length(@ptrCast(*const IUIAutomationElementArray, self), length);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElementArray_GetElement(self: *const T, index: i32, element: ?*?*IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElementArray.VTable, self.vtable).GetElement(@ptrCast(*const IUIAutomationElementArray, self), index, element);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IUIAutomationCondition_Value = Guid.initString("352ffba8-0973-437c-a61f-f64cafd81df9");
pub const IID_IUIAutomationCondition = &IID_IUIAutomationCondition_Value;
pub const IUIAutomationCondition = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IUIAutomationBoolCondition_Value = Guid.initString("1b4e1f2e-75eb-4d0b-8952-5a69988e2307");
pub const IID_IUIAutomationBoolCondition = &IID_IUIAutomationBoolCondition_Value;
pub const IUIAutomationBoolCondition = extern struct {
    pub const VTable = extern struct {
        base: IUIAutomationCondition.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BooleanValue: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationBoolCondition,
                boolVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationBoolCondition,
                boolVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUIAutomationCondition.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationBoolCondition_get_BooleanValue(self: *const T, boolVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationBoolCondition.VTable, self.vtable).get_BooleanValue(@ptrCast(*const IUIAutomationBoolCondition, self), boolVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IUIAutomationPropertyCondition_Value = Guid.initString("99ebf2cb-5578-4267-9ad4-afd6ea77e94b");
pub const IID_IUIAutomationPropertyCondition = &IID_IUIAutomationPropertyCondition_Value;
pub const IUIAutomationPropertyCondition = extern struct {
    pub const VTable = extern struct {
        base: IUIAutomationCondition.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PropertyId: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationPropertyCondition,
                propertyId: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationPropertyCondition,
                propertyId: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PropertyValue: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationPropertyCondition,
                propertyValue: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationPropertyCondition,
                propertyValue: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PropertyConditionFlags: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationPropertyCondition,
                flags: ?*PropertyConditionFlags,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationPropertyCondition,
                flags: ?*PropertyConditionFlags,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUIAutomationCondition.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationPropertyCondition_get_PropertyId(self: *const T, propertyId: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationPropertyCondition.VTable, self.vtable).get_PropertyId(@ptrCast(*const IUIAutomationPropertyCondition, self), propertyId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationPropertyCondition_get_PropertyValue(self: *const T, propertyValue: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationPropertyCondition.VTable, self.vtable).get_PropertyValue(@ptrCast(*const IUIAutomationPropertyCondition, self), propertyValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationPropertyCondition_get_PropertyConditionFlags(self: *const T, flags: ?*PropertyConditionFlags) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationPropertyCondition.VTable, self.vtable).get_PropertyConditionFlags(@ptrCast(*const IUIAutomationPropertyCondition, self), flags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IUIAutomationAndCondition_Value = Guid.initString("a7d0af36-b912-45fe-9855-091ddc174aec");
pub const IID_IUIAutomationAndCondition = &IID_IUIAutomationAndCondition_Value;
pub const IUIAutomationAndCondition = extern struct {
    pub const VTable = extern struct {
        base: IUIAutomationCondition.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ChildCount: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationAndCondition,
                childCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationAndCondition,
                childCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetChildrenAsNativeArray: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationAndCondition,
                childArray: [*]?*?*IUIAutomationCondition,
                childArrayCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationAndCondition,
                childArray: [*]?*?*IUIAutomationCondition,
                childArrayCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetChildren: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationAndCondition,
                childArray: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationAndCondition,
                childArray: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUIAutomationCondition.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationAndCondition_get_ChildCount(self: *const T, childCount: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationAndCondition.VTable, self.vtable).get_ChildCount(@ptrCast(*const IUIAutomationAndCondition, self), childCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationAndCondition_GetChildrenAsNativeArray(self: *const T, childArray: [*]?*?*IUIAutomationCondition, childArrayCount: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationAndCondition.VTable, self.vtable).GetChildrenAsNativeArray(@ptrCast(*const IUIAutomationAndCondition, self), childArray, childArrayCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationAndCondition_GetChildren(self: *const T, childArray: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationAndCondition.VTable, self.vtable).GetChildren(@ptrCast(*const IUIAutomationAndCondition, self), childArray);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IUIAutomationOrCondition_Value = Guid.initString("8753f032-3db1-47b5-a1fc-6e34a266c712");
pub const IID_IUIAutomationOrCondition = &IID_IUIAutomationOrCondition_Value;
pub const IUIAutomationOrCondition = extern struct {
    pub const VTable = extern struct {
        base: IUIAutomationCondition.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ChildCount: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationOrCondition,
                childCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationOrCondition,
                childCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetChildrenAsNativeArray: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationOrCondition,
                childArray: [*]?*?*IUIAutomationCondition,
                childArrayCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationOrCondition,
                childArray: [*]?*?*IUIAutomationCondition,
                childArrayCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetChildren: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationOrCondition,
                childArray: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationOrCondition,
                childArray: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUIAutomationCondition.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationOrCondition_get_ChildCount(self: *const T, childCount: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationOrCondition.VTable, self.vtable).get_ChildCount(@ptrCast(*const IUIAutomationOrCondition, self), childCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationOrCondition_GetChildrenAsNativeArray(self: *const T, childArray: [*]?*?*IUIAutomationCondition, childArrayCount: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationOrCondition.VTable, self.vtable).GetChildrenAsNativeArray(@ptrCast(*const IUIAutomationOrCondition, self), childArray, childArrayCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationOrCondition_GetChildren(self: *const T, childArray: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationOrCondition.VTable, self.vtable).GetChildren(@ptrCast(*const IUIAutomationOrCondition, self), childArray);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IUIAutomationNotCondition_Value = Guid.initString("f528b657-847b-498c-8896-d52b565407a1");
pub const IID_IUIAutomationNotCondition = &IID_IUIAutomationNotCondition_Value;
pub const IUIAutomationNotCondition = extern struct {
    pub const VTable = extern struct {
        base: IUIAutomationCondition.VTable,
        GetChild: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationNotCondition,
                condition: ?*?*IUIAutomationCondition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationNotCondition,
                condition: ?*?*IUIAutomationCondition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUIAutomationCondition.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationNotCondition_GetChild(self: *const T, condition: ?*?*IUIAutomationCondition) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationNotCondition.VTable, self.vtable).GetChild(@ptrCast(*const IUIAutomationNotCondition, self), condition);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IUIAutomationCacheRequest_Value = Guid.initString("b32a92b5-bc25-4078-9c08-d7ee95c48e03");
pub const IID_IUIAutomationCacheRequest = &IID_IUIAutomationCacheRequest_Value;
pub const IUIAutomationCacheRequest = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationCacheRequest,
                propertyId: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationCacheRequest,
                propertyId: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddPattern: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationCacheRequest,
                patternId: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationCacheRequest,
                patternId: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationCacheRequest,
                clonedRequest: ?*?*IUIAutomationCacheRequest,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationCacheRequest,
                clonedRequest: ?*?*IUIAutomationCacheRequest,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TreeScope: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationCacheRequest,
                scope: ?*TreeScope,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationCacheRequest,
                scope: ?*TreeScope,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_TreeScope: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationCacheRequest,
                scope: TreeScope,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationCacheRequest,
                scope: TreeScope,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TreeFilter: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationCacheRequest,
                filter: ?*?*IUIAutomationCondition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationCacheRequest,
                filter: ?*?*IUIAutomationCondition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_TreeFilter: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationCacheRequest,
                filter: ?*IUIAutomationCondition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationCacheRequest,
                filter: ?*IUIAutomationCondition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AutomationElementMode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationCacheRequest,
                mode: ?*AutomationElementMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationCacheRequest,
                mode: ?*AutomationElementMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AutomationElementMode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationCacheRequest,
                mode: AutomationElementMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationCacheRequest,
                mode: AutomationElementMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationCacheRequest_AddProperty(self: *const T, propertyId: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationCacheRequest.VTable, self.vtable).AddProperty(@ptrCast(*const IUIAutomationCacheRequest, self), propertyId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationCacheRequest_AddPattern(self: *const T, patternId: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationCacheRequest.VTable, self.vtable).AddPattern(@ptrCast(*const IUIAutomationCacheRequest, self), patternId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationCacheRequest_Clone(self: *const T, clonedRequest: ?*?*IUIAutomationCacheRequest) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationCacheRequest.VTable, self.vtable).Clone(@ptrCast(*const IUIAutomationCacheRequest, self), clonedRequest);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationCacheRequest_get_TreeScope(self: *const T, scope: ?*TreeScope) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationCacheRequest.VTable, self.vtable).get_TreeScope(@ptrCast(*const IUIAutomationCacheRequest, self), scope);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationCacheRequest_put_TreeScope(self: *const T, scope: TreeScope) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationCacheRequest.VTable, self.vtable).put_TreeScope(@ptrCast(*const IUIAutomationCacheRequest, self), scope);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationCacheRequest_get_TreeFilter(self: *const T, filter: ?*?*IUIAutomationCondition) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationCacheRequest.VTable, self.vtable).get_TreeFilter(@ptrCast(*const IUIAutomationCacheRequest, self), filter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationCacheRequest_put_TreeFilter(self: *const T, filter: ?*IUIAutomationCondition) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationCacheRequest.VTable, self.vtable).put_TreeFilter(@ptrCast(*const IUIAutomationCacheRequest, self), filter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationCacheRequest_get_AutomationElementMode(self: *const T, mode: ?*AutomationElementMode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationCacheRequest.VTable, self.vtable).get_AutomationElementMode(@ptrCast(*const IUIAutomationCacheRequest, self), mode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationCacheRequest_put_AutomationElementMode(self: *const T, mode: AutomationElementMode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationCacheRequest.VTable, self.vtable).put_AutomationElementMode(@ptrCast(*const IUIAutomationCacheRequest, self), mode);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IUIAutomationTreeWalker_Value = Guid.initString("4042c624-389c-4afc-a630-9df854a541fc");
pub const IID_IUIAutomationTreeWalker = &IID_IUIAutomationTreeWalker_Value;
pub const IUIAutomationTreeWalker = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetParentElement: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationTreeWalker,
                element: ?*IUIAutomationElement,
                parent: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationTreeWalker,
                element: ?*IUIAutomationElement,
                parent: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFirstChildElement: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationTreeWalker,
                element: ?*IUIAutomationElement,
                first: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationTreeWalker,
                element: ?*IUIAutomationElement,
                first: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLastChildElement: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationTreeWalker,
                element: ?*IUIAutomationElement,
                last: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationTreeWalker,
                element: ?*IUIAutomationElement,
                last: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNextSiblingElement: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationTreeWalker,
                element: ?*IUIAutomationElement,
                next: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationTreeWalker,
                element: ?*IUIAutomationElement,
                next: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPreviousSiblingElement: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationTreeWalker,
                element: ?*IUIAutomationElement,
                previous: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationTreeWalker,
                element: ?*IUIAutomationElement,
                previous: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NormalizeElement: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationTreeWalker,
                element: ?*IUIAutomationElement,
                normalized: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationTreeWalker,
                element: ?*IUIAutomationElement,
                normalized: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetParentElementBuildCache: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationTreeWalker,
                element: ?*IUIAutomationElement,
                cacheRequest: ?*IUIAutomationCacheRequest,
                parent: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationTreeWalker,
                element: ?*IUIAutomationElement,
                cacheRequest: ?*IUIAutomationCacheRequest,
                parent: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFirstChildElementBuildCache: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationTreeWalker,
                element: ?*IUIAutomationElement,
                cacheRequest: ?*IUIAutomationCacheRequest,
                first: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationTreeWalker,
                element: ?*IUIAutomationElement,
                cacheRequest: ?*IUIAutomationCacheRequest,
                first: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLastChildElementBuildCache: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationTreeWalker,
                element: ?*IUIAutomationElement,
                cacheRequest: ?*IUIAutomationCacheRequest,
                last: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationTreeWalker,
                element: ?*IUIAutomationElement,
                cacheRequest: ?*IUIAutomationCacheRequest,
                last: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNextSiblingElementBuildCache: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationTreeWalker,
                element: ?*IUIAutomationElement,
                cacheRequest: ?*IUIAutomationCacheRequest,
                next: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationTreeWalker,
                element: ?*IUIAutomationElement,
                cacheRequest: ?*IUIAutomationCacheRequest,
                next: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPreviousSiblingElementBuildCache: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationTreeWalker,
                element: ?*IUIAutomationElement,
                cacheRequest: ?*IUIAutomationCacheRequest,
                previous: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationTreeWalker,
                element: ?*IUIAutomationElement,
                cacheRequest: ?*IUIAutomationCacheRequest,
                previous: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NormalizeElementBuildCache: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationTreeWalker,
                element: ?*IUIAutomationElement,
                cacheRequest: ?*IUIAutomationCacheRequest,
                normalized: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationTreeWalker,
                element: ?*IUIAutomationElement,
                cacheRequest: ?*IUIAutomationCacheRequest,
                normalized: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Condition: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationTreeWalker,
                condition: ?*?*IUIAutomationCondition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationTreeWalker,
                condition: ?*?*IUIAutomationCondition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTreeWalker_GetParentElement(self: *const T, element: ?*IUIAutomationElement, parent: ?*?*IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTreeWalker.VTable, self.vtable).GetParentElement(@ptrCast(*const IUIAutomationTreeWalker, self), element, parent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTreeWalker_GetFirstChildElement(self: *const T, element: ?*IUIAutomationElement, first: ?*?*IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTreeWalker.VTable, self.vtable).GetFirstChildElement(@ptrCast(*const IUIAutomationTreeWalker, self), element, first);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTreeWalker_GetLastChildElement(self: *const T, element: ?*IUIAutomationElement, last: ?*?*IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTreeWalker.VTable, self.vtable).GetLastChildElement(@ptrCast(*const IUIAutomationTreeWalker, self), element, last);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTreeWalker_GetNextSiblingElement(self: *const T, element: ?*IUIAutomationElement, next: ?*?*IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTreeWalker.VTable, self.vtable).GetNextSiblingElement(@ptrCast(*const IUIAutomationTreeWalker, self), element, next);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTreeWalker_GetPreviousSiblingElement(self: *const T, element: ?*IUIAutomationElement, previous: ?*?*IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTreeWalker.VTable, self.vtable).GetPreviousSiblingElement(@ptrCast(*const IUIAutomationTreeWalker, self), element, previous);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTreeWalker_NormalizeElement(self: *const T, element: ?*IUIAutomationElement, normalized: ?*?*IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTreeWalker.VTable, self.vtable).NormalizeElement(@ptrCast(*const IUIAutomationTreeWalker, self), element, normalized);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTreeWalker_GetParentElementBuildCache(self: *const T, element: ?*IUIAutomationElement, cacheRequest: ?*IUIAutomationCacheRequest, parent: ?*?*IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTreeWalker.VTable, self.vtable).GetParentElementBuildCache(@ptrCast(*const IUIAutomationTreeWalker, self), element, cacheRequest, parent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTreeWalker_GetFirstChildElementBuildCache(self: *const T, element: ?*IUIAutomationElement, cacheRequest: ?*IUIAutomationCacheRequest, first: ?*?*IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTreeWalker.VTable, self.vtable).GetFirstChildElementBuildCache(@ptrCast(*const IUIAutomationTreeWalker, self), element, cacheRequest, first);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTreeWalker_GetLastChildElementBuildCache(self: *const T, element: ?*IUIAutomationElement, cacheRequest: ?*IUIAutomationCacheRequest, last: ?*?*IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTreeWalker.VTable, self.vtable).GetLastChildElementBuildCache(@ptrCast(*const IUIAutomationTreeWalker, self), element, cacheRequest, last);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTreeWalker_GetNextSiblingElementBuildCache(self: *const T, element: ?*IUIAutomationElement, cacheRequest: ?*IUIAutomationCacheRequest, next: ?*?*IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTreeWalker.VTable, self.vtable).GetNextSiblingElementBuildCache(@ptrCast(*const IUIAutomationTreeWalker, self), element, cacheRequest, next);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTreeWalker_GetPreviousSiblingElementBuildCache(self: *const T, element: ?*IUIAutomationElement, cacheRequest: ?*IUIAutomationCacheRequest, previous: ?*?*IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTreeWalker.VTable, self.vtable).GetPreviousSiblingElementBuildCache(@ptrCast(*const IUIAutomationTreeWalker, self), element, cacheRequest, previous);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTreeWalker_NormalizeElementBuildCache(self: *const T, element: ?*IUIAutomationElement, cacheRequest: ?*IUIAutomationCacheRequest, normalized: ?*?*IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTreeWalker.VTable, self.vtable).NormalizeElementBuildCache(@ptrCast(*const IUIAutomationTreeWalker, self), element, cacheRequest, normalized);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTreeWalker_get_Condition(self: *const T, condition: ?*?*IUIAutomationCondition) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTreeWalker.VTable, self.vtable).get_Condition(@ptrCast(*const IUIAutomationTreeWalker, self), condition);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IUIAutomationEventHandler_Value = Guid.initString("146c3c17-f12e-4e22-8c27-f894b9b79c69");
pub const IID_IUIAutomationEventHandler = &IID_IUIAutomationEventHandler_Value;
pub const IUIAutomationEventHandler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        HandleAutomationEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationEventHandler,
                sender: ?*IUIAutomationElement,
                eventId: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationEventHandler,
                sender: ?*IUIAutomationElement,
                eventId: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationEventHandler_HandleAutomationEvent(self: *const T, sender: ?*IUIAutomationElement, eventId: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationEventHandler.VTable, self.vtable).HandleAutomationEvent(@ptrCast(*const IUIAutomationEventHandler, self), sender, eventId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IUIAutomationPropertyChangedEventHandler_Value = Guid.initString("40cd37d4-c756-4b0c-8c6f-bddfeeb13b50");
pub const IID_IUIAutomationPropertyChangedEventHandler = &IID_IUIAutomationPropertyChangedEventHandler_Value;
pub const IUIAutomationPropertyChangedEventHandler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        HandlePropertyChangedEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationPropertyChangedEventHandler,
                sender: ?*IUIAutomationElement,
                propertyId: i32,
                newValue: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationPropertyChangedEventHandler,
                sender: ?*IUIAutomationElement,
                propertyId: i32,
                newValue: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationPropertyChangedEventHandler_HandlePropertyChangedEvent(self: *const T, sender: ?*IUIAutomationElement, propertyId: i32, newValue: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationPropertyChangedEventHandler.VTable, self.vtable).HandlePropertyChangedEvent(@ptrCast(*const IUIAutomationPropertyChangedEventHandler, self), sender, propertyId, newValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IUIAutomationStructureChangedEventHandler_Value = Guid.initString("e81d1b4e-11c5-42f8-9754-e7036c79f054");
pub const IID_IUIAutomationStructureChangedEventHandler = &IID_IUIAutomationStructureChangedEventHandler_Value;
pub const IUIAutomationStructureChangedEventHandler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        HandleStructureChangedEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationStructureChangedEventHandler,
                sender: ?*IUIAutomationElement,
                changeType: StructureChangeType,
                runtimeId: ?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationStructureChangedEventHandler,
                sender: ?*IUIAutomationElement,
                changeType: StructureChangeType,
                runtimeId: ?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationStructureChangedEventHandler_HandleStructureChangedEvent(self: *const T, sender: ?*IUIAutomationElement, changeType: StructureChangeType, runtimeId: ?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationStructureChangedEventHandler.VTable, self.vtable).HandleStructureChangedEvent(@ptrCast(*const IUIAutomationStructureChangedEventHandler, self), sender, changeType, runtimeId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IUIAutomationFocusChangedEventHandler_Value = Guid.initString("c270f6b5-5c69-4290-9745-7a7f97169468");
pub const IID_IUIAutomationFocusChangedEventHandler = &IID_IUIAutomationFocusChangedEventHandler_Value;
pub const IUIAutomationFocusChangedEventHandler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        HandleFocusChangedEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationFocusChangedEventHandler,
                sender: ?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationFocusChangedEventHandler,
                sender: ?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationFocusChangedEventHandler_HandleFocusChangedEvent(self: *const T, sender: ?*IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationFocusChangedEventHandler.VTable, self.vtable).HandleFocusChangedEvent(@ptrCast(*const IUIAutomationFocusChangedEventHandler, self), sender);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.1'
const IID_IUIAutomationTextEditTextChangedEventHandler_Value = Guid.initString("92faa680-e704-4156-931a-e32d5bb38f3f");
pub const IID_IUIAutomationTextEditTextChangedEventHandler = &IID_IUIAutomationTextEditTextChangedEventHandler_Value;
pub const IUIAutomationTextEditTextChangedEventHandler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        HandleTextEditTextChangedEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationTextEditTextChangedEventHandler,
                sender: ?*IUIAutomationElement,
                textEditChangeType: TextEditChangeType,
                eventStrings: ?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationTextEditTextChangedEventHandler,
                sender: ?*IUIAutomationElement,
                textEditChangeType: TextEditChangeType,
                eventStrings: ?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTextEditTextChangedEventHandler_HandleTextEditTextChangedEvent(self: *const T, sender: ?*IUIAutomationElement, textEditChangeType: TextEditChangeType, eventStrings: ?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTextEditTextChangedEventHandler.VTable, self.vtable).HandleTextEditTextChangedEvent(@ptrCast(*const IUIAutomationTextEditTextChangedEventHandler, self), sender, textEditChangeType, eventStrings);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.15063'
const IID_IUIAutomationChangesEventHandler_Value = Guid.initString("58edca55-2c3e-4980-b1b9-56c17f27a2a0");
pub const IID_IUIAutomationChangesEventHandler = &IID_IUIAutomationChangesEventHandler_Value;
pub const IUIAutomationChangesEventHandler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        HandleChangesEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationChangesEventHandler,
                sender: ?*IUIAutomationElement,
                uiaChanges: [*]UiaChangeInfo,
                changesCount: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationChangesEventHandler,
                sender: ?*IUIAutomationElement,
                uiaChanges: [*]UiaChangeInfo,
                changesCount: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationChangesEventHandler_HandleChangesEvent(self: *const T, sender: ?*IUIAutomationElement, uiaChanges: [*]UiaChangeInfo, changesCount: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationChangesEventHandler.VTable, self.vtable).HandleChangesEvent(@ptrCast(*const IUIAutomationChangesEventHandler, self), sender, uiaChanges, changesCount);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.16299'
const IID_IUIAutomationNotificationEventHandler_Value = Guid.initString("c7cb2637-e6c2-4d0c-85de-4948c02175c7");
pub const IID_IUIAutomationNotificationEventHandler = &IID_IUIAutomationNotificationEventHandler_Value;
pub const IUIAutomationNotificationEventHandler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        HandleNotificationEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationNotificationEventHandler,
                sender: ?*IUIAutomationElement,
                notificationKind: NotificationKind,
                notificationProcessing: NotificationProcessing,
                displayString: ?BSTR,
                activityId: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationNotificationEventHandler,
                sender: ?*IUIAutomationElement,
                notificationKind: NotificationKind,
                notificationProcessing: NotificationProcessing,
                displayString: ?BSTR,
                activityId: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationNotificationEventHandler_HandleNotificationEvent(self: *const T, sender: ?*IUIAutomationElement, notificationKind: NotificationKind, notificationProcessing: NotificationProcessing, displayString: ?BSTR, activityId: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationNotificationEventHandler.VTable, self.vtable).HandleNotificationEvent(@ptrCast(*const IUIAutomationNotificationEventHandler, self), sender, notificationKind, notificationProcessing, displayString, activityId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IUIAutomationInvokePattern_Value = Guid.initString("fb377fbe-8ea6-46d5-9c73-6499642d3059");
pub const IID_IUIAutomationInvokePattern = &IID_IUIAutomationInvokePattern_Value;
pub const IUIAutomationInvokePattern = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Invoke: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationInvokePattern,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationInvokePattern,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationInvokePattern_Invoke(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationInvokePattern.VTable, self.vtable).Invoke(@ptrCast(*const IUIAutomationInvokePattern, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IUIAutomationDockPattern_Value = Guid.initString("fde5ef97-1464-48f6-90bf-43d0948e86ec");
pub const IID_IUIAutomationDockPattern = &IID_IUIAutomationDockPattern_Value;
pub const IUIAutomationDockPattern = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetDockPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationDockPattern,
                dockPos: DockPosition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationDockPattern,
                dockPos: DockPosition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentDockPosition: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationDockPattern,
                retVal: ?*DockPosition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationDockPattern,
                retVal: ?*DockPosition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedDockPosition: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationDockPattern,
                retVal: ?*DockPosition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationDockPattern,
                retVal: ?*DockPosition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationDockPattern_SetDockPosition(self: *const T, dockPos: DockPosition) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationDockPattern.VTable, self.vtable).SetDockPosition(@ptrCast(*const IUIAutomationDockPattern, self), dockPos);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationDockPattern_get_CurrentDockPosition(self: *const T, retVal: ?*DockPosition) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationDockPattern.VTable, self.vtable).get_CurrentDockPosition(@ptrCast(*const IUIAutomationDockPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationDockPattern_get_CachedDockPosition(self: *const T, retVal: ?*DockPosition) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationDockPattern.VTable, self.vtable).get_CachedDockPosition(@ptrCast(*const IUIAutomationDockPattern, self), retVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IUIAutomationExpandCollapsePattern_Value = Guid.initString("619be086-1f4e-4ee4-bafa-210128738730");
pub const IID_IUIAutomationExpandCollapsePattern = &IID_IUIAutomationExpandCollapsePattern_Value;
pub const IUIAutomationExpandCollapsePattern = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Expand: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationExpandCollapsePattern,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationExpandCollapsePattern,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Collapse: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationExpandCollapsePattern,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationExpandCollapsePattern,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentExpandCollapseState: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationExpandCollapsePattern,
                retVal: ?*ExpandCollapseState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationExpandCollapsePattern,
                retVal: ?*ExpandCollapseState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedExpandCollapseState: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationExpandCollapsePattern,
                retVal: ?*ExpandCollapseState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationExpandCollapsePattern,
                retVal: ?*ExpandCollapseState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationExpandCollapsePattern_Expand(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationExpandCollapsePattern.VTable, self.vtable).Expand(@ptrCast(*const IUIAutomationExpandCollapsePattern, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationExpandCollapsePattern_Collapse(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationExpandCollapsePattern.VTable, self.vtable).Collapse(@ptrCast(*const IUIAutomationExpandCollapsePattern, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationExpandCollapsePattern_get_CurrentExpandCollapseState(self: *const T, retVal: ?*ExpandCollapseState) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationExpandCollapsePattern.VTable, self.vtable).get_CurrentExpandCollapseState(@ptrCast(*const IUIAutomationExpandCollapsePattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationExpandCollapsePattern_get_CachedExpandCollapseState(self: *const T, retVal: ?*ExpandCollapseState) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationExpandCollapsePattern.VTable, self.vtable).get_CachedExpandCollapseState(@ptrCast(*const IUIAutomationExpandCollapsePattern, self), retVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IUIAutomationGridPattern_Value = Guid.initString("414c3cdc-856b-4f5b-8538-3131c6302550");
pub const IID_IUIAutomationGridPattern = &IID_IUIAutomationGridPattern_Value;
pub const IUIAutomationGridPattern = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationGridPattern,
                row: i32,
                column: i32,
                element: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationGridPattern,
                row: i32,
                column: i32,
                element: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentRowCount: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationGridPattern,
                retVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationGridPattern,
                retVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentColumnCount: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationGridPattern,
                retVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationGridPattern,
                retVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedRowCount: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationGridPattern,
                retVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationGridPattern,
                retVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedColumnCount: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationGridPattern,
                retVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationGridPattern,
                retVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationGridPattern_GetItem(self: *const T, row: i32, column: i32, element: ?*?*IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationGridPattern.VTable, self.vtable).GetItem(@ptrCast(*const IUIAutomationGridPattern, self), row, column, element);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationGridPattern_get_CurrentRowCount(self: *const T, retVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationGridPattern.VTable, self.vtable).get_CurrentRowCount(@ptrCast(*const IUIAutomationGridPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationGridPattern_get_CurrentColumnCount(self: *const T, retVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationGridPattern.VTable, self.vtable).get_CurrentColumnCount(@ptrCast(*const IUIAutomationGridPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationGridPattern_get_CachedRowCount(self: *const T, retVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationGridPattern.VTable, self.vtable).get_CachedRowCount(@ptrCast(*const IUIAutomationGridPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationGridPattern_get_CachedColumnCount(self: *const T, retVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationGridPattern.VTable, self.vtable).get_CachedColumnCount(@ptrCast(*const IUIAutomationGridPattern, self), retVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IUIAutomationGridItemPattern_Value = Guid.initString("78f8ef57-66c3-4e09-bd7c-e79b2004894d");
pub const IID_IUIAutomationGridItemPattern = &IID_IUIAutomationGridItemPattern_Value;
pub const IUIAutomationGridItemPattern = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentContainingGrid: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationGridItemPattern,
                retVal: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationGridItemPattern,
                retVal: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentRow: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationGridItemPattern,
                retVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationGridItemPattern,
                retVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentColumn: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationGridItemPattern,
                retVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationGridItemPattern,
                retVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentRowSpan: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationGridItemPattern,
                retVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationGridItemPattern,
                retVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentColumnSpan: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationGridItemPattern,
                retVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationGridItemPattern,
                retVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedContainingGrid: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationGridItemPattern,
                retVal: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationGridItemPattern,
                retVal: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedRow: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationGridItemPattern,
                retVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationGridItemPattern,
                retVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedColumn: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationGridItemPattern,
                retVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationGridItemPattern,
                retVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedRowSpan: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationGridItemPattern,
                retVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationGridItemPattern,
                retVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedColumnSpan: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationGridItemPattern,
                retVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationGridItemPattern,
                retVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationGridItemPattern_get_CurrentContainingGrid(self: *const T, retVal: ?*?*IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationGridItemPattern.VTable, self.vtable).get_CurrentContainingGrid(@ptrCast(*const IUIAutomationGridItemPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationGridItemPattern_get_CurrentRow(self: *const T, retVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationGridItemPattern.VTable, self.vtable).get_CurrentRow(@ptrCast(*const IUIAutomationGridItemPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationGridItemPattern_get_CurrentColumn(self: *const T, retVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationGridItemPattern.VTable, self.vtable).get_CurrentColumn(@ptrCast(*const IUIAutomationGridItemPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationGridItemPattern_get_CurrentRowSpan(self: *const T, retVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationGridItemPattern.VTable, self.vtable).get_CurrentRowSpan(@ptrCast(*const IUIAutomationGridItemPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationGridItemPattern_get_CurrentColumnSpan(self: *const T, retVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationGridItemPattern.VTable, self.vtable).get_CurrentColumnSpan(@ptrCast(*const IUIAutomationGridItemPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationGridItemPattern_get_CachedContainingGrid(self: *const T, retVal: ?*?*IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationGridItemPattern.VTable, self.vtable).get_CachedContainingGrid(@ptrCast(*const IUIAutomationGridItemPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationGridItemPattern_get_CachedRow(self: *const T, retVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationGridItemPattern.VTable, self.vtable).get_CachedRow(@ptrCast(*const IUIAutomationGridItemPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationGridItemPattern_get_CachedColumn(self: *const T, retVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationGridItemPattern.VTable, self.vtable).get_CachedColumn(@ptrCast(*const IUIAutomationGridItemPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationGridItemPattern_get_CachedRowSpan(self: *const T, retVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationGridItemPattern.VTable, self.vtable).get_CachedRowSpan(@ptrCast(*const IUIAutomationGridItemPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationGridItemPattern_get_CachedColumnSpan(self: *const T, retVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationGridItemPattern.VTable, self.vtable).get_CachedColumnSpan(@ptrCast(*const IUIAutomationGridItemPattern, self), retVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IUIAutomationMultipleViewPattern_Value = Guid.initString("8d253c91-1dc5-4bb5-b18f-ade16fa495e8");
pub const IID_IUIAutomationMultipleViewPattern = &IID_IUIAutomationMultipleViewPattern_Value;
pub const IUIAutomationMultipleViewPattern = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetViewName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationMultipleViewPattern,
                view: i32,
                name: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationMultipleViewPattern,
                view: i32,
                name: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCurrentView: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationMultipleViewPattern,
                view: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationMultipleViewPattern,
                view: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentCurrentView: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationMultipleViewPattern,
                retVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationMultipleViewPattern,
                retVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentSupportedViews: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationMultipleViewPattern,
                retVal: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationMultipleViewPattern,
                retVal: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedCurrentView: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationMultipleViewPattern,
                retVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationMultipleViewPattern,
                retVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCachedSupportedViews: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationMultipleViewPattern,
                retVal: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationMultipleViewPattern,
                retVal: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationMultipleViewPattern_GetViewName(self: *const T, view: i32, name: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationMultipleViewPattern.VTable, self.vtable).GetViewName(@ptrCast(*const IUIAutomationMultipleViewPattern, self), view, name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationMultipleViewPattern_SetCurrentView(self: *const T, view: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationMultipleViewPattern.VTable, self.vtable).SetCurrentView(@ptrCast(*const IUIAutomationMultipleViewPattern, self), view);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationMultipleViewPattern_get_CurrentCurrentView(self: *const T, retVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationMultipleViewPattern.VTable, self.vtable).get_CurrentCurrentView(@ptrCast(*const IUIAutomationMultipleViewPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationMultipleViewPattern_GetCurrentSupportedViews(self: *const T, retVal: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationMultipleViewPattern.VTable, self.vtable).GetCurrentSupportedViews(@ptrCast(*const IUIAutomationMultipleViewPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationMultipleViewPattern_get_CachedCurrentView(self: *const T, retVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationMultipleViewPattern.VTable, self.vtable).get_CachedCurrentView(@ptrCast(*const IUIAutomationMultipleViewPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationMultipleViewPattern_GetCachedSupportedViews(self: *const T, retVal: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationMultipleViewPattern.VTable, self.vtable).GetCachedSupportedViews(@ptrCast(*const IUIAutomationMultipleViewPattern, self), retVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IUIAutomationObjectModelPattern_Value = Guid.initString("71c284b3-c14d-4d14-981e-19751b0d756d");
pub const IID_IUIAutomationObjectModelPattern = &IID_IUIAutomationObjectModelPattern_Value;
pub const IUIAutomationObjectModelPattern = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetUnderlyingObjectModel: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationObjectModelPattern,
                retVal: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationObjectModelPattern,
                retVal: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationObjectModelPattern_GetUnderlyingObjectModel(self: *const T, retVal: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationObjectModelPattern.VTable, self.vtable).GetUnderlyingObjectModel(@ptrCast(*const IUIAutomationObjectModelPattern, self), retVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IUIAutomationRangeValuePattern_Value = Guid.initString("59213f4f-7346-49e5-b120-80555987a148");
pub const IID_IUIAutomationRangeValuePattern = &IID_IUIAutomationRangeValuePattern_Value;
pub const IUIAutomationRangeValuePattern = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationRangeValuePattern,
                val: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationRangeValuePattern,
                val: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentValue: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationRangeValuePattern,
                retVal: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationRangeValuePattern,
                retVal: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentIsReadOnly: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationRangeValuePattern,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationRangeValuePattern,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentMaximum: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationRangeValuePattern,
                retVal: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationRangeValuePattern,
                retVal: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentMinimum: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationRangeValuePattern,
                retVal: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationRangeValuePattern,
                retVal: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentLargeChange: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationRangeValuePattern,
                retVal: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationRangeValuePattern,
                retVal: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentSmallChange: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationRangeValuePattern,
                retVal: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationRangeValuePattern,
                retVal: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedValue: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationRangeValuePattern,
                retVal: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationRangeValuePattern,
                retVal: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedIsReadOnly: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationRangeValuePattern,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationRangeValuePattern,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedMaximum: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationRangeValuePattern,
                retVal: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationRangeValuePattern,
                retVal: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedMinimum: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationRangeValuePattern,
                retVal: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationRangeValuePattern,
                retVal: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedLargeChange: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationRangeValuePattern,
                retVal: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationRangeValuePattern,
                retVal: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedSmallChange: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationRangeValuePattern,
                retVal: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationRangeValuePattern,
                retVal: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationRangeValuePattern_SetValue(self: *const T, val: f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationRangeValuePattern.VTable, self.vtable).SetValue(@ptrCast(*const IUIAutomationRangeValuePattern, self), val);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationRangeValuePattern_get_CurrentValue(self: *const T, retVal: ?*f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationRangeValuePattern.VTable, self.vtable).get_CurrentValue(@ptrCast(*const IUIAutomationRangeValuePattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationRangeValuePattern_get_CurrentIsReadOnly(self: *const T, retVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationRangeValuePattern.VTable, self.vtable).get_CurrentIsReadOnly(@ptrCast(*const IUIAutomationRangeValuePattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationRangeValuePattern_get_CurrentMaximum(self: *const T, retVal: ?*f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationRangeValuePattern.VTable, self.vtable).get_CurrentMaximum(@ptrCast(*const IUIAutomationRangeValuePattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationRangeValuePattern_get_CurrentMinimum(self: *const T, retVal: ?*f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationRangeValuePattern.VTable, self.vtable).get_CurrentMinimum(@ptrCast(*const IUIAutomationRangeValuePattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationRangeValuePattern_get_CurrentLargeChange(self: *const T, retVal: ?*f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationRangeValuePattern.VTable, self.vtable).get_CurrentLargeChange(@ptrCast(*const IUIAutomationRangeValuePattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationRangeValuePattern_get_CurrentSmallChange(self: *const T, retVal: ?*f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationRangeValuePattern.VTable, self.vtable).get_CurrentSmallChange(@ptrCast(*const IUIAutomationRangeValuePattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationRangeValuePattern_get_CachedValue(self: *const T, retVal: ?*f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationRangeValuePattern.VTable, self.vtable).get_CachedValue(@ptrCast(*const IUIAutomationRangeValuePattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationRangeValuePattern_get_CachedIsReadOnly(self: *const T, retVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationRangeValuePattern.VTable, self.vtable).get_CachedIsReadOnly(@ptrCast(*const IUIAutomationRangeValuePattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationRangeValuePattern_get_CachedMaximum(self: *const T, retVal: ?*f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationRangeValuePattern.VTable, self.vtable).get_CachedMaximum(@ptrCast(*const IUIAutomationRangeValuePattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationRangeValuePattern_get_CachedMinimum(self: *const T, retVal: ?*f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationRangeValuePattern.VTable, self.vtable).get_CachedMinimum(@ptrCast(*const IUIAutomationRangeValuePattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationRangeValuePattern_get_CachedLargeChange(self: *const T, retVal: ?*f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationRangeValuePattern.VTable, self.vtable).get_CachedLargeChange(@ptrCast(*const IUIAutomationRangeValuePattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationRangeValuePattern_get_CachedSmallChange(self: *const T, retVal: ?*f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationRangeValuePattern.VTable, self.vtable).get_CachedSmallChange(@ptrCast(*const IUIAutomationRangeValuePattern, self), retVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IUIAutomationScrollPattern_Value = Guid.initString("88f4d42a-e881-459d-a77c-73bbbb7e02dc");
pub const IID_IUIAutomationScrollPattern = &IID_IUIAutomationScrollPattern_Value;
pub const IUIAutomationScrollPattern = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Scroll: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationScrollPattern,
                horizontalAmount: ScrollAmount,
                verticalAmount: ScrollAmount,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationScrollPattern,
                horizontalAmount: ScrollAmount,
                verticalAmount: ScrollAmount,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetScrollPercent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationScrollPattern,
                horizontalPercent: f64,
                verticalPercent: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationScrollPattern,
                horizontalPercent: f64,
                verticalPercent: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentHorizontalScrollPercent: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationScrollPattern,
                retVal: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationScrollPattern,
                retVal: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentVerticalScrollPercent: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationScrollPattern,
                retVal: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationScrollPattern,
                retVal: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentHorizontalViewSize: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationScrollPattern,
                retVal: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationScrollPattern,
                retVal: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentVerticalViewSize: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationScrollPattern,
                retVal: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationScrollPattern,
                retVal: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentHorizontallyScrollable: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationScrollPattern,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationScrollPattern,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentVerticallyScrollable: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationScrollPattern,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationScrollPattern,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedHorizontalScrollPercent: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationScrollPattern,
                retVal: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationScrollPattern,
                retVal: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedVerticalScrollPercent: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationScrollPattern,
                retVal: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationScrollPattern,
                retVal: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedHorizontalViewSize: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationScrollPattern,
                retVal: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationScrollPattern,
                retVal: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedVerticalViewSize: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationScrollPattern,
                retVal: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationScrollPattern,
                retVal: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedHorizontallyScrollable: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationScrollPattern,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationScrollPattern,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedVerticallyScrollable: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationScrollPattern,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationScrollPattern,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationScrollPattern_Scroll(self: *const T, horizontalAmount: ScrollAmount, verticalAmount: ScrollAmount) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationScrollPattern.VTable, self.vtable).Scroll(@ptrCast(*const IUIAutomationScrollPattern, self), horizontalAmount, verticalAmount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationScrollPattern_SetScrollPercent(self: *const T, horizontalPercent: f64, verticalPercent: f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationScrollPattern.VTable, self.vtable).SetScrollPercent(@ptrCast(*const IUIAutomationScrollPattern, self), horizontalPercent, verticalPercent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationScrollPattern_get_CurrentHorizontalScrollPercent(self: *const T, retVal: ?*f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationScrollPattern.VTable, self.vtable).get_CurrentHorizontalScrollPercent(@ptrCast(*const IUIAutomationScrollPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationScrollPattern_get_CurrentVerticalScrollPercent(self: *const T, retVal: ?*f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationScrollPattern.VTable, self.vtable).get_CurrentVerticalScrollPercent(@ptrCast(*const IUIAutomationScrollPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationScrollPattern_get_CurrentHorizontalViewSize(self: *const T, retVal: ?*f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationScrollPattern.VTable, self.vtable).get_CurrentHorizontalViewSize(@ptrCast(*const IUIAutomationScrollPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationScrollPattern_get_CurrentVerticalViewSize(self: *const T, retVal: ?*f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationScrollPattern.VTable, self.vtable).get_CurrentVerticalViewSize(@ptrCast(*const IUIAutomationScrollPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationScrollPattern_get_CurrentHorizontallyScrollable(self: *const T, retVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationScrollPattern.VTable, self.vtable).get_CurrentHorizontallyScrollable(@ptrCast(*const IUIAutomationScrollPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationScrollPattern_get_CurrentVerticallyScrollable(self: *const T, retVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationScrollPattern.VTable, self.vtable).get_CurrentVerticallyScrollable(@ptrCast(*const IUIAutomationScrollPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationScrollPattern_get_CachedHorizontalScrollPercent(self: *const T, retVal: ?*f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationScrollPattern.VTable, self.vtable).get_CachedHorizontalScrollPercent(@ptrCast(*const IUIAutomationScrollPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationScrollPattern_get_CachedVerticalScrollPercent(self: *const T, retVal: ?*f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationScrollPattern.VTable, self.vtable).get_CachedVerticalScrollPercent(@ptrCast(*const IUIAutomationScrollPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationScrollPattern_get_CachedHorizontalViewSize(self: *const T, retVal: ?*f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationScrollPattern.VTable, self.vtable).get_CachedHorizontalViewSize(@ptrCast(*const IUIAutomationScrollPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationScrollPattern_get_CachedVerticalViewSize(self: *const T, retVal: ?*f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationScrollPattern.VTable, self.vtable).get_CachedVerticalViewSize(@ptrCast(*const IUIAutomationScrollPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationScrollPattern_get_CachedHorizontallyScrollable(self: *const T, retVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationScrollPattern.VTable, self.vtable).get_CachedHorizontallyScrollable(@ptrCast(*const IUIAutomationScrollPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationScrollPattern_get_CachedVerticallyScrollable(self: *const T, retVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationScrollPattern.VTable, self.vtable).get_CachedVerticallyScrollable(@ptrCast(*const IUIAutomationScrollPattern, self), retVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IUIAutomationScrollItemPattern_Value = Guid.initString("b488300f-d015-4f19-9c29-bb595e3645ef");
pub const IID_IUIAutomationScrollItemPattern = &IID_IUIAutomationScrollItemPattern_Value;
pub const IUIAutomationScrollItemPattern = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ScrollIntoView: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationScrollItemPattern,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationScrollItemPattern,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationScrollItemPattern_ScrollIntoView(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationScrollItemPattern.VTable, self.vtable).ScrollIntoView(@ptrCast(*const IUIAutomationScrollItemPattern, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IUIAutomationSelectionPattern_Value = Guid.initString("5ed5202e-b2ac-47a6-b638-4b0bf140d78e");
pub const IID_IUIAutomationSelectionPattern = &IID_IUIAutomationSelectionPattern_Value;
pub const IUIAutomationSelectionPattern = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCurrentSelection: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationSelectionPattern,
                retVal: ?*?*IUIAutomationElementArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationSelectionPattern,
                retVal: ?*?*IUIAutomationElementArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentCanSelectMultiple: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationSelectionPattern,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationSelectionPattern,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentIsSelectionRequired: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationSelectionPattern,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationSelectionPattern,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCachedSelection: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationSelectionPattern,
                retVal: ?*?*IUIAutomationElementArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationSelectionPattern,
                retVal: ?*?*IUIAutomationElementArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedCanSelectMultiple: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationSelectionPattern,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationSelectionPattern,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedIsSelectionRequired: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationSelectionPattern,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationSelectionPattern,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationSelectionPattern_GetCurrentSelection(self: *const T, retVal: ?*?*IUIAutomationElementArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationSelectionPattern.VTable, self.vtable).GetCurrentSelection(@ptrCast(*const IUIAutomationSelectionPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationSelectionPattern_get_CurrentCanSelectMultiple(self: *const T, retVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationSelectionPattern.VTable, self.vtable).get_CurrentCanSelectMultiple(@ptrCast(*const IUIAutomationSelectionPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationSelectionPattern_get_CurrentIsSelectionRequired(self: *const T, retVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationSelectionPattern.VTable, self.vtable).get_CurrentIsSelectionRequired(@ptrCast(*const IUIAutomationSelectionPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationSelectionPattern_GetCachedSelection(self: *const T, retVal: ?*?*IUIAutomationElementArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationSelectionPattern.VTable, self.vtable).GetCachedSelection(@ptrCast(*const IUIAutomationSelectionPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationSelectionPattern_get_CachedCanSelectMultiple(self: *const T, retVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationSelectionPattern.VTable, self.vtable).get_CachedCanSelectMultiple(@ptrCast(*const IUIAutomationSelectionPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationSelectionPattern_get_CachedIsSelectionRequired(self: *const T, retVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationSelectionPattern.VTable, self.vtable).get_CachedIsSelectionRequired(@ptrCast(*const IUIAutomationSelectionPattern, self), retVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.16299'
const IID_IUIAutomationSelectionPattern2_Value = Guid.initString("0532bfae-c011-4e32-a343-6d642d798555");
pub const IID_IUIAutomationSelectionPattern2 = &IID_IUIAutomationSelectionPattern2_Value;
pub const IUIAutomationSelectionPattern2 = extern struct {
    pub const VTable = extern struct {
        base: IUIAutomationSelectionPattern.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentFirstSelectedItem: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationSelectionPattern2,
                retVal: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationSelectionPattern2,
                retVal: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentLastSelectedItem: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationSelectionPattern2,
                retVal: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationSelectionPattern2,
                retVal: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentCurrentSelectedItem: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationSelectionPattern2,
                retVal: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationSelectionPattern2,
                retVal: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentItemCount: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationSelectionPattern2,
                retVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationSelectionPattern2,
                retVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedFirstSelectedItem: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationSelectionPattern2,
                retVal: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationSelectionPattern2,
                retVal: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedLastSelectedItem: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationSelectionPattern2,
                retVal: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationSelectionPattern2,
                retVal: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedCurrentSelectedItem: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationSelectionPattern2,
                retVal: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationSelectionPattern2,
                retVal: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedItemCount: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationSelectionPattern2,
                retVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationSelectionPattern2,
                retVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUIAutomationSelectionPattern.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationSelectionPattern2_get_CurrentFirstSelectedItem(self: *const T, retVal: ?*?*IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationSelectionPattern2.VTable, self.vtable).get_CurrentFirstSelectedItem(@ptrCast(*const IUIAutomationSelectionPattern2, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationSelectionPattern2_get_CurrentLastSelectedItem(self: *const T, retVal: ?*?*IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationSelectionPattern2.VTable, self.vtable).get_CurrentLastSelectedItem(@ptrCast(*const IUIAutomationSelectionPattern2, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationSelectionPattern2_get_CurrentCurrentSelectedItem(self: *const T, retVal: ?*?*IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationSelectionPattern2.VTable, self.vtable).get_CurrentCurrentSelectedItem(@ptrCast(*const IUIAutomationSelectionPattern2, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationSelectionPattern2_get_CurrentItemCount(self: *const T, retVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationSelectionPattern2.VTable, self.vtable).get_CurrentItemCount(@ptrCast(*const IUIAutomationSelectionPattern2, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationSelectionPattern2_get_CachedFirstSelectedItem(self: *const T, retVal: ?*?*IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationSelectionPattern2.VTable, self.vtable).get_CachedFirstSelectedItem(@ptrCast(*const IUIAutomationSelectionPattern2, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationSelectionPattern2_get_CachedLastSelectedItem(self: *const T, retVal: ?*?*IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationSelectionPattern2.VTable, self.vtable).get_CachedLastSelectedItem(@ptrCast(*const IUIAutomationSelectionPattern2, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationSelectionPattern2_get_CachedCurrentSelectedItem(self: *const T, retVal: ?*?*IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationSelectionPattern2.VTable, self.vtable).get_CachedCurrentSelectedItem(@ptrCast(*const IUIAutomationSelectionPattern2, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationSelectionPattern2_get_CachedItemCount(self: *const T, retVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationSelectionPattern2.VTable, self.vtable).get_CachedItemCount(@ptrCast(*const IUIAutomationSelectionPattern2, self), retVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IUIAutomationSelectionItemPattern_Value = Guid.initString("a8efa66a-0fda-421a-9194-38021f3578ea");
pub const IID_IUIAutomationSelectionItemPattern = &IID_IUIAutomationSelectionItemPattern_Value;
pub const IUIAutomationSelectionItemPattern = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Select: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationSelectionItemPattern,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationSelectionItemPattern,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddToSelection: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationSelectionItemPattern,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationSelectionItemPattern,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveFromSelection: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationSelectionItemPattern,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationSelectionItemPattern,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentIsSelected: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationSelectionItemPattern,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationSelectionItemPattern,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentSelectionContainer: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationSelectionItemPattern,
                retVal: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationSelectionItemPattern,
                retVal: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedIsSelected: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationSelectionItemPattern,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationSelectionItemPattern,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedSelectionContainer: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationSelectionItemPattern,
                retVal: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationSelectionItemPattern,
                retVal: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationSelectionItemPattern_Select(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationSelectionItemPattern.VTable, self.vtable).Select(@ptrCast(*const IUIAutomationSelectionItemPattern, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationSelectionItemPattern_AddToSelection(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationSelectionItemPattern.VTable, self.vtable).AddToSelection(@ptrCast(*const IUIAutomationSelectionItemPattern, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationSelectionItemPattern_RemoveFromSelection(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationSelectionItemPattern.VTable, self.vtable).RemoveFromSelection(@ptrCast(*const IUIAutomationSelectionItemPattern, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationSelectionItemPattern_get_CurrentIsSelected(self: *const T, retVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationSelectionItemPattern.VTable, self.vtable).get_CurrentIsSelected(@ptrCast(*const IUIAutomationSelectionItemPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationSelectionItemPattern_get_CurrentSelectionContainer(self: *const T, retVal: ?*?*IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationSelectionItemPattern.VTable, self.vtable).get_CurrentSelectionContainer(@ptrCast(*const IUIAutomationSelectionItemPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationSelectionItemPattern_get_CachedIsSelected(self: *const T, retVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationSelectionItemPattern.VTable, self.vtable).get_CachedIsSelected(@ptrCast(*const IUIAutomationSelectionItemPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationSelectionItemPattern_get_CachedSelectionContainer(self: *const T, retVal: ?*?*IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationSelectionItemPattern.VTable, self.vtable).get_CachedSelectionContainer(@ptrCast(*const IUIAutomationSelectionItemPattern, self), retVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IUIAutomationSynchronizedInputPattern_Value = Guid.initString("2233be0b-afb7-448b-9fda-3b378aa5eae1");
pub const IID_IUIAutomationSynchronizedInputPattern = &IID_IUIAutomationSynchronizedInputPattern_Value;
pub const IUIAutomationSynchronizedInputPattern = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        StartListening: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationSynchronizedInputPattern,
                inputType: SynchronizedInputType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationSynchronizedInputPattern,
                inputType: SynchronizedInputType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Cancel: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationSynchronizedInputPattern,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationSynchronizedInputPattern,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationSynchronizedInputPattern_StartListening(self: *const T, inputType: SynchronizedInputType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationSynchronizedInputPattern.VTable, self.vtable).StartListening(@ptrCast(*const IUIAutomationSynchronizedInputPattern, self), inputType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationSynchronizedInputPattern_Cancel(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationSynchronizedInputPattern.VTable, self.vtable).Cancel(@ptrCast(*const IUIAutomationSynchronizedInputPattern, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IUIAutomationTablePattern_Value = Guid.initString("620e691c-ea96-4710-a850-754b24ce2417");
pub const IID_IUIAutomationTablePattern = &IID_IUIAutomationTablePattern_Value;
pub const IUIAutomationTablePattern = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCurrentRowHeaders: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationTablePattern,
                retVal: ?*?*IUIAutomationElementArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationTablePattern,
                retVal: ?*?*IUIAutomationElementArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentColumnHeaders: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationTablePattern,
                retVal: ?*?*IUIAutomationElementArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationTablePattern,
                retVal: ?*?*IUIAutomationElementArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentRowOrColumnMajor: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationTablePattern,
                retVal: ?*RowOrColumnMajor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationTablePattern,
                retVal: ?*RowOrColumnMajor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCachedRowHeaders: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationTablePattern,
                retVal: ?*?*IUIAutomationElementArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationTablePattern,
                retVal: ?*?*IUIAutomationElementArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCachedColumnHeaders: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationTablePattern,
                retVal: ?*?*IUIAutomationElementArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationTablePattern,
                retVal: ?*?*IUIAutomationElementArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedRowOrColumnMajor: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationTablePattern,
                retVal: ?*RowOrColumnMajor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationTablePattern,
                retVal: ?*RowOrColumnMajor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTablePattern_GetCurrentRowHeaders(self: *const T, retVal: ?*?*IUIAutomationElementArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTablePattern.VTable, self.vtable).GetCurrentRowHeaders(@ptrCast(*const IUIAutomationTablePattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTablePattern_GetCurrentColumnHeaders(self: *const T, retVal: ?*?*IUIAutomationElementArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTablePattern.VTable, self.vtable).GetCurrentColumnHeaders(@ptrCast(*const IUIAutomationTablePattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTablePattern_get_CurrentRowOrColumnMajor(self: *const T, retVal: ?*RowOrColumnMajor) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTablePattern.VTable, self.vtable).get_CurrentRowOrColumnMajor(@ptrCast(*const IUIAutomationTablePattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTablePattern_GetCachedRowHeaders(self: *const T, retVal: ?*?*IUIAutomationElementArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTablePattern.VTable, self.vtable).GetCachedRowHeaders(@ptrCast(*const IUIAutomationTablePattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTablePattern_GetCachedColumnHeaders(self: *const T, retVal: ?*?*IUIAutomationElementArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTablePattern.VTable, self.vtable).GetCachedColumnHeaders(@ptrCast(*const IUIAutomationTablePattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTablePattern_get_CachedRowOrColumnMajor(self: *const T, retVal: ?*RowOrColumnMajor) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTablePattern.VTable, self.vtable).get_CachedRowOrColumnMajor(@ptrCast(*const IUIAutomationTablePattern, self), retVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IUIAutomationTableItemPattern_Value = Guid.initString("0b964eb3-ef2e-4464-9c79-61d61737a27e");
pub const IID_IUIAutomationTableItemPattern = &IID_IUIAutomationTableItemPattern_Value;
pub const IUIAutomationTableItemPattern = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCurrentRowHeaderItems: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationTableItemPattern,
                retVal: ?*?*IUIAutomationElementArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationTableItemPattern,
                retVal: ?*?*IUIAutomationElementArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentColumnHeaderItems: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationTableItemPattern,
                retVal: ?*?*IUIAutomationElementArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationTableItemPattern,
                retVal: ?*?*IUIAutomationElementArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCachedRowHeaderItems: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationTableItemPattern,
                retVal: ?*?*IUIAutomationElementArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationTableItemPattern,
                retVal: ?*?*IUIAutomationElementArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCachedColumnHeaderItems: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationTableItemPattern,
                retVal: ?*?*IUIAutomationElementArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationTableItemPattern,
                retVal: ?*?*IUIAutomationElementArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTableItemPattern_GetCurrentRowHeaderItems(self: *const T, retVal: ?*?*IUIAutomationElementArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTableItemPattern.VTable, self.vtable).GetCurrentRowHeaderItems(@ptrCast(*const IUIAutomationTableItemPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTableItemPattern_GetCurrentColumnHeaderItems(self: *const T, retVal: ?*?*IUIAutomationElementArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTableItemPattern.VTable, self.vtable).GetCurrentColumnHeaderItems(@ptrCast(*const IUIAutomationTableItemPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTableItemPattern_GetCachedRowHeaderItems(self: *const T, retVal: ?*?*IUIAutomationElementArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTableItemPattern.VTable, self.vtable).GetCachedRowHeaderItems(@ptrCast(*const IUIAutomationTableItemPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTableItemPattern_GetCachedColumnHeaderItems(self: *const T, retVal: ?*?*IUIAutomationElementArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTableItemPattern.VTable, self.vtable).GetCachedColumnHeaderItems(@ptrCast(*const IUIAutomationTableItemPattern, self), retVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IUIAutomationTogglePattern_Value = Guid.initString("94cf8058-9b8d-4ab9-8bfd-4cd0a33c8c70");
pub const IID_IUIAutomationTogglePattern = &IID_IUIAutomationTogglePattern_Value;
pub const IUIAutomationTogglePattern = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Toggle: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationTogglePattern,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationTogglePattern,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentToggleState: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationTogglePattern,
                retVal: ?*ToggleState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationTogglePattern,
                retVal: ?*ToggleState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedToggleState: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationTogglePattern,
                retVal: ?*ToggleState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationTogglePattern,
                retVal: ?*ToggleState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTogglePattern_Toggle(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTogglePattern.VTable, self.vtable).Toggle(@ptrCast(*const IUIAutomationTogglePattern, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTogglePattern_get_CurrentToggleState(self: *const T, retVal: ?*ToggleState) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTogglePattern.VTable, self.vtable).get_CurrentToggleState(@ptrCast(*const IUIAutomationTogglePattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTogglePattern_get_CachedToggleState(self: *const T, retVal: ?*ToggleState) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTogglePattern.VTable, self.vtable).get_CachedToggleState(@ptrCast(*const IUIAutomationTogglePattern, self), retVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IUIAutomationTransformPattern_Value = Guid.initString("a9b55844-a55d-4ef0-926d-569c16ff89bb");
pub const IID_IUIAutomationTransformPattern = &IID_IUIAutomationTransformPattern_Value;
pub const IUIAutomationTransformPattern = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Move: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationTransformPattern,
                x: f64,
                y: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationTransformPattern,
                x: f64,
                y: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Resize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationTransformPattern,
                width: f64,
                height: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationTransformPattern,
                width: f64,
                height: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Rotate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationTransformPattern,
                degrees: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationTransformPattern,
                degrees: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentCanMove: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationTransformPattern,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationTransformPattern,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentCanResize: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationTransformPattern,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationTransformPattern,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentCanRotate: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationTransformPattern,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationTransformPattern,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedCanMove: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationTransformPattern,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationTransformPattern,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedCanResize: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationTransformPattern,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationTransformPattern,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedCanRotate: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationTransformPattern,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationTransformPattern,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTransformPattern_Move(self: *const T, x: f64, y: f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTransformPattern.VTable, self.vtable).Move(@ptrCast(*const IUIAutomationTransformPattern, self), x, y);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTransformPattern_Resize(self: *const T, width: f64, height: f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTransformPattern.VTable, self.vtable).Resize(@ptrCast(*const IUIAutomationTransformPattern, self), width, height);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTransformPattern_Rotate(self: *const T, degrees: f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTransformPattern.VTable, self.vtable).Rotate(@ptrCast(*const IUIAutomationTransformPattern, self), degrees);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTransformPattern_get_CurrentCanMove(self: *const T, retVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTransformPattern.VTable, self.vtable).get_CurrentCanMove(@ptrCast(*const IUIAutomationTransformPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTransformPattern_get_CurrentCanResize(self: *const T, retVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTransformPattern.VTable, self.vtable).get_CurrentCanResize(@ptrCast(*const IUIAutomationTransformPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTransformPattern_get_CurrentCanRotate(self: *const T, retVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTransformPattern.VTable, self.vtable).get_CurrentCanRotate(@ptrCast(*const IUIAutomationTransformPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTransformPattern_get_CachedCanMove(self: *const T, retVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTransformPattern.VTable, self.vtable).get_CachedCanMove(@ptrCast(*const IUIAutomationTransformPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTransformPattern_get_CachedCanResize(self: *const T, retVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTransformPattern.VTable, self.vtable).get_CachedCanResize(@ptrCast(*const IUIAutomationTransformPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTransformPattern_get_CachedCanRotate(self: *const T, retVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTransformPattern.VTable, self.vtable).get_CachedCanRotate(@ptrCast(*const IUIAutomationTransformPattern, self), retVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IUIAutomationValuePattern_Value = Guid.initString("a94cd8b1-0844-4cd6-9d2d-640537ab39e9");
pub const IID_IUIAutomationValuePattern = &IID_IUIAutomationValuePattern_Value;
pub const IUIAutomationValuePattern = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationValuePattern,
                val: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationValuePattern,
                val: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentValue: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationValuePattern,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationValuePattern,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentIsReadOnly: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationValuePattern,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationValuePattern,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedValue: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationValuePattern,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationValuePattern,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedIsReadOnly: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationValuePattern,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationValuePattern,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationValuePattern_SetValue(self: *const T, val: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationValuePattern.VTable, self.vtable).SetValue(@ptrCast(*const IUIAutomationValuePattern, self), val);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationValuePattern_get_CurrentValue(self: *const T, retVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationValuePattern.VTable, self.vtable).get_CurrentValue(@ptrCast(*const IUIAutomationValuePattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationValuePattern_get_CurrentIsReadOnly(self: *const T, retVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationValuePattern.VTable, self.vtable).get_CurrentIsReadOnly(@ptrCast(*const IUIAutomationValuePattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationValuePattern_get_CachedValue(self: *const T, retVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationValuePattern.VTable, self.vtable).get_CachedValue(@ptrCast(*const IUIAutomationValuePattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationValuePattern_get_CachedIsReadOnly(self: *const T, retVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationValuePattern.VTable, self.vtable).get_CachedIsReadOnly(@ptrCast(*const IUIAutomationValuePattern, self), retVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IUIAutomationWindowPattern_Value = Guid.initString("0faef453-9208-43ef-bbb2-3b485177864f");
pub const IID_IUIAutomationWindowPattern = &IID_IUIAutomationWindowPattern_Value;
pub const IUIAutomationWindowPattern = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Close: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationWindowPattern,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationWindowPattern,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WaitForInputIdle: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationWindowPattern,
                milliseconds: i32,
                success: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationWindowPattern,
                milliseconds: i32,
                success: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetWindowVisualState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationWindowPattern,
                state: WindowVisualState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationWindowPattern,
                state: WindowVisualState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentCanMaximize: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationWindowPattern,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationWindowPattern,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentCanMinimize: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationWindowPattern,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationWindowPattern,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentIsModal: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationWindowPattern,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationWindowPattern,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentIsTopmost: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationWindowPattern,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationWindowPattern,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentWindowVisualState: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationWindowPattern,
                retVal: ?*WindowVisualState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationWindowPattern,
                retVal: ?*WindowVisualState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentWindowInteractionState: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationWindowPattern,
                retVal: ?*WindowInteractionState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationWindowPattern,
                retVal: ?*WindowInteractionState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedCanMaximize: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationWindowPattern,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationWindowPattern,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedCanMinimize: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationWindowPattern,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationWindowPattern,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedIsModal: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationWindowPattern,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationWindowPattern,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedIsTopmost: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationWindowPattern,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationWindowPattern,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedWindowVisualState: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationWindowPattern,
                retVal: ?*WindowVisualState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationWindowPattern,
                retVal: ?*WindowVisualState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedWindowInteractionState: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationWindowPattern,
                retVal: ?*WindowInteractionState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationWindowPattern,
                retVal: ?*WindowInteractionState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationWindowPattern_Close(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationWindowPattern.VTable, self.vtable).Close(@ptrCast(*const IUIAutomationWindowPattern, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationWindowPattern_WaitForInputIdle(self: *const T, milliseconds: i32, success: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationWindowPattern.VTable, self.vtable).WaitForInputIdle(@ptrCast(*const IUIAutomationWindowPattern, self), milliseconds, success);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationWindowPattern_SetWindowVisualState(self: *const T, state: WindowVisualState) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationWindowPattern.VTable, self.vtable).SetWindowVisualState(@ptrCast(*const IUIAutomationWindowPattern, self), state);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationWindowPattern_get_CurrentCanMaximize(self: *const T, retVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationWindowPattern.VTable, self.vtable).get_CurrentCanMaximize(@ptrCast(*const IUIAutomationWindowPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationWindowPattern_get_CurrentCanMinimize(self: *const T, retVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationWindowPattern.VTable, self.vtable).get_CurrentCanMinimize(@ptrCast(*const IUIAutomationWindowPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationWindowPattern_get_CurrentIsModal(self: *const T, retVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationWindowPattern.VTable, self.vtable).get_CurrentIsModal(@ptrCast(*const IUIAutomationWindowPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationWindowPattern_get_CurrentIsTopmost(self: *const T, retVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationWindowPattern.VTable, self.vtable).get_CurrentIsTopmost(@ptrCast(*const IUIAutomationWindowPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationWindowPattern_get_CurrentWindowVisualState(self: *const T, retVal: ?*WindowVisualState) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationWindowPattern.VTable, self.vtable).get_CurrentWindowVisualState(@ptrCast(*const IUIAutomationWindowPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationWindowPattern_get_CurrentWindowInteractionState(self: *const T, retVal: ?*WindowInteractionState) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationWindowPattern.VTable, self.vtable).get_CurrentWindowInteractionState(@ptrCast(*const IUIAutomationWindowPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationWindowPattern_get_CachedCanMaximize(self: *const T, retVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationWindowPattern.VTable, self.vtable).get_CachedCanMaximize(@ptrCast(*const IUIAutomationWindowPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationWindowPattern_get_CachedCanMinimize(self: *const T, retVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationWindowPattern.VTable, self.vtable).get_CachedCanMinimize(@ptrCast(*const IUIAutomationWindowPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationWindowPattern_get_CachedIsModal(self: *const T, retVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationWindowPattern.VTable, self.vtable).get_CachedIsModal(@ptrCast(*const IUIAutomationWindowPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationWindowPattern_get_CachedIsTopmost(self: *const T, retVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationWindowPattern.VTable, self.vtable).get_CachedIsTopmost(@ptrCast(*const IUIAutomationWindowPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationWindowPattern_get_CachedWindowVisualState(self: *const T, retVal: ?*WindowVisualState) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationWindowPattern.VTable, self.vtable).get_CachedWindowVisualState(@ptrCast(*const IUIAutomationWindowPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationWindowPattern_get_CachedWindowInteractionState(self: *const T, retVal: ?*WindowInteractionState) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationWindowPattern.VTable, self.vtable).get_CachedWindowInteractionState(@ptrCast(*const IUIAutomationWindowPattern, self), retVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IUIAutomationTextRange_Value = Guid.initString("a543cc6a-f4ae-494b-8239-c814481187a8");
pub const IID_IUIAutomationTextRange = &IID_IUIAutomationTextRange_Value;
pub const IUIAutomationTextRange = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationTextRange,
                clonedRange: ?*?*IUIAutomationTextRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationTextRange,
                clonedRange: ?*?*IUIAutomationTextRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Compare: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationTextRange,
                range: ?*IUIAutomationTextRange,
                areSame: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationTextRange,
                range: ?*IUIAutomationTextRange,
                areSame: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CompareEndpoints: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationTextRange,
                srcEndPoint: TextPatternRangeEndpoint,
                range: ?*IUIAutomationTextRange,
                targetEndPoint: TextPatternRangeEndpoint,
                compValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationTextRange,
                srcEndPoint: TextPatternRangeEndpoint,
                range: ?*IUIAutomationTextRange,
                targetEndPoint: TextPatternRangeEndpoint,
                compValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExpandToEnclosingUnit: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationTextRange,
                textUnit: TextUnit,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationTextRange,
                textUnit: TextUnit,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindAttribute: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationTextRange,
                attr: i32,
                val: VARIANT,
                backward: BOOL,
                found: ?*?*IUIAutomationTextRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationTextRange,
                attr: i32,
                val: VARIANT,
                backward: BOOL,
                found: ?*?*IUIAutomationTextRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindText: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationTextRange,
                text: ?BSTR,
                backward: BOOL,
                ignoreCase: BOOL,
                found: ?*?*IUIAutomationTextRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationTextRange,
                text: ?BSTR,
                backward: BOOL,
                ignoreCase: BOOL,
                found: ?*?*IUIAutomationTextRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAttributeValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationTextRange,
                attr: i32,
                value: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationTextRange,
                attr: i32,
                value: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBoundingRectangles: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationTextRange,
                boundingRects: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationTextRange,
                boundingRects: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEnclosingElement: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationTextRange,
                enclosingElement: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationTextRange,
                enclosingElement: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetText: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationTextRange,
                maxLength: i32,
                text: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationTextRange,
                maxLength: i32,
                text: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Move: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationTextRange,
                unit: TextUnit,
                count: i32,
                moved: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationTextRange,
                unit: TextUnit,
                count: i32,
                moved: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        MoveEndpointByUnit: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationTextRange,
                endpoint: TextPatternRangeEndpoint,
                unit: TextUnit,
                count: i32,
                moved: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationTextRange,
                endpoint: TextPatternRangeEndpoint,
                unit: TextUnit,
                count: i32,
                moved: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        MoveEndpointByRange: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationTextRange,
                srcEndPoint: TextPatternRangeEndpoint,
                range: ?*IUIAutomationTextRange,
                targetEndPoint: TextPatternRangeEndpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationTextRange,
                srcEndPoint: TextPatternRangeEndpoint,
                range: ?*IUIAutomationTextRange,
                targetEndPoint: TextPatternRangeEndpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Select: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationTextRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationTextRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddToSelection: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationTextRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationTextRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveFromSelection: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationTextRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationTextRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ScrollIntoView: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationTextRange,
                alignToTop: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationTextRange,
                alignToTop: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetChildren: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationTextRange,
                children: ?*?*IUIAutomationElementArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationTextRange,
                children: ?*?*IUIAutomationElementArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTextRange_Clone(self: *const T, clonedRange: ?*?*IUIAutomationTextRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTextRange.VTable, self.vtable).Clone(@ptrCast(*const IUIAutomationTextRange, self), clonedRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTextRange_Compare(self: *const T, range: ?*IUIAutomationTextRange, areSame: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTextRange.VTable, self.vtable).Compare(@ptrCast(*const IUIAutomationTextRange, self), range, areSame);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTextRange_CompareEndpoints(self: *const T, srcEndPoint: TextPatternRangeEndpoint, range: ?*IUIAutomationTextRange, targetEndPoint: TextPatternRangeEndpoint, compValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTextRange.VTable, self.vtable).CompareEndpoints(@ptrCast(*const IUIAutomationTextRange, self), srcEndPoint, range, targetEndPoint, compValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTextRange_ExpandToEnclosingUnit(self: *const T, textUnit: TextUnit) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTextRange.VTable, self.vtable).ExpandToEnclosingUnit(@ptrCast(*const IUIAutomationTextRange, self), textUnit);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTextRange_FindAttribute(self: *const T, attr: i32, val: VARIANT, backward: BOOL, found: ?*?*IUIAutomationTextRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTextRange.VTable, self.vtable).FindAttribute(@ptrCast(*const IUIAutomationTextRange, self), attr, val, backward, found);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTextRange_FindText(self: *const T, text: ?BSTR, backward: BOOL, ignoreCase: BOOL, found: ?*?*IUIAutomationTextRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTextRange.VTable, self.vtable).FindText(@ptrCast(*const IUIAutomationTextRange, self), text, backward, ignoreCase, found);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTextRange_GetAttributeValue(self: *const T, attr: i32, value: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTextRange.VTable, self.vtable).GetAttributeValue(@ptrCast(*const IUIAutomationTextRange, self), attr, value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTextRange_GetBoundingRectangles(self: *const T, boundingRects: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTextRange.VTable, self.vtable).GetBoundingRectangles(@ptrCast(*const IUIAutomationTextRange, self), boundingRects);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTextRange_GetEnclosingElement(self: *const T, enclosingElement: ?*?*IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTextRange.VTable, self.vtable).GetEnclosingElement(@ptrCast(*const IUIAutomationTextRange, self), enclosingElement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTextRange_GetText(self: *const T, maxLength: i32, text: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTextRange.VTable, self.vtable).GetText(@ptrCast(*const IUIAutomationTextRange, self), maxLength, text);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTextRange_Move(self: *const T, unit: TextUnit, count: i32, moved: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTextRange.VTable, self.vtable).Move(@ptrCast(*const IUIAutomationTextRange, self), unit, count, moved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTextRange_MoveEndpointByUnit(self: *const T, endpoint: TextPatternRangeEndpoint, unit: TextUnit, count: i32, moved: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTextRange.VTable, self.vtable).MoveEndpointByUnit(@ptrCast(*const IUIAutomationTextRange, self), endpoint, unit, count, moved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTextRange_MoveEndpointByRange(self: *const T, srcEndPoint: TextPatternRangeEndpoint, range: ?*IUIAutomationTextRange, targetEndPoint: TextPatternRangeEndpoint) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTextRange.VTable, self.vtable).MoveEndpointByRange(@ptrCast(*const IUIAutomationTextRange, self), srcEndPoint, range, targetEndPoint);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTextRange_Select(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTextRange.VTable, self.vtable).Select(@ptrCast(*const IUIAutomationTextRange, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTextRange_AddToSelection(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTextRange.VTable, self.vtable).AddToSelection(@ptrCast(*const IUIAutomationTextRange, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTextRange_RemoveFromSelection(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTextRange.VTable, self.vtable).RemoveFromSelection(@ptrCast(*const IUIAutomationTextRange, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTextRange_ScrollIntoView(self: *const T, alignToTop: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTextRange.VTable, self.vtable).ScrollIntoView(@ptrCast(*const IUIAutomationTextRange, self), alignToTop);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTextRange_GetChildren(self: *const T, children: ?*?*IUIAutomationElementArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTextRange.VTable, self.vtable).GetChildren(@ptrCast(*const IUIAutomationTextRange, self), children);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.1'
const IID_IUIAutomationTextRange2_Value = Guid.initString("bb9b40e0-5e04-46bd-9be0-4b601b9afad4");
pub const IID_IUIAutomationTextRange2 = &IID_IUIAutomationTextRange2_Value;
pub const IUIAutomationTextRange2 = extern struct {
    pub const VTable = extern struct {
        base: IUIAutomationTextRange.VTable,
        ShowContextMenu: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationTextRange2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationTextRange2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUIAutomationTextRange.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTextRange2_ShowContextMenu(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTextRange2.VTable, self.vtable).ShowContextMenu(@ptrCast(*const IUIAutomationTextRange2, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.15063'
const IID_IUIAutomationTextRange3_Value = Guid.initString("6a315d69-5512-4c2e-85f0-53fce6dd4bc2");
pub const IID_IUIAutomationTextRange3 = &IID_IUIAutomationTextRange3_Value;
pub const IUIAutomationTextRange3 = extern struct {
    pub const VTable = extern struct {
        base: IUIAutomationTextRange2.VTable,
        GetEnclosingElementBuildCache: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationTextRange3,
                cacheRequest: ?*IUIAutomationCacheRequest,
                enclosingElement: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationTextRange3,
                cacheRequest: ?*IUIAutomationCacheRequest,
                enclosingElement: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetChildrenBuildCache: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationTextRange3,
                cacheRequest: ?*IUIAutomationCacheRequest,
                children: ?*?*IUIAutomationElementArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationTextRange3,
                cacheRequest: ?*IUIAutomationCacheRequest,
                children: ?*?*IUIAutomationElementArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAttributeValues: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationTextRange3,
                attributeIds: [*]const i32,
                attributeIdCount: i32,
                attributeValues: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationTextRange3,
                attributeIds: [*]const i32,
                attributeIdCount: i32,
                attributeValues: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUIAutomationTextRange2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTextRange3_GetEnclosingElementBuildCache(self: *const T, cacheRequest: ?*IUIAutomationCacheRequest, enclosingElement: ?*?*IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTextRange3.VTable, self.vtable).GetEnclosingElementBuildCache(@ptrCast(*const IUIAutomationTextRange3, self), cacheRequest, enclosingElement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTextRange3_GetChildrenBuildCache(self: *const T, cacheRequest: ?*IUIAutomationCacheRequest, children: ?*?*IUIAutomationElementArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTextRange3.VTable, self.vtable).GetChildrenBuildCache(@ptrCast(*const IUIAutomationTextRange3, self), cacheRequest, children);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTextRange3_GetAttributeValues(self: *const T, attributeIds: [*]const i32, attributeIdCount: i32, attributeValues: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTextRange3.VTable, self.vtable).GetAttributeValues(@ptrCast(*const IUIAutomationTextRange3, self), attributeIds, attributeIdCount, attributeValues);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IUIAutomationTextRangeArray_Value = Guid.initString("ce4ae76a-e717-4c98-81ea-47371d028eb6");
pub const IID_IUIAutomationTextRangeArray = &IID_IUIAutomationTextRangeArray_Value;
pub const IUIAutomationTextRangeArray = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Length: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationTextRangeArray,
                length: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationTextRangeArray,
                length: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetElement: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationTextRangeArray,
                index: i32,
                element: ?*?*IUIAutomationTextRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationTextRangeArray,
                index: i32,
                element: ?*?*IUIAutomationTextRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTextRangeArray_get_Length(self: *const T, length: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTextRangeArray.VTable, self.vtable).get_Length(@ptrCast(*const IUIAutomationTextRangeArray, self), length);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTextRangeArray_GetElement(self: *const T, index: i32, element: ?*?*IUIAutomationTextRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTextRangeArray.VTable, self.vtable).GetElement(@ptrCast(*const IUIAutomationTextRangeArray, self), index, element);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IUIAutomationTextPattern_Value = Guid.initString("32eba289-3583-42c9-9c59-3b6d9a1e9b6a");
pub const IID_IUIAutomationTextPattern = &IID_IUIAutomationTextPattern_Value;
pub const IUIAutomationTextPattern = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RangeFromPoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationTextPattern,
                pt: POINT,
                range: ?*?*IUIAutomationTextRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationTextPattern,
                pt: POINT,
                range: ?*?*IUIAutomationTextRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RangeFromChild: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationTextPattern,
                child: ?*IUIAutomationElement,
                range: ?*?*IUIAutomationTextRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationTextPattern,
                child: ?*IUIAutomationElement,
                range: ?*?*IUIAutomationTextRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSelection: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationTextPattern,
                ranges: ?*?*IUIAutomationTextRangeArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationTextPattern,
                ranges: ?*?*IUIAutomationTextRangeArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVisibleRanges: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationTextPattern,
                ranges: ?*?*IUIAutomationTextRangeArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationTextPattern,
                ranges: ?*?*IUIAutomationTextRangeArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DocumentRange: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationTextPattern,
                range: ?*?*IUIAutomationTextRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationTextPattern,
                range: ?*?*IUIAutomationTextRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SupportedTextSelection: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationTextPattern,
                supportedTextSelection: ?*SupportedTextSelection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationTextPattern,
                supportedTextSelection: ?*SupportedTextSelection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTextPattern_RangeFromPoint(self: *const T, pt: POINT, range: ?*?*IUIAutomationTextRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTextPattern.VTable, self.vtable).RangeFromPoint(@ptrCast(*const IUIAutomationTextPattern, self), pt, range);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTextPattern_RangeFromChild(self: *const T, child: ?*IUIAutomationElement, range: ?*?*IUIAutomationTextRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTextPattern.VTable, self.vtable).RangeFromChild(@ptrCast(*const IUIAutomationTextPattern, self), child, range);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTextPattern_GetSelection(self: *const T, ranges: ?*?*IUIAutomationTextRangeArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTextPattern.VTable, self.vtable).GetSelection(@ptrCast(*const IUIAutomationTextPattern, self), ranges);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTextPattern_GetVisibleRanges(self: *const T, ranges: ?*?*IUIAutomationTextRangeArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTextPattern.VTable, self.vtable).GetVisibleRanges(@ptrCast(*const IUIAutomationTextPattern, self), ranges);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTextPattern_get_DocumentRange(self: *const T, range: ?*?*IUIAutomationTextRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTextPattern.VTable, self.vtable).get_DocumentRange(@ptrCast(*const IUIAutomationTextPattern, self), range);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTextPattern_get_SupportedTextSelection(self: *const T, supportedTextSelection: ?*SupportedTextSelection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTextPattern.VTable, self.vtable).get_SupportedTextSelection(@ptrCast(*const IUIAutomationTextPattern, self), supportedTextSelection);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IUIAutomationTextPattern2_Value = Guid.initString("506a921a-fcc9-409f-b23b-37eb74106872");
pub const IID_IUIAutomationTextPattern2 = &IID_IUIAutomationTextPattern2_Value;
pub const IUIAutomationTextPattern2 = extern struct {
    pub const VTable = extern struct {
        base: IUIAutomationTextPattern.VTable,
        RangeFromAnnotation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationTextPattern2,
                annotation: ?*IUIAutomationElement,
                range: ?*?*IUIAutomationTextRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationTextPattern2,
                annotation: ?*IUIAutomationElement,
                range: ?*?*IUIAutomationTextRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCaretRange: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationTextPattern2,
                isActive: ?*BOOL,
                range: ?*?*IUIAutomationTextRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationTextPattern2,
                isActive: ?*BOOL,
                range: ?*?*IUIAutomationTextRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUIAutomationTextPattern.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTextPattern2_RangeFromAnnotation(self: *const T, annotation: ?*IUIAutomationElement, range: ?*?*IUIAutomationTextRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTextPattern2.VTable, self.vtable).RangeFromAnnotation(@ptrCast(*const IUIAutomationTextPattern2, self), annotation, range);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTextPattern2_GetCaretRange(self: *const T, isActive: ?*BOOL, range: ?*?*IUIAutomationTextRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTextPattern2.VTable, self.vtable).GetCaretRange(@ptrCast(*const IUIAutomationTextPattern2, self), isActive, range);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.1'
const IID_IUIAutomationTextEditPattern_Value = Guid.initString("17e21576-996c-4870-99d9-bff323380c06");
pub const IID_IUIAutomationTextEditPattern = &IID_IUIAutomationTextEditPattern_Value;
pub const IUIAutomationTextEditPattern = extern struct {
    pub const VTable = extern struct {
        base: IUIAutomationTextPattern.VTable,
        GetActiveComposition: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationTextEditPattern,
                range: ?*?*IUIAutomationTextRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationTextEditPattern,
                range: ?*?*IUIAutomationTextRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetConversionTarget: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationTextEditPattern,
                range: ?*?*IUIAutomationTextRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationTextEditPattern,
                range: ?*?*IUIAutomationTextRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUIAutomationTextPattern.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTextEditPattern_GetActiveComposition(self: *const T, range: ?*?*IUIAutomationTextRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTextEditPattern.VTable, self.vtable).GetActiveComposition(@ptrCast(*const IUIAutomationTextEditPattern, self), range);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTextEditPattern_GetConversionTarget(self: *const T, range: ?*?*IUIAutomationTextRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTextEditPattern.VTable, self.vtable).GetConversionTarget(@ptrCast(*const IUIAutomationTextEditPattern, self), range);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IUIAutomationCustomNavigationPattern_Value = Guid.initString("01ea217a-1766-47ed-a6cc-acf492854b1f");
pub const IID_IUIAutomationCustomNavigationPattern = &IID_IUIAutomationCustomNavigationPattern_Value;
pub const IUIAutomationCustomNavigationPattern = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Navigate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationCustomNavigationPattern,
                direction: NavigateDirection,
                pRetVal: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationCustomNavigationPattern,
                direction: NavigateDirection,
                pRetVal: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationCustomNavigationPattern_Navigate(self: *const T, direction: NavigateDirection, pRetVal: ?*?*IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationCustomNavigationPattern.VTable, self.vtable).Navigate(@ptrCast(*const IUIAutomationCustomNavigationPattern, self), direction, pRetVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.17763'
const IID_IUIAutomationActiveTextPositionChangedEventHandler_Value = Guid.initString("f97933b0-8dae-4496-8997-5ba015fe0d82");
pub const IID_IUIAutomationActiveTextPositionChangedEventHandler = &IID_IUIAutomationActiveTextPositionChangedEventHandler_Value;
pub const IUIAutomationActiveTextPositionChangedEventHandler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        HandleActiveTextPositionChangedEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationActiveTextPositionChangedEventHandler,
                sender: ?*IUIAutomationElement,
                range: ?*IUIAutomationTextRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationActiveTextPositionChangedEventHandler,
                sender: ?*IUIAutomationElement,
                range: ?*IUIAutomationTextRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationActiveTextPositionChangedEventHandler_HandleActiveTextPositionChangedEvent(self: *const T, sender: ?*IUIAutomationElement, range: ?*IUIAutomationTextRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationActiveTextPositionChangedEventHandler.VTable, self.vtable).HandleActiveTextPositionChangedEvent(@ptrCast(*const IUIAutomationActiveTextPositionChangedEventHandler, self), sender, range);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IUIAutomationLegacyIAccessiblePattern_Value = Guid.initString("828055ad-355b-4435-86d5-3b51c14a9b1b");
pub const IID_IUIAutomationLegacyIAccessiblePattern = &IID_IUIAutomationLegacyIAccessiblePattern_Value;
pub const IUIAutomationLegacyIAccessiblePattern = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Select: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationLegacyIAccessiblePattern,
                flagsSelect: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationLegacyIAccessiblePattern,
                flagsSelect: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DoDefaultAction: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationLegacyIAccessiblePattern,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationLegacyIAccessiblePattern,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationLegacyIAccessiblePattern,
                szValue: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationLegacyIAccessiblePattern,
                szValue: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentChildId: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationLegacyIAccessiblePattern,
                pRetVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationLegacyIAccessiblePattern,
                pRetVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationLegacyIAccessiblePattern,
                pszName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationLegacyIAccessiblePattern,
                pszName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentValue: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationLegacyIAccessiblePattern,
                pszValue: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationLegacyIAccessiblePattern,
                pszValue: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentDescription: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationLegacyIAccessiblePattern,
                pszDescription: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationLegacyIAccessiblePattern,
                pszDescription: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentRole: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationLegacyIAccessiblePattern,
                pdwRole: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationLegacyIAccessiblePattern,
                pdwRole: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentState: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationLegacyIAccessiblePattern,
                pdwState: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationLegacyIAccessiblePattern,
                pdwState: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentHelp: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationLegacyIAccessiblePattern,
                pszHelp: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationLegacyIAccessiblePattern,
                pszHelp: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentKeyboardShortcut: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationLegacyIAccessiblePattern,
                pszKeyboardShortcut: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationLegacyIAccessiblePattern,
                pszKeyboardShortcut: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentSelection: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationLegacyIAccessiblePattern,
                pvarSelectedChildren: ?*?*IUIAutomationElementArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationLegacyIAccessiblePattern,
                pvarSelectedChildren: ?*?*IUIAutomationElementArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentDefaultAction: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationLegacyIAccessiblePattern,
                pszDefaultAction: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationLegacyIAccessiblePattern,
                pszDefaultAction: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedChildId: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationLegacyIAccessiblePattern,
                pRetVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationLegacyIAccessiblePattern,
                pRetVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationLegacyIAccessiblePattern,
                pszName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationLegacyIAccessiblePattern,
                pszName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedValue: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationLegacyIAccessiblePattern,
                pszValue: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationLegacyIAccessiblePattern,
                pszValue: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedDescription: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationLegacyIAccessiblePattern,
                pszDescription: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationLegacyIAccessiblePattern,
                pszDescription: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedRole: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationLegacyIAccessiblePattern,
                pdwRole: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationLegacyIAccessiblePattern,
                pdwRole: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedState: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationLegacyIAccessiblePattern,
                pdwState: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationLegacyIAccessiblePattern,
                pdwState: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedHelp: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationLegacyIAccessiblePattern,
                pszHelp: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationLegacyIAccessiblePattern,
                pszHelp: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedKeyboardShortcut: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationLegacyIAccessiblePattern,
                pszKeyboardShortcut: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationLegacyIAccessiblePattern,
                pszKeyboardShortcut: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCachedSelection: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationLegacyIAccessiblePattern,
                pvarSelectedChildren: ?*?*IUIAutomationElementArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationLegacyIAccessiblePattern,
                pvarSelectedChildren: ?*?*IUIAutomationElementArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedDefaultAction: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationLegacyIAccessiblePattern,
                pszDefaultAction: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationLegacyIAccessiblePattern,
                pszDefaultAction: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIAccessible: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationLegacyIAccessiblePattern,
                ppAccessible: ?*?*IAccessible,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationLegacyIAccessiblePattern,
                ppAccessible: ?*?*IAccessible,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationLegacyIAccessiblePattern_Select(self: *const T, flagsSelect: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationLegacyIAccessiblePattern.VTable, self.vtable).Select(@ptrCast(*const IUIAutomationLegacyIAccessiblePattern, self), flagsSelect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationLegacyIAccessiblePattern_DoDefaultAction(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationLegacyIAccessiblePattern.VTable, self.vtable).DoDefaultAction(@ptrCast(*const IUIAutomationLegacyIAccessiblePattern, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationLegacyIAccessiblePattern_SetValue(self: *const T, szValue: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationLegacyIAccessiblePattern.VTable, self.vtable).SetValue(@ptrCast(*const IUIAutomationLegacyIAccessiblePattern, self), szValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationLegacyIAccessiblePattern_get_CurrentChildId(self: *const T, pRetVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationLegacyIAccessiblePattern.VTable, self.vtable).get_CurrentChildId(@ptrCast(*const IUIAutomationLegacyIAccessiblePattern, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationLegacyIAccessiblePattern_get_CurrentName(self: *const T, pszName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationLegacyIAccessiblePattern.VTable, self.vtable).get_CurrentName(@ptrCast(*const IUIAutomationLegacyIAccessiblePattern, self), pszName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationLegacyIAccessiblePattern_get_CurrentValue(self: *const T, pszValue: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationLegacyIAccessiblePattern.VTable, self.vtable).get_CurrentValue(@ptrCast(*const IUIAutomationLegacyIAccessiblePattern, self), pszValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationLegacyIAccessiblePattern_get_CurrentDescription(self: *const T, pszDescription: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationLegacyIAccessiblePattern.VTable, self.vtable).get_CurrentDescription(@ptrCast(*const IUIAutomationLegacyIAccessiblePattern, self), pszDescription);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationLegacyIAccessiblePattern_get_CurrentRole(self: *const T, pdwRole: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationLegacyIAccessiblePattern.VTable, self.vtable).get_CurrentRole(@ptrCast(*const IUIAutomationLegacyIAccessiblePattern, self), pdwRole);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationLegacyIAccessiblePattern_get_CurrentState(self: *const T, pdwState: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationLegacyIAccessiblePattern.VTable, self.vtable).get_CurrentState(@ptrCast(*const IUIAutomationLegacyIAccessiblePattern, self), pdwState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationLegacyIAccessiblePattern_get_CurrentHelp(self: *const T, pszHelp: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationLegacyIAccessiblePattern.VTable, self.vtable).get_CurrentHelp(@ptrCast(*const IUIAutomationLegacyIAccessiblePattern, self), pszHelp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationLegacyIAccessiblePattern_get_CurrentKeyboardShortcut(self: *const T, pszKeyboardShortcut: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationLegacyIAccessiblePattern.VTable, self.vtable).get_CurrentKeyboardShortcut(@ptrCast(*const IUIAutomationLegacyIAccessiblePattern, self), pszKeyboardShortcut);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationLegacyIAccessiblePattern_GetCurrentSelection(self: *const T, pvarSelectedChildren: ?*?*IUIAutomationElementArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationLegacyIAccessiblePattern.VTable, self.vtable).GetCurrentSelection(@ptrCast(*const IUIAutomationLegacyIAccessiblePattern, self), pvarSelectedChildren);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationLegacyIAccessiblePattern_get_CurrentDefaultAction(self: *const T, pszDefaultAction: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationLegacyIAccessiblePattern.VTable, self.vtable).get_CurrentDefaultAction(@ptrCast(*const IUIAutomationLegacyIAccessiblePattern, self), pszDefaultAction);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationLegacyIAccessiblePattern_get_CachedChildId(self: *const T, pRetVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationLegacyIAccessiblePattern.VTable, self.vtable).get_CachedChildId(@ptrCast(*const IUIAutomationLegacyIAccessiblePattern, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationLegacyIAccessiblePattern_get_CachedName(self: *const T, pszName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationLegacyIAccessiblePattern.VTable, self.vtable).get_CachedName(@ptrCast(*const IUIAutomationLegacyIAccessiblePattern, self), pszName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationLegacyIAccessiblePattern_get_CachedValue(self: *const T, pszValue: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationLegacyIAccessiblePattern.VTable, self.vtable).get_CachedValue(@ptrCast(*const IUIAutomationLegacyIAccessiblePattern, self), pszValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationLegacyIAccessiblePattern_get_CachedDescription(self: *const T, pszDescription: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationLegacyIAccessiblePattern.VTable, self.vtable).get_CachedDescription(@ptrCast(*const IUIAutomationLegacyIAccessiblePattern, self), pszDescription);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationLegacyIAccessiblePattern_get_CachedRole(self: *const T, pdwRole: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationLegacyIAccessiblePattern.VTable, self.vtable).get_CachedRole(@ptrCast(*const IUIAutomationLegacyIAccessiblePattern, self), pdwRole);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationLegacyIAccessiblePattern_get_CachedState(self: *const T, pdwState: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationLegacyIAccessiblePattern.VTable, self.vtable).get_CachedState(@ptrCast(*const IUIAutomationLegacyIAccessiblePattern, self), pdwState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationLegacyIAccessiblePattern_get_CachedHelp(self: *const T, pszHelp: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationLegacyIAccessiblePattern.VTable, self.vtable).get_CachedHelp(@ptrCast(*const IUIAutomationLegacyIAccessiblePattern, self), pszHelp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationLegacyIAccessiblePattern_get_CachedKeyboardShortcut(self: *const T, pszKeyboardShortcut: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationLegacyIAccessiblePattern.VTable, self.vtable).get_CachedKeyboardShortcut(@ptrCast(*const IUIAutomationLegacyIAccessiblePattern, self), pszKeyboardShortcut);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationLegacyIAccessiblePattern_GetCachedSelection(self: *const T, pvarSelectedChildren: ?*?*IUIAutomationElementArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationLegacyIAccessiblePattern.VTable, self.vtable).GetCachedSelection(@ptrCast(*const IUIAutomationLegacyIAccessiblePattern, self), pvarSelectedChildren);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationLegacyIAccessiblePattern_get_CachedDefaultAction(self: *const T, pszDefaultAction: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationLegacyIAccessiblePattern.VTable, self.vtable).get_CachedDefaultAction(@ptrCast(*const IUIAutomationLegacyIAccessiblePattern, self), pszDefaultAction);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationLegacyIAccessiblePattern_GetIAccessible(self: *const T, ppAccessible: ?*?*IAccessible) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationLegacyIAccessiblePattern.VTable, self.vtable).GetIAccessible(@ptrCast(*const IUIAutomationLegacyIAccessiblePattern, self), ppAccessible);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IUIAutomationItemContainerPattern_Value = Guid.initString("c690fdb2-27a8-423c-812d-429773c9084e");
pub const IID_IUIAutomationItemContainerPattern = &IID_IUIAutomationItemContainerPattern_Value;
pub const IUIAutomationItemContainerPattern = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        FindItemByProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationItemContainerPattern,
                pStartAfter: ?*IUIAutomationElement,
                propertyId: i32,
                value: VARIANT,
                pFound: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationItemContainerPattern,
                pStartAfter: ?*IUIAutomationElement,
                propertyId: i32,
                value: VARIANT,
                pFound: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationItemContainerPattern_FindItemByProperty(self: *const T, pStartAfter: ?*IUIAutomationElement, propertyId: i32, value: VARIANT, pFound: ?*?*IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationItemContainerPattern.VTable, self.vtable).FindItemByProperty(@ptrCast(*const IUIAutomationItemContainerPattern, self), pStartAfter, propertyId, value, pFound);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IUIAutomationVirtualizedItemPattern_Value = Guid.initString("6ba3d7a6-04cf-4f11-8793-a8d1cde9969f");
pub const IID_IUIAutomationVirtualizedItemPattern = &IID_IUIAutomationVirtualizedItemPattern_Value;
pub const IUIAutomationVirtualizedItemPattern = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Realize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationVirtualizedItemPattern,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationVirtualizedItemPattern,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationVirtualizedItemPattern_Realize(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationVirtualizedItemPattern.VTable, self.vtable).Realize(@ptrCast(*const IUIAutomationVirtualizedItemPattern, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IUIAutomationAnnotationPattern_Value = Guid.initString("9a175b21-339e-41b1-8e8b-623f6b681098");
pub const IID_IUIAutomationAnnotationPattern = &IID_IUIAutomationAnnotationPattern_Value;
pub const IUIAutomationAnnotationPattern = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentAnnotationTypeId: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationAnnotationPattern,
                retVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationAnnotationPattern,
                retVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentAnnotationTypeName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationAnnotationPattern,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationAnnotationPattern,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentAuthor: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationAnnotationPattern,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationAnnotationPattern,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentDateTime: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationAnnotationPattern,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationAnnotationPattern,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentTarget: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationAnnotationPattern,
                retVal: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationAnnotationPattern,
                retVal: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedAnnotationTypeId: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationAnnotationPattern,
                retVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationAnnotationPattern,
                retVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedAnnotationTypeName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationAnnotationPattern,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationAnnotationPattern,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedAuthor: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationAnnotationPattern,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationAnnotationPattern,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedDateTime: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationAnnotationPattern,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationAnnotationPattern,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedTarget: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationAnnotationPattern,
                retVal: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationAnnotationPattern,
                retVal: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationAnnotationPattern_get_CurrentAnnotationTypeId(self: *const T, retVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationAnnotationPattern.VTable, self.vtable).get_CurrentAnnotationTypeId(@ptrCast(*const IUIAutomationAnnotationPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationAnnotationPattern_get_CurrentAnnotationTypeName(self: *const T, retVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationAnnotationPattern.VTable, self.vtable).get_CurrentAnnotationTypeName(@ptrCast(*const IUIAutomationAnnotationPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationAnnotationPattern_get_CurrentAuthor(self: *const T, retVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationAnnotationPattern.VTable, self.vtable).get_CurrentAuthor(@ptrCast(*const IUIAutomationAnnotationPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationAnnotationPattern_get_CurrentDateTime(self: *const T, retVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationAnnotationPattern.VTable, self.vtable).get_CurrentDateTime(@ptrCast(*const IUIAutomationAnnotationPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationAnnotationPattern_get_CurrentTarget(self: *const T, retVal: ?*?*IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationAnnotationPattern.VTable, self.vtable).get_CurrentTarget(@ptrCast(*const IUIAutomationAnnotationPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationAnnotationPattern_get_CachedAnnotationTypeId(self: *const T, retVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationAnnotationPattern.VTable, self.vtable).get_CachedAnnotationTypeId(@ptrCast(*const IUIAutomationAnnotationPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationAnnotationPattern_get_CachedAnnotationTypeName(self: *const T, retVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationAnnotationPattern.VTable, self.vtable).get_CachedAnnotationTypeName(@ptrCast(*const IUIAutomationAnnotationPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationAnnotationPattern_get_CachedAuthor(self: *const T, retVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationAnnotationPattern.VTable, self.vtable).get_CachedAuthor(@ptrCast(*const IUIAutomationAnnotationPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationAnnotationPattern_get_CachedDateTime(self: *const T, retVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationAnnotationPattern.VTable, self.vtable).get_CachedDateTime(@ptrCast(*const IUIAutomationAnnotationPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationAnnotationPattern_get_CachedTarget(self: *const T, retVal: ?*?*IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationAnnotationPattern.VTable, self.vtable).get_CachedTarget(@ptrCast(*const IUIAutomationAnnotationPattern, self), retVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IUIAutomationStylesPattern_Value = Guid.initString("85b5f0a2-bd79-484a-ad2b-388c9838d5fb");
pub const IID_IUIAutomationStylesPattern = &IID_IUIAutomationStylesPattern_Value;
pub const IUIAutomationStylesPattern = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentStyleId: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationStylesPattern,
                retVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationStylesPattern,
                retVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentStyleName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationStylesPattern,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationStylesPattern,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentFillColor: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationStylesPattern,
                retVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationStylesPattern,
                retVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentFillPatternStyle: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationStylesPattern,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationStylesPattern,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentShape: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationStylesPattern,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationStylesPattern,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentFillPatternColor: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationStylesPattern,
                retVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationStylesPattern,
                retVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentExtendedProperties: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationStylesPattern,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationStylesPattern,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentExtendedPropertiesAsArray: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationStylesPattern,
                propertyArray: ?*?*ExtendedProperty,
                propertyCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationStylesPattern,
                propertyArray: ?*?*ExtendedProperty,
                propertyCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedStyleId: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationStylesPattern,
                retVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationStylesPattern,
                retVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedStyleName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationStylesPattern,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationStylesPattern,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedFillColor: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationStylesPattern,
                retVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationStylesPattern,
                retVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedFillPatternStyle: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationStylesPattern,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationStylesPattern,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedShape: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationStylesPattern,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationStylesPattern,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedFillPatternColor: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationStylesPattern,
                retVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationStylesPattern,
                retVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedExtendedProperties: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationStylesPattern,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationStylesPattern,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCachedExtendedPropertiesAsArray: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationStylesPattern,
                propertyArray: ?*?*ExtendedProperty,
                propertyCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationStylesPattern,
                propertyArray: ?*?*ExtendedProperty,
                propertyCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationStylesPattern_get_CurrentStyleId(self: *const T, retVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationStylesPattern.VTable, self.vtable).get_CurrentStyleId(@ptrCast(*const IUIAutomationStylesPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationStylesPattern_get_CurrentStyleName(self: *const T, retVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationStylesPattern.VTable, self.vtable).get_CurrentStyleName(@ptrCast(*const IUIAutomationStylesPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationStylesPattern_get_CurrentFillColor(self: *const T, retVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationStylesPattern.VTable, self.vtable).get_CurrentFillColor(@ptrCast(*const IUIAutomationStylesPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationStylesPattern_get_CurrentFillPatternStyle(self: *const T, retVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationStylesPattern.VTable, self.vtable).get_CurrentFillPatternStyle(@ptrCast(*const IUIAutomationStylesPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationStylesPattern_get_CurrentShape(self: *const T, retVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationStylesPattern.VTable, self.vtable).get_CurrentShape(@ptrCast(*const IUIAutomationStylesPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationStylesPattern_get_CurrentFillPatternColor(self: *const T, retVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationStylesPattern.VTable, self.vtable).get_CurrentFillPatternColor(@ptrCast(*const IUIAutomationStylesPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationStylesPattern_get_CurrentExtendedProperties(self: *const T, retVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationStylesPattern.VTable, self.vtable).get_CurrentExtendedProperties(@ptrCast(*const IUIAutomationStylesPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationStylesPattern_GetCurrentExtendedPropertiesAsArray(self: *const T, propertyArray: ?*?*ExtendedProperty, propertyCount: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationStylesPattern.VTable, self.vtable).GetCurrentExtendedPropertiesAsArray(@ptrCast(*const IUIAutomationStylesPattern, self), propertyArray, propertyCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationStylesPattern_get_CachedStyleId(self: *const T, retVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationStylesPattern.VTable, self.vtable).get_CachedStyleId(@ptrCast(*const IUIAutomationStylesPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationStylesPattern_get_CachedStyleName(self: *const T, retVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationStylesPattern.VTable, self.vtable).get_CachedStyleName(@ptrCast(*const IUIAutomationStylesPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationStylesPattern_get_CachedFillColor(self: *const T, retVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationStylesPattern.VTable, self.vtable).get_CachedFillColor(@ptrCast(*const IUIAutomationStylesPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationStylesPattern_get_CachedFillPatternStyle(self: *const T, retVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationStylesPattern.VTable, self.vtable).get_CachedFillPatternStyle(@ptrCast(*const IUIAutomationStylesPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationStylesPattern_get_CachedShape(self: *const T, retVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationStylesPattern.VTable, self.vtable).get_CachedShape(@ptrCast(*const IUIAutomationStylesPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationStylesPattern_get_CachedFillPatternColor(self: *const T, retVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationStylesPattern.VTable, self.vtable).get_CachedFillPatternColor(@ptrCast(*const IUIAutomationStylesPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationStylesPattern_get_CachedExtendedProperties(self: *const T, retVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationStylesPattern.VTable, self.vtable).get_CachedExtendedProperties(@ptrCast(*const IUIAutomationStylesPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationStylesPattern_GetCachedExtendedPropertiesAsArray(self: *const T, propertyArray: ?*?*ExtendedProperty, propertyCount: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationStylesPattern.VTable, self.vtable).GetCachedExtendedPropertiesAsArray(@ptrCast(*const IUIAutomationStylesPattern, self), propertyArray, propertyCount);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IUIAutomationSpreadsheetPattern_Value = Guid.initString("7517a7c8-faae-4de9-9f08-29b91e8595c1");
pub const IID_IUIAutomationSpreadsheetPattern = &IID_IUIAutomationSpreadsheetPattern_Value;
pub const IUIAutomationSpreadsheetPattern = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetItemByName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationSpreadsheetPattern,
                name: ?BSTR,
                element: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationSpreadsheetPattern,
                name: ?BSTR,
                element: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationSpreadsheetPattern_GetItemByName(self: *const T, name: ?BSTR, element: ?*?*IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationSpreadsheetPattern.VTable, self.vtable).GetItemByName(@ptrCast(*const IUIAutomationSpreadsheetPattern, self), name, element);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IUIAutomationSpreadsheetItemPattern_Value = Guid.initString("7d4fb86c-8d34-40e1-8e83-62c15204e335");
pub const IID_IUIAutomationSpreadsheetItemPattern = &IID_IUIAutomationSpreadsheetItemPattern_Value;
pub const IUIAutomationSpreadsheetItemPattern = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentFormula: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationSpreadsheetItemPattern,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationSpreadsheetItemPattern,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentAnnotationObjects: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationSpreadsheetItemPattern,
                retVal: ?*?*IUIAutomationElementArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationSpreadsheetItemPattern,
                retVal: ?*?*IUIAutomationElementArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentAnnotationTypes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationSpreadsheetItemPattern,
                retVal: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationSpreadsheetItemPattern,
                retVal: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedFormula: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationSpreadsheetItemPattern,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationSpreadsheetItemPattern,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCachedAnnotationObjects: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationSpreadsheetItemPattern,
                retVal: ?*?*IUIAutomationElementArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationSpreadsheetItemPattern,
                retVal: ?*?*IUIAutomationElementArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCachedAnnotationTypes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationSpreadsheetItemPattern,
                retVal: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationSpreadsheetItemPattern,
                retVal: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationSpreadsheetItemPattern_get_CurrentFormula(self: *const T, retVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationSpreadsheetItemPattern.VTable, self.vtable).get_CurrentFormula(@ptrCast(*const IUIAutomationSpreadsheetItemPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationSpreadsheetItemPattern_GetCurrentAnnotationObjects(self: *const T, retVal: ?*?*IUIAutomationElementArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationSpreadsheetItemPattern.VTable, self.vtable).GetCurrentAnnotationObjects(@ptrCast(*const IUIAutomationSpreadsheetItemPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationSpreadsheetItemPattern_GetCurrentAnnotationTypes(self: *const T, retVal: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationSpreadsheetItemPattern.VTable, self.vtable).GetCurrentAnnotationTypes(@ptrCast(*const IUIAutomationSpreadsheetItemPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationSpreadsheetItemPattern_get_CachedFormula(self: *const T, retVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationSpreadsheetItemPattern.VTable, self.vtable).get_CachedFormula(@ptrCast(*const IUIAutomationSpreadsheetItemPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationSpreadsheetItemPattern_GetCachedAnnotationObjects(self: *const T, retVal: ?*?*IUIAutomationElementArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationSpreadsheetItemPattern.VTable, self.vtable).GetCachedAnnotationObjects(@ptrCast(*const IUIAutomationSpreadsheetItemPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationSpreadsheetItemPattern_GetCachedAnnotationTypes(self: *const T, retVal: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationSpreadsheetItemPattern.VTable, self.vtable).GetCachedAnnotationTypes(@ptrCast(*const IUIAutomationSpreadsheetItemPattern, self), retVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IUIAutomationTransformPattern2_Value = Guid.initString("6d74d017-6ecb-4381-b38b-3c17a48ff1c2");
pub const IID_IUIAutomationTransformPattern2 = &IID_IUIAutomationTransformPattern2_Value;
pub const IUIAutomationTransformPattern2 = extern struct {
    pub const VTable = extern struct {
        base: IUIAutomationTransformPattern.VTable,
        Zoom: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationTransformPattern2,
                zoomValue: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationTransformPattern2,
                zoomValue: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ZoomByUnit: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationTransformPattern2,
                zoomUnit: ZoomUnit,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationTransformPattern2,
                zoomUnit: ZoomUnit,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentCanZoom: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationTransformPattern2,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationTransformPattern2,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedCanZoom: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationTransformPattern2,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationTransformPattern2,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentZoomLevel: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationTransformPattern2,
                retVal: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationTransformPattern2,
                retVal: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedZoomLevel: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationTransformPattern2,
                retVal: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationTransformPattern2,
                retVal: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentZoomMinimum: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationTransformPattern2,
                retVal: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationTransformPattern2,
                retVal: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedZoomMinimum: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationTransformPattern2,
                retVal: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationTransformPattern2,
                retVal: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentZoomMaximum: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationTransformPattern2,
                retVal: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationTransformPattern2,
                retVal: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedZoomMaximum: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationTransformPattern2,
                retVal: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationTransformPattern2,
                retVal: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUIAutomationTransformPattern.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTransformPattern2_Zoom(self: *const T, zoomValue: f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTransformPattern2.VTable, self.vtable).Zoom(@ptrCast(*const IUIAutomationTransformPattern2, self), zoomValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTransformPattern2_ZoomByUnit(self: *const T, zoomUnit: ZoomUnit) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTransformPattern2.VTable, self.vtable).ZoomByUnit(@ptrCast(*const IUIAutomationTransformPattern2, self), zoomUnit);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTransformPattern2_get_CurrentCanZoom(self: *const T, retVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTransformPattern2.VTable, self.vtable).get_CurrentCanZoom(@ptrCast(*const IUIAutomationTransformPattern2, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTransformPattern2_get_CachedCanZoom(self: *const T, retVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTransformPattern2.VTable, self.vtable).get_CachedCanZoom(@ptrCast(*const IUIAutomationTransformPattern2, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTransformPattern2_get_CurrentZoomLevel(self: *const T, retVal: ?*f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTransformPattern2.VTable, self.vtable).get_CurrentZoomLevel(@ptrCast(*const IUIAutomationTransformPattern2, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTransformPattern2_get_CachedZoomLevel(self: *const T, retVal: ?*f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTransformPattern2.VTable, self.vtable).get_CachedZoomLevel(@ptrCast(*const IUIAutomationTransformPattern2, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTransformPattern2_get_CurrentZoomMinimum(self: *const T, retVal: ?*f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTransformPattern2.VTable, self.vtable).get_CurrentZoomMinimum(@ptrCast(*const IUIAutomationTransformPattern2, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTransformPattern2_get_CachedZoomMinimum(self: *const T, retVal: ?*f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTransformPattern2.VTable, self.vtable).get_CachedZoomMinimum(@ptrCast(*const IUIAutomationTransformPattern2, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTransformPattern2_get_CurrentZoomMaximum(self: *const T, retVal: ?*f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTransformPattern2.VTable, self.vtable).get_CurrentZoomMaximum(@ptrCast(*const IUIAutomationTransformPattern2, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTransformPattern2_get_CachedZoomMaximum(self: *const T, retVal: ?*f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTransformPattern2.VTable, self.vtable).get_CachedZoomMaximum(@ptrCast(*const IUIAutomationTransformPattern2, self), retVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IUIAutomationTextChildPattern_Value = Guid.initString("6552b038-ae05-40c8-abfd-aa08352aab86");
pub const IID_IUIAutomationTextChildPattern = &IID_IUIAutomationTextChildPattern_Value;
pub const IUIAutomationTextChildPattern = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TextContainer: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationTextChildPattern,
                container: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationTextChildPattern,
                container: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TextRange: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationTextChildPattern,
                range: ?*?*IUIAutomationTextRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationTextChildPattern,
                range: ?*?*IUIAutomationTextRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTextChildPattern_get_TextContainer(self: *const T, container: ?*?*IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTextChildPattern.VTable, self.vtable).get_TextContainer(@ptrCast(*const IUIAutomationTextChildPattern, self), container);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTextChildPattern_get_TextRange(self: *const T, range: ?*?*IUIAutomationTextRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTextChildPattern.VTable, self.vtable).get_TextRange(@ptrCast(*const IUIAutomationTextChildPattern, self), range);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IUIAutomationDragPattern_Value = Guid.initString("1dc7b570-1f54-4bad-bcda-d36a722fb7bd");
pub const IID_IUIAutomationDragPattern = &IID_IUIAutomationDragPattern_Value;
pub const IUIAutomationDragPattern = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentIsGrabbed: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationDragPattern,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationDragPattern,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedIsGrabbed: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationDragPattern,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationDragPattern,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentDropEffect: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationDragPattern,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationDragPattern,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedDropEffect: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationDragPattern,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationDragPattern,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentDropEffects: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationDragPattern,
                retVal: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationDragPattern,
                retVal: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedDropEffects: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationDragPattern,
                retVal: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationDragPattern,
                retVal: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentGrabbedItems: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationDragPattern,
                retVal: ?*?*IUIAutomationElementArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationDragPattern,
                retVal: ?*?*IUIAutomationElementArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCachedGrabbedItems: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationDragPattern,
                retVal: ?*?*IUIAutomationElementArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationDragPattern,
                retVal: ?*?*IUIAutomationElementArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationDragPattern_get_CurrentIsGrabbed(self: *const T, retVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationDragPattern.VTable, self.vtable).get_CurrentIsGrabbed(@ptrCast(*const IUIAutomationDragPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationDragPattern_get_CachedIsGrabbed(self: *const T, retVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationDragPattern.VTable, self.vtable).get_CachedIsGrabbed(@ptrCast(*const IUIAutomationDragPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationDragPattern_get_CurrentDropEffect(self: *const T, retVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationDragPattern.VTable, self.vtable).get_CurrentDropEffect(@ptrCast(*const IUIAutomationDragPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationDragPattern_get_CachedDropEffect(self: *const T, retVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationDragPattern.VTable, self.vtable).get_CachedDropEffect(@ptrCast(*const IUIAutomationDragPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationDragPattern_get_CurrentDropEffects(self: *const T, retVal: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationDragPattern.VTable, self.vtable).get_CurrentDropEffects(@ptrCast(*const IUIAutomationDragPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationDragPattern_get_CachedDropEffects(self: *const T, retVal: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationDragPattern.VTable, self.vtable).get_CachedDropEffects(@ptrCast(*const IUIAutomationDragPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationDragPattern_GetCurrentGrabbedItems(self: *const T, retVal: ?*?*IUIAutomationElementArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationDragPattern.VTable, self.vtable).GetCurrentGrabbedItems(@ptrCast(*const IUIAutomationDragPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationDragPattern_GetCachedGrabbedItems(self: *const T, retVal: ?*?*IUIAutomationElementArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationDragPattern.VTable, self.vtable).GetCachedGrabbedItems(@ptrCast(*const IUIAutomationDragPattern, self), retVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IUIAutomationDropTargetPattern_Value = Guid.initString("69a095f7-eee4-430e-a46b-fb73b1ae39a5");
pub const IID_IUIAutomationDropTargetPattern = &IID_IUIAutomationDropTargetPattern_Value;
pub const IUIAutomationDropTargetPattern = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentDropTargetEffect: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationDropTargetPattern,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationDropTargetPattern,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedDropTargetEffect: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationDropTargetPattern,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationDropTargetPattern,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentDropTargetEffects: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationDropTargetPattern,
                retVal: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationDropTargetPattern,
                retVal: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedDropTargetEffects: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationDropTargetPattern,
                retVal: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationDropTargetPattern,
                retVal: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationDropTargetPattern_get_CurrentDropTargetEffect(self: *const T, retVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationDropTargetPattern.VTable, self.vtable).get_CurrentDropTargetEffect(@ptrCast(*const IUIAutomationDropTargetPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationDropTargetPattern_get_CachedDropTargetEffect(self: *const T, retVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationDropTargetPattern.VTable, self.vtable).get_CachedDropTargetEffect(@ptrCast(*const IUIAutomationDropTargetPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationDropTargetPattern_get_CurrentDropTargetEffects(self: *const T, retVal: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationDropTargetPattern.VTable, self.vtable).get_CurrentDropTargetEffects(@ptrCast(*const IUIAutomationDropTargetPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationDropTargetPattern_get_CachedDropTargetEffects(self: *const T, retVal: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationDropTargetPattern.VTable, self.vtable).get_CachedDropTargetEffects(@ptrCast(*const IUIAutomationDropTargetPattern, self), retVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IUIAutomationElement2_Value = Guid.initString("6749c683-f70d-4487-a698-5f79d55290d6");
pub const IID_IUIAutomationElement2 = &IID_IUIAutomationElement2_Value;
pub const IUIAutomationElement2 = extern struct {
    pub const VTable = extern struct {
        base: IUIAutomationElement.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentOptimizeForVisualContent: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement2,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement2,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedOptimizeForVisualContent: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement2,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement2,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentLiveSetting: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement2,
                retVal: ?*LiveSetting,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement2,
                retVal: ?*LiveSetting,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedLiveSetting: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement2,
                retVal: ?*LiveSetting,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement2,
                retVal: ?*LiveSetting,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentFlowsFrom: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement2,
                retVal: ?*?*IUIAutomationElementArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement2,
                retVal: ?*?*IUIAutomationElementArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedFlowsFrom: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement2,
                retVal: ?*?*IUIAutomationElementArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement2,
                retVal: ?*?*IUIAutomationElementArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUIAutomationElement.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement2_get_CurrentOptimizeForVisualContent(self: *const T, retVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement2.VTable, self.vtable).get_CurrentOptimizeForVisualContent(@ptrCast(*const IUIAutomationElement2, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement2_get_CachedOptimizeForVisualContent(self: *const T, retVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement2.VTable, self.vtable).get_CachedOptimizeForVisualContent(@ptrCast(*const IUIAutomationElement2, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement2_get_CurrentLiveSetting(self: *const T, retVal: ?*LiveSetting) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement2.VTable, self.vtable).get_CurrentLiveSetting(@ptrCast(*const IUIAutomationElement2, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement2_get_CachedLiveSetting(self: *const T, retVal: ?*LiveSetting) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement2.VTable, self.vtable).get_CachedLiveSetting(@ptrCast(*const IUIAutomationElement2, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement2_get_CurrentFlowsFrom(self: *const T, retVal: ?*?*IUIAutomationElementArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement2.VTable, self.vtable).get_CurrentFlowsFrom(@ptrCast(*const IUIAutomationElement2, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement2_get_CachedFlowsFrom(self: *const T, retVal: ?*?*IUIAutomationElementArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement2.VTable, self.vtable).get_CachedFlowsFrom(@ptrCast(*const IUIAutomationElement2, self), retVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.1'
const IID_IUIAutomationElement3_Value = Guid.initString("8471df34-aee0-4a01-a7de-7db9af12c296");
pub const IID_IUIAutomationElement3 = &IID_IUIAutomationElement3_Value;
pub const IUIAutomationElement3 = extern struct {
    pub const VTable = extern struct {
        base: IUIAutomationElement2.VTable,
        ShowContextMenu: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationElement3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationElement3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentIsPeripheral: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement3,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement3,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedIsPeripheral: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement3,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement3,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUIAutomationElement2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement3_ShowContextMenu(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement3.VTable, self.vtable).ShowContextMenu(@ptrCast(*const IUIAutomationElement3, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement3_get_CurrentIsPeripheral(self: *const T, retVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement3.VTable, self.vtable).get_CurrentIsPeripheral(@ptrCast(*const IUIAutomationElement3, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement3_get_CachedIsPeripheral(self: *const T, retVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement3.VTable, self.vtable).get_CachedIsPeripheral(@ptrCast(*const IUIAutomationElement3, self), retVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IUIAutomationElement4_Value = Guid.initString("3b6e233c-52fb-4063-a4c9-77c075c2a06b");
pub const IID_IUIAutomationElement4 = &IID_IUIAutomationElement4_Value;
pub const IUIAutomationElement4 = extern struct {
    pub const VTable = extern struct {
        base: IUIAutomationElement3.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentPositionInSet: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement4,
                retVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement4,
                retVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentSizeOfSet: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement4,
                retVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement4,
                retVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentLevel: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement4,
                retVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement4,
                retVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentAnnotationTypes: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement4,
                retVal: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement4,
                retVal: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentAnnotationObjects: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement4,
                retVal: ?*?*IUIAutomationElementArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement4,
                retVal: ?*?*IUIAutomationElementArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedPositionInSet: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement4,
                retVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement4,
                retVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedSizeOfSet: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement4,
                retVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement4,
                retVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedLevel: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement4,
                retVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement4,
                retVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedAnnotationTypes: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement4,
                retVal: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement4,
                retVal: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedAnnotationObjects: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement4,
                retVal: ?*?*IUIAutomationElementArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement4,
                retVal: ?*?*IUIAutomationElementArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUIAutomationElement3.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement4_get_CurrentPositionInSet(self: *const T, retVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement4.VTable, self.vtable).get_CurrentPositionInSet(@ptrCast(*const IUIAutomationElement4, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement4_get_CurrentSizeOfSet(self: *const T, retVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement4.VTable, self.vtable).get_CurrentSizeOfSet(@ptrCast(*const IUIAutomationElement4, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement4_get_CurrentLevel(self: *const T, retVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement4.VTable, self.vtable).get_CurrentLevel(@ptrCast(*const IUIAutomationElement4, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement4_get_CurrentAnnotationTypes(self: *const T, retVal: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement4.VTable, self.vtable).get_CurrentAnnotationTypes(@ptrCast(*const IUIAutomationElement4, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement4_get_CurrentAnnotationObjects(self: *const T, retVal: ?*?*IUIAutomationElementArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement4.VTable, self.vtable).get_CurrentAnnotationObjects(@ptrCast(*const IUIAutomationElement4, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement4_get_CachedPositionInSet(self: *const T, retVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement4.VTable, self.vtable).get_CachedPositionInSet(@ptrCast(*const IUIAutomationElement4, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement4_get_CachedSizeOfSet(self: *const T, retVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement4.VTable, self.vtable).get_CachedSizeOfSet(@ptrCast(*const IUIAutomationElement4, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement4_get_CachedLevel(self: *const T, retVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement4.VTable, self.vtable).get_CachedLevel(@ptrCast(*const IUIAutomationElement4, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement4_get_CachedAnnotationTypes(self: *const T, retVal: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement4.VTable, self.vtable).get_CachedAnnotationTypes(@ptrCast(*const IUIAutomationElement4, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement4_get_CachedAnnotationObjects(self: *const T, retVal: ?*?*IUIAutomationElementArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement4.VTable, self.vtable).get_CachedAnnotationObjects(@ptrCast(*const IUIAutomationElement4, self), retVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.15063'
const IID_IUIAutomationElement5_Value = Guid.initString("98141c1d-0d0e-4175-bbe2-6bff455842a7");
pub const IID_IUIAutomationElement5 = &IID_IUIAutomationElement5_Value;
pub const IUIAutomationElement5 = extern struct {
    pub const VTable = extern struct {
        base: IUIAutomationElement4.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentLandmarkType: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement5,
                retVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement5,
                retVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentLocalizedLandmarkType: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement5,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement5,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedLandmarkType: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement5,
                retVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement5,
                retVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedLocalizedLandmarkType: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement5,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement5,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUIAutomationElement4.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement5_get_CurrentLandmarkType(self: *const T, retVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement5.VTable, self.vtable).get_CurrentLandmarkType(@ptrCast(*const IUIAutomationElement5, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement5_get_CurrentLocalizedLandmarkType(self: *const T, retVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement5.VTable, self.vtable).get_CurrentLocalizedLandmarkType(@ptrCast(*const IUIAutomationElement5, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement5_get_CachedLandmarkType(self: *const T, retVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement5.VTable, self.vtable).get_CachedLandmarkType(@ptrCast(*const IUIAutomationElement5, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement5_get_CachedLocalizedLandmarkType(self: *const T, retVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement5.VTable, self.vtable).get_CachedLocalizedLandmarkType(@ptrCast(*const IUIAutomationElement5, self), retVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.15063'
const IID_IUIAutomationElement6_Value = Guid.initString("4780d450-8bca-4977-afa5-a4a517f555e3");
pub const IID_IUIAutomationElement6 = &IID_IUIAutomationElement6_Value;
pub const IUIAutomationElement6 = extern struct {
    pub const VTable = extern struct {
        base: IUIAutomationElement5.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentFullDescription: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement6,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement6,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedFullDescription: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement6,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement6,
                retVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUIAutomationElement5.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement6_get_CurrentFullDescription(self: *const T, retVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement6.VTable, self.vtable).get_CurrentFullDescription(@ptrCast(*const IUIAutomationElement6, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement6_get_CachedFullDescription(self: *const T, retVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement6.VTable, self.vtable).get_CachedFullDescription(@ptrCast(*const IUIAutomationElement6, self), retVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.15063'
const IID_IUIAutomationElement7_Value = Guid.initString("204e8572-cfc3-4c11-b0c8-7da7420750b7");
pub const IID_IUIAutomationElement7 = &IID_IUIAutomationElement7_Value;
pub const IUIAutomationElement7 = extern struct {
    pub const VTable = extern struct {
        base: IUIAutomationElement6.VTable,
        FindFirstWithOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationElement7,
                scope: TreeScope,
                condition: ?*IUIAutomationCondition,
                traversalOptions: TreeTraversalOptions,
                root: ?*IUIAutomationElement,
                found: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationElement7,
                scope: TreeScope,
                condition: ?*IUIAutomationCondition,
                traversalOptions: TreeTraversalOptions,
                root: ?*IUIAutomationElement,
                found: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindAllWithOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationElement7,
                scope: TreeScope,
                condition: ?*IUIAutomationCondition,
                traversalOptions: TreeTraversalOptions,
                root: ?*IUIAutomationElement,
                found: ?*?*IUIAutomationElementArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationElement7,
                scope: TreeScope,
                condition: ?*IUIAutomationCondition,
                traversalOptions: TreeTraversalOptions,
                root: ?*IUIAutomationElement,
                found: ?*?*IUIAutomationElementArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindFirstWithOptionsBuildCache: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationElement7,
                scope: TreeScope,
                condition: ?*IUIAutomationCondition,
                cacheRequest: ?*IUIAutomationCacheRequest,
                traversalOptions: TreeTraversalOptions,
                root: ?*IUIAutomationElement,
                found: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationElement7,
                scope: TreeScope,
                condition: ?*IUIAutomationCondition,
                cacheRequest: ?*IUIAutomationCacheRequest,
                traversalOptions: TreeTraversalOptions,
                root: ?*IUIAutomationElement,
                found: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindAllWithOptionsBuildCache: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationElement7,
                scope: TreeScope,
                condition: ?*IUIAutomationCondition,
                cacheRequest: ?*IUIAutomationCacheRequest,
                traversalOptions: TreeTraversalOptions,
                root: ?*IUIAutomationElement,
                found: ?*?*IUIAutomationElementArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationElement7,
                scope: TreeScope,
                condition: ?*IUIAutomationCondition,
                cacheRequest: ?*IUIAutomationCacheRequest,
                traversalOptions: TreeTraversalOptions,
                root: ?*IUIAutomationElement,
                found: ?*?*IUIAutomationElementArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentMetadataValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationElement7,
                targetId: i32,
                metadataId: i32,
                returnVal: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationElement7,
                targetId: i32,
                metadataId: i32,
                returnVal: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUIAutomationElement6.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement7_FindFirstWithOptions(self: *const T, scope: TreeScope, condition: ?*IUIAutomationCondition, traversalOptions: TreeTraversalOptions, root: ?*IUIAutomationElement, found: ?*?*IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement7.VTable, self.vtable).FindFirstWithOptions(@ptrCast(*const IUIAutomationElement7, self), scope, condition, traversalOptions, root, found);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement7_FindAllWithOptions(self: *const T, scope: TreeScope, condition: ?*IUIAutomationCondition, traversalOptions: TreeTraversalOptions, root: ?*IUIAutomationElement, found: ?*?*IUIAutomationElementArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement7.VTable, self.vtable).FindAllWithOptions(@ptrCast(*const IUIAutomationElement7, self), scope, condition, traversalOptions, root, found);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement7_FindFirstWithOptionsBuildCache(self: *const T, scope: TreeScope, condition: ?*IUIAutomationCondition, cacheRequest: ?*IUIAutomationCacheRequest, traversalOptions: TreeTraversalOptions, root: ?*IUIAutomationElement, found: ?*?*IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement7.VTable, self.vtable).FindFirstWithOptionsBuildCache(@ptrCast(*const IUIAutomationElement7, self), scope, condition, cacheRequest, traversalOptions, root, found);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement7_FindAllWithOptionsBuildCache(self: *const T, scope: TreeScope, condition: ?*IUIAutomationCondition, cacheRequest: ?*IUIAutomationCacheRequest, traversalOptions: TreeTraversalOptions, root: ?*IUIAutomationElement, found: ?*?*IUIAutomationElementArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement7.VTable, self.vtable).FindAllWithOptionsBuildCache(@ptrCast(*const IUIAutomationElement7, self), scope, condition, cacheRequest, traversalOptions, root, found);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement7_GetCurrentMetadataValue(self: *const T, targetId: i32, metadataId: i32, returnVal: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement7.VTable, self.vtable).GetCurrentMetadataValue(@ptrCast(*const IUIAutomationElement7, self), targetId, metadataId, returnVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.17134'
const IID_IUIAutomationElement8_Value = Guid.initString("8c60217d-5411-4cde-bcc0-1ceda223830c");
pub const IID_IUIAutomationElement8 = &IID_IUIAutomationElement8_Value;
pub const IUIAutomationElement8 = extern struct {
    pub const VTable = extern struct {
        base: IUIAutomationElement7.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentHeadingLevel: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement8,
                retVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement8,
                retVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedHeadingLevel: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement8,
                retVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement8,
                retVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUIAutomationElement7.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement8_get_CurrentHeadingLevel(self: *const T, retVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement8.VTable, self.vtable).get_CurrentHeadingLevel(@ptrCast(*const IUIAutomationElement8, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement8_get_CachedHeadingLevel(self: *const T, retVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement8.VTable, self.vtable).get_CachedHeadingLevel(@ptrCast(*const IUIAutomationElement8, self), retVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.17763'
const IID_IUIAutomationElement9_Value = Guid.initString("39325fac-039d-440e-a3a3-5eb81a5cecc3");
pub const IID_IUIAutomationElement9 = &IID_IUIAutomationElement9_Value;
pub const IUIAutomationElement9 = extern struct {
    pub const VTable = extern struct {
        base: IUIAutomationElement8.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentIsDialog: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement9,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement9,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CachedIsDialog: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationElement9,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationElement9,
                retVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUIAutomationElement8.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement9_get_CurrentIsDialog(self: *const T, retVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement9.VTable, self.vtable).get_CurrentIsDialog(@ptrCast(*const IUIAutomationElement9, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement9_get_CachedIsDialog(self: *const T, retVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement9.VTable, self.vtable).get_CachedIsDialog(@ptrCast(*const IUIAutomationElement9, self), retVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IUIAutomationProxyFactory_Value = Guid.initString("85b94ecd-849d-42b6-b94d-d6db23fdf5a4");
pub const IID_IUIAutomationProxyFactory = &IID_IUIAutomationProxyFactory_Value;
pub const IUIAutomationProxyFactory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateProvider: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationProxyFactory,
                hwnd: ?HWND,
                idObject: i32,
                idChild: i32,
                provider: ?*?*IRawElementProviderSimple,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationProxyFactory,
                hwnd: ?HWND,
                idObject: i32,
                idChild: i32,
                provider: ?*?*IRawElementProviderSimple,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ProxyFactoryId: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationProxyFactory,
                factoryId: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationProxyFactory,
                factoryId: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationProxyFactory_CreateProvider(self: *const T, hwnd: ?HWND, idObject: i32, idChild: i32, provider: ?*?*IRawElementProviderSimple) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationProxyFactory.VTable, self.vtable).CreateProvider(@ptrCast(*const IUIAutomationProxyFactory, self), hwnd, idObject, idChild, provider);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationProxyFactory_get_ProxyFactoryId(self: *const T, factoryId: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationProxyFactory.VTable, self.vtable).get_ProxyFactoryId(@ptrCast(*const IUIAutomationProxyFactory, self), factoryId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IUIAutomationProxyFactoryEntry_Value = Guid.initString("d50e472e-b64b-490c-bca1-d30696f9f289");
pub const IID_IUIAutomationProxyFactoryEntry = &IID_IUIAutomationProxyFactoryEntry_Value;
pub const IUIAutomationProxyFactoryEntry = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ProxyFactory: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationProxyFactoryEntry,
                factory: ?*?*IUIAutomationProxyFactory,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationProxyFactoryEntry,
                factory: ?*?*IUIAutomationProxyFactory,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ClassName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationProxyFactoryEntry,
                className: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationProxyFactoryEntry,
                className: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ImageName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationProxyFactoryEntry,
                imageName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationProxyFactoryEntry,
                imageName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AllowSubstringMatch: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationProxyFactoryEntry,
                allowSubstringMatch: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationProxyFactoryEntry,
                allowSubstringMatch: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CanCheckBaseClass: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationProxyFactoryEntry,
                canCheckBaseClass: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationProxyFactoryEntry,
                canCheckBaseClass: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NeedsAdviseEvents: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationProxyFactoryEntry,
                adviseEvents: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationProxyFactoryEntry,
                adviseEvents: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ClassName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationProxyFactoryEntry,
                className: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationProxyFactoryEntry,
                className: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ImageName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationProxyFactoryEntry,
                imageName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationProxyFactoryEntry,
                imageName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AllowSubstringMatch: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationProxyFactoryEntry,
                allowSubstringMatch: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationProxyFactoryEntry,
                allowSubstringMatch: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_CanCheckBaseClass: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationProxyFactoryEntry,
                canCheckBaseClass: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationProxyFactoryEntry,
                canCheckBaseClass: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_NeedsAdviseEvents: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationProxyFactoryEntry,
                adviseEvents: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationProxyFactoryEntry,
                adviseEvents: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetWinEventsForAutomationEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationProxyFactoryEntry,
                eventId: i32,
                propertyId: i32,
                winEvents: ?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationProxyFactoryEntry,
                eventId: i32,
                propertyId: i32,
                winEvents: ?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetWinEventsForAutomationEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationProxyFactoryEntry,
                eventId: i32,
                propertyId: i32,
                winEvents: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationProxyFactoryEntry,
                eventId: i32,
                propertyId: i32,
                winEvents: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationProxyFactoryEntry_get_ProxyFactory(self: *const T, factory: ?*?*IUIAutomationProxyFactory) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationProxyFactoryEntry.VTable, self.vtable).get_ProxyFactory(@ptrCast(*const IUIAutomationProxyFactoryEntry, self), factory);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationProxyFactoryEntry_get_ClassName(self: *const T, className: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationProxyFactoryEntry.VTable, self.vtable).get_ClassName(@ptrCast(*const IUIAutomationProxyFactoryEntry, self), className);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationProxyFactoryEntry_get_ImageName(self: *const T, imageName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationProxyFactoryEntry.VTable, self.vtable).get_ImageName(@ptrCast(*const IUIAutomationProxyFactoryEntry, self), imageName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationProxyFactoryEntry_get_AllowSubstringMatch(self: *const T, allowSubstringMatch: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationProxyFactoryEntry.VTable, self.vtable).get_AllowSubstringMatch(@ptrCast(*const IUIAutomationProxyFactoryEntry, self), allowSubstringMatch);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationProxyFactoryEntry_get_CanCheckBaseClass(self: *const T, canCheckBaseClass: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationProxyFactoryEntry.VTable, self.vtable).get_CanCheckBaseClass(@ptrCast(*const IUIAutomationProxyFactoryEntry, self), canCheckBaseClass);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationProxyFactoryEntry_get_NeedsAdviseEvents(self: *const T, adviseEvents: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationProxyFactoryEntry.VTable, self.vtable).get_NeedsAdviseEvents(@ptrCast(*const IUIAutomationProxyFactoryEntry, self), adviseEvents);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationProxyFactoryEntry_put_ClassName(self: *const T, className: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationProxyFactoryEntry.VTable, self.vtable).put_ClassName(@ptrCast(*const IUIAutomationProxyFactoryEntry, self), className);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationProxyFactoryEntry_put_ImageName(self: *const T, imageName: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationProxyFactoryEntry.VTable, self.vtable).put_ImageName(@ptrCast(*const IUIAutomationProxyFactoryEntry, self), imageName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationProxyFactoryEntry_put_AllowSubstringMatch(self: *const T, allowSubstringMatch: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationProxyFactoryEntry.VTable, self.vtable).put_AllowSubstringMatch(@ptrCast(*const IUIAutomationProxyFactoryEntry, self), allowSubstringMatch);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationProxyFactoryEntry_put_CanCheckBaseClass(self: *const T, canCheckBaseClass: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationProxyFactoryEntry.VTable, self.vtable).put_CanCheckBaseClass(@ptrCast(*const IUIAutomationProxyFactoryEntry, self), canCheckBaseClass);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationProxyFactoryEntry_put_NeedsAdviseEvents(self: *const T, adviseEvents: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationProxyFactoryEntry.VTable, self.vtable).put_NeedsAdviseEvents(@ptrCast(*const IUIAutomationProxyFactoryEntry, self), adviseEvents);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationProxyFactoryEntry_SetWinEventsForAutomationEvent(self: *const T, eventId: i32, propertyId: i32, winEvents: ?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationProxyFactoryEntry.VTable, self.vtable).SetWinEventsForAutomationEvent(@ptrCast(*const IUIAutomationProxyFactoryEntry, self), eventId, propertyId, winEvents);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationProxyFactoryEntry_GetWinEventsForAutomationEvent(self: *const T, eventId: i32, propertyId: i32, winEvents: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationProxyFactoryEntry.VTable, self.vtable).GetWinEventsForAutomationEvent(@ptrCast(*const IUIAutomationProxyFactoryEntry, self), eventId, propertyId, winEvents);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IUIAutomationProxyFactoryMapping_Value = Guid.initString("09e31e18-872d-4873-93d1-1e541ec133fd");
pub const IID_IUIAutomationProxyFactoryMapping = &IID_IUIAutomationProxyFactoryMapping_Value;
pub const IUIAutomationProxyFactoryMapping = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomationProxyFactoryMapping,
                count: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomationProxyFactoryMapping,
                count: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTable: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationProxyFactoryMapping,
                table: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationProxyFactoryMapping,
                table: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEntry: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationProxyFactoryMapping,
                index: u32,
                entry: ?*?*IUIAutomationProxyFactoryEntry,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationProxyFactoryMapping,
                index: u32,
                entry: ?*?*IUIAutomationProxyFactoryEntry,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTable: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationProxyFactoryMapping,
                factoryList: ?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationProxyFactoryMapping,
                factoryList: ?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InsertEntries: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationProxyFactoryMapping,
                before: u32,
                factoryList: ?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationProxyFactoryMapping,
                before: u32,
                factoryList: ?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InsertEntry: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationProxyFactoryMapping,
                before: u32,
                factory: ?*IUIAutomationProxyFactoryEntry,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationProxyFactoryMapping,
                before: u32,
                factory: ?*IUIAutomationProxyFactoryEntry,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveEntry: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationProxyFactoryMapping,
                index: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationProxyFactoryMapping,
                index: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ClearTable: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationProxyFactoryMapping,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationProxyFactoryMapping,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RestoreDefaultTable: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationProxyFactoryMapping,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationProxyFactoryMapping,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationProxyFactoryMapping_get_Count(self: *const T, count: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationProxyFactoryMapping.VTable, self.vtable).get_Count(@ptrCast(*const IUIAutomationProxyFactoryMapping, self), count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationProxyFactoryMapping_GetTable(self: *const T, table: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationProxyFactoryMapping.VTable, self.vtable).GetTable(@ptrCast(*const IUIAutomationProxyFactoryMapping, self), table);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationProxyFactoryMapping_GetEntry(self: *const T, index: u32, entry: ?*?*IUIAutomationProxyFactoryEntry) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationProxyFactoryMapping.VTable, self.vtable).GetEntry(@ptrCast(*const IUIAutomationProxyFactoryMapping, self), index, entry);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationProxyFactoryMapping_SetTable(self: *const T, factoryList: ?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationProxyFactoryMapping.VTable, self.vtable).SetTable(@ptrCast(*const IUIAutomationProxyFactoryMapping, self), factoryList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationProxyFactoryMapping_InsertEntries(self: *const T, before: u32, factoryList: ?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationProxyFactoryMapping.VTable, self.vtable).InsertEntries(@ptrCast(*const IUIAutomationProxyFactoryMapping, self), before, factoryList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationProxyFactoryMapping_InsertEntry(self: *const T, before: u32, factory: ?*IUIAutomationProxyFactoryEntry) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationProxyFactoryMapping.VTable, self.vtable).InsertEntry(@ptrCast(*const IUIAutomationProxyFactoryMapping, self), before, factory);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationProxyFactoryMapping_RemoveEntry(self: *const T, index: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationProxyFactoryMapping.VTable, self.vtable).RemoveEntry(@ptrCast(*const IUIAutomationProxyFactoryMapping, self), index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationProxyFactoryMapping_ClearTable(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationProxyFactoryMapping.VTable, self.vtable).ClearTable(@ptrCast(*const IUIAutomationProxyFactoryMapping, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationProxyFactoryMapping_RestoreDefaultTable(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationProxyFactoryMapping.VTable, self.vtable).RestoreDefaultTable(@ptrCast(*const IUIAutomationProxyFactoryMapping, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.17763'
const IID_IUIAutomationEventHandlerGroup_Value = Guid.initString("c9ee12f2-c13b-4408-997c-639914377f4e");
pub const IID_IUIAutomationEventHandlerGroup = &IID_IUIAutomationEventHandlerGroup_Value;
pub const IUIAutomationEventHandlerGroup = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddActiveTextPositionChangedEventHandler: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationEventHandlerGroup,
                scope: TreeScope,
                cacheRequest: ?*IUIAutomationCacheRequest,
                handler: ?*IUIAutomationActiveTextPositionChangedEventHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationEventHandlerGroup,
                scope: TreeScope,
                cacheRequest: ?*IUIAutomationCacheRequest,
                handler: ?*IUIAutomationActiveTextPositionChangedEventHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddAutomationEventHandler: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationEventHandlerGroup,
                eventId: i32,
                scope: TreeScope,
                cacheRequest: ?*IUIAutomationCacheRequest,
                handler: ?*IUIAutomationEventHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationEventHandlerGroup,
                eventId: i32,
                scope: TreeScope,
                cacheRequest: ?*IUIAutomationCacheRequest,
                handler: ?*IUIAutomationEventHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddChangesEventHandler: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationEventHandlerGroup,
                scope: TreeScope,
                changeTypes: [*]i32,
                changesCount: i32,
                cacheRequest: ?*IUIAutomationCacheRequest,
                handler: ?*IUIAutomationChangesEventHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationEventHandlerGroup,
                scope: TreeScope,
                changeTypes: [*]i32,
                changesCount: i32,
                cacheRequest: ?*IUIAutomationCacheRequest,
                handler: ?*IUIAutomationChangesEventHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddNotificationEventHandler: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationEventHandlerGroup,
                scope: TreeScope,
                cacheRequest: ?*IUIAutomationCacheRequest,
                handler: ?*IUIAutomationNotificationEventHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationEventHandlerGroup,
                scope: TreeScope,
                cacheRequest: ?*IUIAutomationCacheRequest,
                handler: ?*IUIAutomationNotificationEventHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddPropertyChangedEventHandler: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationEventHandlerGroup,
                scope: TreeScope,
                cacheRequest: ?*IUIAutomationCacheRequest,
                handler: ?*IUIAutomationPropertyChangedEventHandler,
                propertyArray: [*]i32,
                propertyCount: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationEventHandlerGroup,
                scope: TreeScope,
                cacheRequest: ?*IUIAutomationCacheRequest,
                handler: ?*IUIAutomationPropertyChangedEventHandler,
                propertyArray: [*]i32,
                propertyCount: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddStructureChangedEventHandler: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationEventHandlerGroup,
                scope: TreeScope,
                cacheRequest: ?*IUIAutomationCacheRequest,
                handler: ?*IUIAutomationStructureChangedEventHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationEventHandlerGroup,
                scope: TreeScope,
                cacheRequest: ?*IUIAutomationCacheRequest,
                handler: ?*IUIAutomationStructureChangedEventHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddTextEditTextChangedEventHandler: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomationEventHandlerGroup,
                scope: TreeScope,
                textEditChangeType: TextEditChangeType,
                cacheRequest: ?*IUIAutomationCacheRequest,
                handler: ?*IUIAutomationTextEditTextChangedEventHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomationEventHandlerGroup,
                scope: TreeScope,
                textEditChangeType: TextEditChangeType,
                cacheRequest: ?*IUIAutomationCacheRequest,
                handler: ?*IUIAutomationTextEditTextChangedEventHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationEventHandlerGroup_AddActiveTextPositionChangedEventHandler(self: *const T, scope: TreeScope, cacheRequest: ?*IUIAutomationCacheRequest, handler: ?*IUIAutomationActiveTextPositionChangedEventHandler) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationEventHandlerGroup.VTable, self.vtable).AddActiveTextPositionChangedEventHandler(@ptrCast(*const IUIAutomationEventHandlerGroup, self), scope, cacheRequest, handler);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationEventHandlerGroup_AddAutomationEventHandler(self: *const T, eventId: i32, scope: TreeScope, cacheRequest: ?*IUIAutomationCacheRequest, handler: ?*IUIAutomationEventHandler) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationEventHandlerGroup.VTable, self.vtable).AddAutomationEventHandler(@ptrCast(*const IUIAutomationEventHandlerGroup, self), eventId, scope, cacheRequest, handler);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationEventHandlerGroup_AddChangesEventHandler(self: *const T, scope: TreeScope, changeTypes: [*]i32, changesCount: i32, cacheRequest: ?*IUIAutomationCacheRequest, handler: ?*IUIAutomationChangesEventHandler) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationEventHandlerGroup.VTable, self.vtable).AddChangesEventHandler(@ptrCast(*const IUIAutomationEventHandlerGroup, self), scope, changeTypes, changesCount, cacheRequest, handler);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationEventHandlerGroup_AddNotificationEventHandler(self: *const T, scope: TreeScope, cacheRequest: ?*IUIAutomationCacheRequest, handler: ?*IUIAutomationNotificationEventHandler) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationEventHandlerGroup.VTable, self.vtable).AddNotificationEventHandler(@ptrCast(*const IUIAutomationEventHandlerGroup, self), scope, cacheRequest, handler);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationEventHandlerGroup_AddPropertyChangedEventHandler(self: *const T, scope: TreeScope, cacheRequest: ?*IUIAutomationCacheRequest, handler: ?*IUIAutomationPropertyChangedEventHandler, propertyArray: [*]i32, propertyCount: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationEventHandlerGroup.VTable, self.vtable).AddPropertyChangedEventHandler(@ptrCast(*const IUIAutomationEventHandlerGroup, self), scope, cacheRequest, handler, propertyArray, propertyCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationEventHandlerGroup_AddStructureChangedEventHandler(self: *const T, scope: TreeScope, cacheRequest: ?*IUIAutomationCacheRequest, handler: ?*IUIAutomationStructureChangedEventHandler) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationEventHandlerGroup.VTable, self.vtable).AddStructureChangedEventHandler(@ptrCast(*const IUIAutomationEventHandlerGroup, self), scope, cacheRequest, handler);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationEventHandlerGroup_AddTextEditTextChangedEventHandler(self: *const T, scope: TreeScope, textEditChangeType: TextEditChangeType, cacheRequest: ?*IUIAutomationCacheRequest, handler: ?*IUIAutomationTextEditTextChangedEventHandler) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationEventHandlerGroup.VTable, self.vtable).AddTextEditTextChangedEventHandler(@ptrCast(*const IUIAutomationEventHandlerGroup, self), scope, textEditChangeType, cacheRequest, handler);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IUIAutomation_Value = Guid.initString("30cbe57d-d9d0-452a-ab13-7ac5ac4825ee");
pub const IID_IUIAutomation = &IID_IUIAutomation_Value;
pub const IUIAutomation = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CompareElements: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomation,
                el1: ?*IUIAutomationElement,
                el2: ?*IUIAutomationElement,
                areSame: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomation,
                el1: ?*IUIAutomationElement,
                el2: ?*IUIAutomationElement,
                areSame: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CompareRuntimeIds: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomation,
                runtimeId1: ?*SAFEARRAY,
                runtimeId2: ?*SAFEARRAY,
                areSame: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomation,
                runtimeId1: ?*SAFEARRAY,
                runtimeId2: ?*SAFEARRAY,
                areSame: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRootElement: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomation,
                root: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomation,
                root: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ElementFromHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomation,
                hwnd: ?HWND,
                element: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomation,
                hwnd: ?HWND,
                element: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ElementFromPoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomation,
                pt: POINT,
                element: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomation,
                pt: POINT,
                element: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFocusedElement: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomation,
                element: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomation,
                element: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRootElementBuildCache: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomation,
                cacheRequest: ?*IUIAutomationCacheRequest,
                root: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomation,
                cacheRequest: ?*IUIAutomationCacheRequest,
                root: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ElementFromHandleBuildCache: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomation,
                hwnd: ?HWND,
                cacheRequest: ?*IUIAutomationCacheRequest,
                element: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomation,
                hwnd: ?HWND,
                cacheRequest: ?*IUIAutomationCacheRequest,
                element: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ElementFromPointBuildCache: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomation,
                pt: POINT,
                cacheRequest: ?*IUIAutomationCacheRequest,
                element: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomation,
                pt: POINT,
                cacheRequest: ?*IUIAutomationCacheRequest,
                element: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFocusedElementBuildCache: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomation,
                cacheRequest: ?*IUIAutomationCacheRequest,
                element: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomation,
                cacheRequest: ?*IUIAutomationCacheRequest,
                element: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateTreeWalker: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomation,
                pCondition: ?*IUIAutomationCondition,
                walker: ?*?*IUIAutomationTreeWalker,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomation,
                pCondition: ?*IUIAutomationCondition,
                walker: ?*?*IUIAutomationTreeWalker,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ControlViewWalker: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomation,
                walker: ?*?*IUIAutomationTreeWalker,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomation,
                walker: ?*?*IUIAutomationTreeWalker,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ContentViewWalker: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomation,
                walker: ?*?*IUIAutomationTreeWalker,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomation,
                walker: ?*?*IUIAutomationTreeWalker,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RawViewWalker: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomation,
                walker: ?*?*IUIAutomationTreeWalker,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomation,
                walker: ?*?*IUIAutomationTreeWalker,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RawViewCondition: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomation,
                condition: ?*?*IUIAutomationCondition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomation,
                condition: ?*?*IUIAutomationCondition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ControlViewCondition: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomation,
                condition: ?*?*IUIAutomationCondition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomation,
                condition: ?*?*IUIAutomationCondition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ContentViewCondition: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomation,
                condition: ?*?*IUIAutomationCondition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomation,
                condition: ?*?*IUIAutomationCondition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateCacheRequest: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomation,
                cacheRequest: ?*?*IUIAutomationCacheRequest,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomation,
                cacheRequest: ?*?*IUIAutomationCacheRequest,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateTrueCondition: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomation,
                newCondition: ?*?*IUIAutomationCondition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomation,
                newCondition: ?*?*IUIAutomationCondition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateFalseCondition: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomation,
                newCondition: ?*?*IUIAutomationCondition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomation,
                newCondition: ?*?*IUIAutomationCondition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreatePropertyCondition: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomation,
                propertyId: i32,
                value: VARIANT,
                newCondition: ?*?*IUIAutomationCondition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomation,
                propertyId: i32,
                value: VARIANT,
                newCondition: ?*?*IUIAutomationCondition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreatePropertyConditionEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomation,
                propertyId: i32,
                value: VARIANT,
                flags: PropertyConditionFlags,
                newCondition: ?*?*IUIAutomationCondition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomation,
                propertyId: i32,
                value: VARIANT,
                flags: PropertyConditionFlags,
                newCondition: ?*?*IUIAutomationCondition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateAndCondition: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomation,
                condition1: ?*IUIAutomationCondition,
                condition2: ?*IUIAutomationCondition,
                newCondition: ?*?*IUIAutomationCondition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomation,
                condition1: ?*IUIAutomationCondition,
                condition2: ?*IUIAutomationCondition,
                newCondition: ?*?*IUIAutomationCondition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateAndConditionFromArray: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomation,
                conditions: ?*SAFEARRAY,
                newCondition: ?*?*IUIAutomationCondition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomation,
                conditions: ?*SAFEARRAY,
                newCondition: ?*?*IUIAutomationCondition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateAndConditionFromNativeArray: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomation,
                conditions: [*]?*IUIAutomationCondition,
                conditionCount: i32,
                newCondition: ?*?*IUIAutomationCondition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomation,
                conditions: [*]?*IUIAutomationCondition,
                conditionCount: i32,
                newCondition: ?*?*IUIAutomationCondition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateOrCondition: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomation,
                condition1: ?*IUIAutomationCondition,
                condition2: ?*IUIAutomationCondition,
                newCondition: ?*?*IUIAutomationCondition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomation,
                condition1: ?*IUIAutomationCondition,
                condition2: ?*IUIAutomationCondition,
                newCondition: ?*?*IUIAutomationCondition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateOrConditionFromArray: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomation,
                conditions: ?*SAFEARRAY,
                newCondition: ?*?*IUIAutomationCondition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomation,
                conditions: ?*SAFEARRAY,
                newCondition: ?*?*IUIAutomationCondition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateOrConditionFromNativeArray: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomation,
                conditions: [*]?*IUIAutomationCondition,
                conditionCount: i32,
                newCondition: ?*?*IUIAutomationCondition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomation,
                conditions: [*]?*IUIAutomationCondition,
                conditionCount: i32,
                newCondition: ?*?*IUIAutomationCondition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateNotCondition: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomation,
                condition: ?*IUIAutomationCondition,
                newCondition: ?*?*IUIAutomationCondition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomation,
                condition: ?*IUIAutomationCondition,
                newCondition: ?*?*IUIAutomationCondition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddAutomationEventHandler: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomation,
                eventId: i32,
                element: ?*IUIAutomationElement,
                scope: TreeScope,
                cacheRequest: ?*IUIAutomationCacheRequest,
                handler: ?*IUIAutomationEventHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomation,
                eventId: i32,
                element: ?*IUIAutomationElement,
                scope: TreeScope,
                cacheRequest: ?*IUIAutomationCacheRequest,
                handler: ?*IUIAutomationEventHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveAutomationEventHandler: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomation,
                eventId: i32,
                element: ?*IUIAutomationElement,
                handler: ?*IUIAutomationEventHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomation,
                eventId: i32,
                element: ?*IUIAutomationElement,
                handler: ?*IUIAutomationEventHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddPropertyChangedEventHandlerNativeArray: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomation,
                element: ?*IUIAutomationElement,
                scope: TreeScope,
                cacheRequest: ?*IUIAutomationCacheRequest,
                handler: ?*IUIAutomationPropertyChangedEventHandler,
                propertyArray: [*]i32,
                propertyCount: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomation,
                element: ?*IUIAutomationElement,
                scope: TreeScope,
                cacheRequest: ?*IUIAutomationCacheRequest,
                handler: ?*IUIAutomationPropertyChangedEventHandler,
                propertyArray: [*]i32,
                propertyCount: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddPropertyChangedEventHandler: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomation,
                element: ?*IUIAutomationElement,
                scope: TreeScope,
                cacheRequest: ?*IUIAutomationCacheRequest,
                handler: ?*IUIAutomationPropertyChangedEventHandler,
                propertyArray: ?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomation,
                element: ?*IUIAutomationElement,
                scope: TreeScope,
                cacheRequest: ?*IUIAutomationCacheRequest,
                handler: ?*IUIAutomationPropertyChangedEventHandler,
                propertyArray: ?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemovePropertyChangedEventHandler: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomation,
                element: ?*IUIAutomationElement,
                handler: ?*IUIAutomationPropertyChangedEventHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomation,
                element: ?*IUIAutomationElement,
                handler: ?*IUIAutomationPropertyChangedEventHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddStructureChangedEventHandler: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomation,
                element: ?*IUIAutomationElement,
                scope: TreeScope,
                cacheRequest: ?*IUIAutomationCacheRequest,
                handler: ?*IUIAutomationStructureChangedEventHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomation,
                element: ?*IUIAutomationElement,
                scope: TreeScope,
                cacheRequest: ?*IUIAutomationCacheRequest,
                handler: ?*IUIAutomationStructureChangedEventHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveStructureChangedEventHandler: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomation,
                element: ?*IUIAutomationElement,
                handler: ?*IUIAutomationStructureChangedEventHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomation,
                element: ?*IUIAutomationElement,
                handler: ?*IUIAutomationStructureChangedEventHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddFocusChangedEventHandler: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomation,
                cacheRequest: ?*IUIAutomationCacheRequest,
                handler: ?*IUIAutomationFocusChangedEventHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomation,
                cacheRequest: ?*IUIAutomationCacheRequest,
                handler: ?*IUIAutomationFocusChangedEventHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveFocusChangedEventHandler: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomation,
                handler: ?*IUIAutomationFocusChangedEventHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomation,
                handler: ?*IUIAutomationFocusChangedEventHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveAllEventHandlers: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomation,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomation,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IntNativeArrayToSafeArray: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomation,
                array: [*]i32,
                arrayCount: i32,
                safeArray: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomation,
                array: [*]i32,
                arrayCount: i32,
                safeArray: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IntSafeArrayToNativeArray: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomation,
                intArray: ?*SAFEARRAY,
                array: [*]?*i32,
                arrayCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomation,
                intArray: ?*SAFEARRAY,
                array: [*]?*i32,
                arrayCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RectToVariant: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomation,
                rc: RECT,
                @"var": ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomation,
                rc: RECT,
                @"var": ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        VariantToRect: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomation,
                @"var": VARIANT,
                rc: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomation,
                @"var": VARIANT,
                rc: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SafeArrayToRectNativeArray: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomation,
                rects: ?*SAFEARRAY,
                rectArray: [*]?*RECT,
                rectArrayCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomation,
                rects: ?*SAFEARRAY,
                rectArray: [*]?*RECT,
                rectArrayCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProxyFactoryEntry: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomation,
                factory: ?*IUIAutomationProxyFactory,
                factoryEntry: ?*?*IUIAutomationProxyFactoryEntry,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomation,
                factory: ?*IUIAutomationProxyFactory,
                factoryEntry: ?*?*IUIAutomationProxyFactoryEntry,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ProxyFactoryMapping: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomation,
                factoryMapping: ?*?*IUIAutomationProxyFactoryMapping,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomation,
                factoryMapping: ?*?*IUIAutomationProxyFactoryMapping,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPropertyProgrammaticName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomation,
                property: i32,
                name: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomation,
                property: i32,
                name: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPatternProgrammaticName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomation,
                pattern: i32,
                name: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomation,
                pattern: i32,
                name: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PollForPotentialSupportedPatterns: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomation,
                pElement: ?*IUIAutomationElement,
                patternIds: ?*?*SAFEARRAY,
                patternNames: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomation,
                pElement: ?*IUIAutomationElement,
                patternIds: ?*?*SAFEARRAY,
                patternNames: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PollForPotentialSupportedProperties: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomation,
                pElement: ?*IUIAutomationElement,
                propertyIds: ?*?*SAFEARRAY,
                propertyNames: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomation,
                pElement: ?*IUIAutomationElement,
                propertyIds: ?*?*SAFEARRAY,
                propertyNames: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CheckNotSupported: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomation,
                value: VARIANT,
                isNotSupported: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomation,
                value: VARIANT,
                isNotSupported: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ReservedNotSupportedValue: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomation,
                notSupportedValue: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomation,
                notSupportedValue: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ReservedMixedAttributeValue: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomation,
                mixedAttributeValue: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomation,
                mixedAttributeValue: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ElementFromIAccessible: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomation,
                accessible: ?*IAccessible,
                childId: i32,
                element: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomation,
                accessible: ?*IAccessible,
                childId: i32,
                element: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ElementFromIAccessibleBuildCache: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomation,
                accessible: ?*IAccessible,
                childId: i32,
                cacheRequest: ?*IUIAutomationCacheRequest,
                element: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomation,
                accessible: ?*IAccessible,
                childId: i32,
                cacheRequest: ?*IUIAutomationCacheRequest,
                element: ?*?*IUIAutomationElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_CompareElements(self: *const T, el1: ?*IUIAutomationElement, el2: ?*IUIAutomationElement, areSame: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).CompareElements(@ptrCast(*const IUIAutomation, self), el1, el2, areSame);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_CompareRuntimeIds(self: *const T, runtimeId1: ?*SAFEARRAY, runtimeId2: ?*SAFEARRAY, areSame: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).CompareRuntimeIds(@ptrCast(*const IUIAutomation, self), runtimeId1, runtimeId2, areSame);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_GetRootElement(self: *const T, root: ?*?*IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).GetRootElement(@ptrCast(*const IUIAutomation, self), root);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_ElementFromHandle(self: *const T, hwnd: ?HWND, element: ?*?*IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).ElementFromHandle(@ptrCast(*const IUIAutomation, self), hwnd, element);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_ElementFromPoint(self: *const T, pt: POINT, element: ?*?*IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).ElementFromPoint(@ptrCast(*const IUIAutomation, self), pt, element);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_GetFocusedElement(self: *const T, element: ?*?*IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).GetFocusedElement(@ptrCast(*const IUIAutomation, self), element);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_GetRootElementBuildCache(self: *const T, cacheRequest: ?*IUIAutomationCacheRequest, root: ?*?*IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).GetRootElementBuildCache(@ptrCast(*const IUIAutomation, self), cacheRequest, root);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_ElementFromHandleBuildCache(self: *const T, hwnd: ?HWND, cacheRequest: ?*IUIAutomationCacheRequest, element: ?*?*IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).ElementFromHandleBuildCache(@ptrCast(*const IUIAutomation, self), hwnd, cacheRequest, element);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_ElementFromPointBuildCache(self: *const T, pt: POINT, cacheRequest: ?*IUIAutomationCacheRequest, element: ?*?*IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).ElementFromPointBuildCache(@ptrCast(*const IUIAutomation, self), pt, cacheRequest, element);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_GetFocusedElementBuildCache(self: *const T, cacheRequest: ?*IUIAutomationCacheRequest, element: ?*?*IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).GetFocusedElementBuildCache(@ptrCast(*const IUIAutomation, self), cacheRequest, element);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_CreateTreeWalker(self: *const T, pCondition: ?*IUIAutomationCondition, walker: ?*?*IUIAutomationTreeWalker) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).CreateTreeWalker(@ptrCast(*const IUIAutomation, self), pCondition, walker);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_get_ControlViewWalker(self: *const T, walker: ?*?*IUIAutomationTreeWalker) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).get_ControlViewWalker(@ptrCast(*const IUIAutomation, self), walker);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_get_ContentViewWalker(self: *const T, walker: ?*?*IUIAutomationTreeWalker) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).get_ContentViewWalker(@ptrCast(*const IUIAutomation, self), walker);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_get_RawViewWalker(self: *const T, walker: ?*?*IUIAutomationTreeWalker) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).get_RawViewWalker(@ptrCast(*const IUIAutomation, self), walker);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_get_RawViewCondition(self: *const T, condition: ?*?*IUIAutomationCondition) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).get_RawViewCondition(@ptrCast(*const IUIAutomation, self), condition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_get_ControlViewCondition(self: *const T, condition: ?*?*IUIAutomationCondition) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).get_ControlViewCondition(@ptrCast(*const IUIAutomation, self), condition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_get_ContentViewCondition(self: *const T, condition: ?*?*IUIAutomationCondition) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).get_ContentViewCondition(@ptrCast(*const IUIAutomation, self), condition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_CreateCacheRequest(self: *const T, cacheRequest: ?*?*IUIAutomationCacheRequest) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).CreateCacheRequest(@ptrCast(*const IUIAutomation, self), cacheRequest);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_CreateTrueCondition(self: *const T, newCondition: ?*?*IUIAutomationCondition) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).CreateTrueCondition(@ptrCast(*const IUIAutomation, self), newCondition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_CreateFalseCondition(self: *const T, newCondition: ?*?*IUIAutomationCondition) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).CreateFalseCondition(@ptrCast(*const IUIAutomation, self), newCondition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_CreatePropertyCondition(self: *const T, propertyId: i32, value: VARIANT, newCondition: ?*?*IUIAutomationCondition) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).CreatePropertyCondition(@ptrCast(*const IUIAutomation, self), propertyId, value, newCondition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_CreatePropertyConditionEx(self: *const T, propertyId: i32, value: VARIANT, flags: PropertyConditionFlags, newCondition: ?*?*IUIAutomationCondition) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).CreatePropertyConditionEx(@ptrCast(*const IUIAutomation, self), propertyId, value, flags, newCondition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_CreateAndCondition(self: *const T, condition1: ?*IUIAutomationCondition, condition2: ?*IUIAutomationCondition, newCondition: ?*?*IUIAutomationCondition) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).CreateAndCondition(@ptrCast(*const IUIAutomation, self), condition1, condition2, newCondition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_CreateAndConditionFromArray(self: *const T, conditions: ?*SAFEARRAY, newCondition: ?*?*IUIAutomationCondition) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).CreateAndConditionFromArray(@ptrCast(*const IUIAutomation, self), conditions, newCondition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_CreateAndConditionFromNativeArray(self: *const T, conditions: [*]?*IUIAutomationCondition, conditionCount: i32, newCondition: ?*?*IUIAutomationCondition) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).CreateAndConditionFromNativeArray(@ptrCast(*const IUIAutomation, self), conditions, conditionCount, newCondition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_CreateOrCondition(self: *const T, condition1: ?*IUIAutomationCondition, condition2: ?*IUIAutomationCondition, newCondition: ?*?*IUIAutomationCondition) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).CreateOrCondition(@ptrCast(*const IUIAutomation, self), condition1, condition2, newCondition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_CreateOrConditionFromArray(self: *const T, conditions: ?*SAFEARRAY, newCondition: ?*?*IUIAutomationCondition) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).CreateOrConditionFromArray(@ptrCast(*const IUIAutomation, self), conditions, newCondition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_CreateOrConditionFromNativeArray(self: *const T, conditions: [*]?*IUIAutomationCondition, conditionCount: i32, newCondition: ?*?*IUIAutomationCondition) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).CreateOrConditionFromNativeArray(@ptrCast(*const IUIAutomation, self), conditions, conditionCount, newCondition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_CreateNotCondition(self: *const T, condition: ?*IUIAutomationCondition, newCondition: ?*?*IUIAutomationCondition) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).CreateNotCondition(@ptrCast(*const IUIAutomation, self), condition, newCondition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_AddAutomationEventHandler(self: *const T, eventId: i32, element: ?*IUIAutomationElement, scope: TreeScope, cacheRequest: ?*IUIAutomationCacheRequest, handler: ?*IUIAutomationEventHandler) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).AddAutomationEventHandler(@ptrCast(*const IUIAutomation, self), eventId, element, scope, cacheRequest, handler);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_RemoveAutomationEventHandler(self: *const T, eventId: i32, element: ?*IUIAutomationElement, handler: ?*IUIAutomationEventHandler) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).RemoveAutomationEventHandler(@ptrCast(*const IUIAutomation, self), eventId, element, handler);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_AddPropertyChangedEventHandlerNativeArray(self: *const T, element: ?*IUIAutomationElement, scope: TreeScope, cacheRequest: ?*IUIAutomationCacheRequest, handler: ?*IUIAutomationPropertyChangedEventHandler, propertyArray: [*]i32, propertyCount: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).AddPropertyChangedEventHandlerNativeArray(@ptrCast(*const IUIAutomation, self), element, scope, cacheRequest, handler, propertyArray, propertyCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_AddPropertyChangedEventHandler(self: *const T, element: ?*IUIAutomationElement, scope: TreeScope, cacheRequest: ?*IUIAutomationCacheRequest, handler: ?*IUIAutomationPropertyChangedEventHandler, propertyArray: ?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).AddPropertyChangedEventHandler(@ptrCast(*const IUIAutomation, self), element, scope, cacheRequest, handler, propertyArray);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_RemovePropertyChangedEventHandler(self: *const T, element: ?*IUIAutomationElement, handler: ?*IUIAutomationPropertyChangedEventHandler) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).RemovePropertyChangedEventHandler(@ptrCast(*const IUIAutomation, self), element, handler);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_AddStructureChangedEventHandler(self: *const T, element: ?*IUIAutomationElement, scope: TreeScope, cacheRequest: ?*IUIAutomationCacheRequest, handler: ?*IUIAutomationStructureChangedEventHandler) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).AddStructureChangedEventHandler(@ptrCast(*const IUIAutomation, self), element, scope, cacheRequest, handler);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_RemoveStructureChangedEventHandler(self: *const T, element: ?*IUIAutomationElement, handler: ?*IUIAutomationStructureChangedEventHandler) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).RemoveStructureChangedEventHandler(@ptrCast(*const IUIAutomation, self), element, handler);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_AddFocusChangedEventHandler(self: *const T, cacheRequest: ?*IUIAutomationCacheRequest, handler: ?*IUIAutomationFocusChangedEventHandler) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).AddFocusChangedEventHandler(@ptrCast(*const IUIAutomation, self), cacheRequest, handler);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_RemoveFocusChangedEventHandler(self: *const T, handler: ?*IUIAutomationFocusChangedEventHandler) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).RemoveFocusChangedEventHandler(@ptrCast(*const IUIAutomation, self), handler);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_RemoveAllEventHandlers(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).RemoveAllEventHandlers(@ptrCast(*const IUIAutomation, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_IntNativeArrayToSafeArray(self: *const T, array: [*]i32, arrayCount: i32, safeArray: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).IntNativeArrayToSafeArray(@ptrCast(*const IUIAutomation, self), array, arrayCount, safeArray);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_IntSafeArrayToNativeArray(self: *const T, intArray: ?*SAFEARRAY, array: [*]?*i32, arrayCount: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).IntSafeArrayToNativeArray(@ptrCast(*const IUIAutomation, self), intArray, array, arrayCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_RectToVariant(self: *const T, rc: RECT, @"var": ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).RectToVariant(@ptrCast(*const IUIAutomation, self), rc, @"var");
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_VariantToRect(self: *const T, @"var": VARIANT, rc: ?*RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).VariantToRect(@ptrCast(*const IUIAutomation, self), @"var", rc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_SafeArrayToRectNativeArray(self: *const T, rects: ?*SAFEARRAY, rectArray: [*]?*RECT, rectArrayCount: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).SafeArrayToRectNativeArray(@ptrCast(*const IUIAutomation, self), rects, rectArray, rectArrayCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_CreateProxyFactoryEntry(self: *const T, factory: ?*IUIAutomationProxyFactory, factoryEntry: ?*?*IUIAutomationProxyFactoryEntry) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).CreateProxyFactoryEntry(@ptrCast(*const IUIAutomation, self), factory, factoryEntry);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_get_ProxyFactoryMapping(self: *const T, factoryMapping: ?*?*IUIAutomationProxyFactoryMapping) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).get_ProxyFactoryMapping(@ptrCast(*const IUIAutomation, self), factoryMapping);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_GetPropertyProgrammaticName(self: *const T, property: i32, name: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).GetPropertyProgrammaticName(@ptrCast(*const IUIAutomation, self), property, name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_GetPatternProgrammaticName(self: *const T, pattern: i32, name: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).GetPatternProgrammaticName(@ptrCast(*const IUIAutomation, self), pattern, name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_PollForPotentialSupportedPatterns(self: *const T, pElement: ?*IUIAutomationElement, patternIds: ?*?*SAFEARRAY, patternNames: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).PollForPotentialSupportedPatterns(@ptrCast(*const IUIAutomation, self), pElement, patternIds, patternNames);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_PollForPotentialSupportedProperties(self: *const T, pElement: ?*IUIAutomationElement, propertyIds: ?*?*SAFEARRAY, propertyNames: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).PollForPotentialSupportedProperties(@ptrCast(*const IUIAutomation, self), pElement, propertyIds, propertyNames);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_CheckNotSupported(self: *const T, value: VARIANT, isNotSupported: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).CheckNotSupported(@ptrCast(*const IUIAutomation, self), value, isNotSupported);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_get_ReservedNotSupportedValue(self: *const T, notSupportedValue: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).get_ReservedNotSupportedValue(@ptrCast(*const IUIAutomation, self), notSupportedValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_get_ReservedMixedAttributeValue(self: *const T, mixedAttributeValue: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).get_ReservedMixedAttributeValue(@ptrCast(*const IUIAutomation, self), mixedAttributeValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_ElementFromIAccessible(self: *const T, accessible: ?*IAccessible, childId: i32, element: ?*?*IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).ElementFromIAccessible(@ptrCast(*const IUIAutomation, self), accessible, childId, element);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_ElementFromIAccessibleBuildCache(self: *const T, accessible: ?*IAccessible, childId: i32, cacheRequest: ?*IUIAutomationCacheRequest, element: ?*?*IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).ElementFromIAccessibleBuildCache(@ptrCast(*const IUIAutomation, self), accessible, childId, cacheRequest, element);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IUIAutomation2_Value = Guid.initString("34723aff-0c9d-49d0-9896-7ab52df8cd8a");
pub const IID_IUIAutomation2 = &IID_IUIAutomation2_Value;
pub const IUIAutomation2 = extern struct {
    pub const VTable = extern struct {
        base: IUIAutomation.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AutoSetFocus: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomation2,
                autoSetFocus: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomation2,
                autoSetFocus: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AutoSetFocus: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomation2,
                autoSetFocus: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomation2,
                autoSetFocus: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ConnectionTimeout: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomation2,
                timeout: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomation2,
                timeout: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ConnectionTimeout: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomation2,
                timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomation2,
                timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TransactionTimeout: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomation2,
                timeout: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomation2,
                timeout: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_TransactionTimeout: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomation2,
                timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomation2,
                timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUIAutomation.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation2_get_AutoSetFocus(self: *const T, autoSetFocus: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation2.VTable, self.vtable).get_AutoSetFocus(@ptrCast(*const IUIAutomation2, self), autoSetFocus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation2_put_AutoSetFocus(self: *const T, autoSetFocus: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation2.VTable, self.vtable).put_AutoSetFocus(@ptrCast(*const IUIAutomation2, self), autoSetFocus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation2_get_ConnectionTimeout(self: *const T, timeout: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation2.VTable, self.vtable).get_ConnectionTimeout(@ptrCast(*const IUIAutomation2, self), timeout);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation2_put_ConnectionTimeout(self: *const T, timeout: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation2.VTable, self.vtable).put_ConnectionTimeout(@ptrCast(*const IUIAutomation2, self), timeout);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation2_get_TransactionTimeout(self: *const T, timeout: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation2.VTable, self.vtable).get_TransactionTimeout(@ptrCast(*const IUIAutomation2, self), timeout);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation2_put_TransactionTimeout(self: *const T, timeout: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation2.VTable, self.vtable).put_TransactionTimeout(@ptrCast(*const IUIAutomation2, self), timeout);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.1'
const IID_IUIAutomation3_Value = Guid.initString("73d768da-9b51-4b89-936e-c209290973e7");
pub const IID_IUIAutomation3 = &IID_IUIAutomation3_Value;
pub const IUIAutomation3 = extern struct {
    pub const VTable = extern struct {
        base: IUIAutomation2.VTable,
        AddTextEditTextChangedEventHandler: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomation3,
                element: ?*IUIAutomationElement,
                scope: TreeScope,
                textEditChangeType: TextEditChangeType,
                cacheRequest: ?*IUIAutomationCacheRequest,
                handler: ?*IUIAutomationTextEditTextChangedEventHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomation3,
                element: ?*IUIAutomationElement,
                scope: TreeScope,
                textEditChangeType: TextEditChangeType,
                cacheRequest: ?*IUIAutomationCacheRequest,
                handler: ?*IUIAutomationTextEditTextChangedEventHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveTextEditTextChangedEventHandler: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomation3,
                element: ?*IUIAutomationElement,
                handler: ?*IUIAutomationTextEditTextChangedEventHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomation3,
                element: ?*IUIAutomationElement,
                handler: ?*IUIAutomationTextEditTextChangedEventHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUIAutomation2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation3_AddTextEditTextChangedEventHandler(self: *const T, element: ?*IUIAutomationElement, scope: TreeScope, textEditChangeType: TextEditChangeType, cacheRequest: ?*IUIAutomationCacheRequest, handler: ?*IUIAutomationTextEditTextChangedEventHandler) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation3.VTable, self.vtable).AddTextEditTextChangedEventHandler(@ptrCast(*const IUIAutomation3, self), element, scope, textEditChangeType, cacheRequest, handler);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation3_RemoveTextEditTextChangedEventHandler(self: *const T, element: ?*IUIAutomationElement, handler: ?*IUIAutomationTextEditTextChangedEventHandler) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation3.VTable, self.vtable).RemoveTextEditTextChangedEventHandler(@ptrCast(*const IUIAutomation3, self), element, handler);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.14393'
const IID_IUIAutomation4_Value = Guid.initString("1189c02a-05f8-4319-8e21-e817e3db2860");
pub const IID_IUIAutomation4 = &IID_IUIAutomation4_Value;
pub const IUIAutomation4 = extern struct {
    pub const VTable = extern struct {
        base: IUIAutomation3.VTable,
        AddChangesEventHandler: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomation4,
                element: ?*IUIAutomationElement,
                scope: TreeScope,
                changeTypes: [*]i32,
                changesCount: i32,
                pCacheRequest: ?*IUIAutomationCacheRequest,
                handler: ?*IUIAutomationChangesEventHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomation4,
                element: ?*IUIAutomationElement,
                scope: TreeScope,
                changeTypes: [*]i32,
                changesCount: i32,
                pCacheRequest: ?*IUIAutomationCacheRequest,
                handler: ?*IUIAutomationChangesEventHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveChangesEventHandler: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomation4,
                element: ?*IUIAutomationElement,
                handler: ?*IUIAutomationChangesEventHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomation4,
                element: ?*IUIAutomationElement,
                handler: ?*IUIAutomationChangesEventHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUIAutomation3.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation4_AddChangesEventHandler(self: *const T, element: ?*IUIAutomationElement, scope: TreeScope, changeTypes: [*]i32, changesCount: i32, pCacheRequest: ?*IUIAutomationCacheRequest, handler: ?*IUIAutomationChangesEventHandler) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation4.VTable, self.vtable).AddChangesEventHandler(@ptrCast(*const IUIAutomation4, self), element, scope, changeTypes, changesCount, pCacheRequest, handler);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation4_RemoveChangesEventHandler(self: *const T, element: ?*IUIAutomationElement, handler: ?*IUIAutomationChangesEventHandler) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation4.VTable, self.vtable).RemoveChangesEventHandler(@ptrCast(*const IUIAutomation4, self), element, handler);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.14393'
const IID_IUIAutomation5_Value = Guid.initString("25f700c8-d816-4057-a9dc-3cbdee77e256");
pub const IID_IUIAutomation5 = &IID_IUIAutomation5_Value;
pub const IUIAutomation5 = extern struct {
    pub const VTable = extern struct {
        base: IUIAutomation4.VTable,
        AddNotificationEventHandler: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomation5,
                element: ?*IUIAutomationElement,
                scope: TreeScope,
                cacheRequest: ?*IUIAutomationCacheRequest,
                handler: ?*IUIAutomationNotificationEventHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomation5,
                element: ?*IUIAutomationElement,
                scope: TreeScope,
                cacheRequest: ?*IUIAutomationCacheRequest,
                handler: ?*IUIAutomationNotificationEventHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveNotificationEventHandler: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomation5,
                element: ?*IUIAutomationElement,
                handler: ?*IUIAutomationNotificationEventHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomation5,
                element: ?*IUIAutomationElement,
                handler: ?*IUIAutomationNotificationEventHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUIAutomation4.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation5_AddNotificationEventHandler(self: *const T, element: ?*IUIAutomationElement, scope: TreeScope, cacheRequest: ?*IUIAutomationCacheRequest, handler: ?*IUIAutomationNotificationEventHandler) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation5.VTable, self.vtable).AddNotificationEventHandler(@ptrCast(*const IUIAutomation5, self), element, scope, cacheRequest, handler);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation5_RemoveNotificationEventHandler(self: *const T, element: ?*IUIAutomationElement, handler: ?*IUIAutomationNotificationEventHandler) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation5.VTable, self.vtable).RemoveNotificationEventHandler(@ptrCast(*const IUIAutomation5, self), element, handler);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.17763'
const IID_IUIAutomation6_Value = Guid.initString("aae072da-29e3-413d-87a7-192dbf81ed10");
pub const IID_IUIAutomation6 = &IID_IUIAutomation6_Value;
pub const IUIAutomation6 = extern struct {
    pub const VTable = extern struct {
        base: IUIAutomation5.VTable,
        CreateEventHandlerGroup: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomation6,
                handlerGroup: ?*?*IUIAutomationEventHandlerGroup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomation6,
                handlerGroup: ?*?*IUIAutomationEventHandlerGroup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddEventHandlerGroup: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomation6,
                element: ?*IUIAutomationElement,
                handlerGroup: ?*IUIAutomationEventHandlerGroup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomation6,
                element: ?*IUIAutomationElement,
                handlerGroup: ?*IUIAutomationEventHandlerGroup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveEventHandlerGroup: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomation6,
                element: ?*IUIAutomationElement,
                handlerGroup: ?*IUIAutomationEventHandlerGroup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomation6,
                element: ?*IUIAutomationElement,
                handlerGroup: ?*IUIAutomationEventHandlerGroup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ConnectionRecoveryBehavior: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomation6,
                connectionRecoveryBehaviorOptions: ?*ConnectionRecoveryBehaviorOptions,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomation6,
                connectionRecoveryBehaviorOptions: ?*ConnectionRecoveryBehaviorOptions,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ConnectionRecoveryBehavior: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomation6,
                connectionRecoveryBehaviorOptions: ConnectionRecoveryBehaviorOptions,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomation6,
                connectionRecoveryBehaviorOptions: ConnectionRecoveryBehaviorOptions,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CoalesceEvents: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomation6,
                coalesceEventsOptions: ?*CoalesceEventsOptions,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomation6,
                coalesceEventsOptions: ?*CoalesceEventsOptions,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_CoalesceEvents: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUIAutomation6,
                coalesceEventsOptions: CoalesceEventsOptions,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUIAutomation6,
                coalesceEventsOptions: CoalesceEventsOptions,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddActiveTextPositionChangedEventHandler: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomation6,
                element: ?*IUIAutomationElement,
                scope: TreeScope,
                cacheRequest: ?*IUIAutomationCacheRequest,
                handler: ?*IUIAutomationActiveTextPositionChangedEventHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomation6,
                element: ?*IUIAutomationElement,
                scope: TreeScope,
                cacheRequest: ?*IUIAutomationCacheRequest,
                handler: ?*IUIAutomationActiveTextPositionChangedEventHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveActiveTextPositionChangedEventHandler: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUIAutomation6,
                element: ?*IUIAutomationElement,
                handler: ?*IUIAutomationActiveTextPositionChangedEventHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUIAutomation6,
                element: ?*IUIAutomationElement,
                handler: ?*IUIAutomationActiveTextPositionChangedEventHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUIAutomation5.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation6_CreateEventHandlerGroup(self: *const T, handlerGroup: ?*?*IUIAutomationEventHandlerGroup) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation6.VTable, self.vtable).CreateEventHandlerGroup(@ptrCast(*const IUIAutomation6, self), handlerGroup);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation6_AddEventHandlerGroup(self: *const T, element: ?*IUIAutomationElement, handlerGroup: ?*IUIAutomationEventHandlerGroup) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation6.VTable, self.vtable).AddEventHandlerGroup(@ptrCast(*const IUIAutomation6, self), element, handlerGroup);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation6_RemoveEventHandlerGroup(self: *const T, element: ?*IUIAutomationElement, handlerGroup: ?*IUIAutomationEventHandlerGroup) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation6.VTable, self.vtable).RemoveEventHandlerGroup(@ptrCast(*const IUIAutomation6, self), element, handlerGroup);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation6_get_ConnectionRecoveryBehavior(self: *const T, connectionRecoveryBehaviorOptions: ?*ConnectionRecoveryBehaviorOptions) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation6.VTable, self.vtable).get_ConnectionRecoveryBehavior(@ptrCast(*const IUIAutomation6, self), connectionRecoveryBehaviorOptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation6_put_ConnectionRecoveryBehavior(self: *const T, connectionRecoveryBehaviorOptions: ConnectionRecoveryBehaviorOptions) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation6.VTable, self.vtable).put_ConnectionRecoveryBehavior(@ptrCast(*const IUIAutomation6, self), connectionRecoveryBehaviorOptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation6_get_CoalesceEvents(self: *const T, coalesceEventsOptions: ?*CoalesceEventsOptions) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation6.VTable, self.vtable).get_CoalesceEvents(@ptrCast(*const IUIAutomation6, self), coalesceEventsOptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation6_put_CoalesceEvents(self: *const T, coalesceEventsOptions: CoalesceEventsOptions) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation6.VTable, self.vtable).put_CoalesceEvents(@ptrCast(*const IUIAutomation6, self), coalesceEventsOptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation6_AddActiveTextPositionChangedEventHandler(self: *const T, element: ?*IUIAutomationElement, scope: TreeScope, cacheRequest: ?*IUIAutomationCacheRequest, handler: ?*IUIAutomationActiveTextPositionChangedEventHandler) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation6.VTable, self.vtable).AddActiveTextPositionChangedEventHandler(@ptrCast(*const IUIAutomation6, self), element, scope, cacheRequest, handler);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation6_RemoveActiveTextPositionChangedEventHandler(self: *const T, element: ?*IUIAutomationElement, handler: ?*IUIAutomationActiveTextPositionChangedEventHandler) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation6.VTable, self.vtable).RemoveActiveTextPositionChangedEventHandler(@ptrCast(*const IUIAutomation6, self), element, handler);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const ConditionType = enum(i32) {
    True = 0,
    False = 1,
    Property = 2,
    And = 3,
    Or = 4,
    Not = 5,
};
pub const ConditionType_True = ConditionType.True;
pub const ConditionType_False = ConditionType.False;
pub const ConditionType_Property = ConditionType.Property;
pub const ConditionType_And = ConditionType.And;
pub const ConditionType_Or = ConditionType.Or;
pub const ConditionType_Not = ConditionType.Not;

pub const UiaCondition = extern struct {
    ConditionType: ConditionType,
};

pub const UiaPropertyCondition = extern struct {
    ConditionType: ConditionType,
    PropertyId: i32,
    Value: VARIANT,
    Flags: PropertyConditionFlags,
};

pub const UiaAndOrCondition = extern struct {
    ConditionType: ConditionType,
    ppConditions: ?*?*UiaCondition,
    cConditions: i32,
};

pub const UiaNotCondition = extern struct {
    ConditionType: ConditionType,
    pCondition: ?*UiaCondition,
};

pub const UiaCacheRequest = extern struct {
    pViewCondition: ?*UiaCondition,
    Scope: TreeScope,
    pProperties: ?*i32,
    cProperties: i32,
    pPatterns: ?*i32,
    cPatterns: i32,
    automationElementMode: AutomationElementMode,
};

pub const NormalizeState = enum(i32) {
    None = 0,
    View = 1,
    Custom = 2,
};
pub const NormalizeState_None = NormalizeState.None;
pub const NormalizeState_View = NormalizeState.View;
pub const NormalizeState_Custom = NormalizeState.Custom;

pub const UiaFindParams = extern struct {
    MaxDepth: i32,
    FindFirst: BOOL,
    ExcludeRoot: BOOL,
    pFindCondition: ?*UiaCondition,
};

pub const ProviderType = enum(i32) {
    BaseHwnd = 0,
    Proxy = 1,
    NonClientArea = 2,
};
pub const ProviderType_BaseHwnd = ProviderType.BaseHwnd;
pub const ProviderType_Proxy = ProviderType.Proxy;
pub const ProviderType_NonClientArea = ProviderType.NonClientArea;

pub const UiaProviderCallback = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        hwnd: ?HWND,
        providerType: ProviderType,
    ) callconv(@import("std").os.windows.WINAPI) ?*SAFEARRAY,
    else => *const fn(
        hwnd: ?HWND,
        providerType: ProviderType,
    ) callconv(@import("std").os.windows.WINAPI) ?*SAFEARRAY,
} ;

pub const AutomationIdentifierType = enum(i32) {
    Property = 0,
    Pattern = 1,
    Event = 2,
    ControlType = 3,
    TextAttribute = 4,
    LandmarkType = 5,
    Annotation = 6,
    Changes = 7,
    Style = 8,
};
pub const AutomationIdentifierType_Property = AutomationIdentifierType.Property;
pub const AutomationIdentifierType_Pattern = AutomationIdentifierType.Pattern;
pub const AutomationIdentifierType_Event = AutomationIdentifierType.Event;
pub const AutomationIdentifierType_ControlType = AutomationIdentifierType.ControlType;
pub const AutomationIdentifierType_TextAttribute = AutomationIdentifierType.TextAttribute;
pub const AutomationIdentifierType_LandmarkType = AutomationIdentifierType.LandmarkType;
pub const AutomationIdentifierType_Annotation = AutomationIdentifierType.Annotation;
pub const AutomationIdentifierType_Changes = AutomationIdentifierType.Changes;
pub const AutomationIdentifierType_Style = AutomationIdentifierType.Style;

pub const EventArgsType = enum(i32) {
    Simple = 0,
    PropertyChanged = 1,
    StructureChanged = 2,
    AsyncContentLoaded = 3,
    WindowClosed = 4,
    TextEditTextChanged = 5,
    Changes = 6,
    Notification = 7,
    ActiveTextPositionChanged = 8,
    StructuredMarkup = 9,
};
pub const EventArgsType_Simple = EventArgsType.Simple;
pub const EventArgsType_PropertyChanged = EventArgsType.PropertyChanged;
pub const EventArgsType_StructureChanged = EventArgsType.StructureChanged;
pub const EventArgsType_AsyncContentLoaded = EventArgsType.AsyncContentLoaded;
pub const EventArgsType_WindowClosed = EventArgsType.WindowClosed;
pub const EventArgsType_TextEditTextChanged = EventArgsType.TextEditTextChanged;
pub const EventArgsType_Changes = EventArgsType.Changes;
pub const EventArgsType_Notification = EventArgsType.Notification;
pub const EventArgsType_ActiveTextPositionChanged = EventArgsType.ActiveTextPositionChanged;
pub const EventArgsType_StructuredMarkup = EventArgsType.StructuredMarkup;

pub const AsyncContentLoadedState = enum(i32) {
    Beginning = 0,
    Progress = 1,
    Completed = 2,
};
pub const AsyncContentLoadedState_Beginning = AsyncContentLoadedState.Beginning;
pub const AsyncContentLoadedState_Progress = AsyncContentLoadedState.Progress;
pub const AsyncContentLoadedState_Completed = AsyncContentLoadedState.Completed;

pub const UiaEventArgs = extern struct {
    Type: EventArgsType,
    EventId: i32,
};

pub const UiaPropertyChangedEventArgs = extern struct {
    Type: EventArgsType,
    EventId: i32,
    PropertyId: i32,
    OldValue: VARIANT,
    NewValue: VARIANT,
};

pub const UiaStructureChangedEventArgs = extern struct {
    Type: EventArgsType,
    EventId: i32,
    StructureChangeType: StructureChangeType,
    pRuntimeId: ?*i32,
    cRuntimeIdLen: i32,
};

pub const UiaTextEditTextChangedEventArgs = extern struct {
    Type: EventArgsType,
    EventId: i32,
    TextEditChangeType: TextEditChangeType,
    pTextChange: ?*SAFEARRAY,
};

pub const UiaChangesEventArgs = extern struct {
    Type: EventArgsType,
    EventId: i32,
    EventIdCount: i32,
    pUiaChanges: ?*UiaChangeInfo,
};

pub const UiaAsyncContentLoadedEventArgs = extern struct {
    Type: EventArgsType,
    EventId: i32,
    AsyncContentLoadedState: AsyncContentLoadedState,
    PercentComplete: f64,
};

pub const UiaWindowClosedEventArgs = extern struct {
    Type: EventArgsType,
    EventId: i32,
    pRuntimeId: ?*i32,
    cRuntimeIdLen: i32,
};

pub const UiaEventCallback = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        pArgs: ?*UiaEventArgs,
        pRequestedData: ?*SAFEARRAY,
        pTreeStructure: ?BSTR,
    ) callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn(
        pArgs: ?*UiaEventArgs,
        pRequestedData: ?*SAFEARRAY,
        pTreeStructure: ?BSTR,
    ) callconv(@import("std").os.windows.WINAPI) void,
} ;

pub const SERIALKEYSA = extern struct {
    cbSize: u32,
    dwFlags: SERIALKEYS_FLAGS,
    lpszActivePort: ?PSTR,
    lpszPort: ?PSTR,
    iBaudRate: u32,
    iPortState: u32,
    iActive: u32,
};

pub const SERIALKEYSW = extern struct {
    cbSize: u32,
    dwFlags: SERIALKEYS_FLAGS,
    lpszActivePort: ?PWSTR,
    lpszPort: ?PWSTR,
    iBaudRate: u32,
    iPortState: u32,
    iActive: u32,
};

pub const HIGHCONTRASTA = extern struct {
    cbSize: u32,
    dwFlags: HIGHCONTRASTW_FLAGS,
    lpszDefaultScheme: ?PSTR,
};

pub const HIGHCONTRASTW = extern struct {
    cbSize: u32,
    dwFlags: HIGHCONTRASTW_FLAGS,
    lpszDefaultScheme: ?PWSTR,
};

pub const FILTERKEYS = extern struct {
    cbSize: u32,
    dwFlags: u32,
    iWaitMSec: u32,
    iDelayMSec: u32,
    iRepeatMSec: u32,
    iBounceMSec: u32,
};

pub const STICKYKEYS = extern struct {
    cbSize: u32,
    dwFlags: STICKYKEYS_FLAGS,
};

pub const MOUSEKEYS = extern struct {
    cbSize: u32,
    dwFlags: u32,
    iMaxSpeed: u32,
    iTimeToMaxSpeed: u32,
    iCtrlSpeed: u32,
    dwReserved1: u32,
    dwReserved2: u32,
};

pub const ACCESSTIMEOUT = extern struct {
    cbSize: u32,
    dwFlags: u32,
    iTimeOutMSec: u32,
};

pub const SOUNDSENTRYA = extern struct {
    cbSize: u32,
    dwFlags: SOUNDSENTRY_FLAGS,
    iFSTextEffect: SOUNDSENTRY_TEXT_EFFECT,
    iFSTextEffectMSec: u32,
    iFSTextEffectColorBits: u32,
    iFSGrafEffect: SOUND_SENTRY_GRAPHICS_EFFECT,
    iFSGrafEffectMSec: u32,
    iFSGrafEffectColor: u32,
    iWindowsEffect: SOUNDSENTRY_WINDOWS_EFFECT,
    iWindowsEffectMSec: u32,
    lpszWindowsEffectDLL: ?PSTR,
    iWindowsEffectOrdinal: u32,
};

pub const SOUNDSENTRYW = extern struct {
    cbSize: u32,
    dwFlags: SOUNDSENTRY_FLAGS,
    iFSTextEffect: SOUNDSENTRY_TEXT_EFFECT,
    iFSTextEffectMSec: u32,
    iFSTextEffectColorBits: u32,
    iFSGrafEffect: SOUND_SENTRY_GRAPHICS_EFFECT,
    iFSGrafEffectMSec: u32,
    iFSGrafEffectColor: u32,
    iWindowsEffect: SOUNDSENTRY_WINDOWS_EFFECT,
    iWindowsEffectMSec: u32,
    lpszWindowsEffectDLL: ?PWSTR,
    iWindowsEffectOrdinal: u32,
};

pub const TOGGLEKEYS = extern struct {
    cbSize: u32,
    dwFlags: u32,
};

pub const WINEVENTPROC = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        hWinEventHook: ?HWINEVENTHOOK,
        event: u32,
        hwnd: ?HWND,
        idObject: i32,
        idChild: i32,
        idEventThread: u32,
        dwmsEventTime: u32,
    ) callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn(
        hWinEventHook: ?HWINEVENTHOOK,
        event: u32,
        hwnd: ?HWND,
        idObject: i32,
        idChild: i32,
        idEventThread: u32,
        dwmsEventTime: u32,
    ) callconv(@import("std").os.windows.WINAPI) void,
} ;


//--------------------------------------------------------------------------------
// Section: Functions (123)
//--------------------------------------------------------------------------------
// TODO: this type is limited to platform 'windows5.0'
pub extern "oleacc" fn LresultFromObject(
    riid: ?*const Guid,
    wParam: WPARAM,
    punk: ?*IUnknown,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "oleacc" fn ObjectFromLresult(
    lResult: LRESULT,
    riid: ?*const Guid,
    wParam: WPARAM,
    ppvObject: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "oleacc" fn WindowFromAccessibleObject(
    param0: ?*IAccessible,
    phwnd: ?*?HWND,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "oleacc" fn AccessibleObjectFromWindow(
    hwnd: ?HWND,
    dwId: u32,
    riid: ?*const Guid,
    ppvObject: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "oleacc" fn AccessibleObjectFromEvent(
    hwnd: ?HWND,
    dwId: u32,
    dwChildId: u32,
    ppacc: ?*?*IAccessible,
    pvarChild: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "oleacc" fn AccessibleObjectFromPoint(
    ptScreen: POINT,
    ppacc: ?*?*IAccessible,
    pvarChild: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "oleacc" fn AccessibleChildren(
    paccContainer: ?*IAccessible,
    iChildStart: i32,
    cChildren: i32,
    rgvarChildren: [*]VARIANT,
    pcObtained: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "oleacc" fn GetRoleTextA(
    lRole: u32,
    lpszRole: ?[*:0]u8,
    cchRoleMax: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "oleacc" fn GetRoleTextW(
    lRole: u32,
    lpszRole: ?[*:0]u16,
    cchRoleMax: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "oleacc" fn GetStateTextA(
    lStateBit: u32,
    lpszState: ?[*:0]u8,
    cchState: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "oleacc" fn GetStateTextW(
    lStateBit: u32,
    lpszState: ?[*:0]u16,
    cchState: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "oleacc" fn GetOleaccVersionInfo(
    pVer: ?*u32,
    pBuild: ?*u32,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "oleacc" fn CreateStdAccessibleObject(
    hwnd: ?HWND,
    idObject: i32,
    riid: ?*const Guid,
    ppvObject: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "oleacc" fn CreateStdAccessibleProxyA(
    hwnd: ?HWND,
    pClassName: ?[*:0]const u8,
    idObject: i32,
    riid: ?*const Guid,
    ppvObject: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "oleacc" fn CreateStdAccessibleProxyW(
    hwnd: ?HWND,
    pClassName: ?[*:0]const u16,
    idObject: i32,
    riid: ?*const Guid,
    ppvObject: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "oleacc" fn AccSetRunningUtilityState(
    hwndApp: ?HWND,
    dwUtilityStateMask: u32,
    dwUtilityState: ACC_UTILITY_STATE_FLAGS,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "oleacc" fn AccNotifyTouchInteraction(
    hwndApp: ?HWND,
    hwndTarget: ?HWND,
    ptTarget: POINT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "uiautomationcore" fn UiaGetErrorDescription(
    pDescription: ?*?BSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "uiautomationcore" fn UiaHUiaNodeFromVariant(
    pvar: ?*VARIANT,
    phnode: ?*?HUIANODE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "uiautomationcore" fn UiaHPatternObjectFromVariant(
    pvar: ?*VARIANT,
    phobj: ?*?HUIAPATTERNOBJECT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "uiautomationcore" fn UiaHTextRangeFromVariant(
    pvar: ?*VARIANT,
    phtextrange: ?*?HUIATEXTRANGE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "uiautomationcore" fn UiaNodeRelease(
    hnode: ?HUIANODE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "uiautomationcore" fn UiaGetPropertyValue(
    hnode: ?HUIANODE,
    propertyId: i32,
    pValue: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "uiautomationcore" fn UiaGetPatternProvider(
    hnode: ?HUIANODE,
    patternId: i32,
    phobj: ?*?HUIAPATTERNOBJECT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "uiautomationcore" fn UiaGetRuntimeId(
    hnode: ?HUIANODE,
    pruntimeId: ?*?*SAFEARRAY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "uiautomationcore" fn UiaSetFocus(
    hnode: ?HUIANODE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "uiautomationcore" fn UiaNavigate(
    hnode: ?HUIANODE,
    direction: NavigateDirection,
    pCondition: ?*UiaCondition,
    pRequest: ?*UiaCacheRequest,
    ppRequestedData: ?*?*SAFEARRAY,
    ppTreeStructure: ?*?BSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "uiautomationcore" fn UiaGetUpdatedCache(
    hnode: ?HUIANODE,
    pRequest: ?*UiaCacheRequest,
    normalizeState: NormalizeState,
    pNormalizeCondition: ?*UiaCondition,
    ppRequestedData: ?*?*SAFEARRAY,
    ppTreeStructure: ?*?BSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "uiautomationcore" fn UiaFind(
    hnode: ?HUIANODE,
    pParams: ?*UiaFindParams,
    pRequest: ?*UiaCacheRequest,
    ppRequestedData: ?*?*SAFEARRAY,
    ppOffsets: ?*?*SAFEARRAY,
    ppTreeStructures: ?*?*SAFEARRAY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "uiautomationcore" fn UiaNodeFromPoint(
    x: f64,
    y: f64,
    pRequest: ?*UiaCacheRequest,
    ppRequestedData: ?*?*SAFEARRAY,
    ppTreeStructure: ?*?BSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "uiautomationcore" fn UiaNodeFromFocus(
    pRequest: ?*UiaCacheRequest,
    ppRequestedData: ?*?*SAFEARRAY,
    ppTreeStructure: ?*?BSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "uiautomationcore" fn UiaNodeFromHandle(
    hwnd: ?HWND,
    phnode: ?*?HUIANODE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "uiautomationcore" fn UiaNodeFromProvider(
    pProvider: ?*IRawElementProviderSimple,
    phnode: ?*?HUIANODE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "uiautomationcore" fn UiaGetRootNode(
    phnode: ?*?HUIANODE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "uiautomationcore" fn UiaRegisterProviderCallback(
    pCallback: ?*?UiaProviderCallback,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "uiautomationcore" fn UiaLookupId(
    type: AutomationIdentifierType,
    pGuid: ?*const Guid,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "uiautomationcore" fn UiaGetReservedNotSupportedValue(
    punkNotSupportedValue: ?*?*IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "uiautomationcore" fn UiaGetReservedMixedAttributeValue(
    punkMixedAttributeValue: ?*?*IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "uiautomationcore" fn UiaClientsAreListening(
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "uiautomationcore" fn UiaRaiseAutomationPropertyChangedEvent(
    pProvider: ?*IRawElementProviderSimple,
    id: i32,
    oldValue: VARIANT,
    newValue: VARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "uiautomationcore" fn UiaRaiseAutomationEvent(
    pProvider: ?*IRawElementProviderSimple,
    id: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "uiautomationcore" fn UiaRaiseStructureChangedEvent(
    pProvider: ?*IRawElementProviderSimple,
    structureChangeType: StructureChangeType,
    pRuntimeId: ?*i32,
    cRuntimeIdLen: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "uiautomationcore" fn UiaRaiseAsyncContentLoadedEvent(
    pProvider: ?*IRawElementProviderSimple,
    asyncContentLoadedState: AsyncContentLoadedState,
    percentComplete: f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.1'
pub extern "uiautomationcore" fn UiaRaiseTextEditTextChangedEvent(
    pProvider: ?*IRawElementProviderSimple,
    textEditChangeType: TextEditChangeType,
    pChangedData: ?*SAFEARRAY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "uiautomationcore" fn UiaRaiseChangesEvent(
    pProvider: ?*IRawElementProviderSimple,
    eventIdCount: i32,
    pUiaChanges: ?*UiaChangeInfo,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.16299'
pub extern "uiautomationcore" fn UiaRaiseNotificationEvent(
    provider: ?*IRawElementProviderSimple,
    notificationKind: NotificationKind,
    notificationProcessing: NotificationProcessing,
    displayString: ?BSTR,
    activityId: ?BSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.1'
pub extern "uiautomationcore" fn UiaRaiseActiveTextPositionChangedEvent(
    provider: ?*IRawElementProviderSimple,
    textRange: ?*ITextRangeProvider,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "uiautomationcore" fn UiaAddEvent(
    hnode: ?HUIANODE,
    eventId: i32,
    pCallback: ?*?UiaEventCallback,
    scope: TreeScope,
    pProperties: ?*i32,
    cProperties: i32,
    pRequest: ?*UiaCacheRequest,
    phEvent: ?*?HUIAEVENT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "uiautomationcore" fn UiaRemoveEvent(
    hEvent: ?HUIAEVENT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "uiautomationcore" fn UiaEventAddWindow(
    hEvent: ?HUIAEVENT,
    hwnd: ?HWND,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "uiautomationcore" fn UiaEventRemoveWindow(
    hEvent: ?HUIAEVENT,
    hwnd: ?HWND,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "uiautomationcore" fn DockPattern_SetDockPosition(
    hobj: ?HUIAPATTERNOBJECT,
    dockPosition: DockPosition,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "uiautomationcore" fn ExpandCollapsePattern_Collapse(
    hobj: ?HUIAPATTERNOBJECT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "uiautomationcore" fn ExpandCollapsePattern_Expand(
    hobj: ?HUIAPATTERNOBJECT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "uiautomationcore" fn GridPattern_GetItem(
    hobj: ?HUIAPATTERNOBJECT,
    row: i32,
    column: i32,
    pResult: ?*?HUIANODE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "uiautomationcore" fn InvokePattern_Invoke(
    hobj: ?HUIAPATTERNOBJECT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "uiautomationcore" fn MultipleViewPattern_GetViewName(
    hobj: ?HUIAPATTERNOBJECT,
    viewId: i32,
    ppStr: ?*?BSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "uiautomationcore" fn MultipleViewPattern_SetCurrentView(
    hobj: ?HUIAPATTERNOBJECT,
    viewId: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "uiautomationcore" fn RangeValuePattern_SetValue(
    hobj: ?HUIAPATTERNOBJECT,
    val: f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "uiautomationcore" fn ScrollItemPattern_ScrollIntoView(
    hobj: ?HUIAPATTERNOBJECT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "uiautomationcore" fn ScrollPattern_Scroll(
    hobj: ?HUIAPATTERNOBJECT,
    horizontalAmount: ScrollAmount,
    verticalAmount: ScrollAmount,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "uiautomationcore" fn ScrollPattern_SetScrollPercent(
    hobj: ?HUIAPATTERNOBJECT,
    horizontalPercent: f64,
    verticalPercent: f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "uiautomationcore" fn SelectionItemPattern_AddToSelection(
    hobj: ?HUIAPATTERNOBJECT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "uiautomationcore" fn SelectionItemPattern_RemoveFromSelection(
    hobj: ?HUIAPATTERNOBJECT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "uiautomationcore" fn SelectionItemPattern_Select(
    hobj: ?HUIAPATTERNOBJECT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "uiautomationcore" fn TogglePattern_Toggle(
    hobj: ?HUIAPATTERNOBJECT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "uiautomationcore" fn TransformPattern_Move(
    hobj: ?HUIAPATTERNOBJECT,
    x: f64,
    y: f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "uiautomationcore" fn TransformPattern_Resize(
    hobj: ?HUIAPATTERNOBJECT,
    width: f64,
    height: f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "uiautomationcore" fn TransformPattern_Rotate(
    hobj: ?HUIAPATTERNOBJECT,
    degrees: f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "uiautomationcore" fn ValuePattern_SetValue(
    hobj: ?HUIAPATTERNOBJECT,
    pVal: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "uiautomationcore" fn WindowPattern_Close(
    hobj: ?HUIAPATTERNOBJECT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "uiautomationcore" fn WindowPattern_SetWindowVisualState(
    hobj: ?HUIAPATTERNOBJECT,
    state: WindowVisualState,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "uiautomationcore" fn WindowPattern_WaitForInputIdle(
    hobj: ?HUIAPATTERNOBJECT,
    milliseconds: i32,
    pResult: ?*BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "uiautomationcore" fn TextPattern_GetSelection(
    hobj: ?HUIAPATTERNOBJECT,
    pRetVal: ?*?*SAFEARRAY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "uiautomationcore" fn TextPattern_GetVisibleRanges(
    hobj: ?HUIAPATTERNOBJECT,
    pRetVal: ?*?*SAFEARRAY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "uiautomationcore" fn TextPattern_RangeFromChild(
    hobj: ?HUIAPATTERNOBJECT,
    hnodeChild: ?HUIANODE,
    pRetVal: ?*?HUIATEXTRANGE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "uiautomationcore" fn TextPattern_RangeFromPoint(
    hobj: ?HUIAPATTERNOBJECT,
    point: UiaPoint,
    pRetVal: ?*?HUIATEXTRANGE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "uiautomationcore" fn TextPattern_get_DocumentRange(
    hobj: ?HUIAPATTERNOBJECT,
    pRetVal: ?*?HUIATEXTRANGE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "uiautomationcore" fn TextPattern_get_SupportedTextSelection(
    hobj: ?HUIAPATTERNOBJECT,
    pRetVal: ?*SupportedTextSelection,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "uiautomationcore" fn TextRange_Clone(
    hobj: ?HUIATEXTRANGE,
    pRetVal: ?*?HUIATEXTRANGE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "uiautomationcore" fn TextRange_Compare(
    hobj: ?HUIATEXTRANGE,
    range: ?HUIATEXTRANGE,
    pRetVal: ?*BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "uiautomationcore" fn TextRange_CompareEndpoints(
    hobj: ?HUIATEXTRANGE,
    endpoint: TextPatternRangeEndpoint,
    targetRange: ?HUIATEXTRANGE,
    targetEndpoint: TextPatternRangeEndpoint,
    pRetVal: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "uiautomationcore" fn TextRange_ExpandToEnclosingUnit(
    hobj: ?HUIATEXTRANGE,
    unit: TextUnit,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "uiautomationcore" fn TextRange_GetAttributeValue(
    hobj: ?HUIATEXTRANGE,
    attributeId: i32,
    pRetVal: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "uiautomationcore" fn TextRange_FindAttribute(
    hobj: ?HUIATEXTRANGE,
    attributeId: i32,
    val: VARIANT,
    backward: BOOL,
    pRetVal: ?*?HUIATEXTRANGE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "uiautomationcore" fn TextRange_FindText(
    hobj: ?HUIATEXTRANGE,
    text: ?BSTR,
    backward: BOOL,
    ignoreCase: BOOL,
    pRetVal: ?*?HUIATEXTRANGE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "uiautomationcore" fn TextRange_GetBoundingRectangles(
    hobj: ?HUIATEXTRANGE,
    pRetVal: ?*?*SAFEARRAY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "uiautomationcore" fn TextRange_GetEnclosingElement(
    hobj: ?HUIATEXTRANGE,
    pRetVal: ?*?HUIANODE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "uiautomationcore" fn TextRange_GetText(
    hobj: ?HUIATEXTRANGE,
    maxLength: i32,
    pRetVal: ?*?BSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "uiautomationcore" fn TextRange_Move(
    hobj: ?HUIATEXTRANGE,
    unit: TextUnit,
    count: i32,
    pRetVal: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "uiautomationcore" fn TextRange_MoveEndpointByUnit(
    hobj: ?HUIATEXTRANGE,
    endpoint: TextPatternRangeEndpoint,
    unit: TextUnit,
    count: i32,
    pRetVal: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "uiautomationcore" fn TextRange_MoveEndpointByRange(
    hobj: ?HUIATEXTRANGE,
    endpoint: TextPatternRangeEndpoint,
    targetRange: ?HUIATEXTRANGE,
    targetEndpoint: TextPatternRangeEndpoint,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "uiautomationcore" fn TextRange_Select(
    hobj: ?HUIATEXTRANGE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "uiautomationcore" fn TextRange_AddToSelection(
    hobj: ?HUIATEXTRANGE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "uiautomationcore" fn TextRange_RemoveFromSelection(
    hobj: ?HUIATEXTRANGE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "uiautomationcore" fn TextRange_ScrollIntoView(
    hobj: ?HUIATEXTRANGE,
    alignToTop: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "uiautomationcore" fn TextRange_GetChildren(
    hobj: ?HUIATEXTRANGE,
    pRetVal: ?*?*SAFEARRAY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "uiautomationcore" fn ItemContainerPattern_FindItemByProperty(
    hobj: ?HUIAPATTERNOBJECT,
    hnodeStartAfter: ?HUIANODE,
    propertyId: i32,
    value: VARIANT,
    pFound: ?*?HUIANODE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "uiautomationcore" fn LegacyIAccessiblePattern_Select(
    hobj: ?HUIAPATTERNOBJECT,
    flagsSelect: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "uiautomationcore" fn LegacyIAccessiblePattern_DoDefaultAction(
    hobj: ?HUIAPATTERNOBJECT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "uiautomationcore" fn LegacyIAccessiblePattern_SetValue(
    hobj: ?HUIAPATTERNOBJECT,
    szValue: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "uiautomationcore" fn LegacyIAccessiblePattern_GetIAccessible(
    hobj: ?HUIAPATTERNOBJECT,
    pAccessible: ?*?*IAccessible,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "uiautomationcore" fn SynchronizedInputPattern_StartListening(
    hobj: ?HUIAPATTERNOBJECT,
    inputType: SynchronizedInputType,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "uiautomationcore" fn SynchronizedInputPattern_Cancel(
    hobj: ?HUIAPATTERNOBJECT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "uiautomationcore" fn VirtualizedItemPattern_Realize(
    hobj: ?HUIAPATTERNOBJECT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "uiautomationcore" fn UiaPatternRelease(
    hobj: ?HUIAPATTERNOBJECT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "uiautomationcore" fn UiaTextRangeRelease(
    hobj: ?HUIATEXTRANGE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "uiautomationcore" fn UiaReturnRawElementProvider(
    hwnd: ?HWND,
    wParam: WPARAM,
    lParam: LPARAM,
    el: ?*IRawElementProviderSimple,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "uiautomationcore" fn UiaHostProviderFromHwnd(
    hwnd: ?HWND,
    ppProvider: ?*?*IRawElementProviderSimple,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "uiautomationcore" fn UiaProviderForNonClient(
    hwnd: ?HWND,
    idObject: i32,
    idChild: i32,
    ppProvider: ?*?*IRawElementProviderSimple,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "uiautomationcore" fn UiaIAccessibleFromProvider(
    pProvider: ?*IRawElementProviderSimple,
    dwFlags: u32,
    ppAccessible: ?*?*IAccessible,
    pvarChild: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "uiautomationcore" fn UiaProviderFromIAccessible(
    pAccessible: ?*IAccessible,
    idChild: i32,
    dwFlags: u32,
    ppProvider: ?*?*IRawElementProviderSimple,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "uiautomationcore" fn UiaDisconnectAllProviders(
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "uiautomationcore" fn UiaDisconnectProvider(
    pProvider: ?*IRawElementProviderSimple,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "uiautomationcore" fn UiaHasServerSideProvider(
    hwnd: ?HWND,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "user32" fn RegisterPointerInputTarget(
    hwnd: ?HWND,
    pointerType: POINTER_INPUT_TYPE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "user32" fn UnregisterPointerInputTarget(
    hwnd: ?HWND,
    pointerType: POINTER_INPUT_TYPE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "user32" fn RegisterPointerInputTargetEx(
    hwnd: ?HWND,
    pointerType: POINTER_INPUT_TYPE,
    fObserve: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "user32" fn UnregisterPointerInputTargetEx(
    hwnd: ?HWND,
    pointerType: POINTER_INPUT_TYPE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "user32" fn NotifyWinEvent(
    event: u32,
    hwnd: ?HWND,
    idObject: i32,
    idChild: i32,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "user32" fn SetWinEventHook(
    eventMin: u32,
    eventMax: u32,
    hmodWinEventProc: ?HINSTANCE,
    pfnWinEventProc: ?WINEVENTPROC,
    idProcess: u32,
    idThread: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) ?HWINEVENTHOOK;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "user32" fn IsWinEventHookInstalled(
    event: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "user32" fn UnhookWinEvent(
    hWinEventHook: ?HWINEVENTHOOK,
) callconv(@import("std").os.windows.WINAPI) BOOL;


//--------------------------------------------------------------------------------
// Section: Unicode Aliases (6)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
        pub const SERIALKEYS = thismodule.SERIALKEYSA;
        pub const HIGHCONTRAST = thismodule.HIGHCONTRASTA;
        pub const SOUNDSENTRY = thismodule.SOUNDSENTRYA;
        pub const GetRoleText = thismodule.GetRoleTextA;
        pub const GetStateText = thismodule.GetStateTextA;
        pub const CreateStdAccessibleProxy = thismodule.CreateStdAccessibleProxyA;
    },
    .wide => struct {
        pub const SERIALKEYS = thismodule.SERIALKEYSW;
        pub const HIGHCONTRAST = thismodule.HIGHCONTRASTW;
        pub const SOUNDSENTRY = thismodule.SOUNDSENTRYW;
        pub const GetRoleText = thismodule.GetRoleTextW;
        pub const GetStateText = thismodule.GetStateTextW;
        pub const CreateStdAccessibleProxy = thismodule.CreateStdAccessibleProxyW;
    },
    .unspecified => if (@import("builtin").is_test) struct {
        pub const SERIALKEYS = *opaque{};
        pub const HIGHCONTRAST = *opaque{};
        pub const SOUNDSENTRY = *opaque{};
        pub const GetRoleText = *opaque{};
        pub const GetStateText = *opaque{};
        pub const CreateStdAccessibleProxy = *opaque{};
    } else struct {
        pub const SERIALKEYS = @compileError("'SERIALKEYS' requires that UNICODE be set to true or false in the root module");
        pub const HIGHCONTRAST = @compileError("'HIGHCONTRAST' requires that UNICODE be set to true or false in the root module");
        pub const SOUNDSENTRY = @compileError("'SOUNDSENTRY' requires that UNICODE be set to true or false in the root module");
        pub const GetRoleText = @compileError("'GetRoleText' requires that UNICODE be set to true or false in the root module");
        pub const GetStateText = @compileError("'GetStateText' requires that UNICODE be set to true or false in the root module");
        pub const CreateStdAccessibleProxy = @compileError("'CreateStdAccessibleProxy' requires that UNICODE be set to true or false in the root module");
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (19)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const BOOL = @import("../foundation.zig").BOOL;
const BSTR = @import("../foundation.zig").BSTR;
const HINSTANCE = @import("../foundation.zig").HINSTANCE;
const HMENU = @import("../ui/windows_and_messaging.zig").HMENU;
const HRESULT = @import("../foundation.zig").HRESULT;
const HWND = @import("../foundation.zig").HWND;
const IDispatch = @import("../system/com.zig").IDispatch;
const IUnknown = @import("../system/com.zig").IUnknown;
const LPARAM = @import("../foundation.zig").LPARAM;
const LRESULT = @import("../foundation.zig").LRESULT;
const POINT = @import("../foundation.zig").POINT;
const POINTER_INPUT_TYPE = @import("../ui/windows_and_messaging.zig").POINTER_INPUT_TYPE;
const PSTR = @import("../foundation.zig").PSTR;
const PWSTR = @import("../foundation.zig").PWSTR;
const RECT = @import("../foundation.zig").RECT;
const SAFEARRAY = @import("../system/com.zig").SAFEARRAY;
const VARIANT = @import("../system/com.zig").VARIANT;
const WPARAM = @import("../foundation.zig").WPARAM;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "LPFNLRESULTFROMOBJECT")) { _ = LPFNLRESULTFROMOBJECT; }
    if (@hasDecl(@This(), "LPFNOBJECTFROMLRESULT")) { _ = LPFNOBJECTFROMLRESULT; }
    if (@hasDecl(@This(), "LPFNACCESSIBLEOBJECTFROMWINDOW")) { _ = LPFNACCESSIBLEOBJECTFROMWINDOW; }
    if (@hasDecl(@This(), "LPFNACCESSIBLEOBJECTFROMPOINT")) { _ = LPFNACCESSIBLEOBJECTFROMPOINT; }
    if (@hasDecl(@This(), "LPFNCREATESTDACCESSIBLEOBJECT")) { _ = LPFNCREATESTDACCESSIBLEOBJECT; }
    if (@hasDecl(@This(), "LPFNACCESSIBLECHILDREN")) { _ = LPFNACCESSIBLECHILDREN; }
    if (@hasDecl(@This(), "UiaProviderCallback")) { _ = UiaProviderCallback; }
    if (@hasDecl(@This(), "UiaEventCallback")) { _ = UiaEventCallback; }
    if (@hasDecl(@This(), "WINEVENTPROC")) { _ = WINEVENTPROC; }

    @setEvalBranchQuota(
        comptime @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        if (decl.is_pub) {
            _ = @field(@This(), decl.name);
        }
    }
}
