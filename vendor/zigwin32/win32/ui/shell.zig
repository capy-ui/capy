//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (1580)
//--------------------------------------------------------------------------------
pub const HLINK_E_FIRST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221248));
pub const HLINK_S_FIRST = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262400));
pub const WM_CPL_LAUNCH = @as(u32, 2024);
pub const WM_CPL_LAUNCHED = @as(u32, 2025);
pub const CPL_DYNAMIC_RES = @as(u32, 0);
pub const CPL_INIT = @as(u32, 1);
pub const CPL_GETCOUNT = @as(u32, 2);
pub const CPL_INQUIRE = @as(u32, 3);
pub const CPL_SELECT = @as(u32, 4);
pub const CPL_DBLCLK = @as(u32, 5);
pub const CPL_STOP = @as(u32, 6);
pub const CPL_EXIT = @as(u32, 7);
pub const CPL_NEWINQUIRE = @as(u32, 8);
pub const CPL_STARTWPARMSA = @as(u32, 9);
pub const CPL_STARTWPARMSW = @as(u32, 10);
pub const CPL_STARTWPARMS = @as(u32, 10);
pub const CPL_SETUP = @as(u32, 200);
pub const HLINK_S_DONTHIDE = @as(i32, 262400);
pub const FOLDERID_NetworkFolder = Guid.initString("d20beec4-5ca8-4905-ae3b-bf251ea09b53");
pub const FOLDERID_ComputerFolder = Guid.initString("0ac0837c-bbf8-452a-850d-79d08e667ca7");
pub const FOLDERID_InternetFolder = Guid.initString("4d9f7874-4e0c-4904-967b-40b0d20c3e4b");
pub const FOLDERID_ControlPanelFolder = Guid.initString("82a74aeb-aeb4-465c-a014-d097ee346d63");
pub const FOLDERID_PrintersFolder = Guid.initString("76fc4e2d-d6ad-4519-a663-37bd56068185");
pub const FOLDERID_SyncManagerFolder = Guid.initString("43668bf8-c14e-49b2-97c9-747784d784b7");
pub const FOLDERID_SyncSetupFolder = Guid.initString("0f214138-b1d3-4a90-bba9-27cbc0c5389a");
pub const FOLDERID_ConflictFolder = Guid.initString("4bfefb45-347d-4006-a5be-ac0cb0567192");
pub const FOLDERID_SyncResultsFolder = Guid.initString("289a9a43-be44-4057-a41b-587a76d7e7f9");
pub const FOLDERID_RecycleBinFolder = Guid.initString("b7534046-3ecb-4c18-be4e-64cd4cb7d6ac");
pub const FOLDERID_ConnectionsFolder = Guid.initString("6f0cd92b-2e97-45d1-88ff-b0d186b8dedd");
pub const FOLDERID_Fonts = Guid.initString("fd228cb7-ae11-4ae3-864c-16f3910ab8fe");
pub const FOLDERID_Desktop = Guid.initString("b4bfcc3a-db2c-424c-b029-7fe99a87c641");
pub const FOLDERID_Startup = Guid.initString("b97d20bb-f46a-4c97-ba10-5e3608430854");
pub const FOLDERID_Programs = Guid.initString("a77f5d77-2e2b-44c3-a6a2-aba601054a51");
pub const FOLDERID_StartMenu = Guid.initString("625b53c3-ab48-4ec1-ba1f-a1ef4146fc19");
pub const FOLDERID_Recent = Guid.initString("ae50c081-ebd2-438a-8655-8a092e34987a");
pub const FOLDERID_SendTo = Guid.initString("8983036c-27c0-404b-8f08-102d10dcfd74");
pub const FOLDERID_Documents = Guid.initString("fdd39ad0-238f-46af-adb4-6c85480369c7");
pub const FOLDERID_Favorites = Guid.initString("1777f761-68ad-4d8a-87bd-30b759fa33dd");
pub const FOLDERID_NetHood = Guid.initString("c5abbf53-e17f-4121-8900-86626fc2c973");
pub const FOLDERID_PrintHood = Guid.initString("9274bd8d-cfd1-41c3-b35e-b13f55a758f4");
pub const FOLDERID_Templates = Guid.initString("a63293e8-664e-48db-a079-df759e0509f7");
pub const FOLDERID_CommonStartup = Guid.initString("82a5ea35-d9cd-47c5-9629-e15d2f714e6e");
pub const FOLDERID_CommonPrograms = Guid.initString("0139d44e-6afe-49f2-8690-3dafcae6ffb8");
pub const FOLDERID_CommonStartMenu = Guid.initString("a4115719-d62e-491d-aa7c-e74b8be3b067");
pub const FOLDERID_PublicDesktop = Guid.initString("c4aa340d-f20f-4863-afef-f87ef2e6ba25");
pub const FOLDERID_ProgramData = Guid.initString("62ab5d82-fdc1-4dc3-a9dd-070d1d495d97");
pub const FOLDERID_CommonTemplates = Guid.initString("b94237e7-57ac-4347-9151-b08c6c32d1f7");
pub const FOLDERID_PublicDocuments = Guid.initString("ed4824af-dce4-45a8-81e2-fc7965083634");
pub const FOLDERID_RoamingAppData = Guid.initString("3eb685db-65f9-4cf6-a03a-e3ef65729f3d");
pub const FOLDERID_LocalAppData = Guid.initString("f1b32785-6fba-4fcf-9d55-7b8e7f157091");
pub const FOLDERID_LocalAppDataLow = Guid.initString("a520a1a4-1780-4ff6-bd18-167343c5af16");
pub const FOLDERID_InternetCache = Guid.initString("352481e8-33be-4251-ba85-6007caedcf9d");
pub const FOLDERID_Cookies = Guid.initString("2b0f765d-c0e9-4171-908e-08a611b84ff6");
pub const FOLDERID_History = Guid.initString("d9dc8a3b-b784-432e-a781-5a1130a75963");
pub const FOLDERID_System = Guid.initString("1ac14e77-02e7-4e5d-b744-2eb1ae5198b7");
pub const FOLDERID_SystemX86 = Guid.initString("d65231b0-b2f1-4857-a4ce-a8e7c6ea7d27");
pub const FOLDERID_Windows = Guid.initString("f38bf404-1d43-42f2-9305-67de0b28fc23");
pub const FOLDERID_Profile = Guid.initString("5e6c858f-0e22-4760-9afe-ea3317b67173");
pub const FOLDERID_Pictures = Guid.initString("33e28130-4e1e-4676-835a-98395c3bc3bb");
pub const FOLDERID_ProgramFilesX86 = Guid.initString("7c5a40ef-a0fb-4bfc-874a-c0f2e0b9fa8e");
pub const FOLDERID_ProgramFilesCommonX86 = Guid.initString("de974d24-d9c6-4d3e-bf91-f4455120b917");
pub const FOLDERID_ProgramFilesX64 = Guid.initString("6d809377-6af0-444b-8957-a3773f02200e");
pub const FOLDERID_ProgramFilesCommonX64 = Guid.initString("6365d5a7-0f0d-45e5-87f6-0da56b6a4f7d");
pub const FOLDERID_ProgramFiles = Guid.initString("905e63b6-c1bf-494e-b29c-65b732d3d21a");
pub const FOLDERID_ProgramFilesCommon = Guid.initString("f7f1ed05-9f6d-47a2-aaae-29d317c6f066");
pub const FOLDERID_UserProgramFiles = Guid.initString("5cd7aee2-2219-4a67-b85d-6c9ce15660cb");
pub const FOLDERID_UserProgramFilesCommon = Guid.initString("bcbd3057-ca5c-4622-b42d-bc56db0ae516");
pub const FOLDERID_AdminTools = Guid.initString("724ef170-a42d-4fef-9f26-b60e846fba4f");
pub const FOLDERID_CommonAdminTools = Guid.initString("d0384e7d-bac3-4797-8f14-cba229b392b5");
pub const FOLDERID_Music = Guid.initString("4bd8d571-6d19-48d3-be97-422220080e43");
pub const FOLDERID_Videos = Guid.initString("18989b1d-99b5-455b-841c-ab7c74e4ddfc");
pub const FOLDERID_Ringtones = Guid.initString("c870044b-f49e-4126-a9c3-b52a1ff411e8");
pub const FOLDERID_PublicPictures = Guid.initString("b6ebfb86-6907-413c-9af7-4fc2abf07cc5");
pub const FOLDERID_PublicMusic = Guid.initString("3214fab5-9757-4298-bb61-92a9deaa44ff");
pub const FOLDERID_PublicVideos = Guid.initString("2400183a-6185-49fb-a2d8-4a392a602ba3");
pub const FOLDERID_PublicRingtones = Guid.initString("e555ab60-153b-4d17-9f04-a5fe99fc15ec");
pub const FOLDERID_ResourceDir = Guid.initString("8ad10c31-2adb-4296-a8f7-e4701232c972");
pub const FOLDERID_LocalizedResourcesDir = Guid.initString("2a00375e-224c-49de-b8d1-440df7ef3ddc");
pub const FOLDERID_CommonOEMLinks = Guid.initString("c1bae2d0-10df-4334-bedd-7aa20b227a9d");
pub const FOLDERID_CDBurning = Guid.initString("9e52ab10-f80d-49df-acb8-4330f5687855");
pub const FOLDERID_UserProfiles = Guid.initString("0762d272-c50a-4bb0-a382-697dcd729b80");
pub const FOLDERID_Playlists = Guid.initString("de92c1c7-837f-4f69-a3bb-86e631204a23");
pub const FOLDERID_SamplePlaylists = Guid.initString("15ca69b3-30ee-49c1-ace1-6b5ec372afb5");
pub const FOLDERID_SampleMusic = Guid.initString("b250c668-f57d-4ee1-a63c-290ee7d1aa1f");
pub const FOLDERID_SamplePictures = Guid.initString("c4900540-2379-4c75-844b-64e6faf8716b");
pub const FOLDERID_SampleVideos = Guid.initString("859ead94-2e85-48ad-a71a-0969cb56a6cd");
pub const FOLDERID_PhotoAlbums = Guid.initString("69d2cf90-fc33-4fb7-9a0c-ebb0f0fcb43c");
pub const FOLDERID_Public = Guid.initString("dfdf76a2-c82a-4d63-906a-5644ac457385");
pub const FOLDERID_ChangeRemovePrograms = Guid.initString("df7266ac-9274-4867-8d55-3bd661de872d");
pub const FOLDERID_AppUpdates = Guid.initString("a305ce99-f527-492b-8b1a-7e76fa98d6e4");
pub const FOLDERID_AddNewPrograms = Guid.initString("de61d971-5ebc-4f02-a3a9-6c82895e5c04");
pub const FOLDERID_Downloads = Guid.initString("374de290-123f-4565-9164-39c4925e467b");
pub const FOLDERID_PublicDownloads = Guid.initString("3d644c9b-1fb8-4f30-9b45-f670235f79c0");
pub const FOLDERID_SavedSearches = Guid.initString("7d1d3a04-debb-4115-95cf-2f29da2920da");
pub const FOLDERID_QuickLaunch = Guid.initString("52a4f021-7b75-48a9-9f6b-4b87a210bc8f");
pub const FOLDERID_Contacts = Guid.initString("56784854-c6cb-462b-8169-88e350acb882");
pub const FOLDERID_SidebarParts = Guid.initString("a75d362e-50fc-4fb7-ac2c-a8beaa314493");
pub const FOLDERID_SidebarDefaultParts = Guid.initString("7b396e54-9ec5-4300-be0a-2482ebae1a26");
pub const FOLDERID_PublicGameTasks = Guid.initString("debf2536-e1a8-4c59-b6a2-414586476aea");
pub const FOLDERID_GameTasks = Guid.initString("054fae61-4dd8-4787-80b6-090220c4b700");
pub const FOLDERID_SavedGames = Guid.initString("4c5c32ff-bb9d-43b0-b5b4-2d72e54eaaa4");
pub const FOLDERID_Games = Guid.initString("cac52c1a-b53d-4edc-92d7-6b2e8ac19434");
pub const FOLDERID_SEARCH_MAPI = Guid.initString("98ec0e18-2098-4d44-8644-66979315a281");
pub const FOLDERID_SEARCH_CSC = Guid.initString("ee32e446-31ca-4aba-814f-a5ebd2fd6d5e");
pub const FOLDERID_Links = Guid.initString("bfb9d5e0-c6a9-404c-b2b2-ae6db6af4968");
pub const FOLDERID_UsersFiles = Guid.initString("f3ce0f7c-4901-4acc-8648-d5d44b04ef8f");
pub const FOLDERID_UsersLibraries = Guid.initString("a302545d-deff-464b-abe8-61c8648d939b");
pub const FOLDERID_SearchHome = Guid.initString("190337d1-b8ca-4121-a639-6d472d16972a");
pub const FOLDERID_OriginalImages = Guid.initString("2c36c0aa-5812-4b87-bfd0-4cd0dfb19b39");
pub const FOLDERID_DocumentsLibrary = Guid.initString("7b0db17d-9cd2-4a93-9733-46cc89022e7c");
pub const FOLDERID_MusicLibrary = Guid.initString("2112ab0a-c86a-4ffe-a368-0de96e47012e");
pub const FOLDERID_PicturesLibrary = Guid.initString("a990ae9f-a03b-4e80-94bc-9912d7504104");
pub const FOLDERID_VideosLibrary = Guid.initString("491e922f-5643-4af4-a7eb-4e7a138d8174");
pub const FOLDERID_RecordedTVLibrary = Guid.initString("1a6fdba2-f42d-4358-a798-b74d745926c5");
pub const FOLDERID_HomeGroup = Guid.initString("52528a6b-b9e3-4add-b60d-588c2dba842d");
pub const FOLDERID_HomeGroupCurrentUser = Guid.initString("9b74b6a3-0dfd-4f11-9e78-5f7800f2e772");
pub const FOLDERID_DeviceMetadataStore = Guid.initString("5ce4a5e9-e4eb-479d-b89f-130c02886155");
pub const FOLDERID_Libraries = Guid.initString("1b3ea5dc-b587-4786-b4ef-bd1dc332aeae");
pub const FOLDERID_PublicLibraries = Guid.initString("48daf80b-e6cf-4f4e-b800-0e69d84ee384");
pub const FOLDERID_UserPinned = Guid.initString("9e3995ab-1f9c-4f13-b827-48b24b6c7174");
pub const FOLDERID_ImplicitAppShortcuts = Guid.initString("bcb5256f-79f6-4cee-b725-dc34e402fd46");
pub const FOLDERID_AccountPictures = Guid.initString("008ca0b1-55b4-4c56-b8a8-4de4b299d3be");
pub const FOLDERID_PublicUserTiles = Guid.initString("0482af6c-08f1-4c34-8c90-e17ec98b1e17");
pub const FOLDERID_AppsFolder = Guid.initString("1e87508d-89c2-42f0-8a7e-645a0f50ca58");
pub const FOLDERID_StartMenuAllPrograms = Guid.initString("f26305ef-6948-40b9-b255-81453d09c785");
pub const FOLDERID_CommonStartMenuPlaces = Guid.initString("a440879f-87a0-4f7d-b700-0207b966194a");
pub const FOLDERID_ApplicationShortcuts = Guid.initString("a3918781-e5f2-4890-b3d9-a7e54332328c");
pub const FOLDERID_RoamingTiles = Guid.initString("00bcfc5a-ed94-4e48-96a1-3f6217f21990");
pub const FOLDERID_RoamedTileImages = Guid.initString("aaa8d5a5-f1d6-4259-baa8-78e7ef60835e");
pub const FOLDERID_Screenshots = Guid.initString("b7bede81-df94-4682-a7d8-57a52620b86f");
pub const FOLDERID_CameraRoll = Guid.initString("ab5fb87b-7ce2-4f83-915d-550846c9537b");
pub const FOLDERID_SkyDrive = Guid.initString("a52bba46-e9e1-435f-b3d9-28daa648c0f6");
pub const FOLDERID_OneDrive = Guid.initString("a52bba46-e9e1-435f-b3d9-28daa648c0f6");
pub const FOLDERID_SkyDriveDocuments = Guid.initString("24d89e24-2f19-4534-9dde-6a6671fbb8fe");
pub const FOLDERID_SkyDrivePictures = Guid.initString("339719b5-8c47-4894-94c2-d8f77add44a6");
pub const FOLDERID_SkyDriveMusic = Guid.initString("c3f2459e-80d6-45dc-bfef-1f769f2be730");
pub const FOLDERID_SkyDriveCameraRoll = Guid.initString("767e6811-49cb-4273-87c2-20f355e1085b");
pub const FOLDERID_SearchHistory = Guid.initString("0d4c3db6-03a3-462f-a0e6-08924c41b5d4");
pub const FOLDERID_SearchTemplates = Guid.initString("7e636bfe-dfa9-4d5e-b456-d7b39851d8a9");
pub const FOLDERID_CameraRollLibrary = Guid.initString("2b20df75-1eda-4039-8097-38798227d5b7");
pub const FOLDERID_SavedPictures = Guid.initString("3b193882-d3ad-4eab-965a-69829d1fb59f");
pub const FOLDERID_SavedPicturesLibrary = Guid.initString("e25b5812-be88-4bd9-94b0-29233477b6c3");
pub const FOLDERID_RetailDemo = Guid.initString("12d4c69e-24ad-4923-be19-31321c43a767");
pub const FOLDERID_Device = Guid.initString("1c2ac1dc-4358-4b6c-9733-af21156576f0");
pub const FOLDERID_DevelopmentFiles = Guid.initString("dbe8e08e-3053-4bbc-b183-2a7b2b191e59");
pub const FOLDERID_Objects3D = Guid.initString("31c0dd25-9439-4f12-bf41-7ff4eda38722");
pub const FOLDERID_AppCaptures = Guid.initString("edc0fe71-98d8-4f4a-b920-c8dc133cb165");
pub const FOLDERID_LocalDocuments = Guid.initString("f42ee2d3-909f-4907-8871-4c22fc0bf756");
pub const FOLDERID_LocalPictures = Guid.initString("0ddd015d-b06c-45d5-8c4c-f59713854639");
pub const FOLDERID_LocalVideos = Guid.initString("35286a68-3c57-41a1-bbb1-0eae73d76c95");
pub const FOLDERID_LocalMusic = Guid.initString("a0c69a99-21c8-4671-8703-7934162fcf1d");
pub const FOLDERID_LocalDownloads = Guid.initString("7d83ee9b-2244-4e70-b1f5-5393042af1e4");
pub const FOLDERID_RecordedCalls = Guid.initString("2f8b40c2-83ed-48ee-b383-a1f157ec6f9a");
pub const FOLDERID_AllAppMods = Guid.initString("7ad67899-66af-43ba-9156-6aad42e6c596");
pub const FOLDERID_CurrentAppMods = Guid.initString("3db40b20-2a30-4dbe-917e-771dd21dd099");
pub const FOLDERID_AppDataDesktop = Guid.initString("b2c5e279-7add-439f-b28c-c41fe1bbf672");
pub const FOLDERID_AppDataDocuments = Guid.initString("7be16610-1f7f-44ac-bff0-83e15f2ffca1");
pub const FOLDERID_AppDataFavorites = Guid.initString("7cfbefbc-de1f-45aa-b843-a542ac536cc9");
pub const FOLDERID_AppDataProgramData = Guid.initString("559d40a3-a036-40fa-af61-84cb430a4d34");
pub const FOLDERID_LocalStorage = Guid.initString("b3eb08d3-a1f3-496b-865a-42b536cda0ec");
pub const CLSID_InternetShortcut = Guid.initString("fbf23b40-e3f0-101b-8488-00aa003e56f8");
pub const CLSID_NetworkDomain = Guid.initString("46e06680-4bf0-11d1-83ee-00a0c90dc849");
pub const CLSID_NetworkServer = Guid.initString("c0542a90-4bf0-11d1-83ee-00a0c90dc849");
pub const CLSID_NetworkShare = Guid.initString("54a754c0-4bf0-11d1-83ee-00a0c90dc849");
pub const CLSID_MyComputer = Guid.initString("20d04fe0-3aea-1069-a2d8-08002b30309d");
pub const CLSID_Internet = Guid.initString("871c5380-42a0-1069-a2ea-08002b30309d");
pub const CLSID_RecycleBin = Guid.initString("645ff040-5081-101b-9f08-00aa002f954e");
pub const CLSID_ControlPanel = Guid.initString("21ec2020-3aea-1069-a2dd-08002b30309d");
pub const CLSID_Printers = Guid.initString("2227a280-3aea-1069-a2de-08002b30309d");
pub const CLSID_MyDocuments = Guid.initString("450d8fba-ad25-11d0-98a8-0800361b1103");
pub const CATID_BrowsableShellExt = Guid.initString("00021490-0000-0000-c000-000000000046");
pub const CATID_BrowseInPlace = Guid.initString("00021491-0000-0000-c000-000000000046");
pub const CATID_DeskBand = Guid.initString("00021492-0000-0000-c000-000000000046");
pub const CATID_InfoBand = Guid.initString("00021493-0000-0000-c000-000000000046");
pub const CATID_CommBand = Guid.initString("00021494-0000-0000-c000-000000000046");
pub const FMTID_Intshcut = Guid.initString("000214a0-0000-0000-c000-000000000046");
pub const FMTID_InternetSite = Guid.initString("000214a1-0000-0000-c000-000000000046");
pub const CGID_Explorer = Guid.initString("000214d0-0000-0000-c000-000000000046");
pub const CGID_ShellDocView = Guid.initString("000214d1-0000-0000-c000-000000000046");
pub const CGID_ShellServiceObject = Guid.initString("000214d2-0000-0000-c000-000000000046");
pub const CGID_ExplorerBarDoc = Guid.initString("000214d3-0000-0000-c000-000000000046");
pub const CLSID_FolderShortcut = Guid.initString("0afaced1-e828-11d1-9187-b532f1e9575d");
pub const CLSID_CFSIconOverlayManager = Guid.initString("63b51f81-c868-11d0-999c-00c04fd655e1");
pub const CLSID_ShellThumbnailDiskCache = Guid.initString("1ebdcf80-a200-11d0-a3a4-00c04fd706ec");
pub const SID_DefView = Guid.initString("6d12fe80-7911-11cf-9534-0000c05bae0b");
pub const CGID_DefView = Guid.initString("4af07f10-d231-11d0-b942-00a0c90312e1");
pub const CLSID_MenuBand = Guid.initString("5b4dae26-b807-11d0-9815-00c04fd91972");
pub const VID_LargeIcons = Guid.initString("0057d0e0-3573-11cf-ae69-08002b2e1262");
pub const VID_SmallIcons = Guid.initString("089000c0-3573-11cf-ae69-08002b2e1262");
pub const VID_List = Guid.initString("0e1fa5e0-3573-11cf-ae69-08002b2e1262");
pub const VID_Details = Guid.initString("137e7700-3573-11cf-ae69-08002b2e1262");
pub const VID_Tile = Guid.initString("65f125e5-7be1-4810-ba9d-d271c8432ce3");
pub const VID_Content = Guid.initString("30c2c434-0889-4c8d-985d-a9f71830b0a9");
pub const VID_Thumbnails = Guid.initString("8bebb290-52d0-11d0-b7f4-00c04fd706ec");
pub const VID_ThumbStrip = Guid.initString("8eefa624-d1e9-445b-94b7-74fbce2ea11a");
pub const SID_SInPlaceBrowser = Guid.initString("1d2ae02b-3655-46cc-b63a-285988153bca");
pub const SID_SSearchBoxInfo = Guid.initString("142daa61-516b-4713-b49c-fb985ef82998");
pub const SID_CommandsPropertyBag = Guid.initString("6e043250-4416-485c-b143-e62a760d9fe5");
pub const CLSID_CUrlHistory = Guid.initString("3c374a40-bae4-11cf-bf7d-00aa006946ee");
pub const CLSID_CURLSearchHook = Guid.initString("cfbfae00-17a6-11d0-99cb-00c04fd64497");
pub const CLSID_AutoComplete = Guid.initString("00bb2763-6a77-11d0-a535-00c04fd7d062");
pub const CLSID_ACLHistory = Guid.initString("00bb2764-6a77-11d0-a535-00c04fd7d062");
pub const CLSID_ACListISF = Guid.initString("03c036f1-a186-11d0-824a-00aa005b4383");
pub const CLSID_ACLMRU = Guid.initString("6756a641-de71-11d0-831b-00aa005b4383");
pub const CLSID_ACLMulti = Guid.initString("00bb2765-6a77-11d0-a535-00c04fd7d062");
pub const CLSID_ACLCustomMRU = Guid.initString("6935db93-21e8-4ccc-beb9-9fe3c77a297a");
pub const CLSID_ProgressDialog = Guid.initString("f8383852-fcd3-11d1-a6b9-006097df5bd4");
pub const SID_STopLevelBrowser = Guid.initString("4c96be40-915c-11cf-99d3-00aa004ae837");
pub const CLSID_FileTypes = Guid.initString("b091e540-83e3-11cf-a713-0020afd79762");
pub const CLSID_ActiveDesktop = Guid.initString("75048700-ef1f-11d0-9888-006097deacf9");
pub const CLSID_QueryAssociations = Guid.initString("a07034fd-6caa-4954-ac3f-97a27216f98a");
pub const CLSID_LinkColumnProvider = Guid.initString("24f14f02-7b1c-11d1-838f-0000f80461cf");
pub const CGID_ShortCut = Guid.initString("93a68750-951a-11d1-946f-000000000000");
pub const CLSID_InternetButtons = Guid.initString("1e796980-9cc5-11d1-a83f-00c04fc99d61");
pub const CLSID_MSOButtons = Guid.initString("178f34b8-a282-11d2-86c5-00c04f8eea99");
pub const CLSID_ToolbarExtButtons = Guid.initString("2ce4b5d8-a28f-11d2-86c5-00c04f8eea99");
pub const CLSID_DarwinAppPublisher = Guid.initString("cfccc7a0-a282-11d1-9082-006008059382");
pub const CLSID_DocHostUIHandler = Guid.initString("7057e952-bd1b-11d1-8919-00c04fc2c836");
pub const FMTID_ShellDetails = Guid.initString("28636aa6-953d-11d2-b5d6-00c04fd918d0");
pub const PID_FINDDATA = @as(u32, 0);
pub const PID_NETRESOURCE = @as(u32, 1);
pub const PID_DESCRIPTIONID = @as(u32, 2);
pub const PID_WHICHFOLDER = @as(u32, 3);
pub const PID_NETWORKLOCATION = @as(u32, 4);
pub const PID_COMPUTERNAME = @as(u32, 5);
pub const FMTID_Storage = Guid.initString("b725f130-47ef-101a-a5f1-02608c9eebac");
pub const FMTID_ImageProperties = Guid.initString("14b81da1-0135-4d31-96d9-6cbfc9671a99");
pub const FMTID_CustomImageProperties = Guid.initString("7ecd8b0e-c136-4a9b-9411-4ebd6673ccc3");
pub const FMTID_LibraryProperties = Guid.initString("5d76b67f-9b3d-44bb-b6ae-25da4f638a67");
pub const FMTID_Displaced = Guid.initString("9b174b33-40ff-11d2-a27e-00c04fc30871");
pub const PID_DISPLACED_FROM = @as(u32, 2);
pub const PID_DISPLACED_DATE = @as(u32, 3);
pub const FMTID_Briefcase = Guid.initString("328d8b21-7729-4bfc-954c-902b329d56b0");
pub const PID_SYNC_COPY_IN = @as(u32, 2);
pub const FMTID_Misc = Guid.initString("9b174b34-40ff-11d2-a27e-00c04fc30871");
pub const PID_MISC_STATUS = @as(u32, 2);
pub const PID_MISC_ACCESSCOUNT = @as(u32, 3);
pub const PID_MISC_OWNER = @as(u32, 4);
pub const PID_HTMLINFOTIPFILE = @as(u32, 5);
pub const PID_MISC_PICS = @as(u32, 6);
pub const FMTID_WebView = Guid.initString("f2275480-f782-4291-bd94-f13693513aec");
pub const PID_DISPLAY_PROPERTIES = @as(u32, 0);
pub const PID_INTROTEXT = @as(u32, 1);
pub const FMTID_MUSIC = Guid.initString("56a3372e-ce9c-11d2-9f0e-006097c686f6");
pub const PIDSI_ARTIST = @as(u32, 2);
pub const PIDSI_SONGTITLE = @as(u32, 3);
pub const PIDSI_ALBUM = @as(u32, 4);
pub const PIDSI_YEAR = @as(u32, 5);
pub const PIDSI_COMMENT = @as(u32, 6);
pub const PIDSI_TRACK = @as(u32, 7);
pub const PIDSI_GENRE = @as(u32, 11);
pub const PIDSI_LYRICS = @as(u32, 12);
pub const FMTID_DRM = Guid.initString("aeac19e4-89ae-4508-b9b7-bb867abee2ed");
pub const PIDDRSI_PROTECTED = @as(u32, 2);
pub const PIDDRSI_DESCRIPTION = @as(u32, 3);
pub const PIDDRSI_PLAYCOUNT = @as(u32, 4);
pub const PIDDRSI_PLAYSTARTS = @as(u32, 5);
pub const PIDDRSI_PLAYEXPIRES = @as(u32, 6);
pub const PIDVSI_STREAM_NAME = @as(u32, 2);
pub const PIDVSI_FRAME_WIDTH = @as(u32, 3);
pub const PIDVSI_FRAME_HEIGHT = @as(u32, 4);
pub const PIDVSI_TIMELENGTH = @as(u32, 7);
pub const PIDVSI_FRAME_COUNT = @as(u32, 5);
pub const PIDVSI_FRAME_RATE = @as(u32, 6);
pub const PIDVSI_DATA_RATE = @as(u32, 8);
pub const PIDVSI_SAMPLE_SIZE = @as(u32, 9);
pub const PIDVSI_COMPRESSION = @as(u32, 10);
pub const PIDVSI_STREAM_NUMBER = @as(u32, 11);
pub const PIDASI_FORMAT = @as(u32, 2);
pub const PIDASI_TIMELENGTH = @as(u32, 3);
pub const PIDASI_AVG_DATA_RATE = @as(u32, 4);
pub const PIDASI_SAMPLE_RATE = @as(u32, 5);
pub const PIDASI_SAMPLE_SIZE = @as(u32, 6);
pub const PIDASI_CHANNEL_COUNT = @as(u32, 7);
pub const PIDASI_STREAM_NUMBER = @as(u32, 8);
pub const PIDASI_STREAM_NAME = @as(u32, 9);
pub const PIDASI_COMPRESSION = @as(u32, 10);
pub const PID_CONTROLPANEL_CATEGORY = @as(u32, 2);
pub const FMTID_Volume = Guid.initString("9b174b35-40ff-11d2-a27e-00c04fc30871");
pub const PID_VOLUME_FREE = @as(u32, 2);
pub const PID_VOLUME_CAPACITY = @as(u32, 3);
pub const PID_VOLUME_FILESYSTEM = @as(u32, 4);
pub const PID_SHARE_CSC_STATUS = @as(u32, 2);
pub const PID_LINK_TARGET = @as(u32, 2);
pub const PID_LINK_TARGET_TYPE = @as(u32, 3);
pub const FMTID_Query = Guid.initString("49691c90-7e17-101a-a91c-08002b2ecda9");
pub const PID_QUERY_RANK = @as(u32, 2);
pub const CLSID_HWShellExecute = Guid.initString("ffb8655f-81b9-4fce-b89c-9a6ba76d13e7");
pub const CLSID_DragDropHelper = Guid.initString("4657278a-411b-11d2-839a-00c04fd918d0");
pub const CLSID_CAnchorBrowsePropertyPage = Guid.initString("3050f3bb-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_CImageBrowsePropertyPage = Guid.initString("3050f3b3-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_CDocBrowsePropertyPage = Guid.initString("3050f3b4-98b5-11cf-bb82-00aa00bdce0b");
pub const SID_STopWindow = Guid.initString("49e1b500-4636-11d3-97f7-00c04f45d0b3");
pub const SID_SGetViewFromViewDual = Guid.initString("889a935d-971e-4b12-b90c-24dfc9e1e5e8");
pub const CLSID_FolderItemsMultiLevel = Guid.initString("53c74826-ab99-4d33-aca4-3117f51d3788");
pub const CLSID_NewMenu = Guid.initString("d969a300-e7ff-11d0-a93b-00a0c90f2719");
pub const BHID_SFObject = Guid.initString("3981e224-f559-11d3-8e3a-00c04f6837d5");
pub const BHID_SFUIObject = Guid.initString("3981e225-f559-11d3-8e3a-00c04f6837d5");
pub const BHID_SFViewObject = Guid.initString("3981e226-f559-11d3-8e3a-00c04f6837d5");
pub const BHID_Storage = Guid.initString("3981e227-f559-11d3-8e3a-00c04f6837d5");
pub const BHID_Stream = Guid.initString("1cebb3ab-7c10-499a-a417-92ca16c4cb83");
pub const BHID_RandomAccessStream = Guid.initString("f16fc93b-77ae-4cfe-bda7-a866eea6878d");
pub const BHID_LinkTargetItem = Guid.initString("3981e228-f559-11d3-8e3a-00c04f6837d5");
pub const BHID_StorageEnum = Guid.initString("4621a4e3-f0d6-4773-8a9c-46e77b174840");
pub const BHID_Transfer = Guid.initString("d5e346a1-f753-4932-b403-4574800e2498");
pub const BHID_PropertyStore = Guid.initString("0384e1a4-1523-439c-a4c8-ab911052f586");
pub const BHID_ThumbnailHandler = Guid.initString("7b2e650a-8e20-4f4a-b09e-6597afc72fb0");
pub const BHID_EnumItems = Guid.initString("94f60519-2850-4924-aa5a-d15e84868039");
pub const BHID_DataObject = Guid.initString("b8c0bd9f-ed24-455c-83e6-d5390c4fe8c4");
pub const BHID_AssociationArray = Guid.initString("bea9ef17-82f1-4f60-9284-4f8db75c3be9");
pub const BHID_Filter = Guid.initString("38d08778-f557-4690-9ebf-ba54706ad8f7");
pub const BHID_EnumAssocHandlers = Guid.initString("b8ab0b9c-c2ec-4f7a-918d-314900e6280a");
pub const BHID_StorageItem = Guid.initString("404e2109-77d2-4699-a5a0-4fdf10db9837");
pub const BHID_FilePlaceholder = Guid.initString("8677dceb-aae0-4005-8d3d-547fa852f825");
pub const CATID_FilePlaceholderMergeHandler = Guid.initString("3e9c9a51-d4aa-4870-b47c-7424b491f1cc");
pub const SID_CtxQueryAssociations = Guid.initString("faadfc40-b777-4b69-aa81-77035ef0e6e8");
pub const CLSID_QuickLinks = Guid.initString("0e5cbf21-d15f-11d0-8301-00aa005b4383");
pub const CLSID_ISFBand = Guid.initString("d82be2b0-5764-11d0-a96e-00c04fd705a2");
pub const CLSID_ShellFldSetExt = Guid.initString("6d5313c0-8c62-11d1-b2cd-006097df8c11");
pub const SID_SMenuBandChild = Guid.initString("ed9cc020-08b9-11d1-9823-00c04fd91972");
pub const SID_SMenuBandParent = Guid.initString("8c278eec-3eab-11d1-8cb0-00c04fd918d0");
pub const SID_SMenuPopup = Guid.initString("d1e7afeb-6a2e-11d0-8c78-00c04fd918b4");
pub const SID_SMenuBandBottomSelected = Guid.initString("165ebaf4-6d51-11d2-83ad-00c04fd918d0");
pub const SID_SMenuBandBottom = Guid.initString("743ca664-0deb-11d1-9825-00c04fd91972");
pub const SID_MenuShellFolder = Guid.initString("a6c17eb4-2d65-11d2-838f-00c04fd918d0");
pub const SID_SMenuBandContextMenuModifier = Guid.initString("39545874-7162-465e-b783-2aa1874fef81");
pub const SID_SMenuBandBKContextMenu = Guid.initString("164bbd86-1d0d-4de0-9a3b-d9729647c2b8");
pub const CGID_MENUDESKBAR = Guid.initString("5c9f0a12-959e-11d0-a3a4-00a0c9082636");
pub const SID_SMenuBandTop = Guid.initString("9493a810-ec38-11d0-bc46-00aa006ce2f5");
pub const CLSID_MenuToolbarBase = Guid.initString("40b96610-b522-11d1-b3b4-00aa006efde7");
pub const CLSID_MenuBandSite = Guid.initString("e13ef4e4-d2f2-11d0-9816-00c04fd91972");
pub const SID_SCommDlgBrowser = Guid.initString("80f30233-b7df-11d2-a33b-006097df5bd4");
pub const CPFG_LOGON_USERNAME = Guid.initString("da15bbe8-954d-4fd3-b0f4-1fb5b90b174b");
pub const CPFG_LOGON_PASSWORD = Guid.initString("60624cfa-a477-47b1-8a8e-3a4a19981827");
pub const CPFG_SMARTCARD_USERNAME = Guid.initString("3e1ecf69-568c-4d96-9d59-46444174e2d6");
pub const CPFG_SMARTCARD_PIN = Guid.initString("4fe5263b-9181-46c1-b0a4-9dedd4db7dea");
pub const CPFG_CREDENTIAL_PROVIDER_LOGO = Guid.initString("2d837775-f6cd-464e-a745-482fd0b47493");
pub const CPFG_CREDENTIAL_PROVIDER_LABEL = Guid.initString("286bbff3-bad4-438f-b007-79b7267c3d48");
pub const CPFG_STANDALONE_SUBMIT_BUTTON = Guid.initString("0b7b0ad8-cc36-4d59-802b-82f714fa7022");
pub const CPFG_STYLE_LINK_AS_BUTTON = Guid.initString("088fa508-94a6-4430-a4cb-6fc6e3c0b9e2");
pub const FOLDERTYPEID_Invalid = Guid.initString("57807898-8c4f-4462-bb63-71042380b109");
pub const FOLDERTYPEID_Generic = Guid.initString("5c4f28b5-f869-4e84-8e60-f11db97c5cc7");
pub const FOLDERTYPEID_GenericSearchResults = Guid.initString("7fde1a1e-8b31-49a5-93b8-6be14cfa4943");
pub const FOLDERTYPEID_GenericLibrary = Guid.initString("5f4eab9a-6833-4f61-899d-31cf46979d49");
pub const FOLDERTYPEID_Documents = Guid.initString("7d49d726-3c21-4f05-99aa-fdc2c9474656");
pub const FOLDERTYPEID_Pictures = Guid.initString("b3690e58-e961-423b-b687-386ebfd83239");
pub const FOLDERTYPEID_Music = Guid.initString("94d6ddcc-4a68-4175-a374-bd584a510b78");
pub const FOLDERTYPEID_Videos = Guid.initString("5fa96407-7e77-483c-ac93-691d05850de8");
pub const FOLDERTYPEID_Downloads = Guid.initString("885a186e-a440-4ada-812b-db871b942259");
pub const FOLDERTYPEID_UserFiles = Guid.initString("cd0fc69b-71e2-46e5-9690-5bcd9f57aab3");
pub const FOLDERTYPEID_UsersLibraries = Guid.initString("c4d98f09-6124-4fe0-9942-826416082da9");
pub const FOLDERTYPEID_OtherUsers = Guid.initString("b337fd00-9dd5-4635-a6d4-da33fd102b7a");
pub const FOLDERTYPEID_PublishedItems = Guid.initString("7f2f5b96-ff74-41da-afd8-1c78a5f3aea2");
pub const FOLDERTYPEID_Communications = Guid.initString("91475fe5-586b-4eba-8d75-d17434b8cdf6");
pub const FOLDERTYPEID_Contacts = Guid.initString("de2b70ec-9bf7-4a93-bd3d-243f7881d492");
pub const FOLDERTYPEID_StartMenu = Guid.initString("ef87b4cb-f2ce-4785-8658-4ca6c63e38c6");
pub const FOLDERTYPEID_RecordedTV = Guid.initString("5557a28f-5da6-4f83-8809-c2c98a11a6fa");
pub const FOLDERTYPEID_SavedGames = Guid.initString("d0363307-28cb-4106-9f23-2956e3e5e0e7");
pub const FOLDERTYPEID_OpenSearch = Guid.initString("8faf9629-1980-46ff-8023-9dceab9c3ee3");
pub const FOLDERTYPEID_SearchConnector = Guid.initString("982725ee-6f47-479e-b447-812bfa7d2e8f");
pub const FOLDERTYPEID_AccountPictures = Guid.initString("db2a5d8f-06e6-4007-aba6-af877d526ea6");
pub const FOLDERTYPEID_Games = Guid.initString("b689b0d0-76d3-4cbb-87f7-585d0e0ce070");
pub const FOLDERTYPEID_ControlPanelCategory = Guid.initString("de4f0660-fa10-4b8f-a494-068b20b22307");
pub const FOLDERTYPEID_ControlPanelClassic = Guid.initString("0c3794f3-b545-43aa-a329-c37430c58d2a");
pub const FOLDERTYPEID_Printers = Guid.initString("2c7bbec6-c844-4a0a-91fa-cef6f59cfda1");
pub const FOLDERTYPEID_RecycleBin = Guid.initString("d6d9e004-cd87-442b-9d57-5e0aeb4f6f72");
pub const FOLDERTYPEID_SoftwareExplorer = Guid.initString("d674391b-52d9-4e07-834e-67c98610f39d");
pub const FOLDERTYPEID_CompressedFolder = Guid.initString("80213e82-bcfd-4c4f-8817-bb27601267a9");
pub const FOLDERTYPEID_NetworkExplorer = Guid.initString("25cc242b-9a7c-4f51-80e0-7a2928febe42");
pub const FOLDERTYPEID_Searches = Guid.initString("0b0ba2e3-405f-415e-a6ee-cad625207853");
pub const FOLDERTYPEID_SearchHome = Guid.initString("834d8a44-0974-4ed6-866e-f203d80b3810");
pub const FOLDERTYPEID_StorageProviderGeneric = Guid.initString("4f01ebc5-2385-41f2-a28e-2c5c91fb56e0");
pub const FOLDERTYPEID_StorageProviderDocuments = Guid.initString("dd61bd66-70e8-48dd-9655-65c5e1aac2d1");
pub const FOLDERTYPEID_StorageProviderPictures = Guid.initString("71d642a9-f2b1-42cd-ad92-eb9300c7cc0a");
pub const FOLDERTYPEID_StorageProviderMusic = Guid.initString("672ecd7e-af04-4399-875c-0290845b6247");
pub const FOLDERTYPEID_StorageProviderVideos = Guid.initString("51294da1-d7b1-485b-9e9a-17cffe33e187");
pub const SYNCMGR_OBJECTID_Icon = Guid.initString("6dbc85c3-5d07-4c72-a777-7fec78072c06");
pub const SYNCMGR_OBJECTID_EventStore = Guid.initString("4bef34b9-a786-4075-ba88-0c2b9d89a98f");
pub const SYNCMGR_OBJECTID_ConflictStore = Guid.initString("d78181f4-2389-47e4-a960-60bcc2ed930b");
pub const SYNCMGR_OBJECTID_BrowseContent = Guid.initString("57cbb584-e9b4-47ae-a120-c4df3335dee2");
pub const SYNCMGR_OBJECTID_ShowSchedule = Guid.initString("edc6f3e3-8441-4109-adf3-6c1ca0b7de47");
pub const SYNCMGR_OBJECTID_QueryBeforeActivate = Guid.initString("d882d80b-e7aa-49ed-86b7-e6e1f714cdfe");
pub const SYNCMGR_OBJECTID_QueryBeforeDeactivate = Guid.initString("a0efc282-60e0-460e-9374-ea88513cfc80");
pub const SYNCMGR_OBJECTID_QueryBeforeEnable = Guid.initString("04cbf7f0-5beb-4de1-bc90-908345c480f6");
pub const SYNCMGR_OBJECTID_QueryBeforeDisable = Guid.initString("bb5f64aa-f004-4eb5-8e4d-26751966344c");
pub const SYNCMGR_OBJECTID_QueryBeforeDelete = Guid.initString("f76c3397-afb3-45d7-a59f-5a49e905437e");
pub const SYNCMGR_OBJECTID_EventLinkClick = Guid.initString("2203bdc1-1af1-4082-8c30-28399f41384c");
pub const EP_NavPane = Guid.initString("cb316b22-25f7-42b8-8a09-540d23a43c2f");
pub const EP_Commands = Guid.initString("d9745868-ca5f-4a76-91cd-f5a129fbb076");
pub const EP_Commands_Organize = Guid.initString("72e81700-e3ec-4660-bf24-3c3b7b648806");
pub const EP_Commands_View = Guid.initString("21f7c32d-eeaa-439b-bb51-37b96fd6a943");
pub const EP_DetailsPane = Guid.initString("43abf98b-89b8-472d-b9ce-e69b8229f019");
pub const EP_PreviewPane = Guid.initString("893c63d1-45c8-4d17-be19-223be71be365");
pub const EP_QueryPane = Guid.initString("65bcde4f-4f07-4f27-83a7-1afca4df7ddd");
pub const EP_AdvQueryPane = Guid.initString("b4e9db8b-34ba-4c39-b5cc-16a1bd2c411c");
pub const EP_StatusBar = Guid.initString("65fe56ce-5cfe-4bc4-ad8a-7ae3fe7e8f7c");
pub const EP_Ribbon = Guid.initString("d27524a8-c9f2-4834-a106-df8889fd4f37");
pub const CATID_LocationFactory = Guid.initString("965c4d51-8b76-4e57-80b7-564d2ea4b55e");
pub const CATID_LocationProvider = Guid.initString("1b3ca474-2614-414b-b813-1aceca3e3dd8");
pub const ItemCount_Property_GUID = Guid.initString("abbf5c45-5ccc-47b7-bb4e-87cb87bbd162");
pub const SelectedItemCount_Property_GUID = Guid.initString("8fe316d2-0e52-460a-9c1e-48f273d470a3");
pub const ItemIndex_Property_GUID = Guid.initString("92a053da-2969-4021-bf27-514cfc2e4a69");
pub const CATID_SearchableApplication = Guid.initString("366c292a-d9b3-4dbf-bb70-e62ec3d0bbbf");
pub const IDD_WIZEXTN_FIRST = @as(u32, 20480);
pub const IDD_WIZEXTN_LAST = @as(u32, 20736);
pub const SHPWHF_NORECOMPRESS = @as(u32, 1);
pub const SHPWHF_NONETPLACECREATE = @as(u32, 2);
pub const SHPWHF_NOFILESELECTOR = @as(u32, 4);
pub const SHPWHF_USEMRU = @as(u32, 8);
pub const SHPWHF_ANYLOCATION = @as(u32, 256);
pub const SHPWHF_VALIDATEVIAWEBFOLDERS = @as(u32, 65536);
pub const ACDD_VISIBLE = @as(u32, 1);
pub const SID_SCommandBarState = Guid.initString("b99eaa5c-3850-4400-bc33-2ce534048bf8");
pub const NSTCDHPOS_ONTOP = @as(i32, -1);
pub const FVSIF_RECT = @as(u32, 1);
pub const FVSIF_PINNED = @as(u32, 2);
pub const FVSIF_NEWFAILED = @as(u32, 134217728);
pub const FVSIF_NEWFILE = @as(u32, 2147483648);
pub const FVSIF_CANVIEWIT = @as(u32, 1073741824);
pub const FCIDM_TOOLBAR = @as(u32, 40960);
pub const FCIDM_STATUS = @as(u32, 40961);
pub const IDC_OFFLINE_HAND = @as(u32, 103);
pub const IDC_PANTOOL_HAND_OPEN = @as(u32, 104);
pub const IDC_PANTOOL_HAND_CLOSED = @as(u32, 105);
pub const PANE_NONE = @as(u32, 4294967295);
pub const PANE_ZONE = @as(u32, 1);
pub const PANE_OFFLINE = @as(u32, 2);
pub const PANE_PRINTER = @as(u32, 3);
pub const PANE_SSL = @as(u32, 4);
pub const PANE_NAVIGATION = @as(u32, 5);
pub const PANE_PROGRESS = @as(u32, 6);
pub const PANE_PRIVACY = @as(u32, 7);
pub const DWFRF_NORMAL = @as(u32, 0);
pub const DWFRF_DELETECONFIGDATA = @as(u32, 1);
pub const DWFAF_HIDDEN = @as(u32, 1);
pub const DWFAF_GROUP1 = @as(u32, 2);
pub const DWFAF_GROUP2 = @as(u32, 4);
pub const DWFAF_AUTOHIDE = @as(u32, 16);
pub const SHIMSTCAPFLAG_LOCKABLE = @as(u32, 1);
pub const SHIMSTCAPFLAG_PURGEABLE = @as(u32, 2);
pub const ISFB_MASK_STATE = @as(u32, 1);
pub const ISFB_MASK_BKCOLOR = @as(u32, 2);
pub const ISFB_MASK_VIEWMODE = @as(u32, 4);
pub const ISFB_MASK_SHELLFOLDER = @as(u32, 8);
pub const ISFB_MASK_IDLIST = @as(u32, 16);
pub const ISFB_MASK_COLORS = @as(u32, 32);
pub const ISFB_STATE_DEFAULT = @as(u32, 0);
pub const ISFB_STATE_DEBOSSED = @as(u32, 1);
pub const ISFB_STATE_ALLOWRENAME = @as(u32, 2);
pub const ISFB_STATE_NOSHOWTEXT = @as(u32, 4);
pub const ISFB_STATE_CHANNELBAR = @as(u32, 16);
pub const ISFB_STATE_QLINKSMODE = @as(u32, 32);
pub const ISFB_STATE_FULLOPEN = @as(u32, 64);
pub const ISFB_STATE_NONAMESORT = @as(u32, 128);
pub const ISFB_STATE_BTNMINSIZE = @as(u32, 256);
pub const ISFBVIEWMODE_SMALLICONS = @as(u32, 1);
pub const ISFBVIEWMODE_LARGEICONS = @as(u32, 2);
pub const ISFBVIEWMODE_LOGOS = @as(u32, 3);
pub const DBC_GS_IDEAL = @as(u32, 0);
pub const DBC_GS_SIZEDOWN = @as(u32, 1);
pub const DBC_HIDE = @as(u32, 0);
pub const DBC_SHOW = @as(u32, 1);
pub const DBC_SHOWOBSCURE = @as(u32, 2);
pub const SSM_CLEAR = @as(u32, 0);
pub const SSM_SET = @as(u32, 1);
pub const SSM_REFRESH = @as(u32, 2);
pub const SSM_UPDATE = @as(u32, 4);
pub const SCHEME_DISPLAY = @as(u32, 1);
pub const SCHEME_EDIT = @as(u32, 2);
pub const SCHEME_LOCAL = @as(u32, 4);
pub const SCHEME_GLOBAL = @as(u32, 8);
pub const SCHEME_REFRESH = @as(u32, 16);
pub const SCHEME_UPDATE = @as(u32, 32);
pub const SCHEME_DONOTUSE = @as(u32, 64);
pub const SCHEME_CREATE = @as(u32, 128);
pub const GADOF_DIRTY = @as(u32, 1);
pub const SHCDF_UPDATEITEM = @as(u32, 1);
pub const PPCF_ADDQUOTES = @as(u32, 1);
pub const PPCF_ADDARGUMENTS = @as(u32, 3);
pub const PPCF_NODIRECTORIES = @as(u32, 16);
pub const PPCF_FORCEQUALIFY = @as(u32, 64);
pub const PPCF_LONGESTPOSSIBLE = @as(u32, 128);
pub const OPENPROPS_NONE = @as(u32, 0);
pub const OPENPROPS_INHIBITPIF = @as(u32, 32768);
pub const GETPROPS_NONE = @as(u32, 0);
pub const SETPROPS_NONE = @as(u32, 0);
pub const CLOSEPROPS_NONE = @as(u32, 0);
pub const CLOSEPROPS_DISCARD = @as(u32, 1);
pub const TBIF_APPEND = @as(u32, 0);
pub const TBIF_PREPEND = @as(u32, 1);
pub const TBIF_REPLACE = @as(u32, 2);
pub const TBIF_DEFAULT = @as(u32, 0);
pub const TBIF_INTERNETBAR = @as(u32, 65536);
pub const TBIF_STANDARDTOOLBAR = @as(u32, 131072);
pub const TBIF_NOTOOLBAR = @as(u32, 196608);
pub const SFVM_REARRANGE = @as(u32, 1);
pub const SFVM_ADDOBJECT = @as(u32, 3);
pub const SFVM_REMOVEOBJECT = @as(u32, 6);
pub const SFVM_UPDATEOBJECT = @as(u32, 7);
pub const SFVM_GETSELECTEDOBJECTS = @as(u32, 9);
pub const SFVM_SETITEMPOS = @as(u32, 14);
pub const SFVM_SETCLIPBOARD = @as(u32, 16);
pub const SFVM_SETPOINTS = @as(u32, 23);
pub const GIL_OPENICON = @as(u32, 1);
pub const GIL_FORSHELL = @as(u32, 2);
pub const GIL_ASYNC = @as(u32, 32);
pub const GIL_DEFAULTICON = @as(u32, 64);
pub const GIL_FORSHORTCUT = @as(u32, 128);
pub const GIL_CHECKSHIELD = @as(u32, 512);
pub const GIL_SIMULATEDOC = @as(u32, 1);
pub const GIL_PERINSTANCE = @as(u32, 2);
pub const GIL_PERCLASS = @as(u32, 4);
pub const GIL_NOTFILENAME = @as(u32, 8);
pub const GIL_DONTCACHE = @as(u32, 16);
pub const GIL_SHIELD = @as(u32, 512);
pub const GIL_FORCENOSHIELD = @as(u32, 1024);
pub const SIOM_OVERLAYINDEX = @as(u32, 1);
pub const SIOM_ICONINDEX = @as(u32, 2);
pub const SIOM_RESERVED_SHARED = @as(u32, 0);
pub const SIOM_RESERVED_LINK = @as(u32, 1);
pub const SIOM_RESERVED_SLOWFILE = @as(u32, 2);
pub const SIOM_RESERVED_DEFAULT = @as(u32, 3);
pub const OI_DEFAULT = @as(u32, 0);
pub const OI_ASYNC = @as(u32, 4294962926);
pub const IDO_SHGIOI_SHARE = @as(u32, 268435455);
pub const IDO_SHGIOI_LINK = @as(u32, 268435454);
pub const IDO_SHGIOI_SLOWFILE = @as(u64, 4294967293);
pub const IDO_SHGIOI_DEFAULT = @as(u64, 4294967292);
pub const NT_CONSOLE_PROPS_SIG = @as(u32, 2684354562);
pub const NT_FE_CONSOLE_PROPS_SIG = @as(u32, 2684354564);
pub const EXP_DARWIN_ID_SIG = @as(u32, 2684354566);
pub const EXP_SPECIAL_FOLDER_SIG = @as(u32, 2684354565);
pub const EXP_SZ_LINK_SIG = @as(u32, 2684354561);
pub const EXP_SZ_ICON_SIG = @as(u32, 2684354567);
pub const EXP_PROPERTYSTORAGE_SIG = @as(u32, 2684354569);
pub const FCIDM_SHVIEWFIRST = @as(u32, 0);
pub const FCIDM_SHVIEWLAST = @as(u32, 32767);
pub const FCIDM_BROWSERFIRST = @as(u32, 40960);
pub const FCIDM_BROWSERLAST = @as(u32, 48896);
pub const FCIDM_GLOBALFIRST = @as(u32, 32768);
pub const FCIDM_GLOBALLAST = @as(u32, 40959);
pub const FCIDM_MENU_FILE = @as(u32, 32768);
pub const FCIDM_MENU_EDIT = @as(u32, 32832);
pub const FCIDM_MENU_VIEW = @as(u32, 32896);
pub const FCIDM_MENU_VIEW_SEP_OPTIONS = @as(u32, 32897);
pub const FCIDM_MENU_TOOLS = @as(u32, 32960);
pub const FCIDM_MENU_TOOLS_SEP_GOTO = @as(u32, 32961);
pub const FCIDM_MENU_HELP = @as(u32, 33024);
pub const FCIDM_MENU_FIND = @as(u32, 33088);
pub const FCIDM_MENU_EXPLORE = @as(u32, 33104);
pub const FCIDM_MENU_FAVORITES = @as(u32, 33136);
pub const OFASI_EDIT = @as(u32, 1);
pub const OFASI_OPENDESKTOP = @as(u32, 2);
pub const CSIDL_DESKTOP = @as(u32, 0);
pub const CSIDL_INTERNET = @as(u32, 1);
pub const CSIDL_PROGRAMS = @as(u32, 2);
pub const CSIDL_CONTROLS = @as(u32, 3);
pub const CSIDL_PRINTERS = @as(u32, 4);
pub const CSIDL_PERSONAL = @as(u32, 5);
pub const CSIDL_FAVORITES = @as(u32, 6);
pub const CSIDL_STARTUP = @as(u32, 7);
pub const CSIDL_RECENT = @as(u32, 8);
pub const CSIDL_SENDTO = @as(u32, 9);
pub const CSIDL_BITBUCKET = @as(u32, 10);
pub const CSIDL_STARTMENU = @as(u32, 11);
pub const CSIDL_MYDOCUMENTS = @as(u32, 5);
pub const CSIDL_MYMUSIC = @as(u32, 13);
pub const CSIDL_MYVIDEO = @as(u32, 14);
pub const CSIDL_DESKTOPDIRECTORY = @as(u32, 16);
pub const CSIDL_DRIVES = @as(u32, 17);
pub const CSIDL_NETWORK = @as(u32, 18);
pub const CSIDL_NETHOOD = @as(u32, 19);
pub const CSIDL_FONTS = @as(u32, 20);
pub const CSIDL_TEMPLATES = @as(u32, 21);
pub const CSIDL_COMMON_STARTMENU = @as(u32, 22);
pub const CSIDL_COMMON_PROGRAMS = @as(u32, 23);
pub const CSIDL_COMMON_STARTUP = @as(u32, 24);
pub const CSIDL_COMMON_DESKTOPDIRECTORY = @as(u32, 25);
pub const CSIDL_APPDATA = @as(u32, 26);
pub const CSIDL_PRINTHOOD = @as(u32, 27);
pub const CSIDL_LOCAL_APPDATA = @as(u32, 28);
pub const CSIDL_ALTSTARTUP = @as(u32, 29);
pub const CSIDL_COMMON_ALTSTARTUP = @as(u32, 30);
pub const CSIDL_COMMON_FAVORITES = @as(u32, 31);
pub const CSIDL_INTERNET_CACHE = @as(u32, 32);
pub const CSIDL_COOKIES = @as(u32, 33);
pub const CSIDL_HISTORY = @as(u32, 34);
pub const CSIDL_COMMON_APPDATA = @as(u32, 35);
pub const CSIDL_WINDOWS = @as(u32, 36);
pub const CSIDL_SYSTEM = @as(u32, 37);
pub const CSIDL_PROGRAM_FILES = @as(u32, 38);
pub const CSIDL_MYPICTURES = @as(u32, 39);
pub const CSIDL_PROFILE = @as(u32, 40);
pub const CSIDL_SYSTEMX86 = @as(u32, 41);
pub const CSIDL_PROGRAM_FILESX86 = @as(u32, 42);
pub const CSIDL_PROGRAM_FILES_COMMON = @as(u32, 43);
pub const CSIDL_PROGRAM_FILES_COMMONX86 = @as(u32, 44);
pub const CSIDL_COMMON_TEMPLATES = @as(u32, 45);
pub const CSIDL_COMMON_DOCUMENTS = @as(u32, 46);
pub const CSIDL_COMMON_ADMINTOOLS = @as(u32, 47);
pub const CSIDL_ADMINTOOLS = @as(u32, 48);
pub const CSIDL_CONNECTIONS = @as(u32, 49);
pub const CSIDL_COMMON_MUSIC = @as(u32, 53);
pub const CSIDL_COMMON_PICTURES = @as(u32, 54);
pub const CSIDL_COMMON_VIDEO = @as(u32, 55);
pub const CSIDL_RESOURCES = @as(u32, 56);
pub const CSIDL_RESOURCES_LOCALIZED = @as(u32, 57);
pub const CSIDL_COMMON_OEM_LINKS = @as(u32, 58);
pub const CSIDL_CDBURN_AREA = @as(u32, 59);
pub const CSIDL_COMPUTERSNEARME = @as(u32, 61);
pub const CSIDL_FLAG_CREATE = @as(u32, 32768);
pub const CSIDL_FLAG_DONT_VERIFY = @as(u32, 16384);
pub const CSIDL_FLAG_DONT_UNEXPAND = @as(u32, 8192);
pub const CSIDL_FLAG_NO_ALIAS = @as(u32, 4096);
pub const CSIDL_FLAG_PER_USER_INIT = @as(u32, 2048);
pub const CSIDL_FLAG_MASK = @as(u32, 65280);
pub const FCS_READ = @as(u32, 1);
pub const FCS_FORCEWRITE = @as(u32, 2);
pub const FCS_FLAG_DRAGDROP = @as(u32, 2);
pub const FCSM_VIEWID = @as(u32, 1);
pub const FCSM_WEBVIEWTEMPLATE = @as(u32, 2);
pub const FCSM_INFOTIP = @as(u32, 4);
pub const FCSM_CLSID = @as(u32, 8);
pub const FCSM_ICONFILE = @as(u32, 16);
pub const FCSM_LOGO = @as(u32, 32);
pub const FCSM_FLAGS = @as(u32, 64);
pub const BIF_RETURNONLYFSDIRS = @as(u32, 1);
pub const BIF_DONTGOBELOWDOMAIN = @as(u32, 2);
pub const BIF_STATUSTEXT = @as(u32, 4);
pub const BIF_RETURNFSANCESTORS = @as(u32, 8);
pub const BIF_EDITBOX = @as(u32, 16);
pub const BIF_VALIDATE = @as(u32, 32);
pub const BIF_NEWDIALOGSTYLE = @as(u32, 64);
pub const BIF_BROWSEINCLUDEURLS = @as(u32, 128);
pub const BIF_UAHINT = @as(u32, 256);
pub const BIF_NONEWFOLDERBUTTON = @as(u32, 512);
pub const BIF_NOTRANSLATETARGETS = @as(u32, 1024);
pub const BIF_BROWSEFORCOMPUTER = @as(u32, 4096);
pub const BIF_BROWSEFORPRINTER = @as(u32, 8192);
pub const BIF_BROWSEINCLUDEFILES = @as(u32, 16384);
pub const BIF_SHAREABLE = @as(u32, 32768);
pub const BIF_BROWSEFILEJUNCTIONS = @as(u32, 65536);
pub const BFFM_INITIALIZED = @as(u32, 1);
pub const BFFM_SELCHANGED = @as(u32, 2);
pub const BFFM_VALIDATEFAILEDA = @as(u32, 3);
pub const BFFM_VALIDATEFAILEDW = @as(u32, 4);
pub const BFFM_IUNKNOWN = @as(u32, 5);
pub const BFFM_SETSTATUSTEXTA = @as(u32, 1124);
pub const BFFM_ENABLEOK = @as(u32, 1125);
pub const BFFM_SETSELECTIONA = @as(u32, 1126);
pub const BFFM_SETSELECTIONW = @as(u32, 1127);
pub const BFFM_SETSTATUSTEXTW = @as(u32, 1128);
pub const BFFM_SETOKTEXT = @as(u32, 1129);
pub const BFFM_SETEXPANDED = @as(u32, 1130);
pub const BFFM_SETSTATUSTEXT = @as(u32, 1128);
pub const BFFM_SETSELECTION = @as(u32, 1127);
pub const BFFM_VALIDATEFAILED = @as(u32, 4);
pub const CMDID_INTSHORTCUTCREATE = @as(i32, 1);
pub const PROGDLG_NORMAL = @as(u32, 0);
pub const PROGDLG_MODAL = @as(u32, 1);
pub const PROGDLG_AUTOTIME = @as(u32, 2);
pub const PROGDLG_NOTIME = @as(u32, 4);
pub const PROGDLG_NOMINIMIZE = @as(u32, 8);
pub const PROGDLG_NOPROGRESSBAR = @as(u32, 16);
pub const PROGDLG_MARQUEEPROGRESS = @as(u32, 32);
pub const PROGDLG_NOCANCEL = @as(u32, 64);
pub const PDTIMER_RESET = @as(u32, 1);
pub const PDTIMER_PAUSE = @as(u32, 2);
pub const PDTIMER_RESUME = @as(u32, 3);
pub const COMPONENT_TOP = @as(u32, 1073741823);
pub const COMP_TYPE_HTMLDOC = @as(u32, 0);
pub const COMP_TYPE_PICTURE = @as(u32, 1);
pub const COMP_TYPE_WEBSITE = @as(u32, 2);
pub const COMP_TYPE_CONTROL = @as(u32, 3);
pub const COMP_TYPE_CFHTML = @as(u32, 4);
pub const COMP_TYPE_MAX = @as(u32, 4);
pub const IS_NORMAL = @as(u32, 1);
pub const IS_FULLSCREEN = @as(u32, 2);
pub const IS_SPLIT = @as(u32, 4);
pub const AD_APPLY_SAVE = @as(u32, 1);
pub const AD_APPLY_HTMLGEN = @as(u32, 2);
pub const AD_APPLY_REFRESH = @as(u32, 4);
pub const AD_APPLY_FORCE = @as(u32, 8);
pub const AD_APPLY_BUFFERED_REFRESH = @as(u32, 16);
pub const AD_APPLY_DYNAMICREFRESH = @as(u32, 32);
pub const AD_GETWP_BMP = @as(u32, 0);
pub const AD_GETWP_IMAGE = @as(u32, 1);
pub const AD_GETWP_LAST_APPLIED = @as(u32, 2);
pub const WPSTYLE_CENTER = @as(u32, 0);
pub const WPSTYLE_TILE = @as(u32, 1);
pub const WPSTYLE_STRETCH = @as(u32, 2);
pub const WPSTYLE_KEEPASPECT = @as(u32, 3);
pub const WPSTYLE_CROPTOFIT = @as(u32, 4);
pub const WPSTYLE_SPAN = @as(u32, 5);
pub const WPSTYLE_MAX = @as(u32, 6);
pub const COMP_ELEM_TYPE = @as(u32, 1);
pub const COMP_ELEM_CHECKED = @as(u32, 2);
pub const COMP_ELEM_DIRTY = @as(u32, 4);
pub const COMP_ELEM_NOSCROLL = @as(u32, 8);
pub const COMP_ELEM_POS_LEFT = @as(u32, 16);
pub const COMP_ELEM_POS_TOP = @as(u32, 32);
pub const COMP_ELEM_SIZE_WIDTH = @as(u32, 64);
pub const COMP_ELEM_SIZE_HEIGHT = @as(u32, 128);
pub const COMP_ELEM_POS_ZINDEX = @as(u32, 256);
pub const COMP_ELEM_SOURCE = @as(u32, 512);
pub const COMP_ELEM_FRIENDLYNAME = @as(u32, 1024);
pub const COMP_ELEM_SUBSCRIBEDURL = @as(u32, 2048);
pub const COMP_ELEM_ORIGINAL_CSI = @as(u32, 4096);
pub const COMP_ELEM_RESTORED_CSI = @as(u32, 8192);
pub const COMP_ELEM_CURITEMSTATE = @as(u32, 16384);
pub const ADDURL_SILENT = @as(u32, 1);
pub const COMPONENT_DEFAULT_LEFT = @as(u32, 65535);
pub const COMPONENT_DEFAULT_TOP = @as(u32, 65535);
pub const MAX_COLUMN_NAME_LEN = @as(u32, 80);
pub const MAX_COLUMN_DESC_LEN = @as(u32, 128);
pub const DVASPECT_SHORTNAME = @as(u32, 2);
pub const DVASPECT_COPY = @as(u32, 3);
pub const DVASPECT_LINK = @as(u32, 4);
pub const SHCNEE_ORDERCHANGED = @as(i32, 2);
pub const SHCNEE_MSI_CHANGE = @as(i32, 4);
pub const SHCNEE_MSI_UNINSTALL = @as(i32, 5);
pub const NUM_POINTS = @as(u32, 3);
pub const CABINETSTATE_VERSION = @as(u32, 2);
pub const PIFNAMESIZE = @as(u32, 30);
pub const PIFSTARTLOCSIZE = @as(u32, 63);
pub const PIFDEFPATHSIZE = @as(u32, 64);
pub const PIFPARAMSSIZE = @as(u32, 64);
pub const PIFSHPROGSIZE = @as(u32, 64);
pub const PIFSHDATASIZE = @as(u32, 64);
pub const PIFDEFFILESIZE = @as(u32, 80);
pub const PIFMAXFILEPATH = @as(u32, 260);
pub const QCMINFO_PLACE_BEFORE = @as(u32, 0);
pub const QCMINFO_PLACE_AFTER = @as(u32, 1);
pub const SFVSOC_INVALIDATE_ALL = @as(u32, 1);
pub const SFVSOC_NOSCROLL = @as(u32, 2);
pub const SHELLSTATEVERSION_IE4 = @as(u32, 9);
pub const SHELLSTATEVERSION_WIN2K = @as(u32, 10);
pub const SHPPFW_NONE = @as(u32, 0);
pub const SHPPFW_DIRCREATE = @as(u32, 1);
pub const SHPPFW_ASKDIRCREATE = @as(u32, 2);
pub const SHPPFW_IGNOREFILENAME = @as(u32, 4);
pub const SHPPFW_NOWRITECHECK = @as(u32, 8);
pub const SHPPFW_MEDIACHECKONLY = @as(u32, 16);
pub const CMF_NORMAL = @as(u32, 0);
pub const CMF_DEFAULTONLY = @as(u32, 1);
pub const CMF_VERBSONLY = @as(u32, 2);
pub const CMF_EXPLORE = @as(u32, 4);
pub const CMF_NOVERBS = @as(u32, 8);
pub const CMF_CANRENAME = @as(u32, 16);
pub const CMF_NODEFAULT = @as(u32, 32);
pub const CMF_INCLUDESTATIC = @as(u32, 64);
pub const CMF_ITEMMENU = @as(u32, 128);
pub const CMF_EXTENDEDVERBS = @as(u32, 256);
pub const CMF_DISABLEDVERBS = @as(u32, 512);
pub const CMF_ASYNCVERBSTATE = @as(u32, 1024);
pub const CMF_OPTIMIZEFORINVOKE = @as(u32, 2048);
pub const CMF_SYNCCASCADEMENU = @as(u32, 4096);
pub const CMF_DONOTPICKDEFAULT = @as(u32, 8192);
pub const CMF_RESERVED = @as(u32, 4294901760);
pub const GCS_VERBA = @as(u32, 0);
pub const GCS_HELPTEXTA = @as(u32, 1);
pub const GCS_VALIDATEA = @as(u32, 2);
pub const GCS_VERBW = @as(u32, 4);
pub const GCS_HELPTEXTW = @as(u32, 5);
pub const GCS_VALIDATEW = @as(u32, 6);
pub const GCS_VERBICONW = @as(u32, 20);
pub const GCS_UNICODE = @as(u32, 4);
pub const GCS_VERB = @as(u32, 4);
pub const GCS_HELPTEXT = @as(u32, 5);
pub const GCS_VALIDATE = @as(u32, 6);
pub const CMIC_MASK_SHIFT_DOWN = @as(u32, 268435456);
pub const CMIC_MASK_CONTROL_DOWN = @as(u32, 1073741824);
pub const CMIC_MASK_PTINVOKE = @as(u32, 536870912);
pub const IRTIR_TASK_NOT_RUNNING = @as(u32, 0);
pub const IRTIR_TASK_RUNNING = @as(u32, 1);
pub const IRTIR_TASK_SUSPENDED = @as(u32, 2);
pub const IRTIR_TASK_PENDING = @as(u32, 3);
pub const IRTIR_TASK_FINISHED = @as(u32, 4);
pub const ITSAT_DEFAULT_PRIORITY = @as(u32, 268435456);
pub const ITSAT_MAX_PRIORITY = @as(u32, 2147483647);
pub const ITSAT_MIN_PRIORITY = @as(u32, 0);
pub const ITSSFLAG_COMPLETE_ON_DESTROY = @as(u32, 0);
pub const ITSSFLAG_KILL_ON_DESTROY = @as(u32, 1);
pub const ITSSFLAG_FLAGS_MASK = @as(u32, 3);
pub const CSIDL_FLAG_PFTI_TRACKTARGET = @as(u32, 16384);
pub const SHCIDS_ALLFIELDS = @as(i32, -2147483648);
pub const SHCIDS_CANONICALONLY = @as(i32, 268435456);
pub const SHCIDS_BITMASK = @as(i32, -65536);
pub const SHCIDS_COLUMNMASK = @as(i32, 65535);
pub const SFGAO_CANCOPY = @as(u32, 1);
pub const SFGAO_CANMOVE = @as(u32, 2);
pub const SFGAO_CANLINK = @as(u32, 4);
pub const SFGAO_STORAGE = @as(i32, 8);
pub const SFGAO_CANRENAME = @as(i32, 16);
pub const SFGAO_CANDELETE = @as(i32, 32);
pub const SFGAO_HASPROPSHEET = @as(i32, 64);
pub const SFGAO_DROPTARGET = @as(i32, 256);
pub const SFGAO_CAPABILITYMASK = @as(i32, 375);
pub const SFGAO_PLACEHOLDER = @as(i32, 2048);
pub const SFGAO_SYSTEM = @as(i32, 4096);
pub const SFGAO_ENCRYPTED = @as(i32, 8192);
pub const SFGAO_ISSLOW = @as(i32, 16384);
pub const SFGAO_GHOSTED = @as(i32, 32768);
pub const SFGAO_LINK = @as(i32, 65536);
pub const SFGAO_SHARE = @as(i32, 131072);
pub const SFGAO_READONLY = @as(i32, 262144);
pub const SFGAO_HIDDEN = @as(i32, 524288);
pub const SFGAO_DISPLAYATTRMASK = @as(i32, 1032192);
pub const SFGAO_FILESYSANCESTOR = @as(i32, 268435456);
pub const SFGAO_FOLDER = @as(i32, 536870912);
pub const SFGAO_FILESYSTEM = @as(i32, 1073741824);
pub const SFGAO_HASSUBFOLDER = @as(i32, -2147483648);
pub const SFGAO_CONTENTSMASK = @as(i32, -2147483648);
pub const SFGAO_VALIDATE = @as(i32, 16777216);
pub const SFGAO_REMOVABLE = @as(i32, 33554432);
pub const SFGAO_COMPRESSED = @as(i32, 67108864);
pub const SFGAO_BROWSABLE = @as(i32, 134217728);
pub const SFGAO_NONENUMERATED = @as(i32, 1048576);
pub const SFGAO_NEWCONTENT = @as(i32, 2097152);
pub const SFGAO_CANMONIKER = @as(i32, 4194304);
pub const SFGAO_HASSTORAGE = @as(i32, 4194304);
pub const SFGAO_STREAM = @as(i32, 4194304);
pub const SFGAO_STORAGEANCESTOR = @as(i32, 8388608);
pub const SFGAO_STORAGECAPMASK = @as(i32, 1891958792);
pub const SFGAO_PKEYSFGAOMASK = @as(i32, -2130427904);
pub const BIND_INTERRUPTABLE = @as(u32, 4294967295);
pub const CDBOSC_SETFOCUS = @as(u32, 0);
pub const CDBOSC_KILLFOCUS = @as(u32, 1);
pub const CDBOSC_SELCHANGE = @as(u32, 2);
pub const CDBOSC_RENAME = @as(u32, 3);
pub const CDBOSC_STATECHANGE = @as(u32, 4);
pub const CDB2N_CONTEXTMENU_DONE = @as(u32, 1);
pub const CDB2N_CONTEXTMENU_START = @as(u32, 2);
pub const CDB2GVF_SHOWALLFILES = @as(u32, 1);
pub const CDB2GVF_ISFILESAVE = @as(u32, 2);
pub const CDB2GVF_ALLOWPREVIEWPANE = @as(u32, 4);
pub const CDB2GVF_NOSELECTVERB = @as(u32, 8);
pub const CDB2GVF_NOINCLUDEITEM = @as(u32, 16);
pub const CDB2GVF_ISFOLDERPICKER = @as(u32, 32);
pub const CDB2GVF_ADDSHIELD = @as(u32, 64);
pub const SBSP_DEFBROWSER = @as(u32, 0);
pub const SBSP_SAMEBROWSER = @as(u32, 1);
pub const SBSP_NEWBROWSER = @as(u32, 2);
pub const SBSP_DEFMODE = @as(u32, 0);
pub const SBSP_OPENMODE = @as(u32, 16);
pub const SBSP_EXPLOREMODE = @as(u32, 32);
pub const SBSP_HELPMODE = @as(u32, 64);
pub const SBSP_NOTRANSFERHIST = @as(u32, 128);
pub const SBSP_ABSOLUTE = @as(u32, 0);
pub const SBSP_RELATIVE = @as(u32, 4096);
pub const SBSP_PARENT = @as(u32, 8192);
pub const SBSP_NAVIGATEBACK = @as(u32, 16384);
pub const SBSP_NAVIGATEFORWARD = @as(u32, 32768);
pub const SBSP_ALLOW_AUTONAVIGATE = @as(u32, 65536);
pub const SBSP_KEEPSAMETEMPLATE = @as(u32, 131072);
pub const SBSP_KEEPWORDWHEELTEXT = @as(u32, 262144);
pub const SBSP_ACTIVATE_NOFOCUS = @as(u32, 524288);
pub const SBSP_CREATENOHISTORY = @as(u32, 1048576);
pub const SBSP_PLAYNOSOUND = @as(u32, 2097152);
pub const SBSP_CALLERUNTRUSTED = @as(u32, 8388608);
pub const SBSP_TRUSTFIRSTDOWNLOAD = @as(u32, 16777216);
pub const SBSP_UNTRUSTEDFORDOWNLOAD = @as(u32, 33554432);
pub const SBSP_NOAUTOSELECT = @as(u32, 67108864);
pub const SBSP_WRITENOHISTORY = @as(u32, 134217728);
pub const SBSP_TRUSTEDFORACTIVEX = @as(u32, 268435456);
pub const SBSP_FEEDNAVIGATION = @as(u32, 536870912);
pub const SBSP_REDIRECT = @as(u32, 1073741824);
pub const SBSP_INITIATEDBYHLINKFRAME = @as(u32, 2147483648);
pub const FCW_STATUS = @as(u32, 1);
pub const FCW_TOOLBAR = @as(u32, 2);
pub const FCW_TREE = @as(u32, 3);
pub const FCW_INTERNETBAR = @as(u32, 6);
pub const FCW_PROGRESS = @as(u32, 8);
pub const FCT_MERGE = @as(u32, 1);
pub const FCT_CONFIGABLE = @as(u32, 2);
pub const FCT_ADDTOEND = @as(u32, 4);
pub const ARCONTENT_AUTORUNINF = @as(u32, 2);
pub const ARCONTENT_AUDIOCD = @as(u32, 4);
pub const ARCONTENT_DVDMOVIE = @as(u32, 8);
pub const ARCONTENT_BLANKCD = @as(u32, 16);
pub const ARCONTENT_BLANKDVD = @as(u32, 32);
pub const ARCONTENT_UNKNOWNCONTENT = @as(u32, 64);
pub const ARCONTENT_AUTOPLAYPIX = @as(u32, 128);
pub const ARCONTENT_AUTOPLAYMUSIC = @as(u32, 256);
pub const ARCONTENT_AUTOPLAYVIDEO = @as(u32, 512);
pub const ARCONTENT_VCD = @as(u32, 1024);
pub const ARCONTENT_SVCD = @as(u32, 2048);
pub const ARCONTENT_DVDAUDIO = @as(u32, 4096);
pub const ARCONTENT_BLANKBD = @as(u32, 8192);
pub const ARCONTENT_BLURAY = @as(u32, 16384);
pub const ARCONTENT_CAMERASTORAGE = @as(u32, 32768);
pub const ARCONTENT_CUSTOMEVENT = @as(u32, 65536);
pub const ARCONTENT_NONE = @as(u32, 0);
pub const ARCONTENT_MASK = @as(u32, 131070);
pub const ARCONTENT_PHASE_UNKNOWN = @as(u32, 0);
pub const ARCONTENT_PHASE_PRESNIFF = @as(u32, 268435456);
pub const ARCONTENT_PHASE_SNIFFING = @as(u32, 536870912);
pub const ARCONTENT_PHASE_FINAL = @as(u32, 1073741824);
pub const ARCONTENT_PHASE_MASK = @as(u32, 1879048192);
pub const IEI_PRIORITY_MAX = @as(u32, 2147483647);
pub const IEI_PRIORITY_MIN = @as(u32, 0);
pub const IEIT_PRIORITY_NORMAL = @as(u32, 268435456);
pub const IEIFLAG_ASYNC = @as(u32, 1);
pub const IEIFLAG_CACHE = @as(u32, 2);
pub const IEIFLAG_ASPECT = @as(u32, 4);
pub const IEIFLAG_OFFLINE = @as(u32, 8);
pub const IEIFLAG_GLEAM = @as(u32, 16);
pub const IEIFLAG_SCREEN = @as(u32, 32);
pub const IEIFLAG_ORIGSIZE = @as(u32, 64);
pub const IEIFLAG_NOSTAMP = @as(u32, 128);
pub const IEIFLAG_NOBORDER = @as(u32, 256);
pub const IEIFLAG_QUALITY = @as(u32, 512);
pub const IEIFLAG_REFRESH = @as(u32, 1024);
pub const DBIM_MINSIZE = @as(u32, 1);
pub const DBIM_MAXSIZE = @as(u32, 2);
pub const DBIM_INTEGRAL = @as(u32, 4);
pub const DBIM_ACTUAL = @as(u32, 8);
pub const DBIM_TITLE = @as(u32, 16);
pub const DBIM_MODEFLAGS = @as(u32, 32);
pub const DBIM_BKCOLOR = @as(u32, 64);
pub const DBIMF_NORMAL = @as(u32, 0);
pub const DBIMF_FIXED = @as(u32, 1);
pub const DBIMF_FIXEDBMP = @as(u32, 4);
pub const DBIMF_VARIABLEHEIGHT = @as(u32, 8);
pub const DBIMF_UNDELETEABLE = @as(u32, 16);
pub const DBIMF_DEBOSSED = @as(u32, 32);
pub const DBIMF_BKCOLOR = @as(u32, 64);
pub const DBIMF_USECHEVRON = @as(u32, 128);
pub const DBIMF_BREAK = @as(u32, 256);
pub const DBIMF_ADDTOFRONT = @as(u32, 512);
pub const DBIMF_TOPALIGN = @as(u32, 1024);
pub const DBIMF_NOGRIPPER = @as(u32, 2048);
pub const DBIMF_ALWAYSGRIPPER = @as(u32, 4096);
pub const DBIMF_NOMARGINS = @as(u32, 8192);
pub const DBIF_VIEWMODE_NORMAL = @as(u32, 0);
pub const DBIF_VIEWMODE_VERTICAL = @as(u32, 1);
pub const DBIF_VIEWMODE_FLOATING = @as(u32, 2);
pub const DBIF_VIEWMODE_TRANSPARENT = @as(u32, 4);
pub const DBPC_SELECTFIRST = @as(u32, 4294967295);
pub const THBN_CLICKED = @as(u32, 6144);
pub const FOFX_NOSKIPJUNCTIONS = @as(u32, 65536);
pub const FOFX_PREFERHARDLINK = @as(u32, 131072);
pub const FOFX_SHOWELEVATIONPROMPT = @as(u32, 262144);
pub const FOFX_RECYCLEONDELETE = @as(u32, 524288);
pub const FOFX_EARLYFAILURE = @as(u32, 1048576);
pub const FOFX_PRESERVEFILEEXTENSIONS = @as(u32, 2097152);
pub const FOFX_KEEPNEWERFILE = @as(u32, 4194304);
pub const FOFX_NOCOPYHOOKS = @as(u32, 8388608);
pub const FOFX_NOMINIMIZEBOX = @as(u32, 16777216);
pub const FOFX_MOVEACLSACROSSVOLUMES = @as(u32, 33554432);
pub const FOFX_DONTDISPLAYSOURCEPATH = @as(u32, 67108864);
pub const FOFX_DONTDISPLAYDESTPATH = @as(u32, 134217728);
pub const FOFX_REQUIREELEVATION = @as(u32, 268435456);
pub const FOFX_ADDUNDORECORD = @as(u32, 536870912);
pub const FOFX_COPYASDOWNLOAD = @as(u32, 1073741824);
pub const FOFX_DONTDISPLAYLOCATIONS = @as(u32, 2147483648);
pub const BSIM_STATE = @as(u32, 1);
pub const BSIM_STYLE = @as(u32, 2);
pub const BSSF_VISIBLE = @as(u32, 1);
pub const BSSF_NOTITLE = @as(u32, 2);
pub const BSSF_UNDELETEABLE = @as(u32, 4096);
pub const BSIS_AUTOGRIPPER = @as(u32, 0);
pub const BSIS_NOGRIPPER = @as(u32, 1);
pub const BSIS_ALWAYSGRIPPER = @as(u32, 2);
pub const BSIS_LEFTALIGN = @as(u32, 4);
pub const BSIS_SINGLECLICK = @as(u32, 8);
pub const BSIS_NOCONTEXTMENU = @as(u32, 16);
pub const BSIS_NODROPTARGET = @as(u32, 32);
pub const BSIS_NOCAPTION = @as(u32, 64);
pub const BSIS_PREFERNOLINEBREAK = @as(u32, 128);
pub const BSIS_LOCKED = @as(u32, 256);
pub const BSIS_PRESERVEORDERDURINGLAYOUT = @as(u32, 512);
pub const BSIS_FIXEDORDER = @as(u32, 1024);
pub const OF_CAP_CANSWITCHTO = @as(u32, 1);
pub const OF_CAP_CANCLOSE = @as(u32, 2);
pub const SMDM_SHELLFOLDER = @as(u32, 1);
pub const SMDM_HMENU = @as(u32, 2);
pub const SMDM_TOOLBAR = @as(u32, 4);
pub const SMC_INITMENU = @as(u32, 1);
pub const SMC_CREATE = @as(u32, 2);
pub const SMC_EXITMENU = @as(u32, 3);
pub const SMC_GETINFO = @as(u32, 5);
pub const SMC_GETSFINFO = @as(u32, 6);
pub const SMC_GETOBJECT = @as(u32, 7);
pub const SMC_GETSFOBJECT = @as(u32, 8);
pub const SMC_SFEXEC = @as(u32, 9);
pub const SMC_SFSELECTITEM = @as(u32, 10);
pub const SMC_REFRESH = @as(u32, 16);
pub const SMC_DEMOTE = @as(u32, 17);
pub const SMC_PROMOTE = @as(u32, 18);
pub const SMC_DEFAULTICON = @as(u32, 22);
pub const SMC_NEWITEM = @as(u32, 23);
pub const SMC_CHEVRONEXPAND = @as(u32, 25);
pub const SMC_DISPLAYCHEVRONTIP = @as(u32, 42);
pub const SMC_SETSFOBJECT = @as(u32, 45);
pub const SMC_SHCHANGENOTIFY = @as(u32, 46);
pub const SMC_CHEVRONGETTIP = @as(u32, 47);
pub const SMC_SFDDRESTRICTED = @as(u32, 48);
pub const SMC_SFEXEC_MIDDLE = @as(u32, 49);
pub const SMC_GETAUTOEXPANDSTATE = @as(u32, 65);
pub const SMC_AUTOEXPANDCHANGE = @as(u32, 66);
pub const SMC_GETCONTEXTMENUMODIFIER = @as(u32, 67);
pub const SMC_GETBKCONTEXTMENU = @as(u32, 68);
pub const SMC_OPEN = @as(u32, 69);
pub const SMAE_EXPANDED = @as(u32, 1);
pub const SMAE_CONTRACTED = @as(u32, 2);
pub const SMAE_USER = @as(u32, 4);
pub const SMAE_VALID = @as(u32, 7);
pub const SMINIT_DEFAULT = @as(u32, 0);
pub const SMINIT_RESTRICT_DRAGDROP = @as(u32, 2);
pub const SMINIT_TOPLEVEL = @as(u32, 4);
pub const SMINIT_CACHED = @as(u32, 16);
pub const SMINIT_AUTOEXPAND = @as(u32, 256);
pub const SMINIT_AUTOTOOLTIP = @as(u32, 512);
pub const SMINIT_DROPONCONTAINER = @as(u32, 1024);
pub const SMINIT_VERTICAL = @as(u32, 268435456);
pub const SMINIT_HORIZONTAL = @as(u32, 536870912);
pub const SMSET_TOP = @as(u32, 268435456);
pub const SMSET_BOTTOM = @as(u32, 536870912);
pub const SMSET_DONTOWN = @as(u32, 1);
pub const SMINV_REFRESH = @as(u32, 1);
pub const SMINV_ID = @as(u32, 8);
pub const E_PREVIEWHANDLER_DRM_FAIL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2042494975));
pub const E_PREVIEWHANDLER_NOAUTH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2042494974));
pub const E_PREVIEWHANDLER_NOTFOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2042494973));
pub const E_PREVIEWHANDLER_CORRUPT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2042494972));
pub const SID_URLExecutionContext = Guid.initString("fb5f8ebc-bbb6-4d10-a461-777291a09030");
pub const SID_LaunchSourceViewSizePreference = Guid.initString("80605492-67d9-414f-af89-a1cdf1242bc1");
pub const SID_LaunchTargetViewSizePreference = Guid.initString("26db2472-b7b7-406b-9702-730a4e20d3bf");
pub const SID_LaunchSourceAppUserModelId = Guid.initString("2ce78010-74db-48bc-9c6a-10f372495723");
pub const SID_ShellExecuteNamedPropertyStore = Guid.initString("eb84ada2-00ff-4992-8324-ed5ce061cb29");
pub const ISIOI_ICONFILE = @as(u32, 1);
pub const ISIOI_ICONINDEX = @as(u32, 2);
pub const ABM_NEW = @as(u32, 0);
pub const ABM_REMOVE = @as(u32, 1);
pub const ABM_QUERYPOS = @as(u32, 2);
pub const ABM_SETPOS = @as(u32, 3);
pub const ABM_GETSTATE = @as(u32, 4);
pub const ABM_GETTASKBARPOS = @as(u32, 5);
pub const ABM_ACTIVATE = @as(u32, 6);
pub const ABM_GETAUTOHIDEBAR = @as(u32, 7);
pub const ABM_SETAUTOHIDEBAR = @as(u32, 8);
pub const ABM_WINDOWPOSCHANGED = @as(u32, 9);
pub const ABM_SETSTATE = @as(u32, 10);
pub const ABM_GETAUTOHIDEBAREX = @as(u32, 11);
pub const ABM_SETAUTOHIDEBAREX = @as(u32, 12);
pub const ABN_STATECHANGE = @as(u32, 0);
pub const ABN_POSCHANGED = @as(u32, 1);
pub const ABN_FULLSCREENAPP = @as(u32, 2);
pub const ABN_WINDOWARRANGE = @as(u32, 3);
pub const ABS_AUTOHIDE = @as(u32, 1);
pub const ABS_ALWAYSONTOP = @as(u32, 2);
pub const ABE_LEFT = @as(u32, 0);
pub const ABE_TOP = @as(u32, 1);
pub const ABE_RIGHT = @as(u32, 2);
pub const ABE_BOTTOM = @as(u32, 3);
pub const FO_MOVE = @as(u32, 1);
pub const FO_COPY = @as(u32, 2);
pub const FO_DELETE = @as(u32, 3);
pub const FO_RENAME = @as(u32, 4);
pub const FOF_MULTIDESTFILES = @as(u32, 1);
pub const FOF_CONFIRMMOUSE = @as(u32, 2);
pub const FOF_SILENT = @as(u32, 4);
pub const FOF_RENAMEONCOLLISION = @as(u32, 8);
pub const FOF_NOCONFIRMATION = @as(u32, 16);
pub const FOF_WANTMAPPINGHANDLE = @as(u32, 32);
pub const FOF_ALLOWUNDO = @as(u32, 64);
pub const FOF_FILESONLY = @as(u32, 128);
pub const FOF_SIMPLEPROGRESS = @as(u32, 256);
pub const FOF_NOCONFIRMMKDIR = @as(u32, 512);
pub const FOF_NOERRORUI = @as(u32, 1024);
pub const FOF_NOCOPYSECURITYATTRIBS = @as(u32, 2048);
pub const FOF_NORECURSION = @as(u32, 4096);
pub const FOF_NO_CONNECTED_ELEMENTS = @as(u32, 8192);
pub const FOF_WANTNUKEWARNING = @as(u32, 16384);
pub const FOF_NORECURSEREPARSE = @as(u32, 32768);
pub const PO_DELETE = @as(u32, 19);
pub const PO_RENAME = @as(u32, 20);
pub const PO_PORTCHANGE = @as(u32, 32);
pub const PO_REN_PORT = @as(u32, 52);
pub const SE_ERR_FNF = @as(u32, 2);
pub const SE_ERR_PNF = @as(u32, 3);
pub const SE_ERR_ACCESSDENIED = @as(u32, 5);
pub const SE_ERR_OOM = @as(u32, 8);
pub const SE_ERR_DLLNOTFOUND = @as(u32, 32);
pub const SE_ERR_SHARE = @as(u32, 26);
pub const SE_ERR_ASSOCINCOMPLETE = @as(u32, 27);
pub const SE_ERR_DDETIMEOUT = @as(u32, 28);
pub const SE_ERR_DDEFAIL = @as(u32, 29);
pub const SE_ERR_DDEBUSY = @as(u32, 30);
pub const SE_ERR_NOASSOC = @as(u32, 31);
pub const SEE_MASK_DEFAULT = @as(u32, 0);
pub const SEE_MASK_CLASSNAME = @as(u32, 1);
pub const SEE_MASK_CLASSKEY = @as(u32, 3);
pub const SEE_MASK_IDLIST = @as(u32, 4);
pub const SEE_MASK_INVOKEIDLIST = @as(u32, 12);
pub const SEE_MASK_ICON = @as(u32, 16);
pub const SEE_MASK_HOTKEY = @as(u32, 32);
pub const SEE_MASK_NOCLOSEPROCESS = @as(u32, 64);
pub const SEE_MASK_CONNECTNETDRV = @as(u32, 128);
pub const SEE_MASK_NOASYNC = @as(u32, 256);
pub const SEE_MASK_FLAG_DDEWAIT = @as(u32, 256);
pub const SEE_MASK_DOENVSUBST = @as(u32, 512);
pub const SEE_MASK_FLAG_NO_UI = @as(u32, 1024);
pub const SEE_MASK_UNICODE = @as(u32, 16384);
pub const SEE_MASK_NO_CONSOLE = @as(u32, 32768);
pub const SEE_MASK_ASYNCOK = @as(u32, 1048576);
pub const SEE_MASK_HMONITOR = @as(u32, 2097152);
pub const SEE_MASK_NOZONECHECKS = @as(u32, 8388608);
pub const SEE_MASK_NOQUERYCLASSSTORE = @as(u32, 16777216);
pub const SEE_MASK_WAITFORINPUTIDLE = @as(u32, 33554432);
pub const SEE_MASK_FLAG_LOG_USAGE = @as(u32, 67108864);
pub const SEE_MASK_FLAG_HINST_IS_SITE = @as(u32, 134217728);
pub const SHERB_NOCONFIRMATION = @as(u32, 1);
pub const SHERB_NOPROGRESSUI = @as(u32, 2);
pub const SHERB_NOSOUND = @as(u32, 4);
pub const NIN_SELECT = @as(u32, 1024);
pub const NINF_KEY = @as(u32, 1);
pub const NIN_BALLOONSHOW = @as(u32, 1026);
pub const NIN_BALLOONHIDE = @as(u32, 1027);
pub const NIN_BALLOONTIMEOUT = @as(u32, 1028);
pub const NIN_BALLOONUSERCLICK = @as(u32, 1029);
pub const NIN_POPUPOPEN = @as(u32, 1030);
pub const NIN_POPUPCLOSE = @as(u32, 1031);
pub const NOTIFYICON_VERSION = @as(u32, 3);
pub const NOTIFYICON_VERSION_4 = @as(u32, 4);
pub const NIS_HIDDEN = @as(u32, 1);
pub const NIS_SHAREDICON = @as(u32, 2);
pub const NIIF_NONE = @as(u32, 0);
pub const NIIF_INFO = @as(u32, 1);
pub const NIIF_WARNING = @as(u32, 2);
pub const NIIF_ERROR = @as(u32, 3);
pub const NIIF_USER = @as(u32, 4);
pub const NIIF_ICON_MASK = @as(u32, 15);
pub const NIIF_NOSOUND = @as(u32, 16);
pub const NIIF_LARGE_ICON = @as(u32, 32);
pub const NIIF_RESPECT_QUIET_TIME = @as(u32, 128);
pub const SHGSI_ICONLOCATION = @as(u32, 0);
pub const SHGNLI_PIDL = @as(u64, 1);
pub const SHGNLI_PREFIXNAME = @as(u64, 2);
pub const SHGNLI_NOUNIQUE = @as(u64, 4);
pub const SHGNLI_NOLNK = @as(u64, 8);
pub const SHGNLI_NOLOCNAME = @as(u64, 16);
pub const SHGNLI_USEURLEXT = @as(u64, 32);
pub const PRINTACTION_OPEN = @as(u32, 0);
pub const PRINTACTION_PROPERTIES = @as(u32, 1);
pub const PRINTACTION_NETINSTALL = @as(u32, 2);
pub const PRINTACTION_NETINSTALLLINK = @as(u32, 3);
pub const PRINTACTION_TESTPAGE = @as(u32, 4);
pub const PRINTACTION_OPENNETPRN = @as(u32, 5);
pub const PRINTACTION_DOCUMENTDEFAULTS = @as(u32, 6);
pub const PRINTACTION_SERVERPROPERTIES = @as(u32, 7);
pub const PRINT_PROP_FORCE_NAME = @as(u32, 1);
pub const OFFLINE_STATUS_LOCAL = @as(u32, 1);
pub const OFFLINE_STATUS_REMOTE = @as(u32, 2);
pub const OFFLINE_STATUS_INCOMPLETE = @as(u32, 4);
pub const SHIL_LARGE = @as(u32, 0);
pub const SHIL_SMALL = @as(u32, 1);
pub const SHIL_EXTRALARGE = @as(u32, 2);
pub const SHIL_SYSSMALL = @as(u32, 3);
pub const SHIL_JUMBO = @as(u32, 4);
pub const SHIL_LAST = @as(u32, 4);
pub const NCM_GETADDRESS = @as(u32, 1025);
pub const NCM_SETALLOWTYPE = @as(u32, 1026);
pub const NCM_GETALLOWTYPE = @as(u32, 1027);
pub const NCM_DISPLAYERRORTIP = @as(u32, 1028);
pub const CREDENTIAL_PROVIDER_NO_DEFAULT = @as(u32, 4294967295);
pub const Identity_LocalUserProvider = Guid.initString("a198529b-730f-4089-b646-a12557f5665e");
pub const MAX_SYNCMGR_ID = @as(u32, 64);
pub const MAX_SYNCMGR_PROGRESSTEXT = @as(u32, 260);
pub const MAX_SYNCMGR_NAME = @as(u32, 128);
pub const STIF_DEFAULT = @as(i32, 0);
pub const STIF_SUPPORT_HEX = @as(i32, 1);
pub const GCT_INVALID = @as(u32, 0);
pub const GCT_LFNCHAR = @as(u32, 1);
pub const GCT_SHORTCHAR = @as(u32, 2);
pub const GCT_WILD = @as(u32, 4);
pub const GCT_SEPARATOR = @as(u32, 8);
pub const PMSF_NORMAL = @as(u32, 0);
pub const PMSF_MULTIPLE = @as(u32, 1);
pub const PMSF_DONT_STRIP_SPACES = @as(u32, 65536);
pub const URL_UNESCAPE = @as(u32, 268435456);
pub const URL_ESCAPE_UNSAFE = @as(u32, 536870912);
pub const URL_PLUGGABLE_PROTOCOL = @as(u32, 1073741824);
pub const URL_WININET_COMPATIBILITY = @as(u32, 2147483648);
pub const URL_DONT_ESCAPE_EXTRA_INFO = @as(u32, 33554432);
pub const URL_DONT_UNESCAPE_EXTRA_INFO = @as(u32, 33554432);
pub const URL_BROWSER_MODE = @as(u32, 33554432);
pub const URL_ESCAPE_SPACES_ONLY = @as(u32, 67108864);
pub const URL_DONT_SIMPLIFY = @as(u32, 134217728);
pub const URL_NO_META = @as(u32, 134217728);
pub const URL_UNESCAPE_INPLACE = @as(u32, 1048576);
pub const URL_CONVERT_IF_DOSPATH = @as(u32, 2097152);
pub const URL_UNESCAPE_HIGH_ANSI_ONLY = @as(u32, 4194304);
pub const URL_INTERNAL_PATH = @as(u32, 8388608);
pub const URL_FILE_USE_PATHURL = @as(u32, 65536);
pub const URL_DONT_UNESCAPE = @as(u32, 131072);
pub const URL_ESCAPE_AS_UTF8 = @as(u32, 262144);
pub const URL_UNESCAPE_AS_UTF8 = @as(u32, 262144);
pub const URL_ESCAPE_ASCII_URI_COMPONENT = @as(u32, 524288);
pub const URL_UNESCAPE_URI_COMPONENT = @as(u32, 262144);
pub const URL_ESCAPE_PERCENT = @as(u32, 4096);
pub const URL_ESCAPE_SEGMENT_ONLY = @as(u32, 8192);
pub const URL_PARTFLAG_KEEPSCHEME = @as(u32, 1);
pub const URL_APPLY_DEFAULT = @as(u32, 1);
pub const URL_APPLY_GUESSSCHEME = @as(u32, 2);
pub const URL_APPLY_GUESSFILE = @as(u32, 4);
pub const URL_APPLY_FORCEAPPLY = @as(u32, 8);
pub const SRRF_RT_REG_NONE = @as(u32, 1);
pub const SRRF_RT_REG_SZ = @as(u32, 2);
pub const SRRF_RT_REG_EXPAND_SZ = @as(u32, 4);
pub const SRRF_RT_REG_BINARY = @as(u32, 8);
pub const SRRF_RT_REG_DWORD = @as(u32, 16);
pub const SRRF_RT_REG_MULTI_SZ = @as(u32, 32);
pub const SRRF_RT_REG_QWORD = @as(u32, 64);
pub const SRRF_RT_ANY = @as(u32, 65535);
pub const SRRF_RM_ANY = @as(u32, 0);
pub const SRRF_RM_NORMAL = @as(u32, 65536);
pub const SRRF_RM_SAFE = @as(u32, 131072);
pub const SRRF_RM_SAFENETWORK = @as(u32, 262144);
pub const SRRF_NOEXPAND = @as(u32, 268435456);
pub const SRRF_ZEROONFAILURE = @as(u32, 536870912);
pub const SRRF_NOVIRT = @as(u32, 1073741824);
pub const SHREGSET_HKCU = @as(u32, 1);
pub const SHREGSET_FORCE_HKCU = @as(u32, 2);
pub const SHREGSET_HKLM = @as(u32, 4);
pub const SHREGSET_FORCE_HKLM = @as(u32, 8);
pub const SPMODE_SHELL = @as(u32, 1);
pub const SPMODE_DEBUGOUT = @as(u32, 2);
pub const SPMODE_TEST = @as(u32, 4);
pub const SPMODE_BROWSER = @as(u32, 8);
pub const SPMODE_FLUSH = @as(u32, 16);
pub const SPMODE_EVENT = @as(u32, 32);
pub const SPMODE_MSVM = @as(u32, 64);
pub const SPMODE_FORMATTEXT = @as(u32, 128);
pub const SPMODE_PROFILE = @as(u32, 256);
pub const SPMODE_DEBUGBREAK = @as(u32, 512);
pub const SPMODE_MSGTRACE = @as(u32, 1024);
pub const SPMODE_PERFTAGS = @as(u32, 2048);
pub const SPMODE_MEMWATCH = @as(u32, 4096);
pub const SPMODE_DBMON = @as(u32, 8192);
pub const SPMODE_MULTISTOP = @as(u32, 16384);
pub const SPMODE_EVENTTRACE = @as(u32, 32768);
pub const SHGVSPB_PERUSER = @as(u32, 1);
pub const SHGVSPB_ALLUSERS = @as(u32, 2);
pub const SHGVSPB_PERFOLDER = @as(u32, 4);
pub const SHGVSPB_ALLFOLDERS = @as(u32, 8);
pub const SHGVSPB_INHERIT = @as(u32, 16);
pub const SHGVSPB_ROAM = @as(u32, 32);
pub const SHGVSPB_NOAUTODEFAULTS = @as(u32, 2147483648);
pub const FDTF_SHORTTIME = @as(u32, 1);
pub const FDTF_SHORTDATE = @as(u32, 2);
pub const FDTF_LONGDATE = @as(u32, 4);
pub const FDTF_LONGTIME = @as(u32, 8);
pub const FDTF_RELATIVE = @as(u32, 16);
pub const FDTF_LTRDATE = @as(u32, 256);
pub const FDTF_RTLDATE = @as(u32, 512);
pub const FDTF_NOAUTOREADINGORDER = @as(u32, 1024);
pub const PLATFORM_UNKNOWN = @as(u32, 0);
pub const PLATFORM_IE3 = @as(u32, 1);
pub const PLATFORM_BROWSERONLY = @as(u32, 1);
pub const PLATFORM_INTEGRATED = @as(u32, 2);
pub const ILMM_IE4 = @as(u32, 0);
pub const SHACF_DEFAULT = @as(u32, 0);
pub const SHACF_FILESYSTEM = @as(u32, 1);
pub const SHACF_URLHISTORY = @as(u32, 2);
pub const SHACF_URLMRU = @as(u32, 4);
pub const SHACF_USETAB = @as(u32, 8);
pub const SHACF_FILESYS_ONLY = @as(u32, 16);
pub const SHACF_FILESYS_DIRS = @as(u32, 32);
pub const SHACF_VIRTUAL_NAMESPACE = @as(u32, 64);
pub const SHACF_AUTOSUGGEST_FORCE_ON = @as(u32, 268435456);
pub const SHACF_AUTOSUGGEST_FORCE_OFF = @as(u32, 536870912);
pub const SHACF_AUTOAPPEND_FORCE_ON = @as(u32, 1073741824);
pub const SHACF_AUTOAPPEND_FORCE_OFF = @as(u32, 2147483648);
pub const DLLVER_PLATFORM_WINDOWS = @as(u32, 1);
pub const DLLVER_PLATFORM_NT = @as(u32, 2);
pub const DLLVER_MAJOR_MASK = @as(u64, 18446462598732840960);
pub const DLLVER_MINOR_MASK = @as(u64, 281470681743360);
pub const DLLVER_BUILD_MASK = @as(u64, 4294901760);
pub const DLLVER_QFE_MASK = @as(u64, 65535);
pub const WTS_E_FAILEDEXTRACTION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147175936));
pub const WTS_E_EXTRACTIONTIMEDOUT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147175935));
pub const WTS_E_SURROGATEUNAVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147175934));
pub const WTS_E_FASTEXTRACTIONNOTSUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147175933));
pub const WTS_E_DATAFILEUNAVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147175932));
pub const WTS_E_EXTRACTIONPENDING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147175931));
pub const WTS_E_EXTRACTIONBLOCKED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147175930));
pub const WTS_E_NOSTORAGEPROVIDERTHUMBNAILHANDLER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147175929));
pub const SHIMGDEC_DEFAULT = @as(u32, 0);
pub const SHIMGDEC_THUMBNAIL = @as(u32, 1);
pub const SHIMGDEC_LOADFULL = @as(u32, 2);
pub const E_NOTVALIDFORANIMATEDIMAGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221503));
pub const S_SYNCMGR_MISSINGITEMS = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262657));
pub const S_SYNCMGR_RETRYSYNC = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262658));
pub const S_SYNCMGR_CANCELITEM = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262659));
pub const S_SYNCMGR_CANCELALL = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262660));
pub const S_SYNCMGR_ITEMDELETED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262672));
pub const S_SYNCMGR_ENUMITEMS = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262673));
pub const SYNCMGRPROGRESSITEM_STATUSTEXT = @as(u32, 1);
pub const SYNCMGRPROGRESSITEM_STATUSTYPE = @as(u32, 2);
pub const SYNCMGRPROGRESSITEM_PROGVALUE = @as(u32, 4);
pub const SYNCMGRPROGRESSITEM_MAXVALUE = @as(u32, 8);
pub const SYNCMGRLOGERROR_ERRORFLAGS = @as(u32, 1);
pub const SYNCMGRLOGERROR_ERRORID = @as(u32, 2);
pub const SYNCMGRLOGERROR_ITEMID = @as(u32, 4);
pub const SYNCMGRITEM_ITEMFLAGMASK = @as(u32, 127);
pub const MAX_SYNCMGRITEMNAME = @as(u32, 128);
pub const SYNCMGRHANDLERFLAG_MASK = @as(u32, 15);
pub const MAX_SYNCMGRHANDLERNAME = @as(u32, 32);
pub const SYNCMGRREGISTERFLAGS_MASK = @as(u32, 7);
pub const TLOG_BACK = @as(i32, -1);
pub const TLOG_CURRENT = @as(u32, 0);
pub const TLOG_FORE = @as(u32, 1);
pub const TLMENUF_INCLUDECURRENT = @as(u32, 1);
pub const TLMENUF_BACK = @as(u32, 16);
pub const TLMENUF_FORE = @as(u32, 32);
pub const BSF_REGISTERASDROPTARGET = @as(u32, 1);
pub const BSF_THEATERMODE = @as(u32, 2);
pub const BSF_NOLOCALFILEWARNING = @as(u32, 16);
pub const BSF_UISETBYAUTOMATION = @as(u32, 256);
pub const BSF_RESIZABLE = @as(u32, 512);
pub const BSF_CANMAXIMIZE = @as(u32, 1024);
pub const BSF_TOPBROWSER = @as(u32, 2048);
pub const BSF_NAVNOHISTORY = @as(u32, 4096);
pub const BSF_HTMLNAVCANCELED = @as(u32, 8192);
pub const BSF_DONTSHOWNAVCANCELPAGE = @as(u32, 16384);
pub const BSF_SETNAVIGATABLECODEPAGE = @as(u32, 32768);
pub const BSF_DELEGATEDNAVIGATION = @as(u32, 65536);
pub const BSF_TRUSTEDFORACTIVEX = @as(u32, 131072);
pub const BSF_MERGEDMENUS = @as(u32, 262144);
pub const BSF_FEEDNAVIGATION = @as(u32, 524288);
pub const BSF_FEEDSUBSCRIBED = @as(u32, 1048576);
pub const HLNF_CALLERUNTRUSTED = @as(u32, 2097152);
pub const HLNF_TRUSTEDFORACTIVEX = @as(u32, 4194304);
pub const HLNF_DISABLEWINDOWRESTRICTIONS = @as(u32, 8388608);
pub const HLNF_TRUSTFIRSTDOWNLOAD = @as(u32, 16777216);
pub const HLNF_UNTRUSTEDFORDOWNLOAD = @as(u32, 33554432);
pub const SHHLNF_NOAUTOSELECT = @as(u32, 67108864);
pub const SHHLNF_WRITENOHISTORY = @as(u32, 134217728);
pub const HLNF_EXTERNALNAVIGATE = @as(u32, 268435456);
pub const HLNF_ALLOW_AUTONAVIGATE = @as(u32, 536870912);
pub const HLNF_NEWWINDOWSMANAGED = @as(u32, 2147483648);
pub const INTERNET_MAX_PATH_LENGTH = @as(u32, 2048);
pub const INTERNET_MAX_SCHEME_LENGTH = @as(u32, 32);
pub const VIEW_PRIORITY_RESTRICTED = @as(u32, 112);
pub const VIEW_PRIORITY_CACHEHIT = @as(u32, 80);
pub const VIEW_PRIORITY_STALECACHEHIT = @as(u32, 69);
pub const VIEW_PRIORITY_USEASDEFAULT = @as(u32, 67);
pub const VIEW_PRIORITY_SHELLEXT = @as(u32, 64);
pub const VIEW_PRIORITY_CACHEMISS = @as(u32, 48);
pub const VIEW_PRIORITY_INHERIT = @as(u32, 32);
pub const VIEW_PRIORITY_SHELLEXT_ASBACKUP = @as(u32, 21);
pub const VIEW_PRIORITY_DESPERATE = @as(u32, 16);
pub const VIEW_PRIORITY_NONE = @as(u32, 0);
pub const PATHCCH_MAX_CCH = @as(u32, 32768);
pub const IDS_DESCRIPTION = @as(u32, 1);
pub const ID_APP = @as(u32, 100);
pub const DLG_SCRNSAVECONFIGURE = @as(u32, 2003);
pub const MAXFILELEN = @as(u32, 13);
pub const TITLEBARNAMELEN = @as(u32, 40);
pub const APPNAMEBUFFERLEN = @as(u32, 40);
pub const BUFFLEN = @as(u32, 255);
pub const SCRM_VERIFYPW = @as(u32, 32768);
pub const E_FLAGS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217408));
pub const IS_E_EXEC_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147213310));
pub const URL_E_INVALID_SYNTAX = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217407));
pub const URL_E_UNREGISTERED_PROTOCOL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217406));
pub const CPLPAGE_MOUSE_BUTTONS = @as(u32, 1);
pub const CPLPAGE_MOUSE_PTRMOTION = @as(u32, 2);
pub const CPLPAGE_MOUSE_WHEEL = @as(u32, 3);
pub const CPLPAGE_KEYBOARD_SPEED = @as(u32, 1);
pub const CPLPAGE_DISPLAY_BACKGROUND = @as(u32, 1);
pub const DISPID_SELECTIONCHANGED = @as(u32, 200);
pub const DISPID_FILELISTENUMDONE = @as(u32, 201);
pub const DISPID_VERBINVOKED = @as(u32, 202);
pub const DISPID_DEFAULTVERBINVOKED = @as(u32, 203);
pub const DISPID_BEGINDRAG = @as(u32, 204);
pub const DISPID_VIEWMODECHANGED = @as(u32, 205);
pub const DISPID_NOITEMSTATE_CHANGED = @as(u32, 206);
pub const DISPID_CONTENTSCHANGED = @as(u32, 207);
pub const DISPID_FOCUSCHANGED = @as(u32, 208);
pub const DISPID_CHECKSTATECHANGED = @as(u32, 209);
pub const DISPID_ORDERCHANGED = @as(u32, 210);
pub const DISPID_VIEWPAINTDONE = @as(u32, 211);
pub const DISPID_COLUMNSCHANGED = @as(u32, 212);
pub const DISPID_CTRLMOUSEWHEEL = @as(u32, 213);
pub const DISPID_SORTDONE = @as(u32, 214);
pub const DISPID_ICONSIZECHANGED = @as(u32, 215);
pub const DISPID_FOLDERCHANGED = @as(u32, 217);
pub const DISPID_FILTERINVOKED = @as(u32, 218);
pub const DISPID_WORDWHEELEDITED = @as(u32, 219);
pub const DISPID_SELECTEDITEMCHANGED = @as(u32, 220);
pub const DISPID_EXPLORERWINDOWREADY = @as(u32, 221);
pub const DISPID_UPDATEIMAGE = @as(u32, 222);
pub const DISPID_INITIALENUMERATIONDONE = @as(u32, 223);
pub const DISPID_ENTERPRISEIDCHANGED = @as(u32, 224);
pub const DISPID_ENTERPRESSED = @as(u32, 200);
pub const DISPID_SEARCHCOMMAND_START = @as(u32, 1);
pub const DISPID_SEARCHCOMMAND_COMPLETE = @as(u32, 2);
pub const DISPID_SEARCHCOMMAND_ABORT = @as(u32, 3);
pub const DISPID_SEARCHCOMMAND_UPDATE = @as(u32, 4);
pub const DISPID_SEARCHCOMMAND_PROGRESSTEXT = @as(u32, 5);
pub const DISPID_SEARCHCOMMAND_ERROR = @as(u32, 6);
pub const DISPID_SEARCHCOMMAND_RESTORE = @as(u32, 7);
pub const DISPID_IADCCTL_DIRTY = @as(u32, 256);
pub const DISPID_IADCCTL_PUBCAT = @as(u32, 257);
pub const DISPID_IADCCTL_SORT = @as(u32, 258);
pub const DISPID_IADCCTL_FORCEX86 = @as(u32, 259);
pub const DISPID_IADCCTL_SHOWPOSTSETUP = @as(u32, 260);
pub const DISPID_IADCCTL_ONDOMAIN = @as(u32, 261);
pub const DISPID_IADCCTL_DEFAULTCAT = @as(u32, 262);
pub const COPYENGINE_S_YES = @import("../zig.zig").typedConst(HRESULT, @as(i32, 2555905));
pub const COPYENGINE_S_NOT_HANDLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 2555907));
pub const COPYENGINE_S_USER_RETRY = @import("../zig.zig").typedConst(HRESULT, @as(i32, 2555908));
pub const COPYENGINE_S_USER_IGNORED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 2555909));
pub const COPYENGINE_S_MERGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, 2555910));
pub const COPYENGINE_S_DONT_PROCESS_CHILDREN = @import("../zig.zig").typedConst(HRESULT, @as(i32, 2555912));
pub const COPYENGINE_S_ALREADY_DONE = @import("../zig.zig").typedConst(HRESULT, @as(i32, 2555914));
pub const COPYENGINE_S_PENDING = @import("../zig.zig").typedConst(HRESULT, @as(i32, 2555915));
pub const COPYENGINE_S_KEEP_BOTH = @import("../zig.zig").typedConst(HRESULT, @as(i32, 2555916));
pub const COPYENGINE_S_CLOSE_PROGRAM = @import("../zig.zig").typedConst(HRESULT, @as(i32, 2555917));
pub const COPYENGINE_S_COLLISIONRESOLVED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 2555918));
pub const COPYENGINE_S_PROGRESS_PAUSE = @import("../zig.zig").typedConst(HRESULT, @as(i32, 2555919));
pub const COPYENGINE_E_USER_CANCELLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927744));
pub const COPYENGINE_E_CANCELLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927743));
pub const COPYENGINE_E_REQUIRES_ELEVATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927742));
pub const COPYENGINE_E_SAME_FILE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927741));
pub const COPYENGINE_E_DIFF_DIR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927740));
pub const COPYENGINE_E_MANY_SRC_1_DEST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927739));
pub const COPYENGINE_E_DEST_SUBTREE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927735));
pub const COPYENGINE_E_DEST_SAME_TREE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927734));
pub const COPYENGINE_E_FLD_IS_FILE_DEST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927733));
pub const COPYENGINE_E_FILE_IS_FLD_DEST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927732));
pub const COPYENGINE_E_FILE_TOO_LARGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927731));
pub const COPYENGINE_E_REMOVABLE_FULL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927730));
pub const COPYENGINE_E_DEST_IS_RO_CD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927729));
pub const COPYENGINE_E_DEST_IS_RW_CD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927728));
pub const COPYENGINE_E_DEST_IS_R_CD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927727));
pub const COPYENGINE_E_DEST_IS_RO_DVD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927726));
pub const COPYENGINE_E_DEST_IS_RW_DVD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927725));
pub const COPYENGINE_E_DEST_IS_R_DVD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927724));
pub const COPYENGINE_E_SRC_IS_RO_CD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927723));
pub const COPYENGINE_E_SRC_IS_RW_CD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927722));
pub const COPYENGINE_E_SRC_IS_R_CD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927721));
pub const COPYENGINE_E_SRC_IS_RO_DVD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927720));
pub const COPYENGINE_E_SRC_IS_RW_DVD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927719));
pub const COPYENGINE_E_SRC_IS_R_DVD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927718));
pub const COPYENGINE_E_INVALID_FILES_SRC = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927717));
pub const COPYENGINE_E_INVALID_FILES_DEST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927716));
pub const COPYENGINE_E_PATH_TOO_DEEP_SRC = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927715));
pub const COPYENGINE_E_PATH_TOO_DEEP_DEST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927714));
pub const COPYENGINE_E_ROOT_DIR_SRC = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927713));
pub const COPYENGINE_E_ROOT_DIR_DEST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927712));
pub const COPYENGINE_E_ACCESS_DENIED_SRC = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927711));
pub const COPYENGINE_E_ACCESS_DENIED_DEST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927710));
pub const COPYENGINE_E_PATH_NOT_FOUND_SRC = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927709));
pub const COPYENGINE_E_PATH_NOT_FOUND_DEST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927708));
pub const COPYENGINE_E_NET_DISCONNECT_SRC = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927707));
pub const COPYENGINE_E_NET_DISCONNECT_DEST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927706));
pub const COPYENGINE_E_SHARING_VIOLATION_SRC = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927705));
pub const COPYENGINE_E_SHARING_VIOLATION_DEST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927704));
pub const COPYENGINE_E_ALREADY_EXISTS_NORMAL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927703));
pub const COPYENGINE_E_ALREADY_EXISTS_READONLY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927702));
pub const COPYENGINE_E_ALREADY_EXISTS_SYSTEM = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927701));
pub const COPYENGINE_E_ALREADY_EXISTS_FOLDER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927700));
pub const COPYENGINE_E_STREAM_LOSS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927699));
pub const COPYENGINE_E_EA_LOSS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927698));
pub const COPYENGINE_E_PROPERTY_LOSS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927697));
pub const COPYENGINE_E_PROPERTIES_LOSS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927696));
pub const COPYENGINE_E_ENCRYPTION_LOSS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927695));
pub const COPYENGINE_E_DISK_FULL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927694));
pub const COPYENGINE_E_DISK_FULL_CLEAN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927693));
pub const COPYENGINE_E_EA_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927692));
pub const COPYENGINE_E_CANT_REACH_SOURCE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927691));
pub const COPYENGINE_E_RECYCLE_UNKNOWN_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927691));
pub const COPYENGINE_E_RECYCLE_FORCE_NUKE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927690));
pub const COPYENGINE_E_RECYCLE_SIZE_TOO_BIG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927689));
pub const COPYENGINE_E_RECYCLE_PATH_TOO_LONG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927688));
pub const COPYENGINE_E_RECYCLE_BIN_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927686));
pub const COPYENGINE_E_NEWFILE_NAME_TOO_LONG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927685));
pub const COPYENGINE_E_NEWFOLDER_NAME_TOO_LONG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927684));
pub const COPYENGINE_E_DIR_NOT_EMPTY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927683));
pub const COPYENGINE_E_FAT_MAX_IN_ROOT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927682));
pub const COPYENGINE_E_ACCESSDENIED_READONLY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927681));
pub const COPYENGINE_E_REDIRECTED_TO_WEBPAGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927680));
pub const COPYENGINE_E_SERVER_BAD_FILE_TYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927679));
pub const COPYENGINE_E_INTERNET_ITEM_UNAVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927678));
pub const COPYENGINE_E_CANNOT_MOVE_FROM_RECYCLE_BIN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927677));
pub const COPYENGINE_E_CANNOT_MOVE_SHARED_FOLDER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927676));
pub const COPYENGINE_E_INTERNET_ITEM_STORAGE_PROVIDER_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927675));
pub const COPYENGINE_E_INTERNET_ITEM_STORAGE_PROVIDER_PAUSED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927674));
pub const COPYENGINE_E_REQUIRES_EDP_CONSENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927673));
pub const COPYENGINE_E_BLOCKED_BY_EDP_POLICY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927672));
pub const COPYENGINE_E_REQUIRES_EDP_CONSENT_FOR_REMOVABLE_DRIVE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927671));
pub const COPYENGINE_E_BLOCKED_BY_EDP_FOR_REMOVABLE_DRIVE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927670));
pub const COPYENGINE_E_RMS_REQUIRES_EDP_CONSENT_FOR_REMOVABLE_DRIVE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927669));
pub const COPYENGINE_E_RMS_BLOCKED_BY_EDP_FOR_REMOVABLE_DRIVE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927668));
pub const COPYENGINE_E_WARNED_BY_DLP_POLICY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927667));
pub const COPYENGINE_E_BLOCKED_BY_DLP_POLICY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927666));
pub const COPYENGINE_E_SILENT_FAIL_BY_DLP_POLICY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927665));
pub const NETCACHE_E_NEGATIVE_CACHE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927488));
pub const EXECUTE_E_LAUNCH_APPLICATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927487));
pub const SHELL_E_WRONG_BITDEPTH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927486));
pub const LINK_E_DELETE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927485));
pub const STORE_E_NEWER_VERSION_AVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927484));
pub const E_FILE_PLACEHOLDER_NOT_INITIALIZED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927472));
pub const E_FILE_PLACEHOLDER_VERSION_MISMATCH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927471));
pub const E_FILE_PLACEHOLDER_SERVER_TIMED_OUT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927470));
pub const E_FILE_PLACEHOLDER_STORAGEPROVIDER_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927469));
pub const CAMERAROLL_E_NO_DOWNSAMPLING_REQUIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927456));
pub const E_ACTIVATIONDENIED_USERCLOSE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927440));
pub const E_ACTIVATIONDENIED_SHELLERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927439));
pub const E_ACTIVATIONDENIED_SHELLRESTART = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927438));
pub const E_ACTIVATIONDENIED_UNEXPECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927437));
pub const E_ACTIVATIONDENIED_SHELLNOTREADY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927436));
pub const LIBRARY_E_NO_SAVE_LOCATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927232));
pub const LIBRARY_E_NO_ACCESSIBLE_LOCATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927231));
pub const E_USERTILE_UNSUPPORTEDFILETYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927216));
pub const E_USERTILE_CHANGEDISABLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927215));
pub const E_USERTILE_LARGEORDYNAMIC = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927214));
pub const E_USERTILE_VIDEOFRAMESIZE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927213));
pub const E_USERTILE_FILESIZE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927212));
pub const IMM_ACC_DOCKING_E_INSUFFICIENTHEIGHT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927184));
pub const IMM_ACC_DOCKING_E_DOCKOCCUPIED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927183));
pub const IMSC_E_SHELL_COMPONENT_STARTUP_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927181));
pub const SHC_E_SHELL_COMPONENT_STARTUP_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927180));
pub const E_TILE_NOTIFICATIONS_PLATFORM_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927159));
pub const E_SHELL_EXTENSION_BLOCKED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144926975));
pub const E_IMAGEFEED_CHANGEDISABLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144926960));
pub const GPFIDL_DEFAULT = @as(i32, 0);
pub const GPFIDL_ALTNAME = @as(i32, 1);
pub const GPFIDL_UNCPRINTER = @as(i32, 2);
pub const ISHCUTCMDID_DOWNLOADICON = @as(i32, 0);
pub const ISHCUTCMDID_INTSHORTCUTCREATE = @as(i32, 1);
pub const ISHCUTCMDID_COMMITHISTORY = @as(i32, 2);
pub const ISHCUTCMDID_SETUSERAWURL = @as(i32, 3);
pub const SFBID_PIDLCHANGED = @as(i32, 0);
pub const DBCID_EMPTY = @as(i32, 0);
pub const DBCID_ONDRAG = @as(i32, 1);
pub const DBCID_CLSIDOFBAR = @as(i32, 2);
pub const DBCID_RESIZE = @as(i32, 3);
pub const DBCID_GETBAR = @as(i32, 4);
pub const DBCID_UPDATESIZE = @as(i32, 5);
pub const BMICON_LARGE = @as(i32, 0);
pub const BMICON_SMALL = @as(i32, 1);
pub const ASSOCF_NONE = @as(i32, 0);
pub const ASSOCF_INIT_NOREMAPCLSID = @as(i32, 1);
pub const ASSOCF_INIT_BYEXENAME = @as(i32, 2);
pub const ASSOCF_OPEN_BYEXENAME = @as(i32, 2);
pub const ASSOCF_INIT_DEFAULTTOSTAR = @as(i32, 4);
pub const ASSOCF_INIT_DEFAULTTOFOLDER = @as(i32, 8);
pub const ASSOCF_NOUSERSETTINGS = @as(i32, 16);
pub const ASSOCF_NOTRUNCATE = @as(i32, 32);
pub const ASSOCF_VERIFY = @as(i32, 64);
pub const ASSOCF_REMAPRUNDLL = @as(i32, 128);
pub const ASSOCF_NOFIXUPS = @as(i32, 256);
pub const ASSOCF_IGNOREBASECLASS = @as(i32, 512);
pub const ASSOCF_INIT_IGNOREUNKNOWN = @as(i32, 1024);
pub const ASSOCF_INIT_FIXED_PROGID = @as(i32, 2048);
pub const ASSOCF_IS_PROTOCOL = @as(i32, 4096);
pub const ASSOCF_INIT_FOR_FILE = @as(i32, 8192);
pub const ASSOCF_IS_FULL_URI = @as(i32, 16384);
pub const ASSOCF_PER_MACHINE_ONLY = @as(i32, 32768);
pub const ASSOCF_APP_TO_APP = @as(i32, 65536);
pub const CTF_INSIST = @as(i32, 1);
pub const CTF_THREAD_REF = @as(i32, 2);
pub const CTF_PROCESS_REF = @as(i32, 4);
pub const CTF_COINIT_STA = @as(i32, 8);
pub const CTF_COINIT = @as(i32, 8);
pub const CTF_FREELIBANDEXIT = @as(i32, 16);
pub const CTF_REF_COUNTED = @as(i32, 32);
pub const CTF_WAIT_ALLOWCOM = @as(i32, 64);
pub const CTF_UNUSED = @as(i32, 128);
pub const CTF_INHERITWOW64 = @as(i32, 256);
pub const CTF_WAIT_NO_REENTRANCY = @as(i32, 512);
pub const CTF_KEYBOARD_LOCALE = @as(i32, 1024);
pub const CTF_OLEINITIALIZE = @as(i32, 2048);
pub const CTF_COINIT_MTA = @as(i32, 4096);
pub const CTF_NOADDREFLIB = @as(i32, 8192);

//--------------------------------------------------------------------------------
// Section: Types (966)
//--------------------------------------------------------------------------------
pub const SHGFI_FLAGS = enum(i32) {
    ADDOVERLAYS = 32,
    ATTR_SPECIFIED = 131072,
    ATTRIBUTES = 2048,
    DISPLAYNAME = 512,
    EXETYPE = 8192,
    ICON = 256,
    ICONLOCATION = 4096,
    LARGEICON = 0,
    LINKOVERLAY = 32768,
    OPENICON = 2,
    OVERLAYINDEX = 64,
    PIDL = 8,
    SELECTED = 65536,
    SHELLICONSIZE = 4,
    SMALLICON = 1,
    SYSICONINDEX = 16384,
    TYPENAME = 1024,
    USEFILEATTRIBUTES = 16,
    _,
    pub fn initFlags(o: struct {
        ADDOVERLAYS: u1 = 0,
        ATTR_SPECIFIED: u1 = 0,
        ATTRIBUTES: u1 = 0,
        DISPLAYNAME: u1 = 0,
        EXETYPE: u1 = 0,
        ICON: u1 = 0,
        ICONLOCATION: u1 = 0,
        LARGEICON: u1 = 0,
        LINKOVERLAY: u1 = 0,
        OPENICON: u1 = 0,
        OVERLAYINDEX: u1 = 0,
        PIDL: u1 = 0,
        SELECTED: u1 = 0,
        SHELLICONSIZE: u1 = 0,
        SMALLICON: u1 = 0,
        SYSICONINDEX: u1 = 0,
        TYPENAME: u1 = 0,
        USEFILEATTRIBUTES: u1 = 0,
    }) SHGFI_FLAGS {
        return @as(SHGFI_FLAGS, @enumFromInt((if (o.ADDOVERLAYS == 1) @intFromEnum(SHGFI_FLAGS.ADDOVERLAYS) else 0) | (if (o.ATTR_SPECIFIED == 1) @intFromEnum(SHGFI_FLAGS.ATTR_SPECIFIED) else 0) | (if (o.ATTRIBUTES == 1) @intFromEnum(SHGFI_FLAGS.ATTRIBUTES) else 0) | (if (o.DISPLAYNAME == 1) @intFromEnum(SHGFI_FLAGS.DISPLAYNAME) else 0) | (if (o.EXETYPE == 1) @intFromEnum(SHGFI_FLAGS.EXETYPE) else 0) | (if (o.ICON == 1) @intFromEnum(SHGFI_FLAGS.ICON) else 0) | (if (o.ICONLOCATION == 1) @intFromEnum(SHGFI_FLAGS.ICONLOCATION) else 0) | (if (o.LARGEICON == 1) @intFromEnum(SHGFI_FLAGS.LARGEICON) else 0) | (if (o.LINKOVERLAY == 1) @intFromEnum(SHGFI_FLAGS.LINKOVERLAY) else 0) | (if (o.OPENICON == 1) @intFromEnum(SHGFI_FLAGS.OPENICON) else 0) | (if (o.OVERLAYINDEX == 1) @intFromEnum(SHGFI_FLAGS.OVERLAYINDEX) else 0) | (if (o.PIDL == 1) @intFromEnum(SHGFI_FLAGS.PIDL) else 0) | (if (o.SELECTED == 1) @intFromEnum(SHGFI_FLAGS.SELECTED) else 0) | (if (o.SHELLICONSIZE == 1) @intFromEnum(SHGFI_FLAGS.SHELLICONSIZE) else 0) | (if (o.SMALLICON == 1) @intFromEnum(SHGFI_FLAGS.SMALLICON) else 0) | (if (o.SYSICONINDEX == 1) @intFromEnum(SHGFI_FLAGS.SYSICONINDEX) else 0) | (if (o.TYPENAME == 1) @intFromEnum(SHGFI_FLAGS.TYPENAME) else 0) | (if (o.USEFILEATTRIBUTES == 1) @intFromEnum(SHGFI_FLAGS.USEFILEATTRIBUTES) else 0)));
    }
};
pub const SHGFI_ADDOVERLAYS = SHGFI_FLAGS.ADDOVERLAYS;
pub const SHGFI_ATTR_SPECIFIED = SHGFI_FLAGS.ATTR_SPECIFIED;
pub const SHGFI_ATTRIBUTES = SHGFI_FLAGS.ATTRIBUTES;
pub const SHGFI_DISPLAYNAME = SHGFI_FLAGS.DISPLAYNAME;
pub const SHGFI_EXETYPE = SHGFI_FLAGS.EXETYPE;
pub const SHGFI_ICON = SHGFI_FLAGS.ICON;
pub const SHGFI_ICONLOCATION = SHGFI_FLAGS.ICONLOCATION;
pub const SHGFI_LARGEICON = SHGFI_FLAGS.LARGEICON;
pub const SHGFI_LINKOVERLAY = SHGFI_FLAGS.LINKOVERLAY;
pub const SHGFI_OPENICON = SHGFI_FLAGS.OPENICON;
pub const SHGFI_OVERLAYINDEX = SHGFI_FLAGS.OVERLAYINDEX;
pub const SHGFI_PIDL = SHGFI_FLAGS.PIDL;
pub const SHGFI_SELECTED = SHGFI_FLAGS.SELECTED;
pub const SHGFI_SHELLICONSIZE = SHGFI_FLAGS.SHELLICONSIZE;
pub const SHGFI_SMALLICON = SHGFI_FLAGS.SMALLICON;
pub const SHGFI_SYSICONINDEX = SHGFI_FLAGS.SYSICONINDEX;
pub const SHGFI_TYPENAME = SHGFI_FLAGS.TYPENAME;
pub const SHGFI_USEFILEATTRIBUTES = SHGFI_FLAGS.USEFILEATTRIBUTES;

pub const SHCNE_ID = enum(u32) {
    RENAMEITEM = 1,
    CREATE = 2,
    DELETE = 4,
    MKDIR = 8,
    RMDIR = 16,
    MEDIAINSERTED = 32,
    MEDIAREMOVED = 64,
    DRIVEREMOVED = 128,
    DRIVEADD = 256,
    NETSHARE = 512,
    NETUNSHARE = 1024,
    ATTRIBUTES = 2048,
    UPDATEDIR = 4096,
    UPDATEITEM = 8192,
    SERVERDISCONNECT = 16384,
    UPDATEIMAGE = 32768,
    DRIVEADDGUI = 65536,
    RENAMEFOLDER = 131072,
    FREESPACE = 262144,
    EXTENDED_EVENT = 67108864,
    ASSOCCHANGED = 134217728,
    DISKEVENTS = 145439,
    GLOBALEVENTS = 201687520,
    ALLEVENTS = 2147483647,
    INTERRUPT = 2147483648,
    _,
    pub fn initFlags(o: struct {
        RENAMEITEM: u1 = 0,
        CREATE: u1 = 0,
        DELETE: u1 = 0,
        MKDIR: u1 = 0,
        RMDIR: u1 = 0,
        MEDIAINSERTED: u1 = 0,
        MEDIAREMOVED: u1 = 0,
        DRIVEREMOVED: u1 = 0,
        DRIVEADD: u1 = 0,
        NETSHARE: u1 = 0,
        NETUNSHARE: u1 = 0,
        ATTRIBUTES: u1 = 0,
        UPDATEDIR: u1 = 0,
        UPDATEITEM: u1 = 0,
        SERVERDISCONNECT: u1 = 0,
        UPDATEIMAGE: u1 = 0,
        DRIVEADDGUI: u1 = 0,
        RENAMEFOLDER: u1 = 0,
        FREESPACE: u1 = 0,
        EXTENDED_EVENT: u1 = 0,
        ASSOCCHANGED: u1 = 0,
        DISKEVENTS: u1 = 0,
        GLOBALEVENTS: u1 = 0,
        ALLEVENTS: u1 = 0,
        INTERRUPT: u1 = 0,
    }) SHCNE_ID {
        return @as(SHCNE_ID, @enumFromInt((if (o.RENAMEITEM == 1) @intFromEnum(SHCNE_ID.RENAMEITEM) else 0) | (if (o.CREATE == 1) @intFromEnum(SHCNE_ID.CREATE) else 0) | (if (o.DELETE == 1) @intFromEnum(SHCNE_ID.DELETE) else 0) | (if (o.MKDIR == 1) @intFromEnum(SHCNE_ID.MKDIR) else 0) | (if (o.RMDIR == 1) @intFromEnum(SHCNE_ID.RMDIR) else 0) | (if (o.MEDIAINSERTED == 1) @intFromEnum(SHCNE_ID.MEDIAINSERTED) else 0) | (if (o.MEDIAREMOVED == 1) @intFromEnum(SHCNE_ID.MEDIAREMOVED) else 0) | (if (o.DRIVEREMOVED == 1) @intFromEnum(SHCNE_ID.DRIVEREMOVED) else 0) | (if (o.DRIVEADD == 1) @intFromEnum(SHCNE_ID.DRIVEADD) else 0) | (if (o.NETSHARE == 1) @intFromEnum(SHCNE_ID.NETSHARE) else 0) | (if (o.NETUNSHARE == 1) @intFromEnum(SHCNE_ID.NETUNSHARE) else 0) | (if (o.ATTRIBUTES == 1) @intFromEnum(SHCNE_ID.ATTRIBUTES) else 0) | (if (o.UPDATEDIR == 1) @intFromEnum(SHCNE_ID.UPDATEDIR) else 0) | (if (o.UPDATEITEM == 1) @intFromEnum(SHCNE_ID.UPDATEITEM) else 0) | (if (o.SERVERDISCONNECT == 1) @intFromEnum(SHCNE_ID.SERVERDISCONNECT) else 0) | (if (o.UPDATEIMAGE == 1) @intFromEnum(SHCNE_ID.UPDATEIMAGE) else 0) | (if (o.DRIVEADDGUI == 1) @intFromEnum(SHCNE_ID.DRIVEADDGUI) else 0) | (if (o.RENAMEFOLDER == 1) @intFromEnum(SHCNE_ID.RENAMEFOLDER) else 0) | (if (o.FREESPACE == 1) @intFromEnum(SHCNE_ID.FREESPACE) else 0) | (if (o.EXTENDED_EVENT == 1) @intFromEnum(SHCNE_ID.EXTENDED_EVENT) else 0) | (if (o.ASSOCCHANGED == 1) @intFromEnum(SHCNE_ID.ASSOCCHANGED) else 0) | (if (o.DISKEVENTS == 1) @intFromEnum(SHCNE_ID.DISKEVENTS) else 0) | (if (o.GLOBALEVENTS == 1) @intFromEnum(SHCNE_ID.GLOBALEVENTS) else 0) | (if (o.ALLEVENTS == 1) @intFromEnum(SHCNE_ID.ALLEVENTS) else 0) | (if (o.INTERRUPT == 1) @intFromEnum(SHCNE_ID.INTERRUPT) else 0)));
    }
};
pub const SHCNE_RENAMEITEM = SHCNE_ID.RENAMEITEM;
pub const SHCNE_CREATE = SHCNE_ID.CREATE;
pub const SHCNE_DELETE = SHCNE_ID.DELETE;
pub const SHCNE_MKDIR = SHCNE_ID.MKDIR;
pub const SHCNE_RMDIR = SHCNE_ID.RMDIR;
pub const SHCNE_MEDIAINSERTED = SHCNE_ID.MEDIAINSERTED;
pub const SHCNE_MEDIAREMOVED = SHCNE_ID.MEDIAREMOVED;
pub const SHCNE_DRIVEREMOVED = SHCNE_ID.DRIVEREMOVED;
pub const SHCNE_DRIVEADD = SHCNE_ID.DRIVEADD;
pub const SHCNE_NETSHARE = SHCNE_ID.NETSHARE;
pub const SHCNE_NETUNSHARE = SHCNE_ID.NETUNSHARE;
pub const SHCNE_ATTRIBUTES = SHCNE_ID.ATTRIBUTES;
pub const SHCNE_UPDATEDIR = SHCNE_ID.UPDATEDIR;
pub const SHCNE_UPDATEITEM = SHCNE_ID.UPDATEITEM;
pub const SHCNE_SERVERDISCONNECT = SHCNE_ID.SERVERDISCONNECT;
pub const SHCNE_UPDATEIMAGE = SHCNE_ID.UPDATEIMAGE;
pub const SHCNE_DRIVEADDGUI = SHCNE_ID.DRIVEADDGUI;
pub const SHCNE_RENAMEFOLDER = SHCNE_ID.RENAMEFOLDER;
pub const SHCNE_FREESPACE = SHCNE_ID.FREESPACE;
pub const SHCNE_EXTENDED_EVENT = SHCNE_ID.EXTENDED_EVENT;
pub const SHCNE_ASSOCCHANGED = SHCNE_ID.ASSOCCHANGED;
pub const SHCNE_DISKEVENTS = SHCNE_ID.DISKEVENTS;
pub const SHCNE_GLOBALEVENTS = SHCNE_ID.GLOBALEVENTS;
pub const SHCNE_ALLEVENTS = SHCNE_ID.ALLEVENTS;
pub const SHCNE_INTERRUPT = SHCNE_ID.INTERRUPT;

pub const SHCNRF_SOURCE = enum(i32) {
    InterruptLevel = 1,
    ShellLevel = 2,
    RecursiveInterrupt = 4096,
    NewDelivery = 32768,
    _,
    pub fn initFlags(o: struct {
        InterruptLevel: u1 = 0,
        ShellLevel: u1 = 0,
        RecursiveInterrupt: u1 = 0,
        NewDelivery: u1 = 0,
    }) SHCNRF_SOURCE {
        return @as(SHCNRF_SOURCE, @enumFromInt((if (o.InterruptLevel == 1) @intFromEnum(SHCNRF_SOURCE.InterruptLevel) else 0) | (if (o.ShellLevel == 1) @intFromEnum(SHCNRF_SOURCE.ShellLevel) else 0) | (if (o.RecursiveInterrupt == 1) @intFromEnum(SHCNRF_SOURCE.RecursiveInterrupt) else 0) | (if (o.NewDelivery == 1) @intFromEnum(SHCNRF_SOURCE.NewDelivery) else 0)));
    }
};
pub const SHCNRF_InterruptLevel = SHCNRF_SOURCE.InterruptLevel;
pub const SHCNRF_ShellLevel = SHCNRF_SOURCE.ShellLevel;
pub const SHCNRF_RecursiveInterrupt = SHCNRF_SOURCE.RecursiveInterrupt;
pub const SHCNRF_NewDelivery = SHCNRF_SOURCE.NewDelivery;

pub const SHCNF_FLAGS = enum(u32) {
    IDLIST = 0,
    PATHA = 1,
    PRINTERA = 2,
    DWORD = 3,
    PATHW = 5,
    PRINTERW = 6,
    TYPE = 255,
    FLUSH = 4096,
    FLUSHNOWAIT = 12288,
    NOTIFYRECURSIVE = 65536,
    // PATH = 5, this enum value conflicts with PATHW
    // PRINTER = 6, this enum value conflicts with PRINTERW
    _,
    pub fn initFlags(o: struct {
        IDLIST: u1 = 0,
        PATHA: u1 = 0,
        PRINTERA: u1 = 0,
        DWORD: u1 = 0,
        PATHW: u1 = 0,
        PRINTERW: u1 = 0,
        TYPE: u1 = 0,
        FLUSH: u1 = 0,
        FLUSHNOWAIT: u1 = 0,
        NOTIFYRECURSIVE: u1 = 0,
    }) SHCNF_FLAGS {
        return @as(SHCNF_FLAGS, @enumFromInt((if (o.IDLIST == 1) @intFromEnum(SHCNF_FLAGS.IDLIST) else 0) | (if (o.PATHA == 1) @intFromEnum(SHCNF_FLAGS.PATHA) else 0) | (if (o.PRINTERA == 1) @intFromEnum(SHCNF_FLAGS.PRINTERA) else 0) | (if (o.DWORD == 1) @intFromEnum(SHCNF_FLAGS.DWORD) else 0) | (if (o.PATHW == 1) @intFromEnum(SHCNF_FLAGS.PATHW) else 0) | (if (o.PRINTERW == 1) @intFromEnum(SHCNF_FLAGS.PRINTERW) else 0) | (if (o.TYPE == 1) @intFromEnum(SHCNF_FLAGS.TYPE) else 0) | (if (o.FLUSH == 1) @intFromEnum(SHCNF_FLAGS.FLUSH) else 0) | (if (o.FLUSHNOWAIT == 1) @intFromEnum(SHCNF_FLAGS.FLUSHNOWAIT) else 0) | (if (o.NOTIFYRECURSIVE == 1) @intFromEnum(SHCNF_FLAGS.NOTIFYRECURSIVE) else 0)));
    }
};
pub const SHCNF_IDLIST = SHCNF_FLAGS.IDLIST;
pub const SHCNF_PATHA = SHCNF_FLAGS.PATHA;
pub const SHCNF_PRINTERA = SHCNF_FLAGS.PRINTERA;
pub const SHCNF_DWORD = SHCNF_FLAGS.DWORD;
pub const SHCNF_PATHW = SHCNF_FLAGS.PATHW;
pub const SHCNF_PRINTERW = SHCNF_FLAGS.PRINTERW;
pub const SHCNF_TYPE = SHCNF_FLAGS.TYPE;
pub const SHCNF_FLUSH = SHCNF_FLAGS.FLUSH;
pub const SHCNF_FLUSHNOWAIT = SHCNF_FLAGS.FLUSHNOWAIT;
pub const SHCNF_NOTIFYRECURSIVE = SHCNF_FLAGS.NOTIFYRECURSIVE;
pub const SHCNF_PATH = SHCNF_FLAGS.PATHW;
pub const SHCNF_PRINTER = SHCNF_FLAGS.PRINTERW;

pub const QITIPF_FLAGS = enum(i32) {
    TIPF_DEFAULT = 0,
    TIPF_USENAME = 1,
    TIPF_LINKNOTARGET = 2,
    TIPF_LINKUSETARGET = 4,
    TIPF_USESLOWTIP = 8,
    TIPF_SINGLELINE = 16,
    // F_CACHED = 1, this enum value conflicts with TIPF_USENAME
    // F_DONTEXPANDFOLDER = 2, this enum value conflicts with TIPF_LINKNOTARGET
    _,
    pub fn initFlags(o: struct {
        TIPF_DEFAULT: u1 = 0,
        TIPF_USENAME: u1 = 0,
        TIPF_LINKNOTARGET: u1 = 0,
        TIPF_LINKUSETARGET: u1 = 0,
        TIPF_USESLOWTIP: u1 = 0,
        TIPF_SINGLELINE: u1 = 0,
    }) QITIPF_FLAGS {
        return @as(QITIPF_FLAGS, @enumFromInt((if (o.TIPF_DEFAULT == 1) @intFromEnum(QITIPF_FLAGS.TIPF_DEFAULT) else 0) | (if (o.TIPF_USENAME == 1) @intFromEnum(QITIPF_FLAGS.TIPF_USENAME) else 0) | (if (o.TIPF_LINKNOTARGET == 1) @intFromEnum(QITIPF_FLAGS.TIPF_LINKNOTARGET) else 0) | (if (o.TIPF_LINKUSETARGET == 1) @intFromEnum(QITIPF_FLAGS.TIPF_LINKUSETARGET) else 0) | (if (o.TIPF_USESLOWTIP == 1) @intFromEnum(QITIPF_FLAGS.TIPF_USESLOWTIP) else 0) | (if (o.TIPF_SINGLELINE == 1) @intFromEnum(QITIPF_FLAGS.TIPF_SINGLELINE) else 0)));
    }
};
pub const QITIPF_DEFAULT = QITIPF_FLAGS.TIPF_DEFAULT;
pub const QITIPF_USENAME = QITIPF_FLAGS.TIPF_USENAME;
pub const QITIPF_LINKNOTARGET = QITIPF_FLAGS.TIPF_LINKNOTARGET;
pub const QITIPF_LINKUSETARGET = QITIPF_FLAGS.TIPF_LINKUSETARGET;
pub const QITIPF_USESLOWTIP = QITIPF_FLAGS.TIPF_USESLOWTIP;
pub const QITIPF_SINGLELINE = QITIPF_FLAGS.TIPF_SINGLELINE;
pub const QIF_CACHED = QITIPF_FLAGS.TIPF_USENAME;
pub const QIF_DONTEXPANDFOLDER = QITIPF_FLAGS.TIPF_LINKNOTARGET;

pub const SHDID_ID = enum(i32) {
    ROOT_REGITEM = 1,
    FS_FILE = 2,
    FS_DIRECTORY = 3,
    FS_OTHER = 4,
    COMPUTER_DRIVE35 = 5,
    COMPUTER_DRIVE525 = 6,
    COMPUTER_REMOVABLE = 7,
    COMPUTER_FIXED = 8,
    COMPUTER_NETDRIVE = 9,
    COMPUTER_CDROM = 10,
    COMPUTER_RAMDISK = 11,
    COMPUTER_OTHER = 12,
    NET_DOMAIN = 13,
    NET_SERVER = 14,
    NET_SHARE = 15,
    NET_RESTOFNET = 16,
    NET_OTHER = 17,
    COMPUTER_IMAGING = 18,
    COMPUTER_AUDIO = 19,
    COMPUTER_SHAREDDOCS = 20,
    MOBILE_DEVICE = 21,
    REMOTE_DESKTOP_DRIVE = 22,
};
pub const SHDID_ROOT_REGITEM = SHDID_ID.ROOT_REGITEM;
pub const SHDID_FS_FILE = SHDID_ID.FS_FILE;
pub const SHDID_FS_DIRECTORY = SHDID_ID.FS_DIRECTORY;
pub const SHDID_FS_OTHER = SHDID_ID.FS_OTHER;
pub const SHDID_COMPUTER_DRIVE35 = SHDID_ID.COMPUTER_DRIVE35;
pub const SHDID_COMPUTER_DRIVE525 = SHDID_ID.COMPUTER_DRIVE525;
pub const SHDID_COMPUTER_REMOVABLE = SHDID_ID.COMPUTER_REMOVABLE;
pub const SHDID_COMPUTER_FIXED = SHDID_ID.COMPUTER_FIXED;
pub const SHDID_COMPUTER_NETDRIVE = SHDID_ID.COMPUTER_NETDRIVE;
pub const SHDID_COMPUTER_CDROM = SHDID_ID.COMPUTER_CDROM;
pub const SHDID_COMPUTER_RAMDISK = SHDID_ID.COMPUTER_RAMDISK;
pub const SHDID_COMPUTER_OTHER = SHDID_ID.COMPUTER_OTHER;
pub const SHDID_NET_DOMAIN = SHDID_ID.NET_DOMAIN;
pub const SHDID_NET_SERVER = SHDID_ID.NET_SERVER;
pub const SHDID_NET_SHARE = SHDID_ID.NET_SHARE;
pub const SHDID_NET_RESTOFNET = SHDID_ID.NET_RESTOFNET;
pub const SHDID_NET_OTHER = SHDID_ID.NET_OTHER;
pub const SHDID_COMPUTER_IMAGING = SHDID_ID.COMPUTER_IMAGING;
pub const SHDID_COMPUTER_AUDIO = SHDID_ID.COMPUTER_AUDIO;
pub const SHDID_COMPUTER_SHAREDDOCS = SHDID_ID.COMPUTER_SHAREDDOCS;
pub const SHDID_MOBILE_DEVICE = SHDID_ID.MOBILE_DEVICE;
pub const SHDID_REMOTE_DESKTOP_DRIVE = SHDID_ID.REMOTE_DESKTOP_DRIVE;

pub const SHGDFIL_FORMAT = enum(i32) {
    FINDDATA = 1,
    NETRESOURCE = 2,
    DESCRIPTIONID = 3,
};
pub const SHGDFIL_FINDDATA = SHGDFIL_FORMAT.FINDDATA;
pub const SHGDFIL_NETRESOURCE = SHGDFIL_FORMAT.NETRESOURCE;
pub const SHGDFIL_DESCRIPTIONID = SHGDFIL_FORMAT.DESCRIPTIONID;

pub const PRF_FLAGS = enum(i32) {
    VERIFYEXISTS = 1,
    TRYPROGRAMEXTENSIONS = 3,
    FIRSTDIRDEF = 4,
    DONTFINDLNK = 8,
    REQUIREABSOLUTE = 16,
    _,
    pub fn initFlags(o: struct {
        VERIFYEXISTS: u1 = 0,
        TRYPROGRAMEXTENSIONS: u1 = 0,
        FIRSTDIRDEF: u1 = 0,
        DONTFINDLNK: u1 = 0,
        REQUIREABSOLUTE: u1 = 0,
    }) PRF_FLAGS {
        return @as(PRF_FLAGS, @enumFromInt((if (o.VERIFYEXISTS == 1) @intFromEnum(PRF_FLAGS.VERIFYEXISTS) else 0) | (if (o.TRYPROGRAMEXTENSIONS == 1) @intFromEnum(PRF_FLAGS.TRYPROGRAMEXTENSIONS) else 0) | (if (o.FIRSTDIRDEF == 1) @intFromEnum(PRF_FLAGS.FIRSTDIRDEF) else 0) | (if (o.DONTFINDLNK == 1) @intFromEnum(PRF_FLAGS.DONTFINDLNK) else 0) | (if (o.REQUIREABSOLUTE == 1) @intFromEnum(PRF_FLAGS.REQUIREABSOLUTE) else 0)));
    }
};
pub const PRF_VERIFYEXISTS = PRF_FLAGS.VERIFYEXISTS;
pub const PRF_TRYPROGRAMEXTENSIONS = PRF_FLAGS.TRYPROGRAMEXTENSIONS;
pub const PRF_FIRSTDIRDEF = PRF_FLAGS.FIRSTDIRDEF;
pub const PRF_DONTFINDLNK = PRF_FLAGS.DONTFINDLNK;
pub const PRF_REQUIREABSOLUTE = PRF_FLAGS.REQUIREABSOLUTE;

pub const PCS_RET = enum(u32) {
    FATAL = 2147483648,
    REPLACEDCHAR = 1,
    REMOVEDCHAR = 2,
    TRUNCATED = 4,
    PATHTOOLONG = 8,
    _,
    pub fn initFlags(o: struct {
        FATAL: u1 = 0,
        REPLACEDCHAR: u1 = 0,
        REMOVEDCHAR: u1 = 0,
        TRUNCATED: u1 = 0,
        PATHTOOLONG: u1 = 0,
    }) PCS_RET {
        return @as(PCS_RET, @enumFromInt((if (o.FATAL == 1) @intFromEnum(PCS_RET.FATAL) else 0) | (if (o.REPLACEDCHAR == 1) @intFromEnum(PCS_RET.REPLACEDCHAR) else 0) | (if (o.REMOVEDCHAR == 1) @intFromEnum(PCS_RET.REMOVEDCHAR) else 0) | (if (o.TRUNCATED == 1) @intFromEnum(PCS_RET.TRUNCATED) else 0) | (if (o.PATHTOOLONG == 1) @intFromEnum(PCS_RET.PATHTOOLONG) else 0)));
    }
};
pub const PCS_FATAL = PCS_RET.FATAL;
pub const PCS_REPLACEDCHAR = PCS_RET.REPLACEDCHAR;
pub const PCS_REMOVEDCHAR = PCS_RET.REMOVEDCHAR;
pub const PCS_TRUNCATED = PCS_RET.TRUNCATED;
pub const PCS_PATHTOOLONG = PCS_RET.PATHTOOLONG;

pub const MM_FLAGS = enum(u32) {
    ADDSEPARATOR = 1,
    SUBMENUSHAVEIDS = 2,
    DONTREMOVESEPS = 4,
    _,
    pub fn initFlags(o: struct {
        ADDSEPARATOR: u1 = 0,
        SUBMENUSHAVEIDS: u1 = 0,
        DONTREMOVESEPS: u1 = 0,
    }) MM_FLAGS {
        return @as(MM_FLAGS, @enumFromInt((if (o.ADDSEPARATOR == 1) @intFromEnum(MM_FLAGS.ADDSEPARATOR) else 0) | (if (o.SUBMENUSHAVEIDS == 1) @intFromEnum(MM_FLAGS.SUBMENUSHAVEIDS) else 0) | (if (o.DONTREMOVESEPS == 1) @intFromEnum(MM_FLAGS.DONTREMOVESEPS) else 0)));
    }
};
pub const MM_ADDSEPARATOR = MM_FLAGS.ADDSEPARATOR;
pub const MM_SUBMENUSHAVEIDS = MM_FLAGS.SUBMENUSHAVEIDS;
pub const MM_DONTREMOVESEPS = MM_FLAGS.DONTREMOVESEPS;

pub const SHOP_TYPE = enum(i32) {
    PRINTERNAME = 1,
    FILEPATH = 2,
    VOLUMEGUID = 4,
    _,
    pub fn initFlags(o: struct {
        PRINTERNAME: u1 = 0,
        FILEPATH: u1 = 0,
        VOLUMEGUID: u1 = 0,
    }) SHOP_TYPE {
        return @as(SHOP_TYPE, @enumFromInt((if (o.PRINTERNAME == 1) @intFromEnum(SHOP_TYPE.PRINTERNAME) else 0) | (if (o.FILEPATH == 1) @intFromEnum(SHOP_TYPE.FILEPATH) else 0) | (if (o.VOLUMEGUID == 1) @intFromEnum(SHOP_TYPE.VOLUMEGUID) else 0)));
    }
};
pub const SHOP_PRINTERNAME = SHOP_TYPE.PRINTERNAME;
pub const SHOP_FILEPATH = SHOP_TYPE.FILEPATH;
pub const SHOP_VOLUMEGUID = SHOP_TYPE.VOLUMEGUID;

pub const SHFMT_ID = enum(u32) {
    T = 65535,
};
pub const SHFMT_ID_DEFAULT = SHFMT_ID.T;

pub const SHFMT_OPT = enum(i32) {
    NONE = 0,
    FULL = 1,
    SYSONLY = 2,
    _,
    pub fn initFlags(o: struct {
        NONE: u1 = 0,
        FULL: u1 = 0,
        SYSONLY: u1 = 0,
    }) SHFMT_OPT {
        return @as(SHFMT_OPT, @enumFromInt((if (o.NONE == 1) @intFromEnum(SHFMT_OPT.NONE) else 0) | (if (o.FULL == 1) @intFromEnum(SHFMT_OPT.FULL) else 0) | (if (o.SYSONLY == 1) @intFromEnum(SHFMT_OPT.SYSONLY) else 0)));
    }
};
pub const SHFMT_OPT_NONE = SHFMT_OPT.NONE;
pub const SHFMT_OPT_FULL = SHFMT_OPT.FULL;
pub const SHFMT_OPT_SYSONLY = SHFMT_OPT.SYSONLY;

pub const SHFMT_RET = enum(u32) {
    ERROR = 4294967295,
    CANCEL = 4294967294,
    NOFORMAT = 4294967293,
};
pub const SHFMT_ERROR = SHFMT_RET.ERROR;
pub const SHFMT_CANCEL = SHFMT_RET.CANCEL;
pub const SHFMT_NOFORMAT = SHFMT_RET.NOFORMAT;

pub const VALIDATEUNC_OPTION = enum(i32) {
    CONNECT = 1,
    NOUI = 2,
    PRINT = 4,
    PERSIST = 8,
    VALID = 15,
    _,
    pub fn initFlags(o: struct {
        CONNECT: u1 = 0,
        NOUI: u1 = 0,
        PRINT: u1 = 0,
        PERSIST: u1 = 0,
        VALID: u1 = 0,
    }) VALIDATEUNC_OPTION {
        return @as(VALIDATEUNC_OPTION, @enumFromInt((if (o.CONNECT == 1) @intFromEnum(VALIDATEUNC_OPTION.CONNECT) else 0) | (if (o.NOUI == 1) @intFromEnum(VALIDATEUNC_OPTION.NOUI) else 0) | (if (o.PRINT == 1) @intFromEnum(VALIDATEUNC_OPTION.PRINT) else 0) | (if (o.PERSIST == 1) @intFromEnum(VALIDATEUNC_OPTION.PERSIST) else 0) | (if (o.VALID == 1) @intFromEnum(VALIDATEUNC_OPTION.VALID) else 0)));
    }
};
pub const VALIDATEUNC_CONNECT = VALIDATEUNC_OPTION.CONNECT;
pub const VALIDATEUNC_NOUI = VALIDATEUNC_OPTION.NOUI;
pub const VALIDATEUNC_PRINT = VALIDATEUNC_OPTION.PRINT;
pub const VALIDATEUNC_PERSIST = VALIDATEUNC_OPTION.PERSIST;
pub const VALIDATEUNC_VALID = VALIDATEUNC_OPTION.VALID;

pub const SFVM_MESSAGE_ID = enum(i32) {
    MERGEMENU = 1,
    INVOKECOMMAND = 2,
    GETHELPTEXT = 3,
    GETTOOLTIPTEXT = 4,
    GETBUTTONINFO = 5,
    GETBUTTONS = 6,
    INITMENUPOPUP = 7,
    FSNOTIFY = 14,
    WINDOWCREATED = 15,
    GETDETAILSOF = 23,
    COLUMNCLICK = 24,
    QUERYFSNOTIFY = 25,
    DEFITEMCOUNT = 26,
    DEFVIEWMODE = 27,
    UNMERGEMENU = 28,
    UPDATESTATUSBAR = 31,
    BACKGROUNDENUM = 32,
    DIDDRAGDROP = 36,
    SETISFV = 39,
    THISIDLIST = 41,
    ADDPROPERTYPAGES = 47,
    BACKGROUNDENUMDONE = 48,
    GETNOTIFY = 49,
    GETSORTDEFAULTS = 53,
    SIZE = 57,
    GETZONE = 58,
    GETPANE = 59,
    GETHELPTOPIC = 63,
    GETANIMATION = 68,
};
pub const SFVM_MERGEMENU = SFVM_MESSAGE_ID.MERGEMENU;
pub const SFVM_INVOKECOMMAND = SFVM_MESSAGE_ID.INVOKECOMMAND;
pub const SFVM_GETHELPTEXT = SFVM_MESSAGE_ID.GETHELPTEXT;
pub const SFVM_GETTOOLTIPTEXT = SFVM_MESSAGE_ID.GETTOOLTIPTEXT;
pub const SFVM_GETBUTTONINFO = SFVM_MESSAGE_ID.GETBUTTONINFO;
pub const SFVM_GETBUTTONS = SFVM_MESSAGE_ID.GETBUTTONS;
pub const SFVM_INITMENUPOPUP = SFVM_MESSAGE_ID.INITMENUPOPUP;
pub const SFVM_FSNOTIFY = SFVM_MESSAGE_ID.FSNOTIFY;
pub const SFVM_WINDOWCREATED = SFVM_MESSAGE_ID.WINDOWCREATED;
pub const SFVM_GETDETAILSOF = SFVM_MESSAGE_ID.GETDETAILSOF;
pub const SFVM_COLUMNCLICK = SFVM_MESSAGE_ID.COLUMNCLICK;
pub const SFVM_QUERYFSNOTIFY = SFVM_MESSAGE_ID.QUERYFSNOTIFY;
pub const SFVM_DEFITEMCOUNT = SFVM_MESSAGE_ID.DEFITEMCOUNT;
pub const SFVM_DEFVIEWMODE = SFVM_MESSAGE_ID.DEFVIEWMODE;
pub const SFVM_UNMERGEMENU = SFVM_MESSAGE_ID.UNMERGEMENU;
pub const SFVM_UPDATESTATUSBAR = SFVM_MESSAGE_ID.UPDATESTATUSBAR;
pub const SFVM_BACKGROUNDENUM = SFVM_MESSAGE_ID.BACKGROUNDENUM;
pub const SFVM_DIDDRAGDROP = SFVM_MESSAGE_ID.DIDDRAGDROP;
pub const SFVM_SETISFV = SFVM_MESSAGE_ID.SETISFV;
pub const SFVM_THISIDLIST = SFVM_MESSAGE_ID.THISIDLIST;
pub const SFVM_ADDPROPERTYPAGES = SFVM_MESSAGE_ID.ADDPROPERTYPAGES;
pub const SFVM_BACKGROUNDENUMDONE = SFVM_MESSAGE_ID.BACKGROUNDENUMDONE;
pub const SFVM_GETNOTIFY = SFVM_MESSAGE_ID.GETNOTIFY;
pub const SFVM_GETSORTDEFAULTS = SFVM_MESSAGE_ID.GETSORTDEFAULTS;
pub const SFVM_SIZE = SFVM_MESSAGE_ID.SIZE;
pub const SFVM_GETZONE = SFVM_MESSAGE_ID.GETZONE;
pub const SFVM_GETPANE = SFVM_MESSAGE_ID.GETPANE;
pub const SFVM_GETHELPTOPIC = SFVM_MESSAGE_ID.GETHELPTOPIC;
pub const SFVM_GETANIMATION = SFVM_MESSAGE_ID.GETANIMATION;

pub const SFVS_SELECT = enum(i32) {
    NONE = 0,
    ALLITEMS = 1,
    INVERT = 2,
};
pub const SFVS_SELECT_NONE = SFVS_SELECT.NONE;
pub const SFVS_SELECT_ALLITEMS = SFVS_SELECT.ALLITEMS;
pub const SFVS_SELECT_INVERT = SFVS_SELECT.INVERT;

pub const DFM_MESSAGE_ID = enum(i32) {
    MERGECONTEXTMENU = 1,
    INVOKECOMMAND = 2,
    GETHELPTEXT = 5,
    WM_MEASUREITEM = 6,
    WM_DRAWITEM = 7,
    WM_INITMENUPOPUP = 8,
    VALIDATECMD = 9,
    MERGECONTEXTMENU_TOP = 10,
    GETHELPTEXTW = 11,
    INVOKECOMMANDEX = 12,
    MAPCOMMANDNAME = 13,
    GETDEFSTATICID = 14,
    GETVERBW = 15,
    GETVERBA = 16,
    MERGECONTEXTMENU_BOTTOM = 17,
    MODIFYQCMFLAGS = 18,
};
pub const DFM_MERGECONTEXTMENU = DFM_MESSAGE_ID.MERGECONTEXTMENU;
pub const DFM_INVOKECOMMAND = DFM_MESSAGE_ID.INVOKECOMMAND;
pub const DFM_GETHELPTEXT = DFM_MESSAGE_ID.GETHELPTEXT;
pub const DFM_WM_MEASUREITEM = DFM_MESSAGE_ID.WM_MEASUREITEM;
pub const DFM_WM_DRAWITEM = DFM_MESSAGE_ID.WM_DRAWITEM;
pub const DFM_WM_INITMENUPOPUP = DFM_MESSAGE_ID.WM_INITMENUPOPUP;
pub const DFM_VALIDATECMD = DFM_MESSAGE_ID.VALIDATECMD;
pub const DFM_MERGECONTEXTMENU_TOP = DFM_MESSAGE_ID.MERGECONTEXTMENU_TOP;
pub const DFM_GETHELPTEXTW = DFM_MESSAGE_ID.GETHELPTEXTW;
pub const DFM_INVOKECOMMANDEX = DFM_MESSAGE_ID.INVOKECOMMANDEX;
pub const DFM_MAPCOMMANDNAME = DFM_MESSAGE_ID.MAPCOMMANDNAME;
pub const DFM_GETDEFSTATICID = DFM_MESSAGE_ID.GETDEFSTATICID;
pub const DFM_GETVERBW = DFM_MESSAGE_ID.GETVERBW;
pub const DFM_GETVERBA = DFM_MESSAGE_ID.GETVERBA;
pub const DFM_MERGECONTEXTMENU_BOTTOM = DFM_MESSAGE_ID.MERGECONTEXTMENU_BOTTOM;
pub const DFM_MODIFYQCMFLAGS = DFM_MESSAGE_ID.MODIFYQCMFLAGS;

pub const DFM_CMD = enum(i32) {
    DELETE = -1,
    MOVE = -2,
    COPY = -3,
    LINK = -4,
    PROPERTIES = -5,
    NEWFOLDER = -6,
    PASTE = -7,
    VIEWLIST = -8,
    VIEWDETAILS = -9,
    PASTELINK = -10,
    PASTESPECIAL = -11,
    MODALPROP = -12,
    RENAME = -13,
};
pub const DFM_CMD_DELETE = DFM_CMD.DELETE;
pub const DFM_CMD_MOVE = DFM_CMD.MOVE;
pub const DFM_CMD_COPY = DFM_CMD.COPY;
pub const DFM_CMD_LINK = DFM_CMD.LINK;
pub const DFM_CMD_PROPERTIES = DFM_CMD.PROPERTIES;
pub const DFM_CMD_NEWFOLDER = DFM_CMD.NEWFOLDER;
pub const DFM_CMD_PASTE = DFM_CMD.PASTE;
pub const DFM_CMD_VIEWLIST = DFM_CMD.VIEWLIST;
pub const DFM_CMD_VIEWDETAILS = DFM_CMD.VIEWDETAILS;
pub const DFM_CMD_PASTELINK = DFM_CMD.PASTELINK;
pub const DFM_CMD_PASTESPECIAL = DFM_CMD.PASTESPECIAL;
pub const DFM_CMD_MODALPROP = DFM_CMD.MODALPROP;
pub const DFM_CMD_RENAME = DFM_CMD.RENAME;

pub const PID_IS = enum(i32) {
    URL = 2,
    NAME = 4,
    WORKINGDIR = 5,
    HOTKEY = 6,
    SHOWCMD = 7,
    ICONINDEX = 8,
    ICONFILE = 9,
    WHATSNEW = 10,
    AUTHOR = 11,
    DESCRIPTION = 12,
    COMMENT = 13,
    ROAMED = 15,
};
pub const PID_IS_URL = PID_IS.URL;
pub const PID_IS_NAME = PID_IS.NAME;
pub const PID_IS_WORKINGDIR = PID_IS.WORKINGDIR;
pub const PID_IS_HOTKEY = PID_IS.HOTKEY;
pub const PID_IS_SHOWCMD = PID_IS.SHOWCMD;
pub const PID_IS_ICONINDEX = PID_IS.ICONINDEX;
pub const PID_IS_ICONFILE = PID_IS.ICONFILE;
pub const PID_IS_WHATSNEW = PID_IS.WHATSNEW;
pub const PID_IS_AUTHOR = PID_IS.AUTHOR;
pub const PID_IS_DESCRIPTION = PID_IS.DESCRIPTION;
pub const PID_IS_COMMENT = PID_IS.COMMENT;
pub const PID_IS_ROAMED = PID_IS.ROAMED;

pub const PID_INTSITE = enum(i32) {
    WHATSNEW = 2,
    AUTHOR = 3,
    LASTVISIT = 4,
    LASTMOD = 5,
    VISITCOUNT = 6,
    DESCRIPTION = 7,
    COMMENT = 8,
    FLAGS = 9,
    CONTENTLEN = 10,
    CONTENTCODE = 11,
    RECURSE = 12,
    WATCH = 13,
    SUBSCRIPTION = 14,
    URL = 15,
    TITLE = 16,
    CODEPAGE = 18,
    TRACKING = 19,
    ICONINDEX = 20,
    ICONFILE = 21,
    ROAMED = 34,
};
pub const PID_INTSITE_WHATSNEW = PID_INTSITE.WHATSNEW;
pub const PID_INTSITE_AUTHOR = PID_INTSITE.AUTHOR;
pub const PID_INTSITE_LASTVISIT = PID_INTSITE.LASTVISIT;
pub const PID_INTSITE_LASTMOD = PID_INTSITE.LASTMOD;
pub const PID_INTSITE_VISITCOUNT = PID_INTSITE.VISITCOUNT;
pub const PID_INTSITE_DESCRIPTION = PID_INTSITE.DESCRIPTION;
pub const PID_INTSITE_COMMENT = PID_INTSITE.COMMENT;
pub const PID_INTSITE_FLAGS = PID_INTSITE.FLAGS;
pub const PID_INTSITE_CONTENTLEN = PID_INTSITE.CONTENTLEN;
pub const PID_INTSITE_CONTENTCODE = PID_INTSITE.CONTENTCODE;
pub const PID_INTSITE_RECURSE = PID_INTSITE.RECURSE;
pub const PID_INTSITE_WATCH = PID_INTSITE.WATCH;
pub const PID_INTSITE_SUBSCRIPTION = PID_INTSITE.SUBSCRIPTION;
pub const PID_INTSITE_URL = PID_INTSITE.URL;
pub const PID_INTSITE_TITLE = PID_INTSITE.TITLE;
pub const PID_INTSITE_CODEPAGE = PID_INTSITE.CODEPAGE;
pub const PID_INTSITE_TRACKING = PID_INTSITE.TRACKING;
pub const PID_INTSITE_ICONINDEX = PID_INTSITE.ICONINDEX;
pub const PID_INTSITE_ICONFILE = PID_INTSITE.ICONFILE;
pub const PID_INTSITE_ROAMED = PID_INTSITE.ROAMED;

pub const PIDISF_FLAGS = enum(i32) {
    RECENTLYCHANGED = 1,
    CACHEDSTICKY = 2,
    CACHEIMAGES = 16,
    FOLLOWALLLINKS = 32,
    _,
    pub fn initFlags(o: struct {
        RECENTLYCHANGED: u1 = 0,
        CACHEDSTICKY: u1 = 0,
        CACHEIMAGES: u1 = 0,
        FOLLOWALLLINKS: u1 = 0,
    }) PIDISF_FLAGS {
        return @as(PIDISF_FLAGS, @enumFromInt((if (o.RECENTLYCHANGED == 1) @intFromEnum(PIDISF_FLAGS.RECENTLYCHANGED) else 0) | (if (o.CACHEDSTICKY == 1) @intFromEnum(PIDISF_FLAGS.CACHEDSTICKY) else 0) | (if (o.CACHEIMAGES == 1) @intFromEnum(PIDISF_FLAGS.CACHEIMAGES) else 0) | (if (o.FOLLOWALLLINKS == 1) @intFromEnum(PIDISF_FLAGS.FOLLOWALLLINKS) else 0)));
    }
};
pub const PIDISF_RECENTLYCHANGED = PIDISF_FLAGS.RECENTLYCHANGED;
pub const PIDISF_CACHEDSTICKY = PIDISF_FLAGS.CACHEDSTICKY;
pub const PIDISF_CACHEIMAGES = PIDISF_FLAGS.CACHEIMAGES;
pub const PIDISF_FOLLOWALLLINKS = PIDISF_FLAGS.FOLLOWALLLINKS;

pub const PIDISM_OPTIONS = enum(i32) {
    GLOBAL = 0,
    WATCH = 1,
    DONTWATCH = 2,
};
pub const PIDISM_GLOBAL = PIDISM_OPTIONS.GLOBAL;
pub const PIDISM_WATCH = PIDISM_OPTIONS.WATCH;
pub const PIDISM_DONTWATCH = PIDISM_OPTIONS.DONTWATCH;

pub const PIDISR_INFO = enum(i32) {
    UP_TO_DATE = 0,
    NEEDS_ADD = 1,
    NEEDS_UPDATE = 2,
    NEEDS_DELETE = 3,
};
pub const PIDISR_UP_TO_DATE = PIDISR_INFO.UP_TO_DATE;
pub const PIDISR_NEEDS_ADD = PIDISR_INFO.NEEDS_ADD;
pub const PIDISR_NEEDS_UPDATE = PIDISR_INFO.NEEDS_UPDATE;
pub const PIDISR_NEEDS_DELETE = PIDISR_INFO.NEEDS_DELETE;

pub const SSF_MASK = enum(u32) {
    SHOWALLOBJECTS = 1,
    SHOWEXTENSIONS = 2,
    HIDDENFILEEXTS = 4,
    // SERVERADMINUI = 4, this enum value conflicts with HIDDENFILEEXTS
    SHOWCOMPCOLOR = 8,
    SORTCOLUMNS = 16,
    SHOWSYSFILES = 32,
    DOUBLECLICKINWEBVIEW = 128,
    SHOWATTRIBCOL = 256,
    DESKTOPHTML = 512,
    WIN95CLASSIC = 1024,
    DONTPRETTYPATH = 2048,
    SHOWINFOTIP = 8192,
    MAPNETDRVBUTTON = 4096,
    NOCONFIRMRECYCLE = 32768,
    HIDEICONS = 16384,
    FILTER = 65536,
    WEBVIEW = 131072,
    SHOWSUPERHIDDEN = 262144,
    SEPPROCESS = 524288,
    NONETCRAWLING = 1048576,
    STARTPANELON = 2097152,
    SHOWSTARTPAGE = 4194304,
    AUTOCHECKSELECT = 8388608,
    ICONSONLY = 16777216,
    SHOWTYPEOVERLAY = 33554432,
    SHOWSTATUSBAR = 67108864,
    _,
    pub fn initFlags(o: struct {
        SHOWALLOBJECTS: u1 = 0,
        SHOWEXTENSIONS: u1 = 0,
        HIDDENFILEEXTS: u1 = 0,
        SHOWCOMPCOLOR: u1 = 0,
        SORTCOLUMNS: u1 = 0,
        SHOWSYSFILES: u1 = 0,
        DOUBLECLICKINWEBVIEW: u1 = 0,
        SHOWATTRIBCOL: u1 = 0,
        DESKTOPHTML: u1 = 0,
        WIN95CLASSIC: u1 = 0,
        DONTPRETTYPATH: u1 = 0,
        SHOWINFOTIP: u1 = 0,
        MAPNETDRVBUTTON: u1 = 0,
        NOCONFIRMRECYCLE: u1 = 0,
        HIDEICONS: u1 = 0,
        FILTER: u1 = 0,
        WEBVIEW: u1 = 0,
        SHOWSUPERHIDDEN: u1 = 0,
        SEPPROCESS: u1 = 0,
        NONETCRAWLING: u1 = 0,
        STARTPANELON: u1 = 0,
        SHOWSTARTPAGE: u1 = 0,
        AUTOCHECKSELECT: u1 = 0,
        ICONSONLY: u1 = 0,
        SHOWTYPEOVERLAY: u1 = 0,
        SHOWSTATUSBAR: u1 = 0,
    }) SSF_MASK {
        return @as(SSF_MASK, @enumFromInt((if (o.SHOWALLOBJECTS == 1) @intFromEnum(SSF_MASK.SHOWALLOBJECTS) else 0) | (if (o.SHOWEXTENSIONS == 1) @intFromEnum(SSF_MASK.SHOWEXTENSIONS) else 0) | (if (o.HIDDENFILEEXTS == 1) @intFromEnum(SSF_MASK.HIDDENFILEEXTS) else 0) | (if (o.SHOWCOMPCOLOR == 1) @intFromEnum(SSF_MASK.SHOWCOMPCOLOR) else 0) | (if (o.SORTCOLUMNS == 1) @intFromEnum(SSF_MASK.SORTCOLUMNS) else 0) | (if (o.SHOWSYSFILES == 1) @intFromEnum(SSF_MASK.SHOWSYSFILES) else 0) | (if (o.DOUBLECLICKINWEBVIEW == 1) @intFromEnum(SSF_MASK.DOUBLECLICKINWEBVIEW) else 0) | (if (o.SHOWATTRIBCOL == 1) @intFromEnum(SSF_MASK.SHOWATTRIBCOL) else 0) | (if (o.DESKTOPHTML == 1) @intFromEnum(SSF_MASK.DESKTOPHTML) else 0) | (if (o.WIN95CLASSIC == 1) @intFromEnum(SSF_MASK.WIN95CLASSIC) else 0) | (if (o.DONTPRETTYPATH == 1) @intFromEnum(SSF_MASK.DONTPRETTYPATH) else 0) | (if (o.SHOWINFOTIP == 1) @intFromEnum(SSF_MASK.SHOWINFOTIP) else 0) | (if (o.MAPNETDRVBUTTON == 1) @intFromEnum(SSF_MASK.MAPNETDRVBUTTON) else 0) | (if (o.NOCONFIRMRECYCLE == 1) @intFromEnum(SSF_MASK.NOCONFIRMRECYCLE) else 0) | (if (o.HIDEICONS == 1) @intFromEnum(SSF_MASK.HIDEICONS) else 0) | (if (o.FILTER == 1) @intFromEnum(SSF_MASK.FILTER) else 0) | (if (o.WEBVIEW == 1) @intFromEnum(SSF_MASK.WEBVIEW) else 0) | (if (o.SHOWSUPERHIDDEN == 1) @intFromEnum(SSF_MASK.SHOWSUPERHIDDEN) else 0) | (if (o.SEPPROCESS == 1) @intFromEnum(SSF_MASK.SEPPROCESS) else 0) | (if (o.NONETCRAWLING == 1) @intFromEnum(SSF_MASK.NONETCRAWLING) else 0) | (if (o.STARTPANELON == 1) @intFromEnum(SSF_MASK.STARTPANELON) else 0) | (if (o.SHOWSTARTPAGE == 1) @intFromEnum(SSF_MASK.SHOWSTARTPAGE) else 0) | (if (o.AUTOCHECKSELECT == 1) @intFromEnum(SSF_MASK.AUTOCHECKSELECT) else 0) | (if (o.ICONSONLY == 1) @intFromEnum(SSF_MASK.ICONSONLY) else 0) | (if (o.SHOWTYPEOVERLAY == 1) @intFromEnum(SSF_MASK.SHOWTYPEOVERLAY) else 0) | (if (o.SHOWSTATUSBAR == 1) @intFromEnum(SSF_MASK.SHOWSTATUSBAR) else 0)));
    }
};
pub const SSF_SHOWALLOBJECTS = SSF_MASK.SHOWALLOBJECTS;
pub const SSF_SHOWEXTENSIONS = SSF_MASK.SHOWEXTENSIONS;
pub const SSF_HIDDENFILEEXTS = SSF_MASK.HIDDENFILEEXTS;
pub const SSF_SERVERADMINUI = SSF_MASK.HIDDENFILEEXTS;
pub const SSF_SHOWCOMPCOLOR = SSF_MASK.SHOWCOMPCOLOR;
pub const SSF_SORTCOLUMNS = SSF_MASK.SORTCOLUMNS;
pub const SSF_SHOWSYSFILES = SSF_MASK.SHOWSYSFILES;
pub const SSF_DOUBLECLICKINWEBVIEW = SSF_MASK.DOUBLECLICKINWEBVIEW;
pub const SSF_SHOWATTRIBCOL = SSF_MASK.SHOWATTRIBCOL;
pub const SSF_DESKTOPHTML = SSF_MASK.DESKTOPHTML;
pub const SSF_WIN95CLASSIC = SSF_MASK.WIN95CLASSIC;
pub const SSF_DONTPRETTYPATH = SSF_MASK.DONTPRETTYPATH;
pub const SSF_SHOWINFOTIP = SSF_MASK.SHOWINFOTIP;
pub const SSF_MAPNETDRVBUTTON = SSF_MASK.MAPNETDRVBUTTON;
pub const SSF_NOCONFIRMRECYCLE = SSF_MASK.NOCONFIRMRECYCLE;
pub const SSF_HIDEICONS = SSF_MASK.HIDEICONS;
pub const SSF_FILTER = SSF_MASK.FILTER;
pub const SSF_WEBVIEW = SSF_MASK.WEBVIEW;
pub const SSF_SHOWSUPERHIDDEN = SSF_MASK.SHOWSUPERHIDDEN;
pub const SSF_SEPPROCESS = SSF_MASK.SEPPROCESS;
pub const SSF_NONETCRAWLING = SSF_MASK.NONETCRAWLING;
pub const SSF_STARTPANELON = SSF_MASK.STARTPANELON;
pub const SSF_SHOWSTARTPAGE = SSF_MASK.SHOWSTARTPAGE;
pub const SSF_AUTOCHECKSELECT = SSF_MASK.AUTOCHECKSELECT;
pub const SSF_ICONSONLY = SSF_MASK.ICONSONLY;
pub const SSF_SHOWTYPEOVERLAY = SSF_MASK.SHOWTYPEOVERLAY;
pub const SSF_SHOWSTATUSBAR = SSF_MASK.SHOWSTATUSBAR;

pub const NOTIFY_ICON_MESSAGE = enum(u32) {
    ADD = 0,
    MODIFY = 1,
    DELETE = 2,
    SETFOCUS = 3,
    SETVERSION = 4,
};
pub const NIM_ADD = NOTIFY_ICON_MESSAGE.ADD;
pub const NIM_MODIFY = NOTIFY_ICON_MESSAGE.MODIFY;
pub const NIM_DELETE = NOTIFY_ICON_MESSAGE.DELETE;
pub const NIM_SETFOCUS = NOTIFY_ICON_MESSAGE.SETFOCUS;
pub const NIM_SETVERSION = NOTIFY_ICON_MESSAGE.SETVERSION;

pub const NOTIFY_ICON_DATA_FLAGS = enum(u32) {
    MESSAGE = 1,
    ICON = 2,
    TIP = 4,
    STATE = 8,
    INFO = 16,
    GUID = 32,
    REALTIME = 64,
    SHOWTIP = 128,
    _,
    pub fn initFlags(o: struct {
        MESSAGE: u1 = 0,
        ICON: u1 = 0,
        TIP: u1 = 0,
        STATE: u1 = 0,
        INFO: u1 = 0,
        GUID: u1 = 0,
        REALTIME: u1 = 0,
        SHOWTIP: u1 = 0,
    }) NOTIFY_ICON_DATA_FLAGS {
        return @as(NOTIFY_ICON_DATA_FLAGS, @enumFromInt((if (o.MESSAGE == 1) @intFromEnum(NOTIFY_ICON_DATA_FLAGS.MESSAGE) else 0) | (if (o.ICON == 1) @intFromEnum(NOTIFY_ICON_DATA_FLAGS.ICON) else 0) | (if (o.TIP == 1) @intFromEnum(NOTIFY_ICON_DATA_FLAGS.TIP) else 0) | (if (o.STATE == 1) @intFromEnum(NOTIFY_ICON_DATA_FLAGS.STATE) else 0) | (if (o.INFO == 1) @intFromEnum(NOTIFY_ICON_DATA_FLAGS.INFO) else 0) | (if (o.GUID == 1) @intFromEnum(NOTIFY_ICON_DATA_FLAGS.GUID) else 0) | (if (o.REALTIME == 1) @intFromEnum(NOTIFY_ICON_DATA_FLAGS.REALTIME) else 0) | (if (o.SHOWTIP == 1) @intFromEnum(NOTIFY_ICON_DATA_FLAGS.SHOWTIP) else 0)));
    }
};
pub const NIF_MESSAGE = NOTIFY_ICON_DATA_FLAGS.MESSAGE;
pub const NIF_ICON = NOTIFY_ICON_DATA_FLAGS.ICON;
pub const NIF_TIP = NOTIFY_ICON_DATA_FLAGS.TIP;
pub const NIF_STATE = NOTIFY_ICON_DATA_FLAGS.STATE;
pub const NIF_INFO = NOTIFY_ICON_DATA_FLAGS.INFO;
pub const NIF_GUID = NOTIFY_ICON_DATA_FLAGS.GUID;
pub const NIF_REALTIME = NOTIFY_ICON_DATA_FLAGS.REALTIME;
pub const NIF_SHOWTIP = NOTIFY_ICON_DATA_FLAGS.SHOWTIP;

pub const OS = enum(u32) {
    WINDOWS = 0,
    NT = 1,
    WIN95ORGREATER = 2,
    NT4ORGREATER = 3,
    WIN98ORGREATER = 5,
    WIN98_GOLD = 6,
    WIN2000ORGREATER = 7,
    WIN2000PRO = 8,
    WIN2000SERVER = 9,
    WIN2000ADVSERVER = 10,
    WIN2000DATACENTER = 11,
    WIN2000TERMINAL = 12,
    EMBEDDED = 13,
    TERMINALCLIENT = 14,
    TERMINALREMOTEADMIN = 15,
    WIN95_GOLD = 16,
    MEORGREATER = 17,
    XPORGREATER = 18,
    HOME = 19,
    PROFESSIONAL = 20,
    DATACENTER = 21,
    ADVSERVER = 22,
    SERVER = 23,
    TERMINALSERVER = 24,
    PERSONALTERMINALSERVER = 25,
    FASTUSERSWITCHING = 26,
    WELCOMELOGONUI = 27,
    DOMAINMEMBER = 28,
    ANYSERVER = 29,
    WOW6432 = 30,
    WEBSERVER = 31,
    SMALLBUSINESSSERVER = 32,
    TABLETPC = 33,
    SERVERADMINUI = 34,
    MEDIACENTER = 35,
    APPLIANCE = 36,
};
pub const OS_WINDOWS = OS.WINDOWS;
pub const OS_NT = OS.NT;
pub const OS_WIN95ORGREATER = OS.WIN95ORGREATER;
pub const OS_NT4ORGREATER = OS.NT4ORGREATER;
pub const OS_WIN98ORGREATER = OS.WIN98ORGREATER;
pub const OS_WIN98_GOLD = OS.WIN98_GOLD;
pub const OS_WIN2000ORGREATER = OS.WIN2000ORGREATER;
pub const OS_WIN2000PRO = OS.WIN2000PRO;
pub const OS_WIN2000SERVER = OS.WIN2000SERVER;
pub const OS_WIN2000ADVSERVER = OS.WIN2000ADVSERVER;
pub const OS_WIN2000DATACENTER = OS.WIN2000DATACENTER;
pub const OS_WIN2000TERMINAL = OS.WIN2000TERMINAL;
pub const OS_EMBEDDED = OS.EMBEDDED;
pub const OS_TERMINALCLIENT = OS.TERMINALCLIENT;
pub const OS_TERMINALREMOTEADMIN = OS.TERMINALREMOTEADMIN;
pub const OS_WIN95_GOLD = OS.WIN95_GOLD;
pub const OS_MEORGREATER = OS.MEORGREATER;
pub const OS_XPORGREATER = OS.XPORGREATER;
pub const OS_HOME = OS.HOME;
pub const OS_PROFESSIONAL = OS.PROFESSIONAL;
pub const OS_DATACENTER = OS.DATACENTER;
pub const OS_ADVSERVER = OS.ADVSERVER;
pub const OS_SERVER = OS.SERVER;
pub const OS_TERMINALSERVER = OS.TERMINALSERVER;
pub const OS_PERSONALTERMINALSERVER = OS.PERSONALTERMINALSERVER;
pub const OS_FASTUSERSWITCHING = OS.FASTUSERSWITCHING;
pub const OS_WELCOMELOGONUI = OS.WELCOMELOGONUI;
pub const OS_DOMAINMEMBER = OS.DOMAINMEMBER;
pub const OS_ANYSERVER = OS.ANYSERVER;
pub const OS_WOW6432 = OS.WOW6432;
pub const OS_WEBSERVER = OS.WEBSERVER;
pub const OS_SMALLBUSINESSSERVER = OS.SMALLBUSINESSSERVER;
pub const OS_TABLETPC = OS.TABLETPC;
pub const OS_SERVERADMINUI = OS.SERVERADMINUI;
pub const OS_MEDIACENTER = OS.MEDIACENTER;
pub const OS_APPLIANCE = OS.APPLIANCE;

pub const _APPSTATE_REGISTRATION = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const _APPCONSTRAIN_REGISTRATION = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

// TODO: this type has a FreeFunc 'SHChangeNotification_Unlock', what can Zig do with this information?
pub const ShFindChangeNotificationHandle = isize;

pub const HDROP = *opaque {};

pub const HPSXA = *opaque {};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_INotifyReplica_Value = Guid.initString("99180163-da16-101a-935c-444553540000");
pub const IID_INotifyReplica = &IID_INotifyReplica_Value;
pub const INotifyReplica = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        YouAreAReplica: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INotifyReplica,
                ulcOtherReplicas: u32,
                rgpmkOtherReplicas: [*]?*IMoniker,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INotifyReplica,
                ulcOtherReplicas: u32,
                rgpmkOtherReplicas: [*]?*IMoniker,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INotifyReplica_YouAreAReplica(self: *const T, ulcOtherReplicas: u32, rgpmkOtherReplicas: [*]?*IMoniker) HRESULT {
                return @as(*const INotifyReplica.VTable, @ptrCast(self.vtable)).YouAreAReplica(@as(*const INotifyReplica, @ptrCast(self)), ulcOtherReplicas, rgpmkOtherReplicas);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const APPCATEGORYINFO = extern struct {
    Locale: u32,
    pszDescription: ?PWSTR,
    AppCategoryId: Guid,
};

pub const APPCATEGORYINFOLIST = extern struct {
    cCategory: u32,
    pCategoryInfo: ?*APPCATEGORYINFO,
};

pub const SUBCLASSPROC = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        hWnd: ?HWND,
        uMsg: u32,
        wParam: WPARAM,
        lParam: LPARAM,
        uIdSubclass: usize,
        dwRefData: usize,
    ) callconv(@import("std").os.windows.WINAPI) LRESULT,
    else => *const fn (
        hWnd: ?HWND,
        uMsg: u32,
        wParam: WPARAM,
        lParam: LPARAM,
        uIdSubclass: usize,
        dwRefData: usize,
    ) callconv(@import("std").os.windows.WINAPI) LRESULT,
};

pub const HELPINFO = extern struct {
    cbSize: u32,
    iContextType: i32,
    iCtrlId: i32,
    hItemHandle: ?HANDLE,
    dwContextId: usize,
    MousePos: POINT,
};

pub const MULTIKEYHELPA = extern struct {
    mkSize: u32,
    mkKeylist: CHAR,
    szKeyphrase: [1]CHAR,
};

pub const MULTIKEYHELPW = extern struct {
    mkSize: u32,
    mkKeylist: u16,
    szKeyphrase: [1]u16,
};

pub const HELPWININFOA = extern struct {
    wStructSize: i32,
    x: i32,
    y: i32,
    dx: i32,
    dy: i32,
    wMax: i32,
    rgchMember: [2]CHAR,
};

pub const HELPWININFOW = extern struct {
    wStructSize: i32,
    x: i32,
    y: i32,
    dx: i32,
    dy: i32,
    wMax: i32,
    rgchMember: [2]u16,
};

const CLSID_QueryCancelAutoPlay_Value = Guid.initString("331f1768-05a9-4ddd-b86e-dae34ddc998a");
pub const CLSID_QueryCancelAutoPlay = &CLSID_QueryCancelAutoPlay_Value;

const CLSID_TimeCategorizer_Value = Guid.initString("3bb4118f-ddfd-4d30-a348-9fb5d6bf1afe");
pub const CLSID_TimeCategorizer = &CLSID_TimeCategorizer_Value;

const CLSID_AlphabeticalCategorizer_Value = Guid.initString("3c2654c6-7372-4f6b-b310-55d6128f49d2");
pub const CLSID_AlphabeticalCategorizer = &CLSID_AlphabeticalCategorizer_Value;

const CLSID_MergedCategorizer_Value = Guid.initString("8e827c11-33e7-4bc1-b242-8cd9a1c2b304");
pub const CLSID_MergedCategorizer = &CLSID_MergedCategorizer_Value;

const CLSID_ImageProperties_Value = Guid.initString("7ab770c7-0e23-4d7a-8aa2-19bfad479829");
pub const CLSID_ImageProperties = &CLSID_ImageProperties_Value;

const CLSID_CDBurn_Value = Guid.initString("fbeb8a05-beee-4442-804e-409d6c4515e9");
pub const CLSID_CDBurn = &CLSID_CDBurn_Value;

const CLSID_StartMenuPin_Value = Guid.initString("a2a9545d-a0c2-42b4-9708-a0b2badd77c8");
pub const CLSID_StartMenuPin = &CLSID_StartMenuPin_Value;

const CLSID_WebWizardHost_Value = Guid.initString("c827f149-55c1-4d28-935e-57e47caed973");
pub const CLSID_WebWizardHost = &CLSID_WebWizardHost_Value;

const CLSID_PublishDropTarget_Value = Guid.initString("cc6eeffb-43f6-46c5-9619-51d571967f7d");
pub const CLSID_PublishDropTarget = &CLSID_PublishDropTarget_Value;

const CLSID_PublishingWizard_Value = Guid.initString("6b33163c-76a5-4b6c-bf21-45de9cd503a1");
pub const CLSID_PublishingWizard = &CLSID_PublishingWizard_Value;

const CLSID_InternetPrintOrdering_Value = Guid.initString("add36aa8-751a-4579-a266-d66f5202ccbb");
pub const CLSID_InternetPrintOrdering = &CLSID_InternetPrintOrdering_Value;

const CLSID_FolderViewHost_Value = Guid.initString("20b1cb23-6968-4eb9-b7d4-a66d00d07cee");
pub const CLSID_FolderViewHost = &CLSID_FolderViewHost_Value;

const CLSID_ExplorerBrowser_Value = Guid.initString("71f96385-ddd6-48d3-a0c1-ae06e8b055fb");
pub const CLSID_ExplorerBrowser = &CLSID_ExplorerBrowser_Value;

const CLSID_ImageRecompress_Value = Guid.initString("6e33091c-d2f8-4740-b55e-2e11d1477a2c");
pub const CLSID_ImageRecompress = &CLSID_ImageRecompress_Value;

const CLSID_TrayBandSiteService_Value = Guid.initString("f60ad0a0-e5e1-45cb-b51a-e15b9f8b2934");
pub const CLSID_TrayBandSiteService = &CLSID_TrayBandSiteService_Value;

const CLSID_TrayDeskBand_Value = Guid.initString("e6442437-6c68-4f52-94dd-2cfed267efb9");
pub const CLSID_TrayDeskBand = &CLSID_TrayDeskBand_Value;

const CLSID_AttachmentServices_Value = Guid.initString("4125dd96-e03a-4103-8f70-e0597d803b9c");
pub const CLSID_AttachmentServices = &CLSID_AttachmentServices_Value;

const CLSID_DocPropShellExtension_Value = Guid.initString("883373c3-bf89-11d1-be35-080036b11a03");
pub const CLSID_DocPropShellExtension = &CLSID_DocPropShellExtension_Value;

const CLSID_FSCopyHandler_Value = Guid.initString("d197380a-0a79-4dc8-a033-ed882c2fa14b");
pub const CLSID_FSCopyHandler = &CLSID_FSCopyHandler_Value;

const CLSID_PreviousVersions_Value = Guid.initString("596ab062-b4d2-4215-9f74-e9109b0a8153");
pub const CLSID_PreviousVersions = &CLSID_PreviousVersions_Value;

const CLSID_NamespaceTreeControl_Value = Guid.initString("ae054212-3535-4430-83ed-d501aa6680e6");
pub const CLSID_NamespaceTreeControl = &CLSID_NamespaceTreeControl_Value;

const CLSID_IENamespaceTreeControl_Value = Guid.initString("ace52d03-e5cd-4b20-82ff-e71b11beae1d");
pub const CLSID_IENamespaceTreeControl = &CLSID_IENamespaceTreeControl_Value;

const CLSID_ApplicationAssociationRegistrationUI_Value = Guid.initString("1968106d-f3b5-44cf-890e-116fcb9ecef1");
pub const CLSID_ApplicationAssociationRegistrationUI = &CLSID_ApplicationAssociationRegistrationUI_Value;

const CLSID_DesktopGadget_Value = Guid.initString("924ccc1b-6562-4c85-8657-d177925222b6");
pub const CLSID_DesktopGadget = &CLSID_DesktopGadget_Value;

const CLSID_AccessibilityDockingService_Value = Guid.initString("29ce1d46-b481-4aa0-a08a-d3ebc8aca402");
pub const CLSID_AccessibilityDockingService = &CLSID_AccessibilityDockingService_Value;

const CLSID_ExecuteFolder_Value = Guid.initString("11dbb47c-a525-400b-9e80-a54615a090c0");
pub const CLSID_ExecuteFolder = &CLSID_ExecuteFolder_Value;

const CLSID_VirtualDesktopManager_Value = Guid.initString("aa509086-5ca9-4c25-8f95-589d3c07b48a");
pub const CLSID_VirtualDesktopManager = &CLSID_VirtualDesktopManager_Value;

const CLSID_StorageProviderBanners_Value = Guid.initString("7ccdf9f4-e576-455a-8bc7-f6ec68d6f063");
pub const CLSID_StorageProviderBanners = &CLSID_StorageProviderBanners_Value;

const CLSID_DesktopWallpaper_Value = Guid.initString("c2cf3110-460e-4fc1-b9d0-8a1c0c9cc4bd");
pub const CLSID_DesktopWallpaper = &CLSID_DesktopWallpaper_Value;

const CLSID_ShellDesktop_Value = Guid.initString("00021400-0000-0000-c000-000000000046");
pub const CLSID_ShellDesktop = &CLSID_ShellDesktop_Value;

const CLSID_ShellFSFolder_Value = Guid.initString("f3364ba0-65b9-11ce-a9ba-00aa004ae837");
pub const CLSID_ShellFSFolder = &CLSID_ShellFSFolder_Value;

const CLSID_NetworkPlaces_Value = Guid.initString("208d2c60-3aea-1069-a2d7-08002b30309d");
pub const CLSID_NetworkPlaces = &CLSID_NetworkPlaces_Value;

const CLSID_ShellLink_Value = Guid.initString("00021401-0000-0000-c000-000000000046");
pub const CLSID_ShellLink = &CLSID_ShellLink_Value;

const CLSID_DriveSizeCategorizer_Value = Guid.initString("94357b53-ca29-4b78-83ae-e8fe7409134f");
pub const CLSID_DriveSizeCategorizer = &CLSID_DriveSizeCategorizer_Value;

const CLSID_DriveTypeCategorizer_Value = Guid.initString("b0a8f3cf-4333-4bab-8873-1ccb1cada48b");
pub const CLSID_DriveTypeCategorizer = &CLSID_DriveTypeCategorizer_Value;

const CLSID_FreeSpaceCategorizer_Value = Guid.initString("b5607793-24ac-44c7-82e2-831726aa6cb7");
pub const CLSID_FreeSpaceCategorizer = &CLSID_FreeSpaceCategorizer_Value;

const CLSID_SizeCategorizer_Value = Guid.initString("55d7b852-f6d1-42f2-aa75-8728a1b2d264");
pub const CLSID_SizeCategorizer = &CLSID_SizeCategorizer_Value;

const CLSID_PropertiesUI_Value = Guid.initString("d912f8cf-0396-4915-884e-fb425d32943b");
pub const CLSID_PropertiesUI = &CLSID_PropertiesUI_Value;

const CLSID_UserNotification_Value = Guid.initString("0010890e-8789-413c-adbc-48f5b511b3af");
pub const CLSID_UserNotification = &CLSID_UserNotification_Value;

const CLSID_TaskbarList_Value = Guid.initString("56fdf344-fd6d-11d0-958a-006097c9a090");
pub const CLSID_TaskbarList = &CLSID_TaskbarList_Value;

const CLSID_ShellItem_Value = Guid.initString("9ac9fbe1-e0a2-4ad6-b4ee-e212013ea917");
pub const CLSID_ShellItem = &CLSID_ShellItem_Value;

const CLSID_NamespaceWalker_Value = Guid.initString("72eb61e0-8672-4303-9175-f2e4c68b2e7c");
pub const CLSID_NamespaceWalker = &CLSID_NamespaceWalker_Value;

const CLSID_FileOperation_Value = Guid.initString("3ad05575-8857-4850-9277-11b85bdb8e09");
pub const CLSID_FileOperation = &CLSID_FileOperation_Value;

const CLSID_FileOpenDialog_Value = Guid.initString("dc1c5a9c-e88a-4dde-a5a1-60f82a20aef7");
pub const CLSID_FileOpenDialog = &CLSID_FileOpenDialog_Value;

const CLSID_FileSaveDialog_Value = Guid.initString("c0b4e2f3-ba21-4773-8dba-335ec946eb8b");
pub const CLSID_FileSaveDialog = &CLSID_FileSaveDialog_Value;

const CLSID_KnownFolderManager_Value = Guid.initString("4df0c730-df9d-4ae3-9153-aa6b82e9795a");
pub const CLSID_KnownFolderManager = &CLSID_KnownFolderManager_Value;

const CLSID_SharingConfigurationManager_Value = Guid.initString("49f371e1-8c5c-4d9c-9a3b-54a6827f513c");
pub const CLSID_SharingConfigurationManager = &CLSID_SharingConfigurationManager_Value;

const CLSID_NetworkConnections_Value = Guid.initString("7007acc7-3202-11d1-aad2-00805fc1270e");
pub const CLSID_NetworkConnections = &CLSID_NetworkConnections_Value;

const CLSID_ScheduledTasks_Value = Guid.initString("d6277990-4c6a-11cf-8d87-00aa0060f5bf");
pub const CLSID_ScheduledTasks = &CLSID_ScheduledTasks_Value;

const CLSID_ApplicationAssociationRegistration_Value = Guid.initString("591209c7-767b-42b2-9fba-44ee4615f2c7");
pub const CLSID_ApplicationAssociationRegistration = &CLSID_ApplicationAssociationRegistration_Value;

const CLSID_SearchFolderItemFactory_Value = Guid.initString("14010e02-bbbd-41f0-88e3-eda371216584");
pub const CLSID_SearchFolderItemFactory = &CLSID_SearchFolderItemFactory_Value;

const CLSID_OpenControlPanel_Value = Guid.initString("06622d85-6856-4460-8de1-a81921b41c4b");
pub const CLSID_OpenControlPanel = &CLSID_OpenControlPanel_Value;

const CLSID_MailRecipient_Value = Guid.initString("9e56be60-c50f-11cf-9a2c-00a0c90a90ce");
pub const CLSID_MailRecipient = &CLSID_MailRecipient_Value;

const CLSID_NetworkExplorerFolder_Value = Guid.initString("f02c1a0d-be21-4350-88b0-7367fc96ef3c");
pub const CLSID_NetworkExplorerFolder = &CLSID_NetworkExplorerFolder_Value;

const CLSID_DestinationList_Value = Guid.initString("77f10cf0-3db5-4966-b520-b7c54fd35ed6");
pub const CLSID_DestinationList = &CLSID_DestinationList_Value;

const CLSID_ApplicationDestinations_Value = Guid.initString("86c14003-4d6b-4ef3-a7b4-0506663b2e68");
pub const CLSID_ApplicationDestinations = &CLSID_ApplicationDestinations_Value;

const CLSID_ApplicationDocumentLists_Value = Guid.initString("86bec222-30f2-47e0-9f25-60d11cd75c28");
pub const CLSID_ApplicationDocumentLists = &CLSID_ApplicationDocumentLists_Value;

const CLSID_HomeGroup_Value = Guid.initString("de77ba04-3c92-4d11-a1a5-42352a53e0e3");
pub const CLSID_HomeGroup = &CLSID_HomeGroup_Value;

const CLSID_ShellLibrary_Value = Guid.initString("d9b3211d-e57f-4426-aaef-30a806add397");
pub const CLSID_ShellLibrary = &CLSID_ShellLibrary_Value;

const CLSID_AppStartupLink_Value = Guid.initString("273eb5e7-88b0-4843-bfef-e2c81d43aae5");
pub const CLSID_AppStartupLink = &CLSID_AppStartupLink_Value;

const CLSID_EnumerableObjectCollection_Value = Guid.initString("2d3468c1-36a7-43b6-ac24-d3f02fd9607a");
pub const CLSID_EnumerableObjectCollection = &CLSID_EnumerableObjectCollection_Value;

const CLSID_FrameworkInputPane_Value = Guid.initString("d5120aa3-46ba-44c5-822d-ca8092c1fc72");
pub const CLSID_FrameworkInputPane = &CLSID_FrameworkInputPane_Value;

const CLSID_DefFolderMenu_Value = Guid.initString("c63382be-7933-48d0-9ac8-85fb46be2fdd");
pub const CLSID_DefFolderMenu = &CLSID_DefFolderMenu_Value;

const CLSID_AppVisibility_Value = Guid.initString("7e5fe3d9-985f-4908-91f9-ee19f9fd1514");
pub const CLSID_AppVisibility = &CLSID_AppVisibility_Value;

const CLSID_AppShellVerbHandler_Value = Guid.initString("4ed3a719-cea8-4bd9-910d-e252f997afc2");
pub const CLSID_AppShellVerbHandler = &CLSID_AppShellVerbHandler_Value;

const CLSID_ExecuteUnknown_Value = Guid.initString("e44e9428-bdbc-4987-a099-40dc8fd255e7");
pub const CLSID_ExecuteUnknown = &CLSID_ExecuteUnknown_Value;

const CLSID_PackageDebugSettings_Value = Guid.initString("b1aec16f-2383-4852-b0e9-8f0b1dc66b4d");
pub const CLSID_PackageDebugSettings = &CLSID_PackageDebugSettings_Value;

const CLSID_SuspensionDependencyManager_Value = Guid.initString("6b273fc5-61fd-4918-95a2-c3b5e9d7f581");
pub const CLSID_SuspensionDependencyManager = &CLSID_SuspensionDependencyManager_Value;

const CLSID_ApplicationActivationManager_Value = Guid.initString("45ba127d-10a8-46ea-8ab7-56ea9078943c");
pub const CLSID_ApplicationActivationManager = &CLSID_ApplicationActivationManager_Value;

const CLSID_ApplicationDesignModeSettings_Value = Guid.initString("958a6fb5-dcb2-4faf-aafd-7fb054ad1a3b");
pub const CLSID_ApplicationDesignModeSettings = &CLSID_ApplicationDesignModeSettings_Value;

pub const CMINVOKECOMMANDINFO = extern struct {
    cbSize: u32,
    fMask: u32,
    hwnd: ?HWND,
    lpVerb: ?[*:0]const u8,
    lpParameters: ?[*:0]const u8,
    lpDirectory: ?[*:0]const u8,
    nShow: i32,
    dwHotKey: u32,
    hIcon: ?HANDLE,
};

pub const CMINVOKECOMMANDINFOEX = extern struct {
    cbSize: u32,
    fMask: u32,
    hwnd: ?HWND,
    lpVerb: ?[*:0]const u8,
    lpParameters: ?[*:0]const u8,
    lpDirectory: ?[*:0]const u8,
    nShow: i32,
    dwHotKey: u32,
    hIcon: ?HANDLE,
    lpTitle: ?[*:0]const u8,
    lpVerbW: ?[*:0]const u16,
    lpParametersW: ?[*:0]const u16,
    lpDirectoryW: ?[*:0]const u16,
    lpTitleW: ?[*:0]const u16,
    ptInvoke: POINT,
};

pub const CMINVOKECOMMANDINFOEX_REMOTE = extern struct {
    cbSize: u32,
    fMask: u32,
    hwnd: ?HWND,
    lpVerbString: ?[*:0]const u8,
    lpParameters: ?[*:0]const u8,
    lpDirectory: ?[*:0]const u8,
    nShow: i32,
    dwHotKey: u32,
    lpTitle: ?[*:0]const u8,
    lpVerbWString: ?[*:0]const u16,
    lpParametersW: ?[*:0]const u16,
    lpDirectoryW: ?[*:0]const u16,
    lpTitleW: ?[*:0]const u16,
    ptInvoke: POINT,
    lpVerbInt: u32,
    lpVerbWInt: u32,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IContextMenu_Value = Guid.initString("000214e4-0000-0000-c000-000000000046");
pub const IID_IContextMenu = &IID_IContextMenu_Value;
pub const IContextMenu = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryContextMenu: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IContextMenu,
                hmenu: ?HMENU,
                indexMenu: u32,
                idCmdFirst: u32,
                idCmdLast: u32,
                uFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IContextMenu,
                hmenu: ?HMENU,
                indexMenu: u32,
                idCmdFirst: u32,
                idCmdLast: u32,
                uFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InvokeCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IContextMenu,
                pici: ?*CMINVOKECOMMANDINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IContextMenu,
                pici: ?*CMINVOKECOMMANDINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCommandString: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IContextMenu,
                idCmd: usize,
                uType: u32,
                pReserved: ?*u32,
                pszName: ?PSTR,
                cchMax: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IContextMenu,
                idCmd: usize,
                uType: u32,
                pReserved: ?*u32,
                pszName: ?PSTR,
                cchMax: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IContextMenu_QueryContextMenu(self: *const T, hmenu: ?HMENU, indexMenu: u32, idCmdFirst: u32, idCmdLast: u32, uFlags: u32) HRESULT {
                return @as(*const IContextMenu.VTable, @ptrCast(self.vtable)).QueryContextMenu(@as(*const IContextMenu, @ptrCast(self)), hmenu, indexMenu, idCmdFirst, idCmdLast, uFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IContextMenu_InvokeCommand(self: *const T, pici: ?*CMINVOKECOMMANDINFO) HRESULT {
                return @as(*const IContextMenu.VTable, @ptrCast(self.vtable)).InvokeCommand(@as(*const IContextMenu, @ptrCast(self)), pici);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IContextMenu_GetCommandString(self: *const T, idCmd: usize, uType: u32, pReserved: ?*u32, pszName: ?PSTR, cchMax: u32) HRESULT {
                return @as(*const IContextMenu.VTable, @ptrCast(self.vtable)).GetCommandString(@as(*const IContextMenu, @ptrCast(self)), idCmd, uType, pReserved, pszName, cchMax);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IContextMenu2_Value = Guid.initString("000214f4-0000-0000-c000-000000000046");
pub const IID_IContextMenu2 = &IID_IContextMenu2_Value;
pub const IContextMenu2 = extern struct {
    pub const VTable = extern struct {
        base: IContextMenu.VTable,
        HandleMenuMsg: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IContextMenu2,
                uMsg: u32,
                wParam: WPARAM,
                lParam: LPARAM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IContextMenu2,
                uMsg: u32,
                wParam: WPARAM,
                lParam: LPARAM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IContextMenu.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IContextMenu2_HandleMenuMsg(self: *const T, uMsg: u32, wParam: WPARAM, lParam: LPARAM) HRESULT {
                return @as(*const IContextMenu2.VTable, @ptrCast(self.vtable)).HandleMenuMsg(@as(*const IContextMenu2, @ptrCast(self)), uMsg, wParam, lParam);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IContextMenu3_Value = Guid.initString("bcfce0a0-ec17-11d0-8d10-00a0c90f2719");
pub const IID_IContextMenu3 = &IID_IContextMenu3_Value;
pub const IContextMenu3 = extern struct {
    pub const VTable = extern struct {
        base: IContextMenu2.VTable,
        HandleMenuMsg2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IContextMenu3,
                uMsg: u32,
                wParam: WPARAM,
                lParam: LPARAM,
                plResult: ?*LRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IContextMenu3,
                uMsg: u32,
                wParam: WPARAM,
                lParam: LPARAM,
                plResult: ?*LRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IContextMenu2.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IContextMenu3_HandleMenuMsg2(self: *const T, uMsg: u32, wParam: WPARAM, lParam: LPARAM, plResult: ?*LRESULT) HRESULT {
                return @as(*const IContextMenu3.VTable, @ptrCast(self.vtable)).HandleMenuMsg2(@as(*const IContextMenu3, @ptrCast(self)), uMsg, wParam, lParam, plResult);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IExecuteCommand_Value = Guid.initString("7f9185b0-cb92-43c5-80a9-92277a4f7b54");
pub const IID_IExecuteCommand = &IID_IExecuteCommand_Value;
pub const IExecuteCommand = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetKeyState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IExecuteCommand,
                grfKeyState: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IExecuteCommand,
                grfKeyState: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IExecuteCommand,
                pszParameters: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IExecuteCommand,
                pszParameters: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IExecuteCommand,
                pt: POINT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IExecuteCommand,
                pt: POINT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetShowWindow: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IExecuteCommand,
                nShow: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IExecuteCommand,
                nShow: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetNoShowUI: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IExecuteCommand,
                fNoShowUI: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IExecuteCommand,
                fNoShowUI: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDirectory: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IExecuteCommand,
                pszDirectory: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IExecuteCommand,
                pszDirectory: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Execute: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IExecuteCommand,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IExecuteCommand,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IExecuteCommand_SetKeyState(self: *const T, grfKeyState: u32) HRESULT {
                return @as(*const IExecuteCommand.VTable, @ptrCast(self.vtable)).SetKeyState(@as(*const IExecuteCommand, @ptrCast(self)), grfKeyState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IExecuteCommand_SetParameters(self: *const T, pszParameters: ?[*:0]const u16) HRESULT {
                return @as(*const IExecuteCommand.VTable, @ptrCast(self.vtable)).SetParameters(@as(*const IExecuteCommand, @ptrCast(self)), pszParameters);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IExecuteCommand_SetPosition(self: *const T, pt: POINT) HRESULT {
                return @as(*const IExecuteCommand.VTable, @ptrCast(self.vtable)).SetPosition(@as(*const IExecuteCommand, @ptrCast(self)), pt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IExecuteCommand_SetShowWindow(self: *const T, nShow: i32) HRESULT {
                return @as(*const IExecuteCommand.VTable, @ptrCast(self.vtable)).SetShowWindow(@as(*const IExecuteCommand, @ptrCast(self)), nShow);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IExecuteCommand_SetNoShowUI(self: *const T, fNoShowUI: BOOL) HRESULT {
                return @as(*const IExecuteCommand.VTable, @ptrCast(self.vtable)).SetNoShowUI(@as(*const IExecuteCommand, @ptrCast(self)), fNoShowUI);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IExecuteCommand_SetDirectory(self: *const T, pszDirectory: ?[*:0]const u16) HRESULT {
                return @as(*const IExecuteCommand.VTable, @ptrCast(self.vtable)).SetDirectory(@as(*const IExecuteCommand, @ptrCast(self)), pszDirectory);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IExecuteCommand_Execute(self: *const T) HRESULT {
                return @as(*const IExecuteCommand.VTable, @ptrCast(self.vtable)).Execute(@as(*const IExecuteCommand, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IPersistFolder_Value = Guid.initString("000214ea-0000-0000-c000-000000000046");
pub const IID_IPersistFolder = &IID_IPersistFolder_Value;
pub const IPersistFolder = extern struct {
    pub const VTable = extern struct {
        base: IPersist.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPersistFolder,
                pidl: ?*ITEMIDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPersistFolder,
                pidl: ?*ITEMIDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IPersist.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPersistFolder_Initialize(self: *const T, pidl: ?*ITEMIDLIST) HRESULT {
                return @as(*const IPersistFolder.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IPersistFolder, @ptrCast(self)), pidl);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IRunnableTask_Value = Guid.initString("85788d00-6807-11d0-b810-00c04fd706ec");
pub const IID_IRunnableTask = &IID_IRunnableTask_Value;
pub const IRunnableTask = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Run: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRunnableTask,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRunnableTask,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Kill: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRunnableTask,
                bWait: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRunnableTask,
                bWait: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Suspend: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRunnableTask,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRunnableTask,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Resume: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRunnableTask,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRunnableTask,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsRunning: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRunnableTask,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn (
                self: *const IRunnableTask,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRunnableTask_Run(self: *const T) HRESULT {
                return @as(*const IRunnableTask.VTable, @ptrCast(self.vtable)).Run(@as(*const IRunnableTask, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRunnableTask_Kill(self: *const T, bWait: BOOL) HRESULT {
                return @as(*const IRunnableTask.VTable, @ptrCast(self.vtable)).Kill(@as(*const IRunnableTask, @ptrCast(self)), bWait);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRunnableTask_Suspend(self: *const T) HRESULT {
                return @as(*const IRunnableTask.VTable, @ptrCast(self.vtable)).Suspend(@as(*const IRunnableTask, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRunnableTask_Resume(self: *const T) HRESULT {
                return @as(*const IRunnableTask.VTable, @ptrCast(self.vtable)).Resume(@as(*const IRunnableTask, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRunnableTask_IsRunning(self: *const T) u32 {
                return @as(*const IRunnableTask.VTable, @ptrCast(self.vtable)).IsRunning(@as(*const IRunnableTask, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IShellTaskScheduler_Value = Guid.initString("6ccb7be0-6807-11d0-b810-00c04fd706ec");
pub const IID_IShellTaskScheduler = &IID_IShellTaskScheduler_Value;
pub const IShellTaskScheduler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddTask: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellTaskScheduler,
                prt: ?*IRunnableTask,
                rtoid: ?*const Guid,
                lParam: usize,
                dwPriority: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellTaskScheduler,
                prt: ?*IRunnableTask,
                rtoid: ?*const Guid,
                lParam: usize,
                dwPriority: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveTasks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellTaskScheduler,
                rtoid: ?*const Guid,
                lParam: usize,
                bWaitIfRunning: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellTaskScheduler,
                rtoid: ?*const Guid,
                lParam: usize,
                bWaitIfRunning: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CountTasks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellTaskScheduler,
                rtoid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn (
                self: *const IShellTaskScheduler,
                rtoid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
        Status: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellTaskScheduler,
                dwReleaseStatus: u32,
                dwThreadTimeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellTaskScheduler,
                dwReleaseStatus: u32,
                dwThreadTimeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellTaskScheduler_AddTask(self: *const T, prt: ?*IRunnableTask, rtoid: ?*const Guid, lParam: usize, dwPriority: u32) HRESULT {
                return @as(*const IShellTaskScheduler.VTable, @ptrCast(self.vtable)).AddTask(@as(*const IShellTaskScheduler, @ptrCast(self)), prt, rtoid, lParam, dwPriority);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellTaskScheduler_RemoveTasks(self: *const T, rtoid: ?*const Guid, lParam: usize, bWaitIfRunning: BOOL) HRESULT {
                return @as(*const IShellTaskScheduler.VTable, @ptrCast(self.vtable)).RemoveTasks(@as(*const IShellTaskScheduler, @ptrCast(self)), rtoid, lParam, bWaitIfRunning);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellTaskScheduler_CountTasks(self: *const T, rtoid: ?*const Guid) u32 {
                return @as(*const IShellTaskScheduler.VTable, @ptrCast(self.vtable)).CountTasks(@as(*const IShellTaskScheduler, @ptrCast(self)), rtoid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellTaskScheduler_Status(self: *const T, dwReleaseStatus: u32, dwThreadTimeout: u32) HRESULT {
                return @as(*const IShellTaskScheduler.VTable, @ptrCast(self.vtable)).Status(@as(*const IShellTaskScheduler, @ptrCast(self)), dwReleaseStatus, dwThreadTimeout);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IPersistFolder2_Value = Guid.initString("1ac3d9f0-175c-11d1-95be-00609797ea4f");
pub const IID_IPersistFolder2 = &IID_IPersistFolder2_Value;
pub const IPersistFolder2 = extern struct {
    pub const VTable = extern struct {
        base: IPersistFolder.VTable,
        GetCurFolder: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPersistFolder2,
                ppidl: ?*?*ITEMIDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPersistFolder2,
                ppidl: ?*?*ITEMIDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IPersistFolder.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPersistFolder2_GetCurFolder(self: *const T, ppidl: ?*?*ITEMIDLIST) HRESULT {
                return @as(*const IPersistFolder2.VTable, @ptrCast(self.vtable)).GetCurFolder(@as(*const IPersistFolder2, @ptrCast(self)), ppidl);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const PERSIST_FOLDER_TARGET_INFO = extern struct {
    pidlTargetFolder: ?*ITEMIDLIST,
    szTargetParsingName: [260]u16,
    szNetworkProvider: [260]u16,
    dwAttributes: u32,
    csidl: i32,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IPersistFolder3_Value = Guid.initString("cef04fdf-fe72-11d2-87a5-00c04f6837cf");
pub const IID_IPersistFolder3 = &IID_IPersistFolder3_Value;
pub const IPersistFolder3 = extern struct {
    pub const VTable = extern struct {
        base: IPersistFolder2.VTable,
        InitializeEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPersistFolder3,
                pbc: ?*IBindCtx,
                pidlRoot: ?*ITEMIDLIST,
                ppfti: ?*const PERSIST_FOLDER_TARGET_INFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPersistFolder3,
                pbc: ?*IBindCtx,
                pidlRoot: ?*ITEMIDLIST,
                ppfti: ?*const PERSIST_FOLDER_TARGET_INFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFolderTargetInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPersistFolder3,
                ppfti: ?*PERSIST_FOLDER_TARGET_INFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPersistFolder3,
                ppfti: ?*PERSIST_FOLDER_TARGET_INFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IPersistFolder2.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPersistFolder3_InitializeEx(self: *const T, pbc: ?*IBindCtx, pidlRoot: ?*ITEMIDLIST, ppfti: ?*const PERSIST_FOLDER_TARGET_INFO) HRESULT {
                return @as(*const IPersistFolder3.VTable, @ptrCast(self.vtable)).InitializeEx(@as(*const IPersistFolder3, @ptrCast(self)), pbc, pidlRoot, ppfti);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPersistFolder3_GetFolderTargetInfo(self: *const T, ppfti: ?*PERSIST_FOLDER_TARGET_INFO) HRESULT {
                return @as(*const IPersistFolder3.VTable, @ptrCast(self.vtable)).GetFolderTargetInfo(@as(*const IPersistFolder3, @ptrCast(self)), ppfti);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IPersistIDList_Value = Guid.initString("1079acfc-29bd-11d3-8e0d-00c04f6837d5");
pub const IID_IPersistIDList = &IID_IPersistIDList_Value;
pub const IPersistIDList = extern struct {
    pub const VTable = extern struct {
        base: IPersist.VTable,
        SetIDList: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPersistIDList,
                pidl: ?*ITEMIDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPersistIDList,
                pidl: ?*ITEMIDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIDList: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPersistIDList,
                ppidl: ?*?*ITEMIDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPersistIDList,
                ppidl: ?*?*ITEMIDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IPersist.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPersistIDList_SetIDList(self: *const T, pidl: ?*ITEMIDLIST) HRESULT {
                return @as(*const IPersistIDList.VTable, @ptrCast(self.vtable)).SetIDList(@as(*const IPersistIDList, @ptrCast(self)), pidl);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPersistIDList_GetIDList(self: *const T, ppidl: ?*?*ITEMIDLIST) HRESULT {
                return @as(*const IPersistIDList.VTable, @ptrCast(self.vtable)).GetIDList(@as(*const IPersistIDList, @ptrCast(self)), ppidl);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IEnumIDList_Value = Guid.initString("000214f2-0000-0000-c000-000000000046");
pub const IID_IEnumIDList = &IID_IEnumIDList_Value;
pub const IEnumIDList = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumIDList,
                celt: u32,
                rgelt: [*]?*ITEMIDLIST,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumIDList,
                celt: u32,
                rgelt: [*]?*ITEMIDLIST,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumIDList,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumIDList,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumIDList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumIDList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumIDList,
                ppenum: ?*?*IEnumIDList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumIDList,
                ppenum: ?*?*IEnumIDList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumIDList_Next(self: *const T, celt: u32, rgelt: [*]?*ITEMIDLIST, pceltFetched: ?*u32) HRESULT {
                return @as(*const IEnumIDList.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumIDList, @ptrCast(self)), celt, rgelt, pceltFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumIDList_Skip(self: *const T, celt: u32) HRESULT {
                return @as(*const IEnumIDList.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumIDList, @ptrCast(self)), celt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumIDList_Reset(self: *const T) HRESULT {
                return @as(*const IEnumIDList.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumIDList, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumIDList_Clone(self: *const T, ppenum: ?*?*IEnumIDList) HRESULT {
                return @as(*const IEnumIDList.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumIDList, @ptrCast(self)), ppenum);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IEnumFullIDList_Value = Guid.initString("d0191542-7954-4908-bc06-b2360bbe45ba");
pub const IID_IEnumFullIDList = &IID_IEnumFullIDList_Value;
pub const IEnumFullIDList = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumFullIDList,
                celt: u32,
                rgelt: [*]?*ITEMIDLIST,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumFullIDList,
                celt: u32,
                rgelt: [*]?*ITEMIDLIST,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumFullIDList,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumFullIDList,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumFullIDList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumFullIDList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumFullIDList,
                ppenum: ?*?*IEnumFullIDList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumFullIDList,
                ppenum: ?*?*IEnumFullIDList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumFullIDList_Next(self: *const T, celt: u32, rgelt: [*]?*ITEMIDLIST, pceltFetched: ?*u32) HRESULT {
                return @as(*const IEnumFullIDList.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumFullIDList, @ptrCast(self)), celt, rgelt, pceltFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumFullIDList_Skip(self: *const T, celt: u32) HRESULT {
                return @as(*const IEnumFullIDList.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumFullIDList, @ptrCast(self)), celt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumFullIDList_Reset(self: *const T) HRESULT {
                return @as(*const IEnumFullIDList.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumFullIDList, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumFullIDList_Clone(self: *const T, ppenum: ?*?*IEnumFullIDList) HRESULT {
                return @as(*const IEnumFullIDList.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumFullIDList, @ptrCast(self)), ppenum);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const _SHGDNF = enum(i32) {
    NORMAL = 0,
    INFOLDER = 1,
    FOREDITING = 4096,
    FORADDRESSBAR = 16384,
    FORPARSING = 32768,
};
pub const SHGDN_NORMAL = _SHGDNF.NORMAL;
pub const SHGDN_INFOLDER = _SHGDNF.INFOLDER;
pub const SHGDN_FOREDITING = _SHGDNF.FOREDITING;
pub const SHGDN_FORADDRESSBAR = _SHGDNF.FORADDRESSBAR;
pub const SHGDN_FORPARSING = _SHGDNF.FORPARSING;

pub const _SHCONTF = enum(i32) {
    CHECKING_FOR_CHILDREN = 16,
    FOLDERS = 32,
    NONFOLDERS = 64,
    INCLUDEHIDDEN = 128,
    INIT_ON_FIRST_NEXT = 256,
    NETPRINTERSRCH = 512,
    SHAREABLE = 1024,
    STORAGE = 2048,
    NAVIGATION_ENUM = 4096,
    FASTITEMS = 8192,
    FLATLIST = 16384,
    ENABLE_ASYNC = 32768,
    INCLUDESUPERHIDDEN = 65536,
};
pub const SHCONTF_CHECKING_FOR_CHILDREN = _SHCONTF.CHECKING_FOR_CHILDREN;
pub const SHCONTF_FOLDERS = _SHCONTF.FOLDERS;
pub const SHCONTF_NONFOLDERS = _SHCONTF.NONFOLDERS;
pub const SHCONTF_INCLUDEHIDDEN = _SHCONTF.INCLUDEHIDDEN;
pub const SHCONTF_INIT_ON_FIRST_NEXT = _SHCONTF.INIT_ON_FIRST_NEXT;
pub const SHCONTF_NETPRINTERSRCH = _SHCONTF.NETPRINTERSRCH;
pub const SHCONTF_SHAREABLE = _SHCONTF.SHAREABLE;
pub const SHCONTF_STORAGE = _SHCONTF.STORAGE;
pub const SHCONTF_NAVIGATION_ENUM = _SHCONTF.NAVIGATION_ENUM;
pub const SHCONTF_FASTITEMS = _SHCONTF.FASTITEMS;
pub const SHCONTF_FLATLIST = _SHCONTF.FLATLIST;
pub const SHCONTF_ENABLE_ASYNC = _SHCONTF.ENABLE_ASYNC;
pub const SHCONTF_INCLUDESUPERHIDDEN = _SHCONTF.INCLUDESUPERHIDDEN;

pub const STORAGE_PROVIDER_FILE_FLAGS = enum(i32) {
    NONE = 0,
    DOWNLOAD_BY_DEFAULT = 1,
    CREATED_ON_THIS_DEVICE = 2,
};
pub const SPFF_NONE = STORAGE_PROVIDER_FILE_FLAGS.NONE;
pub const SPFF_DOWNLOAD_BY_DEFAULT = STORAGE_PROVIDER_FILE_FLAGS.DOWNLOAD_BY_DEFAULT;
pub const SPFF_CREATED_ON_THIS_DEVICE = STORAGE_PROVIDER_FILE_FLAGS.CREATED_ON_THIS_DEVICE;

pub const MERGE_UPDATE_STATUS = enum(i32) {
    COMPLETE = 0,
    USERINPUTNEEDED = 1,
    FAILED = 2,
};
pub const MUS_COMPLETE = MERGE_UPDATE_STATUS.COMPLETE;
pub const MUS_USERINPUTNEEDED = MERGE_UPDATE_STATUS.USERINPUTNEEDED;
pub const MUS_FAILED = MERGE_UPDATE_STATUS.FAILED;

// TODO: this type is limited to platform 'windows8.1'
const IID_IFileSyncMergeHandler_Value = Guid.initString("d97b5aac-c792-433c-975d-35c4eadc7a9d");
pub const IID_IFileSyncMergeHandler = &IID_IFileSyncMergeHandler_Value;
pub const IFileSyncMergeHandler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Merge: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileSyncMergeHandler,
                localFilePath: ?[*:0]const u16,
                serverFilePath: ?[*:0]const u16,
                updateStatus: ?*MERGE_UPDATE_STATUS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileSyncMergeHandler,
                localFilePath: ?[*:0]const u16,
                serverFilePath: ?[*:0]const u16,
                updateStatus: ?*MERGE_UPDATE_STATUS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ShowResolveConflictUIAsync: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileSyncMergeHandler,
                localFilePath: ?[*:0]const u16,
                monitorToDisplayOn: ?HMONITOR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileSyncMergeHandler,
                localFilePath: ?[*:0]const u16,
                monitorToDisplayOn: ?HMONITOR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileSyncMergeHandler_Merge(self: *const T, localFilePath: ?[*:0]const u16, serverFilePath: ?[*:0]const u16, updateStatus: ?*MERGE_UPDATE_STATUS) HRESULT {
                return @as(*const IFileSyncMergeHandler.VTable, @ptrCast(self.vtable)).Merge(@as(*const IFileSyncMergeHandler, @ptrCast(self)), localFilePath, serverFilePath, updateStatus);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileSyncMergeHandler_ShowResolveConflictUIAsync(self: *const T, localFilePath: ?[*:0]const u16, monitorToDisplayOn: ?HMONITOR) HRESULT {
                return @as(*const IFileSyncMergeHandler.VTable, @ptrCast(self.vtable)).ShowResolveConflictUIAsync(@as(*const IFileSyncMergeHandler, @ptrCast(self)), localFilePath, monitorToDisplayOn);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const FOLDER_ENUM_MODE = enum(i32) {
    VIEWRESULT = 0,
    NAVIGATION = 1,
};
pub const FEM_VIEWRESULT = FOLDER_ENUM_MODE.VIEWRESULT;
pub const FEM_NAVIGATION = FOLDER_ENUM_MODE.NAVIGATION;

// TODO: this type is limited to platform 'windows6.1'
const IID_IObjectWithFolderEnumMode_Value = Guid.initString("6a9d9026-0e6e-464c-b000-42ecc07de673");
pub const IID_IObjectWithFolderEnumMode = &IID_IObjectWithFolderEnumMode_Value;
pub const IObjectWithFolderEnumMode = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IObjectWithFolderEnumMode,
                feMode: FOLDER_ENUM_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IObjectWithFolderEnumMode,
                feMode: FOLDER_ENUM_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IObjectWithFolderEnumMode,
                pfeMode: ?*FOLDER_ENUM_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IObjectWithFolderEnumMode,
                pfeMode: ?*FOLDER_ENUM_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IObjectWithFolderEnumMode_SetMode(self: *const T, feMode: FOLDER_ENUM_MODE) HRESULT {
                return @as(*const IObjectWithFolderEnumMode.VTable, @ptrCast(self.vtable)).SetMode(@as(*const IObjectWithFolderEnumMode, @ptrCast(self)), feMode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IObjectWithFolderEnumMode_GetMode(self: *const T, pfeMode: ?*FOLDER_ENUM_MODE) HRESULT {
                return @as(*const IObjectWithFolderEnumMode.VTable, @ptrCast(self.vtable)).GetMode(@as(*const IObjectWithFolderEnumMode, @ptrCast(self)), pfeMode);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IParseAndCreateItem_Value = Guid.initString("67efed0e-e827-4408-b493-78f3982b685c");
pub const IID_IParseAndCreateItem = &IID_IParseAndCreateItem_Value;
pub const IParseAndCreateItem = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IParseAndCreateItem,
                psi: ?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IParseAndCreateItem,
                psi: ?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IParseAndCreateItem,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IParseAndCreateItem,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IParseAndCreateItem_SetItem(self: *const T, psi: ?*IShellItem) HRESULT {
                return @as(*const IParseAndCreateItem.VTable, @ptrCast(self.vtable)).SetItem(@as(*const IParseAndCreateItem, @ptrCast(self)), psi);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IParseAndCreateItem_GetItem(self: *const T, riid: ?*const Guid, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const IParseAndCreateItem.VTable, @ptrCast(self.vtable)).GetItem(@as(*const IParseAndCreateItem, @ptrCast(self)), riid, ppv);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IShellFolder_Value = Guid.initString("000214e6-0000-0000-c000-000000000046");
pub const IID_IShellFolder = &IID_IShellFolder_Value;
pub const IShellFolder = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ParseDisplayName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellFolder,
                hwnd: ?HWND,
                pbc: ?*IBindCtx,
                pszDisplayName: ?PWSTR,
                pchEaten: ?*u32,
                ppidl: ?*?*ITEMIDLIST,
                pdwAttributes: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellFolder,
                hwnd: ?HWND,
                pbc: ?*IBindCtx,
                pszDisplayName: ?PWSTR,
                pchEaten: ?*u32,
                ppidl: ?*?*ITEMIDLIST,
                pdwAttributes: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumObjects: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellFolder,
                hwnd: ?HWND,
                grfFlags: u32,
                ppenumIDList: ?*?*IEnumIDList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellFolder,
                hwnd: ?HWND,
                grfFlags: u32,
                ppenumIDList: ?*?*IEnumIDList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BindToObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellFolder,
                pidl: ?*ITEMIDLIST,
                pbc: ?*IBindCtx,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellFolder,
                pidl: ?*ITEMIDLIST,
                pbc: ?*IBindCtx,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BindToStorage: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellFolder,
                pidl: ?*ITEMIDLIST,
                pbc: ?*IBindCtx,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellFolder,
                pidl: ?*ITEMIDLIST,
                pbc: ?*IBindCtx,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CompareIDs: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellFolder,
                lParam: LPARAM,
                pidl1: ?*ITEMIDLIST,
                pidl2: ?*ITEMIDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellFolder,
                lParam: LPARAM,
                pidl1: ?*ITEMIDLIST,
                pidl2: ?*ITEMIDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateViewObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellFolder,
                hwndOwner: ?HWND,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellFolder,
                hwndOwner: ?HWND,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAttributesOf: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellFolder,
                cidl: u32,
                apidl: [*]?*ITEMIDLIST,
                rgfInOut: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellFolder,
                cidl: u32,
                apidl: [*]?*ITEMIDLIST,
                rgfInOut: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetUIObjectOf: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellFolder,
                hwndOwner: ?HWND,
                cidl: u32,
                apidl: [*]?*ITEMIDLIST,
                riid: ?*const Guid,
                rgfReserved: ?*u32,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellFolder,
                hwndOwner: ?HWND,
                cidl: u32,
                apidl: [*]?*ITEMIDLIST,
                riid: ?*const Guid,
                rgfReserved: ?*u32,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDisplayNameOf: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellFolder,
                pidl: ?*ITEMIDLIST,
                uFlags: u32,
                pName: ?*STRRET,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellFolder,
                pidl: ?*ITEMIDLIST,
                uFlags: u32,
                pName: ?*STRRET,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetNameOf: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellFolder,
                hwnd: ?HWND,
                pidl: ?*ITEMIDLIST,
                pszName: ?[*:0]const u16,
                uFlags: u32,
                ppidlOut: ?*?*ITEMIDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellFolder,
                hwnd: ?HWND,
                pidl: ?*ITEMIDLIST,
                pszName: ?[*:0]const u16,
                uFlags: u32,
                ppidlOut: ?*?*ITEMIDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellFolder_ParseDisplayName(self: *const T, hwnd: ?HWND, pbc: ?*IBindCtx, pszDisplayName: ?PWSTR, pchEaten: ?*u32, ppidl: ?*?*ITEMIDLIST, pdwAttributes: ?*u32) HRESULT {
                return @as(*const IShellFolder.VTable, @ptrCast(self.vtable)).ParseDisplayName(@as(*const IShellFolder, @ptrCast(self)), hwnd, pbc, pszDisplayName, pchEaten, ppidl, pdwAttributes);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellFolder_EnumObjects(self: *const T, hwnd: ?HWND, grfFlags: u32, ppenumIDList: ?*?*IEnumIDList) HRESULT {
                return @as(*const IShellFolder.VTable, @ptrCast(self.vtable)).EnumObjects(@as(*const IShellFolder, @ptrCast(self)), hwnd, grfFlags, ppenumIDList);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellFolder_BindToObject(self: *const T, pidl: ?*ITEMIDLIST, pbc: ?*IBindCtx, riid: ?*const Guid, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const IShellFolder.VTable, @ptrCast(self.vtable)).BindToObject(@as(*const IShellFolder, @ptrCast(self)), pidl, pbc, riid, ppv);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellFolder_BindToStorage(self: *const T, pidl: ?*ITEMIDLIST, pbc: ?*IBindCtx, riid: ?*const Guid, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const IShellFolder.VTable, @ptrCast(self.vtable)).BindToStorage(@as(*const IShellFolder, @ptrCast(self)), pidl, pbc, riid, ppv);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellFolder_CompareIDs(self: *const T, lParam: LPARAM, pidl1: ?*ITEMIDLIST, pidl2: ?*ITEMIDLIST) HRESULT {
                return @as(*const IShellFolder.VTable, @ptrCast(self.vtable)).CompareIDs(@as(*const IShellFolder, @ptrCast(self)), lParam, pidl1, pidl2);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellFolder_CreateViewObject(self: *const T, hwndOwner: ?HWND, riid: ?*const Guid, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const IShellFolder.VTable, @ptrCast(self.vtable)).CreateViewObject(@as(*const IShellFolder, @ptrCast(self)), hwndOwner, riid, ppv);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellFolder_GetAttributesOf(self: *const T, cidl: u32, apidl: [*]?*ITEMIDLIST, rgfInOut: ?*u32) HRESULT {
                return @as(*const IShellFolder.VTable, @ptrCast(self.vtable)).GetAttributesOf(@as(*const IShellFolder, @ptrCast(self)), cidl, apidl, rgfInOut);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellFolder_GetUIObjectOf(self: *const T, hwndOwner: ?HWND, cidl: u32, apidl: [*]?*ITEMIDLIST, riid: ?*const Guid, rgfReserved: ?*u32, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const IShellFolder.VTable, @ptrCast(self.vtable)).GetUIObjectOf(@as(*const IShellFolder, @ptrCast(self)), hwndOwner, cidl, apidl, riid, rgfReserved, ppv);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellFolder_GetDisplayNameOf(self: *const T, pidl: ?*ITEMIDLIST, uFlags: u32, pName: ?*STRRET) HRESULT {
                return @as(*const IShellFolder.VTable, @ptrCast(self.vtable)).GetDisplayNameOf(@as(*const IShellFolder, @ptrCast(self)), pidl, uFlags, pName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellFolder_SetNameOf(self: *const T, hwnd: ?HWND, pidl: ?*ITEMIDLIST, pszName: ?[*:0]const u16, uFlags: u32, ppidlOut: ?*?*ITEMIDLIST) HRESULT {
                return @as(*const IShellFolder.VTable, @ptrCast(self.vtable)).SetNameOf(@as(*const IShellFolder, @ptrCast(self)), hwnd, pidl, pszName, uFlags, ppidlOut);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const EXTRASEARCH = extern struct {
    guidSearch: Guid,
    wszFriendlyName: [80]u16,
    wszUrl: [2084]u16,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumExtraSearch_Value = Guid.initString("0e700be1-9db6-11d1-a1ce-00c04fd75d13");
pub const IID_IEnumExtraSearch = &IID_IEnumExtraSearch_Value;
pub const IEnumExtraSearch = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumExtraSearch,
                celt: u32,
                rgelt: [*]EXTRASEARCH,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumExtraSearch,
                celt: u32,
                rgelt: [*]EXTRASEARCH,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumExtraSearch,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumExtraSearch,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumExtraSearch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumExtraSearch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumExtraSearch,
                ppenum: ?*?*IEnumExtraSearch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumExtraSearch,
                ppenum: ?*?*IEnumExtraSearch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumExtraSearch_Next(self: *const T, celt: u32, rgelt: [*]EXTRASEARCH, pceltFetched: ?*u32) HRESULT {
                return @as(*const IEnumExtraSearch.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumExtraSearch, @ptrCast(self)), celt, rgelt, pceltFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumExtraSearch_Skip(self: *const T, celt: u32) HRESULT {
                return @as(*const IEnumExtraSearch.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumExtraSearch, @ptrCast(self)), celt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumExtraSearch_Reset(self: *const T) HRESULT {
                return @as(*const IEnumExtraSearch.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumExtraSearch, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumExtraSearch_Clone(self: *const T, ppenum: ?*?*IEnumExtraSearch) HRESULT {
                return @as(*const IEnumExtraSearch.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumExtraSearch, @ptrCast(self)), ppenum);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IShellFolder2_Value = Guid.initString("93f2f68c-1d1b-11d3-a30e-00c04f79abd1");
pub const IID_IShellFolder2 = &IID_IShellFolder2_Value;
pub const IShellFolder2 = extern struct {
    pub const VTable = extern struct {
        base: IShellFolder.VTable,
        GetDefaultSearchGUID: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellFolder2,
                pguid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellFolder2,
                pguid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumSearches: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellFolder2,
                ppenum: ?*?*IEnumExtraSearch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellFolder2,
                ppenum: ?*?*IEnumExtraSearch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDefaultColumn: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellFolder2,
                dwRes: u32,
                pSort: ?*u32,
                pDisplay: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellFolder2,
                dwRes: u32,
                pSort: ?*u32,
                pDisplay: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDefaultColumnState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellFolder2,
                iColumn: u32,
                pcsFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellFolder2,
                iColumn: u32,
                pcsFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDetailsEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellFolder2,
                pidl: ?*ITEMIDLIST,
                pscid: ?*const PROPERTYKEY,
                pv: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellFolder2,
                pidl: ?*ITEMIDLIST,
                pscid: ?*const PROPERTYKEY,
                pv: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDetailsOf: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellFolder2,
                pidl: ?*ITEMIDLIST,
                iColumn: u32,
                psd: ?*SHELLDETAILS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellFolder2,
                pidl: ?*ITEMIDLIST,
                iColumn: u32,
                psd: ?*SHELLDETAILS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        MapColumnToSCID: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellFolder2,
                iColumn: u32,
                pscid: ?*PROPERTYKEY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellFolder2,
                iColumn: u32,
                pscid: ?*PROPERTYKEY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IShellFolder.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellFolder2_GetDefaultSearchGUID(self: *const T, pguid: ?*Guid) HRESULT {
                return @as(*const IShellFolder2.VTable, @ptrCast(self.vtable)).GetDefaultSearchGUID(@as(*const IShellFolder2, @ptrCast(self)), pguid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellFolder2_EnumSearches(self: *const T, ppenum: ?*?*IEnumExtraSearch) HRESULT {
                return @as(*const IShellFolder2.VTable, @ptrCast(self.vtable)).EnumSearches(@as(*const IShellFolder2, @ptrCast(self)), ppenum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellFolder2_GetDefaultColumn(self: *const T, dwRes: u32, pSort: ?*u32, pDisplay: ?*u32) HRESULT {
                return @as(*const IShellFolder2.VTable, @ptrCast(self.vtable)).GetDefaultColumn(@as(*const IShellFolder2, @ptrCast(self)), dwRes, pSort, pDisplay);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellFolder2_GetDefaultColumnState(self: *const T, iColumn: u32, pcsFlags: ?*u32) HRESULT {
                return @as(*const IShellFolder2.VTable, @ptrCast(self.vtable)).GetDefaultColumnState(@as(*const IShellFolder2, @ptrCast(self)), iColumn, pcsFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellFolder2_GetDetailsEx(self: *const T, pidl: ?*ITEMIDLIST, pscid: ?*const PROPERTYKEY, pv: ?*VARIANT) HRESULT {
                return @as(*const IShellFolder2.VTable, @ptrCast(self.vtable)).GetDetailsEx(@as(*const IShellFolder2, @ptrCast(self)), pidl, pscid, pv);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellFolder2_GetDetailsOf(self: *const T, pidl: ?*ITEMIDLIST, iColumn: u32, psd: ?*SHELLDETAILS) HRESULT {
                return @as(*const IShellFolder2.VTable, @ptrCast(self.vtable)).GetDetailsOf(@as(*const IShellFolder2, @ptrCast(self)), pidl, iColumn, psd);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellFolder2_MapColumnToSCID(self: *const T, iColumn: u32, pscid: ?*PROPERTYKEY) HRESULT {
                return @as(*const IShellFolder2.VTable, @ptrCast(self.vtable)).MapColumnToSCID(@as(*const IShellFolder2, @ptrCast(self)), iColumn, pscid);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const FOLDERFLAGS = enum(i32) {
    NONE = 0,
    AUTOARRANGE = 1,
    ABBREVIATEDNAMES = 2,
    SNAPTOGRID = 4,
    OWNERDATA = 8,
    BESTFITWINDOW = 16,
    DESKTOP = 32,
    SINGLESEL = 64,
    NOSUBFOLDERS = 128,
    TRANSPARENT = 256,
    NOCLIENTEDGE = 512,
    NOSCROLL = 1024,
    ALIGNLEFT = 2048,
    NOICONS = 4096,
    SHOWSELALWAYS = 8192,
    NOVISIBLE = 16384,
    SINGLECLICKACTIVATE = 32768,
    NOWEBVIEW = 65536,
    HIDEFILENAMES = 131072,
    CHECKSELECT = 262144,
    NOENUMREFRESH = 524288,
    NOGROUPING = 1048576,
    FULLROWSELECT = 2097152,
    NOFILTERS = 4194304,
    NOCOLUMNHEADER = 8388608,
    NOHEADERINALLVIEWS = 16777216,
    EXTENDEDTILES = 33554432,
    TRICHECKSELECT = 67108864,
    AUTOCHECKSELECT = 134217728,
    NOBROWSERVIEWSTATE = 268435456,
    SUBSETGROUPS = 536870912,
    USESEARCHFOLDER = 1073741824,
    ALLOWRTLREADING = -2147483648,
};
pub const FWF_NONE = FOLDERFLAGS.NONE;
pub const FWF_AUTOARRANGE = FOLDERFLAGS.AUTOARRANGE;
pub const FWF_ABBREVIATEDNAMES = FOLDERFLAGS.ABBREVIATEDNAMES;
pub const FWF_SNAPTOGRID = FOLDERFLAGS.SNAPTOGRID;
pub const FWF_OWNERDATA = FOLDERFLAGS.OWNERDATA;
pub const FWF_BESTFITWINDOW = FOLDERFLAGS.BESTFITWINDOW;
pub const FWF_DESKTOP = FOLDERFLAGS.DESKTOP;
pub const FWF_SINGLESEL = FOLDERFLAGS.SINGLESEL;
pub const FWF_NOSUBFOLDERS = FOLDERFLAGS.NOSUBFOLDERS;
pub const FWF_TRANSPARENT = FOLDERFLAGS.TRANSPARENT;
pub const FWF_NOCLIENTEDGE = FOLDERFLAGS.NOCLIENTEDGE;
pub const FWF_NOSCROLL = FOLDERFLAGS.NOSCROLL;
pub const FWF_ALIGNLEFT = FOLDERFLAGS.ALIGNLEFT;
pub const FWF_NOICONS = FOLDERFLAGS.NOICONS;
pub const FWF_SHOWSELALWAYS = FOLDERFLAGS.SHOWSELALWAYS;
pub const FWF_NOVISIBLE = FOLDERFLAGS.NOVISIBLE;
pub const FWF_SINGLECLICKACTIVATE = FOLDERFLAGS.SINGLECLICKACTIVATE;
pub const FWF_NOWEBVIEW = FOLDERFLAGS.NOWEBVIEW;
pub const FWF_HIDEFILENAMES = FOLDERFLAGS.HIDEFILENAMES;
pub const FWF_CHECKSELECT = FOLDERFLAGS.CHECKSELECT;
pub const FWF_NOENUMREFRESH = FOLDERFLAGS.NOENUMREFRESH;
pub const FWF_NOGROUPING = FOLDERFLAGS.NOGROUPING;
pub const FWF_FULLROWSELECT = FOLDERFLAGS.FULLROWSELECT;
pub const FWF_NOFILTERS = FOLDERFLAGS.NOFILTERS;
pub const FWF_NOCOLUMNHEADER = FOLDERFLAGS.NOCOLUMNHEADER;
pub const FWF_NOHEADERINALLVIEWS = FOLDERFLAGS.NOHEADERINALLVIEWS;
pub const FWF_EXTENDEDTILES = FOLDERFLAGS.EXTENDEDTILES;
pub const FWF_TRICHECKSELECT = FOLDERFLAGS.TRICHECKSELECT;
pub const FWF_AUTOCHECKSELECT = FOLDERFLAGS.AUTOCHECKSELECT;
pub const FWF_NOBROWSERVIEWSTATE = FOLDERFLAGS.NOBROWSERVIEWSTATE;
pub const FWF_SUBSETGROUPS = FOLDERFLAGS.SUBSETGROUPS;
pub const FWF_USESEARCHFOLDER = FOLDERFLAGS.USESEARCHFOLDER;
pub const FWF_ALLOWRTLREADING = FOLDERFLAGS.ALLOWRTLREADING;

pub const FOLDERVIEWMODE = enum(i32) {
    AUTO = -1,
    FIRST = 1,
    // ICON = 1, this enum value conflicts with FIRST
    SMALLICON = 2,
    LIST = 3,
    DETAILS = 4,
    THUMBNAIL = 5,
    TILE = 6,
    THUMBSTRIP = 7,
    CONTENT = 8,
    // LAST = 8, this enum value conflicts with CONTENT
};
pub const FVM_AUTO = FOLDERVIEWMODE.AUTO;
pub const FVM_FIRST = FOLDERVIEWMODE.FIRST;
pub const FVM_ICON = FOLDERVIEWMODE.FIRST;
pub const FVM_SMALLICON = FOLDERVIEWMODE.SMALLICON;
pub const FVM_LIST = FOLDERVIEWMODE.LIST;
pub const FVM_DETAILS = FOLDERVIEWMODE.DETAILS;
pub const FVM_THUMBNAIL = FOLDERVIEWMODE.THUMBNAIL;
pub const FVM_TILE = FOLDERVIEWMODE.TILE;
pub const FVM_THUMBSTRIP = FOLDERVIEWMODE.THUMBSTRIP;
pub const FVM_CONTENT = FOLDERVIEWMODE.CONTENT;
pub const FVM_LAST = FOLDERVIEWMODE.CONTENT;

pub const FOLDERLOGICALVIEWMODE = enum(i32) {
    UNSPECIFIED = -1,
    FIRST = 1,
    // DETAILS = 1, this enum value conflicts with FIRST
    TILES = 2,
    ICONS = 3,
    LIST = 4,
    CONTENT = 5,
    // LAST = 5, this enum value conflicts with CONTENT
};
pub const FLVM_UNSPECIFIED = FOLDERLOGICALVIEWMODE.UNSPECIFIED;
pub const FLVM_FIRST = FOLDERLOGICALVIEWMODE.FIRST;
pub const FLVM_DETAILS = FOLDERLOGICALVIEWMODE.FIRST;
pub const FLVM_TILES = FOLDERLOGICALVIEWMODE.TILES;
pub const FLVM_ICONS = FOLDERLOGICALVIEWMODE.ICONS;
pub const FLVM_LIST = FOLDERLOGICALVIEWMODE.LIST;
pub const FLVM_CONTENT = FOLDERLOGICALVIEWMODE.CONTENT;
pub const FLVM_LAST = FOLDERLOGICALVIEWMODE.CONTENT;

pub const FOLDERSETTINGS = extern struct {
    ViewMode: u32,
    fFlags: u32,
};

pub const _SVSIF = enum(i32) {
    DESELECT = 0,
    SELECT = 1,
    EDIT = 3,
    DESELECTOTHERS = 4,
    ENSUREVISIBLE = 8,
    FOCUSED = 16,
    TRANSLATEPT = 32,
    SELECTIONMARK = 64,
    POSITIONITEM = 128,
    CHECK = 256,
    CHECK2 = 512,
    KEYBOARDSELECT = 1025,
    NOTAKEFOCUS = 1073741824,
};
pub const SVSI_DESELECT = _SVSIF.DESELECT;
pub const SVSI_SELECT = _SVSIF.SELECT;
pub const SVSI_EDIT = _SVSIF.EDIT;
pub const SVSI_DESELECTOTHERS = _SVSIF.DESELECTOTHERS;
pub const SVSI_ENSUREVISIBLE = _SVSIF.ENSUREVISIBLE;
pub const SVSI_FOCUSED = _SVSIF.FOCUSED;
pub const SVSI_TRANSLATEPT = _SVSIF.TRANSLATEPT;
pub const SVSI_SELECTIONMARK = _SVSIF.SELECTIONMARK;
pub const SVSI_POSITIONITEM = _SVSIF.POSITIONITEM;
pub const SVSI_CHECK = _SVSIF.CHECK;
pub const SVSI_CHECK2 = _SVSIF.CHECK2;
pub const SVSI_KEYBOARDSELECT = _SVSIF.KEYBOARDSELECT;
pub const SVSI_NOTAKEFOCUS = _SVSIF.NOTAKEFOCUS;

pub const _SVGIO = enum(i32) {
    BACKGROUND = 0,
    SELECTION = 1,
    ALLVIEW = 2,
    CHECKED = 3,
    TYPE_MASK = 15,
    FLAG_VIEWORDER = -2147483648,
};
pub const SVGIO_BACKGROUND = _SVGIO.BACKGROUND;
pub const SVGIO_SELECTION = _SVGIO.SELECTION;
pub const SVGIO_ALLVIEW = _SVGIO.ALLVIEW;
pub const SVGIO_CHECKED = _SVGIO.CHECKED;
pub const SVGIO_TYPE_MASK = _SVGIO.TYPE_MASK;
pub const SVGIO_FLAG_VIEWORDER = _SVGIO.FLAG_VIEWORDER;

pub const SVUIA_STATUS = enum(i32) {
    DEACTIVATE = 0,
    ACTIVATE_NOFOCUS = 1,
    ACTIVATE_FOCUS = 2,
    INPLACEACTIVATE = 3,
};
pub const SVUIA_DEACTIVATE = SVUIA_STATUS.DEACTIVATE;
pub const SVUIA_ACTIVATE_NOFOCUS = SVUIA_STATUS.ACTIVATE_NOFOCUS;
pub const SVUIA_ACTIVATE_FOCUS = SVUIA_STATUS.ACTIVATE_FOCUS;
pub const SVUIA_INPLACEACTIVATE = SVUIA_STATUS.INPLACEACTIVATE;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IShellView_Value = Guid.initString("000214e3-0000-0000-c000-000000000046");
pub const IID_IShellView = &IID_IShellView_Value;
pub const IShellView = extern struct {
    pub const VTable = extern struct {
        base: IOleWindow.VTable,
        TranslateAccelerator: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellView,
                pmsg: ?*MSG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellView,
                pmsg: ?*MSG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnableModeless: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellView,
                fEnable: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellView,
                fEnable: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UIActivate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellView,
                uState: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellView,
                uState: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Refresh: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellView,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellView,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateViewWindow: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellView,
                psvPrevious: ?*IShellView,
                pfs: ?*FOLDERSETTINGS,
                psb: ?*IShellBrowser,
                prcView: ?*RECT,
                phWnd: ?*?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellView,
                psvPrevious: ?*IShellView,
                pfs: ?*FOLDERSETTINGS,
                psb: ?*IShellBrowser,
                prcView: ?*RECT,
                phWnd: ?*?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DestroyViewWindow: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellView,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellView,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellView,
                pfs: ?*FOLDERSETTINGS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellView,
                pfs: ?*FOLDERSETTINGS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddPropertySheetPages: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellView,
                dwReserved: u32,
                pfn: ?LPFNSVADDPROPSHEETPAGE,
                lparam: LPARAM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellView,
                dwReserved: u32,
                pfn: ?LPFNSVADDPROPSHEETPAGE,
                lparam: LPARAM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SaveViewState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellView,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellView,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SelectItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellView,
                pidlItem: ?*ITEMIDLIST,
                uFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellView,
                pidlItem: ?*ITEMIDLIST,
                uFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetItemObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellView,
                uItem: u32,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellView,
                uItem: u32,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IOleWindow.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellView_TranslateAccelerator(self: *const T, pmsg: ?*MSG) HRESULT {
                return @as(*const IShellView.VTable, @ptrCast(self.vtable)).TranslateAccelerator(@as(*const IShellView, @ptrCast(self)), pmsg);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellView_EnableModeless(self: *const T, fEnable: BOOL) HRESULT {
                return @as(*const IShellView.VTable, @ptrCast(self.vtable)).EnableModeless(@as(*const IShellView, @ptrCast(self)), fEnable);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellView_UIActivate(self: *const T, uState: u32) HRESULT {
                return @as(*const IShellView.VTable, @ptrCast(self.vtable)).UIActivate(@as(*const IShellView, @ptrCast(self)), uState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellView_Refresh(self: *const T) HRESULT {
                return @as(*const IShellView.VTable, @ptrCast(self.vtable)).Refresh(@as(*const IShellView, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellView_CreateViewWindow(self: *const T, psvPrevious: ?*IShellView, pfs: ?*FOLDERSETTINGS, psb: ?*IShellBrowser, prcView: ?*RECT, phWnd: ?*?HWND) HRESULT {
                return @as(*const IShellView.VTable, @ptrCast(self.vtable)).CreateViewWindow(@as(*const IShellView, @ptrCast(self)), psvPrevious, pfs, psb, prcView, phWnd);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellView_DestroyViewWindow(self: *const T) HRESULT {
                return @as(*const IShellView.VTable, @ptrCast(self.vtable)).DestroyViewWindow(@as(*const IShellView, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellView_GetCurrentInfo(self: *const T, pfs: ?*FOLDERSETTINGS) HRESULT {
                return @as(*const IShellView.VTable, @ptrCast(self.vtable)).GetCurrentInfo(@as(*const IShellView, @ptrCast(self)), pfs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellView_AddPropertySheetPages(self: *const T, dwReserved: u32, pfn: ?LPFNSVADDPROPSHEETPAGE, lparam: LPARAM) HRESULT {
                return @as(*const IShellView.VTable, @ptrCast(self.vtable)).AddPropertySheetPages(@as(*const IShellView, @ptrCast(self)), dwReserved, pfn, lparam);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellView_SaveViewState(self: *const T) HRESULT {
                return @as(*const IShellView.VTable, @ptrCast(self.vtable)).SaveViewState(@as(*const IShellView, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellView_SelectItem(self: *const T, pidlItem: ?*ITEMIDLIST, uFlags: u32) HRESULT {
                return @as(*const IShellView.VTable, @ptrCast(self.vtable)).SelectItem(@as(*const IShellView, @ptrCast(self)), pidlItem, uFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellView_GetItemObject(self: *const T, uItem: u32, riid: ?*const Guid, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const IShellView.VTable, @ptrCast(self.vtable)).GetItemObject(@as(*const IShellView, @ptrCast(self)), uItem, riid, ppv);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SV2CVW2_PARAMS = extern struct {
    cbSize: u32,
    psvPrev: ?*IShellView,
    pfs: ?*FOLDERSETTINGS,
    psbOwner: ?*IShellBrowser,
    prcView: ?*RECT,
    pvid: ?*const Guid,
    hwndView: ?HWND,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IShellView2_Value = Guid.initString("88e39e80-3578-11cf-ae69-08002b2e1262");
pub const IID_IShellView2 = &IID_IShellView2_Value;
pub const IShellView2 = extern struct {
    pub const VTable = extern struct {
        base: IShellView.VTable,
        GetView: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellView2,
                pvid: ?*Guid,
                uView: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellView2,
                pvid: ?*Guid,
                uView: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateViewWindow2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellView2,
                lpParams: ?*SV2CVW2_PARAMS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellView2,
                lpParams: ?*SV2CVW2_PARAMS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        HandleRename: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellView2,
                pidlNew: ?*ITEMIDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellView2,
                pidlNew: ?*ITEMIDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SelectAndPositionItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellView2,
                pidlItem: ?*ITEMIDLIST,
                uFlags: u32,
                ppt: ?*POINT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellView2,
                pidlItem: ?*ITEMIDLIST,
                uFlags: u32,
                ppt: ?*POINT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IShellView.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellView2_GetView(self: *const T, pvid: ?*Guid, uView: u32) HRESULT {
                return @as(*const IShellView2.VTable, @ptrCast(self.vtable)).GetView(@as(*const IShellView2, @ptrCast(self)), pvid, uView);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellView2_CreateViewWindow2(self: *const T, lpParams: ?*SV2CVW2_PARAMS) HRESULT {
                return @as(*const IShellView2.VTable, @ptrCast(self.vtable)).CreateViewWindow2(@as(*const IShellView2, @ptrCast(self)), lpParams);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellView2_HandleRename(self: *const T, pidlNew: ?*ITEMIDLIST) HRESULT {
                return @as(*const IShellView2.VTable, @ptrCast(self.vtable)).HandleRename(@as(*const IShellView2, @ptrCast(self)), pidlNew);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellView2_SelectAndPositionItem(self: *const T, pidlItem: ?*ITEMIDLIST, uFlags: u32, ppt: ?*POINT) HRESULT {
                return @as(*const IShellView2.VTable, @ptrCast(self.vtable)).SelectAndPositionItem(@as(*const IShellView2, @ptrCast(self)), pidlItem, uFlags, ppt);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IFolderView_Value = Guid.initString("cde725b0-ccc9-4519-917e-325d72fab4ce");
pub const IID_IFolderView = &IID_IFolderView_Value;
pub const IFolderView = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCurrentViewMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFolderView,
                pViewMode: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFolderView,
                pViewMode: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCurrentViewMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFolderView,
                ViewMode: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFolderView,
                ViewMode: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFolder: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFolderView,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFolderView,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Item: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFolderView,
                iItemIndex: i32,
                ppidl: ?*?*ITEMIDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFolderView,
                iItemIndex: i32,
                ppidl: ?*?*ITEMIDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ItemCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFolderView,
                uFlags: u32,
                pcItems: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFolderView,
                uFlags: u32,
                pcItems: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Items: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFolderView,
                uFlags: u32,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFolderView,
                uFlags: u32,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSelectionMarkedItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFolderView,
                piItem: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFolderView,
                piItem: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFocusedItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFolderView,
                piItem: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFolderView,
                piItem: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetItemPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFolderView,
                pidl: ?*ITEMIDLIST,
                ppt: ?*POINT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFolderView,
                pidl: ?*ITEMIDLIST,
                ppt: ?*POINT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSpacing: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFolderView,
                ppt: ?*POINT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFolderView,
                ppt: ?*POINT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDefaultSpacing: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFolderView,
                ppt: ?*POINT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFolderView,
                ppt: ?*POINT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAutoArrange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFolderView,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFolderView,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SelectItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFolderView,
                iItem: i32,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFolderView,
                iItem: i32,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SelectAndPositionItems: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFolderView,
                cidl: u32,
                apidl: [*]?*ITEMIDLIST,
                apt: ?[*]POINT,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFolderView,
                cidl: u32,
                apidl: [*]?*ITEMIDLIST,
                apt: ?[*]POINT,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFolderView_GetCurrentViewMode(self: *const T, pViewMode: ?*u32) HRESULT {
                return @as(*const IFolderView.VTable, @ptrCast(self.vtable)).GetCurrentViewMode(@as(*const IFolderView, @ptrCast(self)), pViewMode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFolderView_SetCurrentViewMode(self: *const T, ViewMode: u32) HRESULT {
                return @as(*const IFolderView.VTable, @ptrCast(self.vtable)).SetCurrentViewMode(@as(*const IFolderView, @ptrCast(self)), ViewMode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFolderView_GetFolder(self: *const T, riid: ?*const Guid, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const IFolderView.VTable, @ptrCast(self.vtable)).GetFolder(@as(*const IFolderView, @ptrCast(self)), riid, ppv);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFolderView_Item(self: *const T, iItemIndex: i32, ppidl: ?*?*ITEMIDLIST) HRESULT {
                return @as(*const IFolderView.VTable, @ptrCast(self.vtable)).Item(@as(*const IFolderView, @ptrCast(self)), iItemIndex, ppidl);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFolderView_ItemCount(self: *const T, uFlags: u32, pcItems: ?*i32) HRESULT {
                return @as(*const IFolderView.VTable, @ptrCast(self.vtable)).ItemCount(@as(*const IFolderView, @ptrCast(self)), uFlags, pcItems);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFolderView_Items(self: *const T, uFlags: u32, riid: ?*const Guid, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const IFolderView.VTable, @ptrCast(self.vtable)).Items(@as(*const IFolderView, @ptrCast(self)), uFlags, riid, ppv);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFolderView_GetSelectionMarkedItem(self: *const T, piItem: ?*i32) HRESULT {
                return @as(*const IFolderView.VTable, @ptrCast(self.vtable)).GetSelectionMarkedItem(@as(*const IFolderView, @ptrCast(self)), piItem);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFolderView_GetFocusedItem(self: *const T, piItem: ?*i32) HRESULT {
                return @as(*const IFolderView.VTable, @ptrCast(self.vtable)).GetFocusedItem(@as(*const IFolderView, @ptrCast(self)), piItem);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFolderView_GetItemPosition(self: *const T, pidl: ?*ITEMIDLIST, ppt: ?*POINT) HRESULT {
                return @as(*const IFolderView.VTable, @ptrCast(self.vtable)).GetItemPosition(@as(*const IFolderView, @ptrCast(self)), pidl, ppt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFolderView_GetSpacing(self: *const T, ppt: ?*POINT) HRESULT {
                return @as(*const IFolderView.VTable, @ptrCast(self.vtable)).GetSpacing(@as(*const IFolderView, @ptrCast(self)), ppt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFolderView_GetDefaultSpacing(self: *const T, ppt: ?*POINT) HRESULT {
                return @as(*const IFolderView.VTable, @ptrCast(self.vtable)).GetDefaultSpacing(@as(*const IFolderView, @ptrCast(self)), ppt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFolderView_GetAutoArrange(self: *const T) HRESULT {
                return @as(*const IFolderView.VTable, @ptrCast(self.vtable)).GetAutoArrange(@as(*const IFolderView, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFolderView_SelectItem(self: *const T, iItem: i32, dwFlags: u32) HRESULT {
                return @as(*const IFolderView.VTable, @ptrCast(self.vtable)).SelectItem(@as(*const IFolderView, @ptrCast(self)), iItem, dwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFolderView_SelectAndPositionItems(self: *const T, cidl: u32, apidl: [*]?*ITEMIDLIST, apt: ?[*]POINT, dwFlags: u32) HRESULT {
                return @as(*const IFolderView.VTable, @ptrCast(self.vtable)).SelectAndPositionItems(@as(*const IFolderView, @ptrCast(self)), cidl, apidl, apt, dwFlags);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SORTDIRECTION = enum(i32) {
    DESCENDING = -1,
    ASCENDING = 1,
};
pub const SORT_DESCENDING = SORTDIRECTION.DESCENDING;
pub const SORT_ASCENDING = SORTDIRECTION.ASCENDING;

pub const SORTCOLUMN = extern struct {
    propkey: PROPERTYKEY,
    direction: SORTDIRECTION,
};

pub const FVTEXTTYPE = enum(i32) {
    T = 0,
};
pub const FVST_EMPTYTEXT = FVTEXTTYPE.T;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IFolderView2_Value = Guid.initString("1af3a467-214f-4298-908e-06b03e0b39f9");
pub const IID_IFolderView2 = &IID_IFolderView2_Value;
pub const IFolderView2 = extern struct {
    pub const VTable = extern struct {
        base: IFolderView.VTable,
        SetGroupBy: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFolderView2,
                key: ?*const PROPERTYKEY,
                fAscending: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFolderView2,
                key: ?*const PROPERTYKEY,
                fAscending: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetGroupBy: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFolderView2,
                pkey: ?*PROPERTYKEY,
                pfAscending: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFolderView2,
                pkey: ?*PROPERTYKEY,
                pfAscending: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetViewProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFolderView2,
                pidl: ?*ITEMIDLIST,
                propkey: ?*const PROPERTYKEY,
                propvar: ?*const PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFolderView2,
                pidl: ?*ITEMIDLIST,
                propkey: ?*const PROPERTYKEY,
                propvar: ?*const PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetViewProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFolderView2,
                pidl: ?*ITEMIDLIST,
                propkey: ?*const PROPERTYKEY,
                ppropvar: ?*PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFolderView2,
                pidl: ?*ITEMIDLIST,
                propkey: ?*const PROPERTYKEY,
                ppropvar: ?*PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTileViewProperties: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFolderView2,
                pidl: ?*ITEMIDLIST,
                pszPropList: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFolderView2,
                pidl: ?*ITEMIDLIST,
                pszPropList: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetExtendedTileViewProperties: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFolderView2,
                pidl: ?*ITEMIDLIST,
                pszPropList: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFolderView2,
                pidl: ?*ITEMIDLIST,
                pszPropList: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFolderView2,
                iType: FVTEXTTYPE,
                pwszText: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFolderView2,
                iType: FVTEXTTYPE,
                pwszText: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCurrentFolderFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFolderView2,
                dwMask: u32,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFolderView2,
                dwMask: u32,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentFolderFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFolderView2,
                pdwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFolderView2,
                pdwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSortColumnCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFolderView2,
                pcColumns: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFolderView2,
                pcColumns: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSortColumns: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFolderView2,
                rgSortColumns: [*]const SORTCOLUMN,
                cColumns: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFolderView2,
                rgSortColumns: [*]const SORTCOLUMN,
                cColumns: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSortColumns: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFolderView2,
                rgSortColumns: [*]SORTCOLUMN,
                cColumns: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFolderView2,
                rgSortColumns: [*]SORTCOLUMN,
                cColumns: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFolderView2,
                iItem: i32,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFolderView2,
                iItem: i32,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVisibleItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFolderView2,
                iStart: i32,
                fPrevious: BOOL,
                piItem: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFolderView2,
                iStart: i32,
                fPrevious: BOOL,
                piItem: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSelectedItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFolderView2,
                iStart: i32,
                piItem: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFolderView2,
                iStart: i32,
                piItem: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSelection: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFolderView2,
                fNoneImpliesFolder: BOOL,
                ppsia: ?*?*IShellItemArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFolderView2,
                fNoneImpliesFolder: BOOL,
                ppsia: ?*?*IShellItemArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSelectionState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFolderView2,
                pidl: ?*ITEMIDLIST,
                pdwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFolderView2,
                pidl: ?*ITEMIDLIST,
                pdwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InvokeVerbOnSelection: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFolderView2,
                pszVerb: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFolderView2,
                pszVerb: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetViewModeAndIconSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFolderView2,
                uViewMode: FOLDERVIEWMODE,
                iImageSize: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFolderView2,
                uViewMode: FOLDERVIEWMODE,
                iImageSize: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetViewModeAndIconSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFolderView2,
                puViewMode: ?*FOLDERVIEWMODE,
                piImageSize: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFolderView2,
                puViewMode: ?*FOLDERVIEWMODE,
                piImageSize: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetGroupSubsetCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFolderView2,
                cVisibleRows: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFolderView2,
                cVisibleRows: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetGroupSubsetCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFolderView2,
                pcVisibleRows: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFolderView2,
                pcVisibleRows: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetRedraw: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFolderView2,
                fRedrawOn: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFolderView2,
                fRedrawOn: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsMoveInSameFolder: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFolderView2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFolderView2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DoRename: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFolderView2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFolderView2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IFolderView.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFolderView2_SetGroupBy(self: *const T, key: ?*const PROPERTYKEY, fAscending: BOOL) HRESULT {
                return @as(*const IFolderView2.VTable, @ptrCast(self.vtable)).SetGroupBy(@as(*const IFolderView2, @ptrCast(self)), key, fAscending);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFolderView2_GetGroupBy(self: *const T, pkey: ?*PROPERTYKEY, pfAscending: ?*BOOL) HRESULT {
                return @as(*const IFolderView2.VTable, @ptrCast(self.vtable)).GetGroupBy(@as(*const IFolderView2, @ptrCast(self)), pkey, pfAscending);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFolderView2_SetViewProperty(self: *const T, pidl: ?*ITEMIDLIST, propkey: ?*const PROPERTYKEY, propvar: ?*const PROPVARIANT) HRESULT {
                return @as(*const IFolderView2.VTable, @ptrCast(self.vtable)).SetViewProperty(@as(*const IFolderView2, @ptrCast(self)), pidl, propkey, propvar);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFolderView2_GetViewProperty(self: *const T, pidl: ?*ITEMIDLIST, propkey: ?*const PROPERTYKEY, ppropvar: ?*PROPVARIANT) HRESULT {
                return @as(*const IFolderView2.VTable, @ptrCast(self.vtable)).GetViewProperty(@as(*const IFolderView2, @ptrCast(self)), pidl, propkey, ppropvar);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFolderView2_SetTileViewProperties(self: *const T, pidl: ?*ITEMIDLIST, pszPropList: ?[*:0]const u16) HRESULT {
                return @as(*const IFolderView2.VTable, @ptrCast(self.vtable)).SetTileViewProperties(@as(*const IFolderView2, @ptrCast(self)), pidl, pszPropList);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFolderView2_SetExtendedTileViewProperties(self: *const T, pidl: ?*ITEMIDLIST, pszPropList: ?[*:0]const u16) HRESULT {
                return @as(*const IFolderView2.VTable, @ptrCast(self.vtable)).SetExtendedTileViewProperties(@as(*const IFolderView2, @ptrCast(self)), pidl, pszPropList);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFolderView2_SetText(self: *const T, iType: FVTEXTTYPE, pwszText: ?[*:0]const u16) HRESULT {
                return @as(*const IFolderView2.VTable, @ptrCast(self.vtable)).SetText(@as(*const IFolderView2, @ptrCast(self)), iType, pwszText);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFolderView2_SetCurrentFolderFlags(self: *const T, dwMask: u32, dwFlags: u32) HRESULT {
                return @as(*const IFolderView2.VTable, @ptrCast(self.vtable)).SetCurrentFolderFlags(@as(*const IFolderView2, @ptrCast(self)), dwMask, dwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFolderView2_GetCurrentFolderFlags(self: *const T, pdwFlags: ?*u32) HRESULT {
                return @as(*const IFolderView2.VTable, @ptrCast(self.vtable)).GetCurrentFolderFlags(@as(*const IFolderView2, @ptrCast(self)), pdwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFolderView2_GetSortColumnCount(self: *const T, pcColumns: ?*i32) HRESULT {
                return @as(*const IFolderView2.VTable, @ptrCast(self.vtable)).GetSortColumnCount(@as(*const IFolderView2, @ptrCast(self)), pcColumns);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFolderView2_SetSortColumns(self: *const T, rgSortColumns: [*]const SORTCOLUMN, cColumns: i32) HRESULT {
                return @as(*const IFolderView2.VTable, @ptrCast(self.vtable)).SetSortColumns(@as(*const IFolderView2, @ptrCast(self)), rgSortColumns, cColumns);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFolderView2_GetSortColumns(self: *const T, rgSortColumns: [*]SORTCOLUMN, cColumns: i32) HRESULT {
                return @as(*const IFolderView2.VTable, @ptrCast(self.vtable)).GetSortColumns(@as(*const IFolderView2, @ptrCast(self)), rgSortColumns, cColumns);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFolderView2_GetItem(self: *const T, iItem: i32, riid: ?*const Guid, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const IFolderView2.VTable, @ptrCast(self.vtable)).GetItem(@as(*const IFolderView2, @ptrCast(self)), iItem, riid, ppv);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFolderView2_GetVisibleItem(self: *const T, iStart: i32, fPrevious: BOOL, piItem: ?*i32) HRESULT {
                return @as(*const IFolderView2.VTable, @ptrCast(self.vtable)).GetVisibleItem(@as(*const IFolderView2, @ptrCast(self)), iStart, fPrevious, piItem);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFolderView2_GetSelectedItem(self: *const T, iStart: i32, piItem: ?*i32) HRESULT {
                return @as(*const IFolderView2.VTable, @ptrCast(self.vtable)).GetSelectedItem(@as(*const IFolderView2, @ptrCast(self)), iStart, piItem);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFolderView2_GetSelection(self: *const T, fNoneImpliesFolder: BOOL, ppsia: ?*?*IShellItemArray) HRESULT {
                return @as(*const IFolderView2.VTable, @ptrCast(self.vtable)).GetSelection(@as(*const IFolderView2, @ptrCast(self)), fNoneImpliesFolder, ppsia);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFolderView2_GetSelectionState(self: *const T, pidl: ?*ITEMIDLIST, pdwFlags: ?*u32) HRESULT {
                return @as(*const IFolderView2.VTable, @ptrCast(self.vtable)).GetSelectionState(@as(*const IFolderView2, @ptrCast(self)), pidl, pdwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFolderView2_InvokeVerbOnSelection(self: *const T, pszVerb: ?[*:0]const u8) HRESULT {
                return @as(*const IFolderView2.VTable, @ptrCast(self.vtable)).InvokeVerbOnSelection(@as(*const IFolderView2, @ptrCast(self)), pszVerb);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFolderView2_SetViewModeAndIconSize(self: *const T, uViewMode: FOLDERVIEWMODE, iImageSize: i32) HRESULT {
                return @as(*const IFolderView2.VTable, @ptrCast(self.vtable)).SetViewModeAndIconSize(@as(*const IFolderView2, @ptrCast(self)), uViewMode, iImageSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFolderView2_GetViewModeAndIconSize(self: *const T, puViewMode: ?*FOLDERVIEWMODE, piImageSize: ?*i32) HRESULT {
                return @as(*const IFolderView2.VTable, @ptrCast(self.vtable)).GetViewModeAndIconSize(@as(*const IFolderView2, @ptrCast(self)), puViewMode, piImageSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFolderView2_SetGroupSubsetCount(self: *const T, cVisibleRows: u32) HRESULT {
                return @as(*const IFolderView2.VTable, @ptrCast(self.vtable)).SetGroupSubsetCount(@as(*const IFolderView2, @ptrCast(self)), cVisibleRows);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFolderView2_GetGroupSubsetCount(self: *const T, pcVisibleRows: ?*u32) HRESULT {
                return @as(*const IFolderView2.VTable, @ptrCast(self.vtable)).GetGroupSubsetCount(@as(*const IFolderView2, @ptrCast(self)), pcVisibleRows);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFolderView2_SetRedraw(self: *const T, fRedrawOn: BOOL) HRESULT {
                return @as(*const IFolderView2.VTable, @ptrCast(self.vtable)).SetRedraw(@as(*const IFolderView2, @ptrCast(self)), fRedrawOn);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFolderView2_IsMoveInSameFolder(self: *const T) HRESULT {
                return @as(*const IFolderView2.VTable, @ptrCast(self.vtable)).IsMoveInSameFolder(@as(*const IFolderView2, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFolderView2_DoRename(self: *const T) HRESULT {
                return @as(*const IFolderView2.VTable, @ptrCast(self.vtable)).DoRename(@as(*const IFolderView2, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IFolderViewSettings_Value = Guid.initString("ae8c987d-8797-4ed3-be72-2a47dd938db0");
pub const IID_IFolderViewSettings = &IID_IFolderViewSettings_Value;
pub const IFolderViewSettings = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetColumnPropertyList: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFolderViewSettings,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFolderViewSettings,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetGroupByProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFolderViewSettings,
                pkey: ?*PROPERTYKEY,
                pfGroupAscending: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFolderViewSettings,
                pkey: ?*PROPERTYKEY,
                pfGroupAscending: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetViewMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFolderViewSettings,
                plvm: ?*FOLDERLOGICALVIEWMODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFolderViewSettings,
                plvm: ?*FOLDERLOGICALVIEWMODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIconSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFolderViewSettings,
                puIconSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFolderViewSettings,
                puIconSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFolderFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFolderViewSettings,
                pfolderMask: ?*FOLDERFLAGS,
                pfolderFlags: ?*FOLDERFLAGS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFolderViewSettings,
                pfolderMask: ?*FOLDERFLAGS,
                pfolderFlags: ?*FOLDERFLAGS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSortColumns: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFolderViewSettings,
                rgSortColumns: [*]SORTCOLUMN,
                cColumnsIn: u32,
                pcColumnsOut: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFolderViewSettings,
                rgSortColumns: [*]SORTCOLUMN,
                cColumnsIn: u32,
                pcColumnsOut: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetGroupSubsetCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFolderViewSettings,
                pcVisibleRows: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFolderViewSettings,
                pcVisibleRows: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFolderViewSettings_GetColumnPropertyList(self: *const T, riid: ?*const Guid, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const IFolderViewSettings.VTable, @ptrCast(self.vtable)).GetColumnPropertyList(@as(*const IFolderViewSettings, @ptrCast(self)), riid, ppv);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFolderViewSettings_GetGroupByProperty(self: *const T, pkey: ?*PROPERTYKEY, pfGroupAscending: ?*BOOL) HRESULT {
                return @as(*const IFolderViewSettings.VTable, @ptrCast(self.vtable)).GetGroupByProperty(@as(*const IFolderViewSettings, @ptrCast(self)), pkey, pfGroupAscending);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFolderViewSettings_GetViewMode(self: *const T, plvm: ?*FOLDERLOGICALVIEWMODE) HRESULT {
                return @as(*const IFolderViewSettings.VTable, @ptrCast(self.vtable)).GetViewMode(@as(*const IFolderViewSettings, @ptrCast(self)), plvm);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFolderViewSettings_GetIconSize(self: *const T, puIconSize: ?*u32) HRESULT {
                return @as(*const IFolderViewSettings.VTable, @ptrCast(self.vtable)).GetIconSize(@as(*const IFolderViewSettings, @ptrCast(self)), puIconSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFolderViewSettings_GetFolderFlags(self: *const T, pfolderMask: ?*FOLDERFLAGS, pfolderFlags: ?*FOLDERFLAGS) HRESULT {
                return @as(*const IFolderViewSettings.VTable, @ptrCast(self.vtable)).GetFolderFlags(@as(*const IFolderViewSettings, @ptrCast(self)), pfolderMask, pfolderFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFolderViewSettings_GetSortColumns(self: *const T, rgSortColumns: [*]SORTCOLUMN, cColumnsIn: u32, pcColumnsOut: ?*u32) HRESULT {
                return @as(*const IFolderViewSettings.VTable, @ptrCast(self.vtable)).GetSortColumns(@as(*const IFolderViewSettings, @ptrCast(self)), rgSortColumns, cColumnsIn, pcColumnsOut);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFolderViewSettings_GetGroupSubsetCount(self: *const T, pcVisibleRows: ?*u32) HRESULT {
                return @as(*const IFolderViewSettings.VTable, @ptrCast(self.vtable)).GetGroupSubsetCount(@as(*const IFolderViewSettings, @ptrCast(self)), pcVisibleRows);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IInitializeNetworkFolder_Value = Guid.initString("6e0f9881-42a8-4f2a-97f8-8af4e026d92d");
pub const IID_IInitializeNetworkFolder = &IID_IInitializeNetworkFolder_Value;
pub const IInitializeNetworkFolder = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInitializeNetworkFolder,
                pidl: ?*ITEMIDLIST,
                pidlTarget: ?*ITEMIDLIST,
                uDisplayType: u32,
                pszResName: ?[*:0]const u16,
                pszProvider: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInitializeNetworkFolder,
                pidl: ?*ITEMIDLIST,
                pidlTarget: ?*ITEMIDLIST,
                uDisplayType: u32,
                pszResName: ?[*:0]const u16,
                pszProvider: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInitializeNetworkFolder_Initialize(self: *const T, pidl: ?*ITEMIDLIST, pidlTarget: ?*ITEMIDLIST, uDisplayType: u32, pszResName: ?[*:0]const u16, pszProvider: ?[*:0]const u16) HRESULT {
                return @as(*const IInitializeNetworkFolder.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IInitializeNetworkFolder, @ptrCast(self)), pidl, pidlTarget, uDisplayType, pszResName, pszProvider);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_INetworkFolderInternal_Value = Guid.initString("ceb38218-c971-47bb-a703-f0bc99ccdb81");
pub const IID_INetworkFolderInternal = &IID_INetworkFolderInternal_Value;
pub const INetworkFolderInternal = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetResourceDisplayType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INetworkFolderInternal,
                displayType: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INetworkFolderInternal,
                displayType: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIDList: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INetworkFolderInternal,
                idList: ?*?*ITEMIDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INetworkFolderInternal,
                idList: ?*?*ITEMIDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProvider: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INetworkFolderInternal,
                itemIdCount: u32,
                itemIds: [*]?*ITEMIDLIST,
                providerMaxLength: u32,
                provider: [*:0]u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INetworkFolderInternal,
                itemIdCount: u32,
                itemIds: [*]?*ITEMIDLIST,
                providerMaxLength: u32,
                provider: [*:0]u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetworkFolderInternal_GetResourceDisplayType(self: *const T, displayType: ?*u32) HRESULT {
                return @as(*const INetworkFolderInternal.VTable, @ptrCast(self.vtable)).GetResourceDisplayType(@as(*const INetworkFolderInternal, @ptrCast(self)), displayType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetworkFolderInternal_GetIDList(self: *const T, idList: ?*?*ITEMIDLIST) HRESULT {
                return @as(*const INetworkFolderInternal.VTable, @ptrCast(self.vtable)).GetIDList(@as(*const INetworkFolderInternal, @ptrCast(self)), idList);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INetworkFolderInternal_GetProvider(self: *const T, itemIdCount: u32, itemIds: [*]?*ITEMIDLIST, providerMaxLength: u32, provider: [*:0]u16) HRESULT {
                return @as(*const INetworkFolderInternal.VTable, @ptrCast(self.vtable)).GetProvider(@as(*const INetworkFolderInternal, @ptrCast(self)), itemIdCount, itemIds, providerMaxLength, provider);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IPreviewHandlerVisuals_Value = Guid.initString("196bf9a5-b346-4ef0-aa1e-5dcdb76768b1");
pub const IID_IPreviewHandlerVisuals = &IID_IPreviewHandlerVisuals_Value;
pub const IPreviewHandlerVisuals = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetBackgroundColor: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPreviewHandlerVisuals,
                color: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPreviewHandlerVisuals,
                color: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFont: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPreviewHandlerVisuals,
                plf: ?*const LOGFONTW,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPreviewHandlerVisuals,
                plf: ?*const LOGFONTW,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTextColor: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPreviewHandlerVisuals,
                color: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPreviewHandlerVisuals,
                color: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPreviewHandlerVisuals_SetBackgroundColor(self: *const T, color: u32) HRESULT {
                return @as(*const IPreviewHandlerVisuals.VTable, @ptrCast(self.vtable)).SetBackgroundColor(@as(*const IPreviewHandlerVisuals, @ptrCast(self)), color);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPreviewHandlerVisuals_SetFont(self: *const T, plf: ?*const LOGFONTW) HRESULT {
                return @as(*const IPreviewHandlerVisuals.VTable, @ptrCast(self.vtable)).SetFont(@as(*const IPreviewHandlerVisuals, @ptrCast(self)), plf);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPreviewHandlerVisuals_SetTextColor(self: *const T, color: u32) HRESULT {
                return @as(*const IPreviewHandlerVisuals.VTable, @ptrCast(self.vtable)).SetTextColor(@as(*const IPreviewHandlerVisuals, @ptrCast(self)), color);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ICommDlgBrowser_Value = Guid.initString("000214f1-0000-0000-c000-000000000046");
pub const IID_ICommDlgBrowser = &IID_ICommDlgBrowser_Value;
pub const ICommDlgBrowser = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnDefaultCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICommDlgBrowser,
                ppshv: ?*IShellView,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICommDlgBrowser,
                ppshv: ?*IShellView,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnStateChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICommDlgBrowser,
                ppshv: ?*IShellView,
                uChange: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICommDlgBrowser,
                ppshv: ?*IShellView,
                uChange: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IncludeObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICommDlgBrowser,
                ppshv: ?*IShellView,
                pidl: ?*ITEMIDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICommDlgBrowser,
                ppshv: ?*IShellView,
                pidl: ?*ITEMIDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICommDlgBrowser_OnDefaultCommand(self: *const T, ppshv: ?*IShellView) HRESULT {
                return @as(*const ICommDlgBrowser.VTable, @ptrCast(self.vtable)).OnDefaultCommand(@as(*const ICommDlgBrowser, @ptrCast(self)), ppshv);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICommDlgBrowser_OnStateChange(self: *const T, ppshv: ?*IShellView, uChange: u32) HRESULT {
                return @as(*const ICommDlgBrowser.VTable, @ptrCast(self.vtable)).OnStateChange(@as(*const ICommDlgBrowser, @ptrCast(self)), ppshv, uChange);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICommDlgBrowser_IncludeObject(self: *const T, ppshv: ?*IShellView, pidl: ?*ITEMIDLIST) HRESULT {
                return @as(*const ICommDlgBrowser.VTable, @ptrCast(self.vtable)).IncludeObject(@as(*const ICommDlgBrowser, @ptrCast(self)), ppshv, pidl);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ICommDlgBrowser2_Value = Guid.initString("10339516-2894-11d2-9039-00c04f8eeb3e");
pub const IID_ICommDlgBrowser2 = &IID_ICommDlgBrowser2_Value;
pub const ICommDlgBrowser2 = extern struct {
    pub const VTable = extern struct {
        base: ICommDlgBrowser.VTable,
        Notify: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICommDlgBrowser2,
                ppshv: ?*IShellView,
                dwNotifyType: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICommDlgBrowser2,
                ppshv: ?*IShellView,
                dwNotifyType: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDefaultMenuText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICommDlgBrowser2,
                ppshv: ?*IShellView,
                pszText: [*:0]u16,
                cchMax: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICommDlgBrowser2,
                ppshv: ?*IShellView,
                pszText: [*:0]u16,
                cchMax: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetViewFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICommDlgBrowser2,
                pdwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICommDlgBrowser2,
                pdwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ICommDlgBrowser.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICommDlgBrowser2_Notify(self: *const T, ppshv: ?*IShellView, dwNotifyType: u32) HRESULT {
                return @as(*const ICommDlgBrowser2.VTable, @ptrCast(self.vtable)).Notify(@as(*const ICommDlgBrowser2, @ptrCast(self)), ppshv, dwNotifyType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICommDlgBrowser2_GetDefaultMenuText(self: *const T, ppshv: ?*IShellView, pszText: [*:0]u16, cchMax: i32) HRESULT {
                return @as(*const ICommDlgBrowser2.VTable, @ptrCast(self.vtable)).GetDefaultMenuText(@as(*const ICommDlgBrowser2, @ptrCast(self)), ppshv, pszText, cchMax);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICommDlgBrowser2_GetViewFlags(self: *const T, pdwFlags: ?*u32) HRESULT {
                return @as(*const ICommDlgBrowser2.VTable, @ptrCast(self.vtable)).GetViewFlags(@as(*const ICommDlgBrowser2, @ptrCast(self)), pdwFlags);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const CM_MASK = enum(i32) {
    WIDTH = 1,
    DEFAULTWIDTH = 2,
    IDEALWIDTH = 4,
    NAME = 8,
    STATE = 16,
};
pub const CM_MASK_WIDTH = CM_MASK.WIDTH;
pub const CM_MASK_DEFAULTWIDTH = CM_MASK.DEFAULTWIDTH;
pub const CM_MASK_IDEALWIDTH = CM_MASK.IDEALWIDTH;
pub const CM_MASK_NAME = CM_MASK.NAME;
pub const CM_MASK_STATE = CM_MASK.STATE;

pub const CM_STATE = enum(i32) {
    NONE = 0,
    VISIBLE = 1,
    FIXEDWIDTH = 2,
    NOSORTBYFOLDERNESS = 4,
    ALWAYSVISIBLE = 8,
};
pub const CM_STATE_NONE = CM_STATE.NONE;
pub const CM_STATE_VISIBLE = CM_STATE.VISIBLE;
pub const CM_STATE_FIXEDWIDTH = CM_STATE.FIXEDWIDTH;
pub const CM_STATE_NOSORTBYFOLDERNESS = CM_STATE.NOSORTBYFOLDERNESS;
pub const CM_STATE_ALWAYSVISIBLE = CM_STATE.ALWAYSVISIBLE;

pub const CM_ENUM_FLAGS = enum(i32) {
    ALL = 1,
    VISIBLE = 2,
};
pub const CM_ENUM_ALL = CM_ENUM_FLAGS.ALL;
pub const CM_ENUM_VISIBLE = CM_ENUM_FLAGS.VISIBLE;

pub const CM_SET_WIDTH_VALUE = enum(i32) {
    USEDEFAULT = -1,
    AUTOSIZE = -2,
};
pub const CM_WIDTH_USEDEFAULT = CM_SET_WIDTH_VALUE.USEDEFAULT;
pub const CM_WIDTH_AUTOSIZE = CM_SET_WIDTH_VALUE.AUTOSIZE;

pub const CM_COLUMNINFO = extern struct {
    cbSize: u32,
    dwMask: u32,
    dwState: u32,
    uWidth: u32,
    uDefaultWidth: u32,
    uIdealWidth: u32,
    wszName: [80]u16,
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IColumnManager_Value = Guid.initString("d8ec27bb-3f3b-4042-b10a-4acfd924d453");
pub const IID_IColumnManager = &IID_IColumnManager_Value;
pub const IColumnManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetColumnInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IColumnManager,
                propkey: ?*const PROPERTYKEY,
                pcmci: ?*const CM_COLUMNINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IColumnManager,
                propkey: ?*const PROPERTYKEY,
                pcmci: ?*const CM_COLUMNINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetColumnInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IColumnManager,
                propkey: ?*const PROPERTYKEY,
                pcmci: ?*CM_COLUMNINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IColumnManager,
                propkey: ?*const PROPERTYKEY,
                pcmci: ?*CM_COLUMNINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetColumnCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IColumnManager,
                dwFlags: CM_ENUM_FLAGS,
                puCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IColumnManager,
                dwFlags: CM_ENUM_FLAGS,
                puCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetColumns: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IColumnManager,
                dwFlags: CM_ENUM_FLAGS,
                rgkeyOrder: [*]PROPERTYKEY,
                cColumns: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IColumnManager,
                dwFlags: CM_ENUM_FLAGS,
                rgkeyOrder: [*]PROPERTYKEY,
                cColumns: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetColumns: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IColumnManager,
                rgkeyOrder: [*]const PROPERTYKEY,
                cVisible: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IColumnManager,
                rgkeyOrder: [*]const PROPERTYKEY,
                cVisible: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IColumnManager_SetColumnInfo(self: *const T, propkey: ?*const PROPERTYKEY, pcmci: ?*const CM_COLUMNINFO) HRESULT {
                return @as(*const IColumnManager.VTable, @ptrCast(self.vtable)).SetColumnInfo(@as(*const IColumnManager, @ptrCast(self)), propkey, pcmci);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IColumnManager_GetColumnInfo(self: *const T, propkey: ?*const PROPERTYKEY, pcmci: ?*CM_COLUMNINFO) HRESULT {
                return @as(*const IColumnManager.VTable, @ptrCast(self.vtable)).GetColumnInfo(@as(*const IColumnManager, @ptrCast(self)), propkey, pcmci);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IColumnManager_GetColumnCount(self: *const T, dwFlags: CM_ENUM_FLAGS, puCount: ?*u32) HRESULT {
                return @as(*const IColumnManager.VTable, @ptrCast(self.vtable)).GetColumnCount(@as(*const IColumnManager, @ptrCast(self)), dwFlags, puCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IColumnManager_GetColumns(self: *const T, dwFlags: CM_ENUM_FLAGS, rgkeyOrder: [*]PROPERTYKEY, cColumns: u32) HRESULT {
                return @as(*const IColumnManager.VTable, @ptrCast(self.vtable)).GetColumns(@as(*const IColumnManager, @ptrCast(self)), dwFlags, rgkeyOrder, cColumns);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IColumnManager_SetColumns(self: *const T, rgkeyOrder: [*]const PROPERTYKEY, cVisible: u32) HRESULT {
                return @as(*const IColumnManager.VTable, @ptrCast(self.vtable)).SetColumns(@as(*const IColumnManager, @ptrCast(self)), rgkeyOrder, cVisible);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IFolderFilterSite_Value = Guid.initString("c0a651f5-b48b-11d2-b5ed-006097c686f6");
pub const IID_IFolderFilterSite = &IID_IFolderFilterSite_Value;
pub const IFolderFilterSite = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetFilter: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFolderFilterSite,
                punk: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFolderFilterSite,
                punk: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFolderFilterSite_SetFilter(self: *const T, punk: ?*IUnknown) HRESULT {
                return @as(*const IFolderFilterSite.VTable, @ptrCast(self.vtable)).SetFilter(@as(*const IFolderFilterSite, @ptrCast(self)), punk);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IFolderFilter_Value = Guid.initString("9cc22886-dc8e-11d2-b1d0-00c04f8eeb3e");
pub const IID_IFolderFilter = &IID_IFolderFilter_Value;
pub const IFolderFilter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ShouldShow: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFolderFilter,
                psf: ?*IShellFolder,
                pidlFolder: ?*ITEMIDLIST,
                pidlItem: ?*ITEMIDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFolderFilter,
                psf: ?*IShellFolder,
                pidlFolder: ?*ITEMIDLIST,
                pidlItem: ?*ITEMIDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEnumFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFolderFilter,
                psf: ?*IShellFolder,
                pidlFolder: ?*ITEMIDLIST,
                phwnd: ?*?HWND,
                pgrfFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFolderFilter,
                psf: ?*IShellFolder,
                pidlFolder: ?*ITEMIDLIST,
                phwnd: ?*?HWND,
                pgrfFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFolderFilter_ShouldShow(self: *const T, psf: ?*IShellFolder, pidlFolder: ?*ITEMIDLIST, pidlItem: ?*ITEMIDLIST) HRESULT {
                return @as(*const IFolderFilter.VTable, @ptrCast(self.vtable)).ShouldShow(@as(*const IFolderFilter, @ptrCast(self)), psf, pidlFolder, pidlItem);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFolderFilter_GetEnumFlags(self: *const T, psf: ?*IShellFolder, pidlFolder: ?*ITEMIDLIST, phwnd: ?*?HWND, pgrfFlags: ?*u32) HRESULT {
                return @as(*const IFolderFilter.VTable, @ptrCast(self.vtable)).GetEnumFlags(@as(*const IFolderFilter, @ptrCast(self)), psf, pidlFolder, phwnd, pgrfFlags);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IInputObjectSite_Value = Guid.initString("f1db8392-7331-11d0-8c99-00a0c92dbfe8");
pub const IID_IInputObjectSite = &IID_IInputObjectSite_Value;
pub const IInputObjectSite = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnFocusChangeIS: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInputObjectSite,
                punkObj: ?*IUnknown,
                fSetFocus: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInputObjectSite,
                punkObj: ?*IUnknown,
                fSetFocus: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInputObjectSite_OnFocusChangeIS(self: *const T, punkObj: ?*IUnknown, fSetFocus: BOOL) HRESULT {
                return @as(*const IInputObjectSite.VTable, @ptrCast(self.vtable)).OnFocusChangeIS(@as(*const IInputObjectSite, @ptrCast(self)), punkObj, fSetFocus);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IInputObject_Value = Guid.initString("68284faa-6a48-11d0-8c78-00c04fd918b4");
pub const IID_IInputObject = &IID_IInputObject_Value;
pub const IInputObject = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        UIActivateIO: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInputObject,
                fActivate: BOOL,
                pMsg: ?*MSG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInputObject,
                fActivate: BOOL,
                pMsg: ?*MSG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        HasFocusIO: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInputObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInputObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TranslateAcceleratorIO: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInputObject,
                pMsg: ?*MSG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInputObject,
                pMsg: ?*MSG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInputObject_UIActivateIO(self: *const T, fActivate: BOOL, pMsg: ?*MSG) HRESULT {
                return @as(*const IInputObject.VTable, @ptrCast(self.vtable)).UIActivateIO(@as(*const IInputObject, @ptrCast(self)), fActivate, pMsg);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInputObject_HasFocusIO(self: *const T) HRESULT {
                return @as(*const IInputObject.VTable, @ptrCast(self.vtable)).HasFocusIO(@as(*const IInputObject, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInputObject_TranslateAcceleratorIO(self: *const T, pMsg: ?*MSG) HRESULT {
                return @as(*const IInputObject.VTable, @ptrCast(self.vtable)).TranslateAcceleratorIO(@as(*const IInputObject, @ptrCast(self)), pMsg);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IInputObject2_Value = Guid.initString("6915c085-510b-44cd-94af-28dfa56cf92b");
pub const IID_IInputObject2 = &IID_IInputObject2_Value;
pub const IInputObject2 = extern struct {
    pub const VTable = extern struct {
        base: IInputObject.VTable,
        TranslateAcceleratorGlobal: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInputObject2,
                pMsg: ?*MSG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInputObject2,
                pMsg: ?*MSG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IInputObject.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInputObject2_TranslateAcceleratorGlobal(self: *const T, pMsg: ?*MSG) HRESULT {
                return @as(*const IInputObject2.VTable, @ptrCast(self.vtable)).TranslateAcceleratorGlobal(@as(*const IInputObject2, @ptrCast(self)), pMsg);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IShellIcon_Value = Guid.initString("000214e5-0000-0000-c000-000000000046");
pub const IID_IShellIcon = &IID_IShellIcon_Value;
pub const IShellIcon = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetIconOf: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellIcon,
                pidl: ?*ITEMIDLIST,
                flags: u32,
                pIconIndex: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellIcon,
                pidl: ?*ITEMIDLIST,
                flags: u32,
                pIconIndex: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellIcon_GetIconOf(self: *const T, pidl: ?*ITEMIDLIST, flags: u32, pIconIndex: ?*i32) HRESULT {
                return @as(*const IShellIcon.VTable, @ptrCast(self.vtable)).GetIconOf(@as(*const IShellIcon, @ptrCast(self)), pidl, flags, pIconIndex);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IShellBrowser_Value = Guid.initString("000214e2-0000-0000-c000-000000000046");
pub const IID_IShellBrowser = &IID_IShellBrowser_Value;
pub const IShellBrowser = extern struct {
    pub const VTable = extern struct {
        base: IOleWindow.VTable,
        InsertMenusSB: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellBrowser,
                hmenuShared: ?HMENU,
                lpMenuWidths: ?*OleMenuGroupWidths,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellBrowser,
                hmenuShared: ?HMENU,
                lpMenuWidths: ?*OleMenuGroupWidths,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetMenuSB: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellBrowser,
                hmenuShared: ?HMENU,
                holemenuRes: isize,
                hwndActiveObject: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellBrowser,
                hmenuShared: ?HMENU,
                holemenuRes: isize,
                hwndActiveObject: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveMenusSB: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellBrowser,
                hmenuShared: ?HMENU,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellBrowser,
                hmenuShared: ?HMENU,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetStatusTextSB: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellBrowser,
                pszStatusText: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellBrowser,
                pszStatusText: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnableModelessSB: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellBrowser,
                fEnable: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellBrowser,
                fEnable: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TranslateAcceleratorSB: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellBrowser,
                pmsg: ?*MSG,
                wID: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellBrowser,
                pmsg: ?*MSG,
                wID: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BrowseObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellBrowser,
                pidl: ?*ITEMIDLIST,
                wFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellBrowser,
                pidl: ?*ITEMIDLIST,
                wFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetViewStateStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellBrowser,
                grfMode: u32,
                ppStrm: ?*?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellBrowser,
                grfMode: u32,
                ppStrm: ?*?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetControlWindow: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellBrowser,
                id: u32,
                phwnd: ?*?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellBrowser,
                id: u32,
                phwnd: ?*?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SendControlMsg: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellBrowser,
                id: u32,
                uMsg: u32,
                wParam: WPARAM,
                lParam: LPARAM,
                pret: ?*LRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellBrowser,
                id: u32,
                uMsg: u32,
                wParam: WPARAM,
                lParam: LPARAM,
                pret: ?*LRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryActiveShellView: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellBrowser,
                ppshv: ?*?*IShellView,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellBrowser,
                ppshv: ?*?*IShellView,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnViewWindowActive: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellBrowser,
                pshv: ?*IShellView,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellBrowser,
                pshv: ?*IShellView,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetToolbarItems: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellBrowser,
                lpButtons: ?[*]TBBUTTON,
                nButtons: u32,
                uFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellBrowser,
                lpButtons: ?[*]TBBUTTON,
                nButtons: u32,
                uFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IOleWindow.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellBrowser_InsertMenusSB(self: *const T, hmenuShared: ?HMENU, lpMenuWidths: ?*OleMenuGroupWidths) HRESULT {
                return @as(*const IShellBrowser.VTable, @ptrCast(self.vtable)).InsertMenusSB(@as(*const IShellBrowser, @ptrCast(self)), hmenuShared, lpMenuWidths);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellBrowser_SetMenuSB(self: *const T, hmenuShared: ?HMENU, holemenuRes: isize, hwndActiveObject: ?HWND) HRESULT {
                return @as(*const IShellBrowser.VTable, @ptrCast(self.vtable)).SetMenuSB(@as(*const IShellBrowser, @ptrCast(self)), hmenuShared, holemenuRes, hwndActiveObject);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellBrowser_RemoveMenusSB(self: *const T, hmenuShared: ?HMENU) HRESULT {
                return @as(*const IShellBrowser.VTable, @ptrCast(self.vtable)).RemoveMenusSB(@as(*const IShellBrowser, @ptrCast(self)), hmenuShared);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellBrowser_SetStatusTextSB(self: *const T, pszStatusText: ?[*:0]const u16) HRESULT {
                return @as(*const IShellBrowser.VTable, @ptrCast(self.vtable)).SetStatusTextSB(@as(*const IShellBrowser, @ptrCast(self)), pszStatusText);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellBrowser_EnableModelessSB(self: *const T, fEnable: BOOL) HRESULT {
                return @as(*const IShellBrowser.VTable, @ptrCast(self.vtable)).EnableModelessSB(@as(*const IShellBrowser, @ptrCast(self)), fEnable);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellBrowser_TranslateAcceleratorSB(self: *const T, pmsg: ?*MSG, wID: u16) HRESULT {
                return @as(*const IShellBrowser.VTable, @ptrCast(self.vtable)).TranslateAcceleratorSB(@as(*const IShellBrowser, @ptrCast(self)), pmsg, wID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellBrowser_BrowseObject(self: *const T, pidl: ?*ITEMIDLIST, wFlags: u32) HRESULT {
                return @as(*const IShellBrowser.VTable, @ptrCast(self.vtable)).BrowseObject(@as(*const IShellBrowser, @ptrCast(self)), pidl, wFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellBrowser_GetViewStateStream(self: *const T, grfMode: u32, ppStrm: ?*?*IStream) HRESULT {
                return @as(*const IShellBrowser.VTable, @ptrCast(self.vtable)).GetViewStateStream(@as(*const IShellBrowser, @ptrCast(self)), grfMode, ppStrm);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellBrowser_GetControlWindow(self: *const T, id: u32, phwnd: ?*?HWND) HRESULT {
                return @as(*const IShellBrowser.VTable, @ptrCast(self.vtable)).GetControlWindow(@as(*const IShellBrowser, @ptrCast(self)), id, phwnd);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellBrowser_SendControlMsg(self: *const T, id: u32, uMsg: u32, wParam: WPARAM, lParam: LPARAM, pret: ?*LRESULT) HRESULT {
                return @as(*const IShellBrowser.VTable, @ptrCast(self.vtable)).SendControlMsg(@as(*const IShellBrowser, @ptrCast(self)), id, uMsg, wParam, lParam, pret);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellBrowser_QueryActiveShellView(self: *const T, ppshv: ?*?*IShellView) HRESULT {
                return @as(*const IShellBrowser.VTable, @ptrCast(self.vtable)).QueryActiveShellView(@as(*const IShellBrowser, @ptrCast(self)), ppshv);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellBrowser_OnViewWindowActive(self: *const T, pshv: ?*IShellView) HRESULT {
                return @as(*const IShellBrowser.VTable, @ptrCast(self.vtable)).OnViewWindowActive(@as(*const IShellBrowser, @ptrCast(self)), pshv);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellBrowser_SetToolbarItems(self: *const T, lpButtons: ?[*]TBBUTTON, nButtons: u32, uFlags: u32) HRESULT {
                return @as(*const IShellBrowser.VTable, @ptrCast(self.vtable)).SetToolbarItems(@as(*const IShellBrowser, @ptrCast(self)), lpButtons, nButtons, uFlags);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IProfferService_Value = Guid.initString("cb728b20-f786-11ce-92ad-00aa00a74cd0");
pub const IID_IProfferService = &IID_IProfferService_Value;
pub const IProfferService = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ProfferService: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IProfferService,
                serviceId: ?*const Guid,
                serviceProvider: ?*IServiceProvider,
                cookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IProfferService,
                serviceId: ?*const Guid,
                serviceProvider: ?*IServiceProvider,
                cookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RevokeService: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IProfferService,
                cookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IProfferService,
                cookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IProfferService_ProfferService(self: *const T, serviceId: ?*const Guid, serviceProvider: ?*IServiceProvider, cookie: ?*u32) HRESULT {
                return @as(*const IProfferService.VTable, @ptrCast(self.vtable)).ProfferService(@as(*const IProfferService, @ptrCast(self)), serviceId, serviceProvider, cookie);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IProfferService_RevokeService(self: *const T, cookie: u32) HRESULT {
                return @as(*const IProfferService.VTable, @ptrCast(self.vtable)).RevokeService(@as(*const IProfferService, @ptrCast(self)), cookie);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IGetServiceIds_Value = Guid.initString("4a073526-6103-4e21-b7bc-f519d1524e5d");
pub const IID_IGetServiceIds = &IID_IGetServiceIds_Value;
pub const IGetServiceIds = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetServiceIds: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IGetServiceIds,
                serviceIdCount: ?*u32,
                serviceIds: [*]?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IGetServiceIds,
                serviceIdCount: ?*u32,
                serviceIds: [*]?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IGetServiceIds_GetServiceIds(self: *const T, serviceIdCount: ?*u32, serviceIds: [*]?*Guid) HRESULT {
                return @as(*const IGetServiceIds.VTable, @ptrCast(self.vtable)).GetServiceIds(@as(*const IGetServiceIds, @ptrCast(self)), serviceIdCount, serviceIds);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SIGDN = enum(i32) {
    NORMALDISPLAY = 0,
    PARENTRELATIVEPARSING = -2147385343,
    DESKTOPABSOLUTEPARSING = -2147319808,
    PARENTRELATIVEEDITING = -2147282943,
    DESKTOPABSOLUTEEDITING = -2147172352,
    FILESYSPATH = -2147123200,
    URL = -2147057664,
    PARENTRELATIVEFORADDRESSBAR = -2146975743,
    PARENTRELATIVE = -2146959359,
    PARENTRELATIVEFORUI = -2146877439,
};
pub const SIGDN_NORMALDISPLAY = SIGDN.NORMALDISPLAY;
pub const SIGDN_PARENTRELATIVEPARSING = SIGDN.PARENTRELATIVEPARSING;
pub const SIGDN_DESKTOPABSOLUTEPARSING = SIGDN.DESKTOPABSOLUTEPARSING;
pub const SIGDN_PARENTRELATIVEEDITING = SIGDN.PARENTRELATIVEEDITING;
pub const SIGDN_DESKTOPABSOLUTEEDITING = SIGDN.DESKTOPABSOLUTEEDITING;
pub const SIGDN_FILESYSPATH = SIGDN.FILESYSPATH;
pub const SIGDN_URL = SIGDN.URL;
pub const SIGDN_PARENTRELATIVEFORADDRESSBAR = SIGDN.PARENTRELATIVEFORADDRESSBAR;
pub const SIGDN_PARENTRELATIVE = SIGDN.PARENTRELATIVE;
pub const SIGDN_PARENTRELATIVEFORUI = SIGDN.PARENTRELATIVEFORUI;

pub const _SICHINTF = enum(i32) {
    DISPLAY = 0,
    ALLFIELDS = -2147483648,
    CANONICAL = 268435456,
    TEST_FILESYSPATH_IF_NOT_EQUAL = 536870912,
};
pub const SICHINT_DISPLAY = _SICHINTF.DISPLAY;
pub const SICHINT_ALLFIELDS = _SICHINTF.ALLFIELDS;
pub const SICHINT_CANONICAL = _SICHINTF.CANONICAL;
pub const SICHINT_TEST_FILESYSPATH_IF_NOT_EQUAL = _SICHINTF.TEST_FILESYSPATH_IF_NOT_EQUAL;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IShellItem_Value = Guid.initString("43826d1e-e718-42ee-bc55-a1e261c37bfe");
pub const IID_IShellItem = &IID_IShellItem_Value;
pub const IShellItem = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        BindToHandler: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellItem,
                pbc: ?*IBindCtx,
                bhid: ?*const Guid,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellItem,
                pbc: ?*IBindCtx,
                bhid: ?*const Guid,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetParent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellItem,
                ppsi: ?*?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellItem,
                ppsi: ?*?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDisplayName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellItem,
                sigdnName: SIGDN,
                ppszName: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellItem,
                sigdnName: SIGDN,
                ppszName: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAttributes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellItem,
                sfgaoMask: u32,
                psfgaoAttribs: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellItem,
                sfgaoMask: u32,
                psfgaoAttribs: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Compare: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellItem,
                psi: ?*IShellItem,
                hint: u32,
                piOrder: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellItem,
                psi: ?*IShellItem,
                hint: u32,
                piOrder: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellItem_BindToHandler(self: *const T, pbc: ?*IBindCtx, bhid: ?*const Guid, riid: ?*const Guid, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const IShellItem.VTable, @ptrCast(self.vtable)).BindToHandler(@as(*const IShellItem, @ptrCast(self)), pbc, bhid, riid, ppv);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellItem_GetParent(self: *const T, ppsi: ?*?*IShellItem) HRESULT {
                return @as(*const IShellItem.VTable, @ptrCast(self.vtable)).GetParent(@as(*const IShellItem, @ptrCast(self)), ppsi);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellItem_GetDisplayName(self: *const T, sigdnName: SIGDN, ppszName: ?*?PWSTR) HRESULT {
                return @as(*const IShellItem.VTable, @ptrCast(self.vtable)).GetDisplayName(@as(*const IShellItem, @ptrCast(self)), sigdnName, ppszName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellItem_GetAttributes(self: *const T, sfgaoMask: u32, psfgaoAttribs: ?*u32) HRESULT {
                return @as(*const IShellItem.VTable, @ptrCast(self.vtable)).GetAttributes(@as(*const IShellItem, @ptrCast(self)), sfgaoMask, psfgaoAttribs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellItem_Compare(self: *const T, psi: ?*IShellItem, hint: u32, piOrder: ?*i32) HRESULT {
                return @as(*const IShellItem.VTable, @ptrCast(self.vtable)).Compare(@as(*const IShellItem, @ptrCast(self)), psi, hint, piOrder);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DATAOBJ_GET_ITEM_FLAGS = enum(i32) {
    DEFAULT = 0,
    TRAVERSE_LINK = 1,
    NO_HDROP = 2,
    NO_URL = 4,
    ONLY_IF_ONE = 8,
};
pub const DOGIF_DEFAULT = DATAOBJ_GET_ITEM_FLAGS.DEFAULT;
pub const DOGIF_TRAVERSE_LINK = DATAOBJ_GET_ITEM_FLAGS.TRAVERSE_LINK;
pub const DOGIF_NO_HDROP = DATAOBJ_GET_ITEM_FLAGS.NO_HDROP;
pub const DOGIF_NO_URL = DATAOBJ_GET_ITEM_FLAGS.NO_URL;
pub const DOGIF_ONLY_IF_ONE = DATAOBJ_GET_ITEM_FLAGS.ONLY_IF_ONE;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IShellItem2_Value = Guid.initString("7e9fb0d3-919f-4307-ab2e-9b1860310c93");
pub const IID_IShellItem2 = &IID_IShellItem2_Value;
pub const IShellItem2 = extern struct {
    pub const VTable = extern struct {
        base: IShellItem.VTable,
        GetPropertyStore: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellItem2,
                flags: GETPROPERTYSTOREFLAGS,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellItem2,
                flags: GETPROPERTYSTOREFLAGS,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPropertyStoreWithCreateObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellItem2,
                flags: GETPROPERTYSTOREFLAGS,
                punkCreateObject: ?*IUnknown,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellItem2,
                flags: GETPROPERTYSTOREFLAGS,
                punkCreateObject: ?*IUnknown,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPropertyStoreForKeys: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellItem2,
                rgKeys: [*]const PROPERTYKEY,
                cKeys: u32,
                flags: GETPROPERTYSTOREFLAGS,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellItem2,
                rgKeys: [*]const PROPERTYKEY,
                cKeys: u32,
                flags: GETPROPERTYSTOREFLAGS,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPropertyDescriptionList: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellItem2,
                keyType: ?*const PROPERTYKEY,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellItem2,
                keyType: ?*const PROPERTYKEY,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Update: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellItem2,
                pbc: ?*IBindCtx,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellItem2,
                pbc: ?*IBindCtx,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellItem2,
                key: ?*const PROPERTYKEY,
                ppropvar: ?*PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellItem2,
                key: ?*const PROPERTYKEY,
                ppropvar: ?*PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCLSID: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellItem2,
                key: ?*const PROPERTYKEY,
                pclsid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellItem2,
                key: ?*const PROPERTYKEY,
                pclsid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFileTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellItem2,
                key: ?*const PROPERTYKEY,
                pft: ?*FILETIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellItem2,
                key: ?*const PROPERTYKEY,
                pft: ?*FILETIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInt32: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellItem2,
                key: ?*const PROPERTYKEY,
                pi: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellItem2,
                key: ?*const PROPERTYKEY,
                pi: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetString: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellItem2,
                key: ?*const PROPERTYKEY,
                ppsz: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellItem2,
                key: ?*const PROPERTYKEY,
                ppsz: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetUInt32: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellItem2,
                key: ?*const PROPERTYKEY,
                pui: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellItem2,
                key: ?*const PROPERTYKEY,
                pui: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetUInt64: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellItem2,
                key: ?*const PROPERTYKEY,
                pull: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellItem2,
                key: ?*const PROPERTYKEY,
                pull: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBool: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellItem2,
                key: ?*const PROPERTYKEY,
                pf: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellItem2,
                key: ?*const PROPERTYKEY,
                pf: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IShellItem.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellItem2_GetPropertyStore(self: *const T, flags: GETPROPERTYSTOREFLAGS, riid: ?*const Guid, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const IShellItem2.VTable, @ptrCast(self.vtable)).GetPropertyStore(@as(*const IShellItem2, @ptrCast(self)), flags, riid, ppv);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellItem2_GetPropertyStoreWithCreateObject(self: *const T, flags: GETPROPERTYSTOREFLAGS, punkCreateObject: ?*IUnknown, riid: ?*const Guid, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const IShellItem2.VTable, @ptrCast(self.vtable)).GetPropertyStoreWithCreateObject(@as(*const IShellItem2, @ptrCast(self)), flags, punkCreateObject, riid, ppv);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellItem2_GetPropertyStoreForKeys(self: *const T, rgKeys: [*]const PROPERTYKEY, cKeys: u32, flags: GETPROPERTYSTOREFLAGS, riid: ?*const Guid, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const IShellItem2.VTable, @ptrCast(self.vtable)).GetPropertyStoreForKeys(@as(*const IShellItem2, @ptrCast(self)), rgKeys, cKeys, flags, riid, ppv);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellItem2_GetPropertyDescriptionList(self: *const T, keyType: ?*const PROPERTYKEY, riid: ?*const Guid, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const IShellItem2.VTable, @ptrCast(self.vtable)).GetPropertyDescriptionList(@as(*const IShellItem2, @ptrCast(self)), keyType, riid, ppv);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellItem2_Update(self: *const T, pbc: ?*IBindCtx) HRESULT {
                return @as(*const IShellItem2.VTable, @ptrCast(self.vtable)).Update(@as(*const IShellItem2, @ptrCast(self)), pbc);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellItem2_GetProperty(self: *const T, key: ?*const PROPERTYKEY, ppropvar: ?*PROPVARIANT) HRESULT {
                return @as(*const IShellItem2.VTable, @ptrCast(self.vtable)).GetProperty(@as(*const IShellItem2, @ptrCast(self)), key, ppropvar);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellItem2_GetCLSID(self: *const T, key: ?*const PROPERTYKEY, pclsid: ?*Guid) HRESULT {
                return @as(*const IShellItem2.VTable, @ptrCast(self.vtable)).GetCLSID(@as(*const IShellItem2, @ptrCast(self)), key, pclsid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellItem2_GetFileTime(self: *const T, key: ?*const PROPERTYKEY, pft: ?*FILETIME) HRESULT {
                return @as(*const IShellItem2.VTable, @ptrCast(self.vtable)).GetFileTime(@as(*const IShellItem2, @ptrCast(self)), key, pft);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellItem2_GetInt32(self: *const T, key: ?*const PROPERTYKEY, pi: ?*i32) HRESULT {
                return @as(*const IShellItem2.VTable, @ptrCast(self.vtable)).GetInt32(@as(*const IShellItem2, @ptrCast(self)), key, pi);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellItem2_GetString(self: *const T, key: ?*const PROPERTYKEY, ppsz: ?*?PWSTR) HRESULT {
                return @as(*const IShellItem2.VTable, @ptrCast(self.vtable)).GetString(@as(*const IShellItem2, @ptrCast(self)), key, ppsz);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellItem2_GetUInt32(self: *const T, key: ?*const PROPERTYKEY, pui: ?*u32) HRESULT {
                return @as(*const IShellItem2.VTable, @ptrCast(self.vtable)).GetUInt32(@as(*const IShellItem2, @ptrCast(self)), key, pui);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellItem2_GetUInt64(self: *const T, key: ?*const PROPERTYKEY, pull: ?*u64) HRESULT {
                return @as(*const IShellItem2.VTable, @ptrCast(self.vtable)).GetUInt64(@as(*const IShellItem2, @ptrCast(self)), key, pull);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellItem2_GetBool(self: *const T, key: ?*const PROPERTYKEY, pf: ?*BOOL) HRESULT {
                return @as(*const IShellItem2.VTable, @ptrCast(self.vtable)).GetBool(@as(*const IShellItem2, @ptrCast(self)), key, pf);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SIIGBF = enum(i32) {
    RESIZETOFIT = 0,
    BIGGERSIZEOK = 1,
    MEMORYONLY = 2,
    ICONONLY = 4,
    THUMBNAILONLY = 8,
    INCACHEONLY = 16,
    CROPTOSQUARE = 32,
    WIDETHUMBNAILS = 64,
    ICONBACKGROUND = 128,
    SCALEUP = 256,
    _,
    pub fn initFlags(o: struct {
        RESIZETOFIT: u1 = 0,
        BIGGERSIZEOK: u1 = 0,
        MEMORYONLY: u1 = 0,
        ICONONLY: u1 = 0,
        THUMBNAILONLY: u1 = 0,
        INCACHEONLY: u1 = 0,
        CROPTOSQUARE: u1 = 0,
        WIDETHUMBNAILS: u1 = 0,
        ICONBACKGROUND: u1 = 0,
        SCALEUP: u1 = 0,
    }) SIIGBF {
        return @as(SIIGBF, @enumFromInt((if (o.RESIZETOFIT == 1) @intFromEnum(SIIGBF.RESIZETOFIT) else 0) | (if (o.BIGGERSIZEOK == 1) @intFromEnum(SIIGBF.BIGGERSIZEOK) else 0) | (if (o.MEMORYONLY == 1) @intFromEnum(SIIGBF.MEMORYONLY) else 0) | (if (o.ICONONLY == 1) @intFromEnum(SIIGBF.ICONONLY) else 0) | (if (o.THUMBNAILONLY == 1) @intFromEnum(SIIGBF.THUMBNAILONLY) else 0) | (if (o.INCACHEONLY == 1) @intFromEnum(SIIGBF.INCACHEONLY) else 0) | (if (o.CROPTOSQUARE == 1) @intFromEnum(SIIGBF.CROPTOSQUARE) else 0) | (if (o.WIDETHUMBNAILS == 1) @intFromEnum(SIIGBF.WIDETHUMBNAILS) else 0) | (if (o.ICONBACKGROUND == 1) @intFromEnum(SIIGBF.ICONBACKGROUND) else 0) | (if (o.SCALEUP == 1) @intFromEnum(SIIGBF.SCALEUP) else 0)));
    }
};
pub const SIIGBF_RESIZETOFIT = SIIGBF.RESIZETOFIT;
pub const SIIGBF_BIGGERSIZEOK = SIIGBF.BIGGERSIZEOK;
pub const SIIGBF_MEMORYONLY = SIIGBF.MEMORYONLY;
pub const SIIGBF_ICONONLY = SIIGBF.ICONONLY;
pub const SIIGBF_THUMBNAILONLY = SIIGBF.THUMBNAILONLY;
pub const SIIGBF_INCACHEONLY = SIIGBF.INCACHEONLY;
pub const SIIGBF_CROPTOSQUARE = SIIGBF.CROPTOSQUARE;
pub const SIIGBF_WIDETHUMBNAILS = SIIGBF.WIDETHUMBNAILS;
pub const SIIGBF_ICONBACKGROUND = SIIGBF.ICONBACKGROUND;
pub const SIIGBF_SCALEUP = SIIGBF.SCALEUP;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IShellItemImageFactory_Value = Guid.initString("bcc18b79-ba16-442f-80c4-8a59c30c463b");
pub const IID_IShellItemImageFactory = &IID_IShellItemImageFactory_Value;
pub const IShellItemImageFactory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetImage: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellItemImageFactory,
                size: SIZE,
                flags: SIIGBF,
                phbm: ?*?HBITMAP,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellItemImageFactory,
                size: SIZE,
                flags: SIIGBF,
                phbm: ?*?HBITMAP,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellItemImageFactory_GetImage(self: *const T, size: SIZE, flags: SIIGBF, phbm: ?*?HBITMAP) HRESULT {
                return @as(*const IShellItemImageFactory.VTable, @ptrCast(self.vtable)).GetImage(@as(*const IShellItemImageFactory, @ptrCast(self)), size, flags, phbm);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IEnumShellItems_Value = Guid.initString("70629033-e363-4a28-a567-0db78006e6d7");
pub const IID_IEnumShellItems = &IID_IEnumShellItems_Value;
pub const IEnumShellItems = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumShellItems,
                celt: u32,
                rgelt: [*]?*IShellItem,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumShellItems,
                celt: u32,
                rgelt: [*]?*IShellItem,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumShellItems,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumShellItems,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumShellItems,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumShellItems,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumShellItems,
                ppenum: ?*?*IEnumShellItems,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumShellItems,
                ppenum: ?*?*IEnumShellItems,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumShellItems_Next(self: *const T, celt: u32, rgelt: [*]?*IShellItem, pceltFetched: ?*u32) HRESULT {
                return @as(*const IEnumShellItems.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumShellItems, @ptrCast(self)), celt, rgelt, pceltFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumShellItems_Skip(self: *const T, celt: u32) HRESULT {
                return @as(*const IEnumShellItems.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumShellItems, @ptrCast(self)), celt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumShellItems_Reset(self: *const T) HRESULT {
                return @as(*const IEnumShellItems.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumShellItems, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumShellItems_Clone(self: *const T, ppenum: ?*?*IEnumShellItems) HRESULT {
                return @as(*const IEnumShellItems.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumShellItems, @ptrCast(self)), ppenum);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const STGOP = enum(i32) {
    MOVE = 1,
    COPY = 2,
    SYNC = 3,
    REMOVE = 5,
    RENAME = 6,
    APPLYPROPERTIES = 8,
    NEW = 10,
};
pub const STGOP_MOVE = STGOP.MOVE;
pub const STGOP_COPY = STGOP.COPY;
pub const STGOP_SYNC = STGOP.SYNC;
pub const STGOP_REMOVE = STGOP.REMOVE;
pub const STGOP_RENAME = STGOP.RENAME;
pub const STGOP_APPLYPROPERTIES = STGOP.APPLYPROPERTIES;
pub const STGOP_NEW = STGOP.NEW;

pub const _TRANSFER_SOURCE_FLAGS = enum(i32) {
    NORMAL = 0,
    // FAIL_EXIST = 0, this enum value conflicts with NORMAL
    RENAME_EXIST = 1,
    OVERWRITE_EXIST = 2,
    ALLOW_DECRYPTION = 4,
    NO_SECURITY = 8,
    COPY_CREATION_TIME = 16,
    COPY_WRITE_TIME = 32,
    USE_FULL_ACCESS = 64,
    DELETE_RECYCLE_IF_POSSIBLE = 128,
    COPY_HARD_LINK = 256,
    COPY_LOCALIZED_NAME = 512,
    MOVE_AS_COPY_DELETE = 1024,
    SUSPEND_SHELLEVENTS = 2048,
};
pub const TSF_NORMAL = _TRANSFER_SOURCE_FLAGS.NORMAL;
pub const TSF_FAIL_EXIST = _TRANSFER_SOURCE_FLAGS.NORMAL;
pub const TSF_RENAME_EXIST = _TRANSFER_SOURCE_FLAGS.RENAME_EXIST;
pub const TSF_OVERWRITE_EXIST = _TRANSFER_SOURCE_FLAGS.OVERWRITE_EXIST;
pub const TSF_ALLOW_DECRYPTION = _TRANSFER_SOURCE_FLAGS.ALLOW_DECRYPTION;
pub const TSF_NO_SECURITY = _TRANSFER_SOURCE_FLAGS.NO_SECURITY;
pub const TSF_COPY_CREATION_TIME = _TRANSFER_SOURCE_FLAGS.COPY_CREATION_TIME;
pub const TSF_COPY_WRITE_TIME = _TRANSFER_SOURCE_FLAGS.COPY_WRITE_TIME;
pub const TSF_USE_FULL_ACCESS = _TRANSFER_SOURCE_FLAGS.USE_FULL_ACCESS;
pub const TSF_DELETE_RECYCLE_IF_POSSIBLE = _TRANSFER_SOURCE_FLAGS.DELETE_RECYCLE_IF_POSSIBLE;
pub const TSF_COPY_HARD_LINK = _TRANSFER_SOURCE_FLAGS.COPY_HARD_LINK;
pub const TSF_COPY_LOCALIZED_NAME = _TRANSFER_SOURCE_FLAGS.COPY_LOCALIZED_NAME;
pub const TSF_MOVE_AS_COPY_DELETE = _TRANSFER_SOURCE_FLAGS.MOVE_AS_COPY_DELETE;
pub const TSF_SUSPEND_SHELLEVENTS = _TRANSFER_SOURCE_FLAGS.SUSPEND_SHELLEVENTS;

pub const _TRANSFER_ADVISE_STATE = enum(i32) {
    NONE = 0,
    PERFORMING = 1,
    PREPARING = 2,
    INDETERMINATE = 4,
};
pub const TS_NONE = _TRANSFER_ADVISE_STATE.NONE;
pub const TS_PERFORMING = _TRANSFER_ADVISE_STATE.PERFORMING;
pub const TS_PREPARING = _TRANSFER_ADVISE_STATE.PREPARING;
pub const TS_INDETERMINATE = _TRANSFER_ADVISE_STATE.INDETERMINATE;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ITransferAdviseSink_Value = Guid.initString("d594d0d8-8da7-457b-b3b4-ce5dbaac0b88");
pub const IID_ITransferAdviseSink = &IID_ITransferAdviseSink_Value;
pub const ITransferAdviseSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        UpdateProgress: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITransferAdviseSink,
                ullSizeCurrent: u64,
                ullSizeTotal: u64,
                nFilesCurrent: i32,
                nFilesTotal: i32,
                nFoldersCurrent: i32,
                nFoldersTotal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITransferAdviseSink,
                ullSizeCurrent: u64,
                ullSizeTotal: u64,
                nFilesCurrent: i32,
                nFilesTotal: i32,
                nFoldersCurrent: i32,
                nFoldersTotal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UpdateTransferState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITransferAdviseSink,
                ts: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITransferAdviseSink,
                ts: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ConfirmOverwrite: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITransferAdviseSink,
                psiSource: ?*IShellItem,
                psiDestParent: ?*IShellItem,
                pszName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITransferAdviseSink,
                psiSource: ?*IShellItem,
                psiDestParent: ?*IShellItem,
                pszName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ConfirmEncryptionLoss: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITransferAdviseSink,
                psiSource: ?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITransferAdviseSink,
                psiSource: ?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FileFailure: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITransferAdviseSink,
                psi: ?*IShellItem,
                pszItem: ?[*:0]const u16,
                hrError: HRESULT,
                pszRename: [*:0]u16,
                cchRename: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITransferAdviseSink,
                psi: ?*IShellItem,
                pszItem: ?[*:0]const u16,
                hrError: HRESULT,
                pszRename: [*:0]u16,
                cchRename: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SubStreamFailure: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITransferAdviseSink,
                psi: ?*IShellItem,
                pszStreamName: ?[*:0]const u16,
                hrError: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITransferAdviseSink,
                psi: ?*IShellItem,
                pszStreamName: ?[*:0]const u16,
                hrError: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PropertyFailure: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITransferAdviseSink,
                psi: ?*IShellItem,
                pkey: ?*const PROPERTYKEY,
                hrError: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITransferAdviseSink,
                psi: ?*IShellItem,
                pkey: ?*const PROPERTYKEY,
                hrError: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITransferAdviseSink_UpdateProgress(self: *const T, ullSizeCurrent: u64, ullSizeTotal: u64, nFilesCurrent: i32, nFilesTotal: i32, nFoldersCurrent: i32, nFoldersTotal: i32) HRESULT {
                return @as(*const ITransferAdviseSink.VTable, @ptrCast(self.vtable)).UpdateProgress(@as(*const ITransferAdviseSink, @ptrCast(self)), ullSizeCurrent, ullSizeTotal, nFilesCurrent, nFilesTotal, nFoldersCurrent, nFoldersTotal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITransferAdviseSink_UpdateTransferState(self: *const T, ts: u32) HRESULT {
                return @as(*const ITransferAdviseSink.VTable, @ptrCast(self.vtable)).UpdateTransferState(@as(*const ITransferAdviseSink, @ptrCast(self)), ts);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITransferAdviseSink_ConfirmOverwrite(self: *const T, psiSource: ?*IShellItem, psiDestParent: ?*IShellItem, pszName: ?[*:0]const u16) HRESULT {
                return @as(*const ITransferAdviseSink.VTable, @ptrCast(self.vtable)).ConfirmOverwrite(@as(*const ITransferAdviseSink, @ptrCast(self)), psiSource, psiDestParent, pszName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITransferAdviseSink_ConfirmEncryptionLoss(self: *const T, psiSource: ?*IShellItem) HRESULT {
                return @as(*const ITransferAdviseSink.VTable, @ptrCast(self.vtable)).ConfirmEncryptionLoss(@as(*const ITransferAdviseSink, @ptrCast(self)), psiSource);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITransferAdviseSink_FileFailure(self: *const T, psi: ?*IShellItem, pszItem: ?[*:0]const u16, hrError: HRESULT, pszRename: [*:0]u16, cchRename: u32) HRESULT {
                return @as(*const ITransferAdviseSink.VTable, @ptrCast(self.vtable)).FileFailure(@as(*const ITransferAdviseSink, @ptrCast(self)), psi, pszItem, hrError, pszRename, cchRename);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITransferAdviseSink_SubStreamFailure(self: *const T, psi: ?*IShellItem, pszStreamName: ?[*:0]const u16, hrError: HRESULT) HRESULT {
                return @as(*const ITransferAdviseSink.VTable, @ptrCast(self.vtable)).SubStreamFailure(@as(*const ITransferAdviseSink, @ptrCast(self)), psi, pszStreamName, hrError);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITransferAdviseSink_PropertyFailure(self: *const T, psi: ?*IShellItem, pkey: ?*const PROPERTYKEY, hrError: HRESULT) HRESULT {
                return @as(*const ITransferAdviseSink.VTable, @ptrCast(self.vtable)).PropertyFailure(@as(*const ITransferAdviseSink, @ptrCast(self)), psi, pkey, hrError);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ITransferSource_Value = Guid.initString("00adb003-bde9-45c6-8e29-d09f9353e108");
pub const IID_ITransferSource = &IID_ITransferSource_Value;
pub const ITransferSource = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Advise: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITransferSource,
                psink: ?*ITransferAdviseSink,
                pdwCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITransferSource,
                psink: ?*ITransferAdviseSink,
                pdwCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Unadvise: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITransferSource,
                dwCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITransferSource,
                dwCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetProperties: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITransferSource,
                pproparray: ?*IPropertyChangeArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITransferSource,
                pproparray: ?*IPropertyChangeArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITransferSource,
                psi: ?*IShellItem,
                flags: u32,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITransferSource,
                psi: ?*IShellItem,
                flags: u32,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        MoveItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITransferSource,
                psi: ?*IShellItem,
                psiParentDst: ?*IShellItem,
                pszNameDst: ?[*:0]const u16,
                flags: u32,
                ppsiNew: ?*?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITransferSource,
                psi: ?*IShellItem,
                psiParentDst: ?*IShellItem,
                pszNameDst: ?[*:0]const u16,
                flags: u32,
                ppsiNew: ?*?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RecycleItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITransferSource,
                psiSource: ?*IShellItem,
                psiParentDest: ?*IShellItem,
                flags: u32,
                ppsiNewDest: ?*?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITransferSource,
                psiSource: ?*IShellItem,
                psiParentDest: ?*IShellItem,
                flags: u32,
                ppsiNewDest: ?*?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITransferSource,
                psiSource: ?*IShellItem,
                flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITransferSource,
                psiSource: ?*IShellItem,
                flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RenameItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITransferSource,
                psiSource: ?*IShellItem,
                pszNewName: ?[*:0]const u16,
                flags: u32,
                ppsiNewDest: ?*?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITransferSource,
                psiSource: ?*IShellItem,
                pszNewName: ?[*:0]const u16,
                flags: u32,
                ppsiNewDest: ?*?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LinkItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITransferSource,
                psiSource: ?*IShellItem,
                psiParentDest: ?*IShellItem,
                pszNewName: ?[*:0]const u16,
                flags: u32,
                ppsiNewDest: ?*?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITransferSource,
                psiSource: ?*IShellItem,
                psiParentDest: ?*IShellItem,
                pszNewName: ?[*:0]const u16,
                flags: u32,
                ppsiNewDest: ?*?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ApplyPropertiesToItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITransferSource,
                psiSource: ?*IShellItem,
                ppsiNew: ?*?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITransferSource,
                psiSource: ?*IShellItem,
                ppsiNew: ?*?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDefaultDestinationName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITransferSource,
                psiSource: ?*IShellItem,
                psiParentDest: ?*IShellItem,
                ppszDestinationName: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITransferSource,
                psiSource: ?*IShellItem,
                psiParentDest: ?*IShellItem,
                ppszDestinationName: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnterFolder: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITransferSource,
                psiChildFolderDest: ?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITransferSource,
                psiChildFolderDest: ?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LeaveFolder: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITransferSource,
                psiChildFolderDest: ?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITransferSource,
                psiChildFolderDest: ?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITransferSource_Advise(self: *const T, psink: ?*ITransferAdviseSink, pdwCookie: ?*u32) HRESULT {
                return @as(*const ITransferSource.VTable, @ptrCast(self.vtable)).Advise(@as(*const ITransferSource, @ptrCast(self)), psink, pdwCookie);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITransferSource_Unadvise(self: *const T, dwCookie: u32) HRESULT {
                return @as(*const ITransferSource.VTable, @ptrCast(self.vtable)).Unadvise(@as(*const ITransferSource, @ptrCast(self)), dwCookie);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITransferSource_SetProperties(self: *const T, pproparray: ?*IPropertyChangeArray) HRESULT {
                return @as(*const ITransferSource.VTable, @ptrCast(self.vtable)).SetProperties(@as(*const ITransferSource, @ptrCast(self)), pproparray);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITransferSource_OpenItem(self: *const T, psi: ?*IShellItem, flags: u32, riid: ?*const Guid, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const ITransferSource.VTable, @ptrCast(self.vtable)).OpenItem(@as(*const ITransferSource, @ptrCast(self)), psi, flags, riid, ppv);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITransferSource_MoveItem(self: *const T, psi: ?*IShellItem, psiParentDst: ?*IShellItem, pszNameDst: ?[*:0]const u16, flags: u32, ppsiNew: ?*?*IShellItem) HRESULT {
                return @as(*const ITransferSource.VTable, @ptrCast(self.vtable)).MoveItem(@as(*const ITransferSource, @ptrCast(self)), psi, psiParentDst, pszNameDst, flags, ppsiNew);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITransferSource_RecycleItem(self: *const T, psiSource: ?*IShellItem, psiParentDest: ?*IShellItem, flags: u32, ppsiNewDest: ?*?*IShellItem) HRESULT {
                return @as(*const ITransferSource.VTable, @ptrCast(self.vtable)).RecycleItem(@as(*const ITransferSource, @ptrCast(self)), psiSource, psiParentDest, flags, ppsiNewDest);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITransferSource_RemoveItem(self: *const T, psiSource: ?*IShellItem, flags: u32) HRESULT {
                return @as(*const ITransferSource.VTable, @ptrCast(self.vtable)).RemoveItem(@as(*const ITransferSource, @ptrCast(self)), psiSource, flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITransferSource_RenameItem(self: *const T, psiSource: ?*IShellItem, pszNewName: ?[*:0]const u16, flags: u32, ppsiNewDest: ?*?*IShellItem) HRESULT {
                return @as(*const ITransferSource.VTable, @ptrCast(self.vtable)).RenameItem(@as(*const ITransferSource, @ptrCast(self)), psiSource, pszNewName, flags, ppsiNewDest);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITransferSource_LinkItem(self: *const T, psiSource: ?*IShellItem, psiParentDest: ?*IShellItem, pszNewName: ?[*:0]const u16, flags: u32, ppsiNewDest: ?*?*IShellItem) HRESULT {
                return @as(*const ITransferSource.VTable, @ptrCast(self.vtable)).LinkItem(@as(*const ITransferSource, @ptrCast(self)), psiSource, psiParentDest, pszNewName, flags, ppsiNewDest);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITransferSource_ApplyPropertiesToItem(self: *const T, psiSource: ?*IShellItem, ppsiNew: ?*?*IShellItem) HRESULT {
                return @as(*const ITransferSource.VTable, @ptrCast(self.vtable)).ApplyPropertiesToItem(@as(*const ITransferSource, @ptrCast(self)), psiSource, ppsiNew);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITransferSource_GetDefaultDestinationName(self: *const T, psiSource: ?*IShellItem, psiParentDest: ?*IShellItem, ppszDestinationName: ?*?PWSTR) HRESULT {
                return @as(*const ITransferSource.VTable, @ptrCast(self.vtable)).GetDefaultDestinationName(@as(*const ITransferSource, @ptrCast(self)), psiSource, psiParentDest, ppszDestinationName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITransferSource_EnterFolder(self: *const T, psiChildFolderDest: ?*IShellItem) HRESULT {
                return @as(*const ITransferSource.VTable, @ptrCast(self.vtable)).EnterFolder(@as(*const ITransferSource, @ptrCast(self)), psiChildFolderDest);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITransferSource_LeaveFolder(self: *const T, psiChildFolderDest: ?*IShellItem) HRESULT {
                return @as(*const ITransferSource.VTable, @ptrCast(self.vtable)).LeaveFolder(@as(*const ITransferSource, @ptrCast(self)), psiChildFolderDest);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SHELL_ITEM_RESOURCE = extern struct {
    guidType: Guid,
    szName: [260]u16,
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IEnumResources_Value = Guid.initString("2dd81fe3-a83c-4da9-a330-47249d345ba1");
pub const IID_IEnumResources = &IID_IEnumResources_Value;
pub const IEnumResources = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumResources,
                celt: u32,
                psir: [*]SHELL_ITEM_RESOURCE,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumResources,
                celt: u32,
                psir: [*]SHELL_ITEM_RESOURCE,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumResources,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumResources,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumResources,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumResources,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumResources,
                ppenumr: ?*?*IEnumResources,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumResources,
                ppenumr: ?*?*IEnumResources,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumResources_Next(self: *const T, celt: u32, psir: [*]SHELL_ITEM_RESOURCE, pceltFetched: ?*u32) HRESULT {
                return @as(*const IEnumResources.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumResources, @ptrCast(self)), celt, psir, pceltFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumResources_Skip(self: *const T, celt: u32) HRESULT {
                return @as(*const IEnumResources.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumResources, @ptrCast(self)), celt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumResources_Reset(self: *const T) HRESULT {
                return @as(*const IEnumResources.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumResources, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumResources_Clone(self: *const T, ppenumr: ?*?*IEnumResources) HRESULT {
                return @as(*const IEnumResources.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumResources, @ptrCast(self)), ppenumr);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IShellItemResources_Value = Guid.initString("ff5693be-2ce0-4d48-b5c5-40817d1acdb9");
pub const IID_IShellItemResources = &IID_IShellItemResources_Value;
pub const IShellItemResources = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetAttributes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellItemResources,
                pdwAttributes: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellItemResources,
                pdwAttributes: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellItemResources,
                pullSize: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellItemResources,
                pullSize: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTimes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellItemResources,
                pftCreation: ?*FILETIME,
                pftWrite: ?*FILETIME,
                pftAccess: ?*FILETIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellItemResources,
                pftCreation: ?*FILETIME,
                pftWrite: ?*FILETIME,
                pftAccess: ?*FILETIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTimes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellItemResources,
                pftCreation: ?*const FILETIME,
                pftWrite: ?*const FILETIME,
                pftAccess: ?*const FILETIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellItemResources,
                pftCreation: ?*const FILETIME,
                pftWrite: ?*const FILETIME,
                pftAccess: ?*const FILETIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetResourceDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellItemResources,
                pcsir: ?*const SHELL_ITEM_RESOURCE,
                ppszDescription: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellItemResources,
                pcsir: ?*const SHELL_ITEM_RESOURCE,
                ppszDescription: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumResources: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellItemResources,
                ppenumr: ?*?*IEnumResources,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellItemResources,
                ppenumr: ?*?*IEnumResources,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SupportsResource: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellItemResources,
                pcsir: ?*const SHELL_ITEM_RESOURCE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellItemResources,
                pcsir: ?*const SHELL_ITEM_RESOURCE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenResource: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellItemResources,
                pcsir: ?*const SHELL_ITEM_RESOURCE,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellItemResources,
                pcsir: ?*const SHELL_ITEM_RESOURCE,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateResource: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellItemResources,
                pcsir: ?*const SHELL_ITEM_RESOURCE,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellItemResources,
                pcsir: ?*const SHELL_ITEM_RESOURCE,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        MarkForDelete: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellItemResources,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellItemResources,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellItemResources_GetAttributes(self: *const T, pdwAttributes: ?*u32) HRESULT {
                return @as(*const IShellItemResources.VTable, @ptrCast(self.vtable)).GetAttributes(@as(*const IShellItemResources, @ptrCast(self)), pdwAttributes);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellItemResources_GetSize(self: *const T, pullSize: ?*u64) HRESULT {
                return @as(*const IShellItemResources.VTable, @ptrCast(self.vtable)).GetSize(@as(*const IShellItemResources, @ptrCast(self)), pullSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellItemResources_GetTimes(self: *const T, pftCreation: ?*FILETIME, pftWrite: ?*FILETIME, pftAccess: ?*FILETIME) HRESULT {
                return @as(*const IShellItemResources.VTable, @ptrCast(self.vtable)).GetTimes(@as(*const IShellItemResources, @ptrCast(self)), pftCreation, pftWrite, pftAccess);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellItemResources_SetTimes(self: *const T, pftCreation: ?*const FILETIME, pftWrite: ?*const FILETIME, pftAccess: ?*const FILETIME) HRESULT {
                return @as(*const IShellItemResources.VTable, @ptrCast(self.vtable)).SetTimes(@as(*const IShellItemResources, @ptrCast(self)), pftCreation, pftWrite, pftAccess);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellItemResources_GetResourceDescription(self: *const T, pcsir: ?*const SHELL_ITEM_RESOURCE, ppszDescription: ?*?PWSTR) HRESULT {
                return @as(*const IShellItemResources.VTable, @ptrCast(self.vtable)).GetResourceDescription(@as(*const IShellItemResources, @ptrCast(self)), pcsir, ppszDescription);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellItemResources_EnumResources(self: *const T, ppenumr: ?*?*IEnumResources) HRESULT {
                return @as(*const IShellItemResources.VTable, @ptrCast(self.vtable)).EnumResources(@as(*const IShellItemResources, @ptrCast(self)), ppenumr);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellItemResources_SupportsResource(self: *const T, pcsir: ?*const SHELL_ITEM_RESOURCE) HRESULT {
                return @as(*const IShellItemResources.VTable, @ptrCast(self.vtable)).SupportsResource(@as(*const IShellItemResources, @ptrCast(self)), pcsir);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellItemResources_OpenResource(self: *const T, pcsir: ?*const SHELL_ITEM_RESOURCE, riid: ?*const Guid, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const IShellItemResources.VTable, @ptrCast(self.vtable)).OpenResource(@as(*const IShellItemResources, @ptrCast(self)), pcsir, riid, ppv);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellItemResources_CreateResource(self: *const T, pcsir: ?*const SHELL_ITEM_RESOURCE, riid: ?*const Guid, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const IShellItemResources.VTable, @ptrCast(self.vtable)).CreateResource(@as(*const IShellItemResources, @ptrCast(self)), pcsir, riid, ppv);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellItemResources_MarkForDelete(self: *const T) HRESULT {
                return @as(*const IShellItemResources.VTable, @ptrCast(self.vtable)).MarkForDelete(@as(*const IShellItemResources, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ITransferDestination_Value = Guid.initString("48addd32-3ca5-4124-abe3-b5a72531b207");
pub const IID_ITransferDestination = &IID_ITransferDestination_Value;
pub const ITransferDestination = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Advise: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITransferDestination,
                psink: ?*ITransferAdviseSink,
                pdwCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITransferDestination,
                psink: ?*ITransferAdviseSink,
                pdwCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Unadvise: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITransferDestination,
                dwCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITransferDestination,
                dwCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITransferDestination,
                pszName: ?[*:0]const u16,
                dwAttributes: u32,
                ullSize: u64,
                flags: u32,
                riidItem: ?*const Guid,
                ppvItem: ?*?*anyopaque,
                riidResources: ?*const Guid,
                ppvResources: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITransferDestination,
                pszName: ?[*:0]const u16,
                dwAttributes: u32,
                ullSize: u64,
                flags: u32,
                riidItem: ?*const Guid,
                ppvItem: ?*?*anyopaque,
                riidResources: ?*const Guid,
                ppvResources: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITransferDestination_Advise(self: *const T, psink: ?*ITransferAdviseSink, pdwCookie: ?*u32) HRESULT {
                return @as(*const ITransferDestination.VTable, @ptrCast(self.vtable)).Advise(@as(*const ITransferDestination, @ptrCast(self)), psink, pdwCookie);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITransferDestination_Unadvise(self: *const T, dwCookie: u32) HRESULT {
                return @as(*const ITransferDestination.VTable, @ptrCast(self.vtable)).Unadvise(@as(*const ITransferDestination, @ptrCast(self)), dwCookie);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITransferDestination_CreateItem(self: *const T, pszName: ?[*:0]const u16, dwAttributes: u32, ullSize: u64, flags: u32, riidItem: ?*const Guid, ppvItem: ?*?*anyopaque, riidResources: ?*const Guid, ppvResources: ?*?*anyopaque) HRESULT {
                return @as(*const ITransferDestination.VTable, @ptrCast(self.vtable)).CreateItem(@as(*const ITransferDestination, @ptrCast(self)), pszName, dwAttributes, ullSize, flags, riidItem, ppvItem, riidResources, ppvResources);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IFileOperationProgressSink_Value = Guid.initString("04b0f1a7-9490-44bc-96e1-4296a31252e2");
pub const IID_IFileOperationProgressSink = &IID_IFileOperationProgressSink_Value;
pub const IFileOperationProgressSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        StartOperations: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileOperationProgressSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileOperationProgressSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FinishOperations: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileOperationProgressSink,
                hrResult: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileOperationProgressSink,
                hrResult: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PreRenameItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileOperationProgressSink,
                dwFlags: u32,
                psiItem: ?*IShellItem,
                pszNewName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileOperationProgressSink,
                dwFlags: u32,
                psiItem: ?*IShellItem,
                pszNewName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PostRenameItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileOperationProgressSink,
                dwFlags: u32,
                psiItem: ?*IShellItem,
                pszNewName: ?[*:0]const u16,
                hrRename: HRESULT,
                psiNewlyCreated: ?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileOperationProgressSink,
                dwFlags: u32,
                psiItem: ?*IShellItem,
                pszNewName: ?[*:0]const u16,
                hrRename: HRESULT,
                psiNewlyCreated: ?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PreMoveItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileOperationProgressSink,
                dwFlags: u32,
                psiItem: ?*IShellItem,
                psiDestinationFolder: ?*IShellItem,
                pszNewName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileOperationProgressSink,
                dwFlags: u32,
                psiItem: ?*IShellItem,
                psiDestinationFolder: ?*IShellItem,
                pszNewName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PostMoveItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileOperationProgressSink,
                dwFlags: u32,
                psiItem: ?*IShellItem,
                psiDestinationFolder: ?*IShellItem,
                pszNewName: ?[*:0]const u16,
                hrMove: HRESULT,
                psiNewlyCreated: ?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileOperationProgressSink,
                dwFlags: u32,
                psiItem: ?*IShellItem,
                psiDestinationFolder: ?*IShellItem,
                pszNewName: ?[*:0]const u16,
                hrMove: HRESULT,
                psiNewlyCreated: ?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PreCopyItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileOperationProgressSink,
                dwFlags: u32,
                psiItem: ?*IShellItem,
                psiDestinationFolder: ?*IShellItem,
                pszNewName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileOperationProgressSink,
                dwFlags: u32,
                psiItem: ?*IShellItem,
                psiDestinationFolder: ?*IShellItem,
                pszNewName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PostCopyItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileOperationProgressSink,
                dwFlags: u32,
                psiItem: ?*IShellItem,
                psiDestinationFolder: ?*IShellItem,
                pszNewName: ?[*:0]const u16,
                hrCopy: HRESULT,
                psiNewlyCreated: ?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileOperationProgressSink,
                dwFlags: u32,
                psiItem: ?*IShellItem,
                psiDestinationFolder: ?*IShellItem,
                pszNewName: ?[*:0]const u16,
                hrCopy: HRESULT,
                psiNewlyCreated: ?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PreDeleteItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileOperationProgressSink,
                dwFlags: u32,
                psiItem: ?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileOperationProgressSink,
                dwFlags: u32,
                psiItem: ?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PostDeleteItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileOperationProgressSink,
                dwFlags: u32,
                psiItem: ?*IShellItem,
                hrDelete: HRESULT,
                psiNewlyCreated: ?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileOperationProgressSink,
                dwFlags: u32,
                psiItem: ?*IShellItem,
                hrDelete: HRESULT,
                psiNewlyCreated: ?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PreNewItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileOperationProgressSink,
                dwFlags: u32,
                psiDestinationFolder: ?*IShellItem,
                pszNewName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileOperationProgressSink,
                dwFlags: u32,
                psiDestinationFolder: ?*IShellItem,
                pszNewName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PostNewItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileOperationProgressSink,
                dwFlags: u32,
                psiDestinationFolder: ?*IShellItem,
                pszNewName: ?[*:0]const u16,
                pszTemplateName: ?[*:0]const u16,
                dwFileAttributes: u32,
                hrNew: HRESULT,
                psiNewItem: ?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileOperationProgressSink,
                dwFlags: u32,
                psiDestinationFolder: ?*IShellItem,
                pszNewName: ?[*:0]const u16,
                pszTemplateName: ?[*:0]const u16,
                dwFileAttributes: u32,
                hrNew: HRESULT,
                psiNewItem: ?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UpdateProgress: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileOperationProgressSink,
                iWorkTotal: u32,
                iWorkSoFar: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileOperationProgressSink,
                iWorkTotal: u32,
                iWorkSoFar: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ResetTimer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileOperationProgressSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileOperationProgressSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PauseTimer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileOperationProgressSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileOperationProgressSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ResumeTimer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileOperationProgressSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileOperationProgressSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileOperationProgressSink_StartOperations(self: *const T) HRESULT {
                return @as(*const IFileOperationProgressSink.VTable, @ptrCast(self.vtable)).StartOperations(@as(*const IFileOperationProgressSink, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileOperationProgressSink_FinishOperations(self: *const T, hrResult: HRESULT) HRESULT {
                return @as(*const IFileOperationProgressSink.VTable, @ptrCast(self.vtable)).FinishOperations(@as(*const IFileOperationProgressSink, @ptrCast(self)), hrResult);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileOperationProgressSink_PreRenameItem(self: *const T, dwFlags: u32, psiItem: ?*IShellItem, pszNewName: ?[*:0]const u16) HRESULT {
                return @as(*const IFileOperationProgressSink.VTable, @ptrCast(self.vtable)).PreRenameItem(@as(*const IFileOperationProgressSink, @ptrCast(self)), dwFlags, psiItem, pszNewName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileOperationProgressSink_PostRenameItem(self: *const T, dwFlags: u32, psiItem: ?*IShellItem, pszNewName: ?[*:0]const u16, hrRename: HRESULT, psiNewlyCreated: ?*IShellItem) HRESULT {
                return @as(*const IFileOperationProgressSink.VTable, @ptrCast(self.vtable)).PostRenameItem(@as(*const IFileOperationProgressSink, @ptrCast(self)), dwFlags, psiItem, pszNewName, hrRename, psiNewlyCreated);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileOperationProgressSink_PreMoveItem(self: *const T, dwFlags: u32, psiItem: ?*IShellItem, psiDestinationFolder: ?*IShellItem, pszNewName: ?[*:0]const u16) HRESULT {
                return @as(*const IFileOperationProgressSink.VTable, @ptrCast(self.vtable)).PreMoveItem(@as(*const IFileOperationProgressSink, @ptrCast(self)), dwFlags, psiItem, psiDestinationFolder, pszNewName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileOperationProgressSink_PostMoveItem(self: *const T, dwFlags: u32, psiItem: ?*IShellItem, psiDestinationFolder: ?*IShellItem, pszNewName: ?[*:0]const u16, hrMove: HRESULT, psiNewlyCreated: ?*IShellItem) HRESULT {
                return @as(*const IFileOperationProgressSink.VTable, @ptrCast(self.vtable)).PostMoveItem(@as(*const IFileOperationProgressSink, @ptrCast(self)), dwFlags, psiItem, psiDestinationFolder, pszNewName, hrMove, psiNewlyCreated);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileOperationProgressSink_PreCopyItem(self: *const T, dwFlags: u32, psiItem: ?*IShellItem, psiDestinationFolder: ?*IShellItem, pszNewName: ?[*:0]const u16) HRESULT {
                return @as(*const IFileOperationProgressSink.VTable, @ptrCast(self.vtable)).PreCopyItem(@as(*const IFileOperationProgressSink, @ptrCast(self)), dwFlags, psiItem, psiDestinationFolder, pszNewName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileOperationProgressSink_PostCopyItem(self: *const T, dwFlags: u32, psiItem: ?*IShellItem, psiDestinationFolder: ?*IShellItem, pszNewName: ?[*:0]const u16, hrCopy: HRESULT, psiNewlyCreated: ?*IShellItem) HRESULT {
                return @as(*const IFileOperationProgressSink.VTable, @ptrCast(self.vtable)).PostCopyItem(@as(*const IFileOperationProgressSink, @ptrCast(self)), dwFlags, psiItem, psiDestinationFolder, pszNewName, hrCopy, psiNewlyCreated);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileOperationProgressSink_PreDeleteItem(self: *const T, dwFlags: u32, psiItem: ?*IShellItem) HRESULT {
                return @as(*const IFileOperationProgressSink.VTable, @ptrCast(self.vtable)).PreDeleteItem(@as(*const IFileOperationProgressSink, @ptrCast(self)), dwFlags, psiItem);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileOperationProgressSink_PostDeleteItem(self: *const T, dwFlags: u32, psiItem: ?*IShellItem, hrDelete: HRESULT, psiNewlyCreated: ?*IShellItem) HRESULT {
                return @as(*const IFileOperationProgressSink.VTable, @ptrCast(self.vtable)).PostDeleteItem(@as(*const IFileOperationProgressSink, @ptrCast(self)), dwFlags, psiItem, hrDelete, psiNewlyCreated);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileOperationProgressSink_PreNewItem(self: *const T, dwFlags: u32, psiDestinationFolder: ?*IShellItem, pszNewName: ?[*:0]const u16) HRESULT {
                return @as(*const IFileOperationProgressSink.VTable, @ptrCast(self.vtable)).PreNewItem(@as(*const IFileOperationProgressSink, @ptrCast(self)), dwFlags, psiDestinationFolder, pszNewName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileOperationProgressSink_PostNewItem(self: *const T, dwFlags: u32, psiDestinationFolder: ?*IShellItem, pszNewName: ?[*:0]const u16, pszTemplateName: ?[*:0]const u16, dwFileAttributes: u32, hrNew: HRESULT, psiNewItem: ?*IShellItem) HRESULT {
                return @as(*const IFileOperationProgressSink.VTable, @ptrCast(self.vtable)).PostNewItem(@as(*const IFileOperationProgressSink, @ptrCast(self)), dwFlags, psiDestinationFolder, pszNewName, pszTemplateName, dwFileAttributes, hrNew, psiNewItem);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileOperationProgressSink_UpdateProgress(self: *const T, iWorkTotal: u32, iWorkSoFar: u32) HRESULT {
                return @as(*const IFileOperationProgressSink.VTable, @ptrCast(self.vtable)).UpdateProgress(@as(*const IFileOperationProgressSink, @ptrCast(self)), iWorkTotal, iWorkSoFar);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileOperationProgressSink_ResetTimer(self: *const T) HRESULT {
                return @as(*const IFileOperationProgressSink.VTable, @ptrCast(self.vtable)).ResetTimer(@as(*const IFileOperationProgressSink, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileOperationProgressSink_PauseTimer(self: *const T) HRESULT {
                return @as(*const IFileOperationProgressSink.VTable, @ptrCast(self.vtable)).PauseTimer(@as(*const IFileOperationProgressSink, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileOperationProgressSink_ResumeTimer(self: *const T) HRESULT {
                return @as(*const IFileOperationProgressSink.VTable, @ptrCast(self.vtable)).ResumeTimer(@as(*const IFileOperationProgressSink, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SIATTRIBFLAGS = enum(i32) {
    AND = 1,
    OR = 2,
    APPCOMPAT = 3,
    // MASK = 3, this enum value conflicts with APPCOMPAT
    ALLITEMS = 16384,
};
pub const SIATTRIBFLAGS_AND = SIATTRIBFLAGS.AND;
pub const SIATTRIBFLAGS_OR = SIATTRIBFLAGS.OR;
pub const SIATTRIBFLAGS_APPCOMPAT = SIATTRIBFLAGS.APPCOMPAT;
pub const SIATTRIBFLAGS_MASK = SIATTRIBFLAGS.APPCOMPAT;
pub const SIATTRIBFLAGS_ALLITEMS = SIATTRIBFLAGS.ALLITEMS;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IShellItemArray_Value = Guid.initString("b63ea76d-1f85-456f-a19c-48159efa858b");
pub const IID_IShellItemArray = &IID_IShellItemArray_Value;
pub const IShellItemArray = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        BindToHandler: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellItemArray,
                pbc: ?*IBindCtx,
                bhid: ?*const Guid,
                riid: ?*const Guid,
                ppvOut: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellItemArray,
                pbc: ?*IBindCtx,
                bhid: ?*const Guid,
                riid: ?*const Guid,
                ppvOut: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPropertyStore: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellItemArray,
                flags: GETPROPERTYSTOREFLAGS,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellItemArray,
                flags: GETPROPERTYSTOREFLAGS,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPropertyDescriptionList: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellItemArray,
                keyType: ?*const PROPERTYKEY,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellItemArray,
                keyType: ?*const PROPERTYKEY,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAttributes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellItemArray,
                AttribFlags: SIATTRIBFLAGS,
                sfgaoMask: u32,
                psfgaoAttribs: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellItemArray,
                AttribFlags: SIATTRIBFLAGS,
                sfgaoMask: u32,
                psfgaoAttribs: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellItemArray,
                pdwNumItems: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellItemArray,
                pdwNumItems: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetItemAt: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellItemArray,
                dwIndex: u32,
                ppsi: ?*?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellItemArray,
                dwIndex: u32,
                ppsi: ?*?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumItems: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellItemArray,
                ppenumShellItems: ?*?*IEnumShellItems,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellItemArray,
                ppenumShellItems: ?*?*IEnumShellItems,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellItemArray_BindToHandler(self: *const T, pbc: ?*IBindCtx, bhid: ?*const Guid, riid: ?*const Guid, ppvOut: ?*?*anyopaque) HRESULT {
                return @as(*const IShellItemArray.VTable, @ptrCast(self.vtable)).BindToHandler(@as(*const IShellItemArray, @ptrCast(self)), pbc, bhid, riid, ppvOut);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellItemArray_GetPropertyStore(self: *const T, flags: GETPROPERTYSTOREFLAGS, riid: ?*const Guid, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const IShellItemArray.VTable, @ptrCast(self.vtable)).GetPropertyStore(@as(*const IShellItemArray, @ptrCast(self)), flags, riid, ppv);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellItemArray_GetPropertyDescriptionList(self: *const T, keyType: ?*const PROPERTYKEY, riid: ?*const Guid, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const IShellItemArray.VTable, @ptrCast(self.vtable)).GetPropertyDescriptionList(@as(*const IShellItemArray, @ptrCast(self)), keyType, riid, ppv);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellItemArray_GetAttributes(self: *const T, AttribFlags: SIATTRIBFLAGS, sfgaoMask: u32, psfgaoAttribs: ?*u32) HRESULT {
                return @as(*const IShellItemArray.VTable, @ptrCast(self.vtable)).GetAttributes(@as(*const IShellItemArray, @ptrCast(self)), AttribFlags, sfgaoMask, psfgaoAttribs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellItemArray_GetCount(self: *const T, pdwNumItems: ?*u32) HRESULT {
                return @as(*const IShellItemArray.VTable, @ptrCast(self.vtable)).GetCount(@as(*const IShellItemArray, @ptrCast(self)), pdwNumItems);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellItemArray_GetItemAt(self: *const T, dwIndex: u32, ppsi: ?*?*IShellItem) HRESULT {
                return @as(*const IShellItemArray.VTable, @ptrCast(self.vtable)).GetItemAt(@as(*const IShellItemArray, @ptrCast(self)), dwIndex, ppsi);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellItemArray_EnumItems(self: *const T, ppenumShellItems: ?*?*IEnumShellItems) HRESULT {
                return @as(*const IShellItemArray.VTable, @ptrCast(self.vtable)).EnumItems(@as(*const IShellItemArray, @ptrCast(self)), ppenumShellItems);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IInitializeWithItem_Value = Guid.initString("7f73be3f-fb79-493c-a6c7-7ee14e245841");
pub const IID_IInitializeWithItem = &IID_IInitializeWithItem_Value;
pub const IInitializeWithItem = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInitializeWithItem,
                psi: ?*IShellItem,
                grfMode: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInitializeWithItem,
                psi: ?*IShellItem,
                grfMode: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInitializeWithItem_Initialize(self: *const T, psi: ?*IShellItem, grfMode: u32) HRESULT {
                return @as(*const IInitializeWithItem.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IInitializeWithItem, @ptrCast(self)), psi, grfMode);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IObjectWithSelection_Value = Guid.initString("1c9cd5bb-98e9-4491-a60f-31aacc72b83c");
pub const IID_IObjectWithSelection = &IID_IObjectWithSelection_Value;
pub const IObjectWithSelection = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetSelection: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IObjectWithSelection,
                psia: ?*IShellItemArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IObjectWithSelection,
                psia: ?*IShellItemArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSelection: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IObjectWithSelection,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IObjectWithSelection,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IObjectWithSelection_SetSelection(self: *const T, psia: ?*IShellItemArray) HRESULT {
                return @as(*const IObjectWithSelection.VTable, @ptrCast(self.vtable)).SetSelection(@as(*const IObjectWithSelection, @ptrCast(self)), psia);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IObjectWithSelection_GetSelection(self: *const T, riid: ?*const Guid, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const IObjectWithSelection.VTable, @ptrCast(self.vtable)).GetSelection(@as(*const IObjectWithSelection, @ptrCast(self)), riid, ppv);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IObjectWithBackReferences_Value = Guid.initString("321a6a6a-d61f-4bf3-97ae-14be2986bb36");
pub const IID_IObjectWithBackReferences = &IID_IObjectWithBackReferences_Value;
pub const IObjectWithBackReferences = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RemoveBackReferences: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IObjectWithBackReferences,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IObjectWithBackReferences,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IObjectWithBackReferences_RemoveBackReferences(self: *const T) HRESULT {
                return @as(*const IObjectWithBackReferences.VTable, @ptrCast(self.vtable)).RemoveBackReferences(@as(*const IObjectWithBackReferences, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ICategoryProvider_Value = Guid.initString("9af64809-5864-4c26-a720-c1f78c086ee3");
pub const IID_ICategoryProvider = &IID_ICategoryProvider_Value;
pub const ICategoryProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CanCategorizeOnSCID: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICategoryProvider,
                pscid: ?*const PROPERTYKEY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICategoryProvider,
                pscid: ?*const PROPERTYKEY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDefaultCategory: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICategoryProvider,
                pguid: ?*Guid,
                pscid: ?*PROPERTYKEY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICategoryProvider,
                pguid: ?*Guid,
                pscid: ?*PROPERTYKEY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCategoryForSCID: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICategoryProvider,
                pscid: ?*const PROPERTYKEY,
                pguid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICategoryProvider,
                pscid: ?*const PROPERTYKEY,
                pguid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumCategories: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICategoryProvider,
                penum: ?*?*IEnumGUID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICategoryProvider,
                penum: ?*?*IEnumGUID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCategoryName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICategoryProvider,
                pguid: ?*const Guid,
                pszName: [*:0]u16,
                cch: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICategoryProvider,
                pguid: ?*const Guid,
                pszName: [*:0]u16,
                cch: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateCategory: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICategoryProvider,
                pguid: ?*const Guid,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICategoryProvider,
                pguid: ?*const Guid,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICategoryProvider_CanCategorizeOnSCID(self: *const T, pscid: ?*const PROPERTYKEY) HRESULT {
                return @as(*const ICategoryProvider.VTable, @ptrCast(self.vtable)).CanCategorizeOnSCID(@as(*const ICategoryProvider, @ptrCast(self)), pscid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICategoryProvider_GetDefaultCategory(self: *const T, pguid: ?*Guid, pscid: ?*PROPERTYKEY) HRESULT {
                return @as(*const ICategoryProvider.VTable, @ptrCast(self.vtable)).GetDefaultCategory(@as(*const ICategoryProvider, @ptrCast(self)), pguid, pscid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICategoryProvider_GetCategoryForSCID(self: *const T, pscid: ?*const PROPERTYKEY, pguid: ?*Guid) HRESULT {
                return @as(*const ICategoryProvider.VTable, @ptrCast(self.vtable)).GetCategoryForSCID(@as(*const ICategoryProvider, @ptrCast(self)), pscid, pguid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICategoryProvider_EnumCategories(self: *const T, penum: ?*?*IEnumGUID) HRESULT {
                return @as(*const ICategoryProvider.VTable, @ptrCast(self.vtable)).EnumCategories(@as(*const ICategoryProvider, @ptrCast(self)), penum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICategoryProvider_GetCategoryName(self: *const T, pguid: ?*const Guid, pszName: [*:0]u16, cch: u32) HRESULT {
                return @as(*const ICategoryProvider.VTable, @ptrCast(self.vtable)).GetCategoryName(@as(*const ICategoryProvider, @ptrCast(self)), pguid, pszName, cch);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICategoryProvider_CreateCategory(self: *const T, pguid: ?*const Guid, riid: ?*const Guid, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const ICategoryProvider.VTable, @ptrCast(self.vtable)).CreateCategory(@as(*const ICategoryProvider, @ptrCast(self)), pguid, riid, ppv);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const CATEGORYINFO_FLAGS = enum(i32) {
    NORMAL = 0,
    COLLAPSED = 1,
    HIDDEN = 2,
    EXPANDED = 4,
    NOHEADER = 8,
    NOTCOLLAPSIBLE = 16,
    NOHEADERCOUNT = 32,
    SUBSETTED = 64,
    SEPARATE_IMAGES = 128,
    SHOWEMPTY = 256,
};
pub const CATINFO_NORMAL = CATEGORYINFO_FLAGS.NORMAL;
pub const CATINFO_COLLAPSED = CATEGORYINFO_FLAGS.COLLAPSED;
pub const CATINFO_HIDDEN = CATEGORYINFO_FLAGS.HIDDEN;
pub const CATINFO_EXPANDED = CATEGORYINFO_FLAGS.EXPANDED;
pub const CATINFO_NOHEADER = CATEGORYINFO_FLAGS.NOHEADER;
pub const CATINFO_NOTCOLLAPSIBLE = CATEGORYINFO_FLAGS.NOTCOLLAPSIBLE;
pub const CATINFO_NOHEADERCOUNT = CATEGORYINFO_FLAGS.NOHEADERCOUNT;
pub const CATINFO_SUBSETTED = CATEGORYINFO_FLAGS.SUBSETTED;
pub const CATINFO_SEPARATE_IMAGES = CATEGORYINFO_FLAGS.SEPARATE_IMAGES;
pub const CATINFO_SHOWEMPTY = CATEGORYINFO_FLAGS.SHOWEMPTY;

pub const CATSORT_FLAGS = enum(i32) {
    DEFAULT = 0,
    NAME = 1,
};
pub const CATSORT_DEFAULT = CATSORT_FLAGS.DEFAULT;
pub const CATSORT_NAME = CATSORT_FLAGS.NAME;

pub const CATEGORY_INFO = extern struct {
    cif: CATEGORYINFO_FLAGS,
    wszName: [260]u16,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ICategorizer_Value = Guid.initString("a3b14589-9174-49a8-89a3-06a1ae2b9ba7");
pub const IID_ICategorizer = &IID_ICategorizer_Value;
pub const ICategorizer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICategorizer,
                pszDesc: [*:0]u16,
                cch: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICategorizer,
                pszDesc: [*:0]u16,
                cch: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCategory: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICategorizer,
                cidl: u32,
                apidl: [*]?*ITEMIDLIST,
                rgCategoryIds: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICategorizer,
                cidl: u32,
                apidl: [*]?*ITEMIDLIST,
                rgCategoryIds: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCategoryInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICategorizer,
                dwCategoryId: u32,
                pci: ?*CATEGORY_INFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICategorizer,
                dwCategoryId: u32,
                pci: ?*CATEGORY_INFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CompareCategory: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICategorizer,
                csfFlags: CATSORT_FLAGS,
                dwCategoryId1: u32,
                dwCategoryId2: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICategorizer,
                csfFlags: CATSORT_FLAGS,
                dwCategoryId1: u32,
                dwCategoryId2: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICategorizer_GetDescription(self: *const T, pszDesc: [*:0]u16, cch: u32) HRESULT {
                return @as(*const ICategorizer.VTable, @ptrCast(self.vtable)).GetDescription(@as(*const ICategorizer, @ptrCast(self)), pszDesc, cch);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICategorizer_GetCategory(self: *const T, cidl: u32, apidl: [*]?*ITEMIDLIST, rgCategoryIds: [*]u32) HRESULT {
                return @as(*const ICategorizer.VTable, @ptrCast(self.vtable)).GetCategory(@as(*const ICategorizer, @ptrCast(self)), cidl, apidl, rgCategoryIds);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICategorizer_GetCategoryInfo(self: *const T, dwCategoryId: u32, pci: ?*CATEGORY_INFO) HRESULT {
                return @as(*const ICategorizer.VTable, @ptrCast(self.vtable)).GetCategoryInfo(@as(*const ICategorizer, @ptrCast(self)), dwCategoryId, pci);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICategorizer_CompareCategory(self: *const T, csfFlags: CATSORT_FLAGS, dwCategoryId1: u32, dwCategoryId2: u32) HRESULT {
                return @as(*const ICategorizer.VTable, @ptrCast(self.vtable)).CompareCategory(@as(*const ICategorizer, @ptrCast(self)), csfFlags, dwCategoryId1, dwCategoryId2);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SHDRAGIMAGE = extern struct {
    sizeDragImage: SIZE,
    ptOffset: POINT,
    hbmpDragImage: ?HBITMAP,
    crColorKey: u32,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IDropTargetHelper_Value = Guid.initString("4657278b-411b-11d2-839a-00c04fd918d0");
pub const IID_IDropTargetHelper = &IID_IDropTargetHelper_Value;
pub const IDropTargetHelper = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        DragEnter: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDropTargetHelper,
                hwndTarget: ?HWND,
                pDataObject: ?*IDataObject,
                ppt: ?*POINT,
                dwEffect: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDropTargetHelper,
                hwndTarget: ?HWND,
                pDataObject: ?*IDataObject,
                ppt: ?*POINT,
                dwEffect: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DragLeave: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDropTargetHelper,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDropTargetHelper,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DragOver: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDropTargetHelper,
                ppt: ?*POINT,
                dwEffect: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDropTargetHelper,
                ppt: ?*POINT,
                dwEffect: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Drop: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDropTargetHelper,
                pDataObject: ?*IDataObject,
                ppt: ?*POINT,
                dwEffect: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDropTargetHelper,
                pDataObject: ?*IDataObject,
                ppt: ?*POINT,
                dwEffect: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Show: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDropTargetHelper,
                fShow: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDropTargetHelper,
                fShow: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDropTargetHelper_DragEnter(self: *const T, hwndTarget: ?HWND, pDataObject: ?*IDataObject, ppt: ?*POINT, dwEffect: u32) HRESULT {
                return @as(*const IDropTargetHelper.VTable, @ptrCast(self.vtable)).DragEnter(@as(*const IDropTargetHelper, @ptrCast(self)), hwndTarget, pDataObject, ppt, dwEffect);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDropTargetHelper_DragLeave(self: *const T) HRESULT {
                return @as(*const IDropTargetHelper.VTable, @ptrCast(self.vtable)).DragLeave(@as(*const IDropTargetHelper, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDropTargetHelper_DragOver(self: *const T, ppt: ?*POINT, dwEffect: u32) HRESULT {
                return @as(*const IDropTargetHelper.VTable, @ptrCast(self.vtable)).DragOver(@as(*const IDropTargetHelper, @ptrCast(self)), ppt, dwEffect);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDropTargetHelper_Drop(self: *const T, pDataObject: ?*IDataObject, ppt: ?*POINT, dwEffect: u32) HRESULT {
                return @as(*const IDropTargetHelper.VTable, @ptrCast(self.vtable)).Drop(@as(*const IDropTargetHelper, @ptrCast(self)), pDataObject, ppt, dwEffect);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDropTargetHelper_Show(self: *const T, fShow: BOOL) HRESULT {
                return @as(*const IDropTargetHelper.VTable, @ptrCast(self.vtable)).Show(@as(*const IDropTargetHelper, @ptrCast(self)), fShow);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IDragSourceHelper_Value = Guid.initString("de5bf786-477a-11d2-839d-00c04fd918d0");
pub const IID_IDragSourceHelper = &IID_IDragSourceHelper_Value;
pub const IDragSourceHelper = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        InitializeFromBitmap: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDragSourceHelper,
                pshdi: ?*SHDRAGIMAGE,
                pDataObject: ?*IDataObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDragSourceHelper,
                pshdi: ?*SHDRAGIMAGE,
                pDataObject: ?*IDataObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InitializeFromWindow: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDragSourceHelper,
                hwnd: ?HWND,
                ppt: ?*POINT,
                pDataObject: ?*IDataObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDragSourceHelper,
                hwnd: ?HWND,
                ppt: ?*POINT,
                pDataObject: ?*IDataObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDragSourceHelper_InitializeFromBitmap(self: *const T, pshdi: ?*SHDRAGIMAGE, pDataObject: ?*IDataObject) HRESULT {
                return @as(*const IDragSourceHelper.VTable, @ptrCast(self.vtable)).InitializeFromBitmap(@as(*const IDragSourceHelper, @ptrCast(self)), pshdi, pDataObject);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDragSourceHelper_InitializeFromWindow(self: *const T, hwnd: ?HWND, ppt: ?*POINT, pDataObject: ?*IDataObject) HRESULT {
                return @as(*const IDragSourceHelper.VTable, @ptrCast(self.vtable)).InitializeFromWindow(@as(*const IDragSourceHelper, @ptrCast(self)), hwnd, ppt, pDataObject);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SLR_FLAGS = enum(i32) {
    NONE = 0,
    NO_UI = 1,
    ANY_MATCH = 2,
    UPDATE = 4,
    NOUPDATE = 8,
    NOSEARCH = 16,
    NOTRACK = 32,
    NOLINKINFO = 64,
    INVOKE_MSI = 128,
    NO_UI_WITH_MSG_PUMP = 257,
    OFFER_DELETE_WITHOUT_FILE = 512,
    KNOWNFOLDER = 1024,
    MACHINE_IN_LOCAL_TARGET = 2048,
    UPDATE_MACHINE_AND_SID = 4096,
    NO_OBJECT_ID = 8192,
};
pub const SLR_NONE = SLR_FLAGS.NONE;
pub const SLR_NO_UI = SLR_FLAGS.NO_UI;
pub const SLR_ANY_MATCH = SLR_FLAGS.ANY_MATCH;
pub const SLR_UPDATE = SLR_FLAGS.UPDATE;
pub const SLR_NOUPDATE = SLR_FLAGS.NOUPDATE;
pub const SLR_NOSEARCH = SLR_FLAGS.NOSEARCH;
pub const SLR_NOTRACK = SLR_FLAGS.NOTRACK;
pub const SLR_NOLINKINFO = SLR_FLAGS.NOLINKINFO;
pub const SLR_INVOKE_MSI = SLR_FLAGS.INVOKE_MSI;
pub const SLR_NO_UI_WITH_MSG_PUMP = SLR_FLAGS.NO_UI_WITH_MSG_PUMP;
pub const SLR_OFFER_DELETE_WITHOUT_FILE = SLR_FLAGS.OFFER_DELETE_WITHOUT_FILE;
pub const SLR_KNOWNFOLDER = SLR_FLAGS.KNOWNFOLDER;
pub const SLR_MACHINE_IN_LOCAL_TARGET = SLR_FLAGS.MACHINE_IN_LOCAL_TARGET;
pub const SLR_UPDATE_MACHINE_AND_SID = SLR_FLAGS.UPDATE_MACHINE_AND_SID;
pub const SLR_NO_OBJECT_ID = SLR_FLAGS.NO_OBJECT_ID;

pub const SLGP_FLAGS = enum(i32) {
    SHORTPATH = 1,
    UNCPRIORITY = 2,
    RAWPATH = 4,
    RELATIVEPRIORITY = 8,
};
pub const SLGP_SHORTPATH = SLGP_FLAGS.SHORTPATH;
pub const SLGP_UNCPRIORITY = SLGP_FLAGS.UNCPRIORITY;
pub const SLGP_RAWPATH = SLGP_FLAGS.RAWPATH;
pub const SLGP_RELATIVEPRIORITY = SLGP_FLAGS.RELATIVEPRIORITY;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IShellLinkA_Value = Guid.initString("000214ee-0000-0000-c000-000000000046");
pub const IID_IShellLinkA = &IID_IShellLinkA_Value;
pub const IShellLinkA = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPath: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellLinkA,
                pszFile: [*:0]u8,
                cch: i32,
                pfd: ?*WIN32_FIND_DATAA,
                fFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellLinkA,
                pszFile: [*:0]u8,
                cch: i32,
                pfd: ?*WIN32_FIND_DATAA,
                fFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIDList: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellLinkA,
                ppidl: ?*?*ITEMIDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellLinkA,
                ppidl: ?*?*ITEMIDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetIDList: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellLinkA,
                pidl: ?*ITEMIDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellLinkA,
                pidl: ?*ITEMIDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellLinkA,
                pszName: [*:0]u8,
                cch: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellLinkA,
                pszName: [*:0]u8,
                cch: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellLinkA,
                pszName: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellLinkA,
                pszName: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetWorkingDirectory: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellLinkA,
                pszDir: [*:0]u8,
                cch: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellLinkA,
                pszDir: [*:0]u8,
                cch: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetWorkingDirectory: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellLinkA,
                pszDir: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellLinkA,
                pszDir: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetArguments: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellLinkA,
                pszArgs: [*:0]u8,
                cch: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellLinkA,
                pszArgs: [*:0]u8,
                cch: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetArguments: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellLinkA,
                pszArgs: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellLinkA,
                pszArgs: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetHotkey: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellLinkA,
                pwHotkey: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellLinkA,
                pwHotkey: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetHotkey: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellLinkA,
                wHotkey: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellLinkA,
                wHotkey: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetShowCmd: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellLinkA,
                piShowCmd: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellLinkA,
                piShowCmd: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetShowCmd: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellLinkA,
                iShowCmd: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellLinkA,
                iShowCmd: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIconLocation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellLinkA,
                pszIconPath: [*:0]u8,
                cch: i32,
                piIcon: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellLinkA,
                pszIconPath: [*:0]u8,
                cch: i32,
                piIcon: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetIconLocation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellLinkA,
                pszIconPath: ?[*:0]const u8,
                iIcon: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellLinkA,
                pszIconPath: ?[*:0]const u8,
                iIcon: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetRelativePath: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellLinkA,
                pszPathRel: ?[*:0]const u8,
                dwReserved: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellLinkA,
                pszPathRel: ?[*:0]const u8,
                dwReserved: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Resolve: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellLinkA,
                hwnd: ?HWND,
                fFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellLinkA,
                hwnd: ?HWND,
                fFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPath: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellLinkA,
                pszFile: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellLinkA,
                pszFile: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellLinkA_GetPath(self: *const T, pszFile: [*:0]u8, cch: i32, pfd: ?*WIN32_FIND_DATAA, fFlags: u32) HRESULT {
                return @as(*const IShellLinkA.VTable, @ptrCast(self.vtable)).GetPath(@as(*const IShellLinkA, @ptrCast(self)), pszFile, cch, pfd, fFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellLinkA_GetIDList(self: *const T, ppidl: ?*?*ITEMIDLIST) HRESULT {
                return @as(*const IShellLinkA.VTable, @ptrCast(self.vtable)).GetIDList(@as(*const IShellLinkA, @ptrCast(self)), ppidl);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellLinkA_SetIDList(self: *const T, pidl: ?*ITEMIDLIST) HRESULT {
                return @as(*const IShellLinkA.VTable, @ptrCast(self.vtable)).SetIDList(@as(*const IShellLinkA, @ptrCast(self)), pidl);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellLinkA_GetDescription(self: *const T, pszName: [*:0]u8, cch: i32) HRESULT {
                return @as(*const IShellLinkA.VTable, @ptrCast(self.vtable)).GetDescription(@as(*const IShellLinkA, @ptrCast(self)), pszName, cch);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellLinkA_SetDescription(self: *const T, pszName: ?[*:0]const u8) HRESULT {
                return @as(*const IShellLinkA.VTable, @ptrCast(self.vtable)).SetDescription(@as(*const IShellLinkA, @ptrCast(self)), pszName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellLinkA_GetWorkingDirectory(self: *const T, pszDir: [*:0]u8, cch: i32) HRESULT {
                return @as(*const IShellLinkA.VTable, @ptrCast(self.vtable)).GetWorkingDirectory(@as(*const IShellLinkA, @ptrCast(self)), pszDir, cch);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellLinkA_SetWorkingDirectory(self: *const T, pszDir: ?[*:0]const u8) HRESULT {
                return @as(*const IShellLinkA.VTable, @ptrCast(self.vtable)).SetWorkingDirectory(@as(*const IShellLinkA, @ptrCast(self)), pszDir);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellLinkA_GetArguments(self: *const T, pszArgs: [*:0]u8, cch: i32) HRESULT {
                return @as(*const IShellLinkA.VTable, @ptrCast(self.vtable)).GetArguments(@as(*const IShellLinkA, @ptrCast(self)), pszArgs, cch);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellLinkA_SetArguments(self: *const T, pszArgs: ?[*:0]const u8) HRESULT {
                return @as(*const IShellLinkA.VTable, @ptrCast(self.vtable)).SetArguments(@as(*const IShellLinkA, @ptrCast(self)), pszArgs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellLinkA_GetHotkey(self: *const T, pwHotkey: ?*u16) HRESULT {
                return @as(*const IShellLinkA.VTable, @ptrCast(self.vtable)).GetHotkey(@as(*const IShellLinkA, @ptrCast(self)), pwHotkey);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellLinkA_SetHotkey(self: *const T, wHotkey: u16) HRESULT {
                return @as(*const IShellLinkA.VTable, @ptrCast(self.vtable)).SetHotkey(@as(*const IShellLinkA, @ptrCast(self)), wHotkey);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellLinkA_GetShowCmd(self: *const T, piShowCmd: ?*i32) HRESULT {
                return @as(*const IShellLinkA.VTable, @ptrCast(self.vtable)).GetShowCmd(@as(*const IShellLinkA, @ptrCast(self)), piShowCmd);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellLinkA_SetShowCmd(self: *const T, iShowCmd: i32) HRESULT {
                return @as(*const IShellLinkA.VTable, @ptrCast(self.vtable)).SetShowCmd(@as(*const IShellLinkA, @ptrCast(self)), iShowCmd);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellLinkA_GetIconLocation(self: *const T, pszIconPath: [*:0]u8, cch: i32, piIcon: ?*i32) HRESULT {
                return @as(*const IShellLinkA.VTable, @ptrCast(self.vtable)).GetIconLocation(@as(*const IShellLinkA, @ptrCast(self)), pszIconPath, cch, piIcon);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellLinkA_SetIconLocation(self: *const T, pszIconPath: ?[*:0]const u8, iIcon: i32) HRESULT {
                return @as(*const IShellLinkA.VTable, @ptrCast(self.vtable)).SetIconLocation(@as(*const IShellLinkA, @ptrCast(self)), pszIconPath, iIcon);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellLinkA_SetRelativePath(self: *const T, pszPathRel: ?[*:0]const u8, dwReserved: u32) HRESULT {
                return @as(*const IShellLinkA.VTable, @ptrCast(self.vtable)).SetRelativePath(@as(*const IShellLinkA, @ptrCast(self)), pszPathRel, dwReserved);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellLinkA_Resolve(self: *const T, hwnd: ?HWND, fFlags: u32) HRESULT {
                return @as(*const IShellLinkA.VTable, @ptrCast(self.vtable)).Resolve(@as(*const IShellLinkA, @ptrCast(self)), hwnd, fFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellLinkA_SetPath(self: *const T, pszFile: ?[*:0]const u8) HRESULT {
                return @as(*const IShellLinkA.VTable, @ptrCast(self.vtable)).SetPath(@as(*const IShellLinkA, @ptrCast(self)), pszFile);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IShellLinkW_Value = Guid.initString("000214f9-0000-0000-c000-000000000046");
pub const IID_IShellLinkW = &IID_IShellLinkW_Value;
pub const IShellLinkW = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPath: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellLinkW,
                pszFile: [*:0]u16,
                cch: i32,
                pfd: ?*WIN32_FIND_DATAW,
                fFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellLinkW,
                pszFile: [*:0]u16,
                cch: i32,
                pfd: ?*WIN32_FIND_DATAW,
                fFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIDList: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellLinkW,
                ppidl: ?*?*ITEMIDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellLinkW,
                ppidl: ?*?*ITEMIDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetIDList: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellLinkW,
                pidl: ?*ITEMIDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellLinkW,
                pidl: ?*ITEMIDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellLinkW,
                pszName: [*:0]u16,
                cch: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellLinkW,
                pszName: [*:0]u16,
                cch: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellLinkW,
                pszName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellLinkW,
                pszName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetWorkingDirectory: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellLinkW,
                pszDir: [*:0]u16,
                cch: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellLinkW,
                pszDir: [*:0]u16,
                cch: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetWorkingDirectory: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellLinkW,
                pszDir: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellLinkW,
                pszDir: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetArguments: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellLinkW,
                pszArgs: [*:0]u16,
                cch: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellLinkW,
                pszArgs: [*:0]u16,
                cch: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetArguments: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellLinkW,
                pszArgs: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellLinkW,
                pszArgs: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetHotkey: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellLinkW,
                pwHotkey: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellLinkW,
                pwHotkey: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetHotkey: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellLinkW,
                wHotkey: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellLinkW,
                wHotkey: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetShowCmd: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellLinkW,
                piShowCmd: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellLinkW,
                piShowCmd: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetShowCmd: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellLinkW,
                iShowCmd: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellLinkW,
                iShowCmd: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIconLocation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellLinkW,
                pszIconPath: [*:0]u16,
                cch: i32,
                piIcon: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellLinkW,
                pszIconPath: [*:0]u16,
                cch: i32,
                piIcon: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetIconLocation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellLinkW,
                pszIconPath: ?[*:0]const u16,
                iIcon: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellLinkW,
                pszIconPath: ?[*:0]const u16,
                iIcon: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetRelativePath: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellLinkW,
                pszPathRel: ?[*:0]const u16,
                dwReserved: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellLinkW,
                pszPathRel: ?[*:0]const u16,
                dwReserved: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Resolve: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellLinkW,
                hwnd: ?HWND,
                fFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellLinkW,
                hwnd: ?HWND,
                fFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPath: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellLinkW,
                pszFile: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellLinkW,
                pszFile: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellLinkW_GetPath(self: *const T, pszFile: [*:0]u16, cch: i32, pfd: ?*WIN32_FIND_DATAW, fFlags: u32) HRESULT {
                return @as(*const IShellLinkW.VTable, @ptrCast(self.vtable)).GetPath(@as(*const IShellLinkW, @ptrCast(self)), pszFile, cch, pfd, fFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellLinkW_GetIDList(self: *const T, ppidl: ?*?*ITEMIDLIST) HRESULT {
                return @as(*const IShellLinkW.VTable, @ptrCast(self.vtable)).GetIDList(@as(*const IShellLinkW, @ptrCast(self)), ppidl);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellLinkW_SetIDList(self: *const T, pidl: ?*ITEMIDLIST) HRESULT {
                return @as(*const IShellLinkW.VTable, @ptrCast(self.vtable)).SetIDList(@as(*const IShellLinkW, @ptrCast(self)), pidl);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellLinkW_GetDescription(self: *const T, pszName: [*:0]u16, cch: i32) HRESULT {
                return @as(*const IShellLinkW.VTable, @ptrCast(self.vtable)).GetDescription(@as(*const IShellLinkW, @ptrCast(self)), pszName, cch);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellLinkW_SetDescription(self: *const T, pszName: ?[*:0]const u16) HRESULT {
                return @as(*const IShellLinkW.VTable, @ptrCast(self.vtable)).SetDescription(@as(*const IShellLinkW, @ptrCast(self)), pszName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellLinkW_GetWorkingDirectory(self: *const T, pszDir: [*:0]u16, cch: i32) HRESULT {
                return @as(*const IShellLinkW.VTable, @ptrCast(self.vtable)).GetWorkingDirectory(@as(*const IShellLinkW, @ptrCast(self)), pszDir, cch);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellLinkW_SetWorkingDirectory(self: *const T, pszDir: ?[*:0]const u16) HRESULT {
                return @as(*const IShellLinkW.VTable, @ptrCast(self.vtable)).SetWorkingDirectory(@as(*const IShellLinkW, @ptrCast(self)), pszDir);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellLinkW_GetArguments(self: *const T, pszArgs: [*:0]u16, cch: i32) HRESULT {
                return @as(*const IShellLinkW.VTable, @ptrCast(self.vtable)).GetArguments(@as(*const IShellLinkW, @ptrCast(self)), pszArgs, cch);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellLinkW_SetArguments(self: *const T, pszArgs: ?[*:0]const u16) HRESULT {
                return @as(*const IShellLinkW.VTable, @ptrCast(self.vtable)).SetArguments(@as(*const IShellLinkW, @ptrCast(self)), pszArgs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellLinkW_GetHotkey(self: *const T, pwHotkey: ?*u16) HRESULT {
                return @as(*const IShellLinkW.VTable, @ptrCast(self.vtable)).GetHotkey(@as(*const IShellLinkW, @ptrCast(self)), pwHotkey);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellLinkW_SetHotkey(self: *const T, wHotkey: u16) HRESULT {
                return @as(*const IShellLinkW.VTable, @ptrCast(self.vtable)).SetHotkey(@as(*const IShellLinkW, @ptrCast(self)), wHotkey);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellLinkW_GetShowCmd(self: *const T, piShowCmd: ?*i32) HRESULT {
                return @as(*const IShellLinkW.VTable, @ptrCast(self.vtable)).GetShowCmd(@as(*const IShellLinkW, @ptrCast(self)), piShowCmd);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellLinkW_SetShowCmd(self: *const T, iShowCmd: i32) HRESULT {
                return @as(*const IShellLinkW.VTable, @ptrCast(self.vtable)).SetShowCmd(@as(*const IShellLinkW, @ptrCast(self)), iShowCmd);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellLinkW_GetIconLocation(self: *const T, pszIconPath: [*:0]u16, cch: i32, piIcon: ?*i32) HRESULT {
                return @as(*const IShellLinkW.VTable, @ptrCast(self.vtable)).GetIconLocation(@as(*const IShellLinkW, @ptrCast(self)), pszIconPath, cch, piIcon);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellLinkW_SetIconLocation(self: *const T, pszIconPath: ?[*:0]const u16, iIcon: i32) HRESULT {
                return @as(*const IShellLinkW.VTable, @ptrCast(self.vtable)).SetIconLocation(@as(*const IShellLinkW, @ptrCast(self)), pszIconPath, iIcon);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellLinkW_SetRelativePath(self: *const T, pszPathRel: ?[*:0]const u16, dwReserved: u32) HRESULT {
                return @as(*const IShellLinkW.VTable, @ptrCast(self.vtable)).SetRelativePath(@as(*const IShellLinkW, @ptrCast(self)), pszPathRel, dwReserved);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellLinkW_Resolve(self: *const T, hwnd: ?HWND, fFlags: u32) HRESULT {
                return @as(*const IShellLinkW.VTable, @ptrCast(self.vtable)).Resolve(@as(*const IShellLinkW, @ptrCast(self)), hwnd, fFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellLinkW_SetPath(self: *const T, pszFile: ?[*:0]const u16) HRESULT {
                return @as(*const IShellLinkW.VTable, @ptrCast(self.vtable)).SetPath(@as(*const IShellLinkW, @ptrCast(self)), pszFile);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IShellLinkDataList_Value = Guid.initString("45e2b4ae-b1c3-11d0-b92f-00a0c90312e1");
pub const IID_IShellLinkDataList = &IID_IShellLinkDataList_Value;
pub const IShellLinkDataList = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddDataBlock: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellLinkDataList,
                pDataBlock: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellLinkDataList,
                pDataBlock: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CopyDataBlock: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellLinkDataList,
                dwSig: u32,
                ppDataBlock: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellLinkDataList,
                dwSig: u32,
                ppDataBlock: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveDataBlock: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellLinkDataList,
                dwSig: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellLinkDataList,
                dwSig: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellLinkDataList,
                pdwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellLinkDataList,
                pdwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellLinkDataList,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellLinkDataList,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellLinkDataList_AddDataBlock(self: *const T, pDataBlock: ?*anyopaque) HRESULT {
                return @as(*const IShellLinkDataList.VTable, @ptrCast(self.vtable)).AddDataBlock(@as(*const IShellLinkDataList, @ptrCast(self)), pDataBlock);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellLinkDataList_CopyDataBlock(self: *const T, dwSig: u32, ppDataBlock: ?*?*anyopaque) HRESULT {
                return @as(*const IShellLinkDataList.VTable, @ptrCast(self.vtable)).CopyDataBlock(@as(*const IShellLinkDataList, @ptrCast(self)), dwSig, ppDataBlock);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellLinkDataList_RemoveDataBlock(self: *const T, dwSig: u32) HRESULT {
                return @as(*const IShellLinkDataList.VTable, @ptrCast(self.vtable)).RemoveDataBlock(@as(*const IShellLinkDataList, @ptrCast(self)), dwSig);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellLinkDataList_GetFlags(self: *const T, pdwFlags: ?*u32) HRESULT {
                return @as(*const IShellLinkDataList.VTable, @ptrCast(self.vtable)).GetFlags(@as(*const IShellLinkDataList, @ptrCast(self)), pdwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellLinkDataList_SetFlags(self: *const T, dwFlags: u32) HRESULT {
                return @as(*const IShellLinkDataList.VTable, @ptrCast(self.vtable)).SetFlags(@as(*const IShellLinkDataList, @ptrCast(self)), dwFlags);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IResolveShellLink_Value = Guid.initString("5cd52983-9449-11d2-963a-00c04f79adf0");
pub const IID_IResolveShellLink = &IID_IResolveShellLink_Value;
pub const IResolveShellLink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ResolveShellLink: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IResolveShellLink,
                punkLink: ?*IUnknown,
                hwnd: ?HWND,
                fFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IResolveShellLink,
                punkLink: ?*IUnknown,
                hwnd: ?HWND,
                fFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IResolveShellLink_ResolveShellLink(self: *const T, punkLink: ?*IUnknown, hwnd: ?HWND, fFlags: u32) HRESULT {
                return @as(*const IResolveShellLink.VTable, @ptrCast(self.vtable)).ResolveShellLink(@as(*const IResolveShellLink, @ptrCast(self)), punkLink, hwnd, fFlags);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const _SPINITF = enum(i32) {
    NORMAL = 0,
    MODAL = 1,
    NOMINIMIZE = 8,
};
pub const SPINITF_NORMAL = _SPINITF.NORMAL;
pub const SPINITF_MODAL = _SPINITF.MODAL;
pub const SPINITF_NOMINIMIZE = _SPINITF.NOMINIMIZE;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IActionProgressDialog_Value = Guid.initString("49ff1172-eadc-446d-9285-156453a6431c");
pub const IID_IActionProgressDialog = &IID_IActionProgressDialog_Value;
pub const IActionProgressDialog = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActionProgressDialog,
                flags: u32,
                pszTitle: ?[*:0]const u16,
                pszCancel: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActionProgressDialog,
                flags: u32,
                pszTitle: ?[*:0]const u16,
                pszCancel: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Stop: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActionProgressDialog,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActionProgressDialog,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActionProgressDialog_Initialize(self: *const T, flags: u32, pszTitle: ?[*:0]const u16, pszCancel: ?[*:0]const u16) HRESULT {
                return @as(*const IActionProgressDialog.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IActionProgressDialog, @ptrCast(self)), flags, pszTitle, pszCancel);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActionProgressDialog_Stop(self: *const T) HRESULT {
                return @as(*const IActionProgressDialog.VTable, @ptrCast(self.vtable)).Stop(@as(*const IActionProgressDialog, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const _SPBEGINF = enum(i32) {
    NORMAL = 0,
    AUTOTIME = 2,
    NOPROGRESSBAR = 16,
    MARQUEEPROGRESS = 32,
    NOCANCELBUTTON = 64,
};
pub const SPBEGINF_NORMAL = _SPBEGINF.NORMAL;
pub const SPBEGINF_AUTOTIME = _SPBEGINF.AUTOTIME;
pub const SPBEGINF_NOPROGRESSBAR = _SPBEGINF.NOPROGRESSBAR;
pub const SPBEGINF_MARQUEEPROGRESS = _SPBEGINF.MARQUEEPROGRESS;
pub const SPBEGINF_NOCANCELBUTTON = _SPBEGINF.NOCANCELBUTTON;

pub const SPACTION = enum(i32) {
    NONE = 0,
    MOVING = 1,
    COPYING = 2,
    RECYCLING = 3,
    APPLYINGATTRIBS = 4,
    DOWNLOADING = 5,
    SEARCHING_INTERNET = 6,
    CALCULATING = 7,
    UPLOADING = 8,
    SEARCHING_FILES = 9,
    DELETING = 10,
    RENAMING = 11,
    FORMATTING = 12,
    COPY_MOVING = 13,
};
pub const SPACTION_NONE = SPACTION.NONE;
pub const SPACTION_MOVING = SPACTION.MOVING;
pub const SPACTION_COPYING = SPACTION.COPYING;
pub const SPACTION_RECYCLING = SPACTION.RECYCLING;
pub const SPACTION_APPLYINGATTRIBS = SPACTION.APPLYINGATTRIBS;
pub const SPACTION_DOWNLOADING = SPACTION.DOWNLOADING;
pub const SPACTION_SEARCHING_INTERNET = SPACTION.SEARCHING_INTERNET;
pub const SPACTION_CALCULATING = SPACTION.CALCULATING;
pub const SPACTION_UPLOADING = SPACTION.UPLOADING;
pub const SPACTION_SEARCHING_FILES = SPACTION.SEARCHING_FILES;
pub const SPACTION_DELETING = SPACTION.DELETING;
pub const SPACTION_RENAMING = SPACTION.RENAMING;
pub const SPACTION_FORMATTING = SPACTION.FORMATTING;
pub const SPACTION_COPY_MOVING = SPACTION.COPY_MOVING;

pub const SPTEXT = enum(i32) {
    SCRIPTION = 1,
    TAIL = 2,
};
pub const SPTEXT_ACTIONDESCRIPTION = SPTEXT.SCRIPTION;
pub const SPTEXT_ACTIONDETAIL = SPTEXT.TAIL;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IActionProgress_Value = Guid.initString("49ff1173-eadc-446d-9285-156453a6431c");
pub const IID_IActionProgress = &IID_IActionProgress_Value;
pub const IActionProgress = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Begin: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActionProgress,
                action: SPACTION,
                flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActionProgress,
                action: SPACTION,
                flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UpdateProgress: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActionProgress,
                ulCompleted: u64,
                ulTotal: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActionProgress,
                ulCompleted: u64,
                ulTotal: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UpdateText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActionProgress,
                sptext: SPTEXT,
                pszText: ?[*:0]const u16,
                fMayCompact: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActionProgress,
                sptext: SPTEXT,
                pszText: ?[*:0]const u16,
                fMayCompact: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryCancel: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActionProgress,
                pfCancelled: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActionProgress,
                pfCancelled: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ResetCancel: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActionProgress,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActionProgress,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        End: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActionProgress,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActionProgress,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActionProgress_Begin(self: *const T, action: SPACTION, flags: u32) HRESULT {
                return @as(*const IActionProgress.VTable, @ptrCast(self.vtable)).Begin(@as(*const IActionProgress, @ptrCast(self)), action, flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActionProgress_UpdateProgress(self: *const T, ulCompleted: u64, ulTotal: u64) HRESULT {
                return @as(*const IActionProgress.VTable, @ptrCast(self.vtable)).UpdateProgress(@as(*const IActionProgress, @ptrCast(self)), ulCompleted, ulTotal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActionProgress_UpdateText(self: *const T, sptext: SPTEXT, pszText: ?[*:0]const u16, fMayCompact: BOOL) HRESULT {
                return @as(*const IActionProgress.VTable, @ptrCast(self.vtable)).UpdateText(@as(*const IActionProgress, @ptrCast(self)), sptext, pszText, fMayCompact);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActionProgress_QueryCancel(self: *const T, pfCancelled: ?*BOOL) HRESULT {
                return @as(*const IActionProgress.VTable, @ptrCast(self.vtable)).QueryCancel(@as(*const IActionProgress, @ptrCast(self)), pfCancelled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActionProgress_ResetCancel(self: *const T) HRESULT {
                return @as(*const IActionProgress.VTable, @ptrCast(self.vtable)).ResetCancel(@as(*const IActionProgress, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActionProgress_End(self: *const T) HRESULT {
                return @as(*const IActionProgress.VTable, @ptrCast(self.vtable)).End(@as(*const IActionProgress, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IShellExtInit_Value = Guid.initString("000214e8-0000-0000-c000-000000000046");
pub const IID_IShellExtInit = &IID_IShellExtInit_Value;
pub const IShellExtInit = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellExtInit,
                pidlFolder: ?*ITEMIDLIST,
                pdtobj: ?*IDataObject,
                hkeyProgID: ?HKEY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellExtInit,
                pidlFolder: ?*ITEMIDLIST,
                pdtobj: ?*IDataObject,
                hkeyProgID: ?HKEY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellExtInit_Initialize(self: *const T, pidlFolder: ?*ITEMIDLIST, pdtobj: ?*IDataObject, hkeyProgID: ?HKEY) HRESULT {
                return @as(*const IShellExtInit.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IShellExtInit, @ptrCast(self)), pidlFolder, pdtobj, hkeyProgID);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const _EXPPS = enum(i32) {
    S = 1,
};
pub const EXPPS_FILETYPES = _EXPPS.S;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IShellPropSheetExt_Value = Guid.initString("000214e9-0000-0000-c000-000000000046");
pub const IID_IShellPropSheetExt = &IID_IShellPropSheetExt_Value;
pub const IShellPropSheetExt = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddPages: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellPropSheetExt,
                pfnAddPage: ?LPFNSVADDPROPSHEETPAGE,
                lParam: LPARAM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellPropSheetExt,
                pfnAddPage: ?LPFNSVADDPROPSHEETPAGE,
                lParam: LPARAM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReplacePage: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellPropSheetExt,
                uPageID: u32,
                pfnReplaceWith: ?LPFNSVADDPROPSHEETPAGE,
                lParam: LPARAM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellPropSheetExt,
                uPageID: u32,
                pfnReplaceWith: ?LPFNSVADDPROPSHEETPAGE,
                lParam: LPARAM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellPropSheetExt_AddPages(self: *const T, pfnAddPage: ?LPFNSVADDPROPSHEETPAGE, lParam: LPARAM) HRESULT {
                return @as(*const IShellPropSheetExt.VTable, @ptrCast(self.vtable)).AddPages(@as(*const IShellPropSheetExt, @ptrCast(self)), pfnAddPage, lParam);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellPropSheetExt_ReplacePage(self: *const T, uPageID: u32, pfnReplaceWith: ?LPFNSVADDPROPSHEETPAGE, lParam: LPARAM) HRESULT {
                return @as(*const IShellPropSheetExt.VTable, @ptrCast(self.vtable)).ReplacePage(@as(*const IShellPropSheetExt, @ptrCast(self)), uPageID, pfnReplaceWith, lParam);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IRemoteComputer_Value = Guid.initString("000214fe-0000-0000-c000-000000000046");
pub const IID_IRemoteComputer = &IID_IRemoteComputer_Value;
pub const IRemoteComputer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRemoteComputer,
                pszMachine: ?[*:0]const u16,
                bEnumerating: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRemoteComputer,
                pszMachine: ?[*:0]const u16,
                bEnumerating: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRemoteComputer_Initialize(self: *const T, pszMachine: ?[*:0]const u16, bEnumerating: BOOL) HRESULT {
                return @as(*const IRemoteComputer.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IRemoteComputer, @ptrCast(self)), pszMachine, bEnumerating);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IQueryContinue_Value = Guid.initString("7307055c-b24a-486b-9f25-163e597a28a9");
pub const IID_IQueryContinue = &IID_IQueryContinue_Value;
pub const IQueryContinue = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryContinue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IQueryContinue,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IQueryContinue,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IQueryContinue_QueryContinue(self: *const T) HRESULT {
                return @as(*const IQueryContinue.VTable, @ptrCast(self.vtable)).QueryContinue(@as(*const IQueryContinue, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IObjectWithCancelEvent_Value = Guid.initString("f279b885-0ae9-4b85-ac06-ddecf9408941");
pub const IID_IObjectWithCancelEvent = &IID_IObjectWithCancelEvent_Value;
pub const IObjectWithCancelEvent = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCancelEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IObjectWithCancelEvent,
                phEvent: ?*?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IObjectWithCancelEvent,
                phEvent: ?*?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IObjectWithCancelEvent_GetCancelEvent(self: *const T, phEvent: ?*?HANDLE) HRESULT {
                return @as(*const IObjectWithCancelEvent.VTable, @ptrCast(self.vtable)).GetCancelEvent(@as(*const IObjectWithCancelEvent, @ptrCast(self)), phEvent);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IUserNotification_Value = Guid.initString("ba9711ba-5893-4787-a7e1-41277151550b");
pub const IID_IUserNotification = &IID_IUserNotification_Value;
pub const IUserNotification = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetBalloonInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUserNotification,
                pszTitle: ?[*:0]const u16,
                pszText: ?[*:0]const u16,
                dwInfoFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUserNotification,
                pszTitle: ?[*:0]const u16,
                pszText: ?[*:0]const u16,
                dwInfoFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetBalloonRetry: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUserNotification,
                dwShowTime: u32,
                dwInterval: u32,
                cRetryCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUserNotification,
                dwShowTime: u32,
                dwInterval: u32,
                cRetryCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetIconInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUserNotification,
                hIcon: ?HICON,
                pszToolTip: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUserNotification,
                hIcon: ?HICON,
                pszToolTip: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Show: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUserNotification,
                pqc: ?*IQueryContinue,
                dwContinuePollInterval: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUserNotification,
                pqc: ?*IQueryContinue,
                dwContinuePollInterval: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PlaySound: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUserNotification,
                pszSoundName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUserNotification,
                pszSoundName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUserNotification_SetBalloonInfo(self: *const T, pszTitle: ?[*:0]const u16, pszText: ?[*:0]const u16, dwInfoFlags: u32) HRESULT {
                return @as(*const IUserNotification.VTable, @ptrCast(self.vtable)).SetBalloonInfo(@as(*const IUserNotification, @ptrCast(self)), pszTitle, pszText, dwInfoFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUserNotification_SetBalloonRetry(self: *const T, dwShowTime: u32, dwInterval: u32, cRetryCount: u32) HRESULT {
                return @as(*const IUserNotification.VTable, @ptrCast(self.vtable)).SetBalloonRetry(@as(*const IUserNotification, @ptrCast(self)), dwShowTime, dwInterval, cRetryCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUserNotification_SetIconInfo(self: *const T, hIcon: ?HICON, pszToolTip: ?[*:0]const u16) HRESULT {
                return @as(*const IUserNotification.VTable, @ptrCast(self.vtable)).SetIconInfo(@as(*const IUserNotification, @ptrCast(self)), hIcon, pszToolTip);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUserNotification_Show(self: *const T, pqc: ?*IQueryContinue, dwContinuePollInterval: u32) HRESULT {
                return @as(*const IUserNotification.VTable, @ptrCast(self.vtable)).Show(@as(*const IUserNotification, @ptrCast(self)), pqc, dwContinuePollInterval);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUserNotification_PlaySound(self: *const T, pszSoundName: ?[*:0]const u16) HRESULT {
                return @as(*const IUserNotification.VTable, @ptrCast(self.vtable)).PlaySound(@as(*const IUserNotification, @ptrCast(self)), pszSoundName);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IItemNameLimits_Value = Guid.initString("1df0d7f1-b267-4d28-8b10-12e23202a5c4");
pub const IID_IItemNameLimits = &IID_IItemNameLimits_Value;
pub const IItemNameLimits = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetValidCharacters: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IItemNameLimits,
                ppwszValidChars: ?*?PWSTR,
                ppwszInvalidChars: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IItemNameLimits,
                ppwszValidChars: ?*?PWSTR,
                ppwszInvalidChars: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMaxLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IItemNameLimits,
                pszName: ?[*:0]const u16,
                piMaxNameLen: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IItemNameLimits,
                pszName: ?[*:0]const u16,
                piMaxNameLen: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IItemNameLimits_GetValidCharacters(self: *const T, ppwszValidChars: ?*?PWSTR, ppwszInvalidChars: ?*?PWSTR) HRESULT {
                return @as(*const IItemNameLimits.VTable, @ptrCast(self.vtable)).GetValidCharacters(@as(*const IItemNameLimits, @ptrCast(self)), ppwszValidChars, ppwszInvalidChars);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IItemNameLimits_GetMaxLength(self: *const T, pszName: ?[*:0]const u16, piMaxNameLen: ?*i32) HRESULT {
                return @as(*const IItemNameLimits.VTable, @ptrCast(self.vtable)).GetMaxLength(@as(*const IItemNameLimits, @ptrCast(self)), pszName, piMaxNameLen);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ISearchFolderItemFactory_Value = Guid.initString("a0ffbc28-5482-4366-be27-3e81e78e06c2");
pub const IID_ISearchFolderItemFactory = &IID_ISearchFolderItemFactory_Value;
pub const ISearchFolderItemFactory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetDisplayName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISearchFolderItemFactory,
                pszDisplayName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISearchFolderItemFactory,
                pszDisplayName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFolderTypeID: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISearchFolderItemFactory,
                ftid: Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISearchFolderItemFactory,
                ftid: Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFolderLogicalViewMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISearchFolderItemFactory,
                flvm: FOLDERLOGICALVIEWMODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISearchFolderItemFactory,
                flvm: FOLDERLOGICALVIEWMODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetIconSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISearchFolderItemFactory,
                iIconSize: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISearchFolderItemFactory,
                iIconSize: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetVisibleColumns: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISearchFolderItemFactory,
                cVisibleColumns: u32,
                rgKey: [*]const PROPERTYKEY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISearchFolderItemFactory,
                cVisibleColumns: u32,
                rgKey: [*]const PROPERTYKEY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSortColumns: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISearchFolderItemFactory,
                cSortColumns: u32,
                rgSortColumns: [*]SORTCOLUMN,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISearchFolderItemFactory,
                cSortColumns: u32,
                rgSortColumns: [*]SORTCOLUMN,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetGroupColumn: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISearchFolderItemFactory,
                keyGroup: ?*const PROPERTYKEY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISearchFolderItemFactory,
                keyGroup: ?*const PROPERTYKEY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetStacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISearchFolderItemFactory,
                cStackKeys: u32,
                rgStackKeys: [*]PROPERTYKEY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISearchFolderItemFactory,
                cStackKeys: u32,
                rgStackKeys: [*]PROPERTYKEY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetScope: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISearchFolderItemFactory,
                psiaScope: ?*IShellItemArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISearchFolderItemFactory,
                psiaScope: ?*IShellItemArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCondition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISearchFolderItemFactory,
                pCondition: ?*ICondition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISearchFolderItemFactory,
                pCondition: ?*ICondition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetShellItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISearchFolderItemFactory,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISearchFolderItemFactory,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIDList: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISearchFolderItemFactory,
                ppidl: ?*?*ITEMIDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISearchFolderItemFactory,
                ppidl: ?*?*ITEMIDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchFolderItemFactory_SetDisplayName(self: *const T, pszDisplayName: ?[*:0]const u16) HRESULT {
                return @as(*const ISearchFolderItemFactory.VTable, @ptrCast(self.vtable)).SetDisplayName(@as(*const ISearchFolderItemFactory, @ptrCast(self)), pszDisplayName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchFolderItemFactory_SetFolderTypeID(self: *const T, ftid: Guid) HRESULT {
                return @as(*const ISearchFolderItemFactory.VTable, @ptrCast(self.vtable)).SetFolderTypeID(@as(*const ISearchFolderItemFactory, @ptrCast(self)), ftid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchFolderItemFactory_SetFolderLogicalViewMode(self: *const T, flvm: FOLDERLOGICALVIEWMODE) HRESULT {
                return @as(*const ISearchFolderItemFactory.VTable, @ptrCast(self.vtable)).SetFolderLogicalViewMode(@as(*const ISearchFolderItemFactory, @ptrCast(self)), flvm);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchFolderItemFactory_SetIconSize(self: *const T, iIconSize: i32) HRESULT {
                return @as(*const ISearchFolderItemFactory.VTable, @ptrCast(self.vtable)).SetIconSize(@as(*const ISearchFolderItemFactory, @ptrCast(self)), iIconSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchFolderItemFactory_SetVisibleColumns(self: *const T, cVisibleColumns: u32, rgKey: [*]const PROPERTYKEY) HRESULT {
                return @as(*const ISearchFolderItemFactory.VTable, @ptrCast(self.vtable)).SetVisibleColumns(@as(*const ISearchFolderItemFactory, @ptrCast(self)), cVisibleColumns, rgKey);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchFolderItemFactory_SetSortColumns(self: *const T, cSortColumns: u32, rgSortColumns: [*]SORTCOLUMN) HRESULT {
                return @as(*const ISearchFolderItemFactory.VTable, @ptrCast(self.vtable)).SetSortColumns(@as(*const ISearchFolderItemFactory, @ptrCast(self)), cSortColumns, rgSortColumns);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchFolderItemFactory_SetGroupColumn(self: *const T, keyGroup: ?*const PROPERTYKEY) HRESULT {
                return @as(*const ISearchFolderItemFactory.VTable, @ptrCast(self.vtable)).SetGroupColumn(@as(*const ISearchFolderItemFactory, @ptrCast(self)), keyGroup);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchFolderItemFactory_SetStacks(self: *const T, cStackKeys: u32, rgStackKeys: [*]PROPERTYKEY) HRESULT {
                return @as(*const ISearchFolderItemFactory.VTable, @ptrCast(self.vtable)).SetStacks(@as(*const ISearchFolderItemFactory, @ptrCast(self)), cStackKeys, rgStackKeys);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchFolderItemFactory_SetScope(self: *const T, psiaScope: ?*IShellItemArray) HRESULT {
                return @as(*const ISearchFolderItemFactory.VTable, @ptrCast(self.vtable)).SetScope(@as(*const ISearchFolderItemFactory, @ptrCast(self)), psiaScope);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchFolderItemFactory_SetCondition(self: *const T, pCondition: ?*ICondition) HRESULT {
                return @as(*const ISearchFolderItemFactory.VTable, @ptrCast(self.vtable)).SetCondition(@as(*const ISearchFolderItemFactory, @ptrCast(self)), pCondition);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchFolderItemFactory_GetShellItem(self: *const T, riid: ?*const Guid, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const ISearchFolderItemFactory.VTable, @ptrCast(self.vtable)).GetShellItem(@as(*const ISearchFolderItemFactory, @ptrCast(self)), riid, ppv);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchFolderItemFactory_GetIDList(self: *const T, ppidl: ?*?*ITEMIDLIST) HRESULT {
                return @as(*const ISearchFolderItemFactory.VTable, @ptrCast(self.vtable)).GetIDList(@as(*const ISearchFolderItemFactory, @ptrCast(self)), ppidl);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IExtractImage_Value = Guid.initString("bb2e617c-0920-11d1-9a0b-00c04fc2d6c1");
pub const IID_IExtractImage = &IID_IExtractImage_Value;
pub const IExtractImage = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetLocation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IExtractImage,
                pszPathBuffer: [*:0]u16,
                cch: u32,
                pdwPriority: ?*u32,
                prgSize: ?*const SIZE,
                dwRecClrDepth: u32,
                pdwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IExtractImage,
                pszPathBuffer: [*:0]u16,
                cch: u32,
                pdwPriority: ?*u32,
                prgSize: ?*const SIZE,
                dwRecClrDepth: u32,
                pdwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Extract: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IExtractImage,
                phBmpThumbnail: ?*?HBITMAP,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IExtractImage,
                phBmpThumbnail: ?*?HBITMAP,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IExtractImage_GetLocation(self: *const T, pszPathBuffer: [*:0]u16, cch: u32, pdwPriority: ?*u32, prgSize: ?*const SIZE, dwRecClrDepth: u32, pdwFlags: ?*u32) HRESULT {
                return @as(*const IExtractImage.VTable, @ptrCast(self.vtable)).GetLocation(@as(*const IExtractImage, @ptrCast(self)), pszPathBuffer, cch, pdwPriority, prgSize, dwRecClrDepth, pdwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IExtractImage_Extract(self: *const T, phBmpThumbnail: ?*?HBITMAP) HRESULT {
                return @as(*const IExtractImage.VTable, @ptrCast(self.vtable)).Extract(@as(*const IExtractImage, @ptrCast(self)), phBmpThumbnail);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IExtractImage2_Value = Guid.initString("953bb1ee-93b4-11d1-98a3-00c04fb687da");
pub const IID_IExtractImage2 = &IID_IExtractImage2_Value;
pub const IExtractImage2 = extern struct {
    pub const VTable = extern struct {
        base: IExtractImage.VTable,
        GetDateStamp: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IExtractImage2,
                pDateStamp: ?*FILETIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IExtractImage2,
                pDateStamp: ?*FILETIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IExtractImage.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IExtractImage2_GetDateStamp(self: *const T, pDateStamp: ?*FILETIME) HRESULT {
                return @as(*const IExtractImage2.VTable, @ptrCast(self.vtable)).GetDateStamp(@as(*const IExtractImage2, @ptrCast(self)), pDateStamp);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IThumbnailHandlerFactory_Value = Guid.initString("e35b4b2e-00da-4bc1-9f13-38bc11f5d417");
pub const IID_IThumbnailHandlerFactory = &IID_IThumbnailHandlerFactory_Value;
pub const IThumbnailHandlerFactory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetThumbnailHandler: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IThumbnailHandlerFactory,
                pidlChild: ?*ITEMIDLIST,
                pbc: ?*IBindCtx,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IThumbnailHandlerFactory,
                pidlChild: ?*ITEMIDLIST,
                pbc: ?*IBindCtx,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IThumbnailHandlerFactory_GetThumbnailHandler(self: *const T, pidlChild: ?*ITEMIDLIST, pbc: ?*IBindCtx, riid: ?*const Guid, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const IThumbnailHandlerFactory.VTable, @ptrCast(self.vtable)).GetThumbnailHandler(@as(*const IThumbnailHandlerFactory, @ptrCast(self)), pidlChild, pbc, riid, ppv);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IParentAndItem_Value = Guid.initString("b3a4b685-b685-4805-99d9-5dead2873236");
pub const IID_IParentAndItem = &IID_IParentAndItem_Value;
pub const IParentAndItem = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetParentAndItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IParentAndItem,
                pidlParent: ?*ITEMIDLIST,
                psf: ?*IShellFolder,
                pidlChild: ?*ITEMIDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IParentAndItem,
                pidlParent: ?*ITEMIDLIST,
                psf: ?*IShellFolder,
                pidlChild: ?*ITEMIDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetParentAndItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IParentAndItem,
                ppidlParent: ?*?*ITEMIDLIST,
                ppsf: ?*?*IShellFolder,
                ppidlChild: ?*?*ITEMIDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IParentAndItem,
                ppidlParent: ?*?*ITEMIDLIST,
                ppsf: ?*?*IShellFolder,
                ppidlChild: ?*?*ITEMIDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IParentAndItem_SetParentAndItem(self: *const T, pidlParent: ?*ITEMIDLIST, psf: ?*IShellFolder, pidlChild: ?*ITEMIDLIST) HRESULT {
                return @as(*const IParentAndItem.VTable, @ptrCast(self.vtable)).SetParentAndItem(@as(*const IParentAndItem, @ptrCast(self)), pidlParent, psf, pidlChild);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IParentAndItem_GetParentAndItem(self: *const T, ppidlParent: ?*?*ITEMIDLIST, ppsf: ?*?*IShellFolder, ppidlChild: ?*?*ITEMIDLIST) HRESULT {
                return @as(*const IParentAndItem.VTable, @ptrCast(self.vtable)).GetParentAndItem(@as(*const IParentAndItem, @ptrCast(self)), ppidlParent, ppsf, ppidlChild);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IDockingWindow_Value = Guid.initString("012dd920-7b26-11d0-8ca9-00a0c92dbfe8");
pub const IID_IDockingWindow = &IID_IDockingWindow_Value;
pub const IDockingWindow = extern struct {
    pub const VTable = extern struct {
        base: IOleWindow.VTable,
        ShowDW: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDockingWindow,
                fShow: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDockingWindow,
                fShow: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CloseDW: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDockingWindow,
                dwReserved: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDockingWindow,
                dwReserved: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ResizeBorderDW: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDockingWindow,
                prcBorder: ?*RECT,
                punkToolbarSite: ?*IUnknown,
                fReserved: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDockingWindow,
                prcBorder: ?*RECT,
                punkToolbarSite: ?*IUnknown,
                fReserved: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IOleWindow.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDockingWindow_ShowDW(self: *const T, fShow: BOOL) HRESULT {
                return @as(*const IDockingWindow.VTable, @ptrCast(self.vtable)).ShowDW(@as(*const IDockingWindow, @ptrCast(self)), fShow);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDockingWindow_CloseDW(self: *const T, dwReserved: u32) HRESULT {
                return @as(*const IDockingWindow.VTable, @ptrCast(self.vtable)).CloseDW(@as(*const IDockingWindow, @ptrCast(self)), dwReserved);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDockingWindow_ResizeBorderDW(self: *const T, prcBorder: ?*RECT, punkToolbarSite: ?*IUnknown, fReserved: BOOL) HRESULT {
                return @as(*const IDockingWindow.VTable, @ptrCast(self.vtable)).ResizeBorderDW(@as(*const IDockingWindow, @ptrCast(self)), prcBorder, punkToolbarSite, fReserved);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DESKBANDINFO = extern struct {
    dwMask: u32,
    ptMinSize: POINTL,
    ptMaxSize: POINTL,
    ptIntegral: POINTL,
    ptActual: POINTL,
    wszTitle: [256]u16,
    dwModeFlags: u32,
    crBkgnd: u32,
};

pub const DESKBANDCID = enum(i32) {
    BANDINFOCHANGED = 0,
    SHOWONLY = 1,
    MAXIMIZEBAND = 2,
    PUSHCHEVRON = 3,
    DELAYINIT = 4,
    FINISHINIT = 5,
    SETWINDOWTHEME = 6,
    PERMITAUTOHIDE = 7,
};
pub const DBID_BANDINFOCHANGED = DESKBANDCID.BANDINFOCHANGED;
pub const DBID_SHOWONLY = DESKBANDCID.SHOWONLY;
pub const DBID_MAXIMIZEBAND = DESKBANDCID.MAXIMIZEBAND;
pub const DBID_PUSHCHEVRON = DESKBANDCID.PUSHCHEVRON;
pub const DBID_DELAYINIT = DESKBANDCID.DELAYINIT;
pub const DBID_FINISHINIT = DESKBANDCID.FINISHINIT;
pub const DBID_SETWINDOWTHEME = DESKBANDCID.SETWINDOWTHEME;
pub const DBID_PERMITAUTOHIDE = DESKBANDCID.PERMITAUTOHIDE;

// TODO: this type is limited to platform 'windows5.0'
const IID_IDeskBand_Value = Guid.initString("eb0fe172-1a3a-11d0-89b3-00a0c90a90ac");
pub const IID_IDeskBand = &IID_IDeskBand_Value;
pub const IDeskBand = extern struct {
    pub const VTable = extern struct {
        base: IDockingWindow.VTable,
        GetBandInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDeskBand,
                dwBandID: u32,
                dwViewMode: u32,
                pdbi: ?*DESKBANDINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDeskBand,
                dwBandID: u32,
                dwViewMode: u32,
                pdbi: ?*DESKBANDINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDockingWindow.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDeskBand_GetBandInfo(self: *const T, dwBandID: u32, dwViewMode: u32, pdbi: ?*DESKBANDINFO) HRESULT {
                return @as(*const IDeskBand.VTable, @ptrCast(self.vtable)).GetBandInfo(@as(*const IDeskBand, @ptrCast(self)), dwBandID, dwViewMode, pdbi);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IDeskBandInfo_Value = Guid.initString("77e425fc-cbf9-4307-ba6a-bb5727745661");
pub const IID_IDeskBandInfo = &IID_IDeskBandInfo_Value;
pub const IDeskBandInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDefaultBandWidth: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDeskBandInfo,
                dwBandID: u32,
                dwViewMode: u32,
                pnWidth: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDeskBandInfo,
                dwBandID: u32,
                dwViewMode: u32,
                pnWidth: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDeskBandInfo_GetDefaultBandWidth(self: *const T, dwBandID: u32, dwViewMode: u32, pnWidth: ?*i32) HRESULT {
                return @as(*const IDeskBandInfo.VTable, @ptrCast(self.vtable)).GetDefaultBandWidth(@as(*const IDeskBandInfo, @ptrCast(self)), dwBandID, dwViewMode, pnWidth);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITaskbarList_Value = Guid.initString("56fdf342-fd6d-11d0-958a-006097c9a090");
pub const IID_ITaskbarList = &IID_ITaskbarList_Value;
pub const ITaskbarList = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        HrInit: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITaskbarList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITaskbarList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddTab: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITaskbarList,
                hwnd: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITaskbarList,
                hwnd: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeleteTab: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITaskbarList,
                hwnd: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITaskbarList,
                hwnd: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ActivateTab: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITaskbarList,
                hwnd: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITaskbarList,
                hwnd: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetActiveAlt: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITaskbarList,
                hwnd: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITaskbarList,
                hwnd: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITaskbarList_HrInit(self: *const T) HRESULT {
                return @as(*const ITaskbarList.VTable, @ptrCast(self.vtable)).HrInit(@as(*const ITaskbarList, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITaskbarList_AddTab(self: *const T, hwnd: ?HWND) HRESULT {
                return @as(*const ITaskbarList.VTable, @ptrCast(self.vtable)).AddTab(@as(*const ITaskbarList, @ptrCast(self)), hwnd);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITaskbarList_DeleteTab(self: *const T, hwnd: ?HWND) HRESULT {
                return @as(*const ITaskbarList.VTable, @ptrCast(self.vtable)).DeleteTab(@as(*const ITaskbarList, @ptrCast(self)), hwnd);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITaskbarList_ActivateTab(self: *const T, hwnd: ?HWND) HRESULT {
                return @as(*const ITaskbarList.VTable, @ptrCast(self.vtable)).ActivateTab(@as(*const ITaskbarList, @ptrCast(self)), hwnd);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITaskbarList_SetActiveAlt(self: *const T, hwnd: ?HWND) HRESULT {
                return @as(*const ITaskbarList.VTable, @ptrCast(self.vtable)).SetActiveAlt(@as(*const ITaskbarList, @ptrCast(self)), hwnd);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ITaskbarList2_Value = Guid.initString("602d4995-b13a-429b-a66e-1935e44f4317");
pub const IID_ITaskbarList2 = &IID_ITaskbarList2_Value;
pub const ITaskbarList2 = extern struct {
    pub const VTable = extern struct {
        base: ITaskbarList.VTable,
        MarkFullscreenWindow: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITaskbarList2,
                hwnd: ?HWND,
                fFullscreen: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITaskbarList2,
                hwnd: ?HWND,
                fFullscreen: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITaskbarList.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITaskbarList2_MarkFullscreenWindow(self: *const T, hwnd: ?HWND, fFullscreen: BOOL) HRESULT {
                return @as(*const ITaskbarList2.VTable, @ptrCast(self.vtable)).MarkFullscreenWindow(@as(*const ITaskbarList2, @ptrCast(self)), hwnd, fFullscreen);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const THUMBBUTTONFLAGS = enum(i32) {
    ENABLED = 0,
    DISABLED = 1,
    DISMISSONCLICK = 2,
    NOBACKGROUND = 4,
    HIDDEN = 8,
    NONINTERACTIVE = 16,
};
pub const THBF_ENABLED = THUMBBUTTONFLAGS.ENABLED;
pub const THBF_DISABLED = THUMBBUTTONFLAGS.DISABLED;
pub const THBF_DISMISSONCLICK = THUMBBUTTONFLAGS.DISMISSONCLICK;
pub const THBF_NOBACKGROUND = THUMBBUTTONFLAGS.NOBACKGROUND;
pub const THBF_HIDDEN = THUMBBUTTONFLAGS.HIDDEN;
pub const THBF_NONINTERACTIVE = THUMBBUTTONFLAGS.NONINTERACTIVE;

pub const THUMBBUTTONMASK = enum(i32) {
    BITMAP = 1,
    ICON = 2,
    TOOLTIP = 4,
    FLAGS = 8,
};
pub const THB_BITMAP = THUMBBUTTONMASK.BITMAP;
pub const THB_ICON = THUMBBUTTONMASK.ICON;
pub const THB_TOOLTIP = THUMBBUTTONMASK.TOOLTIP;
pub const THB_FLAGS = THUMBBUTTONMASK.FLAGS;

pub const THUMBBUTTON = extern struct {
    dwMask: THUMBBUTTONMASK,
    iId: u32,
    iBitmap: u32,
    hIcon: ?HICON,
    szTip: [260]u16,
    dwFlags: THUMBBUTTONFLAGS,
};

pub const TBPFLAG = enum(i32) {
    NOPROGRESS = 0,
    INDETERMINATE = 1,
    NORMAL = 2,
    ERROR = 4,
    PAUSED = 8,
};
pub const TBPF_NOPROGRESS = TBPFLAG.NOPROGRESS;
pub const TBPF_INDETERMINATE = TBPFLAG.INDETERMINATE;
pub const TBPF_NORMAL = TBPFLAG.NORMAL;
pub const TBPF_ERROR = TBPFLAG.ERROR;
pub const TBPF_PAUSED = TBPFLAG.PAUSED;

// TODO: this type is limited to platform 'windows6.1'
const IID_ITaskbarList3_Value = Guid.initString("ea1afb91-9e28-4b86-90e9-9e9f8a5eefaf");
pub const IID_ITaskbarList3 = &IID_ITaskbarList3_Value;
pub const ITaskbarList3 = extern struct {
    pub const VTable = extern struct {
        base: ITaskbarList2.VTable,
        SetProgressValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITaskbarList3,
                hwnd: ?HWND,
                ullCompleted: u64,
                ullTotal: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITaskbarList3,
                hwnd: ?HWND,
                ullCompleted: u64,
                ullTotal: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetProgressState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITaskbarList3,
                hwnd: ?HWND,
                tbpFlags: TBPFLAG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITaskbarList3,
                hwnd: ?HWND,
                tbpFlags: TBPFLAG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RegisterTab: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITaskbarList3,
                hwndTab: ?HWND,
                hwndMDI: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITaskbarList3,
                hwndTab: ?HWND,
                hwndMDI: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnregisterTab: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITaskbarList3,
                hwndTab: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITaskbarList3,
                hwndTab: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTabOrder: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITaskbarList3,
                hwndTab: ?HWND,
                hwndInsertBefore: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITaskbarList3,
                hwndTab: ?HWND,
                hwndInsertBefore: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTabActive: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITaskbarList3,
                hwndTab: ?HWND,
                hwndMDI: ?HWND,
                dwReserved: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITaskbarList3,
                hwndTab: ?HWND,
                hwndMDI: ?HWND,
                dwReserved: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ThumbBarAddButtons: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITaskbarList3,
                hwnd: ?HWND,
                cButtons: u32,
                pButton: [*]THUMBBUTTON,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITaskbarList3,
                hwnd: ?HWND,
                cButtons: u32,
                pButton: [*]THUMBBUTTON,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ThumbBarUpdateButtons: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITaskbarList3,
                hwnd: ?HWND,
                cButtons: u32,
                pButton: [*]THUMBBUTTON,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITaskbarList3,
                hwnd: ?HWND,
                cButtons: u32,
                pButton: [*]THUMBBUTTON,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ThumbBarSetImageList: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITaskbarList3,
                hwnd: ?HWND,
                himl: ?HIMAGELIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITaskbarList3,
                hwnd: ?HWND,
                himl: ?HIMAGELIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOverlayIcon: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITaskbarList3,
                hwnd: ?HWND,
                hIcon: ?HICON,
                pszDescription: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITaskbarList3,
                hwnd: ?HWND,
                hIcon: ?HICON,
                pszDescription: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetThumbnailTooltip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITaskbarList3,
                hwnd: ?HWND,
                pszTip: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITaskbarList3,
                hwnd: ?HWND,
                pszTip: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetThumbnailClip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITaskbarList3,
                hwnd: ?HWND,
                prcClip: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITaskbarList3,
                hwnd: ?HWND,
                prcClip: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITaskbarList2.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITaskbarList3_SetProgressValue(self: *const T, hwnd: ?HWND, ullCompleted: u64, ullTotal: u64) HRESULT {
                return @as(*const ITaskbarList3.VTable, @ptrCast(self.vtable)).SetProgressValue(@as(*const ITaskbarList3, @ptrCast(self)), hwnd, ullCompleted, ullTotal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITaskbarList3_SetProgressState(self: *const T, hwnd: ?HWND, tbpFlags: TBPFLAG) HRESULT {
                return @as(*const ITaskbarList3.VTable, @ptrCast(self.vtable)).SetProgressState(@as(*const ITaskbarList3, @ptrCast(self)), hwnd, tbpFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITaskbarList3_RegisterTab(self: *const T, hwndTab: ?HWND, hwndMDI: ?HWND) HRESULT {
                return @as(*const ITaskbarList3.VTable, @ptrCast(self.vtable)).RegisterTab(@as(*const ITaskbarList3, @ptrCast(self)), hwndTab, hwndMDI);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITaskbarList3_UnregisterTab(self: *const T, hwndTab: ?HWND) HRESULT {
                return @as(*const ITaskbarList3.VTable, @ptrCast(self.vtable)).UnregisterTab(@as(*const ITaskbarList3, @ptrCast(self)), hwndTab);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITaskbarList3_SetTabOrder(self: *const T, hwndTab: ?HWND, hwndInsertBefore: ?HWND) HRESULT {
                return @as(*const ITaskbarList3.VTable, @ptrCast(self.vtable)).SetTabOrder(@as(*const ITaskbarList3, @ptrCast(self)), hwndTab, hwndInsertBefore);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITaskbarList3_SetTabActive(self: *const T, hwndTab: ?HWND, hwndMDI: ?HWND, dwReserved: u32) HRESULT {
                return @as(*const ITaskbarList3.VTable, @ptrCast(self.vtable)).SetTabActive(@as(*const ITaskbarList3, @ptrCast(self)), hwndTab, hwndMDI, dwReserved);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITaskbarList3_ThumbBarAddButtons(self: *const T, hwnd: ?HWND, cButtons: u32, pButton: [*]THUMBBUTTON) HRESULT {
                return @as(*const ITaskbarList3.VTable, @ptrCast(self.vtable)).ThumbBarAddButtons(@as(*const ITaskbarList3, @ptrCast(self)), hwnd, cButtons, pButton);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITaskbarList3_ThumbBarUpdateButtons(self: *const T, hwnd: ?HWND, cButtons: u32, pButton: [*]THUMBBUTTON) HRESULT {
                return @as(*const ITaskbarList3.VTable, @ptrCast(self.vtable)).ThumbBarUpdateButtons(@as(*const ITaskbarList3, @ptrCast(self)), hwnd, cButtons, pButton);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITaskbarList3_ThumbBarSetImageList(self: *const T, hwnd: ?HWND, himl: ?HIMAGELIST) HRESULT {
                return @as(*const ITaskbarList3.VTable, @ptrCast(self.vtable)).ThumbBarSetImageList(@as(*const ITaskbarList3, @ptrCast(self)), hwnd, himl);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITaskbarList3_SetOverlayIcon(self: *const T, hwnd: ?HWND, hIcon: ?HICON, pszDescription: ?[*:0]const u16) HRESULT {
                return @as(*const ITaskbarList3.VTable, @ptrCast(self.vtable)).SetOverlayIcon(@as(*const ITaskbarList3, @ptrCast(self)), hwnd, hIcon, pszDescription);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITaskbarList3_SetThumbnailTooltip(self: *const T, hwnd: ?HWND, pszTip: ?[*:0]const u16) HRESULT {
                return @as(*const ITaskbarList3.VTable, @ptrCast(self.vtable)).SetThumbnailTooltip(@as(*const ITaskbarList3, @ptrCast(self)), hwnd, pszTip);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITaskbarList3_SetThumbnailClip(self: *const T, hwnd: ?HWND, prcClip: ?*RECT) HRESULT {
                return @as(*const ITaskbarList3.VTable, @ptrCast(self.vtable)).SetThumbnailClip(@as(*const ITaskbarList3, @ptrCast(self)), hwnd, prcClip);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const STPFLAG = enum(i32) {
    NONE = 0,
    USEAPPTHUMBNAILALWAYS = 1,
    USEAPPTHUMBNAILWHENACTIVE = 2,
    USEAPPPEEKALWAYS = 4,
    USEAPPPEEKWHENACTIVE = 8,
};
pub const STPF_NONE = STPFLAG.NONE;
pub const STPF_USEAPPTHUMBNAILALWAYS = STPFLAG.USEAPPTHUMBNAILALWAYS;
pub const STPF_USEAPPTHUMBNAILWHENACTIVE = STPFLAG.USEAPPTHUMBNAILWHENACTIVE;
pub const STPF_USEAPPPEEKALWAYS = STPFLAG.USEAPPPEEKALWAYS;
pub const STPF_USEAPPPEEKWHENACTIVE = STPFLAG.USEAPPPEEKWHENACTIVE;

// TODO: this type is limited to platform 'windows6.1'
const IID_ITaskbarList4_Value = Guid.initString("c43dc798-95d1-4bea-9030-bb99e2983a1a");
pub const IID_ITaskbarList4 = &IID_ITaskbarList4_Value;
pub const ITaskbarList4 = extern struct {
    pub const VTable = extern struct {
        base: ITaskbarList3.VTable,
        SetTabProperties: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITaskbarList4,
                hwndTab: ?HWND,
                stpFlags: STPFLAG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITaskbarList4,
                hwndTab: ?HWND,
                stpFlags: STPFLAG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITaskbarList3.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITaskbarList4_SetTabProperties(self: *const T, hwndTab: ?HWND, stpFlags: STPFLAG) HRESULT {
                return @as(*const ITaskbarList4.VTable, @ptrCast(self.vtable)).SetTabProperties(@as(*const ITaskbarList4, @ptrCast(self)), hwndTab, stpFlags);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IExplorerBrowserEvents_Value = Guid.initString("361bbdc7-e6ee-4e13-be58-58e2240c810f");
pub const IID_IExplorerBrowserEvents = &IID_IExplorerBrowserEvents_Value;
pub const IExplorerBrowserEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnNavigationPending: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IExplorerBrowserEvents,
                pidlFolder: ?*ITEMIDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IExplorerBrowserEvents,
                pidlFolder: ?*ITEMIDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnViewCreated: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IExplorerBrowserEvents,
                psv: ?*IShellView,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IExplorerBrowserEvents,
                psv: ?*IShellView,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnNavigationComplete: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IExplorerBrowserEvents,
                pidlFolder: ?*ITEMIDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IExplorerBrowserEvents,
                pidlFolder: ?*ITEMIDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnNavigationFailed: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IExplorerBrowserEvents,
                pidlFolder: ?*ITEMIDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IExplorerBrowserEvents,
                pidlFolder: ?*ITEMIDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IExplorerBrowserEvents_OnNavigationPending(self: *const T, pidlFolder: ?*ITEMIDLIST) HRESULT {
                return @as(*const IExplorerBrowserEvents.VTable, @ptrCast(self.vtable)).OnNavigationPending(@as(*const IExplorerBrowserEvents, @ptrCast(self)), pidlFolder);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IExplorerBrowserEvents_OnViewCreated(self: *const T, psv: ?*IShellView) HRESULT {
                return @as(*const IExplorerBrowserEvents.VTable, @ptrCast(self.vtable)).OnViewCreated(@as(*const IExplorerBrowserEvents, @ptrCast(self)), psv);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IExplorerBrowserEvents_OnNavigationComplete(self: *const T, pidlFolder: ?*ITEMIDLIST) HRESULT {
                return @as(*const IExplorerBrowserEvents.VTable, @ptrCast(self.vtable)).OnNavigationComplete(@as(*const IExplorerBrowserEvents, @ptrCast(self)), pidlFolder);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IExplorerBrowserEvents_OnNavigationFailed(self: *const T, pidlFolder: ?*ITEMIDLIST) HRESULT {
                return @as(*const IExplorerBrowserEvents.VTable, @ptrCast(self.vtable)).OnNavigationFailed(@as(*const IExplorerBrowserEvents, @ptrCast(self)), pidlFolder);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const EXPLORER_BROWSER_OPTIONS = enum(i32) {
    NONE = 0,
    NAVIGATEONCE = 1,
    SHOWFRAMES = 2,
    ALWAYSNAVIGATE = 4,
    NOTRAVELLOG = 8,
    NOWRAPPERWINDOW = 16,
    HTMLSHAREPOINTVIEW = 32,
    NOBORDER = 64,
    NOPERSISTVIEWSTATE = 128,
};
pub const EBO_NONE = EXPLORER_BROWSER_OPTIONS.NONE;
pub const EBO_NAVIGATEONCE = EXPLORER_BROWSER_OPTIONS.NAVIGATEONCE;
pub const EBO_SHOWFRAMES = EXPLORER_BROWSER_OPTIONS.SHOWFRAMES;
pub const EBO_ALWAYSNAVIGATE = EXPLORER_BROWSER_OPTIONS.ALWAYSNAVIGATE;
pub const EBO_NOTRAVELLOG = EXPLORER_BROWSER_OPTIONS.NOTRAVELLOG;
pub const EBO_NOWRAPPERWINDOW = EXPLORER_BROWSER_OPTIONS.NOWRAPPERWINDOW;
pub const EBO_HTMLSHAREPOINTVIEW = EXPLORER_BROWSER_OPTIONS.HTMLSHAREPOINTVIEW;
pub const EBO_NOBORDER = EXPLORER_BROWSER_OPTIONS.NOBORDER;
pub const EBO_NOPERSISTVIEWSTATE = EXPLORER_BROWSER_OPTIONS.NOPERSISTVIEWSTATE;

pub const EXPLORER_BROWSER_FILL_FLAGS = enum(i32) {
    NONE = 0,
    SELECTFROMDATAOBJECT = 256,
    NODROPTARGET = 512,
};
pub const EBF_NONE = EXPLORER_BROWSER_FILL_FLAGS.NONE;
pub const EBF_SELECTFROMDATAOBJECT = EXPLORER_BROWSER_FILL_FLAGS.SELECTFROMDATAOBJECT;
pub const EBF_NODROPTARGET = EXPLORER_BROWSER_FILL_FLAGS.NODROPTARGET;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IExplorerBrowser_Value = Guid.initString("dfd3b6b5-c10c-4be9-85f6-a66969f402f6");
pub const IID_IExplorerBrowser = &IID_IExplorerBrowser_Value;
pub const IExplorerBrowser = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IExplorerBrowser,
                hwndParent: ?HWND,
                prc: ?*const RECT,
                pfs: ?*const FOLDERSETTINGS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IExplorerBrowser,
                hwndParent: ?HWND,
                prc: ?*const RECT,
                pfs: ?*const FOLDERSETTINGS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Destroy: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IExplorerBrowser,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IExplorerBrowser,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetRect: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IExplorerBrowser,
                phdwp: ?*isize,
                rcBrowser: RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IExplorerBrowser,
                phdwp: ?*isize,
                rcBrowser: RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPropertyBag: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IExplorerBrowser,
                pszPropertyBag: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IExplorerBrowser,
                pszPropertyBag: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEmptyText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IExplorerBrowser,
                pszEmptyText: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IExplorerBrowser,
                pszEmptyText: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFolderSettings: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IExplorerBrowser,
                pfs: ?*const FOLDERSETTINGS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IExplorerBrowser,
                pfs: ?*const FOLDERSETTINGS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Advise: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IExplorerBrowser,
                psbe: ?*IExplorerBrowserEvents,
                pdwCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IExplorerBrowser,
                psbe: ?*IExplorerBrowserEvents,
                pdwCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Unadvise: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IExplorerBrowser,
                dwCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IExplorerBrowser,
                dwCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IExplorerBrowser,
                dwFlag: EXPLORER_BROWSER_OPTIONS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IExplorerBrowser,
                dwFlag: EXPLORER_BROWSER_OPTIONS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IExplorerBrowser,
                pdwFlag: ?*EXPLORER_BROWSER_OPTIONS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IExplorerBrowser,
                pdwFlag: ?*EXPLORER_BROWSER_OPTIONS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BrowseToIDList: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IExplorerBrowser,
                pidl: ?*ITEMIDLIST,
                uFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IExplorerBrowser,
                pidl: ?*ITEMIDLIST,
                uFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BrowseToObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IExplorerBrowser,
                punk: ?*IUnknown,
                uFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IExplorerBrowser,
                punk: ?*IUnknown,
                uFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FillFromObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IExplorerBrowser,
                punk: ?*IUnknown,
                dwFlags: EXPLORER_BROWSER_FILL_FLAGS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IExplorerBrowser,
                punk: ?*IUnknown,
                dwFlags: EXPLORER_BROWSER_FILL_FLAGS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveAll: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IExplorerBrowser,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IExplorerBrowser,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentView: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IExplorerBrowser,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IExplorerBrowser,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IExplorerBrowser_Initialize(self: *const T, hwndParent: ?HWND, prc: ?*const RECT, pfs: ?*const FOLDERSETTINGS) HRESULT {
                return @as(*const IExplorerBrowser.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IExplorerBrowser, @ptrCast(self)), hwndParent, prc, pfs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IExplorerBrowser_Destroy(self: *const T) HRESULT {
                return @as(*const IExplorerBrowser.VTable, @ptrCast(self.vtable)).Destroy(@as(*const IExplorerBrowser, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IExplorerBrowser_SetRect(self: *const T, phdwp: ?*isize, rcBrowser: RECT) HRESULT {
                return @as(*const IExplorerBrowser.VTable, @ptrCast(self.vtable)).SetRect(@as(*const IExplorerBrowser, @ptrCast(self)), phdwp, rcBrowser);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IExplorerBrowser_SetPropertyBag(self: *const T, pszPropertyBag: ?[*:0]const u16) HRESULT {
                return @as(*const IExplorerBrowser.VTable, @ptrCast(self.vtable)).SetPropertyBag(@as(*const IExplorerBrowser, @ptrCast(self)), pszPropertyBag);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IExplorerBrowser_SetEmptyText(self: *const T, pszEmptyText: ?[*:0]const u16) HRESULT {
                return @as(*const IExplorerBrowser.VTable, @ptrCast(self.vtable)).SetEmptyText(@as(*const IExplorerBrowser, @ptrCast(self)), pszEmptyText);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IExplorerBrowser_SetFolderSettings(self: *const T, pfs: ?*const FOLDERSETTINGS) HRESULT {
                return @as(*const IExplorerBrowser.VTable, @ptrCast(self.vtable)).SetFolderSettings(@as(*const IExplorerBrowser, @ptrCast(self)), pfs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IExplorerBrowser_Advise(self: *const T, psbe: ?*IExplorerBrowserEvents, pdwCookie: ?*u32) HRESULT {
                return @as(*const IExplorerBrowser.VTable, @ptrCast(self.vtable)).Advise(@as(*const IExplorerBrowser, @ptrCast(self)), psbe, pdwCookie);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IExplorerBrowser_Unadvise(self: *const T, dwCookie: u32) HRESULT {
                return @as(*const IExplorerBrowser.VTable, @ptrCast(self.vtable)).Unadvise(@as(*const IExplorerBrowser, @ptrCast(self)), dwCookie);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IExplorerBrowser_SetOptions(self: *const T, dwFlag: EXPLORER_BROWSER_OPTIONS) HRESULT {
                return @as(*const IExplorerBrowser.VTable, @ptrCast(self.vtable)).SetOptions(@as(*const IExplorerBrowser, @ptrCast(self)), dwFlag);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IExplorerBrowser_GetOptions(self: *const T, pdwFlag: ?*EXPLORER_BROWSER_OPTIONS) HRESULT {
                return @as(*const IExplorerBrowser.VTable, @ptrCast(self.vtable)).GetOptions(@as(*const IExplorerBrowser, @ptrCast(self)), pdwFlag);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IExplorerBrowser_BrowseToIDList(self: *const T, pidl: ?*ITEMIDLIST, uFlags: u32) HRESULT {
                return @as(*const IExplorerBrowser.VTable, @ptrCast(self.vtable)).BrowseToIDList(@as(*const IExplorerBrowser, @ptrCast(self)), pidl, uFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IExplorerBrowser_BrowseToObject(self: *const T, punk: ?*IUnknown, uFlags: u32) HRESULT {
                return @as(*const IExplorerBrowser.VTable, @ptrCast(self.vtable)).BrowseToObject(@as(*const IExplorerBrowser, @ptrCast(self)), punk, uFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IExplorerBrowser_FillFromObject(self: *const T, punk: ?*IUnknown, dwFlags: EXPLORER_BROWSER_FILL_FLAGS) HRESULT {
                return @as(*const IExplorerBrowser.VTable, @ptrCast(self.vtable)).FillFromObject(@as(*const IExplorerBrowser, @ptrCast(self)), punk, dwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IExplorerBrowser_RemoveAll(self: *const T) HRESULT {
                return @as(*const IExplorerBrowser.VTable, @ptrCast(self.vtable)).RemoveAll(@as(*const IExplorerBrowser, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IExplorerBrowser_GetCurrentView(self: *const T, riid: ?*const Guid, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const IExplorerBrowser.VTable, @ptrCast(self.vtable)).GetCurrentView(@as(*const IExplorerBrowser, @ptrCast(self)), riid, ppv);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IEnumObjects_Value = Guid.initString("2c1c7e2e-2d0e-4059-831e-1e6f82335c2e");
pub const IID_IEnumObjects = &IID_IEnumObjects_Value;
pub const IEnumObjects = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumObjects,
                celt: u32,
                riid: ?*const Guid,
                rgelt: [*]?*anyopaque,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumObjects,
                celt: u32,
                riid: ?*const Guid,
                rgelt: [*]?*anyopaque,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumObjects,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumObjects,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumObjects,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumObjects,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumObjects,
                ppenum: ?*?*IEnumObjects,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumObjects,
                ppenum: ?*?*IEnumObjects,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumObjects_Next(self: *const T, celt: u32, riid: ?*const Guid, rgelt: [*]?*anyopaque, pceltFetched: ?*u32) HRESULT {
                return @as(*const IEnumObjects.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumObjects, @ptrCast(self)), celt, riid, rgelt, pceltFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumObjects_Skip(self: *const T, celt: u32) HRESULT {
                return @as(*const IEnumObjects.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumObjects, @ptrCast(self)), celt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumObjects_Reset(self: *const T) HRESULT {
                return @as(*const IEnumObjects.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumObjects, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumObjects_Clone(self: *const T, ppenum: ?*?*IEnumObjects) HRESULT {
                return @as(*const IEnumObjects.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumObjects, @ptrCast(self)), ppenum);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const _OPPROGDLGF = enum(i32) {
    DEFAULT = 0,
    ENABLEPAUSE = 128,
    ALLOWUNDO = 256,
    DONTDISPLAYSOURCEPATH = 512,
    DONTDISPLAYDESTPATH = 1024,
    NOMULTIDAYESTIMATES = 2048,
    DONTDISPLAYLOCATIONS = 4096,
};
pub const OPPROGDLG_DEFAULT = _OPPROGDLGF.DEFAULT;
pub const OPPROGDLG_ENABLEPAUSE = _OPPROGDLGF.ENABLEPAUSE;
pub const OPPROGDLG_ALLOWUNDO = _OPPROGDLGF.ALLOWUNDO;
pub const OPPROGDLG_DONTDISPLAYSOURCEPATH = _OPPROGDLGF.DONTDISPLAYSOURCEPATH;
pub const OPPROGDLG_DONTDISPLAYDESTPATH = _OPPROGDLGF.DONTDISPLAYDESTPATH;
pub const OPPROGDLG_NOMULTIDAYESTIMATES = _OPPROGDLGF.NOMULTIDAYESTIMATES;
pub const OPPROGDLG_DONTDISPLAYLOCATIONS = _OPPROGDLGF.DONTDISPLAYLOCATIONS;

pub const _PDMODE = enum(i32) {
    DEFAULT = 0,
    RUN = 1,
    PREFLIGHT = 2,
    UNDOING = 4,
    ERRORSBLOCKING = 8,
    INDETERMINATE = 16,
};
pub const PDM_DEFAULT = _PDMODE.DEFAULT;
pub const PDM_RUN = _PDMODE.RUN;
pub const PDM_PREFLIGHT = _PDMODE.PREFLIGHT;
pub const PDM_UNDOING = _PDMODE.UNDOING;
pub const PDM_ERRORSBLOCKING = _PDMODE.ERRORSBLOCKING;
pub const PDM_INDETERMINATE = _PDMODE.INDETERMINATE;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IOperationsProgressDialog_Value = Guid.initString("0c9fb851-e5c9-43eb-a370-f0677b13874c");
pub const IID_IOperationsProgressDialog = &IID_IOperationsProgressDialog_Value;
pub const IOperationsProgressDialog = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        StartProgressDialog: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOperationsProgressDialog,
                hwndOwner: ?HWND,
                flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOperationsProgressDialog,
                hwndOwner: ?HWND,
                flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StopProgressDialog: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOperationsProgressDialog,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOperationsProgressDialog,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOperation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOperationsProgressDialog,
                action: SPACTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOperationsProgressDialog,
                action: SPACTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOperationsProgressDialog,
                mode: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOperationsProgressDialog,
                mode: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UpdateProgress: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOperationsProgressDialog,
                ullPointsCurrent: u64,
                ullPointsTotal: u64,
                ullSizeCurrent: u64,
                ullSizeTotal: u64,
                ullItemsCurrent: u64,
                ullItemsTotal: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOperationsProgressDialog,
                ullPointsCurrent: u64,
                ullPointsTotal: u64,
                ullSizeCurrent: u64,
                ullSizeTotal: u64,
                ullItemsCurrent: u64,
                ullItemsTotal: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UpdateLocations: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOperationsProgressDialog,
                psiSource: ?*IShellItem,
                psiTarget: ?*IShellItem,
                psiItem: ?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOperationsProgressDialog,
                psiSource: ?*IShellItem,
                psiTarget: ?*IShellItem,
                psiItem: ?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ResetTimer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOperationsProgressDialog,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOperationsProgressDialog,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PauseTimer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOperationsProgressDialog,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOperationsProgressDialog,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ResumeTimer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOperationsProgressDialog,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOperationsProgressDialog,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMilliseconds: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOperationsProgressDialog,
                pullElapsed: ?*u64,
                pullRemaining: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOperationsProgressDialog,
                pullElapsed: ?*u64,
                pullRemaining: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOperationStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOperationsProgressDialog,
                popstatus: ?*PDOPSTATUS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOperationsProgressDialog,
                popstatus: ?*PDOPSTATUS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOperationsProgressDialog_StartProgressDialog(self: *const T, hwndOwner: ?HWND, flags: u32) HRESULT {
                return @as(*const IOperationsProgressDialog.VTable, @ptrCast(self.vtable)).StartProgressDialog(@as(*const IOperationsProgressDialog, @ptrCast(self)), hwndOwner, flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOperationsProgressDialog_StopProgressDialog(self: *const T) HRESULT {
                return @as(*const IOperationsProgressDialog.VTable, @ptrCast(self.vtable)).StopProgressDialog(@as(*const IOperationsProgressDialog, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOperationsProgressDialog_SetOperation(self: *const T, action: SPACTION) HRESULT {
                return @as(*const IOperationsProgressDialog.VTable, @ptrCast(self.vtable)).SetOperation(@as(*const IOperationsProgressDialog, @ptrCast(self)), action);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOperationsProgressDialog_SetMode(self: *const T, mode: u32) HRESULT {
                return @as(*const IOperationsProgressDialog.VTable, @ptrCast(self.vtable)).SetMode(@as(*const IOperationsProgressDialog, @ptrCast(self)), mode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOperationsProgressDialog_UpdateProgress(self: *const T, ullPointsCurrent: u64, ullPointsTotal: u64, ullSizeCurrent: u64, ullSizeTotal: u64, ullItemsCurrent: u64, ullItemsTotal: u64) HRESULT {
                return @as(*const IOperationsProgressDialog.VTable, @ptrCast(self.vtable)).UpdateProgress(@as(*const IOperationsProgressDialog, @ptrCast(self)), ullPointsCurrent, ullPointsTotal, ullSizeCurrent, ullSizeTotal, ullItemsCurrent, ullItemsTotal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOperationsProgressDialog_UpdateLocations(self: *const T, psiSource: ?*IShellItem, psiTarget: ?*IShellItem, psiItem: ?*IShellItem) HRESULT {
                return @as(*const IOperationsProgressDialog.VTable, @ptrCast(self.vtable)).UpdateLocations(@as(*const IOperationsProgressDialog, @ptrCast(self)), psiSource, psiTarget, psiItem);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOperationsProgressDialog_ResetTimer(self: *const T) HRESULT {
                return @as(*const IOperationsProgressDialog.VTable, @ptrCast(self.vtable)).ResetTimer(@as(*const IOperationsProgressDialog, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOperationsProgressDialog_PauseTimer(self: *const T) HRESULT {
                return @as(*const IOperationsProgressDialog.VTable, @ptrCast(self.vtable)).PauseTimer(@as(*const IOperationsProgressDialog, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOperationsProgressDialog_ResumeTimer(self: *const T) HRESULT {
                return @as(*const IOperationsProgressDialog.VTable, @ptrCast(self.vtable)).ResumeTimer(@as(*const IOperationsProgressDialog, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOperationsProgressDialog_GetMilliseconds(self: *const T, pullElapsed: ?*u64, pullRemaining: ?*u64) HRESULT {
                return @as(*const IOperationsProgressDialog.VTable, @ptrCast(self.vtable)).GetMilliseconds(@as(*const IOperationsProgressDialog, @ptrCast(self)), pullElapsed, pullRemaining);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOperationsProgressDialog_GetOperationStatus(self: *const T, popstatus: ?*PDOPSTATUS) HRESULT {
                return @as(*const IOperationsProgressDialog.VTable, @ptrCast(self.vtable)).GetOperationStatus(@as(*const IOperationsProgressDialog, @ptrCast(self)), popstatus);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IIOCancelInformation_Value = Guid.initString("f5b0bf81-8cb5-4b1b-9449-1a159e0c733c");
pub const IID_IIOCancelInformation = &IID_IIOCancelInformation_Value;
pub const IIOCancelInformation = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetCancelInformation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IIOCancelInformation,
                dwThreadID: u32,
                uMsgCancel: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IIOCancelInformation,
                dwThreadID: u32,
                uMsgCancel: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCancelInformation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IIOCancelInformation,
                pdwThreadID: ?*u32,
                puMsgCancel: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IIOCancelInformation,
                pdwThreadID: ?*u32,
                puMsgCancel: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IIOCancelInformation_SetCancelInformation(self: *const T, dwThreadID: u32, uMsgCancel: u32) HRESULT {
                return @as(*const IIOCancelInformation.VTable, @ptrCast(self.vtable)).SetCancelInformation(@as(*const IIOCancelInformation, @ptrCast(self)), dwThreadID, uMsgCancel);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IIOCancelInformation_GetCancelInformation(self: *const T, pdwThreadID: ?*u32, puMsgCancel: ?*u32) HRESULT {
                return @as(*const IIOCancelInformation.VTable, @ptrCast(self.vtable)).GetCancelInformation(@as(*const IIOCancelInformation, @ptrCast(self)), pdwThreadID, puMsgCancel);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IFileOperation_Value = Guid.initString("947aab5f-0a5c-4c13-b4d6-4bf7836fc9f8");
pub const IID_IFileOperation = &IID_IFileOperation_Value;
pub const IFileOperation = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Advise: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileOperation,
                pfops: ?*IFileOperationProgressSink,
                pdwCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileOperation,
                pfops: ?*IFileOperationProgressSink,
                pdwCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Unadvise: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileOperation,
                dwCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileOperation,
                dwCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOperationFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileOperation,
                dwOperationFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileOperation,
                dwOperationFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetProgressMessage: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileOperation,
                pszMessage: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileOperation,
                pszMessage: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetProgressDialog: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileOperation,
                popd: ?*IOperationsProgressDialog,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileOperation,
                popd: ?*IOperationsProgressDialog,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetProperties: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileOperation,
                pproparray: ?*IPropertyChangeArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileOperation,
                pproparray: ?*IPropertyChangeArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOwnerWindow: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileOperation,
                hwndOwner: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileOperation,
                hwndOwner: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ApplyPropertiesToItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileOperation,
                psiItem: ?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileOperation,
                psiItem: ?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ApplyPropertiesToItems: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileOperation,
                punkItems: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileOperation,
                punkItems: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RenameItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileOperation,
                psiItem: ?*IShellItem,
                pszNewName: ?[*:0]const u16,
                pfopsItem: ?*IFileOperationProgressSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileOperation,
                psiItem: ?*IShellItem,
                pszNewName: ?[*:0]const u16,
                pfopsItem: ?*IFileOperationProgressSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RenameItems: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileOperation,
                pUnkItems: ?*IUnknown,
                pszNewName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileOperation,
                pUnkItems: ?*IUnknown,
                pszNewName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        MoveItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileOperation,
                psiItem: ?*IShellItem,
                psiDestinationFolder: ?*IShellItem,
                pszNewName: ?[*:0]const u16,
                pfopsItem: ?*IFileOperationProgressSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileOperation,
                psiItem: ?*IShellItem,
                psiDestinationFolder: ?*IShellItem,
                pszNewName: ?[*:0]const u16,
                pfopsItem: ?*IFileOperationProgressSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        MoveItems: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileOperation,
                punkItems: ?*IUnknown,
                psiDestinationFolder: ?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileOperation,
                punkItems: ?*IUnknown,
                psiDestinationFolder: ?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CopyItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileOperation,
                psiItem: ?*IShellItem,
                psiDestinationFolder: ?*IShellItem,
                pszCopyName: ?[*:0]const u16,
                pfopsItem: ?*IFileOperationProgressSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileOperation,
                psiItem: ?*IShellItem,
                psiDestinationFolder: ?*IShellItem,
                pszCopyName: ?[*:0]const u16,
                pfopsItem: ?*IFileOperationProgressSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CopyItems: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileOperation,
                punkItems: ?*IUnknown,
                psiDestinationFolder: ?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileOperation,
                punkItems: ?*IUnknown,
                psiDestinationFolder: ?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeleteItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileOperation,
                psiItem: ?*IShellItem,
                pfopsItem: ?*IFileOperationProgressSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileOperation,
                psiItem: ?*IShellItem,
                pfopsItem: ?*IFileOperationProgressSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeleteItems: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileOperation,
                punkItems: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileOperation,
                punkItems: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NewItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileOperation,
                psiDestinationFolder: ?*IShellItem,
                dwFileAttributes: u32,
                pszName: ?[*:0]const u16,
                pszTemplateName: ?[*:0]const u16,
                pfopsItem: ?*IFileOperationProgressSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileOperation,
                psiDestinationFolder: ?*IShellItem,
                dwFileAttributes: u32,
                pszName: ?[*:0]const u16,
                pszTemplateName: ?[*:0]const u16,
                pfopsItem: ?*IFileOperationProgressSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PerformOperations: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileOperation,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileOperation,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAnyOperationsAborted: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileOperation,
                pfAnyOperationsAborted: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileOperation,
                pfAnyOperationsAborted: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileOperation_Advise(self: *const T, pfops: ?*IFileOperationProgressSink, pdwCookie: ?*u32) HRESULT {
                return @as(*const IFileOperation.VTable, @ptrCast(self.vtable)).Advise(@as(*const IFileOperation, @ptrCast(self)), pfops, pdwCookie);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileOperation_Unadvise(self: *const T, dwCookie: u32) HRESULT {
                return @as(*const IFileOperation.VTable, @ptrCast(self.vtable)).Unadvise(@as(*const IFileOperation, @ptrCast(self)), dwCookie);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileOperation_SetOperationFlags(self: *const T, dwOperationFlags: u32) HRESULT {
                return @as(*const IFileOperation.VTable, @ptrCast(self.vtable)).SetOperationFlags(@as(*const IFileOperation, @ptrCast(self)), dwOperationFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileOperation_SetProgressMessage(self: *const T, pszMessage: ?[*:0]const u16) HRESULT {
                return @as(*const IFileOperation.VTable, @ptrCast(self.vtable)).SetProgressMessage(@as(*const IFileOperation, @ptrCast(self)), pszMessage);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileOperation_SetProgressDialog(self: *const T, popd: ?*IOperationsProgressDialog) HRESULT {
                return @as(*const IFileOperation.VTable, @ptrCast(self.vtable)).SetProgressDialog(@as(*const IFileOperation, @ptrCast(self)), popd);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileOperation_SetProperties(self: *const T, pproparray: ?*IPropertyChangeArray) HRESULT {
                return @as(*const IFileOperation.VTable, @ptrCast(self.vtable)).SetProperties(@as(*const IFileOperation, @ptrCast(self)), pproparray);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileOperation_SetOwnerWindow(self: *const T, hwndOwner: ?HWND) HRESULT {
                return @as(*const IFileOperation.VTable, @ptrCast(self.vtable)).SetOwnerWindow(@as(*const IFileOperation, @ptrCast(self)), hwndOwner);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileOperation_ApplyPropertiesToItem(self: *const T, psiItem: ?*IShellItem) HRESULT {
                return @as(*const IFileOperation.VTable, @ptrCast(self.vtable)).ApplyPropertiesToItem(@as(*const IFileOperation, @ptrCast(self)), psiItem);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileOperation_ApplyPropertiesToItems(self: *const T, punkItems: ?*IUnknown) HRESULT {
                return @as(*const IFileOperation.VTable, @ptrCast(self.vtable)).ApplyPropertiesToItems(@as(*const IFileOperation, @ptrCast(self)), punkItems);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileOperation_RenameItem(self: *const T, psiItem: ?*IShellItem, pszNewName: ?[*:0]const u16, pfopsItem: ?*IFileOperationProgressSink) HRESULT {
                return @as(*const IFileOperation.VTable, @ptrCast(self.vtable)).RenameItem(@as(*const IFileOperation, @ptrCast(self)), psiItem, pszNewName, pfopsItem);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileOperation_RenameItems(self: *const T, pUnkItems: ?*IUnknown, pszNewName: ?[*:0]const u16) HRESULT {
                return @as(*const IFileOperation.VTable, @ptrCast(self.vtable)).RenameItems(@as(*const IFileOperation, @ptrCast(self)), pUnkItems, pszNewName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileOperation_MoveItem(self: *const T, psiItem: ?*IShellItem, psiDestinationFolder: ?*IShellItem, pszNewName: ?[*:0]const u16, pfopsItem: ?*IFileOperationProgressSink) HRESULT {
                return @as(*const IFileOperation.VTable, @ptrCast(self.vtable)).MoveItem(@as(*const IFileOperation, @ptrCast(self)), psiItem, psiDestinationFolder, pszNewName, pfopsItem);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileOperation_MoveItems(self: *const T, punkItems: ?*IUnknown, psiDestinationFolder: ?*IShellItem) HRESULT {
                return @as(*const IFileOperation.VTable, @ptrCast(self.vtable)).MoveItems(@as(*const IFileOperation, @ptrCast(self)), punkItems, psiDestinationFolder);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileOperation_CopyItem(self: *const T, psiItem: ?*IShellItem, psiDestinationFolder: ?*IShellItem, pszCopyName: ?[*:0]const u16, pfopsItem: ?*IFileOperationProgressSink) HRESULT {
                return @as(*const IFileOperation.VTable, @ptrCast(self.vtable)).CopyItem(@as(*const IFileOperation, @ptrCast(self)), psiItem, psiDestinationFolder, pszCopyName, pfopsItem);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileOperation_CopyItems(self: *const T, punkItems: ?*IUnknown, psiDestinationFolder: ?*IShellItem) HRESULT {
                return @as(*const IFileOperation.VTable, @ptrCast(self.vtable)).CopyItems(@as(*const IFileOperation, @ptrCast(self)), punkItems, psiDestinationFolder);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileOperation_DeleteItem(self: *const T, psiItem: ?*IShellItem, pfopsItem: ?*IFileOperationProgressSink) HRESULT {
                return @as(*const IFileOperation.VTable, @ptrCast(self.vtable)).DeleteItem(@as(*const IFileOperation, @ptrCast(self)), psiItem, pfopsItem);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileOperation_DeleteItems(self: *const T, punkItems: ?*IUnknown) HRESULT {
                return @as(*const IFileOperation.VTable, @ptrCast(self.vtable)).DeleteItems(@as(*const IFileOperation, @ptrCast(self)), punkItems);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileOperation_NewItem(self: *const T, psiDestinationFolder: ?*IShellItem, dwFileAttributes: u32, pszName: ?[*:0]const u16, pszTemplateName: ?[*:0]const u16, pfopsItem: ?*IFileOperationProgressSink) HRESULT {
                return @as(*const IFileOperation.VTable, @ptrCast(self.vtable)).NewItem(@as(*const IFileOperation, @ptrCast(self)), psiDestinationFolder, dwFileAttributes, pszName, pszTemplateName, pfopsItem);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileOperation_PerformOperations(self: *const T) HRESULT {
                return @as(*const IFileOperation.VTable, @ptrCast(self.vtable)).PerformOperations(@as(*const IFileOperation, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileOperation_GetAnyOperationsAborted(self: *const T, pfAnyOperationsAborted: ?*BOOL) HRESULT {
                return @as(*const IFileOperation.VTable, @ptrCast(self.vtable)).GetAnyOperationsAborted(@as(*const IFileOperation, @ptrCast(self)), pfAnyOperationsAborted);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const FILE_OPERATION_FLAGS2 = enum(i32) {
    NONE = 0,
    MERGEFOLDERSONCOLLISION = 1,
};
pub const FOF2_NONE = FILE_OPERATION_FLAGS2.NONE;
pub const FOF2_MERGEFOLDERSONCOLLISION = FILE_OPERATION_FLAGS2.MERGEFOLDERSONCOLLISION;

const IID_IFileOperation2_Value = Guid.initString("cd8f23c1-8f61-4916-909d-55bdd0918753");
pub const IID_IFileOperation2 = &IID_IFileOperation2_Value;
pub const IFileOperation2 = extern struct {
    pub const VTable = extern struct {
        base: IFileOperation.VTable,
        SetOperationFlags2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileOperation2,
                operationFlags2: FILE_OPERATION_FLAGS2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileOperation2,
                operationFlags2: FILE_OPERATION_FLAGS2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IFileOperation.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileOperation2_SetOperationFlags2(self: *const T, operationFlags2: FILE_OPERATION_FLAGS2) HRESULT {
                return @as(*const IFileOperation2.VTable, @ptrCast(self.vtable)).SetOperationFlags2(@as(*const IFileOperation2, @ptrCast(self)), operationFlags2);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IObjectProvider_Value = Guid.initString("a6087428-3be3-4d73-b308-7c04a540bf1a");
pub const IID_IObjectProvider = &IID_IObjectProvider_Value;
pub const IObjectProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IObjectProvider,
                guidObject: ?*const Guid,
                riid: ?*const Guid,
                ppvOut: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IObjectProvider,
                guidObject: ?*const Guid,
                riid: ?*const Guid,
                ppvOut: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IObjectProvider_QueryObject(self: *const T, guidObject: ?*const Guid, riid: ?*const Guid, ppvOut: ?*?*anyopaque) HRESULT {
                return @as(*const IObjectProvider.VTable, @ptrCast(self.vtable)).QueryObject(@as(*const IObjectProvider, @ptrCast(self)), guidObject, riid, ppvOut);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_INamespaceWalkCB_Value = Guid.initString("d92995f8-cf5e-4a76-bf59-ead39ea2b97e");
pub const IID_INamespaceWalkCB = &IID_INamespaceWalkCB_Value;
pub const INamespaceWalkCB = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        FoundItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INamespaceWalkCB,
                psf: ?*IShellFolder,
                pidl: ?*ITEMIDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INamespaceWalkCB,
                psf: ?*IShellFolder,
                pidl: ?*ITEMIDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnterFolder: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INamespaceWalkCB,
                psf: ?*IShellFolder,
                pidl: ?*ITEMIDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INamespaceWalkCB,
                psf: ?*IShellFolder,
                pidl: ?*ITEMIDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LeaveFolder: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INamespaceWalkCB,
                psf: ?*IShellFolder,
                pidl: ?*ITEMIDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INamespaceWalkCB,
                psf: ?*IShellFolder,
                pidl: ?*ITEMIDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InitializeProgressDialog: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INamespaceWalkCB,
                ppszTitle: ?*?PWSTR,
                ppszCancel: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INamespaceWalkCB,
                ppszTitle: ?*?PWSTR,
                ppszCancel: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INamespaceWalkCB_FoundItem(self: *const T, psf: ?*IShellFolder, pidl: ?*ITEMIDLIST) HRESULT {
                return @as(*const INamespaceWalkCB.VTable, @ptrCast(self.vtable)).FoundItem(@as(*const INamespaceWalkCB, @ptrCast(self)), psf, pidl);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INamespaceWalkCB_EnterFolder(self: *const T, psf: ?*IShellFolder, pidl: ?*ITEMIDLIST) HRESULT {
                return @as(*const INamespaceWalkCB.VTable, @ptrCast(self.vtable)).EnterFolder(@as(*const INamespaceWalkCB, @ptrCast(self)), psf, pidl);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INamespaceWalkCB_LeaveFolder(self: *const T, psf: ?*IShellFolder, pidl: ?*ITEMIDLIST) HRESULT {
                return @as(*const INamespaceWalkCB.VTable, @ptrCast(self.vtable)).LeaveFolder(@as(*const INamespaceWalkCB, @ptrCast(self)), psf, pidl);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INamespaceWalkCB_InitializeProgressDialog(self: *const T, ppszTitle: ?*?PWSTR, ppszCancel: ?*?PWSTR) HRESULT {
                return @as(*const INamespaceWalkCB.VTable, @ptrCast(self.vtable)).InitializeProgressDialog(@as(*const INamespaceWalkCB, @ptrCast(self)), ppszTitle, ppszCancel);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_INamespaceWalkCB2_Value = Guid.initString("7ac7492b-c38e-438a-87db-68737844ff70");
pub const IID_INamespaceWalkCB2 = &IID_INamespaceWalkCB2_Value;
pub const INamespaceWalkCB2 = extern struct {
    pub const VTable = extern struct {
        base: INamespaceWalkCB.VTable,
        WalkComplete: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INamespaceWalkCB2,
                hr: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INamespaceWalkCB2,
                hr: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace INamespaceWalkCB.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INamespaceWalkCB2_WalkComplete(self: *const T, hr: HRESULT) HRESULT {
                return @as(*const INamespaceWalkCB2.VTable, @ptrCast(self.vtable)).WalkComplete(@as(*const INamespaceWalkCB2, @ptrCast(self)), hr);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const NAMESPACEWALKFLAG = enum(i32) {
    DEFAULT = 0,
    NONE_IMPLIES_ALL = 1,
    ONE_IMPLIES_ALL = 2,
    DONT_TRAVERSE_LINKS = 4,
    DONT_ACCUMULATE_RESULT = 8,
    TRAVERSE_STREAM_JUNCTIONS = 16,
    FILESYSTEM_ONLY = 32,
    SHOW_PROGRESS = 64,
    FLAG_VIEWORDER = 128,
    IGNORE_AUTOPLAY_HIDA = 256,
    ASYNC = 512,
    DONT_RESOLVE_LINKS = 1024,
    ACCUMULATE_FOLDERS = 2048,
    DONT_SORT = 4096,
    USE_TRANSFER_MEDIUM = 8192,
    DONT_TRAVERSE_STREAM_JUNCTIONS = 16384,
    ANY_IMPLIES_ALL = 32768,
};
pub const NSWF_DEFAULT = NAMESPACEWALKFLAG.DEFAULT;
pub const NSWF_NONE_IMPLIES_ALL = NAMESPACEWALKFLAG.NONE_IMPLIES_ALL;
pub const NSWF_ONE_IMPLIES_ALL = NAMESPACEWALKFLAG.ONE_IMPLIES_ALL;
pub const NSWF_DONT_TRAVERSE_LINKS = NAMESPACEWALKFLAG.DONT_TRAVERSE_LINKS;
pub const NSWF_DONT_ACCUMULATE_RESULT = NAMESPACEWALKFLAG.DONT_ACCUMULATE_RESULT;
pub const NSWF_TRAVERSE_STREAM_JUNCTIONS = NAMESPACEWALKFLAG.TRAVERSE_STREAM_JUNCTIONS;
pub const NSWF_FILESYSTEM_ONLY = NAMESPACEWALKFLAG.FILESYSTEM_ONLY;
pub const NSWF_SHOW_PROGRESS = NAMESPACEWALKFLAG.SHOW_PROGRESS;
pub const NSWF_FLAG_VIEWORDER = NAMESPACEWALKFLAG.FLAG_VIEWORDER;
pub const NSWF_IGNORE_AUTOPLAY_HIDA = NAMESPACEWALKFLAG.IGNORE_AUTOPLAY_HIDA;
pub const NSWF_ASYNC = NAMESPACEWALKFLAG.ASYNC;
pub const NSWF_DONT_RESOLVE_LINKS = NAMESPACEWALKFLAG.DONT_RESOLVE_LINKS;
pub const NSWF_ACCUMULATE_FOLDERS = NAMESPACEWALKFLAG.ACCUMULATE_FOLDERS;
pub const NSWF_DONT_SORT = NAMESPACEWALKFLAG.DONT_SORT;
pub const NSWF_USE_TRANSFER_MEDIUM = NAMESPACEWALKFLAG.USE_TRANSFER_MEDIUM;
pub const NSWF_DONT_TRAVERSE_STREAM_JUNCTIONS = NAMESPACEWALKFLAG.DONT_TRAVERSE_STREAM_JUNCTIONS;
pub const NSWF_ANY_IMPLIES_ALL = NAMESPACEWALKFLAG.ANY_IMPLIES_ALL;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_INamespaceWalk_Value = Guid.initString("57ced8a7-3f4a-432c-9350-30f24483f74f");
pub const IID_INamespaceWalk = &IID_INamespaceWalk_Value;
pub const INamespaceWalk = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Walk: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INamespaceWalk,
                punkToWalk: ?*IUnknown,
                dwFlags: u32,
                cDepth: i32,
                pnswcb: ?*INamespaceWalkCB,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INamespaceWalk,
                punkToWalk: ?*IUnknown,
                dwFlags: u32,
                cDepth: i32,
                pnswcb: ?*INamespaceWalkCB,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIDArrayResult: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INamespaceWalk,
                pcItems: ?*u32,
                prgpidl: [*]?*?*ITEMIDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INamespaceWalk,
                pcItems: ?*u32,
                prgpidl: [*]?*?*ITEMIDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INamespaceWalk_Walk(self: *const T, punkToWalk: ?*IUnknown, dwFlags: u32, cDepth: i32, pnswcb: ?*INamespaceWalkCB) HRESULT {
                return @as(*const INamespaceWalk.VTable, @ptrCast(self.vtable)).Walk(@as(*const INamespaceWalk, @ptrCast(self)), punkToWalk, dwFlags, cDepth, pnswcb);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INamespaceWalk_GetIDArrayResult(self: *const T, pcItems: ?*u32, prgpidl: [*]?*?*ITEMIDLIST) HRESULT {
                return @as(*const INamespaceWalk.VTable, @ptrCast(self.vtable)).GetIDArrayResult(@as(*const INamespaceWalk, @ptrCast(self)), pcItems, prgpidl);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const BANDSITEINFO = extern struct {
    dwMask: u32,
    dwState: u32,
    dwStyle: u32,
};

pub const BANDSITECID = enum(i32) {
    ADDED = 0,
    REMOVED = 1,
};
pub const BSID_BANDADDED = BANDSITECID.ADDED;
pub const BSID_BANDREMOVED = BANDSITECID.REMOVED;

// TODO: this type is limited to platform 'windows5.0'
const IID_IBandSite_Value = Guid.initString("4cf504b0-de96-11d0-8b3f-00a0c911e8e5");
pub const IID_IBandSite = &IID_IBandSite_Value;
pub const IBandSite = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddBand: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBandSite,
                punk: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBandSite,
                punk: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumBands: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBandSite,
                uBand: u32,
                pdwBandID: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBandSite,
                uBand: u32,
                pdwBandID: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryBand: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBandSite,
                dwBandID: u32,
                ppstb: ?*?*IDeskBand,
                pdwState: ?*u32,
                pszName: ?[*:0]u16,
                cchName: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBandSite,
                dwBandID: u32,
                ppstb: ?*?*IDeskBand,
                pdwState: ?*u32,
                pszName: ?[*:0]u16,
                cchName: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetBandState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBandSite,
                dwBandID: u32,
                dwMask: u32,
                dwState: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBandSite,
                dwBandID: u32,
                dwMask: u32,
                dwState: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveBand: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBandSite,
                dwBandID: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBandSite,
                dwBandID: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBandObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBandSite,
                dwBandID: u32,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBandSite,
                dwBandID: u32,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetBandSiteInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBandSite,
                pbsinfo: ?*const BANDSITEINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBandSite,
                pbsinfo: ?*const BANDSITEINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBandSiteInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBandSite,
                pbsinfo: ?*BANDSITEINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBandSite,
                pbsinfo: ?*BANDSITEINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBandSite_AddBand(self: *const T, punk: ?*IUnknown) HRESULT {
                return @as(*const IBandSite.VTable, @ptrCast(self.vtable)).AddBand(@as(*const IBandSite, @ptrCast(self)), punk);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBandSite_EnumBands(self: *const T, uBand: u32, pdwBandID: ?*u32) HRESULT {
                return @as(*const IBandSite.VTable, @ptrCast(self.vtable)).EnumBands(@as(*const IBandSite, @ptrCast(self)), uBand, pdwBandID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBandSite_QueryBand(self: *const T, dwBandID: u32, ppstb: ?*?*IDeskBand, pdwState: ?*u32, pszName: ?[*:0]u16, cchName: i32) HRESULT {
                return @as(*const IBandSite.VTable, @ptrCast(self.vtable)).QueryBand(@as(*const IBandSite, @ptrCast(self)), dwBandID, ppstb, pdwState, pszName, cchName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBandSite_SetBandState(self: *const T, dwBandID: u32, dwMask: u32, dwState: u32) HRESULT {
                return @as(*const IBandSite.VTable, @ptrCast(self.vtable)).SetBandState(@as(*const IBandSite, @ptrCast(self)), dwBandID, dwMask, dwState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBandSite_RemoveBand(self: *const T, dwBandID: u32) HRESULT {
                return @as(*const IBandSite.VTable, @ptrCast(self.vtable)).RemoveBand(@as(*const IBandSite, @ptrCast(self)), dwBandID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBandSite_GetBandObject(self: *const T, dwBandID: u32, riid: ?*const Guid, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const IBandSite.VTable, @ptrCast(self.vtable)).GetBandObject(@as(*const IBandSite, @ptrCast(self)), dwBandID, riid, ppv);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBandSite_SetBandSiteInfo(self: *const T, pbsinfo: ?*const BANDSITEINFO) HRESULT {
                return @as(*const IBandSite.VTable, @ptrCast(self.vtable)).SetBandSiteInfo(@as(*const IBandSite, @ptrCast(self)), pbsinfo);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBandSite_GetBandSiteInfo(self: *const T, pbsinfo: ?*BANDSITEINFO) HRESULT {
                return @as(*const IBandSite.VTable, @ptrCast(self.vtable)).GetBandSiteInfo(@as(*const IBandSite, @ptrCast(self)), pbsinfo);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IModalWindow_Value = Guid.initString("b4db1657-70d7-485e-8e3e-6fcb5a5c1802");
pub const IID_IModalWindow = &IID_IModalWindow_Value;
pub const IModalWindow = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Show: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IModalWindow,
                hwndOwner: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IModalWindow,
                hwndOwner: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IModalWindow_Show(self: *const T, hwndOwner: ?HWND) HRESULT {
                return @as(*const IModalWindow.VTable, @ptrCast(self.vtable)).Show(@as(*const IModalWindow, @ptrCast(self)), hwndOwner);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IContextMenuSite_Value = Guid.initString("0811aebe-0b87-4c54-9e72-548cf649016b");
pub const IID_IContextMenuSite = &IID_IContextMenuSite_Value;
pub const IContextMenuSite = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        DoContextMenuPopup: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IContextMenuSite,
                punkContextMenu: ?*IUnknown,
                fFlags: u32,
                pt: POINT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IContextMenuSite,
                punkContextMenu: ?*IUnknown,
                fFlags: u32,
                pt: POINT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IContextMenuSite_DoContextMenuPopup(self: *const T, punkContextMenu: ?*IUnknown, fFlags: u32, pt: POINT) HRESULT {
                return @as(*const IContextMenuSite.VTable, @ptrCast(self.vtable)).DoContextMenuPopup(@as(*const IContextMenuSite, @ptrCast(self)), punkContextMenu, fFlags, pt);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MENUBANDHANDLERCID = enum(i32) {
    T = 0,
};
pub const MBHANDCID_PIDLSELECT = MENUBANDHANDLERCID.T;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMenuBand_Value = Guid.initString("568804cd-cbd7-11d0-9816-00c04fd91972");
pub const IID_IMenuBand = &IID_IMenuBand_Value;
pub const IMenuBand = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IsMenuMessage: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMenuBand,
                pmsg: ?*MSG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMenuBand,
                pmsg: ?*MSG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TranslateMenuMessage: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMenuBand,
                pmsg: ?*MSG,
                plRet: ?*LRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMenuBand,
                pmsg: ?*MSG,
                plRet: ?*LRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMenuBand_IsMenuMessage(self: *const T, pmsg: ?*MSG) HRESULT {
                return @as(*const IMenuBand.VTable, @ptrCast(self.vtable)).IsMenuMessage(@as(*const IMenuBand, @ptrCast(self)), pmsg);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMenuBand_TranslateMenuMessage(self: *const T, pmsg: ?*MSG, plRet: ?*LRESULT) HRESULT {
                return @as(*const IMenuBand.VTable, @ptrCast(self.vtable)).TranslateMenuMessage(@as(*const IMenuBand, @ptrCast(self)), pmsg, plRet);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IRegTreeItem_Value = Guid.initString("a9521922-0812-4d44-9ec3-7fd38c726f3d");
pub const IID_IRegTreeItem = &IID_IRegTreeItem_Value;
pub const IRegTreeItem = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCheckState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRegTreeItem,
                pbCheck: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRegTreeItem,
                pbCheck: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCheckState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRegTreeItem,
                bCheck: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRegTreeItem,
                bCheck: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRegTreeItem_GetCheckState(self: *const T, pbCheck: ?*BOOL) HRESULT {
                return @as(*const IRegTreeItem.VTable, @ptrCast(self.vtable)).GetCheckState(@as(*const IRegTreeItem, @ptrCast(self)), pbCheck);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRegTreeItem_SetCheckState(self: *const T, bCheck: BOOL) HRESULT {
                return @as(*const IRegTreeItem.VTable, @ptrCast(self.vtable)).SetCheckState(@as(*const IRegTreeItem, @ptrCast(self)), bCheck);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IDeskBar_Value = Guid.initString("eb0fe173-1a3a-11d0-89b3-00a0c90a90ac");
pub const IID_IDeskBar = &IID_IDeskBar_Value;
pub const IDeskBar = extern struct {
    pub const VTable = extern struct {
        base: IOleWindow.VTable,
        SetClient: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDeskBar,
                punkClient: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDeskBar,
                punkClient: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetClient: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDeskBar,
                ppunkClient: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDeskBar,
                ppunkClient: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnPosRectChangeDB: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDeskBar,
                prc: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDeskBar,
                prc: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IOleWindow.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDeskBar_SetClient(self: *const T, punkClient: ?*IUnknown) HRESULT {
                return @as(*const IDeskBar.VTable, @ptrCast(self.vtable)).SetClient(@as(*const IDeskBar, @ptrCast(self)), punkClient);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDeskBar_GetClient(self: *const T, ppunkClient: ?*?*IUnknown) HRESULT {
                return @as(*const IDeskBar.VTable, @ptrCast(self.vtable)).GetClient(@as(*const IDeskBar, @ptrCast(self)), ppunkClient);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDeskBar_OnPosRectChangeDB(self: *const T, prc: ?*RECT) HRESULT {
                return @as(*const IDeskBar.VTable, @ptrCast(self.vtable)).OnPosRectChangeDB(@as(*const IDeskBar, @ptrCast(self)), prc);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MENUPOPUPSELECT = enum(i32) {
    EXECUTE = 0,
    FULLCANCEL = 1,
    CANCELLEVEL = 2,
    SELECTLEFT = 3,
    SELECTRIGHT = 4,
    CHILDTRACKING = 5,
};
pub const MPOS_EXECUTE = MENUPOPUPSELECT.EXECUTE;
pub const MPOS_FULLCANCEL = MENUPOPUPSELECT.FULLCANCEL;
pub const MPOS_CANCELLEVEL = MENUPOPUPSELECT.CANCELLEVEL;
pub const MPOS_SELECTLEFT = MENUPOPUPSELECT.SELECTLEFT;
pub const MPOS_SELECTRIGHT = MENUPOPUPSELECT.SELECTRIGHT;
pub const MPOS_CHILDTRACKING = MENUPOPUPSELECT.CHILDTRACKING;

pub const MENUPOPUPPOPUPFLAGS = enum(i32) {
    SETFOCUS = 1,
    INITIALSELECT = 2,
    NOANIMATE = 4,
    KEYBOARD = 16,
    REPOSITION = 32,
    FORCEZORDER = 64,
    FINALSELECT = 128,
    TOP = 536870912,
    LEFT = 1073741824,
    RIGHT = 1610612736,
    BOTTOM = -2147483648,
    POS_MASK = -536870912,
    ALIGN_LEFT = 33554432,
    ALIGN_RIGHT = 67108864,
};
pub const MPPF_SETFOCUS = MENUPOPUPPOPUPFLAGS.SETFOCUS;
pub const MPPF_INITIALSELECT = MENUPOPUPPOPUPFLAGS.INITIALSELECT;
pub const MPPF_NOANIMATE = MENUPOPUPPOPUPFLAGS.NOANIMATE;
pub const MPPF_KEYBOARD = MENUPOPUPPOPUPFLAGS.KEYBOARD;
pub const MPPF_REPOSITION = MENUPOPUPPOPUPFLAGS.REPOSITION;
pub const MPPF_FORCEZORDER = MENUPOPUPPOPUPFLAGS.FORCEZORDER;
pub const MPPF_FINALSELECT = MENUPOPUPPOPUPFLAGS.FINALSELECT;
pub const MPPF_TOP = MENUPOPUPPOPUPFLAGS.TOP;
pub const MPPF_LEFT = MENUPOPUPPOPUPFLAGS.LEFT;
pub const MPPF_RIGHT = MENUPOPUPPOPUPFLAGS.RIGHT;
pub const MPPF_BOTTOM = MENUPOPUPPOPUPFLAGS.BOTTOM;
pub const MPPF_POS_MASK = MENUPOPUPPOPUPFLAGS.POS_MASK;
pub const MPPF_ALIGN_LEFT = MENUPOPUPPOPUPFLAGS.ALIGN_LEFT;
pub const MPPF_ALIGN_RIGHT = MENUPOPUPPOPUPFLAGS.ALIGN_RIGHT;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMenuPopup_Value = Guid.initString("d1e7afeb-6a2e-11d0-8c78-00c04fd918b4");
pub const IID_IMenuPopup = &IID_IMenuPopup_Value;
pub const IMenuPopup = extern struct {
    pub const VTable = extern struct {
        base: IDeskBar.VTable,
        Popup: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMenuPopup,
                ppt: ?*POINTL,
                prcExclude: ?*RECTL,
                dwFlags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMenuPopup,
                ppt: ?*POINTL,
                prcExclude: ?*RECTL,
                dwFlags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnSelect: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMenuPopup,
                dwSelectType: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMenuPopup,
                dwSelectType: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSubMenu: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMenuPopup,
                pmp: ?*IMenuPopup,
                fSet: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMenuPopup,
                pmp: ?*IMenuPopup,
                fSet: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDeskBar.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMenuPopup_Popup(self: *const T, ppt: ?*POINTL, prcExclude: ?*RECTL, dwFlags: i32) HRESULT {
                return @as(*const IMenuPopup.VTable, @ptrCast(self.vtable)).Popup(@as(*const IMenuPopup, @ptrCast(self)), ppt, prcExclude, dwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMenuPopup_OnSelect(self: *const T, dwSelectType: u32) HRESULT {
                return @as(*const IMenuPopup.VTable, @ptrCast(self.vtable)).OnSelect(@as(*const IMenuPopup, @ptrCast(self)), dwSelectType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMenuPopup_SetSubMenu(self: *const T, pmp: ?*IMenuPopup, fSet: BOOL) HRESULT {
                return @as(*const IMenuPopup.VTable, @ptrCast(self.vtable)).SetSubMenu(@as(*const IMenuPopup, @ptrCast(self)), pmp, fSet);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const FILE_USAGE_TYPE = enum(i32) {
    PLAYING = 0,
    EDITING = 1,
    GENERIC = 2,
};
pub const FUT_PLAYING = FILE_USAGE_TYPE.PLAYING;
pub const FUT_EDITING = FILE_USAGE_TYPE.EDITING;
pub const FUT_GENERIC = FILE_USAGE_TYPE.GENERIC;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IFileIsInUse_Value = Guid.initString("64a1cbf0-3a1a-4461-9158-376969693950");
pub const IID_IFileIsInUse = &IID_IFileIsInUse_Value;
pub const IFileIsInUse = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetAppName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileIsInUse,
                ppszName: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileIsInUse,
                ppszName: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetUsage: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileIsInUse,
                pfut: ?*FILE_USAGE_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileIsInUse,
                pfut: ?*FILE_USAGE_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCapabilities: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileIsInUse,
                pdwCapFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileIsInUse,
                pdwCapFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSwitchToHWND: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileIsInUse,
                phwnd: ?*?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileIsInUse,
                phwnd: ?*?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CloseFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileIsInUse,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileIsInUse,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileIsInUse_GetAppName(self: *const T, ppszName: ?*?PWSTR) HRESULT {
                return @as(*const IFileIsInUse.VTable, @ptrCast(self.vtable)).GetAppName(@as(*const IFileIsInUse, @ptrCast(self)), ppszName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileIsInUse_GetUsage(self: *const T, pfut: ?*FILE_USAGE_TYPE) HRESULT {
                return @as(*const IFileIsInUse.VTable, @ptrCast(self.vtable)).GetUsage(@as(*const IFileIsInUse, @ptrCast(self)), pfut);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileIsInUse_GetCapabilities(self: *const T, pdwCapFlags: ?*u32) HRESULT {
                return @as(*const IFileIsInUse.VTable, @ptrCast(self.vtable)).GetCapabilities(@as(*const IFileIsInUse, @ptrCast(self)), pdwCapFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileIsInUse_GetSwitchToHWND(self: *const T, phwnd: ?*?HWND) HRESULT {
                return @as(*const IFileIsInUse.VTable, @ptrCast(self.vtable)).GetSwitchToHWND(@as(*const IFileIsInUse, @ptrCast(self)), phwnd);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileIsInUse_CloseFile(self: *const T) HRESULT {
                return @as(*const IFileIsInUse.VTable, @ptrCast(self.vtable)).CloseFile(@as(*const IFileIsInUse, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const FDE_OVERWRITE_RESPONSE = enum(i32) {
    DEFAULT = 0,
    ACCEPT = 1,
    REFUSE = 2,
};
pub const FDEOR_DEFAULT = FDE_OVERWRITE_RESPONSE.DEFAULT;
pub const FDEOR_ACCEPT = FDE_OVERWRITE_RESPONSE.ACCEPT;
pub const FDEOR_REFUSE = FDE_OVERWRITE_RESPONSE.REFUSE;

pub const FDE_SHAREVIOLATION_RESPONSE = enum(i32) {
    DEFAULT = 0,
    ACCEPT = 1,
    REFUSE = 2,
};
pub const FDESVR_DEFAULT = FDE_SHAREVIOLATION_RESPONSE.DEFAULT;
pub const FDESVR_ACCEPT = FDE_SHAREVIOLATION_RESPONSE.ACCEPT;
pub const FDESVR_REFUSE = FDE_SHAREVIOLATION_RESPONSE.REFUSE;

pub const FDAP = enum(i32) {
    BOTTOM = 0,
    TOP = 1,
};
pub const FDAP_BOTTOM = FDAP.BOTTOM;
pub const FDAP_TOP = FDAP.TOP;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IFileDialogEvents_Value = Guid.initString("973510db-7d7f-452b-8975-74a85828d354");
pub const IID_IFileDialogEvents = &IID_IFileDialogEvents_Value;
pub const IFileDialogEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnFileOk: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileDialogEvents,
                pfd: ?*IFileDialog,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileDialogEvents,
                pfd: ?*IFileDialog,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnFolderChanging: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileDialogEvents,
                pfd: ?*IFileDialog,
                psiFolder: ?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileDialogEvents,
                pfd: ?*IFileDialog,
                psiFolder: ?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnFolderChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileDialogEvents,
                pfd: ?*IFileDialog,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileDialogEvents,
                pfd: ?*IFileDialog,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnSelectionChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileDialogEvents,
                pfd: ?*IFileDialog,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileDialogEvents,
                pfd: ?*IFileDialog,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnShareViolation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileDialogEvents,
                pfd: ?*IFileDialog,
                psi: ?*IShellItem,
                pResponse: ?*FDE_SHAREVIOLATION_RESPONSE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileDialogEvents,
                pfd: ?*IFileDialog,
                psi: ?*IShellItem,
                pResponse: ?*FDE_SHAREVIOLATION_RESPONSE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnTypeChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileDialogEvents,
                pfd: ?*IFileDialog,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileDialogEvents,
                pfd: ?*IFileDialog,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnOverwrite: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileDialogEvents,
                pfd: ?*IFileDialog,
                psi: ?*IShellItem,
                pResponse: ?*FDE_OVERWRITE_RESPONSE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileDialogEvents,
                pfd: ?*IFileDialog,
                psi: ?*IShellItem,
                pResponse: ?*FDE_OVERWRITE_RESPONSE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileDialogEvents_OnFileOk(self: *const T, pfd: ?*IFileDialog) HRESULT {
                return @as(*const IFileDialogEvents.VTable, @ptrCast(self.vtable)).OnFileOk(@as(*const IFileDialogEvents, @ptrCast(self)), pfd);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileDialogEvents_OnFolderChanging(self: *const T, pfd: ?*IFileDialog, psiFolder: ?*IShellItem) HRESULT {
                return @as(*const IFileDialogEvents.VTable, @ptrCast(self.vtable)).OnFolderChanging(@as(*const IFileDialogEvents, @ptrCast(self)), pfd, psiFolder);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileDialogEvents_OnFolderChange(self: *const T, pfd: ?*IFileDialog) HRESULT {
                return @as(*const IFileDialogEvents.VTable, @ptrCast(self.vtable)).OnFolderChange(@as(*const IFileDialogEvents, @ptrCast(self)), pfd);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileDialogEvents_OnSelectionChange(self: *const T, pfd: ?*IFileDialog) HRESULT {
                return @as(*const IFileDialogEvents.VTable, @ptrCast(self.vtable)).OnSelectionChange(@as(*const IFileDialogEvents, @ptrCast(self)), pfd);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileDialogEvents_OnShareViolation(self: *const T, pfd: ?*IFileDialog, psi: ?*IShellItem, pResponse: ?*FDE_SHAREVIOLATION_RESPONSE) HRESULT {
                return @as(*const IFileDialogEvents.VTable, @ptrCast(self.vtable)).OnShareViolation(@as(*const IFileDialogEvents, @ptrCast(self)), pfd, psi, pResponse);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileDialogEvents_OnTypeChange(self: *const T, pfd: ?*IFileDialog) HRESULT {
                return @as(*const IFileDialogEvents.VTable, @ptrCast(self.vtable)).OnTypeChange(@as(*const IFileDialogEvents, @ptrCast(self)), pfd);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileDialogEvents_OnOverwrite(self: *const T, pfd: ?*IFileDialog, psi: ?*IShellItem, pResponse: ?*FDE_OVERWRITE_RESPONSE) HRESULT {
                return @as(*const IFileDialogEvents.VTable, @ptrCast(self.vtable)).OnOverwrite(@as(*const IFileDialogEvents, @ptrCast(self)), pfd, psi, pResponse);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const _FILEOPENDIALOGOPTIONS = enum(i32) {
    OVERWRITEPROMPT = 2,
    STRICTFILETYPES = 4,
    NOCHANGEDIR = 8,
    PICKFOLDERS = 32,
    FORCEFILESYSTEM = 64,
    ALLNONSTORAGEITEMS = 128,
    NOVALIDATE = 256,
    ALLOWMULTISELECT = 512,
    PATHMUSTEXIST = 2048,
    FILEMUSTEXIST = 4096,
    CREATEPROMPT = 8192,
    SHAREAWARE = 16384,
    NOREADONLYRETURN = 32768,
    NOTESTFILECREATE = 65536,
    HIDEMRUPLACES = 131072,
    HIDEPINNEDPLACES = 262144,
    NODEREFERENCELINKS = 1048576,
    OKBUTTONNEEDSINTERACTION = 2097152,
    DONTADDTORECENT = 33554432,
    FORCESHOWHIDDEN = 268435456,
    DEFAULTNOMINIMODE = 536870912,
    FORCEPREVIEWPANEON = 1073741824,
    SUPPORTSTREAMABLEITEMS = -2147483648,
};
pub const FOS_OVERWRITEPROMPT = _FILEOPENDIALOGOPTIONS.OVERWRITEPROMPT;
pub const FOS_STRICTFILETYPES = _FILEOPENDIALOGOPTIONS.STRICTFILETYPES;
pub const FOS_NOCHANGEDIR = _FILEOPENDIALOGOPTIONS.NOCHANGEDIR;
pub const FOS_PICKFOLDERS = _FILEOPENDIALOGOPTIONS.PICKFOLDERS;
pub const FOS_FORCEFILESYSTEM = _FILEOPENDIALOGOPTIONS.FORCEFILESYSTEM;
pub const FOS_ALLNONSTORAGEITEMS = _FILEOPENDIALOGOPTIONS.ALLNONSTORAGEITEMS;
pub const FOS_NOVALIDATE = _FILEOPENDIALOGOPTIONS.NOVALIDATE;
pub const FOS_ALLOWMULTISELECT = _FILEOPENDIALOGOPTIONS.ALLOWMULTISELECT;
pub const FOS_PATHMUSTEXIST = _FILEOPENDIALOGOPTIONS.PATHMUSTEXIST;
pub const FOS_FILEMUSTEXIST = _FILEOPENDIALOGOPTIONS.FILEMUSTEXIST;
pub const FOS_CREATEPROMPT = _FILEOPENDIALOGOPTIONS.CREATEPROMPT;
pub const FOS_SHAREAWARE = _FILEOPENDIALOGOPTIONS.SHAREAWARE;
pub const FOS_NOREADONLYRETURN = _FILEOPENDIALOGOPTIONS.NOREADONLYRETURN;
pub const FOS_NOTESTFILECREATE = _FILEOPENDIALOGOPTIONS.NOTESTFILECREATE;
pub const FOS_HIDEMRUPLACES = _FILEOPENDIALOGOPTIONS.HIDEMRUPLACES;
pub const FOS_HIDEPINNEDPLACES = _FILEOPENDIALOGOPTIONS.HIDEPINNEDPLACES;
pub const FOS_NODEREFERENCELINKS = _FILEOPENDIALOGOPTIONS.NODEREFERENCELINKS;
pub const FOS_OKBUTTONNEEDSINTERACTION = _FILEOPENDIALOGOPTIONS.OKBUTTONNEEDSINTERACTION;
pub const FOS_DONTADDTORECENT = _FILEOPENDIALOGOPTIONS.DONTADDTORECENT;
pub const FOS_FORCESHOWHIDDEN = _FILEOPENDIALOGOPTIONS.FORCESHOWHIDDEN;
pub const FOS_DEFAULTNOMINIMODE = _FILEOPENDIALOGOPTIONS.DEFAULTNOMINIMODE;
pub const FOS_FORCEPREVIEWPANEON = _FILEOPENDIALOGOPTIONS.FORCEPREVIEWPANEON;
pub const FOS_SUPPORTSTREAMABLEITEMS = _FILEOPENDIALOGOPTIONS.SUPPORTSTREAMABLEITEMS;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IFileDialog_Value = Guid.initString("42f85136-db7e-439c-85f1-e4075d135fc8");
pub const IID_IFileDialog = &IID_IFileDialog_Value;
pub const IFileDialog = extern struct {
    pub const VTable = extern struct {
        base: IModalWindow.VTable,
        SetFileTypes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileDialog,
                cFileTypes: u32,
                rgFilterSpec: [*]const COMDLG_FILTERSPEC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileDialog,
                cFileTypes: u32,
                rgFilterSpec: [*]const COMDLG_FILTERSPEC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFileTypeIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileDialog,
                iFileType: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileDialog,
                iFileType: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFileTypeIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileDialog,
                piFileType: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileDialog,
                piFileType: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Advise: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileDialog,
                pfde: ?*IFileDialogEvents,
                pdwCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileDialog,
                pfde: ?*IFileDialogEvents,
                pdwCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Unadvise: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileDialog,
                dwCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileDialog,
                dwCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileDialog,
                fos: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileDialog,
                fos: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileDialog,
                pfos: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileDialog,
                pfos: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDefaultFolder: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileDialog,
                psi: ?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileDialog,
                psi: ?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFolder: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileDialog,
                psi: ?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileDialog,
                psi: ?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFolder: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileDialog,
                ppsi: ?*?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileDialog,
                ppsi: ?*?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentSelection: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileDialog,
                ppsi: ?*?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileDialog,
                ppsi: ?*?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFileName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileDialog,
                pszName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileDialog,
                pszName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFileName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileDialog,
                pszName: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileDialog,
                pszName: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTitle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileDialog,
                pszTitle: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileDialog,
                pszTitle: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOkButtonLabel: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileDialog,
                pszText: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileDialog,
                pszText: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFileNameLabel: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileDialog,
                pszLabel: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileDialog,
                pszLabel: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetResult: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileDialog,
                ppsi: ?*?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileDialog,
                ppsi: ?*?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddPlace: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileDialog,
                psi: ?*IShellItem,
                fdap: FDAP,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileDialog,
                psi: ?*IShellItem,
                fdap: FDAP,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDefaultExtension: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileDialog,
                pszDefaultExtension: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileDialog,
                pszDefaultExtension: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Close: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileDialog,
                hr: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileDialog,
                hr: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetClientGuid: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileDialog,
                guid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileDialog,
                guid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ClearClientData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileDialog,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileDialog,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFilter: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileDialog,
                pFilter: ?*IShellItemFilter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileDialog,
                pFilter: ?*IShellItemFilter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IModalWindow.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileDialog_SetFileTypes(self: *const T, cFileTypes: u32, rgFilterSpec: [*]const COMDLG_FILTERSPEC) HRESULT {
                return @as(*const IFileDialog.VTable, @ptrCast(self.vtable)).SetFileTypes(@as(*const IFileDialog, @ptrCast(self)), cFileTypes, rgFilterSpec);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileDialog_SetFileTypeIndex(self: *const T, iFileType: u32) HRESULT {
                return @as(*const IFileDialog.VTable, @ptrCast(self.vtable)).SetFileTypeIndex(@as(*const IFileDialog, @ptrCast(self)), iFileType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileDialog_GetFileTypeIndex(self: *const T, piFileType: ?*u32) HRESULT {
                return @as(*const IFileDialog.VTable, @ptrCast(self.vtable)).GetFileTypeIndex(@as(*const IFileDialog, @ptrCast(self)), piFileType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileDialog_Advise(self: *const T, pfde: ?*IFileDialogEvents, pdwCookie: ?*u32) HRESULT {
                return @as(*const IFileDialog.VTable, @ptrCast(self.vtable)).Advise(@as(*const IFileDialog, @ptrCast(self)), pfde, pdwCookie);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileDialog_Unadvise(self: *const T, dwCookie: u32) HRESULT {
                return @as(*const IFileDialog.VTable, @ptrCast(self.vtable)).Unadvise(@as(*const IFileDialog, @ptrCast(self)), dwCookie);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileDialog_SetOptions(self: *const T, fos: u32) HRESULT {
                return @as(*const IFileDialog.VTable, @ptrCast(self.vtable)).SetOptions(@as(*const IFileDialog, @ptrCast(self)), fos);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileDialog_GetOptions(self: *const T, pfos: ?*u32) HRESULT {
                return @as(*const IFileDialog.VTable, @ptrCast(self.vtable)).GetOptions(@as(*const IFileDialog, @ptrCast(self)), pfos);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileDialog_SetDefaultFolder(self: *const T, psi: ?*IShellItem) HRESULT {
                return @as(*const IFileDialog.VTable, @ptrCast(self.vtable)).SetDefaultFolder(@as(*const IFileDialog, @ptrCast(self)), psi);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileDialog_SetFolder(self: *const T, psi: ?*IShellItem) HRESULT {
                return @as(*const IFileDialog.VTable, @ptrCast(self.vtable)).SetFolder(@as(*const IFileDialog, @ptrCast(self)), psi);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileDialog_GetFolder(self: *const T, ppsi: ?*?*IShellItem) HRESULT {
                return @as(*const IFileDialog.VTable, @ptrCast(self.vtable)).GetFolder(@as(*const IFileDialog, @ptrCast(self)), ppsi);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileDialog_GetCurrentSelection(self: *const T, ppsi: ?*?*IShellItem) HRESULT {
                return @as(*const IFileDialog.VTable, @ptrCast(self.vtable)).GetCurrentSelection(@as(*const IFileDialog, @ptrCast(self)), ppsi);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileDialog_SetFileName(self: *const T, pszName: ?[*:0]const u16) HRESULT {
                return @as(*const IFileDialog.VTable, @ptrCast(self.vtable)).SetFileName(@as(*const IFileDialog, @ptrCast(self)), pszName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileDialog_GetFileName(self: *const T, pszName: ?*?PWSTR) HRESULT {
                return @as(*const IFileDialog.VTable, @ptrCast(self.vtable)).GetFileName(@as(*const IFileDialog, @ptrCast(self)), pszName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileDialog_SetTitle(self: *const T, pszTitle: ?[*:0]const u16) HRESULT {
                return @as(*const IFileDialog.VTable, @ptrCast(self.vtable)).SetTitle(@as(*const IFileDialog, @ptrCast(self)), pszTitle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileDialog_SetOkButtonLabel(self: *const T, pszText: ?[*:0]const u16) HRESULT {
                return @as(*const IFileDialog.VTable, @ptrCast(self.vtable)).SetOkButtonLabel(@as(*const IFileDialog, @ptrCast(self)), pszText);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileDialog_SetFileNameLabel(self: *const T, pszLabel: ?[*:0]const u16) HRESULT {
                return @as(*const IFileDialog.VTable, @ptrCast(self.vtable)).SetFileNameLabel(@as(*const IFileDialog, @ptrCast(self)), pszLabel);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileDialog_GetResult(self: *const T, ppsi: ?*?*IShellItem) HRESULT {
                return @as(*const IFileDialog.VTable, @ptrCast(self.vtable)).GetResult(@as(*const IFileDialog, @ptrCast(self)), ppsi);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileDialog_AddPlace(self: *const T, psi: ?*IShellItem, fdap: FDAP) HRESULT {
                return @as(*const IFileDialog.VTable, @ptrCast(self.vtable)).AddPlace(@as(*const IFileDialog, @ptrCast(self)), psi, fdap);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileDialog_SetDefaultExtension(self: *const T, pszDefaultExtension: ?[*:0]const u16) HRESULT {
                return @as(*const IFileDialog.VTable, @ptrCast(self.vtable)).SetDefaultExtension(@as(*const IFileDialog, @ptrCast(self)), pszDefaultExtension);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileDialog_Close(self: *const T, hr: HRESULT) HRESULT {
                return @as(*const IFileDialog.VTable, @ptrCast(self.vtable)).Close(@as(*const IFileDialog, @ptrCast(self)), hr);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileDialog_SetClientGuid(self: *const T, guid: ?*const Guid) HRESULT {
                return @as(*const IFileDialog.VTable, @ptrCast(self.vtable)).SetClientGuid(@as(*const IFileDialog, @ptrCast(self)), guid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileDialog_ClearClientData(self: *const T) HRESULT {
                return @as(*const IFileDialog.VTable, @ptrCast(self.vtable)).ClearClientData(@as(*const IFileDialog, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileDialog_SetFilter(self: *const T, pFilter: ?*IShellItemFilter) HRESULT {
                return @as(*const IFileDialog.VTable, @ptrCast(self.vtable)).SetFilter(@as(*const IFileDialog, @ptrCast(self)), pFilter);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IFileSaveDialog_Value = Guid.initString("84bccd23-5fde-4cdb-aea4-af64b83d78ab");
pub const IID_IFileSaveDialog = &IID_IFileSaveDialog_Value;
pub const IFileSaveDialog = extern struct {
    pub const VTable = extern struct {
        base: IFileDialog.VTable,
        SetSaveAsItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileSaveDialog,
                psi: ?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileSaveDialog,
                psi: ?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetProperties: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileSaveDialog,
                pStore: ?*IPropertyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileSaveDialog,
                pStore: ?*IPropertyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCollectedProperties: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileSaveDialog,
                pList: ?*IPropertyDescriptionList,
                fAppendDefault: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileSaveDialog,
                pList: ?*IPropertyDescriptionList,
                fAppendDefault: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProperties: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileSaveDialog,
                ppStore: ?*?*IPropertyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileSaveDialog,
                ppStore: ?*?*IPropertyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ApplyProperties: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileSaveDialog,
                psi: ?*IShellItem,
                pStore: ?*IPropertyStore,
                hwnd: ?HWND,
                pSink: ?*IFileOperationProgressSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileSaveDialog,
                psi: ?*IShellItem,
                pStore: ?*IPropertyStore,
                hwnd: ?HWND,
                pSink: ?*IFileOperationProgressSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IFileDialog.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileSaveDialog_SetSaveAsItem(self: *const T, psi: ?*IShellItem) HRESULT {
                return @as(*const IFileSaveDialog.VTable, @ptrCast(self.vtable)).SetSaveAsItem(@as(*const IFileSaveDialog, @ptrCast(self)), psi);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileSaveDialog_SetProperties(self: *const T, pStore: ?*IPropertyStore) HRESULT {
                return @as(*const IFileSaveDialog.VTable, @ptrCast(self.vtable)).SetProperties(@as(*const IFileSaveDialog, @ptrCast(self)), pStore);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileSaveDialog_SetCollectedProperties(self: *const T, pList: ?*IPropertyDescriptionList, fAppendDefault: BOOL) HRESULT {
                return @as(*const IFileSaveDialog.VTable, @ptrCast(self.vtable)).SetCollectedProperties(@as(*const IFileSaveDialog, @ptrCast(self)), pList, fAppendDefault);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileSaveDialog_GetProperties(self: *const T, ppStore: ?*?*IPropertyStore) HRESULT {
                return @as(*const IFileSaveDialog.VTable, @ptrCast(self.vtable)).GetProperties(@as(*const IFileSaveDialog, @ptrCast(self)), ppStore);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileSaveDialog_ApplyProperties(self: *const T, psi: ?*IShellItem, pStore: ?*IPropertyStore, hwnd: ?HWND, pSink: ?*IFileOperationProgressSink) HRESULT {
                return @as(*const IFileSaveDialog.VTable, @ptrCast(self.vtable)).ApplyProperties(@as(*const IFileSaveDialog, @ptrCast(self)), psi, pStore, hwnd, pSink);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IFileOpenDialog_Value = Guid.initString("d57c7288-d4ad-4768-be02-9d969532d960");
pub const IID_IFileOpenDialog = &IID_IFileOpenDialog_Value;
pub const IFileOpenDialog = extern struct {
    pub const VTable = extern struct {
        base: IFileDialog.VTable,
        GetResults: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileOpenDialog,
                ppenum: ?*?*IShellItemArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileOpenDialog,
                ppenum: ?*?*IShellItemArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSelectedItems: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileOpenDialog,
                ppsai: ?*?*IShellItemArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileOpenDialog,
                ppsai: ?*?*IShellItemArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IFileDialog.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileOpenDialog_GetResults(self: *const T, ppenum: ?*?*IShellItemArray) HRESULT {
                return @as(*const IFileOpenDialog.VTable, @ptrCast(self.vtable)).GetResults(@as(*const IFileOpenDialog, @ptrCast(self)), ppenum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileOpenDialog_GetSelectedItems(self: *const T, ppsai: ?*?*IShellItemArray) HRESULT {
                return @as(*const IFileOpenDialog.VTable, @ptrCast(self.vtable)).GetSelectedItems(@as(*const IFileOpenDialog, @ptrCast(self)), ppsai);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const CDCONTROLSTATEF = enum(i32) {
    INACTIVE = 0,
    ENABLED = 1,
    VISIBLE = 2,
    ENABLEDVISIBLE = 3,
};
pub const CDCS_INACTIVE = CDCONTROLSTATEF.INACTIVE;
pub const CDCS_ENABLED = CDCONTROLSTATEF.ENABLED;
pub const CDCS_VISIBLE = CDCONTROLSTATEF.VISIBLE;
pub const CDCS_ENABLEDVISIBLE = CDCONTROLSTATEF.ENABLEDVISIBLE;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IFileDialogCustomize_Value = Guid.initString("e6fdd21a-163f-4975-9c8c-a69f1ba37034");
pub const IID_IFileDialogCustomize = &IID_IFileDialogCustomize_Value;
pub const IFileDialogCustomize = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EnableOpenDropDown: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileDialogCustomize,
                dwIDCtl: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileDialogCustomize,
                dwIDCtl: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddMenu: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileDialogCustomize,
                dwIDCtl: u32,
                pszLabel: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileDialogCustomize,
                dwIDCtl: u32,
                pszLabel: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddPushButton: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileDialogCustomize,
                dwIDCtl: u32,
                pszLabel: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileDialogCustomize,
                dwIDCtl: u32,
                pszLabel: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddComboBox: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileDialogCustomize,
                dwIDCtl: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileDialogCustomize,
                dwIDCtl: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddRadioButtonList: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileDialogCustomize,
                dwIDCtl: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileDialogCustomize,
                dwIDCtl: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddCheckButton: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileDialogCustomize,
                dwIDCtl: u32,
                pszLabel: ?[*:0]const u16,
                bChecked: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileDialogCustomize,
                dwIDCtl: u32,
                pszLabel: ?[*:0]const u16,
                bChecked: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddEditBox: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileDialogCustomize,
                dwIDCtl: u32,
                pszText: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileDialogCustomize,
                dwIDCtl: u32,
                pszText: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddSeparator: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileDialogCustomize,
                dwIDCtl: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileDialogCustomize,
                dwIDCtl: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileDialogCustomize,
                dwIDCtl: u32,
                pszText: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileDialogCustomize,
                dwIDCtl: u32,
                pszText: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetControlLabel: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileDialogCustomize,
                dwIDCtl: u32,
                pszLabel: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileDialogCustomize,
                dwIDCtl: u32,
                pszLabel: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetControlState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileDialogCustomize,
                dwIDCtl: u32,
                pdwState: ?*CDCONTROLSTATEF,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileDialogCustomize,
                dwIDCtl: u32,
                pdwState: ?*CDCONTROLSTATEF,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetControlState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileDialogCustomize,
                dwIDCtl: u32,
                dwState: CDCONTROLSTATEF,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileDialogCustomize,
                dwIDCtl: u32,
                dwState: CDCONTROLSTATEF,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEditBoxText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileDialogCustomize,
                dwIDCtl: u32,
                ppszText: ?*?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileDialogCustomize,
                dwIDCtl: u32,
                ppszText: ?*?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEditBoxText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileDialogCustomize,
                dwIDCtl: u32,
                pszText: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileDialogCustomize,
                dwIDCtl: u32,
                pszText: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCheckButtonState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileDialogCustomize,
                dwIDCtl: u32,
                pbChecked: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileDialogCustomize,
                dwIDCtl: u32,
                pbChecked: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCheckButtonState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileDialogCustomize,
                dwIDCtl: u32,
                bChecked: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileDialogCustomize,
                dwIDCtl: u32,
                bChecked: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddControlItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileDialogCustomize,
                dwIDCtl: u32,
                dwIDItem: u32,
                pszLabel: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileDialogCustomize,
                dwIDCtl: u32,
                dwIDItem: u32,
                pszLabel: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveControlItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileDialogCustomize,
                dwIDCtl: u32,
                dwIDItem: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileDialogCustomize,
                dwIDCtl: u32,
                dwIDItem: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveAllControlItems: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileDialogCustomize,
                dwIDCtl: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileDialogCustomize,
                dwIDCtl: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetControlItemState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileDialogCustomize,
                dwIDCtl: u32,
                dwIDItem: u32,
                pdwState: ?*CDCONTROLSTATEF,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileDialogCustomize,
                dwIDCtl: u32,
                dwIDItem: u32,
                pdwState: ?*CDCONTROLSTATEF,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetControlItemState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileDialogCustomize,
                dwIDCtl: u32,
                dwIDItem: u32,
                dwState: CDCONTROLSTATEF,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileDialogCustomize,
                dwIDCtl: u32,
                dwIDItem: u32,
                dwState: CDCONTROLSTATEF,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSelectedControlItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileDialogCustomize,
                dwIDCtl: u32,
                pdwIDItem: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileDialogCustomize,
                dwIDCtl: u32,
                pdwIDItem: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSelectedControlItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileDialogCustomize,
                dwIDCtl: u32,
                dwIDItem: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileDialogCustomize,
                dwIDCtl: u32,
                dwIDItem: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartVisualGroup: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileDialogCustomize,
                dwIDCtl: u32,
                pszLabel: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileDialogCustomize,
                dwIDCtl: u32,
                pszLabel: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndVisualGroup: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileDialogCustomize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileDialogCustomize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        MakeProminent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileDialogCustomize,
                dwIDCtl: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileDialogCustomize,
                dwIDCtl: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetControlItemText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileDialogCustomize,
                dwIDCtl: u32,
                dwIDItem: u32,
                pszLabel: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileDialogCustomize,
                dwIDCtl: u32,
                dwIDItem: u32,
                pszLabel: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileDialogCustomize_EnableOpenDropDown(self: *const T, dwIDCtl: u32) HRESULT {
                return @as(*const IFileDialogCustomize.VTable, @ptrCast(self.vtable)).EnableOpenDropDown(@as(*const IFileDialogCustomize, @ptrCast(self)), dwIDCtl);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileDialogCustomize_AddMenu(self: *const T, dwIDCtl: u32, pszLabel: ?[*:0]const u16) HRESULT {
                return @as(*const IFileDialogCustomize.VTable, @ptrCast(self.vtable)).AddMenu(@as(*const IFileDialogCustomize, @ptrCast(self)), dwIDCtl, pszLabel);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileDialogCustomize_AddPushButton(self: *const T, dwIDCtl: u32, pszLabel: ?[*:0]const u16) HRESULT {
                return @as(*const IFileDialogCustomize.VTable, @ptrCast(self.vtable)).AddPushButton(@as(*const IFileDialogCustomize, @ptrCast(self)), dwIDCtl, pszLabel);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileDialogCustomize_AddComboBox(self: *const T, dwIDCtl: u32) HRESULT {
                return @as(*const IFileDialogCustomize.VTable, @ptrCast(self.vtable)).AddComboBox(@as(*const IFileDialogCustomize, @ptrCast(self)), dwIDCtl);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileDialogCustomize_AddRadioButtonList(self: *const T, dwIDCtl: u32) HRESULT {
                return @as(*const IFileDialogCustomize.VTable, @ptrCast(self.vtable)).AddRadioButtonList(@as(*const IFileDialogCustomize, @ptrCast(self)), dwIDCtl);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileDialogCustomize_AddCheckButton(self: *const T, dwIDCtl: u32, pszLabel: ?[*:0]const u16, bChecked: BOOL) HRESULT {
                return @as(*const IFileDialogCustomize.VTable, @ptrCast(self.vtable)).AddCheckButton(@as(*const IFileDialogCustomize, @ptrCast(self)), dwIDCtl, pszLabel, bChecked);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileDialogCustomize_AddEditBox(self: *const T, dwIDCtl: u32, pszText: ?[*:0]const u16) HRESULT {
                return @as(*const IFileDialogCustomize.VTable, @ptrCast(self.vtable)).AddEditBox(@as(*const IFileDialogCustomize, @ptrCast(self)), dwIDCtl, pszText);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileDialogCustomize_AddSeparator(self: *const T, dwIDCtl: u32) HRESULT {
                return @as(*const IFileDialogCustomize.VTable, @ptrCast(self.vtable)).AddSeparator(@as(*const IFileDialogCustomize, @ptrCast(self)), dwIDCtl);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileDialogCustomize_AddText(self: *const T, dwIDCtl: u32, pszText: ?[*:0]const u16) HRESULT {
                return @as(*const IFileDialogCustomize.VTable, @ptrCast(self.vtable)).AddText(@as(*const IFileDialogCustomize, @ptrCast(self)), dwIDCtl, pszText);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileDialogCustomize_SetControlLabel(self: *const T, dwIDCtl: u32, pszLabel: ?[*:0]const u16) HRESULT {
                return @as(*const IFileDialogCustomize.VTable, @ptrCast(self.vtable)).SetControlLabel(@as(*const IFileDialogCustomize, @ptrCast(self)), dwIDCtl, pszLabel);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileDialogCustomize_GetControlState(self: *const T, dwIDCtl: u32, pdwState: ?*CDCONTROLSTATEF) HRESULT {
                return @as(*const IFileDialogCustomize.VTable, @ptrCast(self.vtable)).GetControlState(@as(*const IFileDialogCustomize, @ptrCast(self)), dwIDCtl, pdwState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileDialogCustomize_SetControlState(self: *const T, dwIDCtl: u32, dwState: CDCONTROLSTATEF) HRESULT {
                return @as(*const IFileDialogCustomize.VTable, @ptrCast(self.vtable)).SetControlState(@as(*const IFileDialogCustomize, @ptrCast(self)), dwIDCtl, dwState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileDialogCustomize_GetEditBoxText(self: *const T, dwIDCtl: u32, ppszText: ?*?*u16) HRESULT {
                return @as(*const IFileDialogCustomize.VTable, @ptrCast(self.vtable)).GetEditBoxText(@as(*const IFileDialogCustomize, @ptrCast(self)), dwIDCtl, ppszText);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileDialogCustomize_SetEditBoxText(self: *const T, dwIDCtl: u32, pszText: ?[*:0]const u16) HRESULT {
                return @as(*const IFileDialogCustomize.VTable, @ptrCast(self.vtable)).SetEditBoxText(@as(*const IFileDialogCustomize, @ptrCast(self)), dwIDCtl, pszText);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileDialogCustomize_GetCheckButtonState(self: *const T, dwIDCtl: u32, pbChecked: ?*BOOL) HRESULT {
                return @as(*const IFileDialogCustomize.VTable, @ptrCast(self.vtable)).GetCheckButtonState(@as(*const IFileDialogCustomize, @ptrCast(self)), dwIDCtl, pbChecked);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileDialogCustomize_SetCheckButtonState(self: *const T, dwIDCtl: u32, bChecked: BOOL) HRESULT {
                return @as(*const IFileDialogCustomize.VTable, @ptrCast(self.vtable)).SetCheckButtonState(@as(*const IFileDialogCustomize, @ptrCast(self)), dwIDCtl, bChecked);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileDialogCustomize_AddControlItem(self: *const T, dwIDCtl: u32, dwIDItem: u32, pszLabel: ?[*:0]const u16) HRESULT {
                return @as(*const IFileDialogCustomize.VTable, @ptrCast(self.vtable)).AddControlItem(@as(*const IFileDialogCustomize, @ptrCast(self)), dwIDCtl, dwIDItem, pszLabel);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileDialogCustomize_RemoveControlItem(self: *const T, dwIDCtl: u32, dwIDItem: u32) HRESULT {
                return @as(*const IFileDialogCustomize.VTable, @ptrCast(self.vtable)).RemoveControlItem(@as(*const IFileDialogCustomize, @ptrCast(self)), dwIDCtl, dwIDItem);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileDialogCustomize_RemoveAllControlItems(self: *const T, dwIDCtl: u32) HRESULT {
                return @as(*const IFileDialogCustomize.VTable, @ptrCast(self.vtable)).RemoveAllControlItems(@as(*const IFileDialogCustomize, @ptrCast(self)), dwIDCtl);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileDialogCustomize_GetControlItemState(self: *const T, dwIDCtl: u32, dwIDItem: u32, pdwState: ?*CDCONTROLSTATEF) HRESULT {
                return @as(*const IFileDialogCustomize.VTable, @ptrCast(self.vtable)).GetControlItemState(@as(*const IFileDialogCustomize, @ptrCast(self)), dwIDCtl, dwIDItem, pdwState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileDialogCustomize_SetControlItemState(self: *const T, dwIDCtl: u32, dwIDItem: u32, dwState: CDCONTROLSTATEF) HRESULT {
                return @as(*const IFileDialogCustomize.VTable, @ptrCast(self.vtable)).SetControlItemState(@as(*const IFileDialogCustomize, @ptrCast(self)), dwIDCtl, dwIDItem, dwState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileDialogCustomize_GetSelectedControlItem(self: *const T, dwIDCtl: u32, pdwIDItem: ?*u32) HRESULT {
                return @as(*const IFileDialogCustomize.VTable, @ptrCast(self.vtable)).GetSelectedControlItem(@as(*const IFileDialogCustomize, @ptrCast(self)), dwIDCtl, pdwIDItem);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileDialogCustomize_SetSelectedControlItem(self: *const T, dwIDCtl: u32, dwIDItem: u32) HRESULT {
                return @as(*const IFileDialogCustomize.VTable, @ptrCast(self.vtable)).SetSelectedControlItem(@as(*const IFileDialogCustomize, @ptrCast(self)), dwIDCtl, dwIDItem);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileDialogCustomize_StartVisualGroup(self: *const T, dwIDCtl: u32, pszLabel: ?[*:0]const u16) HRESULT {
                return @as(*const IFileDialogCustomize.VTable, @ptrCast(self.vtable)).StartVisualGroup(@as(*const IFileDialogCustomize, @ptrCast(self)), dwIDCtl, pszLabel);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileDialogCustomize_EndVisualGroup(self: *const T) HRESULT {
                return @as(*const IFileDialogCustomize.VTable, @ptrCast(self.vtable)).EndVisualGroup(@as(*const IFileDialogCustomize, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileDialogCustomize_MakeProminent(self: *const T, dwIDCtl: u32) HRESULT {
                return @as(*const IFileDialogCustomize.VTable, @ptrCast(self.vtable)).MakeProminent(@as(*const IFileDialogCustomize, @ptrCast(self)), dwIDCtl);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileDialogCustomize_SetControlItemText(self: *const T, dwIDCtl: u32, dwIDItem: u32, pszLabel: ?[*:0]const u16) HRESULT {
                return @as(*const IFileDialogCustomize.VTable, @ptrCast(self.vtable)).SetControlItemText(@as(*const IFileDialogCustomize, @ptrCast(self)), dwIDCtl, dwIDItem, pszLabel);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const ASSOCIATIONLEVEL = enum(i32) {
    MACHINE = 0,
    EFFECTIVE = 1,
    USER = 2,
};
pub const AL_MACHINE = ASSOCIATIONLEVEL.MACHINE;
pub const AL_EFFECTIVE = ASSOCIATIONLEVEL.EFFECTIVE;
pub const AL_USER = ASSOCIATIONLEVEL.USER;

pub const ASSOCIATIONTYPE = enum(i32) {
    FILEEXTENSION = 0,
    URLPROTOCOL = 1,
    STARTMENUCLIENT = 2,
    MIMETYPE = 3,
};
pub const AT_FILEEXTENSION = ASSOCIATIONTYPE.FILEEXTENSION;
pub const AT_URLPROTOCOL = ASSOCIATIONTYPE.URLPROTOCOL;
pub const AT_STARTMENUCLIENT = ASSOCIATIONTYPE.STARTMENUCLIENT;
pub const AT_MIMETYPE = ASSOCIATIONTYPE.MIMETYPE;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IApplicationAssociationRegistration_Value = Guid.initString("4e530b0a-e611-4c77-a3ac-9031d022281b");
pub const IID_IApplicationAssociationRegistration = &IID_IApplicationAssociationRegistration_Value;
pub const IApplicationAssociationRegistration = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryCurrentDefault: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IApplicationAssociationRegistration,
                pszQuery: ?[*:0]const u16,
                atQueryType: ASSOCIATIONTYPE,
                alQueryLevel: ASSOCIATIONLEVEL,
                ppszAssociation: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IApplicationAssociationRegistration,
                pszQuery: ?[*:0]const u16,
                atQueryType: ASSOCIATIONTYPE,
                alQueryLevel: ASSOCIATIONLEVEL,
                ppszAssociation: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryAppIsDefault: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IApplicationAssociationRegistration,
                pszQuery: ?[*:0]const u16,
                atQueryType: ASSOCIATIONTYPE,
                alQueryLevel: ASSOCIATIONLEVEL,
                pszAppRegistryName: ?[*:0]const u16,
                pfDefault: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IApplicationAssociationRegistration,
                pszQuery: ?[*:0]const u16,
                atQueryType: ASSOCIATIONTYPE,
                alQueryLevel: ASSOCIATIONLEVEL,
                pszAppRegistryName: ?[*:0]const u16,
                pfDefault: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryAppIsDefaultAll: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IApplicationAssociationRegistration,
                alQueryLevel: ASSOCIATIONLEVEL,
                pszAppRegistryName: ?[*:0]const u16,
                pfDefault: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IApplicationAssociationRegistration,
                alQueryLevel: ASSOCIATIONLEVEL,
                pszAppRegistryName: ?[*:0]const u16,
                pfDefault: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetAppAsDefault: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IApplicationAssociationRegistration,
                pszAppRegistryName: ?[*:0]const u16,
                pszSet: ?[*:0]const u16,
                atSetType: ASSOCIATIONTYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IApplicationAssociationRegistration,
                pszAppRegistryName: ?[*:0]const u16,
                pszSet: ?[*:0]const u16,
                atSetType: ASSOCIATIONTYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetAppAsDefaultAll: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IApplicationAssociationRegistration,
                pszAppRegistryName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IApplicationAssociationRegistration,
                pszAppRegistryName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ClearUserAssociations: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IApplicationAssociationRegistration,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IApplicationAssociationRegistration,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IApplicationAssociationRegistration_QueryCurrentDefault(self: *const T, pszQuery: ?[*:0]const u16, atQueryType: ASSOCIATIONTYPE, alQueryLevel: ASSOCIATIONLEVEL, ppszAssociation: ?*?PWSTR) HRESULT {
                return @as(*const IApplicationAssociationRegistration.VTable, @ptrCast(self.vtable)).QueryCurrentDefault(@as(*const IApplicationAssociationRegistration, @ptrCast(self)), pszQuery, atQueryType, alQueryLevel, ppszAssociation);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IApplicationAssociationRegistration_QueryAppIsDefault(self: *const T, pszQuery: ?[*:0]const u16, atQueryType: ASSOCIATIONTYPE, alQueryLevel: ASSOCIATIONLEVEL, pszAppRegistryName: ?[*:0]const u16, pfDefault: ?*BOOL) HRESULT {
                return @as(*const IApplicationAssociationRegistration.VTable, @ptrCast(self.vtable)).QueryAppIsDefault(@as(*const IApplicationAssociationRegistration, @ptrCast(self)), pszQuery, atQueryType, alQueryLevel, pszAppRegistryName, pfDefault);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IApplicationAssociationRegistration_QueryAppIsDefaultAll(self: *const T, alQueryLevel: ASSOCIATIONLEVEL, pszAppRegistryName: ?[*:0]const u16, pfDefault: ?*BOOL) HRESULT {
                return @as(*const IApplicationAssociationRegistration.VTable, @ptrCast(self.vtable)).QueryAppIsDefaultAll(@as(*const IApplicationAssociationRegistration, @ptrCast(self)), alQueryLevel, pszAppRegistryName, pfDefault);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IApplicationAssociationRegistration_SetAppAsDefault(self: *const T, pszAppRegistryName: ?[*:0]const u16, pszSet: ?[*:0]const u16, atSetType: ASSOCIATIONTYPE) HRESULT {
                return @as(*const IApplicationAssociationRegistration.VTable, @ptrCast(self.vtable)).SetAppAsDefault(@as(*const IApplicationAssociationRegistration, @ptrCast(self)), pszAppRegistryName, pszSet, atSetType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IApplicationAssociationRegistration_SetAppAsDefaultAll(self: *const T, pszAppRegistryName: ?[*:0]const u16) HRESULT {
                return @as(*const IApplicationAssociationRegistration.VTable, @ptrCast(self.vtable)).SetAppAsDefaultAll(@as(*const IApplicationAssociationRegistration, @ptrCast(self)), pszAppRegistryName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IApplicationAssociationRegistration_ClearUserAssociations(self: *const T) HRESULT {
                return @as(*const IApplicationAssociationRegistration.VTable, @ptrCast(self.vtable)).ClearUserAssociations(@as(*const IApplicationAssociationRegistration, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DELEGATEITEMID = extern struct {
    cbSize: u16 align(1),
    wOuter: u16 align(1),
    cbInner: u16 align(1),
    rgb: [1]u8 align(1),
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IDelegateFolder_Value = Guid.initString("add8ba80-002b-11d0-8f0f-00c04fd7d062");
pub const IID_IDelegateFolder = &IID_IDelegateFolder_Value;
pub const IDelegateFolder = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetItemAlloc: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDelegateFolder,
                pmalloc: ?*IMalloc,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDelegateFolder,
                pmalloc: ?*IMalloc,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDelegateFolder_SetItemAlloc(self: *const T, pmalloc: ?*IMalloc) HRESULT {
                return @as(*const IDelegateFolder.VTable, @ptrCast(self.vtable)).SetItemAlloc(@as(*const IDelegateFolder, @ptrCast(self)), pmalloc);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const _BROWSERFRAMEOPTIONS = enum(i32) {
    FO_NONE = 0,
    FO_BROWSER_PERSIST_SETTINGS = 1,
    FO_RENAME_FOLDER_OPTIONS_TOINTERNET = 2,
    FO_BOTH_OPTIONS = 4,
    IF_PREFER_INTERNET_SHORTCUT = 8,
    FO_BROWSE_NO_IN_NEW_PROCESS = 16,
    FO_ENABLE_HYPERLINK_TRACKING = 32,
    FO_USE_IE_OFFLINE_SUPPORT = 64,
    FO_SUBSTITUE_INTERNET_START_PAGE = 128,
    FO_USE_IE_LOGOBANDING = 256,
    FO_ADD_IE_TOCAPTIONBAR = 512,
    FO_USE_DIALUP_REF = 1024,
    FO_USE_IE_TOOLBAR = 2048,
    FO_NO_PARENT_FOLDER_SUPPORT = 4096,
    FO_NO_REOPEN_NEXT_RESTART = 8192,
    FO_GO_HOME_PAGE = 16384,
    FO_PREFER_IEPROCESS = 32768,
    FO_SHOW_NAVIGATION_CANCELLED = 65536,
    FO_USE_IE_STATUSBAR = 131072,
    FO_QUERY_ALL = -1,
};
pub const BFO_NONE = _BROWSERFRAMEOPTIONS.FO_NONE;
pub const BFO_BROWSER_PERSIST_SETTINGS = _BROWSERFRAMEOPTIONS.FO_BROWSER_PERSIST_SETTINGS;
pub const BFO_RENAME_FOLDER_OPTIONS_TOINTERNET = _BROWSERFRAMEOPTIONS.FO_RENAME_FOLDER_OPTIONS_TOINTERNET;
pub const BFO_BOTH_OPTIONS = _BROWSERFRAMEOPTIONS.FO_BOTH_OPTIONS;
pub const BIF_PREFER_INTERNET_SHORTCUT = _BROWSERFRAMEOPTIONS.IF_PREFER_INTERNET_SHORTCUT;
pub const BFO_BROWSE_NO_IN_NEW_PROCESS = _BROWSERFRAMEOPTIONS.FO_BROWSE_NO_IN_NEW_PROCESS;
pub const BFO_ENABLE_HYPERLINK_TRACKING = _BROWSERFRAMEOPTIONS.FO_ENABLE_HYPERLINK_TRACKING;
pub const BFO_USE_IE_OFFLINE_SUPPORT = _BROWSERFRAMEOPTIONS.FO_USE_IE_OFFLINE_SUPPORT;
pub const BFO_SUBSTITUE_INTERNET_START_PAGE = _BROWSERFRAMEOPTIONS.FO_SUBSTITUE_INTERNET_START_PAGE;
pub const BFO_USE_IE_LOGOBANDING = _BROWSERFRAMEOPTIONS.FO_USE_IE_LOGOBANDING;
pub const BFO_ADD_IE_TOCAPTIONBAR = _BROWSERFRAMEOPTIONS.FO_ADD_IE_TOCAPTIONBAR;
pub const BFO_USE_DIALUP_REF = _BROWSERFRAMEOPTIONS.FO_USE_DIALUP_REF;
pub const BFO_USE_IE_TOOLBAR = _BROWSERFRAMEOPTIONS.FO_USE_IE_TOOLBAR;
pub const BFO_NO_PARENT_FOLDER_SUPPORT = _BROWSERFRAMEOPTIONS.FO_NO_PARENT_FOLDER_SUPPORT;
pub const BFO_NO_REOPEN_NEXT_RESTART = _BROWSERFRAMEOPTIONS.FO_NO_REOPEN_NEXT_RESTART;
pub const BFO_GO_HOME_PAGE = _BROWSERFRAMEOPTIONS.FO_GO_HOME_PAGE;
pub const BFO_PREFER_IEPROCESS = _BROWSERFRAMEOPTIONS.FO_PREFER_IEPROCESS;
pub const BFO_SHOW_NAVIGATION_CANCELLED = _BROWSERFRAMEOPTIONS.FO_SHOW_NAVIGATION_CANCELLED;
pub const BFO_USE_IE_STATUSBAR = _BROWSERFRAMEOPTIONS.FO_USE_IE_STATUSBAR;
pub const BFO_QUERY_ALL = _BROWSERFRAMEOPTIONS.FO_QUERY_ALL;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IBrowserFrameOptions_Value = Guid.initString("10df43c8-1dbe-11d3-8b34-006097df5bd4");
pub const IID_IBrowserFrameOptions = &IID_IBrowserFrameOptions_Value;
pub const IBrowserFrameOptions = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetFrameOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserFrameOptions,
                dwMask: u32,
                pdwOptions: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBrowserFrameOptions,
                dwMask: u32,
                pdwOptions: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserFrameOptions_GetFrameOptions(self: *const T, dwMask: u32, pdwOptions: ?*u32) HRESULT {
                return @as(*const IBrowserFrameOptions.VTable, @ptrCast(self.vtable)).GetFrameOptions(@as(*const IBrowserFrameOptions, @ptrCast(self)), dwMask, pdwOptions);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const NWMF = enum(i32) {
    UNLOADING = 1,
    USERINITED = 2,
    FIRST = 4,
    OVERRIDEKEY = 8,
    SHOWHELP = 16,
    HTMLDIALOG = 32,
    FROMDIALOGCHILD = 64,
    USERREQUESTED = 128,
    USERALLOWED = 256,
    FORCEWINDOW = 65536,
    FORCETAB = 131072,
    SUGGESTWINDOW = 262144,
    SUGGESTTAB = 524288,
    INACTIVETAB = 1048576,
};
pub const NWMF_UNLOADING = NWMF.UNLOADING;
pub const NWMF_USERINITED = NWMF.USERINITED;
pub const NWMF_FIRST = NWMF.FIRST;
pub const NWMF_OVERRIDEKEY = NWMF.OVERRIDEKEY;
pub const NWMF_SHOWHELP = NWMF.SHOWHELP;
pub const NWMF_HTMLDIALOG = NWMF.HTMLDIALOG;
pub const NWMF_FROMDIALOGCHILD = NWMF.FROMDIALOGCHILD;
pub const NWMF_USERREQUESTED = NWMF.USERREQUESTED;
pub const NWMF_USERALLOWED = NWMF.USERALLOWED;
pub const NWMF_FORCEWINDOW = NWMF.FORCEWINDOW;
pub const NWMF_FORCETAB = NWMF.FORCETAB;
pub const NWMF_SUGGESTWINDOW = NWMF.SUGGESTWINDOW;
pub const NWMF_SUGGESTTAB = NWMF.SUGGESTTAB;
pub const NWMF_INACTIVETAB = NWMF.INACTIVETAB;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_INewWindowManager_Value = Guid.initString("d2bc4c84-3f72-4a52-a604-7bcbf3982cbb");
pub const IID_INewWindowManager = &IID_INewWindowManager_Value;
pub const INewWindowManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EvaluateNewWindow: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INewWindowManager,
                pszUrl: ?[*:0]const u16,
                pszName: ?[*:0]const u16,
                pszUrlContext: ?[*:0]const u16,
                pszFeatures: ?[*:0]const u16,
                fReplace: BOOL,
                dwFlags: u32,
                dwUserActionTime: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INewWindowManager,
                pszUrl: ?[*:0]const u16,
                pszName: ?[*:0]const u16,
                pszUrlContext: ?[*:0]const u16,
                pszFeatures: ?[*:0]const u16,
                fReplace: BOOL,
                dwFlags: u32,
                dwUserActionTime: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INewWindowManager_EvaluateNewWindow(self: *const T, pszUrl: ?[*:0]const u16, pszName: ?[*:0]const u16, pszUrlContext: ?[*:0]const u16, pszFeatures: ?[*:0]const u16, fReplace: BOOL, dwFlags: u32, dwUserActionTime: u32) HRESULT {
                return @as(*const INewWindowManager.VTable, @ptrCast(self.vtable)).EvaluateNewWindow(@as(*const INewWindowManager, @ptrCast(self)), pszUrl, pszName, pszUrlContext, pszFeatures, fReplace, dwFlags, dwUserActionTime);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const ATTACHMENT_PROMPT = enum(i32) {
    NONE = 0,
    SAVE = 1,
    EXEC = 2,
    EXEC_OR_SAVE = 3,
};
pub const ATTACHMENT_PROMPT_NONE = ATTACHMENT_PROMPT.NONE;
pub const ATTACHMENT_PROMPT_SAVE = ATTACHMENT_PROMPT.SAVE;
pub const ATTACHMENT_PROMPT_EXEC = ATTACHMENT_PROMPT.EXEC;
pub const ATTACHMENT_PROMPT_EXEC_OR_SAVE = ATTACHMENT_PROMPT.EXEC_OR_SAVE;

pub const ATTACHMENT_ACTION = enum(i32) {
    CANCEL = 0,
    SAVE = 1,
    EXEC = 2,
};
pub const ATTACHMENT_ACTION_CANCEL = ATTACHMENT_ACTION.CANCEL;
pub const ATTACHMENT_ACTION_SAVE = ATTACHMENT_ACTION.SAVE;
pub const ATTACHMENT_ACTION_EXEC = ATTACHMENT_ACTION.EXEC;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IAttachmentExecute_Value = Guid.initString("73db1241-1e85-4581-8e4f-a81e1d0f8c57");
pub const IID_IAttachmentExecute = &IID_IAttachmentExecute_Value;
pub const IAttachmentExecute = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetClientTitle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAttachmentExecute,
                pszTitle: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAttachmentExecute,
                pszTitle: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetClientGuid: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAttachmentExecute,
                guid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAttachmentExecute,
                guid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetLocalPath: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAttachmentExecute,
                pszLocalPath: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAttachmentExecute,
                pszLocalPath: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFileName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAttachmentExecute,
                pszFileName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAttachmentExecute,
                pszFileName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSource: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAttachmentExecute,
                pszSource: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAttachmentExecute,
                pszSource: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetReferrer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAttachmentExecute,
                pszReferrer: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAttachmentExecute,
                pszReferrer: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CheckPolicy: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAttachmentExecute,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAttachmentExecute,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Prompt: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAttachmentExecute,
                hwnd: ?HWND,
                prompt: ATTACHMENT_PROMPT,
                paction: ?*ATTACHMENT_ACTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAttachmentExecute,
                hwnd: ?HWND,
                prompt: ATTACHMENT_PROMPT,
                paction: ?*ATTACHMENT_ACTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Save: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAttachmentExecute,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAttachmentExecute,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Execute: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAttachmentExecute,
                hwnd: ?HWND,
                pszVerb: ?[*:0]const u16,
                phProcess: ?*?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAttachmentExecute,
                hwnd: ?HWND,
                pszVerb: ?[*:0]const u16,
                phProcess: ?*?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SaveWithUI: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAttachmentExecute,
                hwnd: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAttachmentExecute,
                hwnd: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ClearClientState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAttachmentExecute,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAttachmentExecute,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAttachmentExecute_SetClientTitle(self: *const T, pszTitle: ?[*:0]const u16) HRESULT {
                return @as(*const IAttachmentExecute.VTable, @ptrCast(self.vtable)).SetClientTitle(@as(*const IAttachmentExecute, @ptrCast(self)), pszTitle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAttachmentExecute_SetClientGuid(self: *const T, guid: ?*const Guid) HRESULT {
                return @as(*const IAttachmentExecute.VTable, @ptrCast(self.vtable)).SetClientGuid(@as(*const IAttachmentExecute, @ptrCast(self)), guid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAttachmentExecute_SetLocalPath(self: *const T, pszLocalPath: ?[*:0]const u16) HRESULT {
                return @as(*const IAttachmentExecute.VTable, @ptrCast(self.vtable)).SetLocalPath(@as(*const IAttachmentExecute, @ptrCast(self)), pszLocalPath);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAttachmentExecute_SetFileName(self: *const T, pszFileName: ?[*:0]const u16) HRESULT {
                return @as(*const IAttachmentExecute.VTable, @ptrCast(self.vtable)).SetFileName(@as(*const IAttachmentExecute, @ptrCast(self)), pszFileName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAttachmentExecute_SetSource(self: *const T, pszSource: ?[*:0]const u16) HRESULT {
                return @as(*const IAttachmentExecute.VTable, @ptrCast(self.vtable)).SetSource(@as(*const IAttachmentExecute, @ptrCast(self)), pszSource);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAttachmentExecute_SetReferrer(self: *const T, pszReferrer: ?[*:0]const u16) HRESULT {
                return @as(*const IAttachmentExecute.VTable, @ptrCast(self.vtable)).SetReferrer(@as(*const IAttachmentExecute, @ptrCast(self)), pszReferrer);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAttachmentExecute_CheckPolicy(self: *const T) HRESULT {
                return @as(*const IAttachmentExecute.VTable, @ptrCast(self.vtable)).CheckPolicy(@as(*const IAttachmentExecute, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAttachmentExecute_Prompt(self: *const T, hwnd: ?HWND, prompt: ATTACHMENT_PROMPT, paction: ?*ATTACHMENT_ACTION) HRESULT {
                return @as(*const IAttachmentExecute.VTable, @ptrCast(self.vtable)).Prompt(@as(*const IAttachmentExecute, @ptrCast(self)), hwnd, prompt, paction);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAttachmentExecute_Save(self: *const T) HRESULT {
                return @as(*const IAttachmentExecute.VTable, @ptrCast(self.vtable)).Save(@as(*const IAttachmentExecute, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAttachmentExecute_Execute(self: *const T, hwnd: ?HWND, pszVerb: ?[*:0]const u16, phProcess: ?*?HANDLE) HRESULT {
                return @as(*const IAttachmentExecute.VTable, @ptrCast(self.vtable)).Execute(@as(*const IAttachmentExecute, @ptrCast(self)), hwnd, pszVerb, phProcess);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAttachmentExecute_SaveWithUI(self: *const T, hwnd: ?HWND) HRESULT {
                return @as(*const IAttachmentExecute.VTable, @ptrCast(self.vtable)).SaveWithUI(@as(*const IAttachmentExecute, @ptrCast(self)), hwnd);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAttachmentExecute_ClearClientState(self: *const T) HRESULT {
                return @as(*const IAttachmentExecute.VTable, @ptrCast(self.vtable)).ClearClientState(@as(*const IAttachmentExecute, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SMDATA = extern struct {
    dwMask: u32,
    dwFlags: u32,
    hmenu: ?HMENU,
    hwnd: ?HWND,
    uId: u32,
    uIdParent: u32,
    uIdAncestor: u32,
    punk: ?*IUnknown,
    pidlFolder: ?*ITEMIDLIST,
    pidlItem: ?*ITEMIDLIST,
    psf: ?*IShellFolder,
    pvUserData: ?*anyopaque,
};

pub const SMINFO = extern struct {
    dwMask: u32,
    dwType: u32,
    dwFlags: u32,
    iIcon: i32,
};

pub const SMCSHCHANGENOTIFYSTRUCT = extern struct {
    lEvent: i32,
    pidl1: ?*ITEMIDLIST,
    pidl2: ?*ITEMIDLIST,
};

pub const SMINFOMASK = enum(i32) {
    TYPE = 1,
    FLAGS = 2,
    ICON = 4,
};
pub const SMIM_TYPE = SMINFOMASK.TYPE;
pub const SMIM_FLAGS = SMINFOMASK.FLAGS;
pub const SMIM_ICON = SMINFOMASK.ICON;

pub const SMINFOTYPE = enum(i32) {
    EPARATOR = 1,
    TRING = 2,
};
pub const SMIT_SEPARATOR = SMINFOTYPE.EPARATOR;
pub const SMIT_STRING = SMINFOTYPE.TRING;

pub const SMINFOFLAGS = enum(i32) {
    ICON = 1,
    ACCELERATOR = 2,
    DROPTARGET = 4,
    SUBMENU = 8,
    CHECKED = 32,
    DROPCASCADE = 64,
    HIDDEN = 128,
    DISABLED = 256,
    TRACKPOPUP = 512,
    DEMOTED = 1024,
    ALTSTATE = 2048,
    DRAGNDROP = 4096,
    NEW = 8192,
};
pub const SMIF_ICON = SMINFOFLAGS.ICON;
pub const SMIF_ACCELERATOR = SMINFOFLAGS.ACCELERATOR;
pub const SMIF_DROPTARGET = SMINFOFLAGS.DROPTARGET;
pub const SMIF_SUBMENU = SMINFOFLAGS.SUBMENU;
pub const SMIF_CHECKED = SMINFOFLAGS.CHECKED;
pub const SMIF_DROPCASCADE = SMINFOFLAGS.DROPCASCADE;
pub const SMIF_HIDDEN = SMINFOFLAGS.HIDDEN;
pub const SMIF_DISABLED = SMINFOFLAGS.DISABLED;
pub const SMIF_TRACKPOPUP = SMINFOFLAGS.TRACKPOPUP;
pub const SMIF_DEMOTED = SMINFOFLAGS.DEMOTED;
pub const SMIF_ALTSTATE = SMINFOFLAGS.ALTSTATE;
pub const SMIF_DRAGNDROP = SMINFOFLAGS.DRAGNDROP;
pub const SMIF_NEW = SMINFOFLAGS.NEW;

// TODO: this type is limited to platform 'windows5.0'
const IID_IShellMenuCallback_Value = Guid.initString("4ca300a1-9b8d-11d1-8b22-00c04fd918d0");
pub const IID_IShellMenuCallback = &IID_IShellMenuCallback_Value;
pub const IShellMenuCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CallbackSM: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellMenuCallback,
                psmd: ?*SMDATA,
                uMsg: u32,
                wParam: WPARAM,
                lParam: LPARAM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellMenuCallback,
                psmd: ?*SMDATA,
                uMsg: u32,
                wParam: WPARAM,
                lParam: LPARAM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellMenuCallback_CallbackSM(self: *const T, psmd: ?*SMDATA, uMsg: u32, wParam: WPARAM, lParam: LPARAM) HRESULT {
                return @as(*const IShellMenuCallback.VTable, @ptrCast(self.vtable)).CallbackSM(@as(*const IShellMenuCallback, @ptrCast(self)), psmd, uMsg, wParam, lParam);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IShellMenu_Value = Guid.initString("ee1f7637-e138-11d1-8379-00c04fd918d0");
pub const IID_IShellMenu = &IID_IShellMenu_Value;
pub const IShellMenu = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellMenu,
                psmc: ?*IShellMenuCallback,
                uId: u32,
                uIdAncestor: u32,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellMenu,
                psmc: ?*IShellMenuCallback,
                uId: u32,
                uIdAncestor: u32,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMenuInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellMenu,
                ppsmc: ?*?*IShellMenuCallback,
                puId: ?*u32,
                puIdAncestor: ?*u32,
                pdwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellMenu,
                ppsmc: ?*?*IShellMenuCallback,
                puId: ?*u32,
                puIdAncestor: ?*u32,
                pdwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetShellFolder: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellMenu,
                psf: ?*IShellFolder,
                pidlFolder: ?*ITEMIDLIST,
                hKey: ?HKEY,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellMenu,
                psf: ?*IShellFolder,
                pidlFolder: ?*ITEMIDLIST,
                hKey: ?HKEY,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetShellFolder: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellMenu,
                pdwFlags: ?*u32,
                ppidl: ?*?*ITEMIDLIST,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellMenu,
                pdwFlags: ?*u32,
                ppidl: ?*?*ITEMIDLIST,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetMenu: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellMenu,
                hmenu: ?HMENU,
                hwnd: ?HWND,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellMenu,
                hmenu: ?HMENU,
                hwnd: ?HWND,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMenu: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellMenu,
                phmenu: ?*?HMENU,
                phwnd: ?*?HWND,
                pdwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellMenu,
                phmenu: ?*?HMENU,
                phwnd: ?*?HWND,
                pdwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InvalidateItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellMenu,
                psmd: ?*SMDATA,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellMenu,
                psmd: ?*SMDATA,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellMenu,
                psmd: ?*SMDATA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellMenu,
                psmd: ?*SMDATA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetMenuToolbar: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellMenu,
                punk: ?*IUnknown,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellMenu,
                punk: ?*IUnknown,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellMenu_Initialize(self: *const T, psmc: ?*IShellMenuCallback, uId: u32, uIdAncestor: u32, dwFlags: u32) HRESULT {
                return @as(*const IShellMenu.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IShellMenu, @ptrCast(self)), psmc, uId, uIdAncestor, dwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellMenu_GetMenuInfo(self: *const T, ppsmc: ?*?*IShellMenuCallback, puId: ?*u32, puIdAncestor: ?*u32, pdwFlags: ?*u32) HRESULT {
                return @as(*const IShellMenu.VTable, @ptrCast(self.vtable)).GetMenuInfo(@as(*const IShellMenu, @ptrCast(self)), ppsmc, puId, puIdAncestor, pdwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellMenu_SetShellFolder(self: *const T, psf: ?*IShellFolder, pidlFolder: ?*ITEMIDLIST, hKey: ?HKEY, dwFlags: u32) HRESULT {
                return @as(*const IShellMenu.VTable, @ptrCast(self.vtable)).SetShellFolder(@as(*const IShellMenu, @ptrCast(self)), psf, pidlFolder, hKey, dwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellMenu_GetShellFolder(self: *const T, pdwFlags: ?*u32, ppidl: ?*?*ITEMIDLIST, riid: ?*const Guid, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const IShellMenu.VTable, @ptrCast(self.vtable)).GetShellFolder(@as(*const IShellMenu, @ptrCast(self)), pdwFlags, ppidl, riid, ppv);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellMenu_SetMenu(self: *const T, hmenu: ?HMENU, hwnd: ?HWND, dwFlags: u32) HRESULT {
                return @as(*const IShellMenu.VTable, @ptrCast(self.vtable)).SetMenu(@as(*const IShellMenu, @ptrCast(self)), hmenu, hwnd, dwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellMenu_GetMenu(self: *const T, phmenu: ?*?HMENU, phwnd: ?*?HWND, pdwFlags: ?*u32) HRESULT {
                return @as(*const IShellMenu.VTable, @ptrCast(self.vtable)).GetMenu(@as(*const IShellMenu, @ptrCast(self)), phmenu, phwnd, pdwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellMenu_InvalidateItem(self: *const T, psmd: ?*SMDATA, dwFlags: u32) HRESULT {
                return @as(*const IShellMenu.VTable, @ptrCast(self.vtable)).InvalidateItem(@as(*const IShellMenu, @ptrCast(self)), psmd, dwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellMenu_GetState(self: *const T, psmd: ?*SMDATA) HRESULT {
                return @as(*const IShellMenu.VTable, @ptrCast(self.vtable)).GetState(@as(*const IShellMenu, @ptrCast(self)), psmd);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellMenu_SetMenuToolbar(self: *const T, punk: ?*IUnknown, dwFlags: u32) HRESULT {
                return @as(*const IShellMenu.VTable, @ptrCast(self.vtable)).SetMenuToolbar(@as(*const IShellMenu, @ptrCast(self)), punk, dwFlags);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const KF_CATEGORY = enum(i32) {
    VIRTUAL = 1,
    FIXED = 2,
    COMMON = 3,
    PERUSER = 4,
};
pub const KF_CATEGORY_VIRTUAL = KF_CATEGORY.VIRTUAL;
pub const KF_CATEGORY_FIXED = KF_CATEGORY.FIXED;
pub const KF_CATEGORY_COMMON = KF_CATEGORY.COMMON;
pub const KF_CATEGORY_PERUSER = KF_CATEGORY.PERUSER;

pub const _KF_DEFINITION_FLAGS = enum(i32) {
    LOCAL_REDIRECT_ONLY = 2,
    ROAMABLE = 4,
    PRECREATE = 8,
    STREAM = 16,
    PUBLISHEXPANDEDPATH = 32,
    NO_REDIRECT_UI = 64,
};
pub const KFDF_LOCAL_REDIRECT_ONLY = _KF_DEFINITION_FLAGS.LOCAL_REDIRECT_ONLY;
pub const KFDF_ROAMABLE = _KF_DEFINITION_FLAGS.ROAMABLE;
pub const KFDF_PRECREATE = _KF_DEFINITION_FLAGS.PRECREATE;
pub const KFDF_STREAM = _KF_DEFINITION_FLAGS.STREAM;
pub const KFDF_PUBLISHEXPANDEDPATH = _KF_DEFINITION_FLAGS.PUBLISHEXPANDEDPATH;
pub const KFDF_NO_REDIRECT_UI = _KF_DEFINITION_FLAGS.NO_REDIRECT_UI;

pub const _KF_REDIRECT_FLAGS = enum(i32) {
    USER_EXCLUSIVE = 1,
    COPY_SOURCE_DACL = 2,
    OWNER_USER = 4,
    SET_OWNER_EXPLICIT = 8,
    CHECK_ONLY = 16,
    WITH_UI = 32,
    UNPIN = 64,
    PIN = 128,
    COPY_CONTENTS = 512,
    DEL_SOURCE_CONTENTS = 1024,
    EXCLUDE_ALL_KNOWN_SUBFOLDERS = 2048,
};
pub const KF_REDIRECT_USER_EXCLUSIVE = _KF_REDIRECT_FLAGS.USER_EXCLUSIVE;
pub const KF_REDIRECT_COPY_SOURCE_DACL = _KF_REDIRECT_FLAGS.COPY_SOURCE_DACL;
pub const KF_REDIRECT_OWNER_USER = _KF_REDIRECT_FLAGS.OWNER_USER;
pub const KF_REDIRECT_SET_OWNER_EXPLICIT = _KF_REDIRECT_FLAGS.SET_OWNER_EXPLICIT;
pub const KF_REDIRECT_CHECK_ONLY = _KF_REDIRECT_FLAGS.CHECK_ONLY;
pub const KF_REDIRECT_WITH_UI = _KF_REDIRECT_FLAGS.WITH_UI;
pub const KF_REDIRECT_UNPIN = _KF_REDIRECT_FLAGS.UNPIN;
pub const KF_REDIRECT_PIN = _KF_REDIRECT_FLAGS.PIN;
pub const KF_REDIRECT_COPY_CONTENTS = _KF_REDIRECT_FLAGS.COPY_CONTENTS;
pub const KF_REDIRECT_DEL_SOURCE_CONTENTS = _KF_REDIRECT_FLAGS.DEL_SOURCE_CONTENTS;
pub const KF_REDIRECT_EXCLUDE_ALL_KNOWN_SUBFOLDERS = _KF_REDIRECT_FLAGS.EXCLUDE_ALL_KNOWN_SUBFOLDERS;

pub const _KF_REDIRECTION_CAPABILITIES = enum(i32) {
    ALLOW_ALL = 255,
    REDIRECTABLE = 1,
    DENY_ALL = 1048320,
    DENY_POLICY_REDIRECTED = 256,
    DENY_POLICY = 512,
    DENY_PERMISSIONS = 1024,
};
pub const KF_REDIRECTION_CAPABILITIES_ALLOW_ALL = _KF_REDIRECTION_CAPABILITIES.ALLOW_ALL;
pub const KF_REDIRECTION_CAPABILITIES_REDIRECTABLE = _KF_REDIRECTION_CAPABILITIES.REDIRECTABLE;
pub const KF_REDIRECTION_CAPABILITIES_DENY_ALL = _KF_REDIRECTION_CAPABILITIES.DENY_ALL;
pub const KF_REDIRECTION_CAPABILITIES_DENY_POLICY_REDIRECTED = _KF_REDIRECTION_CAPABILITIES.DENY_POLICY_REDIRECTED;
pub const KF_REDIRECTION_CAPABILITIES_DENY_POLICY = _KF_REDIRECTION_CAPABILITIES.DENY_POLICY;
pub const KF_REDIRECTION_CAPABILITIES_DENY_PERMISSIONS = _KF_REDIRECTION_CAPABILITIES.DENY_PERMISSIONS;

pub const KNOWNFOLDER_DEFINITION = extern struct {
    category: KF_CATEGORY,
    pszName: ?PWSTR,
    pszDescription: ?PWSTR,
    fidParent: Guid,
    pszRelativePath: ?PWSTR,
    pszParsingName: ?PWSTR,
    pszTooltip: ?PWSTR,
    pszLocalizedName: ?PWSTR,
    pszIcon: ?PWSTR,
    pszSecurity: ?PWSTR,
    dwAttributes: u32,
    kfdFlags: u32,
    ftidType: Guid,
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IKnownFolder_Value = Guid.initString("3aa7af7e-9b36-420c-a8e3-f77d4674a488");
pub const IID_IKnownFolder = &IID_IKnownFolder_Value;
pub const IKnownFolder = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IKnownFolder,
                pkfid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IKnownFolder,
                pkfid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCategory: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IKnownFolder,
                pCategory: ?*KF_CATEGORY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IKnownFolder,
                pCategory: ?*KF_CATEGORY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetShellItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IKnownFolder,
                dwFlags: u32,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IKnownFolder,
                dwFlags: u32,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPath: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IKnownFolder,
                dwFlags: u32,
                ppszPath: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IKnownFolder,
                dwFlags: u32,
                ppszPath: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPath: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IKnownFolder,
                dwFlags: u32,
                pszPath: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IKnownFolder,
                dwFlags: u32,
                pszPath: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIDList: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IKnownFolder,
                dwFlags: u32,
                ppidl: ?*?*ITEMIDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IKnownFolder,
                dwFlags: u32,
                ppidl: ?*?*ITEMIDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFolderType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IKnownFolder,
                pftid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IKnownFolder,
                pftid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRedirectionCapabilities: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IKnownFolder,
                pCapabilities: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IKnownFolder,
                pCapabilities: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFolderDefinition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IKnownFolder,
                pKFD: ?*KNOWNFOLDER_DEFINITION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IKnownFolder,
                pKFD: ?*KNOWNFOLDER_DEFINITION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IKnownFolder_GetId(self: *const T, pkfid: ?*Guid) HRESULT {
                return @as(*const IKnownFolder.VTable, @ptrCast(self.vtable)).GetId(@as(*const IKnownFolder, @ptrCast(self)), pkfid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IKnownFolder_GetCategory(self: *const T, pCategory: ?*KF_CATEGORY) HRESULT {
                return @as(*const IKnownFolder.VTable, @ptrCast(self.vtable)).GetCategory(@as(*const IKnownFolder, @ptrCast(self)), pCategory);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IKnownFolder_GetShellItem(self: *const T, dwFlags: u32, riid: ?*const Guid, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const IKnownFolder.VTable, @ptrCast(self.vtable)).GetShellItem(@as(*const IKnownFolder, @ptrCast(self)), dwFlags, riid, ppv);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IKnownFolder_GetPath(self: *const T, dwFlags: u32, ppszPath: ?*?PWSTR) HRESULT {
                return @as(*const IKnownFolder.VTable, @ptrCast(self.vtable)).GetPath(@as(*const IKnownFolder, @ptrCast(self)), dwFlags, ppszPath);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IKnownFolder_SetPath(self: *const T, dwFlags: u32, pszPath: ?[*:0]const u16) HRESULT {
                return @as(*const IKnownFolder.VTable, @ptrCast(self.vtable)).SetPath(@as(*const IKnownFolder, @ptrCast(self)), dwFlags, pszPath);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IKnownFolder_GetIDList(self: *const T, dwFlags: u32, ppidl: ?*?*ITEMIDLIST) HRESULT {
                return @as(*const IKnownFolder.VTable, @ptrCast(self.vtable)).GetIDList(@as(*const IKnownFolder, @ptrCast(self)), dwFlags, ppidl);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IKnownFolder_GetFolderType(self: *const T, pftid: ?*Guid) HRESULT {
                return @as(*const IKnownFolder.VTable, @ptrCast(self.vtable)).GetFolderType(@as(*const IKnownFolder, @ptrCast(self)), pftid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IKnownFolder_GetRedirectionCapabilities(self: *const T, pCapabilities: ?*u32) HRESULT {
                return @as(*const IKnownFolder.VTable, @ptrCast(self.vtable)).GetRedirectionCapabilities(@as(*const IKnownFolder, @ptrCast(self)), pCapabilities);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IKnownFolder_GetFolderDefinition(self: *const T, pKFD: ?*KNOWNFOLDER_DEFINITION) HRESULT {
                return @as(*const IKnownFolder.VTable, @ptrCast(self.vtable)).GetFolderDefinition(@as(*const IKnownFolder, @ptrCast(self)), pKFD);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const FFFP_MODE = enum(i32) {
    EXACTMATCH = 0,
    NEARESTPARENTMATCH = 1,
};
pub const FFFP_EXACTMATCH = FFFP_MODE.EXACTMATCH;
pub const FFFP_NEARESTPARENTMATCH = FFFP_MODE.NEARESTPARENTMATCH;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IKnownFolderManager_Value = Guid.initString("8be2d872-86aa-4d47-b776-32cca40c7018");
pub const IID_IKnownFolderManager = &IID_IKnownFolderManager_Value;
pub const IKnownFolderManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        FolderIdFromCsidl: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IKnownFolderManager,
                nCsidl: i32,
                pfid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IKnownFolderManager,
                nCsidl: i32,
                pfid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FolderIdToCsidl: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IKnownFolderManager,
                rfid: ?*const Guid,
                pnCsidl: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IKnownFolderManager,
                rfid: ?*const Guid,
                pnCsidl: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFolderIds: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IKnownFolderManager,
                ppKFId: [*]?*Guid,
                pCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IKnownFolderManager,
                ppKFId: [*]?*Guid,
                pCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFolder: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IKnownFolderManager,
                rfid: ?*const Guid,
                ppkf: ?*?*IKnownFolder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IKnownFolderManager,
                rfid: ?*const Guid,
                ppkf: ?*?*IKnownFolder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFolderByName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IKnownFolderManager,
                pszCanonicalName: ?[*:0]const u16,
                ppkf: ?*?*IKnownFolder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IKnownFolderManager,
                pszCanonicalName: ?[*:0]const u16,
                ppkf: ?*?*IKnownFolder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RegisterFolder: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IKnownFolderManager,
                rfid: ?*const Guid,
                pKFD: ?*const KNOWNFOLDER_DEFINITION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IKnownFolderManager,
                rfid: ?*const Guid,
                pKFD: ?*const KNOWNFOLDER_DEFINITION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnregisterFolder: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IKnownFolderManager,
                rfid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IKnownFolderManager,
                rfid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindFolderFromPath: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IKnownFolderManager,
                pszPath: ?[*:0]const u16,
                mode: FFFP_MODE,
                ppkf: ?*?*IKnownFolder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IKnownFolderManager,
                pszPath: ?[*:0]const u16,
                mode: FFFP_MODE,
                ppkf: ?*?*IKnownFolder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindFolderFromIDList: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IKnownFolderManager,
                pidl: ?*ITEMIDLIST,
                ppkf: ?*?*IKnownFolder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IKnownFolderManager,
                pidl: ?*ITEMIDLIST,
                ppkf: ?*?*IKnownFolder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Redirect: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IKnownFolderManager,
                rfid: ?*const Guid,
                hwnd: ?HWND,
                flags: u32,
                pszTargetPath: ?[*:0]const u16,
                cFolders: u32,
                pExclusion: ?[*]const Guid,
                ppszError: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IKnownFolderManager,
                rfid: ?*const Guid,
                hwnd: ?HWND,
                flags: u32,
                pszTargetPath: ?[*:0]const u16,
                cFolders: u32,
                pExclusion: ?[*]const Guid,
                ppszError: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IKnownFolderManager_FolderIdFromCsidl(self: *const T, nCsidl: i32, pfid: ?*Guid) HRESULT {
                return @as(*const IKnownFolderManager.VTable, @ptrCast(self.vtable)).FolderIdFromCsidl(@as(*const IKnownFolderManager, @ptrCast(self)), nCsidl, pfid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IKnownFolderManager_FolderIdToCsidl(self: *const T, rfid: ?*const Guid, pnCsidl: ?*i32) HRESULT {
                return @as(*const IKnownFolderManager.VTable, @ptrCast(self.vtable)).FolderIdToCsidl(@as(*const IKnownFolderManager, @ptrCast(self)), rfid, pnCsidl);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IKnownFolderManager_GetFolderIds(self: *const T, ppKFId: [*]?*Guid, pCount: ?*u32) HRESULT {
                return @as(*const IKnownFolderManager.VTable, @ptrCast(self.vtable)).GetFolderIds(@as(*const IKnownFolderManager, @ptrCast(self)), ppKFId, pCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IKnownFolderManager_GetFolder(self: *const T, rfid: ?*const Guid, ppkf: ?*?*IKnownFolder) HRESULT {
                return @as(*const IKnownFolderManager.VTable, @ptrCast(self.vtable)).GetFolder(@as(*const IKnownFolderManager, @ptrCast(self)), rfid, ppkf);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IKnownFolderManager_GetFolderByName(self: *const T, pszCanonicalName: ?[*:0]const u16, ppkf: ?*?*IKnownFolder) HRESULT {
                return @as(*const IKnownFolderManager.VTable, @ptrCast(self.vtable)).GetFolderByName(@as(*const IKnownFolderManager, @ptrCast(self)), pszCanonicalName, ppkf);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IKnownFolderManager_RegisterFolder(self: *const T, rfid: ?*const Guid, pKFD: ?*const KNOWNFOLDER_DEFINITION) HRESULT {
                return @as(*const IKnownFolderManager.VTable, @ptrCast(self.vtable)).RegisterFolder(@as(*const IKnownFolderManager, @ptrCast(self)), rfid, pKFD);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IKnownFolderManager_UnregisterFolder(self: *const T, rfid: ?*const Guid) HRESULT {
                return @as(*const IKnownFolderManager.VTable, @ptrCast(self.vtable)).UnregisterFolder(@as(*const IKnownFolderManager, @ptrCast(self)), rfid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IKnownFolderManager_FindFolderFromPath(self: *const T, pszPath: ?[*:0]const u16, mode: FFFP_MODE, ppkf: ?*?*IKnownFolder) HRESULT {
                return @as(*const IKnownFolderManager.VTable, @ptrCast(self.vtable)).FindFolderFromPath(@as(*const IKnownFolderManager, @ptrCast(self)), pszPath, mode, ppkf);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IKnownFolderManager_FindFolderFromIDList(self: *const T, pidl: ?*ITEMIDLIST, ppkf: ?*?*IKnownFolder) HRESULT {
                return @as(*const IKnownFolderManager.VTable, @ptrCast(self.vtable)).FindFolderFromIDList(@as(*const IKnownFolderManager, @ptrCast(self)), pidl, ppkf);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IKnownFolderManager_Redirect(self: *const T, rfid: ?*const Guid, hwnd: ?HWND, flags: u32, pszTargetPath: ?[*:0]const u16, cFolders: u32, pExclusion: ?[*]const Guid, ppszError: ?*?PWSTR) HRESULT {
                return @as(*const IKnownFolderManager.VTable, @ptrCast(self.vtable)).Redirect(@as(*const IKnownFolderManager, @ptrCast(self)), rfid, hwnd, flags, pszTargetPath, cFolders, pExclusion, ppszError);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SHARE_ROLE = enum(i32) {
    INVALID = -1,
    READER = 0,
    CONTRIBUTOR = 1,
    CO_OWNER = 2,
    OWNER = 3,
    CUSTOM = 4,
    MIXED = 5,
};
pub const SHARE_ROLE_INVALID = SHARE_ROLE.INVALID;
pub const SHARE_ROLE_READER = SHARE_ROLE.READER;
pub const SHARE_ROLE_CONTRIBUTOR = SHARE_ROLE.CONTRIBUTOR;
pub const SHARE_ROLE_CO_OWNER = SHARE_ROLE.CO_OWNER;
pub const SHARE_ROLE_OWNER = SHARE_ROLE.OWNER;
pub const SHARE_ROLE_CUSTOM = SHARE_ROLE.CUSTOM;
pub const SHARE_ROLE_MIXED = SHARE_ROLE.MIXED;

pub const DEF_SHARE_ID = enum(i32) {
    USERS = 1,
    PUBLIC = 2,
};
pub const DEFSHAREID_USERS = DEF_SHARE_ID.USERS;
pub const DEFSHAREID_PUBLIC = DEF_SHARE_ID.PUBLIC;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ISharingConfigurationManager_Value = Guid.initString("b4cd448a-9c86-4466-9201-2e62105b87ae");
pub const IID_ISharingConfigurationManager = &IID_ISharingConfigurationManager_Value;
pub const ISharingConfigurationManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateShare: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISharingConfigurationManager,
                dsid: DEF_SHARE_ID,
                role: SHARE_ROLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISharingConfigurationManager,
                dsid: DEF_SHARE_ID,
                role: SHARE_ROLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeleteShare: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISharingConfigurationManager,
                dsid: DEF_SHARE_ID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISharingConfigurationManager,
                dsid: DEF_SHARE_ID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ShareExists: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISharingConfigurationManager,
                dsid: DEF_SHARE_ID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISharingConfigurationManager,
                dsid: DEF_SHARE_ID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSharePermissions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISharingConfigurationManager,
                dsid: DEF_SHARE_ID,
                pRole: ?*SHARE_ROLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISharingConfigurationManager,
                dsid: DEF_SHARE_ID,
                pRole: ?*SHARE_ROLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SharePrinters: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISharingConfigurationManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISharingConfigurationManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StopSharingPrinters: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISharingConfigurationManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISharingConfigurationManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ArePrintersShared: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISharingConfigurationManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISharingConfigurationManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISharingConfigurationManager_CreateShare(self: *const T, dsid: DEF_SHARE_ID, role: SHARE_ROLE) HRESULT {
                return @as(*const ISharingConfigurationManager.VTable, @ptrCast(self.vtable)).CreateShare(@as(*const ISharingConfigurationManager, @ptrCast(self)), dsid, role);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISharingConfigurationManager_DeleteShare(self: *const T, dsid: DEF_SHARE_ID) HRESULT {
                return @as(*const ISharingConfigurationManager.VTable, @ptrCast(self.vtable)).DeleteShare(@as(*const ISharingConfigurationManager, @ptrCast(self)), dsid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISharingConfigurationManager_ShareExists(self: *const T, dsid: DEF_SHARE_ID) HRESULT {
                return @as(*const ISharingConfigurationManager.VTable, @ptrCast(self.vtable)).ShareExists(@as(*const ISharingConfigurationManager, @ptrCast(self)), dsid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISharingConfigurationManager_GetSharePermissions(self: *const T, dsid: DEF_SHARE_ID, pRole: ?*SHARE_ROLE) HRESULT {
                return @as(*const ISharingConfigurationManager.VTable, @ptrCast(self.vtable)).GetSharePermissions(@as(*const ISharingConfigurationManager, @ptrCast(self)), dsid, pRole);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISharingConfigurationManager_SharePrinters(self: *const T) HRESULT {
                return @as(*const ISharingConfigurationManager.VTable, @ptrCast(self.vtable)).SharePrinters(@as(*const ISharingConfigurationManager, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISharingConfigurationManager_StopSharingPrinters(self: *const T) HRESULT {
                return @as(*const ISharingConfigurationManager.VTable, @ptrCast(self.vtable)).StopSharingPrinters(@as(*const ISharingConfigurationManager, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISharingConfigurationManager_ArePrintersShared(self: *const T) HRESULT {
                return @as(*const ISharingConfigurationManager.VTable, @ptrCast(self.vtable)).ArePrintersShared(@as(*const ISharingConfigurationManager, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IRelatedItem_Value = Guid.initString("a73ce67a-8ab1-44f1-8d43-d2fcbf6b1cd0");
pub const IID_IRelatedItem = &IID_IRelatedItem_Value;
pub const IRelatedItem = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetItemIDList: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRelatedItem,
                ppidl: ?*?*ITEMIDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRelatedItem,
                ppidl: ?*?*ITEMIDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRelatedItem,
                ppsi: ?*?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRelatedItem,
                ppsi: ?*?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRelatedItem_GetItemIDList(self: *const T, ppidl: ?*?*ITEMIDLIST) HRESULT {
                return @as(*const IRelatedItem.VTable, @ptrCast(self.vtable)).GetItemIDList(@as(*const IRelatedItem, @ptrCast(self)), ppidl);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRelatedItem_GetItem(self: *const T, ppsi: ?*?*IShellItem) HRESULT {
                return @as(*const IRelatedItem.VTable, @ptrCast(self.vtable)).GetItem(@as(*const IRelatedItem, @ptrCast(self)), ppsi);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IIdentityName_Value = Guid.initString("7d903fca-d6f9-4810-8332-946c0177e247");
pub const IID_IIdentityName = &IID_IIdentityName_Value;
pub const IIdentityName = extern struct {
    pub const VTable = extern struct {
        base: IRelatedItem.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IRelatedItem.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IDelegateItem_Value = Guid.initString("3c5a1c94-c951-4cb7-bb6d-3b93f30cce93");
pub const IID_IDelegateItem = &IID_IDelegateItem_Value;
pub const IDelegateItem = extern struct {
    pub const VTable = extern struct {
        base: IRelatedItem.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IRelatedItem.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ICurrentItem_Value = Guid.initString("240a7174-d653-4a1d-a6d3-d4943cfbfe3d");
pub const IID_ICurrentItem = &IID_ICurrentItem_Value;
pub const ICurrentItem = extern struct {
    pub const VTable = extern struct {
        base: IRelatedItem.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IRelatedItem.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ITransferMediumItem_Value = Guid.initString("77f295d5-2d6f-4e19-b8ae-322f3e721ab5");
pub const IID_ITransferMediumItem = &IID_ITransferMediumItem_Value;
pub const ITransferMediumItem = extern struct {
    pub const VTable = extern struct {
        base: IRelatedItem.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IRelatedItem.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IDisplayItem_Value = Guid.initString("c6fd5997-9f6b-4888-8703-94e80e8cde3f");
pub const IID_IDisplayItem = &IID_IDisplayItem_Value;
pub const IDisplayItem = extern struct {
    pub const VTable = extern struct {
        base: IRelatedItem.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IRelatedItem.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IViewStateIdentityItem_Value = Guid.initString("9d264146-a94f-4195-9f9f-3bb12ce0c955");
pub const IID_IViewStateIdentityItem = &IID_IViewStateIdentityItem_Value;
pub const IViewStateIdentityItem = extern struct {
    pub const VTable = extern struct {
        base: IRelatedItem.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IRelatedItem.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IPreviewItem_Value = Guid.initString("36149969-0a8f-49c8-8b00-4aecb20222fb");
pub const IID_IPreviewItem = &IID_IPreviewItem_Value;
pub const IPreviewItem = extern struct {
    pub const VTable = extern struct {
        base: IRelatedItem.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IRelatedItem.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IDestinationStreamFactory_Value = Guid.initString("8a87781b-39a7-4a1f-aab3-a39b9c34a7d9");
pub const IID_IDestinationStreamFactory = &IID_IDestinationStreamFactory_Value;
pub const IDestinationStreamFactory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDestinationStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDestinationStreamFactory,
                ppstm: ?*?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDestinationStreamFactory,
                ppstm: ?*?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDestinationStreamFactory_GetDestinationStream(self: *const T, ppstm: ?*?*IStream) HRESULT {
                return @as(*const IDestinationStreamFactory.VTable, @ptrCast(self.vtable)).GetDestinationStream(@as(*const IDestinationStreamFactory, @ptrCast(self)), ppstm);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ICreateProcessInputs_Value = Guid.initString("f6ef6140-e26f-4d82-bac4-e9ba5fd239a8");
pub const IID_ICreateProcessInputs = &IID_ICreateProcessInputs_Value;
pub const ICreateProcessInputs = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCreateFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICreateProcessInputs,
                pdwCreationFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICreateProcessInputs,
                pdwCreationFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCreateFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICreateProcessInputs,
                dwCreationFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICreateProcessInputs,
                dwCreationFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddCreateFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICreateProcessInputs,
                dwCreationFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICreateProcessInputs,
                dwCreationFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetHotKey: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICreateProcessInputs,
                wHotKey: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICreateProcessInputs,
                wHotKey: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddStartupFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICreateProcessInputs,
                dwStartupInfoFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICreateProcessInputs,
                dwStartupInfoFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTitle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICreateProcessInputs,
                pszTitle: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICreateProcessInputs,
                pszTitle: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEnvironmentVariable: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICreateProcessInputs,
                pszName: ?[*:0]const u16,
                pszValue: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICreateProcessInputs,
                pszName: ?[*:0]const u16,
                pszValue: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICreateProcessInputs_GetCreateFlags(self: *const T, pdwCreationFlags: ?*u32) HRESULT {
                return @as(*const ICreateProcessInputs.VTable, @ptrCast(self.vtable)).GetCreateFlags(@as(*const ICreateProcessInputs, @ptrCast(self)), pdwCreationFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICreateProcessInputs_SetCreateFlags(self: *const T, dwCreationFlags: u32) HRESULT {
                return @as(*const ICreateProcessInputs.VTable, @ptrCast(self.vtable)).SetCreateFlags(@as(*const ICreateProcessInputs, @ptrCast(self)), dwCreationFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICreateProcessInputs_AddCreateFlags(self: *const T, dwCreationFlags: u32) HRESULT {
                return @as(*const ICreateProcessInputs.VTable, @ptrCast(self.vtable)).AddCreateFlags(@as(*const ICreateProcessInputs, @ptrCast(self)), dwCreationFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICreateProcessInputs_SetHotKey(self: *const T, wHotKey: u16) HRESULT {
                return @as(*const ICreateProcessInputs.VTable, @ptrCast(self.vtable)).SetHotKey(@as(*const ICreateProcessInputs, @ptrCast(self)), wHotKey);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICreateProcessInputs_AddStartupFlags(self: *const T, dwStartupInfoFlags: u32) HRESULT {
                return @as(*const ICreateProcessInputs.VTable, @ptrCast(self.vtable)).AddStartupFlags(@as(*const ICreateProcessInputs, @ptrCast(self)), dwStartupInfoFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICreateProcessInputs_SetTitle(self: *const T, pszTitle: ?[*:0]const u16) HRESULT {
                return @as(*const ICreateProcessInputs.VTable, @ptrCast(self.vtable)).SetTitle(@as(*const ICreateProcessInputs, @ptrCast(self)), pszTitle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICreateProcessInputs_SetEnvironmentVariable(self: *const T, pszName: ?[*:0]const u16, pszValue: ?[*:0]const u16) HRESULT {
                return @as(*const ICreateProcessInputs.VTable, @ptrCast(self.vtable)).SetEnvironmentVariable(@as(*const ICreateProcessInputs, @ptrCast(self)), pszName, pszValue);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ICreatingProcess_Value = Guid.initString("c2b937a9-3110-4398-8a56-f34c6342d244");
pub const IID_ICreatingProcess = &IID_ICreatingProcess_Value;
pub const ICreatingProcess = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnCreating: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICreatingProcess,
                pcpi: ?*ICreateProcessInputs,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICreatingProcess,
                pcpi: ?*ICreateProcessInputs,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICreatingProcess_OnCreating(self: *const T, pcpi: ?*ICreateProcessInputs) HRESULT {
                return @as(*const ICreatingProcess.VTable, @ptrCast(self.vtable)).OnCreating(@as(*const ICreatingProcess, @ptrCast(self)), pcpi);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ILaunchUIContext_Value = Guid.initString("1791e8f6-21c7-4340-882a-a6a93e3fd73b");
pub const IID_ILaunchUIContext = &IID_ILaunchUIContext_Value;
pub const ILaunchUIContext = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetAssociatedWindow: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ILaunchUIContext,
                value: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ILaunchUIContext,
                value: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTabGroupingPreference: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ILaunchUIContext,
                value: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ILaunchUIContext,
                value: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ILaunchUIContext_SetAssociatedWindow(self: *const T, value: ?HWND) HRESULT {
                return @as(*const ILaunchUIContext.VTable, @ptrCast(self.vtable)).SetAssociatedWindow(@as(*const ILaunchUIContext, @ptrCast(self)), value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ILaunchUIContext_SetTabGroupingPreference(self: *const T, value: u32) HRESULT {
                return @as(*const ILaunchUIContext.VTable, @ptrCast(self.vtable)).SetTabGroupingPreference(@as(*const ILaunchUIContext, @ptrCast(self)), value);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ILaunchUIContextProvider_Value = Guid.initString("0d12c4c8-a3d9-4e24-94c1-0e20c5a956c4");
pub const IID_ILaunchUIContextProvider = &IID_ILaunchUIContextProvider_Value;
pub const ILaunchUIContextProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        UpdateContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ILaunchUIContextProvider,
                context: ?*ILaunchUIContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ILaunchUIContextProvider,
                context: ?*ILaunchUIContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ILaunchUIContextProvider_UpdateContext(self: *const T, context: ?*ILaunchUIContext) HRESULT {
                return @as(*const ILaunchUIContextProvider.VTable, @ptrCast(self.vtable)).UpdateContext(@as(*const ILaunchUIContextProvider, @ptrCast(self)), context);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const _NMCII_FLAGS = enum(i32) {
    NONE = 0,
    ITEMS = 1,
    FOLDERS = 2,
};
pub const NMCII_NONE = _NMCII_FLAGS.NONE;
pub const NMCII_ITEMS = _NMCII_FLAGS.ITEMS;
pub const NMCII_FOLDERS = _NMCII_FLAGS.FOLDERS;

pub const _NMCSAEI_FLAGS = enum(i32) {
    SELECT = 0,
    EDIT = 1,
};
pub const NMCSAEI_SELECT = _NMCSAEI_FLAGS.SELECT;
pub const NMCSAEI_EDIT = _NMCSAEI_FLAGS.EDIT;

// TODO: this type is limited to platform 'windows6.1'
const IID_INewMenuClient_Value = Guid.initString("dcb07fdc-3bb5-451c-90be-966644fed7b0");
pub const IID_INewMenuClient = &IID_INewMenuClient_Value;
pub const INewMenuClient = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IncludeItems: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INewMenuClient,
                pflags: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INewMenuClient,
                pflags: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SelectAndEditItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INewMenuClient,
                pidlItem: ?*ITEMIDLIST,
                flags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INewMenuClient,
                pidlItem: ?*ITEMIDLIST,
                flags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INewMenuClient_IncludeItems(self: *const T, pflags: ?*i32) HRESULT {
                return @as(*const INewMenuClient.VTable, @ptrCast(self.vtable)).IncludeItems(@as(*const INewMenuClient, @ptrCast(self)), pflags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INewMenuClient_SelectAndEditItem(self: *const T, pidlItem: ?*ITEMIDLIST, flags: i32) HRESULT {
                return @as(*const INewMenuClient.VTable, @ptrCast(self.vtable)).SelectAndEditItem(@as(*const INewMenuClient, @ptrCast(self)), pidlItem, flags);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IInitializeWithBindCtx_Value = Guid.initString("71c0d2bc-726d-45cc-a6c0-2e31c1db2159");
pub const IID_IInitializeWithBindCtx = &IID_IInitializeWithBindCtx_Value;
pub const IInitializeWithBindCtx = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInitializeWithBindCtx,
                pbc: ?*IBindCtx,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInitializeWithBindCtx,
                pbc: ?*IBindCtx,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInitializeWithBindCtx_Initialize(self: *const T, pbc: ?*IBindCtx) HRESULT {
                return @as(*const IInitializeWithBindCtx.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IInitializeWithBindCtx, @ptrCast(self)), pbc);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IShellItemFilter_Value = Guid.initString("2659b475-eeb8-48b7-8f07-b378810f48cf");
pub const IID_IShellItemFilter = &IID_IShellItemFilter_Value;
pub const IShellItemFilter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IncludeItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellItemFilter,
                psi: ?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellItemFilter,
                psi: ?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEnumFlagsForItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellItemFilter,
                psi: ?*IShellItem,
                pgrfFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellItemFilter,
                psi: ?*IShellItem,
                pgrfFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellItemFilter_IncludeItem(self: *const T, psi: ?*IShellItem) HRESULT {
                return @as(*const IShellItemFilter.VTable, @ptrCast(self.vtable)).IncludeItem(@as(*const IShellItemFilter, @ptrCast(self)), psi);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellItemFilter_GetEnumFlagsForItem(self: *const T, psi: ?*IShellItem, pgrfFlags: ?*u32) HRESULT {
                return @as(*const IShellItemFilter.VTable, @ptrCast(self.vtable)).GetEnumFlagsForItem(@as(*const IShellItemFilter, @ptrCast(self)), psi, pgrfFlags);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const _NSTCSTYLE = enum(i32) {
    HASEXPANDOS = 1,
    HASLINES = 2,
    SINGLECLICKEXPAND = 4,
    FULLROWSELECT = 8,
    SPRINGEXPAND = 16,
    HORIZONTALSCROLL = 32,
    ROOTHASEXPANDO = 64,
    SHOWSELECTIONALWAYS = 128,
    NOINFOTIP = 512,
    EVENHEIGHT = 1024,
    NOREPLACEOPEN = 2048,
    DISABLEDRAGDROP = 4096,
    NOORDERSTREAM = 8192,
    RICHTOOLTIP = 16384,
    BORDER = 32768,
    NOEDITLABELS = 65536,
    TABSTOP = 131072,
    FAVORITESMODE = 524288,
    AUTOHSCROLL = 1048576,
    FADEINOUTEXPANDOS = 2097152,
    EMPTYTEXT = 4194304,
    CHECKBOXES = 8388608,
    PARTIALCHECKBOXES = 16777216,
    EXCLUSIONCHECKBOXES = 33554432,
    DIMMEDCHECKBOXES = 67108864,
    NOINDENTCHECKS = 134217728,
    ALLOWJUNCTIONS = 268435456,
    SHOWTABSBUTTON = 536870912,
    SHOWDELETEBUTTON = 1073741824,
    SHOWREFRESHBUTTON = -2147483648,
};
pub const NSTCS_HASEXPANDOS = _NSTCSTYLE.HASEXPANDOS;
pub const NSTCS_HASLINES = _NSTCSTYLE.HASLINES;
pub const NSTCS_SINGLECLICKEXPAND = _NSTCSTYLE.SINGLECLICKEXPAND;
pub const NSTCS_FULLROWSELECT = _NSTCSTYLE.FULLROWSELECT;
pub const NSTCS_SPRINGEXPAND = _NSTCSTYLE.SPRINGEXPAND;
pub const NSTCS_HORIZONTALSCROLL = _NSTCSTYLE.HORIZONTALSCROLL;
pub const NSTCS_ROOTHASEXPANDO = _NSTCSTYLE.ROOTHASEXPANDO;
pub const NSTCS_SHOWSELECTIONALWAYS = _NSTCSTYLE.SHOWSELECTIONALWAYS;
pub const NSTCS_NOINFOTIP = _NSTCSTYLE.NOINFOTIP;
pub const NSTCS_EVENHEIGHT = _NSTCSTYLE.EVENHEIGHT;
pub const NSTCS_NOREPLACEOPEN = _NSTCSTYLE.NOREPLACEOPEN;
pub const NSTCS_DISABLEDRAGDROP = _NSTCSTYLE.DISABLEDRAGDROP;
pub const NSTCS_NOORDERSTREAM = _NSTCSTYLE.NOORDERSTREAM;
pub const NSTCS_RICHTOOLTIP = _NSTCSTYLE.RICHTOOLTIP;
pub const NSTCS_BORDER = _NSTCSTYLE.BORDER;
pub const NSTCS_NOEDITLABELS = _NSTCSTYLE.NOEDITLABELS;
pub const NSTCS_TABSTOP = _NSTCSTYLE.TABSTOP;
pub const NSTCS_FAVORITESMODE = _NSTCSTYLE.FAVORITESMODE;
pub const NSTCS_AUTOHSCROLL = _NSTCSTYLE.AUTOHSCROLL;
pub const NSTCS_FADEINOUTEXPANDOS = _NSTCSTYLE.FADEINOUTEXPANDOS;
pub const NSTCS_EMPTYTEXT = _NSTCSTYLE.EMPTYTEXT;
pub const NSTCS_CHECKBOXES = _NSTCSTYLE.CHECKBOXES;
pub const NSTCS_PARTIALCHECKBOXES = _NSTCSTYLE.PARTIALCHECKBOXES;
pub const NSTCS_EXCLUSIONCHECKBOXES = _NSTCSTYLE.EXCLUSIONCHECKBOXES;
pub const NSTCS_DIMMEDCHECKBOXES = _NSTCSTYLE.DIMMEDCHECKBOXES;
pub const NSTCS_NOINDENTCHECKS = _NSTCSTYLE.NOINDENTCHECKS;
pub const NSTCS_ALLOWJUNCTIONS = _NSTCSTYLE.ALLOWJUNCTIONS;
pub const NSTCS_SHOWTABSBUTTON = _NSTCSTYLE.SHOWTABSBUTTON;
pub const NSTCS_SHOWDELETEBUTTON = _NSTCSTYLE.SHOWDELETEBUTTON;
pub const NSTCS_SHOWREFRESHBUTTON = _NSTCSTYLE.SHOWREFRESHBUTTON;

pub const _NSTCROOTSTYLE = enum(i32) {
    VISIBLE = 0,
    HIDDEN = 1,
    EXPANDED = 2,
};
pub const NSTCRS_VISIBLE = _NSTCROOTSTYLE.VISIBLE;
pub const NSTCRS_HIDDEN = _NSTCROOTSTYLE.HIDDEN;
pub const NSTCRS_EXPANDED = _NSTCROOTSTYLE.EXPANDED;

pub const _NSTCITEMSTATE = enum(i32) {
    NONE = 0,
    SELECTED = 1,
    EXPANDED = 2,
    BOLD = 4,
    DISABLED = 8,
    SELECTEDNOEXPAND = 16,
};
pub const NSTCIS_NONE = _NSTCITEMSTATE.NONE;
pub const NSTCIS_SELECTED = _NSTCITEMSTATE.SELECTED;
pub const NSTCIS_EXPANDED = _NSTCITEMSTATE.EXPANDED;
pub const NSTCIS_BOLD = _NSTCITEMSTATE.BOLD;
pub const NSTCIS_DISABLED = _NSTCITEMSTATE.DISABLED;
pub const NSTCIS_SELECTEDNOEXPAND = _NSTCITEMSTATE.SELECTEDNOEXPAND;

pub const NSTCGNI = enum(i32) {
    NEXT = 0,
    NEXTVISIBLE = 1,
    PREV = 2,
    PREVVISIBLE = 3,
    PARENT = 4,
    CHILD = 5,
    FIRSTVISIBLE = 6,
    LASTVISIBLE = 7,
};
pub const NSTCGNI_NEXT = NSTCGNI.NEXT;
pub const NSTCGNI_NEXTVISIBLE = NSTCGNI.NEXTVISIBLE;
pub const NSTCGNI_PREV = NSTCGNI.PREV;
pub const NSTCGNI_PREVVISIBLE = NSTCGNI.PREVVISIBLE;
pub const NSTCGNI_PARENT = NSTCGNI.PARENT;
pub const NSTCGNI_CHILD = NSTCGNI.CHILD;
pub const NSTCGNI_FIRSTVISIBLE = NSTCGNI.FIRSTVISIBLE;
pub const NSTCGNI_LASTVISIBLE = NSTCGNI.LASTVISIBLE;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_INameSpaceTreeControl_Value = Guid.initString("028212a3-b627-47e9-8856-c14265554e4f");
pub const IID_INameSpaceTreeControl = &IID_INameSpaceTreeControl_Value;
pub const INameSpaceTreeControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INameSpaceTreeControl,
                hwndParent: ?HWND,
                prc: ?*RECT,
                nsctsFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INameSpaceTreeControl,
                hwndParent: ?HWND,
                prc: ?*RECT,
                nsctsFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TreeAdvise: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INameSpaceTreeControl,
                punk: ?*IUnknown,
                pdwCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INameSpaceTreeControl,
                punk: ?*IUnknown,
                pdwCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TreeUnadvise: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INameSpaceTreeControl,
                dwCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INameSpaceTreeControl,
                dwCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AppendRoot: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INameSpaceTreeControl,
                psiRoot: ?*IShellItem,
                grfEnumFlags: u32,
                grfRootStyle: u32,
                pif: ?*IShellItemFilter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INameSpaceTreeControl,
                psiRoot: ?*IShellItem,
                grfEnumFlags: u32,
                grfRootStyle: u32,
                pif: ?*IShellItemFilter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InsertRoot: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INameSpaceTreeControl,
                iIndex: i32,
                psiRoot: ?*IShellItem,
                grfEnumFlags: u32,
                grfRootStyle: u32,
                pif: ?*IShellItemFilter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INameSpaceTreeControl,
                iIndex: i32,
                psiRoot: ?*IShellItem,
                grfEnumFlags: u32,
                grfRootStyle: u32,
                pif: ?*IShellItemFilter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveRoot: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INameSpaceTreeControl,
                psiRoot: ?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INameSpaceTreeControl,
                psiRoot: ?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveAllRoots: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INameSpaceTreeControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INameSpaceTreeControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRootItems: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INameSpaceTreeControl,
                ppsiaRootItems: ?*?*IShellItemArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INameSpaceTreeControl,
                ppsiaRootItems: ?*?*IShellItemArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetItemState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INameSpaceTreeControl,
                psi: ?*IShellItem,
                nstcisMask: u32,
                nstcisFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INameSpaceTreeControl,
                psi: ?*IShellItem,
                nstcisMask: u32,
                nstcisFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetItemState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INameSpaceTreeControl,
                psi: ?*IShellItem,
                nstcisMask: u32,
                pnstcisFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INameSpaceTreeControl,
                psi: ?*IShellItem,
                nstcisMask: u32,
                pnstcisFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSelectedItems: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INameSpaceTreeControl,
                psiaItems: ?*?*IShellItemArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INameSpaceTreeControl,
                psiaItems: ?*?*IShellItemArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetItemCustomState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INameSpaceTreeControl,
                psi: ?*IShellItem,
                piStateNumber: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INameSpaceTreeControl,
                psi: ?*IShellItem,
                piStateNumber: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetItemCustomState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INameSpaceTreeControl,
                psi: ?*IShellItem,
                iStateNumber: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INameSpaceTreeControl,
                psi: ?*IShellItem,
                iStateNumber: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnsureItemVisible: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INameSpaceTreeControl,
                psi: ?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INameSpaceTreeControl,
                psi: ?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTheme: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INameSpaceTreeControl,
                pszTheme: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INameSpaceTreeControl,
                pszTheme: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNextItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INameSpaceTreeControl,
                psi: ?*IShellItem,
                nstcgi: NSTCGNI,
                ppsiNext: ?*?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INameSpaceTreeControl,
                psi: ?*IShellItem,
                nstcgi: NSTCGNI,
                ppsiNext: ?*?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        HitTest: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INameSpaceTreeControl,
                ppt: ?*POINT,
                ppsiOut: ?*?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INameSpaceTreeControl,
                ppt: ?*POINT,
                ppsiOut: ?*?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetItemRect: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INameSpaceTreeControl,
                psi: ?*IShellItem,
                prect: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INameSpaceTreeControl,
                psi: ?*IShellItem,
                prect: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CollapseAll: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INameSpaceTreeControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INameSpaceTreeControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INameSpaceTreeControl_Initialize(self: *const T, hwndParent: ?HWND, prc: ?*RECT, nsctsFlags: u32) HRESULT {
                return @as(*const INameSpaceTreeControl.VTable, @ptrCast(self.vtable)).Initialize(@as(*const INameSpaceTreeControl, @ptrCast(self)), hwndParent, prc, nsctsFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INameSpaceTreeControl_TreeAdvise(self: *const T, punk: ?*IUnknown, pdwCookie: ?*u32) HRESULT {
                return @as(*const INameSpaceTreeControl.VTable, @ptrCast(self.vtable)).TreeAdvise(@as(*const INameSpaceTreeControl, @ptrCast(self)), punk, pdwCookie);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INameSpaceTreeControl_TreeUnadvise(self: *const T, dwCookie: u32) HRESULT {
                return @as(*const INameSpaceTreeControl.VTable, @ptrCast(self.vtable)).TreeUnadvise(@as(*const INameSpaceTreeControl, @ptrCast(self)), dwCookie);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INameSpaceTreeControl_AppendRoot(self: *const T, psiRoot: ?*IShellItem, grfEnumFlags: u32, grfRootStyle: u32, pif: ?*IShellItemFilter) HRESULT {
                return @as(*const INameSpaceTreeControl.VTable, @ptrCast(self.vtable)).AppendRoot(@as(*const INameSpaceTreeControl, @ptrCast(self)), psiRoot, grfEnumFlags, grfRootStyle, pif);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INameSpaceTreeControl_InsertRoot(self: *const T, iIndex: i32, psiRoot: ?*IShellItem, grfEnumFlags: u32, grfRootStyle: u32, pif: ?*IShellItemFilter) HRESULT {
                return @as(*const INameSpaceTreeControl.VTable, @ptrCast(self.vtable)).InsertRoot(@as(*const INameSpaceTreeControl, @ptrCast(self)), iIndex, psiRoot, grfEnumFlags, grfRootStyle, pif);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INameSpaceTreeControl_RemoveRoot(self: *const T, psiRoot: ?*IShellItem) HRESULT {
                return @as(*const INameSpaceTreeControl.VTable, @ptrCast(self.vtable)).RemoveRoot(@as(*const INameSpaceTreeControl, @ptrCast(self)), psiRoot);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INameSpaceTreeControl_RemoveAllRoots(self: *const T) HRESULT {
                return @as(*const INameSpaceTreeControl.VTable, @ptrCast(self.vtable)).RemoveAllRoots(@as(*const INameSpaceTreeControl, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INameSpaceTreeControl_GetRootItems(self: *const T, ppsiaRootItems: ?*?*IShellItemArray) HRESULT {
                return @as(*const INameSpaceTreeControl.VTable, @ptrCast(self.vtable)).GetRootItems(@as(*const INameSpaceTreeControl, @ptrCast(self)), ppsiaRootItems);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INameSpaceTreeControl_SetItemState(self: *const T, psi: ?*IShellItem, nstcisMask: u32, nstcisFlags: u32) HRESULT {
                return @as(*const INameSpaceTreeControl.VTable, @ptrCast(self.vtable)).SetItemState(@as(*const INameSpaceTreeControl, @ptrCast(self)), psi, nstcisMask, nstcisFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INameSpaceTreeControl_GetItemState(self: *const T, psi: ?*IShellItem, nstcisMask: u32, pnstcisFlags: ?*u32) HRESULT {
                return @as(*const INameSpaceTreeControl.VTable, @ptrCast(self.vtable)).GetItemState(@as(*const INameSpaceTreeControl, @ptrCast(self)), psi, nstcisMask, pnstcisFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INameSpaceTreeControl_GetSelectedItems(self: *const T, psiaItems: ?*?*IShellItemArray) HRESULT {
                return @as(*const INameSpaceTreeControl.VTable, @ptrCast(self.vtable)).GetSelectedItems(@as(*const INameSpaceTreeControl, @ptrCast(self)), psiaItems);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INameSpaceTreeControl_GetItemCustomState(self: *const T, psi: ?*IShellItem, piStateNumber: ?*i32) HRESULT {
                return @as(*const INameSpaceTreeControl.VTable, @ptrCast(self.vtable)).GetItemCustomState(@as(*const INameSpaceTreeControl, @ptrCast(self)), psi, piStateNumber);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INameSpaceTreeControl_SetItemCustomState(self: *const T, psi: ?*IShellItem, iStateNumber: i32) HRESULT {
                return @as(*const INameSpaceTreeControl.VTable, @ptrCast(self.vtable)).SetItemCustomState(@as(*const INameSpaceTreeControl, @ptrCast(self)), psi, iStateNumber);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INameSpaceTreeControl_EnsureItemVisible(self: *const T, psi: ?*IShellItem) HRESULT {
                return @as(*const INameSpaceTreeControl.VTable, @ptrCast(self.vtable)).EnsureItemVisible(@as(*const INameSpaceTreeControl, @ptrCast(self)), psi);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INameSpaceTreeControl_SetTheme(self: *const T, pszTheme: ?[*:0]const u16) HRESULT {
                return @as(*const INameSpaceTreeControl.VTable, @ptrCast(self.vtable)).SetTheme(@as(*const INameSpaceTreeControl, @ptrCast(self)), pszTheme);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INameSpaceTreeControl_GetNextItem(self: *const T, psi: ?*IShellItem, nstcgi: NSTCGNI, ppsiNext: ?*?*IShellItem) HRESULT {
                return @as(*const INameSpaceTreeControl.VTable, @ptrCast(self.vtable)).GetNextItem(@as(*const INameSpaceTreeControl, @ptrCast(self)), psi, nstcgi, ppsiNext);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INameSpaceTreeControl_HitTest(self: *const T, ppt: ?*POINT, ppsiOut: ?*?*IShellItem) HRESULT {
                return @as(*const INameSpaceTreeControl.VTable, @ptrCast(self.vtable)).HitTest(@as(*const INameSpaceTreeControl, @ptrCast(self)), ppt, ppsiOut);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INameSpaceTreeControl_GetItemRect(self: *const T, psi: ?*IShellItem, prect: ?*RECT) HRESULT {
                return @as(*const INameSpaceTreeControl.VTable, @ptrCast(self.vtable)).GetItemRect(@as(*const INameSpaceTreeControl, @ptrCast(self)), psi, prect);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INameSpaceTreeControl_CollapseAll(self: *const T) HRESULT {
                return @as(*const INameSpaceTreeControl.VTable, @ptrCast(self.vtable)).CollapseAll(@as(*const INameSpaceTreeControl, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const NSTCFOLDERCAPABILITIES = enum(i32) {
    NONE = 0,
    PINNEDITEMFILTERING = 1,
    DELAY_REGISTER_NOTIFY = 2,
};
pub const NSTCFC_NONE = NSTCFOLDERCAPABILITIES.NONE;
pub const NSTCFC_PINNEDITEMFILTERING = NSTCFOLDERCAPABILITIES.PINNEDITEMFILTERING;
pub const NSTCFC_DELAY_REGISTER_NOTIFY = NSTCFOLDERCAPABILITIES.DELAY_REGISTER_NOTIFY;

// TODO: this type is limited to platform 'windows6.1'
const IID_INameSpaceTreeControlFolderCapabilities_Value = Guid.initString("e9701183-e6b3-4ff2-8568-813615fec7be");
pub const IID_INameSpaceTreeControlFolderCapabilities = &IID_INameSpaceTreeControlFolderCapabilities_Value;
pub const INameSpaceTreeControlFolderCapabilities = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetFolderCapabilities: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INameSpaceTreeControlFolderCapabilities,
                nfcMask: NSTCFOLDERCAPABILITIES,
                pnfcValue: ?*NSTCFOLDERCAPABILITIES,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INameSpaceTreeControlFolderCapabilities,
                nfcMask: NSTCFOLDERCAPABILITIES,
                pnfcValue: ?*NSTCFOLDERCAPABILITIES,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INameSpaceTreeControlFolderCapabilities_GetFolderCapabilities(self: *const T, nfcMask: NSTCFOLDERCAPABILITIES, pnfcValue: ?*NSTCFOLDERCAPABILITIES) HRESULT {
                return @as(*const INameSpaceTreeControlFolderCapabilities.VTable, @ptrCast(self.vtable)).GetFolderCapabilities(@as(*const INameSpaceTreeControlFolderCapabilities, @ptrCast(self)), nfcMask, pnfcValue);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IPreviewHandler_Value = Guid.initString("8895b1c6-b41f-4c1c-a562-0d564250836f");
pub const IID_IPreviewHandler = &IID_IPreviewHandler_Value;
pub const IPreviewHandler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetWindow: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPreviewHandler,
                hwnd: ?HWND,
                prc: ?*const RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPreviewHandler,
                hwnd: ?HWND,
                prc: ?*const RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetRect: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPreviewHandler,
                prc: ?*const RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPreviewHandler,
                prc: ?*const RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DoPreview: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPreviewHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPreviewHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Unload: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPreviewHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPreviewHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFocus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPreviewHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPreviewHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryFocus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPreviewHandler,
                phwnd: ?*?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPreviewHandler,
                phwnd: ?*?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TranslateAccelerator: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPreviewHandler,
                pmsg: ?*MSG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPreviewHandler,
                pmsg: ?*MSG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPreviewHandler_SetWindow(self: *const T, hwnd: ?HWND, prc: ?*const RECT) HRESULT {
                return @as(*const IPreviewHandler.VTable, @ptrCast(self.vtable)).SetWindow(@as(*const IPreviewHandler, @ptrCast(self)), hwnd, prc);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPreviewHandler_SetRect(self: *const T, prc: ?*const RECT) HRESULT {
                return @as(*const IPreviewHandler.VTable, @ptrCast(self.vtable)).SetRect(@as(*const IPreviewHandler, @ptrCast(self)), prc);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPreviewHandler_DoPreview(self: *const T) HRESULT {
                return @as(*const IPreviewHandler.VTable, @ptrCast(self.vtable)).DoPreview(@as(*const IPreviewHandler, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPreviewHandler_Unload(self: *const T) HRESULT {
                return @as(*const IPreviewHandler.VTable, @ptrCast(self.vtable)).Unload(@as(*const IPreviewHandler, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPreviewHandler_SetFocus(self: *const T) HRESULT {
                return @as(*const IPreviewHandler.VTable, @ptrCast(self.vtable)).SetFocus(@as(*const IPreviewHandler, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPreviewHandler_QueryFocus(self: *const T, phwnd: ?*?HWND) HRESULT {
                return @as(*const IPreviewHandler.VTable, @ptrCast(self.vtable)).QueryFocus(@as(*const IPreviewHandler, @ptrCast(self)), phwnd);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPreviewHandler_TranslateAccelerator(self: *const T, pmsg: ?*MSG) HRESULT {
                return @as(*const IPreviewHandler.VTable, @ptrCast(self.vtable)).TranslateAccelerator(@as(*const IPreviewHandler, @ptrCast(self)), pmsg);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const PREVIEWHANDLERFRAMEINFO = extern struct {
    haccel: ?HACCEL,
    cAccelEntries: u32,
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IPreviewHandlerFrame_Value = Guid.initString("fec87aaf-35f9-447a-adb7-20234491401a");
pub const IID_IPreviewHandlerFrame = &IID_IPreviewHandlerFrame_Value;
pub const IPreviewHandlerFrame = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetWindowContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPreviewHandlerFrame,
                pinfo: ?*PREVIEWHANDLERFRAMEINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPreviewHandlerFrame,
                pinfo: ?*PREVIEWHANDLERFRAMEINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TranslateAccelerator: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPreviewHandlerFrame,
                pmsg: ?*MSG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPreviewHandlerFrame,
                pmsg: ?*MSG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPreviewHandlerFrame_GetWindowContext(self: *const T, pinfo: ?*PREVIEWHANDLERFRAMEINFO) HRESULT {
                return @as(*const IPreviewHandlerFrame.VTable, @ptrCast(self.vtable)).GetWindowContext(@as(*const IPreviewHandlerFrame, @ptrCast(self)), pinfo);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPreviewHandlerFrame_TranslateAccelerator(self: *const T, pmsg: ?*MSG) HRESULT {
                return @as(*const IPreviewHandlerFrame.VTable, @ptrCast(self.vtable)).TranslateAccelerator(@as(*const IPreviewHandlerFrame, @ptrCast(self)), pmsg);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const _EXPLORERPANESTATE = enum(i32) {
    DONTCARE = 0,
    DEFAULT_ON = 1,
    DEFAULT_OFF = 2,
    STATEMASK = 65535,
    INITIALSTATE = 65536,
    FORCE = 131072,
};
pub const EPS_DONTCARE = _EXPLORERPANESTATE.DONTCARE;
pub const EPS_DEFAULT_ON = _EXPLORERPANESTATE.DEFAULT_ON;
pub const EPS_DEFAULT_OFF = _EXPLORERPANESTATE.DEFAULT_OFF;
pub const EPS_STATEMASK = _EXPLORERPANESTATE.STATEMASK;
pub const EPS_INITIALSTATE = _EXPLORERPANESTATE.INITIALSTATE;
pub const EPS_FORCE = _EXPLORERPANESTATE.FORCE;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IExplorerPaneVisibility_Value = Guid.initString("e07010ec-bc17-44c0-97b0-46c7c95b9edc");
pub const IID_IExplorerPaneVisibility = &IID_IExplorerPaneVisibility_Value;
pub const IExplorerPaneVisibility = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPaneState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IExplorerPaneVisibility,
                ep: ?*const Guid,
                peps: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IExplorerPaneVisibility,
                ep: ?*const Guid,
                peps: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IExplorerPaneVisibility_GetPaneState(self: *const T, ep: ?*const Guid, peps: ?*u32) HRESULT {
                return @as(*const IExplorerPaneVisibility.VTable, @ptrCast(self.vtable)).GetPaneState(@as(*const IExplorerPaneVisibility, @ptrCast(self)), ep, peps);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IContextMenuCB_Value = Guid.initString("3409e930-5a39-11d1-83fa-00a0c90dc849");
pub const IID_IContextMenuCB = &IID_IContextMenuCB_Value;
pub const IContextMenuCB = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CallBack: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IContextMenuCB,
                psf: ?*IShellFolder,
                hwndOwner: ?HWND,
                pdtobj: ?*IDataObject,
                uMsg: u32,
                wParam: WPARAM,
                lParam: LPARAM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IContextMenuCB,
                psf: ?*IShellFolder,
                hwndOwner: ?HWND,
                pdtobj: ?*IDataObject,
                uMsg: u32,
                wParam: WPARAM,
                lParam: LPARAM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IContextMenuCB_CallBack(self: *const T, psf: ?*IShellFolder, hwndOwner: ?HWND, pdtobj: ?*IDataObject, uMsg: u32, wParam: WPARAM, lParam: LPARAM) HRESULT {
                return @as(*const IContextMenuCB.VTable, @ptrCast(self.vtable)).CallBack(@as(*const IContextMenuCB, @ptrCast(self)), psf, hwndOwner, pdtobj, uMsg, wParam, lParam);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IDefaultExtractIconInit_Value = Guid.initString("41ded17d-d6b3-4261-997d-88c60e4b1d58");
pub const IID_IDefaultExtractIconInit = &IID_IDefaultExtractIconInit_Value;
pub const IDefaultExtractIconInit = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDefaultExtractIconInit,
                uFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDefaultExtractIconInit,
                uFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetKey: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDefaultExtractIconInit,
                hkey: ?HKEY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDefaultExtractIconInit,
                hkey: ?HKEY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetNormalIcon: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDefaultExtractIconInit,
                pszFile: ?[*:0]const u16,
                iIcon: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDefaultExtractIconInit,
                pszFile: ?[*:0]const u16,
                iIcon: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOpenIcon: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDefaultExtractIconInit,
                pszFile: ?[*:0]const u16,
                iIcon: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDefaultExtractIconInit,
                pszFile: ?[*:0]const u16,
                iIcon: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetShortcutIcon: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDefaultExtractIconInit,
                pszFile: ?[*:0]const u16,
                iIcon: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDefaultExtractIconInit,
                pszFile: ?[*:0]const u16,
                iIcon: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDefaultIcon: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDefaultExtractIconInit,
                pszFile: ?[*:0]const u16,
                iIcon: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDefaultExtractIconInit,
                pszFile: ?[*:0]const u16,
                iIcon: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDefaultExtractIconInit_SetFlags(self: *const T, uFlags: u32) HRESULT {
                return @as(*const IDefaultExtractIconInit.VTable, @ptrCast(self.vtable)).SetFlags(@as(*const IDefaultExtractIconInit, @ptrCast(self)), uFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDefaultExtractIconInit_SetKey(self: *const T, hkey: ?HKEY) HRESULT {
                return @as(*const IDefaultExtractIconInit.VTable, @ptrCast(self.vtable)).SetKey(@as(*const IDefaultExtractIconInit, @ptrCast(self)), hkey);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDefaultExtractIconInit_SetNormalIcon(self: *const T, pszFile: ?[*:0]const u16, iIcon: i32) HRESULT {
                return @as(*const IDefaultExtractIconInit.VTable, @ptrCast(self.vtable)).SetNormalIcon(@as(*const IDefaultExtractIconInit, @ptrCast(self)), pszFile, iIcon);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDefaultExtractIconInit_SetOpenIcon(self: *const T, pszFile: ?[*:0]const u16, iIcon: i32) HRESULT {
                return @as(*const IDefaultExtractIconInit.VTable, @ptrCast(self.vtable)).SetOpenIcon(@as(*const IDefaultExtractIconInit, @ptrCast(self)), pszFile, iIcon);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDefaultExtractIconInit_SetShortcutIcon(self: *const T, pszFile: ?[*:0]const u16, iIcon: i32) HRESULT {
                return @as(*const IDefaultExtractIconInit.VTable, @ptrCast(self.vtable)).SetShortcutIcon(@as(*const IDefaultExtractIconInit, @ptrCast(self)), pszFile, iIcon);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDefaultExtractIconInit_SetDefaultIcon(self: *const T, pszFile: ?[*:0]const u16, iIcon: i32) HRESULT {
                return @as(*const IDefaultExtractIconInit.VTable, @ptrCast(self.vtable)).SetDefaultIcon(@as(*const IDefaultExtractIconInit, @ptrCast(self)), pszFile, iIcon);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const _EXPCMDSTATE = enum(i32) {
    ENABLED = 0,
    DISABLED = 1,
    HIDDEN = 2,
    CHECKBOX = 4,
    CHECKED = 8,
    RADIOCHECK = 16,
};
pub const ECS_ENABLED = _EXPCMDSTATE.ENABLED;
pub const ECS_DISABLED = _EXPCMDSTATE.DISABLED;
pub const ECS_HIDDEN = _EXPCMDSTATE.HIDDEN;
pub const ECS_CHECKBOX = _EXPCMDSTATE.CHECKBOX;
pub const ECS_CHECKED = _EXPCMDSTATE.CHECKED;
pub const ECS_RADIOCHECK = _EXPCMDSTATE.RADIOCHECK;

pub const _EXPCMDFLAGS = enum(i32) {
    DEFAULT = 0,
    HASSUBCOMMANDS = 1,
    HASSPLITBUTTON = 2,
    HIDELABEL = 4,
    ISSEPARATOR = 8,
    HASLUASHIELD = 16,
    SEPARATORBEFORE = 32,
    SEPARATORAFTER = 64,
    ISDROPDOWN = 128,
    TOGGLEABLE = 256,
    AUTOMENUICONS = 512,
};
pub const ECF_DEFAULT = _EXPCMDFLAGS.DEFAULT;
pub const ECF_HASSUBCOMMANDS = _EXPCMDFLAGS.HASSUBCOMMANDS;
pub const ECF_HASSPLITBUTTON = _EXPCMDFLAGS.HASSPLITBUTTON;
pub const ECF_HIDELABEL = _EXPCMDFLAGS.HIDELABEL;
pub const ECF_ISSEPARATOR = _EXPCMDFLAGS.ISSEPARATOR;
pub const ECF_HASLUASHIELD = _EXPCMDFLAGS.HASLUASHIELD;
pub const ECF_SEPARATORBEFORE = _EXPCMDFLAGS.SEPARATORBEFORE;
pub const ECF_SEPARATORAFTER = _EXPCMDFLAGS.SEPARATORAFTER;
pub const ECF_ISDROPDOWN = _EXPCMDFLAGS.ISDROPDOWN;
pub const ECF_TOGGLEABLE = _EXPCMDFLAGS.TOGGLEABLE;
pub const ECF_AUTOMENUICONS = _EXPCMDFLAGS.AUTOMENUICONS;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IExplorerCommand_Value = Guid.initString("a08ce4d0-fa25-44ab-b57c-c7b1c323e0b9");
pub const IID_IExplorerCommand = &IID_IExplorerCommand_Value;
pub const IExplorerCommand = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTitle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IExplorerCommand,
                psiItemArray: ?*IShellItemArray,
                ppszName: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IExplorerCommand,
                psiItemArray: ?*IShellItemArray,
                ppszName: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIcon: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IExplorerCommand,
                psiItemArray: ?*IShellItemArray,
                ppszIcon: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IExplorerCommand,
                psiItemArray: ?*IShellItemArray,
                ppszIcon: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetToolTip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IExplorerCommand,
                psiItemArray: ?*IShellItemArray,
                ppszInfotip: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IExplorerCommand,
                psiItemArray: ?*IShellItemArray,
                ppszInfotip: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCanonicalName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IExplorerCommand,
                pguidCommandName: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IExplorerCommand,
                pguidCommandName: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IExplorerCommand,
                psiItemArray: ?*IShellItemArray,
                fOkToBeSlow: BOOL,
                pCmdState: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IExplorerCommand,
                psiItemArray: ?*IShellItemArray,
                fOkToBeSlow: BOOL,
                pCmdState: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Invoke: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IExplorerCommand,
                psiItemArray: ?*IShellItemArray,
                pbc: ?*IBindCtx,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IExplorerCommand,
                psiItemArray: ?*IShellItemArray,
                pbc: ?*IBindCtx,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IExplorerCommand,
                pFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IExplorerCommand,
                pFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumSubCommands: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IExplorerCommand,
                ppEnum: ?*?*IEnumExplorerCommand,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IExplorerCommand,
                ppEnum: ?*?*IEnumExplorerCommand,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IExplorerCommand_GetTitle(self: *const T, psiItemArray: ?*IShellItemArray, ppszName: ?*?PWSTR) HRESULT {
                return @as(*const IExplorerCommand.VTable, @ptrCast(self.vtable)).GetTitle(@as(*const IExplorerCommand, @ptrCast(self)), psiItemArray, ppszName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IExplorerCommand_GetIcon(self: *const T, psiItemArray: ?*IShellItemArray, ppszIcon: ?*?PWSTR) HRESULT {
                return @as(*const IExplorerCommand.VTable, @ptrCast(self.vtable)).GetIcon(@as(*const IExplorerCommand, @ptrCast(self)), psiItemArray, ppszIcon);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IExplorerCommand_GetToolTip(self: *const T, psiItemArray: ?*IShellItemArray, ppszInfotip: ?*?PWSTR) HRESULT {
                return @as(*const IExplorerCommand.VTable, @ptrCast(self.vtable)).GetToolTip(@as(*const IExplorerCommand, @ptrCast(self)), psiItemArray, ppszInfotip);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IExplorerCommand_GetCanonicalName(self: *const T, pguidCommandName: ?*Guid) HRESULT {
                return @as(*const IExplorerCommand.VTable, @ptrCast(self.vtable)).GetCanonicalName(@as(*const IExplorerCommand, @ptrCast(self)), pguidCommandName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IExplorerCommand_GetState(self: *const T, psiItemArray: ?*IShellItemArray, fOkToBeSlow: BOOL, pCmdState: ?*u32) HRESULT {
                return @as(*const IExplorerCommand.VTable, @ptrCast(self.vtable)).GetState(@as(*const IExplorerCommand, @ptrCast(self)), psiItemArray, fOkToBeSlow, pCmdState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IExplorerCommand_Invoke(self: *const T, psiItemArray: ?*IShellItemArray, pbc: ?*IBindCtx) HRESULT {
                return @as(*const IExplorerCommand.VTable, @ptrCast(self.vtable)).Invoke(@as(*const IExplorerCommand, @ptrCast(self)), psiItemArray, pbc);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IExplorerCommand_GetFlags(self: *const T, pFlags: ?*u32) HRESULT {
                return @as(*const IExplorerCommand.VTable, @ptrCast(self.vtable)).GetFlags(@as(*const IExplorerCommand, @ptrCast(self)), pFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IExplorerCommand_EnumSubCommands(self: *const T, ppEnum: ?*?*IEnumExplorerCommand) HRESULT {
                return @as(*const IExplorerCommand.VTable, @ptrCast(self.vtable)).EnumSubCommands(@as(*const IExplorerCommand, @ptrCast(self)), ppEnum);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IExplorerCommandState_Value = Guid.initString("bddacb60-7657-47ae-8445-d23e1acf82ae");
pub const IID_IExplorerCommandState = &IID_IExplorerCommandState_Value;
pub const IExplorerCommandState = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IExplorerCommandState,
                psiItemArray: ?*IShellItemArray,
                fOkToBeSlow: BOOL,
                pCmdState: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IExplorerCommandState,
                psiItemArray: ?*IShellItemArray,
                fOkToBeSlow: BOOL,
                pCmdState: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IExplorerCommandState_GetState(self: *const T, psiItemArray: ?*IShellItemArray, fOkToBeSlow: BOOL, pCmdState: ?*u32) HRESULT {
                return @as(*const IExplorerCommandState.VTable, @ptrCast(self.vtable)).GetState(@as(*const IExplorerCommandState, @ptrCast(self)), psiItemArray, fOkToBeSlow, pCmdState);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IInitializeCommand_Value = Guid.initString("85075acf-231f-40ea-9610-d26b7b58f638");
pub const IID_IInitializeCommand = &IID_IInitializeCommand_Value;
pub const IInitializeCommand = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInitializeCommand,
                pszCommandName: ?[*:0]const u16,
                ppb: ?*IPropertyBag,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInitializeCommand,
                pszCommandName: ?[*:0]const u16,
                ppb: ?*IPropertyBag,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInitializeCommand_Initialize(self: *const T, pszCommandName: ?[*:0]const u16, ppb: ?*IPropertyBag) HRESULT {
                return @as(*const IInitializeCommand.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IInitializeCommand, @ptrCast(self)), pszCommandName, ppb);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IEnumExplorerCommand_Value = Guid.initString("a88826f8-186f-4987-aade-ea0cef8fbfe8");
pub const IID_IEnumExplorerCommand = &IID_IEnumExplorerCommand_Value;
pub const IEnumExplorerCommand = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumExplorerCommand,
                celt: u32,
                pUICommand: [*]?*IExplorerCommand,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumExplorerCommand,
                celt: u32,
                pUICommand: [*]?*IExplorerCommand,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumExplorerCommand,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumExplorerCommand,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumExplorerCommand,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumExplorerCommand,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumExplorerCommand,
                ppenum: ?*?*IEnumExplorerCommand,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumExplorerCommand,
                ppenum: ?*?*IEnumExplorerCommand,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumExplorerCommand_Next(self: *const T, celt: u32, pUICommand: [*]?*IExplorerCommand, pceltFetched: ?*u32) HRESULT {
                return @as(*const IEnumExplorerCommand.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumExplorerCommand, @ptrCast(self)), celt, pUICommand, pceltFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumExplorerCommand_Skip(self: *const T, celt: u32) HRESULT {
                return @as(*const IEnumExplorerCommand.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumExplorerCommand, @ptrCast(self)), celt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumExplorerCommand_Reset(self: *const T) HRESULT {
                return @as(*const IEnumExplorerCommand.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumExplorerCommand, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumExplorerCommand_Clone(self: *const T, ppenum: ?*?*IEnumExplorerCommand) HRESULT {
                return @as(*const IEnumExplorerCommand.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumExplorerCommand, @ptrCast(self)), ppenum);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IExplorerCommandProvider_Value = Guid.initString("64961751-0835-43c0-8ffe-d57686530e64");
pub const IID_IExplorerCommandProvider = &IID_IExplorerCommandProvider_Value;
pub const IExplorerCommandProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCommands: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IExplorerCommandProvider,
                punkSite: ?*IUnknown,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IExplorerCommandProvider,
                punkSite: ?*IUnknown,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IExplorerCommandProvider,
                rguidCommandId: ?*const Guid,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IExplorerCommandProvider,
                rguidCommandId: ?*const Guid,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IExplorerCommandProvider_GetCommands(self: *const T, punkSite: ?*IUnknown, riid: ?*const Guid, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const IExplorerCommandProvider.VTable, @ptrCast(self.vtable)).GetCommands(@as(*const IExplorerCommandProvider, @ptrCast(self)), punkSite, riid, ppv);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IExplorerCommandProvider_GetCommand(self: *const T, rguidCommandId: ?*const Guid, riid: ?*const Guid, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const IExplorerCommandProvider.VTable, @ptrCast(self.vtable)).GetCommand(@as(*const IExplorerCommandProvider, @ptrCast(self)), rguidCommandId, riid, ppv);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const CPVIEW = enum(i32) {
    CLASSIC = 0,
    // ALLITEMS = 0, this enum value conflicts with CLASSIC
    CATEGORY = 1,
    // HOME = 1, this enum value conflicts with CATEGORY
};
pub const CPVIEW_CLASSIC = CPVIEW.CLASSIC;
pub const CPVIEW_ALLITEMS = CPVIEW.CLASSIC;
pub const CPVIEW_CATEGORY = CPVIEW.CATEGORY;
pub const CPVIEW_HOME = CPVIEW.CATEGORY;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IOpenControlPanel_Value = Guid.initString("d11ad862-66de-4df4-bf6c-1f5621996af1");
pub const IID_IOpenControlPanel = &IID_IOpenControlPanel_Value;
pub const IOpenControlPanel = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Open: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOpenControlPanel,
                pszName: ?[*:0]const u16,
                pszPage: ?[*:0]const u16,
                punkSite: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOpenControlPanel,
                pszName: ?[*:0]const u16,
                pszPage: ?[*:0]const u16,
                punkSite: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPath: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOpenControlPanel,
                pszName: ?[*:0]const u16,
                pszPath: [*:0]u16,
                cchPath: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOpenControlPanel,
                pszName: ?[*:0]const u16,
                pszPath: [*:0]u16,
                cchPath: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentView: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOpenControlPanel,
                pView: ?*CPVIEW,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOpenControlPanel,
                pView: ?*CPVIEW,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOpenControlPanel_Open(self: *const T, pszName: ?[*:0]const u16, pszPage: ?[*:0]const u16, punkSite: ?*IUnknown) HRESULT {
                return @as(*const IOpenControlPanel.VTable, @ptrCast(self.vtable)).Open(@as(*const IOpenControlPanel, @ptrCast(self)), pszName, pszPage, punkSite);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOpenControlPanel_GetPath(self: *const T, pszName: ?[*:0]const u16, pszPath: [*:0]u16, cchPath: u32) HRESULT {
                return @as(*const IOpenControlPanel.VTable, @ptrCast(self.vtable)).GetPath(@as(*const IOpenControlPanel, @ptrCast(self)), pszName, pszPath, cchPath);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOpenControlPanel_GetCurrentView(self: *const T, pView: ?*CPVIEW) HRESULT {
                return @as(*const IOpenControlPanel.VTable, @ptrCast(self.vtable)).GetCurrentView(@as(*const IOpenControlPanel, @ptrCast(self)), pView);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IFileSystemBindData_Value = Guid.initString("01e18d10-4d8b-11d2-855d-006008059367");
pub const IID_IFileSystemBindData = &IID_IFileSystemBindData_Value;
pub const IFileSystemBindData = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetFindData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileSystemBindData,
                pfd: ?*const WIN32_FIND_DATAW,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileSystemBindData,
                pfd: ?*const WIN32_FIND_DATAW,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFindData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileSystemBindData,
                pfd: ?*WIN32_FIND_DATAW,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileSystemBindData,
                pfd: ?*WIN32_FIND_DATAW,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileSystemBindData_SetFindData(self: *const T, pfd: ?*const WIN32_FIND_DATAW) HRESULT {
                return @as(*const IFileSystemBindData.VTable, @ptrCast(self.vtable)).SetFindData(@as(*const IFileSystemBindData, @ptrCast(self)), pfd);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileSystemBindData_GetFindData(self: *const T, pfd: ?*WIN32_FIND_DATAW) HRESULT {
                return @as(*const IFileSystemBindData.VTable, @ptrCast(self.vtable)).GetFindData(@as(*const IFileSystemBindData, @ptrCast(self)), pfd);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IFileSystemBindData2_Value = Guid.initString("3acf075f-71db-4afa-81f0-3fc4fdf2a5b8");
pub const IID_IFileSystemBindData2 = &IID_IFileSystemBindData2_Value;
pub const IFileSystemBindData2 = extern struct {
    pub const VTable = extern struct {
        base: IFileSystemBindData.VTable,
        SetFileID: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileSystemBindData2,
                liFileID: LARGE_INTEGER,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileSystemBindData2,
                liFileID: LARGE_INTEGER,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFileID: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileSystemBindData2,
                pliFileID: ?*LARGE_INTEGER,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileSystemBindData2,
                pliFileID: ?*LARGE_INTEGER,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetJunctionCLSID: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileSystemBindData2,
                clsid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileSystemBindData2,
                clsid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetJunctionCLSID: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileSystemBindData2,
                pclsid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileSystemBindData2,
                pclsid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IFileSystemBindData.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileSystemBindData2_SetFileID(self: *const T, liFileID: LARGE_INTEGER) HRESULT {
                return @as(*const IFileSystemBindData2.VTable, @ptrCast(self.vtable)).SetFileID(@as(*const IFileSystemBindData2, @ptrCast(self)), liFileID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileSystemBindData2_GetFileID(self: *const T, pliFileID: ?*LARGE_INTEGER) HRESULT {
                return @as(*const IFileSystemBindData2.VTable, @ptrCast(self.vtable)).GetFileID(@as(*const IFileSystemBindData2, @ptrCast(self)), pliFileID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileSystemBindData2_SetJunctionCLSID(self: *const T, clsid: ?*const Guid) HRESULT {
                return @as(*const IFileSystemBindData2.VTable, @ptrCast(self.vtable)).SetJunctionCLSID(@as(*const IFileSystemBindData2, @ptrCast(self)), clsid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileSystemBindData2_GetJunctionCLSID(self: *const T, pclsid: ?*Guid) HRESULT {
                return @as(*const IFileSystemBindData2.VTable, @ptrCast(self.vtable)).GetJunctionCLSID(@as(*const IFileSystemBindData2, @ptrCast(self)), pclsid);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const KNOWNDESTCATEGORY = enum(i32) {
    FREQUENT = 1,
    RECENT = 2,
};
pub const KDC_FREQUENT = KNOWNDESTCATEGORY.FREQUENT;
pub const KDC_RECENT = KNOWNDESTCATEGORY.RECENT;

// TODO: this type is limited to platform 'windows6.1'
const IID_ICustomDestinationList_Value = Guid.initString("6332debf-87b5-4670-90c0-5e57b408a49e");
pub const IID_ICustomDestinationList = &IID_ICustomDestinationList_Value;
pub const ICustomDestinationList = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetAppID: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICustomDestinationList,
                pszAppID: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICustomDestinationList,
                pszAppID: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BeginList: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICustomDestinationList,
                pcMinSlots: ?*u32,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICustomDestinationList,
                pcMinSlots: ?*u32,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AppendCategory: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICustomDestinationList,
                pszCategory: ?[*:0]const u16,
                poa: ?*IObjectArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICustomDestinationList,
                pszCategory: ?[*:0]const u16,
                poa: ?*IObjectArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AppendKnownCategory: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICustomDestinationList,
                category: KNOWNDESTCATEGORY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICustomDestinationList,
                category: KNOWNDESTCATEGORY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddUserTasks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICustomDestinationList,
                poa: ?*IObjectArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICustomDestinationList,
                poa: ?*IObjectArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CommitList: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICustomDestinationList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICustomDestinationList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRemovedDestinations: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICustomDestinationList,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICustomDestinationList,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeleteList: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICustomDestinationList,
                pszAppID: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICustomDestinationList,
                pszAppID: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AbortList: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICustomDestinationList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICustomDestinationList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICustomDestinationList_SetAppID(self: *const T, pszAppID: ?[*:0]const u16) HRESULT {
                return @as(*const ICustomDestinationList.VTable, @ptrCast(self.vtable)).SetAppID(@as(*const ICustomDestinationList, @ptrCast(self)), pszAppID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICustomDestinationList_BeginList(self: *const T, pcMinSlots: ?*u32, riid: ?*const Guid, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const ICustomDestinationList.VTable, @ptrCast(self.vtable)).BeginList(@as(*const ICustomDestinationList, @ptrCast(self)), pcMinSlots, riid, ppv);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICustomDestinationList_AppendCategory(self: *const T, pszCategory: ?[*:0]const u16, poa: ?*IObjectArray) HRESULT {
                return @as(*const ICustomDestinationList.VTable, @ptrCast(self.vtable)).AppendCategory(@as(*const ICustomDestinationList, @ptrCast(self)), pszCategory, poa);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICustomDestinationList_AppendKnownCategory(self: *const T, category: KNOWNDESTCATEGORY) HRESULT {
                return @as(*const ICustomDestinationList.VTable, @ptrCast(self.vtable)).AppendKnownCategory(@as(*const ICustomDestinationList, @ptrCast(self)), category);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICustomDestinationList_AddUserTasks(self: *const T, poa: ?*IObjectArray) HRESULT {
                return @as(*const ICustomDestinationList.VTable, @ptrCast(self.vtable)).AddUserTasks(@as(*const ICustomDestinationList, @ptrCast(self)), poa);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICustomDestinationList_CommitList(self: *const T) HRESULT {
                return @as(*const ICustomDestinationList.VTable, @ptrCast(self.vtable)).CommitList(@as(*const ICustomDestinationList, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICustomDestinationList_GetRemovedDestinations(self: *const T, riid: ?*const Guid, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const ICustomDestinationList.VTable, @ptrCast(self.vtable)).GetRemovedDestinations(@as(*const ICustomDestinationList, @ptrCast(self)), riid, ppv);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICustomDestinationList_DeleteList(self: *const T, pszAppID: ?[*:0]const u16) HRESULT {
                return @as(*const ICustomDestinationList.VTable, @ptrCast(self.vtable)).DeleteList(@as(*const ICustomDestinationList, @ptrCast(self)), pszAppID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICustomDestinationList_AbortList(self: *const T) HRESULT {
                return @as(*const ICustomDestinationList.VTable, @ptrCast(self.vtable)).AbortList(@as(*const ICustomDestinationList, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IApplicationDestinations_Value = Guid.initString("12337d35-94c6-48a0-bce7-6a9c69d4d600");
pub const IID_IApplicationDestinations = &IID_IApplicationDestinations_Value;
pub const IApplicationDestinations = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetAppID: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IApplicationDestinations,
                pszAppID: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IApplicationDestinations,
                pszAppID: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveDestination: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IApplicationDestinations,
                punk: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IApplicationDestinations,
                punk: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveAllDestinations: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IApplicationDestinations,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IApplicationDestinations,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IApplicationDestinations_SetAppID(self: *const T, pszAppID: ?[*:0]const u16) HRESULT {
                return @as(*const IApplicationDestinations.VTable, @ptrCast(self.vtable)).SetAppID(@as(*const IApplicationDestinations, @ptrCast(self)), pszAppID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IApplicationDestinations_RemoveDestination(self: *const T, punk: ?*IUnknown) HRESULT {
                return @as(*const IApplicationDestinations.VTable, @ptrCast(self.vtable)).RemoveDestination(@as(*const IApplicationDestinations, @ptrCast(self)), punk);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IApplicationDestinations_RemoveAllDestinations(self: *const T) HRESULT {
                return @as(*const IApplicationDestinations.VTable, @ptrCast(self.vtable)).RemoveAllDestinations(@as(*const IApplicationDestinations, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const APPDOCLISTTYPE = enum(i32) {
    RECENT = 0,
    FREQUENT = 1,
};
pub const ADLT_RECENT = APPDOCLISTTYPE.RECENT;
pub const ADLT_FREQUENT = APPDOCLISTTYPE.FREQUENT;

// TODO: this type is limited to platform 'windows6.1'
const IID_IApplicationDocumentLists_Value = Guid.initString("3c594f9f-9f30-47a1-979a-c9e83d3d0a06");
pub const IID_IApplicationDocumentLists = &IID_IApplicationDocumentLists_Value;
pub const IApplicationDocumentLists = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetAppID: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IApplicationDocumentLists,
                pszAppID: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IApplicationDocumentLists,
                pszAppID: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetList: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IApplicationDocumentLists,
                listtype: APPDOCLISTTYPE,
                cItemsDesired: u32,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IApplicationDocumentLists,
                listtype: APPDOCLISTTYPE,
                cItemsDesired: u32,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IApplicationDocumentLists_SetAppID(self: *const T, pszAppID: ?[*:0]const u16) HRESULT {
                return @as(*const IApplicationDocumentLists.VTable, @ptrCast(self.vtable)).SetAppID(@as(*const IApplicationDocumentLists, @ptrCast(self)), pszAppID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IApplicationDocumentLists_GetList(self: *const T, listtype: APPDOCLISTTYPE, cItemsDesired: u32, riid: ?*const Guid, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const IApplicationDocumentLists.VTable, @ptrCast(self.vtable)).GetList(@as(*const IApplicationDocumentLists, @ptrCast(self)), listtype, cItemsDesired, riid, ppv);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IObjectWithAppUserModelID_Value = Guid.initString("36db0196-9665-46d1-9ba7-d3709eecf9ed");
pub const IID_IObjectWithAppUserModelID = &IID_IObjectWithAppUserModelID_Value;
pub const IObjectWithAppUserModelID = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetAppID: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IObjectWithAppUserModelID,
                pszAppID: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IObjectWithAppUserModelID,
                pszAppID: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAppID: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IObjectWithAppUserModelID,
                ppszAppID: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IObjectWithAppUserModelID,
                ppszAppID: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IObjectWithAppUserModelID_SetAppID(self: *const T, pszAppID: ?[*:0]const u16) HRESULT {
                return @as(*const IObjectWithAppUserModelID.VTable, @ptrCast(self.vtable)).SetAppID(@as(*const IObjectWithAppUserModelID, @ptrCast(self)), pszAppID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IObjectWithAppUserModelID_GetAppID(self: *const T, ppszAppID: ?*?PWSTR) HRESULT {
                return @as(*const IObjectWithAppUserModelID.VTable, @ptrCast(self.vtable)).GetAppID(@as(*const IObjectWithAppUserModelID, @ptrCast(self)), ppszAppID);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IObjectWithProgID_Value = Guid.initString("71e806fb-8dee-46fc-bf8c-7748a8a1ae13");
pub const IID_IObjectWithProgID = &IID_IObjectWithProgID_Value;
pub const IObjectWithProgID = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetProgID: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IObjectWithProgID,
                pszProgID: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IObjectWithProgID,
                pszProgID: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProgID: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IObjectWithProgID,
                ppszProgID: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IObjectWithProgID,
                ppszProgID: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IObjectWithProgID_SetProgID(self: *const T, pszProgID: ?[*:0]const u16) HRESULT {
                return @as(*const IObjectWithProgID.VTable, @ptrCast(self.vtable)).SetProgID(@as(*const IObjectWithProgID, @ptrCast(self)), pszProgID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IObjectWithProgID_GetProgID(self: *const T, ppszProgID: ?*?PWSTR) HRESULT {
                return @as(*const IObjectWithProgID.VTable, @ptrCast(self.vtable)).GetProgID(@as(*const IObjectWithProgID, @ptrCast(self)), ppszProgID);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IUpdateIDList_Value = Guid.initString("6589b6d2-5f8d-4b9e-b7e0-23cdd9717d8c");
pub const IID_IUpdateIDList = &IID_IUpdateIDList_Value;
pub const IUpdateIDList = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Update: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUpdateIDList,
                pbc: ?*IBindCtx,
                pidlIn: ?*ITEMIDLIST,
                ppidlOut: ?*?*ITEMIDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUpdateIDList,
                pbc: ?*IBindCtx,
                pidlIn: ?*ITEMIDLIST,
                ppidlOut: ?*?*ITEMIDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUpdateIDList_Update(self: *const T, pbc: ?*IBindCtx, pidlIn: ?*ITEMIDLIST, ppidlOut: ?*?*ITEMIDLIST) HRESULT {
                return @as(*const IUpdateIDList.VTable, @ptrCast(self.vtable)).Update(@as(*const IUpdateIDList, @ptrCast(self)), pbc, pidlIn, ppidlOut);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DESKTOP_SLIDESHOW_OPTIONS = enum(i32) {
    S = 1,
};
pub const DSO_SHUFFLEIMAGES = DESKTOP_SLIDESHOW_OPTIONS.S;

pub const DESKTOP_SLIDESHOW_STATE = enum(i32) {
    ENABLED = 1,
    SLIDESHOW = 2,
    DISABLED_BY_REMOTE_SESSION = 4,
};
pub const DSS_ENABLED = DESKTOP_SLIDESHOW_STATE.ENABLED;
pub const DSS_SLIDESHOW = DESKTOP_SLIDESHOW_STATE.SLIDESHOW;
pub const DSS_DISABLED_BY_REMOTE_SESSION = DESKTOP_SLIDESHOW_STATE.DISABLED_BY_REMOTE_SESSION;

pub const DESKTOP_SLIDESHOW_DIRECTION = enum(i32) {
    FORWARD = 0,
    BACKWARD = 1,
};
pub const DSD_FORWARD = DESKTOP_SLIDESHOW_DIRECTION.FORWARD;
pub const DSD_BACKWARD = DESKTOP_SLIDESHOW_DIRECTION.BACKWARD;

pub const DESKTOP_WALLPAPER_POSITION = enum(i32) {
    CENTER = 0,
    TILE = 1,
    STRETCH = 2,
    FIT = 3,
    FILL = 4,
    SPAN = 5,
};
pub const DWPOS_CENTER = DESKTOP_WALLPAPER_POSITION.CENTER;
pub const DWPOS_TILE = DESKTOP_WALLPAPER_POSITION.TILE;
pub const DWPOS_STRETCH = DESKTOP_WALLPAPER_POSITION.STRETCH;
pub const DWPOS_FIT = DESKTOP_WALLPAPER_POSITION.FIT;
pub const DWPOS_FILL = DESKTOP_WALLPAPER_POSITION.FILL;
pub const DWPOS_SPAN = DESKTOP_WALLPAPER_POSITION.SPAN;

// TODO: this type is limited to platform 'windows8.0'
const IID_IDesktopWallpaper_Value = Guid.initString("b92b56a9-8b55-4e14-9a89-0199bbb6f93b");
pub const IID_IDesktopWallpaper = &IID_IDesktopWallpaper_Value;
pub const IDesktopWallpaper = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetWallpaper: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDesktopWallpaper,
                monitorID: ?[*:0]const u16,
                wallpaper: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDesktopWallpaper,
                monitorID: ?[*:0]const u16,
                wallpaper: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetWallpaper: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDesktopWallpaper,
                monitorID: ?[*:0]const u16,
                wallpaper: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDesktopWallpaper,
                monitorID: ?[*:0]const u16,
                wallpaper: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMonitorDevicePathAt: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDesktopWallpaper,
                monitorIndex: u32,
                monitorID: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDesktopWallpaper,
                monitorIndex: u32,
                monitorID: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMonitorDevicePathCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDesktopWallpaper,
                count: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDesktopWallpaper,
                count: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMonitorRECT: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDesktopWallpaper,
                monitorID: ?[*:0]const u16,
                displayRect: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDesktopWallpaper,
                monitorID: ?[*:0]const u16,
                displayRect: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetBackgroundColor: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDesktopWallpaper,
                color: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDesktopWallpaper,
                color: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBackgroundColor: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDesktopWallpaper,
                color: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDesktopWallpaper,
                color: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDesktopWallpaper,
                position: DESKTOP_WALLPAPER_POSITION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDesktopWallpaper,
                position: DESKTOP_WALLPAPER_POSITION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDesktopWallpaper,
                position: ?*DESKTOP_WALLPAPER_POSITION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDesktopWallpaper,
                position: ?*DESKTOP_WALLPAPER_POSITION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSlideshow: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDesktopWallpaper,
                items: ?*IShellItemArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDesktopWallpaper,
                items: ?*IShellItemArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSlideshow: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDesktopWallpaper,
                items: ?*?*IShellItemArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDesktopWallpaper,
                items: ?*?*IShellItemArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSlideshowOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDesktopWallpaper,
                options: DESKTOP_SLIDESHOW_OPTIONS,
                slideshowTick: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDesktopWallpaper,
                options: DESKTOP_SLIDESHOW_OPTIONS,
                slideshowTick: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSlideshowOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDesktopWallpaper,
                options: ?*DESKTOP_SLIDESHOW_OPTIONS,
                slideshowTick: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDesktopWallpaper,
                options: ?*DESKTOP_SLIDESHOW_OPTIONS,
                slideshowTick: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AdvanceSlideshow: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDesktopWallpaper,
                monitorID: ?[*:0]const u16,
                direction: DESKTOP_SLIDESHOW_DIRECTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDesktopWallpaper,
                monitorID: ?[*:0]const u16,
                direction: DESKTOP_SLIDESHOW_DIRECTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDesktopWallpaper,
                state: ?*DESKTOP_SLIDESHOW_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDesktopWallpaper,
                state: ?*DESKTOP_SLIDESHOW_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Enable: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDesktopWallpaper,
                enable: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDesktopWallpaper,
                enable: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDesktopWallpaper_SetWallpaper(self: *const T, monitorID: ?[*:0]const u16, wallpaper: ?[*:0]const u16) HRESULT {
                return @as(*const IDesktopWallpaper.VTable, @ptrCast(self.vtable)).SetWallpaper(@as(*const IDesktopWallpaper, @ptrCast(self)), monitorID, wallpaper);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDesktopWallpaper_GetWallpaper(self: *const T, monitorID: ?[*:0]const u16, wallpaper: ?*?PWSTR) HRESULT {
                return @as(*const IDesktopWallpaper.VTable, @ptrCast(self.vtable)).GetWallpaper(@as(*const IDesktopWallpaper, @ptrCast(self)), monitorID, wallpaper);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDesktopWallpaper_GetMonitorDevicePathAt(self: *const T, monitorIndex: u32, monitorID: ?*?PWSTR) HRESULT {
                return @as(*const IDesktopWallpaper.VTable, @ptrCast(self.vtable)).GetMonitorDevicePathAt(@as(*const IDesktopWallpaper, @ptrCast(self)), monitorIndex, monitorID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDesktopWallpaper_GetMonitorDevicePathCount(self: *const T, count: ?*u32) HRESULT {
                return @as(*const IDesktopWallpaper.VTable, @ptrCast(self.vtable)).GetMonitorDevicePathCount(@as(*const IDesktopWallpaper, @ptrCast(self)), count);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDesktopWallpaper_GetMonitorRECT(self: *const T, monitorID: ?[*:0]const u16, displayRect: ?*RECT) HRESULT {
                return @as(*const IDesktopWallpaper.VTable, @ptrCast(self.vtable)).GetMonitorRECT(@as(*const IDesktopWallpaper, @ptrCast(self)), monitorID, displayRect);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDesktopWallpaper_SetBackgroundColor(self: *const T, color: u32) HRESULT {
                return @as(*const IDesktopWallpaper.VTable, @ptrCast(self.vtable)).SetBackgroundColor(@as(*const IDesktopWallpaper, @ptrCast(self)), color);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDesktopWallpaper_GetBackgroundColor(self: *const T, color: ?*u32) HRESULT {
                return @as(*const IDesktopWallpaper.VTable, @ptrCast(self.vtable)).GetBackgroundColor(@as(*const IDesktopWallpaper, @ptrCast(self)), color);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDesktopWallpaper_SetPosition(self: *const T, position: DESKTOP_WALLPAPER_POSITION) HRESULT {
                return @as(*const IDesktopWallpaper.VTable, @ptrCast(self.vtable)).SetPosition(@as(*const IDesktopWallpaper, @ptrCast(self)), position);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDesktopWallpaper_GetPosition(self: *const T, position: ?*DESKTOP_WALLPAPER_POSITION) HRESULT {
                return @as(*const IDesktopWallpaper.VTable, @ptrCast(self.vtable)).GetPosition(@as(*const IDesktopWallpaper, @ptrCast(self)), position);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDesktopWallpaper_SetSlideshow(self: *const T, items: ?*IShellItemArray) HRESULT {
                return @as(*const IDesktopWallpaper.VTable, @ptrCast(self.vtable)).SetSlideshow(@as(*const IDesktopWallpaper, @ptrCast(self)), items);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDesktopWallpaper_GetSlideshow(self: *const T, items: ?*?*IShellItemArray) HRESULT {
                return @as(*const IDesktopWallpaper.VTable, @ptrCast(self.vtable)).GetSlideshow(@as(*const IDesktopWallpaper, @ptrCast(self)), items);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDesktopWallpaper_SetSlideshowOptions(self: *const T, options: DESKTOP_SLIDESHOW_OPTIONS, slideshowTick: u32) HRESULT {
                return @as(*const IDesktopWallpaper.VTable, @ptrCast(self.vtable)).SetSlideshowOptions(@as(*const IDesktopWallpaper, @ptrCast(self)), options, slideshowTick);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDesktopWallpaper_GetSlideshowOptions(self: *const T, options: ?*DESKTOP_SLIDESHOW_OPTIONS, slideshowTick: ?*u32) HRESULT {
                return @as(*const IDesktopWallpaper.VTable, @ptrCast(self.vtable)).GetSlideshowOptions(@as(*const IDesktopWallpaper, @ptrCast(self)), options, slideshowTick);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDesktopWallpaper_AdvanceSlideshow(self: *const T, monitorID: ?[*:0]const u16, direction: DESKTOP_SLIDESHOW_DIRECTION) HRESULT {
                return @as(*const IDesktopWallpaper.VTable, @ptrCast(self.vtable)).AdvanceSlideshow(@as(*const IDesktopWallpaper, @ptrCast(self)), monitorID, direction);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDesktopWallpaper_GetStatus(self: *const T, state: ?*DESKTOP_SLIDESHOW_STATE) HRESULT {
                return @as(*const IDesktopWallpaper.VTable, @ptrCast(self.vtable)).GetStatus(@as(*const IDesktopWallpaper, @ptrCast(self)), state);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDesktopWallpaper_Enable(self: *const T, enable: BOOL) HRESULT {
                return @as(*const IDesktopWallpaper.VTable, @ptrCast(self.vtable)).Enable(@as(*const IDesktopWallpaper, @ptrCast(self)), enable);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const HOMEGROUPSHARINGCHOICES = enum(i32) {
    NONE = 0,
    MUSICLIBRARY = 1,
    PICTURESLIBRARY = 2,
    VIDEOSLIBRARY = 4,
    DOCUMENTSLIBRARY = 8,
    PRINTERS = 16,
};
pub const HGSC_NONE = HOMEGROUPSHARINGCHOICES.NONE;
pub const HGSC_MUSICLIBRARY = HOMEGROUPSHARINGCHOICES.MUSICLIBRARY;
pub const HGSC_PICTURESLIBRARY = HOMEGROUPSHARINGCHOICES.PICTURESLIBRARY;
pub const HGSC_VIDEOSLIBRARY = HOMEGROUPSHARINGCHOICES.VIDEOSLIBRARY;
pub const HGSC_DOCUMENTSLIBRARY = HOMEGROUPSHARINGCHOICES.DOCUMENTSLIBRARY;
pub const HGSC_PRINTERS = HOMEGROUPSHARINGCHOICES.PRINTERS;

// TODO: this type is limited to platform 'windows6.1'
const IID_IHomeGroup_Value = Guid.initString("7a3bd1d9-35a9-4fb3-a467-f48cac35e2d0");
pub const IID_IHomeGroup = &IID_IHomeGroup_Value;
pub const IHomeGroup = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IsMember: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IHomeGroup,
                member: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IHomeGroup,
                member: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ShowSharingWizard: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IHomeGroup,
                owner: ?HWND,
                sharingchoices: ?*HOMEGROUPSHARINGCHOICES,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IHomeGroup,
                owner: ?HWND,
                sharingchoices: ?*HOMEGROUPSHARINGCHOICES,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IHomeGroup_IsMember(self: *const T, member: ?*BOOL) HRESULT {
                return @as(*const IHomeGroup.VTable, @ptrCast(self.vtable)).IsMember(@as(*const IHomeGroup, @ptrCast(self)), member);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IHomeGroup_ShowSharingWizard(self: *const T, owner: ?HWND, sharingchoices: ?*HOMEGROUPSHARINGCHOICES) HRESULT {
                return @as(*const IHomeGroup.VTable, @ptrCast(self.vtable)).ShowSharingWizard(@as(*const IHomeGroup, @ptrCast(self)), owner, sharingchoices);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IInitializeWithPropertyStore_Value = Guid.initString("c3e12eb5-7d8d-44f8-b6dd-0e77b34d6de4");
pub const IID_IInitializeWithPropertyStore = &IID_IInitializeWithPropertyStore_Value;
pub const IInitializeWithPropertyStore = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInitializeWithPropertyStore,
                pps: ?*IPropertyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInitializeWithPropertyStore,
                pps: ?*IPropertyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInitializeWithPropertyStore_Initialize(self: *const T, pps: ?*IPropertyStore) HRESULT {
                return @as(*const IInitializeWithPropertyStore.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IInitializeWithPropertyStore, @ptrCast(self)), pps);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IOpenSearchSource_Value = Guid.initString("f0ee7333-e6fc-479b-9f25-a860c234a38e");
pub const IID_IOpenSearchSource = &IID_IOpenSearchSource_Value;
pub const IOpenSearchSource = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetResults: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOpenSearchSource,
                hwnd: ?HWND,
                pszQuery: ?[*:0]const u16,
                dwStartIndex: u32,
                dwCount: u32,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOpenSearchSource,
                hwnd: ?HWND,
                pszQuery: ?[*:0]const u16,
                dwStartIndex: u32,
                dwCount: u32,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOpenSearchSource_GetResults(self: *const T, hwnd: ?HWND, pszQuery: ?[*:0]const u16, dwStartIndex: u32, dwCount: u32, riid: ?*const Guid, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const IOpenSearchSource.VTable, @ptrCast(self.vtable)).GetResults(@as(*const IOpenSearchSource, @ptrCast(self)), hwnd, pszQuery, dwStartIndex, dwCount, riid, ppv);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const LIBRARYFOLDERFILTER = enum(i32) {
    FORCEFILESYSTEM = 1,
    STORAGEITEMS = 2,
    ALLITEMS = 3,
};
pub const LFF_FORCEFILESYSTEM = LIBRARYFOLDERFILTER.FORCEFILESYSTEM;
pub const LFF_STORAGEITEMS = LIBRARYFOLDERFILTER.STORAGEITEMS;
pub const LFF_ALLITEMS = LIBRARYFOLDERFILTER.ALLITEMS;

pub const LIBRARYOPTIONFLAGS = enum(i32) {
    DEFAULT = 0,
    PINNEDTONAVPANE = 1,
    // MASK_ALL = 1, this enum value conflicts with PINNEDTONAVPANE
};
pub const LOF_DEFAULT = LIBRARYOPTIONFLAGS.DEFAULT;
pub const LOF_PINNEDTONAVPANE = LIBRARYOPTIONFLAGS.PINNEDTONAVPANE;
pub const LOF_MASK_ALL = LIBRARYOPTIONFLAGS.PINNEDTONAVPANE;

pub const DEFAULTSAVEFOLDERTYPE = enum(i32) {
    DETECT = 1,
    PRIVATE = 2,
    PUBLIC = 3,
};
pub const DSFT_DETECT = DEFAULTSAVEFOLDERTYPE.DETECT;
pub const DSFT_PRIVATE = DEFAULTSAVEFOLDERTYPE.PRIVATE;
pub const DSFT_PUBLIC = DEFAULTSAVEFOLDERTYPE.PUBLIC;

pub const LIBRARYSAVEFLAGS = enum(i32) {
    FAILIFTHERE = 0,
    OVERRIDEEXISTING = 1,
    MAKEUNIQUENAME = 2,
};
pub const LSF_FAILIFTHERE = LIBRARYSAVEFLAGS.FAILIFTHERE;
pub const LSF_OVERRIDEEXISTING = LIBRARYSAVEFLAGS.OVERRIDEEXISTING;
pub const LSF_MAKEUNIQUENAME = LIBRARYSAVEFLAGS.MAKEUNIQUENAME;

// TODO: this type is limited to platform 'windows6.1'
const IID_IShellLibrary_Value = Guid.initString("11a66efa-382e-451a-9234-1e0e12ef3085");
pub const IID_IShellLibrary = &IID_IShellLibrary_Value;
pub const IShellLibrary = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        LoadLibraryFromItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellLibrary,
                psiLibrary: ?*IShellItem,
                grfMode: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellLibrary,
                psiLibrary: ?*IShellItem,
                grfMode: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LoadLibraryFromKnownFolder: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellLibrary,
                kfidLibrary: ?*const Guid,
                grfMode: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellLibrary,
                kfidLibrary: ?*const Guid,
                grfMode: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddFolder: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellLibrary,
                psiLocation: ?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellLibrary,
                psiLocation: ?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveFolder: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellLibrary,
                psiLocation: ?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellLibrary,
                psiLocation: ?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFolders: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellLibrary,
                lff: LIBRARYFOLDERFILTER,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellLibrary,
                lff: LIBRARYFOLDERFILTER,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ResolveFolder: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellLibrary,
                psiFolderToResolve: ?*IShellItem,
                dwTimeout: u32,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellLibrary,
                psiFolderToResolve: ?*IShellItem,
                dwTimeout: u32,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDefaultSaveFolder: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellLibrary,
                dsft: DEFAULTSAVEFOLDERTYPE,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellLibrary,
                dsft: DEFAULTSAVEFOLDERTYPE,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDefaultSaveFolder: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellLibrary,
                dsft: DEFAULTSAVEFOLDERTYPE,
                psi: ?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellLibrary,
                dsft: DEFAULTSAVEFOLDERTYPE,
                psi: ?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellLibrary,
                plofOptions: ?*LIBRARYOPTIONFLAGS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellLibrary,
                plofOptions: ?*LIBRARYOPTIONFLAGS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellLibrary,
                lofMask: LIBRARYOPTIONFLAGS,
                lofOptions: LIBRARYOPTIONFLAGS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellLibrary,
                lofMask: LIBRARYOPTIONFLAGS,
                lofOptions: LIBRARYOPTIONFLAGS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFolderType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellLibrary,
                pftid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellLibrary,
                pftid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFolderType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellLibrary,
                ftid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellLibrary,
                ftid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIcon: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellLibrary,
                ppszIcon: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellLibrary,
                ppszIcon: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetIcon: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellLibrary,
                pszIcon: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellLibrary,
                pszIcon: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Commit: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellLibrary,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellLibrary,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Save: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellLibrary,
                psiFolderToSaveIn: ?*IShellItem,
                pszLibraryName: ?[*:0]const u16,
                lsf: LIBRARYSAVEFLAGS,
                ppsiSavedTo: ?*?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellLibrary,
                psiFolderToSaveIn: ?*IShellItem,
                pszLibraryName: ?[*:0]const u16,
                lsf: LIBRARYSAVEFLAGS,
                ppsiSavedTo: ?*?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SaveInKnownFolder: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellLibrary,
                kfidToSaveIn: ?*const Guid,
                pszLibraryName: ?[*:0]const u16,
                lsf: LIBRARYSAVEFLAGS,
                ppsiSavedTo: ?*?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellLibrary,
                kfidToSaveIn: ?*const Guid,
                pszLibraryName: ?[*:0]const u16,
                lsf: LIBRARYSAVEFLAGS,
                ppsiSavedTo: ?*?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellLibrary_LoadLibraryFromItem(self: *const T, psiLibrary: ?*IShellItem, grfMode: u32) HRESULT {
                return @as(*const IShellLibrary.VTable, @ptrCast(self.vtable)).LoadLibraryFromItem(@as(*const IShellLibrary, @ptrCast(self)), psiLibrary, grfMode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellLibrary_LoadLibraryFromKnownFolder(self: *const T, kfidLibrary: ?*const Guid, grfMode: u32) HRESULT {
                return @as(*const IShellLibrary.VTable, @ptrCast(self.vtable)).LoadLibraryFromKnownFolder(@as(*const IShellLibrary, @ptrCast(self)), kfidLibrary, grfMode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellLibrary_AddFolder(self: *const T, psiLocation: ?*IShellItem) HRESULT {
                return @as(*const IShellLibrary.VTable, @ptrCast(self.vtable)).AddFolder(@as(*const IShellLibrary, @ptrCast(self)), psiLocation);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellLibrary_RemoveFolder(self: *const T, psiLocation: ?*IShellItem) HRESULT {
                return @as(*const IShellLibrary.VTable, @ptrCast(self.vtable)).RemoveFolder(@as(*const IShellLibrary, @ptrCast(self)), psiLocation);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellLibrary_GetFolders(self: *const T, lff: LIBRARYFOLDERFILTER, riid: ?*const Guid, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const IShellLibrary.VTable, @ptrCast(self.vtable)).GetFolders(@as(*const IShellLibrary, @ptrCast(self)), lff, riid, ppv);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellLibrary_ResolveFolder(self: *const T, psiFolderToResolve: ?*IShellItem, dwTimeout: u32, riid: ?*const Guid, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const IShellLibrary.VTable, @ptrCast(self.vtable)).ResolveFolder(@as(*const IShellLibrary, @ptrCast(self)), psiFolderToResolve, dwTimeout, riid, ppv);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellLibrary_GetDefaultSaveFolder(self: *const T, dsft: DEFAULTSAVEFOLDERTYPE, riid: ?*const Guid, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const IShellLibrary.VTable, @ptrCast(self.vtable)).GetDefaultSaveFolder(@as(*const IShellLibrary, @ptrCast(self)), dsft, riid, ppv);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellLibrary_SetDefaultSaveFolder(self: *const T, dsft: DEFAULTSAVEFOLDERTYPE, psi: ?*IShellItem) HRESULT {
                return @as(*const IShellLibrary.VTable, @ptrCast(self.vtable)).SetDefaultSaveFolder(@as(*const IShellLibrary, @ptrCast(self)), dsft, psi);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellLibrary_GetOptions(self: *const T, plofOptions: ?*LIBRARYOPTIONFLAGS) HRESULT {
                return @as(*const IShellLibrary.VTable, @ptrCast(self.vtable)).GetOptions(@as(*const IShellLibrary, @ptrCast(self)), plofOptions);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellLibrary_SetOptions(self: *const T, lofMask: LIBRARYOPTIONFLAGS, lofOptions: LIBRARYOPTIONFLAGS) HRESULT {
                return @as(*const IShellLibrary.VTable, @ptrCast(self.vtable)).SetOptions(@as(*const IShellLibrary, @ptrCast(self)), lofMask, lofOptions);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellLibrary_GetFolderType(self: *const T, pftid: ?*Guid) HRESULT {
                return @as(*const IShellLibrary.VTable, @ptrCast(self.vtable)).GetFolderType(@as(*const IShellLibrary, @ptrCast(self)), pftid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellLibrary_SetFolderType(self: *const T, ftid: ?*const Guid) HRESULT {
                return @as(*const IShellLibrary.VTable, @ptrCast(self.vtable)).SetFolderType(@as(*const IShellLibrary, @ptrCast(self)), ftid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellLibrary_GetIcon(self: *const T, ppszIcon: ?*?PWSTR) HRESULT {
                return @as(*const IShellLibrary.VTable, @ptrCast(self.vtable)).GetIcon(@as(*const IShellLibrary, @ptrCast(self)), ppszIcon);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellLibrary_SetIcon(self: *const T, pszIcon: ?[*:0]const u16) HRESULT {
                return @as(*const IShellLibrary.VTable, @ptrCast(self.vtable)).SetIcon(@as(*const IShellLibrary, @ptrCast(self)), pszIcon);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellLibrary_Commit(self: *const T) HRESULT {
                return @as(*const IShellLibrary.VTable, @ptrCast(self.vtable)).Commit(@as(*const IShellLibrary, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellLibrary_Save(self: *const T, psiFolderToSaveIn: ?*IShellItem, pszLibraryName: ?[*:0]const u16, lsf: LIBRARYSAVEFLAGS, ppsiSavedTo: ?*?*IShellItem) HRESULT {
                return @as(*const IShellLibrary.VTable, @ptrCast(self.vtable)).Save(@as(*const IShellLibrary, @ptrCast(self)), psiFolderToSaveIn, pszLibraryName, lsf, ppsiSavedTo);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellLibrary_SaveInKnownFolder(self: *const T, kfidToSaveIn: ?*const Guid, pszLibraryName: ?[*:0]const u16, lsf: LIBRARYSAVEFLAGS, ppsiSavedTo: ?*?*IShellItem) HRESULT {
                return @as(*const IShellLibrary.VTable, @ptrCast(self.vtable)).SaveInKnownFolder(@as(*const IShellLibrary, @ptrCast(self)), kfidToSaveIn, pszLibraryName, lsf, ppsiSavedTo);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DEFAULT_FOLDER_MENU_RESTRICTIONS = enum(i32) {
    DEFAULT = 0,
    NO_STATIC_VERBS = 8,
    STATIC_VERBS_ONLY = 16,
    NO_RESOURCE_VERBS = 32,
    OPTIN_HANDLERS_ONLY = 64,
    RESOURCE_AND_FOLDER_VERBS_ONLY = 128,
    USE_SPECIFIED_HANDLERS = 256,
    USE_SPECIFIED_VERBS = 512,
    NO_ASYNC_VERBS = 1024,
    NO_NATIVECPU_VERBS = 2048,
    NO_NONWOW_VERBS = 4096,
};
pub const DFMR_DEFAULT = DEFAULT_FOLDER_MENU_RESTRICTIONS.DEFAULT;
pub const DFMR_NO_STATIC_VERBS = DEFAULT_FOLDER_MENU_RESTRICTIONS.NO_STATIC_VERBS;
pub const DFMR_STATIC_VERBS_ONLY = DEFAULT_FOLDER_MENU_RESTRICTIONS.STATIC_VERBS_ONLY;
pub const DFMR_NO_RESOURCE_VERBS = DEFAULT_FOLDER_MENU_RESTRICTIONS.NO_RESOURCE_VERBS;
pub const DFMR_OPTIN_HANDLERS_ONLY = DEFAULT_FOLDER_MENU_RESTRICTIONS.OPTIN_HANDLERS_ONLY;
pub const DFMR_RESOURCE_AND_FOLDER_VERBS_ONLY = DEFAULT_FOLDER_MENU_RESTRICTIONS.RESOURCE_AND_FOLDER_VERBS_ONLY;
pub const DFMR_USE_SPECIFIED_HANDLERS = DEFAULT_FOLDER_MENU_RESTRICTIONS.USE_SPECIFIED_HANDLERS;
pub const DFMR_USE_SPECIFIED_VERBS = DEFAULT_FOLDER_MENU_RESTRICTIONS.USE_SPECIFIED_VERBS;
pub const DFMR_NO_ASYNC_VERBS = DEFAULT_FOLDER_MENU_RESTRICTIONS.NO_ASYNC_VERBS;
pub const DFMR_NO_NATIVECPU_VERBS = DEFAULT_FOLDER_MENU_RESTRICTIONS.NO_NATIVECPU_VERBS;
pub const DFMR_NO_NONWOW_VERBS = DEFAULT_FOLDER_MENU_RESTRICTIONS.NO_NONWOW_VERBS;

// TODO: this type is limited to platform 'windows8.0'
const IID_IDefaultFolderMenuInitialize_Value = Guid.initString("7690aa79-f8fc-4615-a327-36f7d18f5d91");
pub const IID_IDefaultFolderMenuInitialize = &IID_IDefaultFolderMenuInitialize_Value;
pub const IDefaultFolderMenuInitialize = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDefaultFolderMenuInitialize,
                hwnd: ?HWND,
                pcmcb: ?*IContextMenuCB,
                pidlFolder: ?*ITEMIDLIST,
                psf: ?*IShellFolder,
                cidl: u32,
                apidl: [*]?*ITEMIDLIST,
                punkAssociation: ?*IUnknown,
                cKeys: u32,
                aKeys: ?*const ?HKEY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDefaultFolderMenuInitialize,
                hwnd: ?HWND,
                pcmcb: ?*IContextMenuCB,
                pidlFolder: ?*ITEMIDLIST,
                psf: ?*IShellFolder,
                cidl: u32,
                apidl: [*]?*ITEMIDLIST,
                punkAssociation: ?*IUnknown,
                cKeys: u32,
                aKeys: ?*const ?HKEY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetMenuRestrictions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDefaultFolderMenuInitialize,
                dfmrValues: DEFAULT_FOLDER_MENU_RESTRICTIONS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDefaultFolderMenuInitialize,
                dfmrValues: DEFAULT_FOLDER_MENU_RESTRICTIONS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMenuRestrictions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDefaultFolderMenuInitialize,
                dfmrMask: DEFAULT_FOLDER_MENU_RESTRICTIONS,
                pdfmrValues: ?*DEFAULT_FOLDER_MENU_RESTRICTIONS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDefaultFolderMenuInitialize,
                dfmrMask: DEFAULT_FOLDER_MENU_RESTRICTIONS,
                pdfmrValues: ?*DEFAULT_FOLDER_MENU_RESTRICTIONS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetHandlerClsid: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDefaultFolderMenuInitialize,
                rclsid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDefaultFolderMenuInitialize,
                rclsid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDefaultFolderMenuInitialize_Initialize(self: *const T, hwnd: ?HWND, pcmcb: ?*IContextMenuCB, pidlFolder: ?*ITEMIDLIST, psf: ?*IShellFolder, cidl: u32, apidl: [*]?*ITEMIDLIST, punkAssociation: ?*IUnknown, cKeys: u32, aKeys: ?*const ?HKEY) HRESULT {
                return @as(*const IDefaultFolderMenuInitialize.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IDefaultFolderMenuInitialize, @ptrCast(self)), hwnd, pcmcb, pidlFolder, psf, cidl, apidl, punkAssociation, cKeys, aKeys);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDefaultFolderMenuInitialize_SetMenuRestrictions(self: *const T, dfmrValues: DEFAULT_FOLDER_MENU_RESTRICTIONS) HRESULT {
                return @as(*const IDefaultFolderMenuInitialize.VTable, @ptrCast(self.vtable)).SetMenuRestrictions(@as(*const IDefaultFolderMenuInitialize, @ptrCast(self)), dfmrValues);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDefaultFolderMenuInitialize_GetMenuRestrictions(self: *const T, dfmrMask: DEFAULT_FOLDER_MENU_RESTRICTIONS, pdfmrValues: ?*DEFAULT_FOLDER_MENU_RESTRICTIONS) HRESULT {
                return @as(*const IDefaultFolderMenuInitialize.VTable, @ptrCast(self.vtable)).GetMenuRestrictions(@as(*const IDefaultFolderMenuInitialize, @ptrCast(self)), dfmrMask, pdfmrValues);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDefaultFolderMenuInitialize_SetHandlerClsid(self: *const T, rclsid: ?*const Guid) HRESULT {
                return @as(*const IDefaultFolderMenuInitialize.VTable, @ptrCast(self.vtable)).SetHandlerClsid(@as(*const IDefaultFolderMenuInitialize, @ptrCast(self)), rclsid);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const ACTIVATEOPTIONS = enum(i32) {
    NONE = 0,
    DESIGNMODE = 1,
    NOERRORUI = 2,
    NOSPLASHSCREEN = 4,
    PRELAUNCH = 33554432,
};
pub const AO_NONE = ACTIVATEOPTIONS.NONE;
pub const AO_DESIGNMODE = ACTIVATEOPTIONS.DESIGNMODE;
pub const AO_NOERRORUI = ACTIVATEOPTIONS.NOERRORUI;
pub const AO_NOSPLASHSCREEN = ACTIVATEOPTIONS.NOSPLASHSCREEN;
pub const AO_PRELAUNCH = ACTIVATEOPTIONS.PRELAUNCH;

// TODO: this type is limited to platform 'windows8.0'
const IID_IApplicationActivationManager_Value = Guid.initString("2e941141-7f97-4756-ba1d-9decde894a3d");
pub const IID_IApplicationActivationManager = &IID_IApplicationActivationManager_Value;
pub const IApplicationActivationManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ActivateApplication: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IApplicationActivationManager,
                appUserModelId: ?[*:0]const u16,
                arguments: ?[*:0]const u16,
                options: ACTIVATEOPTIONS,
                processId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IApplicationActivationManager,
                appUserModelId: ?[*:0]const u16,
                arguments: ?[*:0]const u16,
                options: ACTIVATEOPTIONS,
                processId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ActivateForFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IApplicationActivationManager,
                appUserModelId: ?[*:0]const u16,
                itemArray: ?*IShellItemArray,
                verb: ?[*:0]const u16,
                processId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IApplicationActivationManager,
                appUserModelId: ?[*:0]const u16,
                itemArray: ?*IShellItemArray,
                verb: ?[*:0]const u16,
                processId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ActivateForProtocol: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IApplicationActivationManager,
                appUserModelId: ?[*:0]const u16,
                itemArray: ?*IShellItemArray,
                processId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IApplicationActivationManager,
                appUserModelId: ?[*:0]const u16,
                itemArray: ?*IShellItemArray,
                processId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IApplicationActivationManager_ActivateApplication(self: *const T, appUserModelId: ?[*:0]const u16, arguments: ?[*:0]const u16, options: ACTIVATEOPTIONS, processId: ?*u32) HRESULT {
                return @as(*const IApplicationActivationManager.VTable, @ptrCast(self.vtable)).ActivateApplication(@as(*const IApplicationActivationManager, @ptrCast(self)), appUserModelId, arguments, options, processId);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IApplicationActivationManager_ActivateForFile(self: *const T, appUserModelId: ?[*:0]const u16, itemArray: ?*IShellItemArray, verb: ?[*:0]const u16, processId: ?*u32) HRESULT {
                return @as(*const IApplicationActivationManager.VTable, @ptrCast(self.vtable)).ActivateForFile(@as(*const IApplicationActivationManager, @ptrCast(self)), appUserModelId, itemArray, verb, processId);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IApplicationActivationManager_ActivateForProtocol(self: *const T, appUserModelId: ?[*:0]const u16, itemArray: ?*IShellItemArray, processId: ?*u32) HRESULT {
                return @as(*const IApplicationActivationManager.VTable, @ptrCast(self.vtable)).ActivateForProtocol(@as(*const IApplicationActivationManager, @ptrCast(self)), appUserModelId, itemArray, processId);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IVirtualDesktopManager_Value = Guid.initString("a5cd92ff-29be-454c-8d04-d82879fb3f1b");
pub const IID_IVirtualDesktopManager = &IID_IVirtualDesktopManager_Value;
pub const IVirtualDesktopManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IsWindowOnCurrentVirtualDesktop: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IVirtualDesktopManager,
                topLevelWindow: ?HWND,
                onCurrentDesktop: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IVirtualDesktopManager,
                topLevelWindow: ?HWND,
                onCurrentDesktop: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetWindowDesktopId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IVirtualDesktopManager,
                topLevelWindow: ?HWND,
                desktopId: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IVirtualDesktopManager,
                topLevelWindow: ?HWND,
                desktopId: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        MoveWindowToDesktop: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IVirtualDesktopManager,
                topLevelWindow: ?HWND,
                desktopId: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IVirtualDesktopManager,
                topLevelWindow: ?HWND,
                desktopId: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IVirtualDesktopManager_IsWindowOnCurrentVirtualDesktop(self: *const T, topLevelWindow: ?HWND, onCurrentDesktop: ?*BOOL) HRESULT {
                return @as(*const IVirtualDesktopManager.VTable, @ptrCast(self.vtable)).IsWindowOnCurrentVirtualDesktop(@as(*const IVirtualDesktopManager, @ptrCast(self)), topLevelWindow, onCurrentDesktop);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IVirtualDesktopManager_GetWindowDesktopId(self: *const T, topLevelWindow: ?HWND, desktopId: ?*Guid) HRESULT {
                return @as(*const IVirtualDesktopManager.VTable, @ptrCast(self.vtable)).GetWindowDesktopId(@as(*const IVirtualDesktopManager, @ptrCast(self)), topLevelWindow, desktopId);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IVirtualDesktopManager_MoveWindowToDesktop(self: *const T, topLevelWindow: ?HWND, desktopId: ?*const Guid) HRESULT {
                return @as(*const IVirtualDesktopManager.VTable, @ptrCast(self.vtable)).MoveWindowToDesktop(@as(*const IVirtualDesktopManager, @ptrCast(self)), topLevelWindow, desktopId);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const LIBRARYMANAGEDIALOGOPTIONS = enum(i32) {
    DEFAULT = 0,
    ALLOWUNINDEXABLENETWORKLOCATIONS = 1,
};
pub const LMD_DEFAULT = LIBRARYMANAGEDIALOGOPTIONS.DEFAULT;
pub const LMD_ALLOWUNINDEXABLENETWORKLOCATIONS = LIBRARYMANAGEDIALOGOPTIONS.ALLOWUNINDEXABLENETWORKLOCATIONS;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAssocHandlerInvoker_Value = Guid.initString("92218cab-ecaa-4335-8133-807fd234c2ee");
pub const IID_IAssocHandlerInvoker = &IID_IAssocHandlerInvoker_Value;
pub const IAssocHandlerInvoker = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SupportsSelection: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAssocHandlerInvoker,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAssocHandlerInvoker,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Invoke: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAssocHandlerInvoker,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAssocHandlerInvoker,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAssocHandlerInvoker_SupportsSelection(self: *const T) HRESULT {
                return @as(*const IAssocHandlerInvoker.VTable, @ptrCast(self.vtable)).SupportsSelection(@as(*const IAssocHandlerInvoker, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAssocHandlerInvoker_Invoke(self: *const T) HRESULT {
                return @as(*const IAssocHandlerInvoker.VTable, @ptrCast(self.vtable)).Invoke(@as(*const IAssocHandlerInvoker, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const AHTYPE = enum(i32) {
    UNDEFINED = 0,
    USER_APPLICATION = 8,
    ANY_APPLICATION = 16,
    MACHINEDEFAULT = 32,
    PROGID = 64,
    APPLICATION = 128,
    CLASS_APPLICATION = 256,
    ANY_PROGID = 512,
};
pub const AHTYPE_UNDEFINED = AHTYPE.UNDEFINED;
pub const AHTYPE_USER_APPLICATION = AHTYPE.USER_APPLICATION;
pub const AHTYPE_ANY_APPLICATION = AHTYPE.ANY_APPLICATION;
pub const AHTYPE_MACHINEDEFAULT = AHTYPE.MACHINEDEFAULT;
pub const AHTYPE_PROGID = AHTYPE.PROGID;
pub const AHTYPE_APPLICATION = AHTYPE.APPLICATION;
pub const AHTYPE_CLASS_APPLICATION = AHTYPE.CLASS_APPLICATION;
pub const AHTYPE_ANY_PROGID = AHTYPE.ANY_PROGID;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAssocHandler_Value = Guid.initString("f04061ac-1659-4a3f-a954-775aa57fc083");
pub const IID_IAssocHandler = &IID_IAssocHandler_Value;
pub const IAssocHandler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAssocHandler,
                ppsz: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAssocHandler,
                ppsz: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetUIName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAssocHandler,
                ppsz: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAssocHandler,
                ppsz: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIconLocation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAssocHandler,
                ppszPath: ?*?PWSTR,
                pIndex: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAssocHandler,
                ppszPath: ?*?PWSTR,
                pIndex: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsRecommended: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAssocHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAssocHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        MakeDefault: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAssocHandler,
                pszDescription: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAssocHandler,
                pszDescription: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Invoke: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAssocHandler,
                pdo: ?*IDataObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAssocHandler,
                pdo: ?*IDataObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateInvoker: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAssocHandler,
                pdo: ?*IDataObject,
                ppInvoker: ?*?*IAssocHandlerInvoker,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAssocHandler,
                pdo: ?*IDataObject,
                ppInvoker: ?*?*IAssocHandlerInvoker,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAssocHandler_GetName(self: *const T, ppsz: ?*?PWSTR) HRESULT {
                return @as(*const IAssocHandler.VTable, @ptrCast(self.vtable)).GetName(@as(*const IAssocHandler, @ptrCast(self)), ppsz);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAssocHandler_GetUIName(self: *const T, ppsz: ?*?PWSTR) HRESULT {
                return @as(*const IAssocHandler.VTable, @ptrCast(self.vtable)).GetUIName(@as(*const IAssocHandler, @ptrCast(self)), ppsz);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAssocHandler_GetIconLocation(self: *const T, ppszPath: ?*?PWSTR, pIndex: ?*i32) HRESULT {
                return @as(*const IAssocHandler.VTable, @ptrCast(self.vtable)).GetIconLocation(@as(*const IAssocHandler, @ptrCast(self)), ppszPath, pIndex);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAssocHandler_IsRecommended(self: *const T) HRESULT {
                return @as(*const IAssocHandler.VTable, @ptrCast(self.vtable)).IsRecommended(@as(*const IAssocHandler, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAssocHandler_MakeDefault(self: *const T, pszDescription: ?[*:0]const u16) HRESULT {
                return @as(*const IAssocHandler.VTable, @ptrCast(self.vtable)).MakeDefault(@as(*const IAssocHandler, @ptrCast(self)), pszDescription);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAssocHandler_Invoke(self: *const T, pdo: ?*IDataObject) HRESULT {
                return @as(*const IAssocHandler.VTable, @ptrCast(self.vtable)).Invoke(@as(*const IAssocHandler, @ptrCast(self)), pdo);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAssocHandler_CreateInvoker(self: *const T, pdo: ?*IDataObject, ppInvoker: ?*?*IAssocHandlerInvoker) HRESULT {
                return @as(*const IAssocHandler.VTable, @ptrCast(self.vtable)).CreateInvoker(@as(*const IAssocHandler, @ptrCast(self)), pdo, ppInvoker);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IEnumAssocHandlers_Value = Guid.initString("973810ae-9599-4b88-9e4d-6ee98c9552da");
pub const IID_IEnumAssocHandlers = &IID_IEnumAssocHandlers_Value;
pub const IEnumAssocHandlers = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumAssocHandlers,
                celt: u32,
                rgelt: [*]?*IAssocHandler,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumAssocHandlers,
                celt: u32,
                rgelt: [*]?*IAssocHandler,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumAssocHandlers_Next(self: *const T, celt: u32, rgelt: [*]?*IAssocHandler, pceltFetched: ?*u32) HRESULT {
                return @as(*const IEnumAssocHandlers.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumAssocHandlers, @ptrCast(self)), celt, rgelt, pceltFetched);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const ASSOC_FILTER = enum(i32) {
    NONE = 0,
    RECOMMENDED = 1,
};
pub const ASSOC_FILTER_NONE = ASSOC_FILTER.NONE;
pub const ASSOC_FILTER_RECOMMENDED = ASSOC_FILTER.RECOMMENDED;

// TODO: this type is limited to platform 'windows8.0'
const IID_IDataObjectProvider_Value = Guid.initString("3d25f6d6-4b2a-433c-9184-7c33ad35d001");
pub const IID_IDataObjectProvider = &IID_IDataObjectProvider_Value;
pub const IDataObjectProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDataObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataObjectProvider,
                dataObject: ?*?*IDataObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataObjectProvider,
                dataObject: ?*?*IDataObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDataObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataObjectProvider,
                dataObject: ?*IDataObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataObjectProvider,
                dataObject: ?*IDataObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataObjectProvider_GetDataObject(self: *const T, dataObject: ?*?*IDataObject) HRESULT {
                return @as(*const IDataObjectProvider.VTable, @ptrCast(self.vtable)).GetDataObject(@as(*const IDataObjectProvider, @ptrCast(self)), dataObject);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataObjectProvider_SetDataObject(self: *const T, dataObject: ?*IDataObject) HRESULT {
                return @as(*const IDataObjectProvider.VTable, @ptrCast(self.vtable)).SetDataObject(@as(*const IDataObjectProvider, @ptrCast(self)), dataObject);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IDataTransferManagerInterop_Value = Guid.initString("3a3dcd6c-3eab-43dc-bcde-45671ce800c8");
pub const IID_IDataTransferManagerInterop = &IID_IDataTransferManagerInterop_Value;
pub const IDataTransferManagerInterop = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetForWindow: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataTransferManagerInterop,
                appWindow: ?HWND,
                riid: ?*const Guid,
                dataTransferManager: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataTransferManagerInterop,
                appWindow: ?HWND,
                riid: ?*const Guid,
                dataTransferManager: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ShowShareUIForWindow: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataTransferManagerInterop,
                appWindow: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataTransferManagerInterop,
                appWindow: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataTransferManagerInterop_GetForWindow(self: *const T, appWindow: ?HWND, riid: ?*const Guid, dataTransferManager: ?*?*anyopaque) HRESULT {
                return @as(*const IDataTransferManagerInterop.VTable, @ptrCast(self.vtable)).GetForWindow(@as(*const IDataTransferManagerInterop, @ptrCast(self)), appWindow, riid, dataTransferManager);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataTransferManagerInterop_ShowShareUIForWindow(self: *const T, appWindow: ?HWND) HRESULT {
                return @as(*const IDataTransferManagerInterop.VTable, @ptrCast(self.vtable)).ShowShareUIForWindow(@as(*const IDataTransferManagerInterop, @ptrCast(self)), appWindow);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IFrameworkInputPaneHandler_Value = Guid.initString("226c537b-1e76-4d9e-a760-33db29922f18");
pub const IID_IFrameworkInputPaneHandler = &IID_IFrameworkInputPaneHandler_Value;
pub const IFrameworkInputPaneHandler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Showing: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFrameworkInputPaneHandler,
                prcInputPaneScreenLocation: ?*RECT,
                fEnsureFocusedElementInView: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFrameworkInputPaneHandler,
                prcInputPaneScreenLocation: ?*RECT,
                fEnsureFocusedElementInView: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Hiding: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFrameworkInputPaneHandler,
                fEnsureFocusedElementInView: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFrameworkInputPaneHandler,
                fEnsureFocusedElementInView: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFrameworkInputPaneHandler_Showing(self: *const T, prcInputPaneScreenLocation: ?*RECT, fEnsureFocusedElementInView: BOOL) HRESULT {
                return @as(*const IFrameworkInputPaneHandler.VTable, @ptrCast(self.vtable)).Showing(@as(*const IFrameworkInputPaneHandler, @ptrCast(self)), prcInputPaneScreenLocation, fEnsureFocusedElementInView);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFrameworkInputPaneHandler_Hiding(self: *const T, fEnsureFocusedElementInView: BOOL) HRESULT {
                return @as(*const IFrameworkInputPaneHandler.VTable, @ptrCast(self.vtable)).Hiding(@as(*const IFrameworkInputPaneHandler, @ptrCast(self)), fEnsureFocusedElementInView);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IFrameworkInputPane_Value = Guid.initString("5752238b-24f0-495a-82f1-2fd593056796");
pub const IID_IFrameworkInputPane = &IID_IFrameworkInputPane_Value;
pub const IFrameworkInputPane = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Advise: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFrameworkInputPane,
                pWindow: ?*IUnknown,
                pHandler: ?*IFrameworkInputPaneHandler,
                pdwCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFrameworkInputPane,
                pWindow: ?*IUnknown,
                pHandler: ?*IFrameworkInputPaneHandler,
                pdwCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AdviseWithHWND: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFrameworkInputPane,
                hwnd: ?HWND,
                pHandler: ?*IFrameworkInputPaneHandler,
                pdwCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFrameworkInputPane,
                hwnd: ?HWND,
                pHandler: ?*IFrameworkInputPaneHandler,
                pdwCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Unadvise: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFrameworkInputPane,
                dwCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFrameworkInputPane,
                dwCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Location: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFrameworkInputPane,
                prcInputPaneScreenLocation: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFrameworkInputPane,
                prcInputPaneScreenLocation: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFrameworkInputPane_Advise(self: *const T, pWindow: ?*IUnknown, pHandler: ?*IFrameworkInputPaneHandler, pdwCookie: ?*u32) HRESULT {
                return @as(*const IFrameworkInputPane.VTable, @ptrCast(self.vtable)).Advise(@as(*const IFrameworkInputPane, @ptrCast(self)), pWindow, pHandler, pdwCookie);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFrameworkInputPane_AdviseWithHWND(self: *const T, hwnd: ?HWND, pHandler: ?*IFrameworkInputPaneHandler, pdwCookie: ?*u32) HRESULT {
                return @as(*const IFrameworkInputPane.VTable, @ptrCast(self.vtable)).AdviseWithHWND(@as(*const IFrameworkInputPane, @ptrCast(self)), hwnd, pHandler, pdwCookie);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFrameworkInputPane_Unadvise(self: *const T, dwCookie: u32) HRESULT {
                return @as(*const IFrameworkInputPane.VTable, @ptrCast(self.vtable)).Unadvise(@as(*const IFrameworkInputPane, @ptrCast(self)), dwCookie);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFrameworkInputPane_Location(self: *const T, prcInputPaneScreenLocation: ?*RECT) HRESULT {
                return @as(*const IFrameworkInputPane.VTable, @ptrCast(self.vtable)).Location(@as(*const IFrameworkInputPane, @ptrCast(self)), prcInputPaneScreenLocation);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MONITOR_APP_VISIBILITY = enum(i32) {
    UNKNOWN = 0,
    NO_APP_VISIBLE = 1,
    APP_VISIBLE = 2,
};
pub const MAV_UNKNOWN = MONITOR_APP_VISIBILITY.UNKNOWN;
pub const MAV_NO_APP_VISIBLE = MONITOR_APP_VISIBILITY.NO_APP_VISIBLE;
pub const MAV_APP_VISIBLE = MONITOR_APP_VISIBILITY.APP_VISIBLE;

// TODO: this type is limited to platform 'windows8.0'
const IID_IAppVisibilityEvents_Value = Guid.initString("6584ce6b-7d82-49c2-89c9-c6bc02ba8c38");
pub const IID_IAppVisibilityEvents = &IID_IAppVisibilityEvents_Value;
pub const IAppVisibilityEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AppVisibilityOnMonitorChanged: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAppVisibilityEvents,
                hMonitor: ?HMONITOR,
                previousMode: MONITOR_APP_VISIBILITY,
                currentMode: MONITOR_APP_VISIBILITY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAppVisibilityEvents,
                hMonitor: ?HMONITOR,
                previousMode: MONITOR_APP_VISIBILITY,
                currentMode: MONITOR_APP_VISIBILITY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LauncherVisibilityChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAppVisibilityEvents,
                currentVisibleState: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAppVisibilityEvents,
                currentVisibleState: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAppVisibilityEvents_AppVisibilityOnMonitorChanged(self: *const T, hMonitor: ?HMONITOR, previousMode: MONITOR_APP_VISIBILITY, currentMode: MONITOR_APP_VISIBILITY) HRESULT {
                return @as(*const IAppVisibilityEvents.VTable, @ptrCast(self.vtable)).AppVisibilityOnMonitorChanged(@as(*const IAppVisibilityEvents, @ptrCast(self)), hMonitor, previousMode, currentMode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAppVisibilityEvents_LauncherVisibilityChange(self: *const T, currentVisibleState: BOOL) HRESULT {
                return @as(*const IAppVisibilityEvents.VTable, @ptrCast(self.vtable)).LauncherVisibilityChange(@as(*const IAppVisibilityEvents, @ptrCast(self)), currentVisibleState);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IAppVisibility_Value = Guid.initString("2246ea2d-caea-4444-a3c4-6de827e44313");
pub const IID_IAppVisibility = &IID_IAppVisibility_Value;
pub const IAppVisibility = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetAppVisibilityOnMonitor: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAppVisibility,
                hMonitor: ?HMONITOR,
                pMode: ?*MONITOR_APP_VISIBILITY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAppVisibility,
                hMonitor: ?HMONITOR,
                pMode: ?*MONITOR_APP_VISIBILITY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsLauncherVisible: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAppVisibility,
                pfVisible: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAppVisibility,
                pfVisible: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Advise: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAppVisibility,
                pCallback: ?*IAppVisibilityEvents,
                pdwCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAppVisibility,
                pCallback: ?*IAppVisibilityEvents,
                pdwCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Unadvise: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAppVisibility,
                dwCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAppVisibility,
                dwCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAppVisibility_GetAppVisibilityOnMonitor(self: *const T, hMonitor: ?HMONITOR, pMode: ?*MONITOR_APP_VISIBILITY) HRESULT {
                return @as(*const IAppVisibility.VTable, @ptrCast(self.vtable)).GetAppVisibilityOnMonitor(@as(*const IAppVisibility, @ptrCast(self)), hMonitor, pMode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAppVisibility_IsLauncherVisible(self: *const T, pfVisible: ?*BOOL) HRESULT {
                return @as(*const IAppVisibility.VTable, @ptrCast(self.vtable)).IsLauncherVisible(@as(*const IAppVisibility, @ptrCast(self)), pfVisible);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAppVisibility_Advise(self: *const T, pCallback: ?*IAppVisibilityEvents, pdwCookie: ?*u32) HRESULT {
                return @as(*const IAppVisibility.VTable, @ptrCast(self.vtable)).Advise(@as(*const IAppVisibility, @ptrCast(self)), pCallback, pdwCookie);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAppVisibility_Unadvise(self: *const T, dwCookie: u32) HRESULT {
                return @as(*const IAppVisibility.VTable, @ptrCast(self.vtable)).Unadvise(@as(*const IAppVisibility, @ptrCast(self)), dwCookie);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const PACKAGE_EXECUTION_STATE = enum(i32) {
    UNKNOWN = 0,
    RUNNING = 1,
    SUSPENDING = 2,
    SUSPENDED = 3,
    TERMINATED = 4,
};
pub const PES_UNKNOWN = PACKAGE_EXECUTION_STATE.UNKNOWN;
pub const PES_RUNNING = PACKAGE_EXECUTION_STATE.RUNNING;
pub const PES_SUSPENDING = PACKAGE_EXECUTION_STATE.SUSPENDING;
pub const PES_SUSPENDED = PACKAGE_EXECUTION_STATE.SUSPENDED;
pub const PES_TERMINATED = PACKAGE_EXECUTION_STATE.TERMINATED;

// TODO: this type is limited to platform 'windows8.0'
const IID_IPackageExecutionStateChangeNotification_Value = Guid.initString("1bb12a62-2ad8-432b-8ccf-0c2c52afcd5b");
pub const IID_IPackageExecutionStateChangeNotification = &IID_IPackageExecutionStateChangeNotification_Value;
pub const IPackageExecutionStateChangeNotification = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnStateChanged: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPackageExecutionStateChangeNotification,
                pszPackageFullName: ?[*:0]const u16,
                pesNewState: PACKAGE_EXECUTION_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPackageExecutionStateChangeNotification,
                pszPackageFullName: ?[*:0]const u16,
                pesNewState: PACKAGE_EXECUTION_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPackageExecutionStateChangeNotification_OnStateChanged(self: *const T, pszPackageFullName: ?[*:0]const u16, pesNewState: PACKAGE_EXECUTION_STATE) HRESULT {
                return @as(*const IPackageExecutionStateChangeNotification.VTable, @ptrCast(self.vtable)).OnStateChanged(@as(*const IPackageExecutionStateChangeNotification, @ptrCast(self)), pszPackageFullName, pesNewState);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IPackageDebugSettings_Value = Guid.initString("f27c3930-8029-4ad1-94e3-3dba417810c1");
pub const IID_IPackageDebugSettings = &IID_IPackageDebugSettings_Value;
pub const IPackageDebugSettings = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EnableDebugging: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPackageDebugSettings,
                packageFullName: ?[*:0]const u16,
                debuggerCommandLine: ?[*:0]const u16,
                environment: ?[*]u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPackageDebugSettings,
                packageFullName: ?[*:0]const u16,
                debuggerCommandLine: ?[*:0]const u16,
                environment: ?[*]u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DisableDebugging: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPackageDebugSettings,
                packageFullName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPackageDebugSettings,
                packageFullName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Suspend: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPackageDebugSettings,
                packageFullName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPackageDebugSettings,
                packageFullName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Resume: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPackageDebugSettings,
                packageFullName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPackageDebugSettings,
                packageFullName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TerminateAllProcesses: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPackageDebugSettings,
                packageFullName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPackageDebugSettings,
                packageFullName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTargetSessionId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPackageDebugSettings,
                sessionId: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPackageDebugSettings,
                sessionId: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumerateBackgroundTasks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPackageDebugSettings,
                packageFullName: ?[*:0]const u16,
                taskCount: ?*u32,
                taskIds: ?*?*Guid,
                taskNames: ?*?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPackageDebugSettings,
                packageFullName: ?[*:0]const u16,
                taskCount: ?*u32,
                taskIds: ?*?*Guid,
                taskNames: ?*?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ActivateBackgroundTask: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPackageDebugSettings,
                taskId: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPackageDebugSettings,
                taskId: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartServicing: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPackageDebugSettings,
                packageFullName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPackageDebugSettings,
                packageFullName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StopServicing: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPackageDebugSettings,
                packageFullName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPackageDebugSettings,
                packageFullName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartSessionRedirection: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPackageDebugSettings,
                packageFullName: ?[*:0]const u16,
                sessionId: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPackageDebugSettings,
                packageFullName: ?[*:0]const u16,
                sessionId: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StopSessionRedirection: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPackageDebugSettings,
                packageFullName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPackageDebugSettings,
                packageFullName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPackageExecutionState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPackageDebugSettings,
                packageFullName: ?[*:0]const u16,
                packageExecutionState: ?*PACKAGE_EXECUTION_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPackageDebugSettings,
                packageFullName: ?[*:0]const u16,
                packageExecutionState: ?*PACKAGE_EXECUTION_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RegisterForPackageStateChanges: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPackageDebugSettings,
                packageFullName: ?[*:0]const u16,
                pPackageExecutionStateChangeNotification: ?*IPackageExecutionStateChangeNotification,
                pdwCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPackageDebugSettings,
                packageFullName: ?[*:0]const u16,
                pPackageExecutionStateChangeNotification: ?*IPackageExecutionStateChangeNotification,
                pdwCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnregisterForPackageStateChanges: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPackageDebugSettings,
                dwCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPackageDebugSettings,
                dwCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPackageDebugSettings_EnableDebugging(self: *const T, packageFullName: ?[*:0]const u16, debuggerCommandLine: ?[*:0]const u16, environment: ?[*]u16) HRESULT {
                return @as(*const IPackageDebugSettings.VTable, @ptrCast(self.vtable)).EnableDebugging(@as(*const IPackageDebugSettings, @ptrCast(self)), packageFullName, debuggerCommandLine, environment);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPackageDebugSettings_DisableDebugging(self: *const T, packageFullName: ?[*:0]const u16) HRESULT {
                return @as(*const IPackageDebugSettings.VTable, @ptrCast(self.vtable)).DisableDebugging(@as(*const IPackageDebugSettings, @ptrCast(self)), packageFullName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPackageDebugSettings_Suspend(self: *const T, packageFullName: ?[*:0]const u16) HRESULT {
                return @as(*const IPackageDebugSettings.VTable, @ptrCast(self.vtable)).Suspend(@as(*const IPackageDebugSettings, @ptrCast(self)), packageFullName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPackageDebugSettings_Resume(self: *const T, packageFullName: ?[*:0]const u16) HRESULT {
                return @as(*const IPackageDebugSettings.VTable, @ptrCast(self.vtable)).Resume(@as(*const IPackageDebugSettings, @ptrCast(self)), packageFullName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPackageDebugSettings_TerminateAllProcesses(self: *const T, packageFullName: ?[*:0]const u16) HRESULT {
                return @as(*const IPackageDebugSettings.VTable, @ptrCast(self.vtable)).TerminateAllProcesses(@as(*const IPackageDebugSettings, @ptrCast(self)), packageFullName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPackageDebugSettings_SetTargetSessionId(self: *const T, sessionId: u32) HRESULT {
                return @as(*const IPackageDebugSettings.VTable, @ptrCast(self.vtable)).SetTargetSessionId(@as(*const IPackageDebugSettings, @ptrCast(self)), sessionId);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPackageDebugSettings_EnumerateBackgroundTasks(self: *const T, packageFullName: ?[*:0]const u16, taskCount: ?*u32, taskIds: ?*?*Guid, taskNames: ?*?*?PWSTR) HRESULT {
                return @as(*const IPackageDebugSettings.VTable, @ptrCast(self.vtable)).EnumerateBackgroundTasks(@as(*const IPackageDebugSettings, @ptrCast(self)), packageFullName, taskCount, taskIds, taskNames);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPackageDebugSettings_ActivateBackgroundTask(self: *const T, taskId: ?*const Guid) HRESULT {
                return @as(*const IPackageDebugSettings.VTable, @ptrCast(self.vtable)).ActivateBackgroundTask(@as(*const IPackageDebugSettings, @ptrCast(self)), taskId);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPackageDebugSettings_StartServicing(self: *const T, packageFullName: ?[*:0]const u16) HRESULT {
                return @as(*const IPackageDebugSettings.VTable, @ptrCast(self.vtable)).StartServicing(@as(*const IPackageDebugSettings, @ptrCast(self)), packageFullName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPackageDebugSettings_StopServicing(self: *const T, packageFullName: ?[*:0]const u16) HRESULT {
                return @as(*const IPackageDebugSettings.VTable, @ptrCast(self.vtable)).StopServicing(@as(*const IPackageDebugSettings, @ptrCast(self)), packageFullName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPackageDebugSettings_StartSessionRedirection(self: *const T, packageFullName: ?[*:0]const u16, sessionId: u32) HRESULT {
                return @as(*const IPackageDebugSettings.VTable, @ptrCast(self.vtable)).StartSessionRedirection(@as(*const IPackageDebugSettings, @ptrCast(self)), packageFullName, sessionId);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPackageDebugSettings_StopSessionRedirection(self: *const T, packageFullName: ?[*:0]const u16) HRESULT {
                return @as(*const IPackageDebugSettings.VTable, @ptrCast(self.vtable)).StopSessionRedirection(@as(*const IPackageDebugSettings, @ptrCast(self)), packageFullName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPackageDebugSettings_GetPackageExecutionState(self: *const T, packageFullName: ?[*:0]const u16, packageExecutionState: ?*PACKAGE_EXECUTION_STATE) HRESULT {
                return @as(*const IPackageDebugSettings.VTable, @ptrCast(self.vtable)).GetPackageExecutionState(@as(*const IPackageDebugSettings, @ptrCast(self)), packageFullName, packageExecutionState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPackageDebugSettings_RegisterForPackageStateChanges(self: *const T, packageFullName: ?[*:0]const u16, pPackageExecutionStateChangeNotification: ?*IPackageExecutionStateChangeNotification, pdwCookie: ?*u32) HRESULT {
                return @as(*const IPackageDebugSettings.VTable, @ptrCast(self.vtable)).RegisterForPackageStateChanges(@as(*const IPackageDebugSettings, @ptrCast(self)), packageFullName, pPackageExecutionStateChangeNotification, pdwCookie);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPackageDebugSettings_UnregisterForPackageStateChanges(self: *const T, dwCookie: u32) HRESULT {
                return @as(*const IPackageDebugSettings.VTable, @ptrCast(self.vtable)).UnregisterForPackageStateChanges(@as(*const IPackageDebugSettings, @ptrCast(self)), dwCookie);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IPackageDebugSettings2_Value = Guid.initString("6e3194bb-ab82-4d22-93f5-fabda40e7b16");
pub const IID_IPackageDebugSettings2 = &IID_IPackageDebugSettings2_Value;
pub const IPackageDebugSettings2 = extern struct {
    pub const VTable = extern struct {
        base: IPackageDebugSettings.VTable,
        EnumerateApps: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPackageDebugSettings2,
                packageFullName: ?[*:0]const u16,
                appCount: ?*u32,
                appUserModelIds: ?*?*?PWSTR,
                appDisplayNames: ?*?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPackageDebugSettings2,
                packageFullName: ?[*:0]const u16,
                appCount: ?*u32,
                appUserModelIds: ?*?*?PWSTR,
                appDisplayNames: ?*?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IPackageDebugSettings.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPackageDebugSettings2_EnumerateApps(self: *const T, packageFullName: ?[*:0]const u16, appCount: ?*u32, appUserModelIds: ?*?*?PWSTR, appDisplayNames: ?*?*?PWSTR) HRESULT {
                return @as(*const IPackageDebugSettings2.VTable, @ptrCast(self.vtable)).EnumerateApps(@as(*const IPackageDebugSettings2, @ptrCast(self)), packageFullName, appCount, appUserModelIds, appDisplayNames);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.1'
const IID_ISuspensionDependencyManager_Value = Guid.initString("52b83a42-2543-416a-81d9-c0de7969c8b3");
pub const IID_ISuspensionDependencyManager = &IID_ISuspensionDependencyManager_Value;
pub const ISuspensionDependencyManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RegisterAsChild: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISuspensionDependencyManager,
                processHandle: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISuspensionDependencyManager,
                processHandle: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GroupChildWithParent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISuspensionDependencyManager,
                childProcessHandle: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISuspensionDependencyManager,
                childProcessHandle: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UngroupChildFromParent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISuspensionDependencyManager,
                childProcessHandle: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISuspensionDependencyManager,
                childProcessHandle: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISuspensionDependencyManager_RegisterAsChild(self: *const T, processHandle: ?HANDLE) HRESULT {
                return @as(*const ISuspensionDependencyManager.VTable, @ptrCast(self.vtable)).RegisterAsChild(@as(*const ISuspensionDependencyManager, @ptrCast(self)), processHandle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISuspensionDependencyManager_GroupChildWithParent(self: *const T, childProcessHandle: ?HANDLE) HRESULT {
                return @as(*const ISuspensionDependencyManager.VTable, @ptrCast(self.vtable)).GroupChildWithParent(@as(*const ISuspensionDependencyManager, @ptrCast(self)), childProcessHandle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISuspensionDependencyManager_UngroupChildFromParent(self: *const T, childProcessHandle: ?HANDLE) HRESULT {
                return @as(*const ISuspensionDependencyManager.VTable, @ptrCast(self.vtable)).UngroupChildFromParent(@as(*const ISuspensionDependencyManager, @ptrCast(self)), childProcessHandle);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const AHE_TYPE = enum(i32) {
    DESKTOP = 0,
    IMMERSIVE = 1,
};
pub const AHE_DESKTOP = AHE_TYPE.DESKTOP;
pub const AHE_IMMERSIVE = AHE_TYPE.IMMERSIVE;

// TODO: this type is limited to platform 'windows8.0'
const IID_IExecuteCommandApplicationHostEnvironment_Value = Guid.initString("18b21aa9-e184-4ff0-9f5e-f882d03771b3");
pub const IID_IExecuteCommandApplicationHostEnvironment = &IID_IExecuteCommandApplicationHostEnvironment_Value;
pub const IExecuteCommandApplicationHostEnvironment = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IExecuteCommandApplicationHostEnvironment,
                pahe: ?*AHE_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IExecuteCommandApplicationHostEnvironment,
                pahe: ?*AHE_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IExecuteCommandApplicationHostEnvironment_GetValue(self: *const T, pahe: ?*AHE_TYPE) HRESULT {
                return @as(*const IExecuteCommandApplicationHostEnvironment.VTable, @ptrCast(self.vtable)).GetValue(@as(*const IExecuteCommandApplicationHostEnvironment, @ptrCast(self)), pahe);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const EC_HOST_UI_MODE = enum(i32) {
    DESKTOP = 0,
    IMMERSIVE = 1,
    SYSTEM_LAUNCHER = 2,
};
pub const ECHUIM_DESKTOP = EC_HOST_UI_MODE.DESKTOP;
pub const ECHUIM_IMMERSIVE = EC_HOST_UI_MODE.IMMERSIVE;
pub const ECHUIM_SYSTEM_LAUNCHER = EC_HOST_UI_MODE.SYSTEM_LAUNCHER;

// TODO: this type is limited to platform 'windows8.0'
const IID_IExecuteCommandHost_Value = Guid.initString("4b6832a2-5f04-4c9d-b89d-727a15d103e7");
pub const IID_IExecuteCommandHost = &IID_IExecuteCommandHost_Value;
pub const IExecuteCommandHost = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetUIMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IExecuteCommandHost,
                pUIMode: ?*EC_HOST_UI_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IExecuteCommandHost,
                pUIMode: ?*EC_HOST_UI_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IExecuteCommandHost_GetUIMode(self: *const T, pUIMode: ?*EC_HOST_UI_MODE) HRESULT {
                return @as(*const IExecuteCommandHost.VTable, @ptrCast(self.vtable)).GetUIMode(@as(*const IExecuteCommandHost, @ptrCast(self)), pUIMode);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const APPLICATION_VIEW_STATE = enum(i32) {
    FULLSCREEN_LANDSCAPE = 0,
    FILLED = 1,
    SNAPPED = 2,
    FULLSCREEN_PORTRAIT = 3,
};
pub const AVS_FULLSCREEN_LANDSCAPE = APPLICATION_VIEW_STATE.FULLSCREEN_LANDSCAPE;
pub const AVS_FILLED = APPLICATION_VIEW_STATE.FILLED;
pub const AVS_SNAPPED = APPLICATION_VIEW_STATE.SNAPPED;
pub const AVS_FULLSCREEN_PORTRAIT = APPLICATION_VIEW_STATE.FULLSCREEN_PORTRAIT;

pub const EDGE_GESTURE_KIND = enum(i32) {
    TOUCH = 0,
    KEYBOARD = 1,
    MOUSE = 2,
};
pub const EGK_TOUCH = EDGE_GESTURE_KIND.TOUCH;
pub const EGK_KEYBOARD = EDGE_GESTURE_KIND.KEYBOARD;
pub const EGK_MOUSE = EDGE_GESTURE_KIND.MOUSE;

// TODO: this type is limited to platform 'windows8.0'
const IID_IApplicationDesignModeSettings_Value = Guid.initString("2a3dee9a-e31d-46d6-8508-bcc597db3557");
pub const IID_IApplicationDesignModeSettings = &IID_IApplicationDesignModeSettings_Value;
pub const IApplicationDesignModeSettings = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetNativeDisplaySize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IApplicationDesignModeSettings,
                nativeDisplaySizePixels: SIZE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IApplicationDesignModeSettings,
                nativeDisplaySizePixels: SIZE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetScaleFactor: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IApplicationDesignModeSettings,
                scaleFactor: DEVICE_SCALE_FACTOR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IApplicationDesignModeSettings,
                scaleFactor: DEVICE_SCALE_FACTOR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetApplicationViewState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IApplicationDesignModeSettings,
                viewState: APPLICATION_VIEW_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IApplicationDesignModeSettings,
                viewState: APPLICATION_VIEW_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ComputeApplicationSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IApplicationDesignModeSettings,
                applicationSizePixels: ?*SIZE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IApplicationDesignModeSettings,
                applicationSizePixels: ?*SIZE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsApplicationViewStateSupported: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IApplicationDesignModeSettings,
                viewState: APPLICATION_VIEW_STATE,
                nativeDisplaySizePixels: SIZE,
                scaleFactor: DEVICE_SCALE_FACTOR,
                supported: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IApplicationDesignModeSettings,
                viewState: APPLICATION_VIEW_STATE,
                nativeDisplaySizePixels: SIZE,
                scaleFactor: DEVICE_SCALE_FACTOR,
                supported: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TriggerEdgeGesture: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IApplicationDesignModeSettings,
                edgeGestureKind: EDGE_GESTURE_KIND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IApplicationDesignModeSettings,
                edgeGestureKind: EDGE_GESTURE_KIND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IApplicationDesignModeSettings_SetNativeDisplaySize(self: *const T, nativeDisplaySizePixels: SIZE) HRESULT {
                return @as(*const IApplicationDesignModeSettings.VTable, @ptrCast(self.vtable)).SetNativeDisplaySize(@as(*const IApplicationDesignModeSettings, @ptrCast(self)), nativeDisplaySizePixels);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IApplicationDesignModeSettings_SetScaleFactor(self: *const T, scaleFactor: DEVICE_SCALE_FACTOR) HRESULT {
                return @as(*const IApplicationDesignModeSettings.VTable, @ptrCast(self.vtable)).SetScaleFactor(@as(*const IApplicationDesignModeSettings, @ptrCast(self)), scaleFactor);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IApplicationDesignModeSettings_SetApplicationViewState(self: *const T, viewState: APPLICATION_VIEW_STATE) HRESULT {
                return @as(*const IApplicationDesignModeSettings.VTable, @ptrCast(self.vtable)).SetApplicationViewState(@as(*const IApplicationDesignModeSettings, @ptrCast(self)), viewState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IApplicationDesignModeSettings_ComputeApplicationSize(self: *const T, applicationSizePixels: ?*SIZE) HRESULT {
                return @as(*const IApplicationDesignModeSettings.VTable, @ptrCast(self.vtable)).ComputeApplicationSize(@as(*const IApplicationDesignModeSettings, @ptrCast(self)), applicationSizePixels);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IApplicationDesignModeSettings_IsApplicationViewStateSupported(self: *const T, viewState: APPLICATION_VIEW_STATE, nativeDisplaySizePixels: SIZE, scaleFactor: DEVICE_SCALE_FACTOR, supported: ?*BOOL) HRESULT {
                return @as(*const IApplicationDesignModeSettings.VTable, @ptrCast(self.vtable)).IsApplicationViewStateSupported(@as(*const IApplicationDesignModeSettings, @ptrCast(self)), viewState, nativeDisplaySizePixels, scaleFactor, supported);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IApplicationDesignModeSettings_TriggerEdgeGesture(self: *const T, edgeGestureKind: EDGE_GESTURE_KIND) HRESULT {
                return @as(*const IApplicationDesignModeSettings.VTable, @ptrCast(self.vtable)).TriggerEdgeGesture(@as(*const IApplicationDesignModeSettings, @ptrCast(self)), edgeGestureKind);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const NATIVE_DISPLAY_ORIENTATION = enum(i32) {
    LANDSCAPE = 0,
    PORTRAIT = 1,
};
pub const NDO_LANDSCAPE = NATIVE_DISPLAY_ORIENTATION.LANDSCAPE;
pub const NDO_PORTRAIT = NATIVE_DISPLAY_ORIENTATION.PORTRAIT;

pub const APPLICATION_VIEW_ORIENTATION = enum(i32) {
    LANDSCAPE = 0,
    PORTRAIT = 1,
};
pub const AVO_LANDSCAPE = APPLICATION_VIEW_ORIENTATION.LANDSCAPE;
pub const AVO_PORTRAIT = APPLICATION_VIEW_ORIENTATION.PORTRAIT;

pub const ADJACENT_DISPLAY_EDGES = enum(i32) {
    NONE = 0,
    LEFT = 1,
    RIGHT = 2,
};
pub const ADE_NONE = ADJACENT_DISPLAY_EDGES.NONE;
pub const ADE_LEFT = ADJACENT_DISPLAY_EDGES.LEFT;
pub const ADE_RIGHT = ADJACENT_DISPLAY_EDGES.RIGHT;

pub const APPLICATION_VIEW_MIN_WIDTH = enum(i32) {
    DEFAULT = 0,
    @"320" = 1,
    @"500" = 2,
};
pub const AVMW_DEFAULT = APPLICATION_VIEW_MIN_WIDTH.DEFAULT;
pub const AVMW_320 = APPLICATION_VIEW_MIN_WIDTH.@"320";
pub const AVMW_500 = APPLICATION_VIEW_MIN_WIDTH.@"500";

// TODO: this type is limited to platform 'windows8.1'
const IID_IApplicationDesignModeSettings2_Value = Guid.initString("490514e1-675a-4d6e-a58d-e54901b4ca2f");
pub const IID_IApplicationDesignModeSettings2 = &IID_IApplicationDesignModeSettings2_Value;
pub const IApplicationDesignModeSettings2 = extern struct {
    pub const VTable = extern struct {
        base: IApplicationDesignModeSettings.VTable,
        SetNativeDisplayOrientation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IApplicationDesignModeSettings2,
                nativeDisplayOrientation: NATIVE_DISPLAY_ORIENTATION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IApplicationDesignModeSettings2,
                nativeDisplayOrientation: NATIVE_DISPLAY_ORIENTATION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetApplicationViewOrientation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IApplicationDesignModeSettings2,
                viewOrientation: APPLICATION_VIEW_ORIENTATION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IApplicationDesignModeSettings2,
                viewOrientation: APPLICATION_VIEW_ORIENTATION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetAdjacentDisplayEdges: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IApplicationDesignModeSettings2,
                adjacentDisplayEdges: ADJACENT_DISPLAY_EDGES,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IApplicationDesignModeSettings2,
                adjacentDisplayEdges: ADJACENT_DISPLAY_EDGES,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetIsOnLockScreen: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IApplicationDesignModeSettings2,
                isOnLockScreen: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IApplicationDesignModeSettings2,
                isOnLockScreen: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetApplicationViewMinWidth: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IApplicationDesignModeSettings2,
                viewMinWidth: APPLICATION_VIEW_MIN_WIDTH,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IApplicationDesignModeSettings2,
                viewMinWidth: APPLICATION_VIEW_MIN_WIDTH,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetApplicationSizeBounds: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IApplicationDesignModeSettings2,
                minApplicationSizePixels: ?*SIZE,
                maxApplicationSizePixels: ?*SIZE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IApplicationDesignModeSettings2,
                minApplicationSizePixels: ?*SIZE,
                maxApplicationSizePixels: ?*SIZE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetApplicationViewOrientation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IApplicationDesignModeSettings2,
                applicationSizePixels: SIZE,
                viewOrientation: ?*APPLICATION_VIEW_ORIENTATION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IApplicationDesignModeSettings2,
                applicationSizePixels: SIZE,
                viewOrientation: ?*APPLICATION_VIEW_ORIENTATION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IApplicationDesignModeSettings.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IApplicationDesignModeSettings2_SetNativeDisplayOrientation(self: *const T, nativeDisplayOrientation: NATIVE_DISPLAY_ORIENTATION) HRESULT {
                return @as(*const IApplicationDesignModeSettings2.VTable, @ptrCast(self.vtable)).SetNativeDisplayOrientation(@as(*const IApplicationDesignModeSettings2, @ptrCast(self)), nativeDisplayOrientation);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IApplicationDesignModeSettings2_SetApplicationViewOrientation(self: *const T, viewOrientation: APPLICATION_VIEW_ORIENTATION) HRESULT {
                return @as(*const IApplicationDesignModeSettings2.VTable, @ptrCast(self.vtable)).SetApplicationViewOrientation(@as(*const IApplicationDesignModeSettings2, @ptrCast(self)), viewOrientation);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IApplicationDesignModeSettings2_SetAdjacentDisplayEdges(self: *const T, adjacentDisplayEdges: ADJACENT_DISPLAY_EDGES) HRESULT {
                return @as(*const IApplicationDesignModeSettings2.VTable, @ptrCast(self.vtable)).SetAdjacentDisplayEdges(@as(*const IApplicationDesignModeSettings2, @ptrCast(self)), adjacentDisplayEdges);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IApplicationDesignModeSettings2_SetIsOnLockScreen(self: *const T, isOnLockScreen: BOOL) HRESULT {
                return @as(*const IApplicationDesignModeSettings2.VTable, @ptrCast(self.vtable)).SetIsOnLockScreen(@as(*const IApplicationDesignModeSettings2, @ptrCast(self)), isOnLockScreen);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IApplicationDesignModeSettings2_SetApplicationViewMinWidth(self: *const T, viewMinWidth: APPLICATION_VIEW_MIN_WIDTH) HRESULT {
                return @as(*const IApplicationDesignModeSettings2.VTable, @ptrCast(self.vtable)).SetApplicationViewMinWidth(@as(*const IApplicationDesignModeSettings2, @ptrCast(self)), viewMinWidth);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IApplicationDesignModeSettings2_GetApplicationSizeBounds(self: *const T, minApplicationSizePixels: ?*SIZE, maxApplicationSizePixels: ?*SIZE) HRESULT {
                return @as(*const IApplicationDesignModeSettings2.VTable, @ptrCast(self.vtable)).GetApplicationSizeBounds(@as(*const IApplicationDesignModeSettings2, @ptrCast(self)), minApplicationSizePixels, maxApplicationSizePixels);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IApplicationDesignModeSettings2_GetApplicationViewOrientation(self: *const T, applicationSizePixels: SIZE, viewOrientation: ?*APPLICATION_VIEW_ORIENTATION) HRESULT {
                return @as(*const IApplicationDesignModeSettings2.VTable, @ptrCast(self.vtable)).GetApplicationViewOrientation(@as(*const IApplicationDesignModeSettings2, @ptrCast(self)), applicationSizePixels, viewOrientation);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.1'
const IID_ILaunchTargetMonitor_Value = Guid.initString("266fbc7e-490d-46ed-a96b-2274db252003");
pub const IID_ILaunchTargetMonitor = &IID_ILaunchTargetMonitor_Value;
pub const ILaunchTargetMonitor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetMonitor: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ILaunchTargetMonitor,
                monitor: ?*?HMONITOR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ILaunchTargetMonitor,
                monitor: ?*?HMONITOR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ILaunchTargetMonitor_GetMonitor(self: *const T, monitor: ?*?HMONITOR) HRESULT {
                return @as(*const ILaunchTargetMonitor.VTable, @ptrCast(self.vtable)).GetMonitor(@as(*const ILaunchTargetMonitor, @ptrCast(self)), monitor);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const APPLICATION_VIEW_SIZE_PREFERENCE = enum(i32) {
    DEFAULT = 0,
    USE_LESS = 1,
    USE_HALF = 2,
    USE_MORE = 3,
    USE_MINIMUM = 4,
    USE_NONE = 5,
    CUSTOM = 6,
};
pub const AVSP_DEFAULT = APPLICATION_VIEW_SIZE_PREFERENCE.DEFAULT;
pub const AVSP_USE_LESS = APPLICATION_VIEW_SIZE_PREFERENCE.USE_LESS;
pub const AVSP_USE_HALF = APPLICATION_VIEW_SIZE_PREFERENCE.USE_HALF;
pub const AVSP_USE_MORE = APPLICATION_VIEW_SIZE_PREFERENCE.USE_MORE;
pub const AVSP_USE_MINIMUM = APPLICATION_VIEW_SIZE_PREFERENCE.USE_MINIMUM;
pub const AVSP_USE_NONE = APPLICATION_VIEW_SIZE_PREFERENCE.USE_NONE;
pub const AVSP_CUSTOM = APPLICATION_VIEW_SIZE_PREFERENCE.CUSTOM;

// TODO: this type is limited to platform 'windows8.1'
const IID_ILaunchSourceViewSizePreference_Value = Guid.initString("e5aa01f7-1fb8-4830-8720-4e6734cbd5f3");
pub const IID_ILaunchSourceViewSizePreference = &IID_ILaunchSourceViewSizePreference_Value;
pub const ILaunchSourceViewSizePreference = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSourceViewToPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ILaunchSourceViewSizePreference,
                hwnd: ?*?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ILaunchSourceViewSizePreference,
                hwnd: ?*?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceViewSizePreference: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ILaunchSourceViewSizePreference,
                sourceSizeAfterLaunch: ?*APPLICATION_VIEW_SIZE_PREFERENCE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ILaunchSourceViewSizePreference,
                sourceSizeAfterLaunch: ?*APPLICATION_VIEW_SIZE_PREFERENCE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ILaunchSourceViewSizePreference_GetSourceViewToPosition(self: *const T, hwnd: ?*?HWND) HRESULT {
                return @as(*const ILaunchSourceViewSizePreference.VTable, @ptrCast(self.vtable)).GetSourceViewToPosition(@as(*const ILaunchSourceViewSizePreference, @ptrCast(self)), hwnd);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ILaunchSourceViewSizePreference_GetSourceViewSizePreference(self: *const T, sourceSizeAfterLaunch: ?*APPLICATION_VIEW_SIZE_PREFERENCE) HRESULT {
                return @as(*const ILaunchSourceViewSizePreference.VTable, @ptrCast(self.vtable)).GetSourceViewSizePreference(@as(*const ILaunchSourceViewSizePreference, @ptrCast(self)), sourceSizeAfterLaunch);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.1'
const IID_ILaunchTargetViewSizePreference_Value = Guid.initString("2f0666c6-12f7-4360-b511-a394a0553725");
pub const IID_ILaunchTargetViewSizePreference = &IID_ILaunchTargetViewSizePreference_Value;
pub const ILaunchTargetViewSizePreference = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTargetViewSizePreference: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ILaunchTargetViewSizePreference,
                targetSizeOnLaunch: ?*APPLICATION_VIEW_SIZE_PREFERENCE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ILaunchTargetViewSizePreference,
                targetSizeOnLaunch: ?*APPLICATION_VIEW_SIZE_PREFERENCE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ILaunchTargetViewSizePreference_GetTargetViewSizePreference(self: *const T, targetSizeOnLaunch: ?*APPLICATION_VIEW_SIZE_PREFERENCE) HRESULT {
                return @as(*const ILaunchTargetViewSizePreference.VTable, @ptrCast(self.vtable)).GetTargetViewSizePreference(@as(*const ILaunchTargetViewSizePreference, @ptrCast(self)), targetSizeOnLaunch);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.1'
const IID_ILaunchSourceAppUserModelId_Value = Guid.initString("989191ac-28ff-4cf0-9584-e0d078bc2396");
pub const IID_ILaunchSourceAppUserModelId = &IID_ILaunchSourceAppUserModelId_Value;
pub const ILaunchSourceAppUserModelId = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetAppUserModelId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ILaunchSourceAppUserModelId,
                launchingApp: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ILaunchSourceAppUserModelId,
                launchingApp: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ILaunchSourceAppUserModelId_GetAppUserModelId(self: *const T, launchingApp: ?*?PWSTR) HRESULT {
                return @as(*const ILaunchSourceAppUserModelId.VTable, @ptrCast(self.vtable)).GetAppUserModelId(@as(*const ILaunchSourceAppUserModelId, @ptrCast(self)), launchingApp);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IInitializeWithWindow_Value = Guid.initString("3e68d4bd-7135-4d10-8018-9fb6d9f33fa1");
pub const IID_IInitializeWithWindow = &IID_IInitializeWithWindow_Value;
pub const IInitializeWithWindow = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInitializeWithWindow,
                hwnd: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInitializeWithWindow,
                hwnd: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInitializeWithWindow_Initialize(self: *const T, hwnd: ?HWND) HRESULT {
                return @as(*const IInitializeWithWindow.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IInitializeWithWindow, @ptrCast(self)), hwnd);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IHandlerInfo_Value = Guid.initString("997706ef-f880-453b-8118-39e1a2d2655a");
pub const IID_IHandlerInfo = &IID_IHandlerInfo_Value;
pub const IHandlerInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetApplicationDisplayName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IHandlerInfo,
                value: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IHandlerInfo,
                value: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetApplicationPublisher: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IHandlerInfo,
                value: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IHandlerInfo,
                value: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetApplicationIconReference: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IHandlerInfo,
                value: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IHandlerInfo,
                value: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IHandlerInfo_GetApplicationDisplayName(self: *const T, value: ?*?PWSTR) HRESULT {
                return @as(*const IHandlerInfo.VTable, @ptrCast(self.vtable)).GetApplicationDisplayName(@as(*const IHandlerInfo, @ptrCast(self)), value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IHandlerInfo_GetApplicationPublisher(self: *const T, value: ?*?PWSTR) HRESULT {
                return @as(*const IHandlerInfo.VTable, @ptrCast(self.vtable)).GetApplicationPublisher(@as(*const IHandlerInfo, @ptrCast(self)), value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IHandlerInfo_GetApplicationIconReference(self: *const T, value: ?*?PWSTR) HRESULT {
                return @as(*const IHandlerInfo.VTable, @ptrCast(self.vtable)).GetApplicationIconReference(@as(*const IHandlerInfo, @ptrCast(self)), value);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IHandlerInfo2_Value = Guid.initString("31cca04c-04d3-4ea9-90de-97b15e87a532");
pub const IID_IHandlerInfo2 = &IID_IHandlerInfo2_Value;
pub const IHandlerInfo2 = extern struct {
    pub const VTable = extern struct {
        base: IHandlerInfo.VTable,
        GetApplicationId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IHandlerInfo2,
                value: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IHandlerInfo2,
                value: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IHandlerInfo.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IHandlerInfo2_GetApplicationId(self: *const T, value: ?*?PWSTR) HRESULT {
                return @as(*const IHandlerInfo2.VTable, @ptrCast(self.vtable)).GetApplicationId(@as(*const IHandlerInfo2, @ptrCast(self)), value);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IHandlerActivationHost_Value = Guid.initString("35094a87-8bb1-4237-96c6-c417eebdb078");
pub const IID_IHandlerActivationHost = &IID_IHandlerActivationHost_Value;
pub const IHandlerActivationHost = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        BeforeCoCreateInstance: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IHandlerActivationHost,
                clsidHandler: ?*const Guid,
                itemsBeingActivated: ?*IShellItemArray,
                handlerInfo: ?*IHandlerInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IHandlerActivationHost,
                clsidHandler: ?*const Guid,
                itemsBeingActivated: ?*IShellItemArray,
                handlerInfo: ?*IHandlerInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BeforeCreateProcess: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IHandlerActivationHost,
                applicationPath: ?[*:0]const u16,
                commandLine: ?[*:0]const u16,
                handlerInfo: ?*IHandlerInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IHandlerActivationHost,
                applicationPath: ?[*:0]const u16,
                commandLine: ?[*:0]const u16,
                handlerInfo: ?*IHandlerInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IHandlerActivationHost_BeforeCoCreateInstance(self: *const T, clsidHandler: ?*const Guid, itemsBeingActivated: ?*IShellItemArray, handlerInfo: ?*IHandlerInfo) HRESULT {
                return @as(*const IHandlerActivationHost.VTable, @ptrCast(self.vtable)).BeforeCoCreateInstance(@as(*const IHandlerActivationHost, @ptrCast(self)), clsidHandler, itemsBeingActivated, handlerInfo);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IHandlerActivationHost_BeforeCreateProcess(self: *const T, applicationPath: ?[*:0]const u16, commandLine: ?[*:0]const u16, handlerInfo: ?*IHandlerInfo) HRESULT {
                return @as(*const IHandlerActivationHost.VTable, @ptrCast(self.vtable)).BeforeCreateProcess(@as(*const IHandlerActivationHost, @ptrCast(self)), applicationPath, commandLine, handlerInfo);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IAppActivationUIInfo_Value = Guid.initString("abad189d-9fa3-4278-b3ca-8ca448a88dcb");
pub const IID_IAppActivationUIInfo = &IID_IAppActivationUIInfo_Value;
pub const IAppActivationUIInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetMonitor: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAppActivationUIInfo,
                value: ?*?HMONITOR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAppActivationUIInfo,
                value: ?*?HMONITOR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInvokePoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAppActivationUIInfo,
                value: ?*POINT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAppActivationUIInfo,
                value: ?*POINT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetShowCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAppActivationUIInfo,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAppActivationUIInfo,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetShowUI: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAppActivationUIInfo,
                value: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAppActivationUIInfo,
                value: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetKeyState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAppActivationUIInfo,
                value: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAppActivationUIInfo,
                value: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAppActivationUIInfo_GetMonitor(self: *const T, value: ?*?HMONITOR) HRESULT {
                return @as(*const IAppActivationUIInfo.VTable, @ptrCast(self.vtable)).GetMonitor(@as(*const IAppActivationUIInfo, @ptrCast(self)), value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAppActivationUIInfo_GetInvokePoint(self: *const T, value: ?*POINT) HRESULT {
                return @as(*const IAppActivationUIInfo.VTable, @ptrCast(self.vtable)).GetInvokePoint(@as(*const IAppActivationUIInfo, @ptrCast(self)), value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAppActivationUIInfo_GetShowCommand(self: *const T, value: ?*i32) HRESULT {
                return @as(*const IAppActivationUIInfo.VTable, @ptrCast(self.vtable)).GetShowCommand(@as(*const IAppActivationUIInfo, @ptrCast(self)), value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAppActivationUIInfo_GetShowUI(self: *const T, value: ?*BOOL) HRESULT {
                return @as(*const IAppActivationUIInfo.VTable, @ptrCast(self.vtable)).GetShowUI(@as(*const IAppActivationUIInfo, @ptrCast(self)), value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAppActivationUIInfo_GetKeyState(self: *const T, value: ?*u32) HRESULT {
                return @as(*const IAppActivationUIInfo.VTable, @ptrCast(self.vtable)).GetKeyState(@as(*const IAppActivationUIInfo, @ptrCast(self)), value);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const FLYOUT_PLACEMENT = enum(i32) {
    DEFAULT = 0,
    ABOVE = 1,
    BELOW = 2,
    LEFT = 3,
    RIGHT = 4,
};
pub const FP_DEFAULT = FLYOUT_PLACEMENT.DEFAULT;
pub const FP_ABOVE = FLYOUT_PLACEMENT.ABOVE;
pub const FP_BELOW = FLYOUT_PLACEMENT.BELOW;
pub const FP_LEFT = FLYOUT_PLACEMENT.LEFT;
pub const FP_RIGHT = FLYOUT_PLACEMENT.RIGHT;

// TODO: this type is limited to platform 'windows8.1'
const IID_IContactManagerInterop_Value = Guid.initString("99eacba7-e073-43b6-a896-55afe48a0833");
pub const IID_IContactManagerInterop = &IID_IContactManagerInterop_Value;
pub const IContactManagerInterop = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ShowContactCardForWindow: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IContactManagerInterop,
                appWindow: ?HWND,
                contact: ?*IUnknown,
                selection: ?*const RECT,
                preferredPlacement: FLYOUT_PLACEMENT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IContactManagerInterop,
                appWindow: ?HWND,
                contact: ?*IUnknown,
                selection: ?*const RECT,
                preferredPlacement: FLYOUT_PLACEMENT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IContactManagerInterop_ShowContactCardForWindow(self: *const T, appWindow: ?HWND, contact: ?*IUnknown, selection: ?*const RECT, preferredPlacement: FLYOUT_PLACEMENT) HRESULT {
                return @as(*const IContactManagerInterop.VTable, @ptrCast(self.vtable)).ShowContactCardForWindow(@as(*const IContactManagerInterop, @ptrCast(self)), appWindow, contact, selection, preferredPlacement);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IShellIconOverlayIdentifier_Value = Guid.initString("0c6c4200-c589-11d0-999a-00c04fd655e1");
pub const IID_IShellIconOverlayIdentifier = &IID_IShellIconOverlayIdentifier_Value;
pub const IShellIconOverlayIdentifier = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IsMemberOf: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellIconOverlayIdentifier,
                pwszPath: ?[*:0]const u16,
                dwAttrib: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellIconOverlayIdentifier,
                pwszPath: ?[*:0]const u16,
                dwAttrib: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOverlayInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellIconOverlayIdentifier,
                pwszIconFile: [*:0]u16,
                cchMax: i32,
                pIndex: ?*i32,
                pdwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellIconOverlayIdentifier,
                pwszIconFile: [*:0]u16,
                cchMax: i32,
                pIndex: ?*i32,
                pdwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPriority: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellIconOverlayIdentifier,
                pPriority: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellIconOverlayIdentifier,
                pPriority: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellIconOverlayIdentifier_IsMemberOf(self: *const T, pwszPath: ?[*:0]const u16, dwAttrib: u32) HRESULT {
                return @as(*const IShellIconOverlayIdentifier.VTable, @ptrCast(self.vtable)).IsMemberOf(@as(*const IShellIconOverlayIdentifier, @ptrCast(self)), pwszPath, dwAttrib);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellIconOverlayIdentifier_GetOverlayInfo(self: *const T, pwszIconFile: [*:0]u16, cchMax: i32, pIndex: ?*i32, pdwFlags: ?*u32) HRESULT {
                return @as(*const IShellIconOverlayIdentifier.VTable, @ptrCast(self.vtable)).GetOverlayInfo(@as(*const IShellIconOverlayIdentifier, @ptrCast(self)), pwszIconFile, cchMax, pIndex, pdwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellIconOverlayIdentifier_GetPriority(self: *const T, pPriority: ?*i32) HRESULT {
                return @as(*const IShellIconOverlayIdentifier.VTable, @ptrCast(self.vtable)).GetPriority(@as(*const IShellIconOverlayIdentifier, @ptrCast(self)), pPriority);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const BANNER_NOTIFICATION_EVENT = enum(i32) {
    Rendered = 0,
    Hovered = 1,
    Closed = 2,
    Dismissed = 3,
    Button1Clicked = 4,
    Button2Clicked = 5,
};
pub const BNE_Rendered = BANNER_NOTIFICATION_EVENT.Rendered;
pub const BNE_Hovered = BANNER_NOTIFICATION_EVENT.Hovered;
pub const BNE_Closed = BANNER_NOTIFICATION_EVENT.Closed;
pub const BNE_Dismissed = BANNER_NOTIFICATION_EVENT.Dismissed;
pub const BNE_Button1Clicked = BANNER_NOTIFICATION_EVENT.Button1Clicked;
pub const BNE_Button2Clicked = BANNER_NOTIFICATION_EVENT.Button2Clicked;

pub const BANNER_NOTIFICATION = extern struct {
    event: BANNER_NOTIFICATION_EVENT,
    providerIdentity: ?[*:0]const u16,
    contentId: ?[*:0]const u16,
};

const IID_IBannerNotificationHandler_Value = Guid.initString("8d7b2ba7-db05-46a8-823c-d2b6de08ee91");
pub const IID_IBannerNotificationHandler = &IID_IBannerNotificationHandler_Value;
pub const IBannerNotificationHandler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnBannerEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBannerNotificationHandler,
                notification: ?*const BANNER_NOTIFICATION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBannerNotificationHandler,
                notification: ?*const BANNER_NOTIFICATION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBannerNotificationHandler_OnBannerEvent(self: *const T, notification: ?*const BANNER_NOTIFICATION) HRESULT {
                return @as(*const IBannerNotificationHandler.VTable, @ptrCast(self.vtable)).OnBannerEvent(@as(*const IBannerNotificationHandler, @ptrCast(self)), notification);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SORT_ORDER_TYPE = enum(i32) {
    DEFAULT = 0,
    IGNORE_FOLDERNESS = 1,
};
pub const SOT_DEFAULT = SORT_ORDER_TYPE.DEFAULT;
pub const SOT_IGNORE_FOLDERNESS = SORT_ORDER_TYPE.IGNORE_FOLDERNESS;

const IID_ISortColumnArray_Value = Guid.initString("6dfc60fb-f2e9-459b-beb5-288f1a7c7d54");
pub const IID_ISortColumnArray = &IID_ISortColumnArray_Value;
pub const ISortColumnArray = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISortColumnArray,
                columnCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISortColumnArray,
                columnCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAt: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISortColumnArray,
                index: u32,
                sortcolumn: ?*SORTCOLUMN,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISortColumnArray,
                index: u32,
                sortcolumn: ?*SORTCOLUMN,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSortType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISortColumnArray,
                type: ?*SORT_ORDER_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISortColumnArray,
                type: ?*SORT_ORDER_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISortColumnArray_GetCount(self: *const T, columnCount: ?*u32) HRESULT {
                return @as(*const ISortColumnArray.VTable, @ptrCast(self.vtable)).GetCount(@as(*const ISortColumnArray, @ptrCast(self)), columnCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISortColumnArray_GetAt(self: *const T, index: u32, sortcolumn: ?*SORTCOLUMN) HRESULT {
                return @as(*const ISortColumnArray.VTable, @ptrCast(self.vtable)).GetAt(@as(*const ISortColumnArray, @ptrCast(self)), index, sortcolumn);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISortColumnArray_GetSortType(self: *const T, type_: ?*SORT_ORDER_TYPE) HRESULT {
                return @as(*const ISortColumnArray.VTable, @ptrCast(self.vtable)).GetSortType(@as(*const ISortColumnArray, @ptrCast(self)), type_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IPropertyKeyStore_Value = Guid.initString("75bd59aa-f23b-4963-aba4-0b355752a91b");
pub const IID_IPropertyKeyStore = &IID_IPropertyKeyStore_Value;
pub const IPropertyKeyStore = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetKeyCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPropertyKeyStore,
                keyCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPropertyKeyStore,
                keyCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetKeyAt: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPropertyKeyStore,
                index: i32,
                pkey: ?*PROPERTYKEY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPropertyKeyStore,
                index: i32,
                pkey: ?*PROPERTYKEY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AppendKey: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPropertyKeyStore,
                key: ?*const PROPERTYKEY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPropertyKeyStore,
                key: ?*const PROPERTYKEY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeleteKey: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPropertyKeyStore,
                index: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPropertyKeyStore,
                index: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsKeyInStore: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPropertyKeyStore,
                key: ?*const PROPERTYKEY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPropertyKeyStore,
                key: ?*const PROPERTYKEY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveKey: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPropertyKeyStore,
                key: ?*const PROPERTYKEY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPropertyKeyStore,
                key: ?*const PROPERTYKEY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPropertyKeyStore_GetKeyCount(self: *const T, keyCount: ?*i32) HRESULT {
                return @as(*const IPropertyKeyStore.VTable, @ptrCast(self.vtable)).GetKeyCount(@as(*const IPropertyKeyStore, @ptrCast(self)), keyCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPropertyKeyStore_GetKeyAt(self: *const T, index: i32, pkey: ?*PROPERTYKEY) HRESULT {
                return @as(*const IPropertyKeyStore.VTable, @ptrCast(self.vtable)).GetKeyAt(@as(*const IPropertyKeyStore, @ptrCast(self)), index, pkey);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPropertyKeyStore_AppendKey(self: *const T, key: ?*const PROPERTYKEY) HRESULT {
                return @as(*const IPropertyKeyStore.VTable, @ptrCast(self.vtable)).AppendKey(@as(*const IPropertyKeyStore, @ptrCast(self)), key);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPropertyKeyStore_DeleteKey(self: *const T, index: i32) HRESULT {
                return @as(*const IPropertyKeyStore.VTable, @ptrCast(self.vtable)).DeleteKey(@as(*const IPropertyKeyStore, @ptrCast(self)), index);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPropertyKeyStore_IsKeyInStore(self: *const T, key: ?*const PROPERTYKEY) HRESULT {
                return @as(*const IPropertyKeyStore.VTable, @ptrCast(self.vtable)).IsKeyInStore(@as(*const IPropertyKeyStore, @ptrCast(self)), key);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPropertyKeyStore_RemoveKey(self: *const T, key: ?*const PROPERTYKEY) HRESULT {
                return @as(*const IPropertyKeyStore.VTable, @ptrCast(self.vtable)).RemoveKey(@as(*const IPropertyKeyStore, @ptrCast(self)), key);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IQueryCodePage_Value = Guid.initString("c7b236ce-ee80-11d0-985f-006008059382");
pub const IID_IQueryCodePage = &IID_IQueryCodePage_Value;
pub const IQueryCodePage = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCodePage: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IQueryCodePage,
                puiCodePage: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IQueryCodePage,
                puiCodePage: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCodePage: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IQueryCodePage,
                uiCodePage: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IQueryCodePage,
                uiCodePage: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IQueryCodePage_GetCodePage(self: *const T, puiCodePage: ?*u32) HRESULT {
                return @as(*const IQueryCodePage.VTable, @ptrCast(self.vtable)).GetCodePage(@as(*const IQueryCodePage, @ptrCast(self)), puiCodePage);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IQueryCodePage_SetCodePage(self: *const T, uiCodePage: u32) HRESULT {
                return @as(*const IQueryCodePage.VTable, @ptrCast(self.vtable)).SetCodePage(@as(*const IQueryCodePage, @ptrCast(self)), uiCodePage);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const FOLDERVIEWOPTIONS = enum(i32) {
    DEFAULT = 0,
    VISTALAYOUT = 1,
    CUSTOMPOSITION = 2,
    CUSTOMORDERING = 4,
    SUPPORTHYPERLINKS = 8,
    NOANIMATIONS = 16,
    NOSCROLLTIPS = 32,
};
pub const FVO_DEFAULT = FOLDERVIEWOPTIONS.DEFAULT;
pub const FVO_VISTALAYOUT = FOLDERVIEWOPTIONS.VISTALAYOUT;
pub const FVO_CUSTOMPOSITION = FOLDERVIEWOPTIONS.CUSTOMPOSITION;
pub const FVO_CUSTOMORDERING = FOLDERVIEWOPTIONS.CUSTOMORDERING;
pub const FVO_SUPPORTHYPERLINKS = FOLDERVIEWOPTIONS.SUPPORTHYPERLINKS;
pub const FVO_NOANIMATIONS = FOLDERVIEWOPTIONS.NOANIMATIONS;
pub const FVO_NOSCROLLTIPS = FOLDERVIEWOPTIONS.NOSCROLLTIPS;

// TODO: this type is limited to platform 'windows6.1'
const IID_IFolderViewOptions_Value = Guid.initString("3cc974d2-b302-4d36-ad3e-06d93f695d3f");
pub const IID_IFolderViewOptions = &IID_IFolderViewOptions_Value;
pub const IFolderViewOptions = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetFolderViewOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFolderViewOptions,
                fvoMask: FOLDERVIEWOPTIONS,
                fvoFlags: FOLDERVIEWOPTIONS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFolderViewOptions,
                fvoMask: FOLDERVIEWOPTIONS,
                fvoFlags: FOLDERVIEWOPTIONS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFolderViewOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFolderViewOptions,
                pfvoFlags: ?*FOLDERVIEWOPTIONS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFolderViewOptions,
                pfvoFlags: ?*FOLDERVIEWOPTIONS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFolderViewOptions_SetFolderViewOptions(self: *const T, fvoMask: FOLDERVIEWOPTIONS, fvoFlags: FOLDERVIEWOPTIONS) HRESULT {
                return @as(*const IFolderViewOptions.VTable, @ptrCast(self.vtable)).SetFolderViewOptions(@as(*const IFolderViewOptions, @ptrCast(self)), fvoMask, fvoFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFolderViewOptions_GetFolderViewOptions(self: *const T, pfvoFlags: ?*FOLDERVIEWOPTIONS) HRESULT {
                return @as(*const IFolderViewOptions.VTable, @ptrCast(self.vtable)).GetFolderViewOptions(@as(*const IFolderViewOptions, @ptrCast(self)), pfvoFlags);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const _SV3CVW3_FLAGS = enum(i32) {
    DEFAULT = 0,
    NONINTERACTIVE = 1,
    FORCEVIEWMODE = 2,
    FORCEFOLDERFLAGS = 4,
};
pub const SV3CVW3_DEFAULT = _SV3CVW3_FLAGS.DEFAULT;
pub const SV3CVW3_NONINTERACTIVE = _SV3CVW3_FLAGS.NONINTERACTIVE;
pub const SV3CVW3_FORCEVIEWMODE = _SV3CVW3_FLAGS.FORCEVIEWMODE;
pub const SV3CVW3_FORCEFOLDERFLAGS = _SV3CVW3_FLAGS.FORCEFOLDERFLAGS;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IShellView3_Value = Guid.initString("ec39fa88-f8af-41c5-8421-38bed28f4673");
pub const IID_IShellView3 = &IID_IShellView3_Value;
pub const IShellView3 = extern struct {
    pub const VTable = extern struct {
        base: IShellView2.VTable,
        CreateViewWindow3: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellView3,
                psbOwner: ?*IShellBrowser,
                psvPrev: ?*IShellView,
                dwViewFlags: u32,
                dwMask: FOLDERFLAGS,
                dwFlags: FOLDERFLAGS,
                fvMode: FOLDERVIEWMODE,
                pvid: ?*const Guid,
                prcView: ?*const RECT,
                phwndView: ?*?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellView3,
                psbOwner: ?*IShellBrowser,
                psvPrev: ?*IShellView,
                dwViewFlags: u32,
                dwMask: FOLDERFLAGS,
                dwFlags: FOLDERFLAGS,
                fvMode: FOLDERVIEWMODE,
                pvid: ?*const Guid,
                prcView: ?*const RECT,
                phwndView: ?*?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IShellView2.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellView3_CreateViewWindow3(self: *const T, psbOwner: ?*IShellBrowser, psvPrev: ?*IShellView, dwViewFlags: u32, dwMask: FOLDERFLAGS, dwFlags: FOLDERFLAGS, fvMode: FOLDERVIEWMODE, pvid: ?*const Guid, prcView: ?*const RECT, phwndView: ?*?HWND) HRESULT {
                return @as(*const IShellView3.VTable, @ptrCast(self.vtable)).CreateViewWindow3(@as(*const IShellView3, @ptrCast(self)), psbOwner, psvPrev, dwViewFlags, dwMask, dwFlags, fvMode, pvid, prcView, phwndView);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ISearchBoxInfo_Value = Guid.initString("6af6e03f-d664-4ef4-9626-f7e0ed36755e");
pub const IID_ISearchBoxInfo = &IID_ISearchBoxInfo_Value;
pub const ISearchBoxInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCondition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISearchBoxInfo,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISearchBoxInfo,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISearchBoxInfo,
                ppsz: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISearchBoxInfo,
                ppsz: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchBoxInfo_GetCondition(self: *const T, riid: ?*const Guid, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const ISearchBoxInfo.VTable, @ptrCast(self.vtable)).GetCondition(@as(*const ISearchBoxInfo, @ptrCast(self)), riid, ppv);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchBoxInfo_GetText(self: *const T, ppsz: ?*?PWSTR) HRESULT {
                return @as(*const ISearchBoxInfo.VTable, @ptrCast(self.vtable)).GetText(@as(*const ISearchBoxInfo, @ptrCast(self)), ppsz);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const VPWATERMARKFLAGS = enum(i32) {
    DEFAULT = 0,
    ALPHABLEND = 1,
};
pub const VPWF_DEFAULT = VPWATERMARKFLAGS.DEFAULT;
pub const VPWF_ALPHABLEND = VPWATERMARKFLAGS.ALPHABLEND;

pub const VPCOLORFLAGS = enum(i32) {
    TEXT = 1,
    BACKGROUND = 2,
    SORTCOLUMN = 3,
    SUBTEXT = 4,
    TEXTBACKGROUND = 5,
};
pub const VPCF_TEXT = VPCOLORFLAGS.TEXT;
pub const VPCF_BACKGROUND = VPCOLORFLAGS.BACKGROUND;
pub const VPCF_SORTCOLUMN = VPCOLORFLAGS.SORTCOLUMN;
pub const VPCF_SUBTEXT = VPCOLORFLAGS.SUBTEXT;
pub const VPCF_TEXTBACKGROUND = VPCOLORFLAGS.TEXTBACKGROUND;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IVisualProperties_Value = Guid.initString("e693cf68-d967-4112-8763-99172aee5e5a");
pub const IID_IVisualProperties = &IID_IVisualProperties_Value;
pub const IVisualProperties = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetWatermark: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IVisualProperties,
                hbmp: ?HBITMAP,
                vpwf: VPWATERMARKFLAGS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IVisualProperties,
                hbmp: ?HBITMAP,
                vpwf: VPWATERMARKFLAGS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetColor: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IVisualProperties,
                vpcf: VPCOLORFLAGS,
                cr: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IVisualProperties,
                vpcf: VPCOLORFLAGS,
                cr: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetColor: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IVisualProperties,
                vpcf: VPCOLORFLAGS,
                pcr: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IVisualProperties,
                vpcf: VPCOLORFLAGS,
                pcr: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetItemHeight: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IVisualProperties,
                cyItemInPixels: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IVisualProperties,
                cyItemInPixels: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetItemHeight: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IVisualProperties,
                cyItemInPixels: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IVisualProperties,
                cyItemInPixels: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFont: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IVisualProperties,
                plf: ?*const LOGFONTW,
                bRedraw: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IVisualProperties,
                plf: ?*const LOGFONTW,
                bRedraw: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFont: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IVisualProperties,
                plf: ?*LOGFONTW,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IVisualProperties,
                plf: ?*LOGFONTW,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTheme: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IVisualProperties,
                pszSubAppName: ?[*:0]const u16,
                pszSubIdList: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IVisualProperties,
                pszSubAppName: ?[*:0]const u16,
                pszSubIdList: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IVisualProperties_SetWatermark(self: *const T, hbmp: ?HBITMAP, vpwf: VPWATERMARKFLAGS) HRESULT {
                return @as(*const IVisualProperties.VTable, @ptrCast(self.vtable)).SetWatermark(@as(*const IVisualProperties, @ptrCast(self)), hbmp, vpwf);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IVisualProperties_SetColor(self: *const T, vpcf: VPCOLORFLAGS, cr: u32) HRESULT {
                return @as(*const IVisualProperties.VTable, @ptrCast(self.vtable)).SetColor(@as(*const IVisualProperties, @ptrCast(self)), vpcf, cr);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IVisualProperties_GetColor(self: *const T, vpcf: VPCOLORFLAGS, pcr: ?*u32) HRESULT {
                return @as(*const IVisualProperties.VTable, @ptrCast(self.vtable)).GetColor(@as(*const IVisualProperties, @ptrCast(self)), vpcf, pcr);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IVisualProperties_SetItemHeight(self: *const T, cyItemInPixels: i32) HRESULT {
                return @as(*const IVisualProperties.VTable, @ptrCast(self.vtable)).SetItemHeight(@as(*const IVisualProperties, @ptrCast(self)), cyItemInPixels);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IVisualProperties_GetItemHeight(self: *const T, cyItemInPixels: ?*i32) HRESULT {
                return @as(*const IVisualProperties.VTable, @ptrCast(self.vtable)).GetItemHeight(@as(*const IVisualProperties, @ptrCast(self)), cyItemInPixels);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IVisualProperties_SetFont(self: *const T, plf: ?*const LOGFONTW, bRedraw: BOOL) HRESULT {
                return @as(*const IVisualProperties.VTable, @ptrCast(self.vtable)).SetFont(@as(*const IVisualProperties, @ptrCast(self)), plf, bRedraw);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IVisualProperties_GetFont(self: *const T, plf: ?*LOGFONTW) HRESULT {
                return @as(*const IVisualProperties.VTable, @ptrCast(self.vtable)).GetFont(@as(*const IVisualProperties, @ptrCast(self)), plf);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IVisualProperties_SetTheme(self: *const T, pszSubAppName: ?[*:0]const u16, pszSubIdList: ?[*:0]const u16) HRESULT {
                return @as(*const IVisualProperties.VTable, @ptrCast(self.vtable)).SetTheme(@as(*const IVisualProperties, @ptrCast(self)), pszSubAppName, pszSubIdList);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ICommDlgBrowser3_Value = Guid.initString("c8ad25a1-3294-41ee-8165-71174bd01c57");
pub const IID_ICommDlgBrowser3 = &IID_ICommDlgBrowser3_Value;
pub const ICommDlgBrowser3 = extern struct {
    pub const VTable = extern struct {
        base: ICommDlgBrowser2.VTable,
        OnColumnClicked: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICommDlgBrowser3,
                ppshv: ?*IShellView,
                iColumn: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICommDlgBrowser3,
                ppshv: ?*IShellView,
                iColumn: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentFilter: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICommDlgBrowser3,
                pszFileSpec: [*:0]u16,
                cchFileSpec: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICommDlgBrowser3,
                pszFileSpec: [*:0]u16,
                cchFileSpec: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnPreViewCreated: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICommDlgBrowser3,
                ppshv: ?*IShellView,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICommDlgBrowser3,
                ppshv: ?*IShellView,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ICommDlgBrowser2.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICommDlgBrowser3_OnColumnClicked(self: *const T, ppshv: ?*IShellView, iColumn: i32) HRESULT {
                return @as(*const ICommDlgBrowser3.VTable, @ptrCast(self.vtable)).OnColumnClicked(@as(*const ICommDlgBrowser3, @ptrCast(self)), ppshv, iColumn);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICommDlgBrowser3_GetCurrentFilter(self: *const T, pszFileSpec: [*:0]u16, cchFileSpec: i32) HRESULT {
                return @as(*const ICommDlgBrowser3.VTable, @ptrCast(self.vtable)).GetCurrentFilter(@as(*const ICommDlgBrowser3, @ptrCast(self)), pszFileSpec, cchFileSpec);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICommDlgBrowser3_OnPreViewCreated(self: *const T, ppshv: ?*IShellView) HRESULT {
                return @as(*const ICommDlgBrowser3.VTable, @ptrCast(self.vtable)).OnPreViewCreated(@as(*const ICommDlgBrowser3, @ptrCast(self)), ppshv);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IUserAccountChangeCallback_Value = Guid.initString("a561e69a-b4b8-4113-91a5-64c6bcca3430");
pub const IID_IUserAccountChangeCallback = &IID_IUserAccountChangeCallback_Value;
pub const IUserAccountChangeCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnPictureChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUserAccountChangeCallback,
                pszUserName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUserAccountChangeCallback,
                pszUserName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUserAccountChangeCallback_OnPictureChange(self: *const T, pszUserName: ?[*:0]const u16) HRESULT {
                return @as(*const IUserAccountChangeCallback.VTable, @ptrCast(self.vtable)).OnPictureChange(@as(*const IUserAccountChangeCallback, @ptrCast(self)), pszUserName);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IStreamAsync_Value = Guid.initString("fe0b6665-e0ca-49b9-a178-2b5cb48d92a5");
pub const IID_IStreamAsync = &IID_IStreamAsync_Value;
pub const IStreamAsync = extern struct {
    pub const VTable = extern struct {
        base: IStream.VTable,
        ReadAsync: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IStreamAsync,
                // TODO: what to do with BytesParamIndex 1?
                pv: ?*anyopaque,
                cb: u32,
                pcbRead: ?*u32,
                lpOverlapped: ?*OVERLAPPED,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IStreamAsync,
                // TODO: what to do with BytesParamIndex 1?
                pv: ?*anyopaque,
                cb: u32,
                pcbRead: ?*u32,
                lpOverlapped: ?*OVERLAPPED,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteAsync: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IStreamAsync,
                // TODO: what to do with BytesParamIndex 1?
                lpBuffer: ?*const anyopaque,
                cb: u32,
                pcbWritten: ?*u32,
                lpOverlapped: ?*OVERLAPPED,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IStreamAsync,
                // TODO: what to do with BytesParamIndex 1?
                lpBuffer: ?*const anyopaque,
                cb: u32,
                pcbWritten: ?*u32,
                lpOverlapped: ?*OVERLAPPED,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OverlappedResult: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IStreamAsync,
                lpOverlapped: ?*OVERLAPPED,
                lpNumberOfBytesTransferred: ?*u32,
                bWait: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IStreamAsync,
                lpOverlapped: ?*OVERLAPPED,
                lpNumberOfBytesTransferred: ?*u32,
                bWait: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CancelIo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IStreamAsync,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IStreamAsync,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IStream.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IStreamAsync_ReadAsync(self: *const T, pv: ?*anyopaque, cb: u32, pcbRead: ?*u32, lpOverlapped: ?*OVERLAPPED) HRESULT {
                return @as(*const IStreamAsync.VTable, @ptrCast(self.vtable)).ReadAsync(@as(*const IStreamAsync, @ptrCast(self)), pv, cb, pcbRead, lpOverlapped);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IStreamAsync_WriteAsync(self: *const T, lpBuffer: ?*const anyopaque, cb: u32, pcbWritten: ?*u32, lpOverlapped: ?*OVERLAPPED) HRESULT {
                return @as(*const IStreamAsync.VTable, @ptrCast(self.vtable)).WriteAsync(@as(*const IStreamAsync, @ptrCast(self)), lpBuffer, cb, pcbWritten, lpOverlapped);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IStreamAsync_OverlappedResult(self: *const T, lpOverlapped: ?*OVERLAPPED, lpNumberOfBytesTransferred: ?*u32, bWait: BOOL) HRESULT {
                return @as(*const IStreamAsync.VTable, @ptrCast(self.vtable)).OverlappedResult(@as(*const IStreamAsync, @ptrCast(self)), lpOverlapped, lpNumberOfBytesTransferred, bWait);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IStreamAsync_CancelIo(self: *const T) HRESULT {
                return @as(*const IStreamAsync.VTable, @ptrCast(self.vtable)).CancelIo(@as(*const IStreamAsync, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IStreamUnbufferedInfo_Value = Guid.initString("8a68fdda-1fdc-4c20-8ceb-416643b5a625");
pub const IID_IStreamUnbufferedInfo = &IID_IStreamUnbufferedInfo_Value;
pub const IStreamUnbufferedInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSectorSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IStreamUnbufferedInfo,
                pcbSectorSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IStreamUnbufferedInfo,
                pcbSectorSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IStreamUnbufferedInfo_GetSectorSize(self: *const T, pcbSectorSize: ?*u32) HRESULT {
                return @as(*const IStreamUnbufferedInfo.VTable, @ptrCast(self.vtable)).GetSectorSize(@as(*const IStreamUnbufferedInfo, @ptrCast(self)), pcbSectorSize);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DSH_FLAGS = enum(i32) {
    T = 1,
};
pub const DSH_ALLOWDROPDESCRIPTIONTEXT = DSH_FLAGS.T;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IDragSourceHelper2_Value = Guid.initString("83e07d0d-0c5f-4163-bf1a-60b274051e40");
pub const IID_IDragSourceHelper2 = &IID_IDragSourceHelper2_Value;
pub const IDragSourceHelper2 = extern struct {
    pub const VTable = extern struct {
        base: IDragSourceHelper.VTable,
        SetFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDragSourceHelper2,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDragSourceHelper2,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDragSourceHelper.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDragSourceHelper2_SetFlags(self: *const T, dwFlags: u32) HRESULT {
                return @as(*const IDragSourceHelper2.VTable, @ptrCast(self.vtable)).SetFlags(@as(*const IDragSourceHelper2, @ptrCast(self)), dwFlags);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IHWEventHandler_Value = Guid.initString("c1fb73d0-ec3a-4ba2-b512-8cdb9187b6d1");
pub const IID_IHWEventHandler = &IID_IHWEventHandler_Value;
pub const IHWEventHandler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IHWEventHandler,
                pszParams: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IHWEventHandler,
                pszParams: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        HandleEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IHWEventHandler,
                pszDeviceID: ?[*:0]const u16,
                pszAltDeviceID: ?[*:0]const u16,
                pszEventType: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IHWEventHandler,
                pszDeviceID: ?[*:0]const u16,
                pszAltDeviceID: ?[*:0]const u16,
                pszEventType: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        HandleEventWithContent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IHWEventHandler,
                pszDeviceID: ?[*:0]const u16,
                pszAltDeviceID: ?[*:0]const u16,
                pszEventType: ?[*:0]const u16,
                pszContentTypeHandler: ?[*:0]const u16,
                pdataobject: ?*IDataObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IHWEventHandler,
                pszDeviceID: ?[*:0]const u16,
                pszAltDeviceID: ?[*:0]const u16,
                pszEventType: ?[*:0]const u16,
                pszContentTypeHandler: ?[*:0]const u16,
                pdataobject: ?*IDataObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IHWEventHandler_Initialize(self: *const T, pszParams: ?[*:0]const u16) HRESULT {
                return @as(*const IHWEventHandler.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IHWEventHandler, @ptrCast(self)), pszParams);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IHWEventHandler_HandleEvent(self: *const T, pszDeviceID: ?[*:0]const u16, pszAltDeviceID: ?[*:0]const u16, pszEventType: ?[*:0]const u16) HRESULT {
                return @as(*const IHWEventHandler.VTable, @ptrCast(self.vtable)).HandleEvent(@as(*const IHWEventHandler, @ptrCast(self)), pszDeviceID, pszAltDeviceID, pszEventType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IHWEventHandler_HandleEventWithContent(self: *const T, pszDeviceID: ?[*:0]const u16, pszAltDeviceID: ?[*:0]const u16, pszEventType: ?[*:0]const u16, pszContentTypeHandler: ?[*:0]const u16, pdataobject: ?*IDataObject) HRESULT {
                return @as(*const IHWEventHandler.VTable, @ptrCast(self.vtable)).HandleEventWithContent(@as(*const IHWEventHandler, @ptrCast(self)), pszDeviceID, pszAltDeviceID, pszEventType, pszContentTypeHandler, pdataobject);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IHWEventHandler2_Value = Guid.initString("cfcc809f-295d-42e8-9ffc-424b33c487e6");
pub const IID_IHWEventHandler2 = &IID_IHWEventHandler2_Value;
pub const IHWEventHandler2 = extern struct {
    pub const VTable = extern struct {
        base: IHWEventHandler.VTable,
        HandleEventWithHWND: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IHWEventHandler2,
                pszDeviceID: ?[*:0]const u16,
                pszAltDeviceID: ?[*:0]const u16,
                pszEventType: ?[*:0]const u16,
                hwndOwner: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IHWEventHandler2,
                pszDeviceID: ?[*:0]const u16,
                pszAltDeviceID: ?[*:0]const u16,
                pszEventType: ?[*:0]const u16,
                hwndOwner: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IHWEventHandler.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IHWEventHandler2_HandleEventWithHWND(self: *const T, pszDeviceID: ?[*:0]const u16, pszAltDeviceID: ?[*:0]const u16, pszEventType: ?[*:0]const u16, hwndOwner: ?HWND) HRESULT {
                return @as(*const IHWEventHandler2.VTable, @ptrCast(self.vtable)).HandleEventWithHWND(@as(*const IHWEventHandler2, @ptrCast(self)), pszDeviceID, pszAltDeviceID, pszEventType, hwndOwner);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IQueryCancelAutoPlay_Value = Guid.initString("ddefe873-6997-4e68-be26-39b633adbe12");
pub const IID_IQueryCancelAutoPlay = &IID_IQueryCancelAutoPlay_Value;
pub const IQueryCancelAutoPlay = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AllowAutoPlay: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IQueryCancelAutoPlay,
                pszPath: ?[*:0]const u16,
                dwContentType: u32,
                pszLabel: ?[*:0]const u16,
                dwSerialNumber: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IQueryCancelAutoPlay,
                pszPath: ?[*:0]const u16,
                dwContentType: u32,
                pszLabel: ?[*:0]const u16,
                dwSerialNumber: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IQueryCancelAutoPlay_AllowAutoPlay(self: *const T, pszPath: ?[*:0]const u16, dwContentType: u32, pszLabel: ?[*:0]const u16, dwSerialNumber: u32) HRESULT {
                return @as(*const IQueryCancelAutoPlay.VTable, @ptrCast(self.vtable)).AllowAutoPlay(@as(*const IQueryCancelAutoPlay, @ptrCast(self)), pszPath, dwContentType, pszLabel, dwSerialNumber);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IDynamicHWHandler_Value = Guid.initString("dc2601d7-059e-42fc-a09d-2afd21b6d5f7");
pub const IID_IDynamicHWHandler = &IID_IDynamicHWHandler_Value;
pub const IDynamicHWHandler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDynamicInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDynamicHWHandler,
                pszDeviceID: ?[*:0]const u16,
                dwContentType: u32,
                ppszAction: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDynamicHWHandler,
                pszDeviceID: ?[*:0]const u16,
                dwContentType: u32,
                ppszAction: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDynamicHWHandler_GetDynamicInfo(self: *const T, pszDeviceID: ?[*:0]const u16, dwContentType: u32, ppszAction: ?*?PWSTR) HRESULT {
                return @as(*const IDynamicHWHandler.VTable, @ptrCast(self.vtable)).GetDynamicInfo(@as(*const IDynamicHWHandler, @ptrCast(self)), pszDeviceID, dwContentType, ppszAction);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IUserNotificationCallback_Value = Guid.initString("19108294-0441-4aff-8013-fa0a730b0bea");
pub const IID_IUserNotificationCallback = &IID_IUserNotificationCallback_Value;
pub const IUserNotificationCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnBalloonUserClick: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUserNotificationCallback,
                pt: ?*POINT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUserNotificationCallback,
                pt: ?*POINT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnLeftClick: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUserNotificationCallback,
                pt: ?*POINT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUserNotificationCallback,
                pt: ?*POINT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnContextMenu: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUserNotificationCallback,
                pt: ?*POINT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUserNotificationCallback,
                pt: ?*POINT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUserNotificationCallback_OnBalloonUserClick(self: *const T, pt: ?*POINT) HRESULT {
                return @as(*const IUserNotificationCallback.VTable, @ptrCast(self.vtable)).OnBalloonUserClick(@as(*const IUserNotificationCallback, @ptrCast(self)), pt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUserNotificationCallback_OnLeftClick(self: *const T, pt: ?*POINT) HRESULT {
                return @as(*const IUserNotificationCallback.VTable, @ptrCast(self.vtable)).OnLeftClick(@as(*const IUserNotificationCallback, @ptrCast(self)), pt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUserNotificationCallback_OnContextMenu(self: *const T, pt: ?*POINT) HRESULT {
                return @as(*const IUserNotificationCallback.VTable, @ptrCast(self.vtable)).OnContextMenu(@as(*const IUserNotificationCallback, @ptrCast(self)), pt);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IUserNotification2_Value = Guid.initString("215913cc-57eb-4fab-ab5a-e5fa7bea2a6c");
pub const IID_IUserNotification2 = &IID_IUserNotification2_Value;
pub const IUserNotification2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetBalloonInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUserNotification2,
                pszTitle: ?[*:0]const u16,
                pszText: ?[*:0]const u16,
                dwInfoFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUserNotification2,
                pszTitle: ?[*:0]const u16,
                pszText: ?[*:0]const u16,
                dwInfoFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetBalloonRetry: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUserNotification2,
                dwShowTime: u32,
                dwInterval: u32,
                cRetryCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUserNotification2,
                dwShowTime: u32,
                dwInterval: u32,
                cRetryCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetIconInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUserNotification2,
                hIcon: ?HICON,
                pszToolTip: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUserNotification2,
                hIcon: ?HICON,
                pszToolTip: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Show: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUserNotification2,
                pqc: ?*IQueryContinue,
                dwContinuePollInterval: u32,
                pSink: ?*IUserNotificationCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUserNotification2,
                pqc: ?*IQueryContinue,
                dwContinuePollInterval: u32,
                pSink: ?*IUserNotificationCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PlaySound: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUserNotification2,
                pszSoundName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUserNotification2,
                pszSoundName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUserNotification2_SetBalloonInfo(self: *const T, pszTitle: ?[*:0]const u16, pszText: ?[*:0]const u16, dwInfoFlags: u32) HRESULT {
                return @as(*const IUserNotification2.VTable, @ptrCast(self.vtable)).SetBalloonInfo(@as(*const IUserNotification2, @ptrCast(self)), pszTitle, pszText, dwInfoFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUserNotification2_SetBalloonRetry(self: *const T, dwShowTime: u32, dwInterval: u32, cRetryCount: u32) HRESULT {
                return @as(*const IUserNotification2.VTable, @ptrCast(self.vtable)).SetBalloonRetry(@as(*const IUserNotification2, @ptrCast(self)), dwShowTime, dwInterval, cRetryCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUserNotification2_SetIconInfo(self: *const T, hIcon: ?HICON, pszToolTip: ?[*:0]const u16) HRESULT {
                return @as(*const IUserNotification2.VTable, @ptrCast(self.vtable)).SetIconInfo(@as(*const IUserNotification2, @ptrCast(self)), hIcon, pszToolTip);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUserNotification2_Show(self: *const T, pqc: ?*IQueryContinue, dwContinuePollInterval: u32, pSink: ?*IUserNotificationCallback) HRESULT {
                return @as(*const IUserNotification2.VTable, @ptrCast(self.vtable)).Show(@as(*const IUserNotification2, @ptrCast(self)), pqc, dwContinuePollInterval, pSink);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUserNotification2_PlaySound(self: *const T, pszSoundName: ?[*:0]const u16) HRESULT {
                return @as(*const IUserNotification2.VTable, @ptrCast(self.vtable)).PlaySound(@as(*const IUserNotification2, @ptrCast(self)), pszSoundName);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IDeskBand2_Value = Guid.initString("79d16de4-abee-4021-8d9d-9169b261d657");
pub const IID_IDeskBand2 = &IID_IDeskBand2_Value;
pub const IDeskBand2 = extern struct {
    pub const VTable = extern struct {
        base: IDeskBand.VTable,
        CanRenderComposited: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDeskBand2,
                pfCanRenderComposited: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDeskBand2,
                pfCanRenderComposited: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCompositionState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDeskBand2,
                fCompositionEnabled: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDeskBand2,
                fCompositionEnabled: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCompositionState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDeskBand2,
                pfCompositionEnabled: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDeskBand2,
                pfCompositionEnabled: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDeskBand.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDeskBand2_CanRenderComposited(self: *const T, pfCanRenderComposited: ?*BOOL) HRESULT {
                return @as(*const IDeskBand2.VTable, @ptrCast(self.vtable)).CanRenderComposited(@as(*const IDeskBand2, @ptrCast(self)), pfCanRenderComposited);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDeskBand2_SetCompositionState(self: *const T, fCompositionEnabled: BOOL) HRESULT {
                return @as(*const IDeskBand2.VTable, @ptrCast(self.vtable)).SetCompositionState(@as(*const IDeskBand2, @ptrCast(self)), fCompositionEnabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDeskBand2_GetCompositionState(self: *const T, pfCompositionEnabled: ?*BOOL) HRESULT {
                return @as(*const IDeskBand2.VTable, @ptrCast(self.vtable)).GetCompositionState(@as(*const IDeskBand2, @ptrCast(self)), pfCompositionEnabled);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IStartMenuPinnedList_Value = Guid.initString("4cd19ada-25a5-4a32-b3b7-347bee5be36b");
pub const IID_IStartMenuPinnedList = &IID_IStartMenuPinnedList_Value;
pub const IStartMenuPinnedList = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RemoveFromList: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IStartMenuPinnedList,
                pitem: ?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IStartMenuPinnedList,
                pitem: ?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IStartMenuPinnedList_RemoveFromList(self: *const T, pitem: ?*IShellItem) HRESULT {
                return @as(*const IStartMenuPinnedList.VTable, @ptrCast(self.vtable)).RemoveFromList(@as(*const IStartMenuPinnedList, @ptrCast(self)), pitem);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ICDBurn_Value = Guid.initString("3d73a659-e5d0-4d42-afc0-5121ba425c8d");
pub const IID_ICDBurn = &IID_ICDBurn_Value;
pub const ICDBurn = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetRecorderDriveLetter: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICDBurn,
                pszDrive: [*:0]u16,
                cch: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICDBurn,
                pszDrive: [*:0]u16,
                cch: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Burn: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICDBurn,
                hwnd: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICDBurn,
                hwnd: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        HasRecordableDrive: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICDBurn,
                pfHasRecorder: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICDBurn,
                pfHasRecorder: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICDBurn_GetRecorderDriveLetter(self: *const T, pszDrive: [*:0]u16, cch: u32) HRESULT {
                return @as(*const ICDBurn.VTable, @ptrCast(self.vtable)).GetRecorderDriveLetter(@as(*const ICDBurn, @ptrCast(self)), pszDrive, cch);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICDBurn_Burn(self: *const T, hwnd: ?HWND) HRESULT {
                return @as(*const ICDBurn.VTable, @ptrCast(self.vtable)).Burn(@as(*const ICDBurn, @ptrCast(self)), hwnd);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICDBurn_HasRecordableDrive(self: *const T, pfHasRecorder: ?*BOOL) HRESULT {
                return @as(*const ICDBurn.VTable, @ptrCast(self.vtable)).HasRecordableDrive(@as(*const ICDBurn, @ptrCast(self)), pfHasRecorder);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IWizardSite_Value = Guid.initString("88960f5b-422f-4e7b-8013-73415381c3c3");
pub const IID_IWizardSite = &IID_IWizardSite_Value;
pub const IWizardSite = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPreviousPage: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWizardSite,
                phpage: ?*?HPROPSHEETPAGE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWizardSite,
                phpage: ?*?HPROPSHEETPAGE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNextPage: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWizardSite,
                phpage: ?*?HPROPSHEETPAGE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWizardSite,
                phpage: ?*?HPROPSHEETPAGE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCancelledPage: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWizardSite,
                phpage: ?*?HPROPSHEETPAGE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWizardSite,
                phpage: ?*?HPROPSHEETPAGE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWizardSite_GetPreviousPage(self: *const T, phpage: ?*?HPROPSHEETPAGE) HRESULT {
                return @as(*const IWizardSite.VTable, @ptrCast(self.vtable)).GetPreviousPage(@as(*const IWizardSite, @ptrCast(self)), phpage);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWizardSite_GetNextPage(self: *const T, phpage: ?*?HPROPSHEETPAGE) HRESULT {
                return @as(*const IWizardSite.VTable, @ptrCast(self.vtable)).GetNextPage(@as(*const IWizardSite, @ptrCast(self)), phpage);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWizardSite_GetCancelledPage(self: *const T, phpage: ?*?HPROPSHEETPAGE) HRESULT {
                return @as(*const IWizardSite.VTable, @ptrCast(self.vtable)).GetCancelledPage(@as(*const IWizardSite, @ptrCast(self)), phpage);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IWizardExtension_Value = Guid.initString("c02ea696-86cc-491e-9b23-74394a0444a8");
pub const IID_IWizardExtension = &IID_IWizardExtension_Value;
pub const IWizardExtension = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddPages: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWizardExtension,
                aPages: [*]?HPROPSHEETPAGE,
                cPages: u32,
                pnPagesAdded: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWizardExtension,
                aPages: [*]?HPROPSHEETPAGE,
                cPages: u32,
                pnPagesAdded: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFirstPage: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWizardExtension,
                phpage: ?*?HPROPSHEETPAGE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWizardExtension,
                phpage: ?*?HPROPSHEETPAGE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLastPage: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWizardExtension,
                phpage: ?*?HPROPSHEETPAGE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWizardExtension,
                phpage: ?*?HPROPSHEETPAGE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWizardExtension_AddPages(self: *const T, aPages: [*]?HPROPSHEETPAGE, cPages: u32, pnPagesAdded: ?*u32) HRESULT {
                return @as(*const IWizardExtension.VTable, @ptrCast(self.vtable)).AddPages(@as(*const IWizardExtension, @ptrCast(self)), aPages, cPages, pnPagesAdded);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWizardExtension_GetFirstPage(self: *const T, phpage: ?*?HPROPSHEETPAGE) HRESULT {
                return @as(*const IWizardExtension.VTable, @ptrCast(self.vtable)).GetFirstPage(@as(*const IWizardExtension, @ptrCast(self)), phpage);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWizardExtension_GetLastPage(self: *const T, phpage: ?*?HPROPSHEETPAGE) HRESULT {
                return @as(*const IWizardExtension.VTable, @ptrCast(self.vtable)).GetLastPage(@as(*const IWizardExtension, @ptrCast(self)), phpage);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IWebWizardExtension_Value = Guid.initString("0e6b3f66-98d1-48c0-a222-fbde74e2fbc5");
pub const IID_IWebWizardExtension = &IID_IWebWizardExtension_Value;
pub const IWebWizardExtension = extern struct {
    pub const VTable = extern struct {
        base: IWizardExtension.VTable,
        SetInitialURL: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWebWizardExtension,
                pszURL: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWebWizardExtension,
                pszURL: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetErrorURL: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWebWizardExtension,
                pszErrorURL: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWebWizardExtension,
                pszErrorURL: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWizardExtension.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWebWizardExtension_SetInitialURL(self: *const T, pszURL: ?[*:0]const u16) HRESULT {
                return @as(*const IWebWizardExtension.VTable, @ptrCast(self.vtable)).SetInitialURL(@as(*const IWebWizardExtension, @ptrCast(self)), pszURL);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWebWizardExtension_SetErrorURL(self: *const T, pszErrorURL: ?[*:0]const u16) HRESULT {
                return @as(*const IWebWizardExtension.VTable, @ptrCast(self.vtable)).SetErrorURL(@as(*const IWebWizardExtension, @ptrCast(self)), pszErrorURL);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IPublishingWizard_Value = Guid.initString("aa9198bb-ccec-472d-beed-19a4f6733f7a");
pub const IID_IPublishingWizard = &IID_IPublishingWizard_Value;
pub const IPublishingWizard = extern struct {
    pub const VTable = extern struct {
        base: IWizardExtension.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPublishingWizard,
                pdo: ?*IDataObject,
                dwOptions: u32,
                pszServiceScope: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPublishingWizard,
                pdo: ?*IDataObject,
                dwOptions: u32,
                pszServiceScope: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTransferManifest: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPublishingWizard,
                phrFromTransfer: ?*HRESULT,
                pdocManifest: ?*?*IXMLDOMDocument,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPublishingWizard,
                phrFromTransfer: ?*HRESULT,
                pdocManifest: ?*?*IXMLDOMDocument,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWizardExtension.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPublishingWizard_Initialize(self: *const T, pdo: ?*IDataObject, dwOptions: u32, pszServiceScope: ?[*:0]const u16) HRESULT {
                return @as(*const IPublishingWizard.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IPublishingWizard, @ptrCast(self)), pdo, dwOptions, pszServiceScope);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPublishingWizard_GetTransferManifest(self: *const T, phrFromTransfer: ?*HRESULT, pdocManifest: ?*?*IXMLDOMDocument) HRESULT {
                return @as(*const IPublishingWizard.VTable, @ptrCast(self.vtable)).GetTransferManifest(@as(*const IPublishingWizard, @ptrCast(self)), phrFromTransfer, pdocManifest);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IFolderViewHost_Value = Guid.initString("1ea58f02-d55a-411d-b09e-9e65ac21605b");
pub const IID_IFolderViewHost = &IID_IFolderViewHost_Value;
pub const IFolderViewHost = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFolderViewHost,
                hwndParent: ?HWND,
                pdo: ?*IDataObject,
                prc: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFolderViewHost,
                hwndParent: ?HWND,
                pdo: ?*IDataObject,
                prc: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFolderViewHost_Initialize(self: *const T, hwndParent: ?HWND, pdo: ?*IDataObject, prc: ?*RECT) HRESULT {
                return @as(*const IFolderViewHost.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IFolderViewHost, @ptrCast(self)), hwndParent, pdo, prc);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAccessibleObject_Value = Guid.initString("95a391c5-9ed4-4c28-8401-ab9e06719e11");
pub const IID_IAccessibleObject = &IID_IAccessibleObject_Value;
pub const IAccessibleObject = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetAccessibleName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAccessibleObject,
                pszName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAccessibleObject,
                pszName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAccessibleObject_SetAccessibleName(self: *const T, pszName: ?[*:0]const u16) HRESULT {
                return @as(*const IAccessibleObject.VTable, @ptrCast(self.vtable)).SetAccessibleName(@as(*const IAccessibleObject, @ptrCast(self)), pszName);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IResultsFolder_Value = Guid.initString("96e5ae6d-6ae1-4b1c-900c-c6480eaa8828");
pub const IID_IResultsFolder = &IID_IResultsFolder_Value;
pub const IResultsFolder = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IResultsFolder,
                psi: ?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IResultsFolder,
                psi: ?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddIDList: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IResultsFolder,
                pidl: ?*ITEMIDLIST,
                ppidlAdded: ?*?*ITEMIDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IResultsFolder,
                pidl: ?*ITEMIDLIST,
                ppidlAdded: ?*?*ITEMIDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IResultsFolder,
                psi: ?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IResultsFolder,
                psi: ?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveIDList: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IResultsFolder,
                pidl: ?*ITEMIDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IResultsFolder,
                pidl: ?*ITEMIDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveAll: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IResultsFolder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IResultsFolder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IResultsFolder_AddItem(self: *const T, psi: ?*IShellItem) HRESULT {
                return @as(*const IResultsFolder.VTable, @ptrCast(self.vtable)).AddItem(@as(*const IResultsFolder, @ptrCast(self)), psi);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IResultsFolder_AddIDList(self: *const T, pidl: ?*ITEMIDLIST, ppidlAdded: ?*?*ITEMIDLIST) HRESULT {
                return @as(*const IResultsFolder.VTable, @ptrCast(self.vtable)).AddIDList(@as(*const IResultsFolder, @ptrCast(self)), pidl, ppidlAdded);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IResultsFolder_RemoveItem(self: *const T, psi: ?*IShellItem) HRESULT {
                return @as(*const IResultsFolder.VTable, @ptrCast(self.vtable)).RemoveItem(@as(*const IResultsFolder, @ptrCast(self)), psi);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IResultsFolder_RemoveIDList(self: *const T, pidl: ?*ITEMIDLIST) HRESULT {
                return @as(*const IResultsFolder.VTable, @ptrCast(self.vtable)).RemoveIDList(@as(*const IResultsFolder, @ptrCast(self)), pidl);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IResultsFolder_RemoveAll(self: *const T) HRESULT {
                return @as(*const IResultsFolder.VTable, @ptrCast(self.vtable)).RemoveAll(@as(*const IResultsFolder, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IAutoCompleteDropDown_Value = Guid.initString("3cd141f4-3c6a-11d2-bcaa-00c04fd929db");
pub const IID_IAutoCompleteDropDown = &IID_IAutoCompleteDropDown_Value;
pub const IAutoCompleteDropDown = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDropDownStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAutoCompleteDropDown,
                pdwFlags: ?*u32,
                ppwszString: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAutoCompleteDropDown,
                pdwFlags: ?*u32,
                ppwszString: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ResetEnumerator: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAutoCompleteDropDown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAutoCompleteDropDown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAutoCompleteDropDown_GetDropDownStatus(self: *const T, pdwFlags: ?*u32, ppwszString: ?*?PWSTR) HRESULT {
                return @as(*const IAutoCompleteDropDown.VTable, @ptrCast(self.vtable)).GetDropDownStatus(@as(*const IAutoCompleteDropDown, @ptrCast(self)), pdwFlags, ppwszString);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAutoCompleteDropDown_ResetEnumerator(self: *const T) HRESULT {
                return @as(*const IAutoCompleteDropDown.VTable, @ptrCast(self.vtable)).ResetEnumerator(@as(*const IAutoCompleteDropDown, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const CDBURNINGEXTENSIONRET = enum(i32) {
    DEFAULT = 0,
    DONTRUNOTHEREXTS = 1,
    STOPWIZARD = 2,
};
pub const CDBE_RET_DEFAULT = CDBURNINGEXTENSIONRET.DEFAULT;
pub const CDBE_RET_DONTRUNOTHEREXTS = CDBURNINGEXTENSIONRET.DONTRUNOTHEREXTS;
pub const CDBE_RET_STOPWIZARD = CDBURNINGEXTENSIONRET.STOPWIZARD;

pub const _CDBE_ACTIONS = enum(i32) {
    MUSIC = 1,
    DATA = 2,
    ALL = -1,
};
pub const CDBE_TYPE_MUSIC = _CDBE_ACTIONS.MUSIC;
pub const CDBE_TYPE_DATA = _CDBE_ACTIONS.DATA;
pub const CDBE_TYPE_ALL = _CDBE_ACTIONS.ALL;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ICDBurnExt_Value = Guid.initString("2271dcca-74fc-4414-8fb7-c56b05ace2d7");
pub const IID_ICDBurnExt = &IID_ICDBurnExt_Value;
pub const ICDBurnExt = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSupportedActionTypes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICDBurnExt,
                pdwActions: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICDBurnExt,
                pdwActions: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICDBurnExt_GetSupportedActionTypes(self: *const T, pdwActions: ?*u32) HRESULT {
                return @as(*const ICDBurnExt.VTable, @ptrCast(self.vtable)).GetSupportedActionTypes(@as(*const ICDBurnExt, @ptrCast(self)), pdwActions);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IEnumReadyCallback_Value = Guid.initString("61e00d45-8fff-4e60-924e-6537b61612dd");
pub const IID_IEnumReadyCallback = &IID_IEnumReadyCallback_Value;
pub const IEnumReadyCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EnumReady: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumReadyCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumReadyCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumReadyCallback_EnumReady(self: *const T) HRESULT {
                return @as(*const IEnumReadyCallback.VTable, @ptrCast(self.vtable)).EnumReady(@as(*const IEnumReadyCallback, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IEnumerableView_Value = Guid.initString("8c8bf236-1aec-495f-9894-91d57c3c686f");
pub const IID_IEnumerableView = &IID_IEnumerableView_Value;
pub const IEnumerableView = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetEnumReadyCallback: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumerableView,
                percb: ?*IEnumReadyCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumerableView,
                percb: ?*IEnumReadyCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateEnumIDListFromContents: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumerableView,
                pidlFolder: ?*ITEMIDLIST,
                dwEnumFlags: u32,
                ppEnumIDList: ?*?*IEnumIDList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumerableView,
                pidlFolder: ?*ITEMIDLIST,
                dwEnumFlags: u32,
                ppEnumIDList: ?*?*IEnumIDList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumerableView_SetEnumReadyCallback(self: *const T, percb: ?*IEnumReadyCallback) HRESULT {
                return @as(*const IEnumerableView.VTable, @ptrCast(self.vtable)).SetEnumReadyCallback(@as(*const IEnumerableView, @ptrCast(self)), percb);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumerableView_CreateEnumIDListFromContents(self: *const T, pidlFolder: ?*ITEMIDLIST, dwEnumFlags: u32, ppEnumIDList: ?*?*IEnumIDList) HRESULT {
                return @as(*const IEnumerableView.VTable, @ptrCast(self.vtable)).CreateEnumIDListFromContents(@as(*const IEnumerableView, @ptrCast(self)), pidlFolder, dwEnumFlags, ppEnumIDList);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IInsertItem_Value = Guid.initString("d2b57227-3d23-4b95-93c0-492bd454c356");
pub const IID_IInsertItem = &IID_IInsertItem_Value;
pub const IInsertItem = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        InsertItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInsertItem,
                pidl: ?*ITEMIDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInsertItem,
                pidl: ?*ITEMIDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInsertItem_InsertItem(self: *const T, pidl: ?*ITEMIDLIST) HRESULT {
                return @as(*const IInsertItem.VTable, @ptrCast(self.vtable)).InsertItem(@as(*const IInsertItem, @ptrCast(self)), pidl);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IFolderBandPriv_Value = Guid.initString("47c01f95-e185-412c-b5c5-4f27df965aea");
pub const IID_IFolderBandPriv = &IID_IFolderBandPriv_Value;
pub const IFolderBandPriv = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetCascade: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFolderBandPriv,
                fCascade: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFolderBandPriv,
                fCascade: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetAccelerators: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFolderBandPriv,
                fAccelerators: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFolderBandPriv,
                fAccelerators: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetNoIcons: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFolderBandPriv,
                fNoIcons: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFolderBandPriv,
                fNoIcons: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetNoText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFolderBandPriv,
                fNoText: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFolderBandPriv,
                fNoText: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFolderBandPriv_SetCascade(self: *const T, fCascade: BOOL) HRESULT {
                return @as(*const IFolderBandPriv.VTable, @ptrCast(self.vtable)).SetCascade(@as(*const IFolderBandPriv, @ptrCast(self)), fCascade);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFolderBandPriv_SetAccelerators(self: *const T, fAccelerators: BOOL) HRESULT {
                return @as(*const IFolderBandPriv.VTable, @ptrCast(self.vtable)).SetAccelerators(@as(*const IFolderBandPriv, @ptrCast(self)), fAccelerators);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFolderBandPriv_SetNoIcons(self: *const T, fNoIcons: BOOL) HRESULT {
                return @as(*const IFolderBandPriv.VTable, @ptrCast(self.vtable)).SetNoIcons(@as(*const IFolderBandPriv, @ptrCast(self)), fNoIcons);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFolderBandPriv_SetNoText(self: *const T, fNoText: BOOL) HRESULT {
                return @as(*const IFolderBandPriv.VTable, @ptrCast(self.vtable)).SetNoText(@as(*const IFolderBandPriv, @ptrCast(self)), fNoText);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IImageRecompress_Value = Guid.initString("505f1513-6b3e-4892-a272-59f8889a4d3e");
pub const IID_IImageRecompress = &IID_IImageRecompress_Value;
pub const IImageRecompress = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RecompressImage: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IImageRecompress,
                psi: ?*IShellItem,
                cx: i32,
                cy: i32,
                iQuality: i32,
                pstg: ?*IStorage,
                ppstrmOut: ?*?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IImageRecompress,
                psi: ?*IShellItem,
                cx: i32,
                cy: i32,
                iQuality: i32,
                pstg: ?*IStorage,
                ppstrmOut: ?*?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IImageRecompress_RecompressImage(self: *const T, psi: ?*IShellItem, cx: i32, cy: i32, iQuality: i32, pstg: ?*IStorage, ppstrmOut: ?*?*IStream) HRESULT {
                return @as(*const IImageRecompress.VTable, @ptrCast(self.vtable)).RecompressImage(@as(*const IImageRecompress, @ptrCast(self)), psi, cx, cy, iQuality, pstg, ppstrmOut);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IFileDialogControlEvents_Value = Guid.initString("36116642-d713-4b97-9b83-7484a9d00433");
pub const IID_IFileDialogControlEvents = &IID_IFileDialogControlEvents_Value;
pub const IFileDialogControlEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnItemSelected: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileDialogControlEvents,
                pfdc: ?*IFileDialogCustomize,
                dwIDCtl: u32,
                dwIDItem: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileDialogControlEvents,
                pfdc: ?*IFileDialogCustomize,
                dwIDCtl: u32,
                dwIDItem: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnButtonClicked: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileDialogControlEvents,
                pfdc: ?*IFileDialogCustomize,
                dwIDCtl: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileDialogControlEvents,
                pfdc: ?*IFileDialogCustomize,
                dwIDCtl: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnCheckButtonToggled: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileDialogControlEvents,
                pfdc: ?*IFileDialogCustomize,
                dwIDCtl: u32,
                bChecked: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileDialogControlEvents,
                pfdc: ?*IFileDialogCustomize,
                dwIDCtl: u32,
                bChecked: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnControlActivating: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileDialogControlEvents,
                pfdc: ?*IFileDialogCustomize,
                dwIDCtl: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileDialogControlEvents,
                pfdc: ?*IFileDialogCustomize,
                dwIDCtl: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileDialogControlEvents_OnItemSelected(self: *const T, pfdc: ?*IFileDialogCustomize, dwIDCtl: u32, dwIDItem: u32) HRESULT {
                return @as(*const IFileDialogControlEvents.VTable, @ptrCast(self.vtable)).OnItemSelected(@as(*const IFileDialogControlEvents, @ptrCast(self)), pfdc, dwIDCtl, dwIDItem);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileDialogControlEvents_OnButtonClicked(self: *const T, pfdc: ?*IFileDialogCustomize, dwIDCtl: u32) HRESULT {
                return @as(*const IFileDialogControlEvents.VTable, @ptrCast(self.vtable)).OnButtonClicked(@as(*const IFileDialogControlEvents, @ptrCast(self)), pfdc, dwIDCtl);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileDialogControlEvents_OnCheckButtonToggled(self: *const T, pfdc: ?*IFileDialogCustomize, dwIDCtl: u32, bChecked: BOOL) HRESULT {
                return @as(*const IFileDialogControlEvents.VTable, @ptrCast(self.vtable)).OnCheckButtonToggled(@as(*const IFileDialogControlEvents, @ptrCast(self)), pfdc, dwIDCtl, bChecked);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileDialogControlEvents_OnControlActivating(self: *const T, pfdc: ?*IFileDialogCustomize, dwIDCtl: u32) HRESULT {
                return @as(*const IFileDialogControlEvents.VTable, @ptrCast(self.vtable)).OnControlActivating(@as(*const IFileDialogControlEvents, @ptrCast(self)), pfdc, dwIDCtl);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IFileDialog2_Value = Guid.initString("61744fc7-85b5-4791-a9b0-272276309b13");
pub const IID_IFileDialog2 = &IID_IFileDialog2_Value;
pub const IFileDialog2 = extern struct {
    pub const VTable = extern struct {
        base: IFileDialog.VTable,
        SetCancelButtonLabel: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileDialog2,
                pszLabel: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileDialog2,
                pszLabel: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetNavigationRoot: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileDialog2,
                psi: ?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileDialog2,
                psi: ?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IFileDialog.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileDialog2_SetCancelButtonLabel(self: *const T, pszLabel: ?[*:0]const u16) HRESULT {
                return @as(*const IFileDialog2.VTable, @ptrCast(self.vtable)).SetCancelButtonLabel(@as(*const IFileDialog2, @ptrCast(self)), pszLabel);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileDialog2_SetNavigationRoot(self: *const T, psi: ?*IShellItem) HRESULT {
                return @as(*const IFileDialog2.VTable, @ptrCast(self.vtable)).SetNavigationRoot(@as(*const IFileDialog2, @ptrCast(self)), psi);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IApplicationAssociationRegistrationUI_Value = Guid.initString("1f76a169-f994-40ac-8fc8-0959e8874710");
pub const IID_IApplicationAssociationRegistrationUI = &IID_IApplicationAssociationRegistrationUI_Value;
pub const IApplicationAssociationRegistrationUI = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        LaunchAdvancedAssociationUI: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IApplicationAssociationRegistrationUI,
                pszAppRegistryName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IApplicationAssociationRegistrationUI,
                pszAppRegistryName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IApplicationAssociationRegistrationUI_LaunchAdvancedAssociationUI(self: *const T, pszAppRegistryName: ?[*:0]const u16) HRESULT {
                return @as(*const IApplicationAssociationRegistrationUI.VTable, @ptrCast(self.vtable)).LaunchAdvancedAssociationUI(@as(*const IApplicationAssociationRegistrationUI, @ptrCast(self)), pszAppRegistryName);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IShellRunDll_Value = Guid.initString("fce4bde0-4b68-4b80-8e9c-7426315a7388");
pub const IID_IShellRunDll = &IID_IShellRunDll_Value;
pub const IShellRunDll = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Run: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellRunDll,
                pszArgs: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellRunDll,
                pszArgs: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellRunDll_Run(self: *const T, pszArgs: ?[*:0]const u16) HRESULT {
                return @as(*const IShellRunDll.VTable, @ptrCast(self.vtable)).Run(@as(*const IShellRunDll, @ptrCast(self)), pszArgs);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IPreviousVersionsInfo_Value = Guid.initString("76e54780-ad74-48e3-a695-3ba9a0aff10d");
pub const IID_IPreviousVersionsInfo = &IID_IPreviousVersionsInfo_Value;
pub const IPreviousVersionsInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AreSnapshotsAvailable: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPreviousVersionsInfo,
                pszPath: ?[*:0]const u16,
                fOkToBeSlow: BOOL,
                pfAvailable: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPreviousVersionsInfo,
                pszPath: ?[*:0]const u16,
                fOkToBeSlow: BOOL,
                pfAvailable: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPreviousVersionsInfo_AreSnapshotsAvailable(self: *const T, pszPath: ?[*:0]const u16, fOkToBeSlow: BOOL, pfAvailable: ?*BOOL) HRESULT {
                return @as(*const IPreviousVersionsInfo.VTable, @ptrCast(self.vtable)).AreSnapshotsAvailable(@as(*const IPreviousVersionsInfo, @ptrCast(self)), pszPath, fOkToBeSlow, pfAvailable);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IUseToBrowseItem_Value = Guid.initString("05edda5c-98a3-4717-8adb-c5e7da991eb1");
pub const IID_IUseToBrowseItem = &IID_IUseToBrowseItem_Value;
pub const IUseToBrowseItem = extern struct {
    pub const VTable = extern struct {
        base: IRelatedItem.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IRelatedItem.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const NSTCSTYLE2 = enum(i32) {
    STCS2_DEFAULT = 0,
    STCS2_INTERRUPTNOTIFICATIONS = 1,
    STCS2_SHOWNULLSPACEMENU = 2,
    STCS2_DISPLAYPADDING = 4,
    STCS2_DISPLAYPINNEDONLY = 8,
    TSCS2_NOSINGLETONAUTOEXPAND = 16,
    TSCS2_NEVERINSERTNONENUMERATED = 32,
};
pub const NSTCS2_DEFAULT = NSTCSTYLE2.STCS2_DEFAULT;
pub const NSTCS2_INTERRUPTNOTIFICATIONS = NSTCSTYLE2.STCS2_INTERRUPTNOTIFICATIONS;
pub const NSTCS2_SHOWNULLSPACEMENU = NSTCSTYLE2.STCS2_SHOWNULLSPACEMENU;
pub const NSTCS2_DISPLAYPADDING = NSTCSTYLE2.STCS2_DISPLAYPADDING;
pub const NSTCS2_DISPLAYPINNEDONLY = NSTCSTYLE2.STCS2_DISPLAYPINNEDONLY;
pub const NTSCS2_NOSINGLETONAUTOEXPAND = NSTCSTYLE2.TSCS2_NOSINGLETONAUTOEXPAND;
pub const NTSCS2_NEVERINSERTNONENUMERATED = NSTCSTYLE2.TSCS2_NEVERINSERTNONENUMERATED;

// TODO: this type is limited to platform 'windows6.1'
const IID_INameSpaceTreeControl2_Value = Guid.initString("7cc7aed8-290e-49bc-8945-c1401cc9306c");
pub const IID_INameSpaceTreeControl2 = &IID_INameSpaceTreeControl2_Value;
pub const INameSpaceTreeControl2 = extern struct {
    pub const VTable = extern struct {
        base: INameSpaceTreeControl.VTable,
        SetControlStyle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INameSpaceTreeControl2,
                nstcsMask: u32,
                nstcsStyle: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INameSpaceTreeControl2,
                nstcsMask: u32,
                nstcsStyle: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetControlStyle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INameSpaceTreeControl2,
                nstcsMask: u32,
                pnstcsStyle: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INameSpaceTreeControl2,
                nstcsMask: u32,
                pnstcsStyle: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetControlStyle2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INameSpaceTreeControl2,
                nstcsMask: NSTCSTYLE2,
                nstcsStyle: NSTCSTYLE2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INameSpaceTreeControl2,
                nstcsMask: NSTCSTYLE2,
                nstcsStyle: NSTCSTYLE2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetControlStyle2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INameSpaceTreeControl2,
                nstcsMask: NSTCSTYLE2,
                pnstcsStyle: ?*NSTCSTYLE2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INameSpaceTreeControl2,
                nstcsMask: NSTCSTYLE2,
                pnstcsStyle: ?*NSTCSTYLE2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace INameSpaceTreeControl.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INameSpaceTreeControl2_SetControlStyle(self: *const T, nstcsMask: u32, nstcsStyle: u32) HRESULT {
                return @as(*const INameSpaceTreeControl2.VTable, @ptrCast(self.vtable)).SetControlStyle(@as(*const INameSpaceTreeControl2, @ptrCast(self)), nstcsMask, nstcsStyle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INameSpaceTreeControl2_GetControlStyle(self: *const T, nstcsMask: u32, pnstcsStyle: ?*u32) HRESULT {
                return @as(*const INameSpaceTreeControl2.VTable, @ptrCast(self.vtable)).GetControlStyle(@as(*const INameSpaceTreeControl2, @ptrCast(self)), nstcsMask, pnstcsStyle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INameSpaceTreeControl2_SetControlStyle2(self: *const T, nstcsMask: NSTCSTYLE2, nstcsStyle: NSTCSTYLE2) HRESULT {
                return @as(*const INameSpaceTreeControl2.VTable, @ptrCast(self.vtable)).SetControlStyle2(@as(*const INameSpaceTreeControl2, @ptrCast(self)), nstcsMask, nstcsStyle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INameSpaceTreeControl2_GetControlStyle2(self: *const T, nstcsMask: NSTCSTYLE2, pnstcsStyle: ?*NSTCSTYLE2) HRESULT {
                return @as(*const INameSpaceTreeControl2.VTable, @ptrCast(self.vtable)).GetControlStyle2(@as(*const INameSpaceTreeControl2, @ptrCast(self)), nstcsMask, pnstcsStyle);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const _NSTCEHITTEST = enum(i32) {
    NOWHERE = 1,
    ONITEMICON = 2,
    ONITEMLABEL = 4,
    ONITEMINDENT = 8,
    ONITEMBUTTON = 16,
    ONITEMRIGHT = 32,
    ONITEMSTATEICON = 64,
    ONITEM = 70,
    ONITEMTABBUTTON = 4096,
};
pub const NSTCEHT_NOWHERE = _NSTCEHITTEST.NOWHERE;
pub const NSTCEHT_ONITEMICON = _NSTCEHITTEST.ONITEMICON;
pub const NSTCEHT_ONITEMLABEL = _NSTCEHITTEST.ONITEMLABEL;
pub const NSTCEHT_ONITEMINDENT = _NSTCEHITTEST.ONITEMINDENT;
pub const NSTCEHT_ONITEMBUTTON = _NSTCEHITTEST.ONITEMBUTTON;
pub const NSTCEHT_ONITEMRIGHT = _NSTCEHITTEST.ONITEMRIGHT;
pub const NSTCEHT_ONITEMSTATEICON = _NSTCEHITTEST.ONITEMSTATEICON;
pub const NSTCEHT_ONITEM = _NSTCEHITTEST.ONITEM;
pub const NSTCEHT_ONITEMTABBUTTON = _NSTCEHITTEST.ONITEMTABBUTTON;

pub const _NSTCECLICKTYPE = enum(i32) {
    LBUTTON = 1,
    MBUTTON = 2,
    RBUTTON = 3,
    // BUTTON = 3, this enum value conflicts with RBUTTON
    DBLCLICK = 4,
};
pub const NSTCECT_LBUTTON = _NSTCECLICKTYPE.LBUTTON;
pub const NSTCECT_MBUTTON = _NSTCECLICKTYPE.MBUTTON;
pub const NSTCECT_RBUTTON = _NSTCECLICKTYPE.RBUTTON;
pub const NSTCECT_BUTTON = _NSTCECLICKTYPE.RBUTTON;
pub const NSTCECT_DBLCLICK = _NSTCECLICKTYPE.DBLCLICK;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_INameSpaceTreeControlEvents_Value = Guid.initString("93d77985-b3d8-4484-8318-672cdda002ce");
pub const IID_INameSpaceTreeControlEvents = &IID_INameSpaceTreeControlEvents_Value;
pub const INameSpaceTreeControlEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnItemClick: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INameSpaceTreeControlEvents,
                psi: ?*IShellItem,
                nstceHitTest: u32,
                nstceClickType: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INameSpaceTreeControlEvents,
                psi: ?*IShellItem,
                nstceHitTest: u32,
                nstceClickType: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnPropertyItemCommit: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INameSpaceTreeControlEvents,
                psi: ?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INameSpaceTreeControlEvents,
                psi: ?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnItemStateChanging: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INameSpaceTreeControlEvents,
                psi: ?*IShellItem,
                nstcisMask: u32,
                nstcisState: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INameSpaceTreeControlEvents,
                psi: ?*IShellItem,
                nstcisMask: u32,
                nstcisState: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnItemStateChanged: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INameSpaceTreeControlEvents,
                psi: ?*IShellItem,
                nstcisMask: u32,
                nstcisState: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INameSpaceTreeControlEvents,
                psi: ?*IShellItem,
                nstcisMask: u32,
                nstcisState: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnSelectionChanged: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INameSpaceTreeControlEvents,
                psiaSelection: ?*IShellItemArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INameSpaceTreeControlEvents,
                psiaSelection: ?*IShellItemArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnKeyboardInput: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INameSpaceTreeControlEvents,
                uMsg: u32,
                wParam: WPARAM,
                lParam: LPARAM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INameSpaceTreeControlEvents,
                uMsg: u32,
                wParam: WPARAM,
                lParam: LPARAM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnBeforeExpand: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INameSpaceTreeControlEvents,
                psi: ?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INameSpaceTreeControlEvents,
                psi: ?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnAfterExpand: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INameSpaceTreeControlEvents,
                psi: ?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INameSpaceTreeControlEvents,
                psi: ?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnBeginLabelEdit: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INameSpaceTreeControlEvents,
                psi: ?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INameSpaceTreeControlEvents,
                psi: ?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnEndLabelEdit: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INameSpaceTreeControlEvents,
                psi: ?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INameSpaceTreeControlEvents,
                psi: ?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnGetToolTip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INameSpaceTreeControlEvents,
                psi: ?*IShellItem,
                pszTip: [*:0]u16,
                cchTip: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INameSpaceTreeControlEvents,
                psi: ?*IShellItem,
                pszTip: [*:0]u16,
                cchTip: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnBeforeItemDelete: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INameSpaceTreeControlEvents,
                psi: ?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INameSpaceTreeControlEvents,
                psi: ?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnItemAdded: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INameSpaceTreeControlEvents,
                psi: ?*IShellItem,
                fIsRoot: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INameSpaceTreeControlEvents,
                psi: ?*IShellItem,
                fIsRoot: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnItemDeleted: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INameSpaceTreeControlEvents,
                psi: ?*IShellItem,
                fIsRoot: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INameSpaceTreeControlEvents,
                psi: ?*IShellItem,
                fIsRoot: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnBeforeContextMenu: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INameSpaceTreeControlEvents,
                psi: ?*IShellItem,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INameSpaceTreeControlEvents,
                psi: ?*IShellItem,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnAfterContextMenu: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INameSpaceTreeControlEvents,
                psi: ?*IShellItem,
                pcmIn: ?*IContextMenu,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INameSpaceTreeControlEvents,
                psi: ?*IShellItem,
                pcmIn: ?*IContextMenu,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnBeforeStateImageChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INameSpaceTreeControlEvents,
                psi: ?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INameSpaceTreeControlEvents,
                psi: ?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnGetDefaultIconIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INameSpaceTreeControlEvents,
                psi: ?*IShellItem,
                piDefaultIcon: ?*i32,
                piOpenIcon: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INameSpaceTreeControlEvents,
                psi: ?*IShellItem,
                piDefaultIcon: ?*i32,
                piOpenIcon: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INameSpaceTreeControlEvents_OnItemClick(self: *const T, psi: ?*IShellItem, nstceHitTest: u32, nstceClickType: u32) HRESULT {
                return @as(*const INameSpaceTreeControlEvents.VTable, @ptrCast(self.vtable)).OnItemClick(@as(*const INameSpaceTreeControlEvents, @ptrCast(self)), psi, nstceHitTest, nstceClickType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INameSpaceTreeControlEvents_OnPropertyItemCommit(self: *const T, psi: ?*IShellItem) HRESULT {
                return @as(*const INameSpaceTreeControlEvents.VTable, @ptrCast(self.vtable)).OnPropertyItemCommit(@as(*const INameSpaceTreeControlEvents, @ptrCast(self)), psi);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INameSpaceTreeControlEvents_OnItemStateChanging(self: *const T, psi: ?*IShellItem, nstcisMask: u32, nstcisState: u32) HRESULT {
                return @as(*const INameSpaceTreeControlEvents.VTable, @ptrCast(self.vtable)).OnItemStateChanging(@as(*const INameSpaceTreeControlEvents, @ptrCast(self)), psi, nstcisMask, nstcisState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INameSpaceTreeControlEvents_OnItemStateChanged(self: *const T, psi: ?*IShellItem, nstcisMask: u32, nstcisState: u32) HRESULT {
                return @as(*const INameSpaceTreeControlEvents.VTable, @ptrCast(self.vtable)).OnItemStateChanged(@as(*const INameSpaceTreeControlEvents, @ptrCast(self)), psi, nstcisMask, nstcisState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INameSpaceTreeControlEvents_OnSelectionChanged(self: *const T, psiaSelection: ?*IShellItemArray) HRESULT {
                return @as(*const INameSpaceTreeControlEvents.VTable, @ptrCast(self.vtable)).OnSelectionChanged(@as(*const INameSpaceTreeControlEvents, @ptrCast(self)), psiaSelection);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INameSpaceTreeControlEvents_OnKeyboardInput(self: *const T, uMsg: u32, wParam: WPARAM, lParam: LPARAM) HRESULT {
                return @as(*const INameSpaceTreeControlEvents.VTable, @ptrCast(self.vtable)).OnKeyboardInput(@as(*const INameSpaceTreeControlEvents, @ptrCast(self)), uMsg, wParam, lParam);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INameSpaceTreeControlEvents_OnBeforeExpand(self: *const T, psi: ?*IShellItem) HRESULT {
                return @as(*const INameSpaceTreeControlEvents.VTable, @ptrCast(self.vtable)).OnBeforeExpand(@as(*const INameSpaceTreeControlEvents, @ptrCast(self)), psi);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INameSpaceTreeControlEvents_OnAfterExpand(self: *const T, psi: ?*IShellItem) HRESULT {
                return @as(*const INameSpaceTreeControlEvents.VTable, @ptrCast(self.vtable)).OnAfterExpand(@as(*const INameSpaceTreeControlEvents, @ptrCast(self)), psi);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INameSpaceTreeControlEvents_OnBeginLabelEdit(self: *const T, psi: ?*IShellItem) HRESULT {
                return @as(*const INameSpaceTreeControlEvents.VTable, @ptrCast(self.vtable)).OnBeginLabelEdit(@as(*const INameSpaceTreeControlEvents, @ptrCast(self)), psi);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INameSpaceTreeControlEvents_OnEndLabelEdit(self: *const T, psi: ?*IShellItem) HRESULT {
                return @as(*const INameSpaceTreeControlEvents.VTable, @ptrCast(self.vtable)).OnEndLabelEdit(@as(*const INameSpaceTreeControlEvents, @ptrCast(self)), psi);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INameSpaceTreeControlEvents_OnGetToolTip(self: *const T, psi: ?*IShellItem, pszTip: [*:0]u16, cchTip: i32) HRESULT {
                return @as(*const INameSpaceTreeControlEvents.VTable, @ptrCast(self.vtable)).OnGetToolTip(@as(*const INameSpaceTreeControlEvents, @ptrCast(self)), psi, pszTip, cchTip);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INameSpaceTreeControlEvents_OnBeforeItemDelete(self: *const T, psi: ?*IShellItem) HRESULT {
                return @as(*const INameSpaceTreeControlEvents.VTable, @ptrCast(self.vtable)).OnBeforeItemDelete(@as(*const INameSpaceTreeControlEvents, @ptrCast(self)), psi);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INameSpaceTreeControlEvents_OnItemAdded(self: *const T, psi: ?*IShellItem, fIsRoot: BOOL) HRESULT {
                return @as(*const INameSpaceTreeControlEvents.VTable, @ptrCast(self.vtable)).OnItemAdded(@as(*const INameSpaceTreeControlEvents, @ptrCast(self)), psi, fIsRoot);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INameSpaceTreeControlEvents_OnItemDeleted(self: *const T, psi: ?*IShellItem, fIsRoot: BOOL) HRESULT {
                return @as(*const INameSpaceTreeControlEvents.VTable, @ptrCast(self.vtable)).OnItemDeleted(@as(*const INameSpaceTreeControlEvents, @ptrCast(self)), psi, fIsRoot);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INameSpaceTreeControlEvents_OnBeforeContextMenu(self: *const T, psi: ?*IShellItem, riid: ?*const Guid, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const INameSpaceTreeControlEvents.VTable, @ptrCast(self.vtable)).OnBeforeContextMenu(@as(*const INameSpaceTreeControlEvents, @ptrCast(self)), psi, riid, ppv);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INameSpaceTreeControlEvents_OnAfterContextMenu(self: *const T, psi: ?*IShellItem, pcmIn: ?*IContextMenu, riid: ?*const Guid, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const INameSpaceTreeControlEvents.VTable, @ptrCast(self.vtable)).OnAfterContextMenu(@as(*const INameSpaceTreeControlEvents, @ptrCast(self)), psi, pcmIn, riid, ppv);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INameSpaceTreeControlEvents_OnBeforeStateImageChange(self: *const T, psi: ?*IShellItem) HRESULT {
                return @as(*const INameSpaceTreeControlEvents.VTable, @ptrCast(self.vtable)).OnBeforeStateImageChange(@as(*const INameSpaceTreeControlEvents, @ptrCast(self)), psi);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INameSpaceTreeControlEvents_OnGetDefaultIconIndex(self: *const T, psi: ?*IShellItem, piDefaultIcon: ?*i32, piOpenIcon: ?*i32) HRESULT {
                return @as(*const INameSpaceTreeControlEvents.VTable, @ptrCast(self.vtable)).OnGetDefaultIconIndex(@as(*const INameSpaceTreeControlEvents, @ptrCast(self)), psi, piDefaultIcon, piOpenIcon);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_INameSpaceTreeControlDropHandler_Value = Guid.initString("f9c665d6-c2f2-4c19-bf33-8322d7352f51");
pub const IID_INameSpaceTreeControlDropHandler = &IID_INameSpaceTreeControlDropHandler_Value;
pub const INameSpaceTreeControlDropHandler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnDragEnter: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INameSpaceTreeControlDropHandler,
                psiOver: ?*IShellItem,
                psiaData: ?*IShellItemArray,
                fOutsideSource: BOOL,
                grfKeyState: u32,
                pdwEffect: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INameSpaceTreeControlDropHandler,
                psiOver: ?*IShellItem,
                psiaData: ?*IShellItemArray,
                fOutsideSource: BOOL,
                grfKeyState: u32,
                pdwEffect: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnDragOver: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INameSpaceTreeControlDropHandler,
                psiOver: ?*IShellItem,
                psiaData: ?*IShellItemArray,
                grfKeyState: u32,
                pdwEffect: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INameSpaceTreeControlDropHandler,
                psiOver: ?*IShellItem,
                psiaData: ?*IShellItemArray,
                grfKeyState: u32,
                pdwEffect: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnDragPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INameSpaceTreeControlDropHandler,
                psiOver: ?*IShellItem,
                psiaData: ?*IShellItemArray,
                iNewPosition: i32,
                iOldPosition: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INameSpaceTreeControlDropHandler,
                psiOver: ?*IShellItem,
                psiaData: ?*IShellItemArray,
                iNewPosition: i32,
                iOldPosition: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnDrop: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INameSpaceTreeControlDropHandler,
                psiOver: ?*IShellItem,
                psiaData: ?*IShellItemArray,
                iPosition: i32,
                grfKeyState: u32,
                pdwEffect: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INameSpaceTreeControlDropHandler,
                psiOver: ?*IShellItem,
                psiaData: ?*IShellItemArray,
                iPosition: i32,
                grfKeyState: u32,
                pdwEffect: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnDropPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INameSpaceTreeControlDropHandler,
                psiOver: ?*IShellItem,
                psiaData: ?*IShellItemArray,
                iNewPosition: i32,
                iOldPosition: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INameSpaceTreeControlDropHandler,
                psiOver: ?*IShellItem,
                psiaData: ?*IShellItemArray,
                iNewPosition: i32,
                iOldPosition: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnDragLeave: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INameSpaceTreeControlDropHandler,
                psiOver: ?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INameSpaceTreeControlDropHandler,
                psiOver: ?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INameSpaceTreeControlDropHandler_OnDragEnter(self: *const T, psiOver: ?*IShellItem, psiaData: ?*IShellItemArray, fOutsideSource: BOOL, grfKeyState: u32, pdwEffect: ?*u32) HRESULT {
                return @as(*const INameSpaceTreeControlDropHandler.VTable, @ptrCast(self.vtable)).OnDragEnter(@as(*const INameSpaceTreeControlDropHandler, @ptrCast(self)), psiOver, psiaData, fOutsideSource, grfKeyState, pdwEffect);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INameSpaceTreeControlDropHandler_OnDragOver(self: *const T, psiOver: ?*IShellItem, psiaData: ?*IShellItemArray, grfKeyState: u32, pdwEffect: ?*u32) HRESULT {
                return @as(*const INameSpaceTreeControlDropHandler.VTable, @ptrCast(self.vtable)).OnDragOver(@as(*const INameSpaceTreeControlDropHandler, @ptrCast(self)), psiOver, psiaData, grfKeyState, pdwEffect);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INameSpaceTreeControlDropHandler_OnDragPosition(self: *const T, psiOver: ?*IShellItem, psiaData: ?*IShellItemArray, iNewPosition: i32, iOldPosition: i32) HRESULT {
                return @as(*const INameSpaceTreeControlDropHandler.VTable, @ptrCast(self.vtable)).OnDragPosition(@as(*const INameSpaceTreeControlDropHandler, @ptrCast(self)), psiOver, psiaData, iNewPosition, iOldPosition);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INameSpaceTreeControlDropHandler_OnDrop(self: *const T, psiOver: ?*IShellItem, psiaData: ?*IShellItemArray, iPosition: i32, grfKeyState: u32, pdwEffect: ?*u32) HRESULT {
                return @as(*const INameSpaceTreeControlDropHandler.VTable, @ptrCast(self.vtable)).OnDrop(@as(*const INameSpaceTreeControlDropHandler, @ptrCast(self)), psiOver, psiaData, iPosition, grfKeyState, pdwEffect);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INameSpaceTreeControlDropHandler_OnDropPosition(self: *const T, psiOver: ?*IShellItem, psiaData: ?*IShellItemArray, iNewPosition: i32, iOldPosition: i32) HRESULT {
                return @as(*const INameSpaceTreeControlDropHandler.VTable, @ptrCast(self.vtable)).OnDropPosition(@as(*const INameSpaceTreeControlDropHandler, @ptrCast(self)), psiOver, psiaData, iNewPosition, iOldPosition);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INameSpaceTreeControlDropHandler_OnDragLeave(self: *const T, psiOver: ?*IShellItem) HRESULT {
                return @as(*const INameSpaceTreeControlDropHandler.VTable, @ptrCast(self.vtable)).OnDragLeave(@as(*const INameSpaceTreeControlDropHandler, @ptrCast(self)), psiOver);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_INameSpaceTreeAccessible_Value = Guid.initString("71f312de-43ed-4190-8477-e9536b82350b");
pub const IID_INameSpaceTreeAccessible = &IID_INameSpaceTreeAccessible_Value;
pub const INameSpaceTreeAccessible = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnGetDefaultAccessibilityAction: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INameSpaceTreeAccessible,
                psi: ?*IShellItem,
                pbstrDefaultAction: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INameSpaceTreeAccessible,
                psi: ?*IShellItem,
                pbstrDefaultAction: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnDoDefaultAccessibilityAction: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INameSpaceTreeAccessible,
                psi: ?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INameSpaceTreeAccessible,
                psi: ?*IShellItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnGetAccessibilityRole: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INameSpaceTreeAccessible,
                psi: ?*IShellItem,
                pvarRole: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INameSpaceTreeAccessible,
                psi: ?*IShellItem,
                pvarRole: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INameSpaceTreeAccessible_OnGetDefaultAccessibilityAction(self: *const T, psi: ?*IShellItem, pbstrDefaultAction: ?*?BSTR) HRESULT {
                return @as(*const INameSpaceTreeAccessible.VTable, @ptrCast(self.vtable)).OnGetDefaultAccessibilityAction(@as(*const INameSpaceTreeAccessible, @ptrCast(self)), psi, pbstrDefaultAction);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INameSpaceTreeAccessible_OnDoDefaultAccessibilityAction(self: *const T, psi: ?*IShellItem) HRESULT {
                return @as(*const INameSpaceTreeAccessible.VTable, @ptrCast(self.vtable)).OnDoDefaultAccessibilityAction(@as(*const INameSpaceTreeAccessible, @ptrCast(self)), psi);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INameSpaceTreeAccessible_OnGetAccessibilityRole(self: *const T, psi: ?*IShellItem, pvarRole: ?*VARIANT) HRESULT {
                return @as(*const INameSpaceTreeAccessible.VTable, @ptrCast(self.vtable)).OnGetAccessibilityRole(@as(*const INameSpaceTreeAccessible, @ptrCast(self)), psi, pvarRole);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const NSTCCUSTOMDRAW = extern struct {
    psi: ?*IShellItem,
    uItemState: u32,
    nstcis: u32,
    pszText: ?[*:0]const u16,
    iImage: i32,
    himl: ?HIMAGELIST,
    iLevel: i32,
    iIndent: i32,
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_INameSpaceTreeControlCustomDraw_Value = Guid.initString("2d3ba758-33ee-42d5-bb7b-5f3431d86c78");
pub const IID_INameSpaceTreeControlCustomDraw = &IID_INameSpaceTreeControlCustomDraw_Value;
pub const INameSpaceTreeControlCustomDraw = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        PrePaint: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INameSpaceTreeControlCustomDraw,
                hdc: ?HDC,
                prc: ?*RECT,
                plres: ?*LRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INameSpaceTreeControlCustomDraw,
                hdc: ?HDC,
                prc: ?*RECT,
                plres: ?*LRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PostPaint: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INameSpaceTreeControlCustomDraw,
                hdc: ?HDC,
                prc: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INameSpaceTreeControlCustomDraw,
                hdc: ?HDC,
                prc: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ItemPrePaint: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INameSpaceTreeControlCustomDraw,
                hdc: ?HDC,
                prc: ?*RECT,
                pnstccdItem: ?*NSTCCUSTOMDRAW,
                pclrText: ?*u32,
                pclrTextBk: ?*u32,
                plres: ?*LRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INameSpaceTreeControlCustomDraw,
                hdc: ?HDC,
                prc: ?*RECT,
                pnstccdItem: ?*NSTCCUSTOMDRAW,
                pclrText: ?*u32,
                pclrTextBk: ?*u32,
                plres: ?*LRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ItemPostPaint: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INameSpaceTreeControlCustomDraw,
                hdc: ?HDC,
                prc: ?*RECT,
                pnstccdItem: ?*NSTCCUSTOMDRAW,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INameSpaceTreeControlCustomDraw,
                hdc: ?HDC,
                prc: ?*RECT,
                pnstccdItem: ?*NSTCCUSTOMDRAW,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INameSpaceTreeControlCustomDraw_PrePaint(self: *const T, hdc: ?HDC, prc: ?*RECT, plres: ?*LRESULT) HRESULT {
                return @as(*const INameSpaceTreeControlCustomDraw.VTable, @ptrCast(self.vtable)).PrePaint(@as(*const INameSpaceTreeControlCustomDraw, @ptrCast(self)), hdc, prc, plres);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INameSpaceTreeControlCustomDraw_PostPaint(self: *const T, hdc: ?HDC, prc: ?*RECT) HRESULT {
                return @as(*const INameSpaceTreeControlCustomDraw.VTable, @ptrCast(self.vtable)).PostPaint(@as(*const INameSpaceTreeControlCustomDraw, @ptrCast(self)), hdc, prc);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INameSpaceTreeControlCustomDraw_ItemPrePaint(self: *const T, hdc: ?HDC, prc: ?*RECT, pnstccdItem: ?*NSTCCUSTOMDRAW, pclrText: ?*u32, pclrTextBk: ?*u32, plres: ?*LRESULT) HRESULT {
                return @as(*const INameSpaceTreeControlCustomDraw.VTable, @ptrCast(self.vtable)).ItemPrePaint(@as(*const INameSpaceTreeControlCustomDraw, @ptrCast(self)), hdc, prc, pnstccdItem, pclrText, pclrTextBk, plres);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INameSpaceTreeControlCustomDraw_ItemPostPaint(self: *const T, hdc: ?HDC, prc: ?*RECT, pnstccdItem: ?*NSTCCUSTOMDRAW) HRESULT {
                return @as(*const INameSpaceTreeControlCustomDraw.VTable, @ptrCast(self.vtable)).ItemPostPaint(@as(*const INameSpaceTreeControlCustomDraw, @ptrCast(self)), hdc, prc, pnstccdItem);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ITrayDeskBand_Value = Guid.initString("6d67e846-5b9c-4db8-9cbc-dde12f4254f1");
pub const IID_ITrayDeskBand = &IID_ITrayDeskBand_Value;
pub const ITrayDeskBand = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ShowDeskBand: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITrayDeskBand,
                clsid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITrayDeskBand,
                clsid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        HideDeskBand: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITrayDeskBand,
                clsid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITrayDeskBand,
                clsid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsDeskBandShown: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITrayDeskBand,
                clsid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITrayDeskBand,
                clsid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeskBandRegistrationChanged: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITrayDeskBand,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITrayDeskBand,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITrayDeskBand_ShowDeskBand(self: *const T, clsid: ?*const Guid) HRESULT {
                return @as(*const ITrayDeskBand.VTable, @ptrCast(self.vtable)).ShowDeskBand(@as(*const ITrayDeskBand, @ptrCast(self)), clsid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITrayDeskBand_HideDeskBand(self: *const T, clsid: ?*const Guid) HRESULT {
                return @as(*const ITrayDeskBand.VTable, @ptrCast(self.vtable)).HideDeskBand(@as(*const ITrayDeskBand, @ptrCast(self)), clsid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITrayDeskBand_IsDeskBandShown(self: *const T, clsid: ?*const Guid) HRESULT {
                return @as(*const ITrayDeskBand.VTable, @ptrCast(self.vtable)).IsDeskBandShown(@as(*const ITrayDeskBand, @ptrCast(self)), clsid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITrayDeskBand_DeskBandRegistrationChanged(self: *const T) HRESULT {
                return @as(*const ITrayDeskBand.VTable, @ptrCast(self.vtable)).DeskBandRegistrationChanged(@as(*const ITrayDeskBand, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IBandHost_Value = Guid.initString("b9075c7c-d48e-403f-ab99-d6c77a1084ac");
pub const IID_IBandHost = &IID_IBandHost_Value;
pub const IBandHost = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateBand: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBandHost,
                rclsidBand: ?*const Guid,
                fAvailable: BOOL,
                fVisible: BOOL,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBandHost,
                rclsidBand: ?*const Guid,
                fAvailable: BOOL,
                fVisible: BOOL,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetBandAvailability: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBandHost,
                rclsidBand: ?*const Guid,
                fAvailable: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBandHost,
                rclsidBand: ?*const Guid,
                fAvailable: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DestroyBand: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBandHost,
                rclsidBand: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBandHost,
                rclsidBand: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBandHost_CreateBand(self: *const T, rclsidBand: ?*const Guid, fAvailable: BOOL, fVisible: BOOL, riid: ?*const Guid, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const IBandHost.VTable, @ptrCast(self.vtable)).CreateBand(@as(*const IBandHost, @ptrCast(self)), rclsidBand, fAvailable, fVisible, riid, ppv);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBandHost_SetBandAvailability(self: *const T, rclsidBand: ?*const Guid, fAvailable: BOOL) HRESULT {
                return @as(*const IBandHost.VTable, @ptrCast(self.vtable)).SetBandAvailability(@as(*const IBandHost, @ptrCast(self)), rclsidBand, fAvailable);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBandHost_DestroyBand(self: *const T, rclsidBand: ?*const Guid) HRESULT {
                return @as(*const IBandHost.VTable, @ptrCast(self.vtable)).DestroyBand(@as(*const IBandHost, @ptrCast(self)), rclsidBand);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IComputerInfoChangeNotify_Value = Guid.initString("0df60d92-6818-46d6-b358-d66170dde466");
pub const IID_IComputerInfoChangeNotify = &IID_IComputerInfoChangeNotify_Value;
pub const IComputerInfoChangeNotify = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ComputerInfoChanged: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IComputerInfoChangeNotify,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IComputerInfoChangeNotify,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IComputerInfoChangeNotify_ComputerInfoChanged(self: *const T) HRESULT {
                return @as(*const IComputerInfoChangeNotify.VTable, @ptrCast(self.vtable)).ComputerInfoChanged(@as(*const IComputerInfoChangeNotify, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IDesktopGadget_Value = Guid.initString("c1646bc4-f298-4f91-a204-eb2dd1709d1a");
pub const IID_IDesktopGadget = &IID_IDesktopGadget_Value;
pub const IDesktopGadget = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RunGadget: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDesktopGadget,
                gadgetPath: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDesktopGadget,
                gadgetPath: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDesktopGadget_RunGadget(self: *const T, gadgetPath: ?[*:0]const u16) HRESULT {
                return @as(*const IDesktopGadget.VTable, @ptrCast(self.vtable)).RunGadget(@as(*const IDesktopGadget, @ptrCast(self)), gadgetPath);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const UNDOCK_REASON = enum(i32) {
    RESOLUTION_CHANGE = 0,
    MONITOR_DISCONNECT = 1,
};
pub const UR_RESOLUTION_CHANGE = UNDOCK_REASON.RESOLUTION_CHANGE;
pub const UR_MONITOR_DISCONNECT = UNDOCK_REASON.MONITOR_DISCONNECT;

const IID_IAccessibilityDockingServiceCallback_Value = Guid.initString("157733fd-a592-42e5-b594-248468c5a81b");
pub const IID_IAccessibilityDockingServiceCallback = &IID_IAccessibilityDockingServiceCallback_Value;
pub const IAccessibilityDockingServiceCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Undocked: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAccessibilityDockingServiceCallback,
                undockReason: UNDOCK_REASON,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAccessibilityDockingServiceCallback,
                undockReason: UNDOCK_REASON,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAccessibilityDockingServiceCallback_Undocked(self: *const T, undockReason: UNDOCK_REASON) HRESULT {
                return @as(*const IAccessibilityDockingServiceCallback.VTable, @ptrCast(self.vtable)).Undocked(@as(*const IAccessibilityDockingServiceCallback, @ptrCast(self)), undockReason);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IAccessibilityDockingService_Value = Guid.initString("8849dc22-cedf-4c95-998d-051419dd3f76");
pub const IID_IAccessibilityDockingService = &IID_IAccessibilityDockingService_Value;
pub const IAccessibilityDockingService = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetAvailableSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAccessibilityDockingService,
                hMonitor: ?HMONITOR,
                pcxFixed: ?*u32,
                pcyMax: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAccessibilityDockingService,
                hMonitor: ?HMONITOR,
                pcxFixed: ?*u32,
                pcyMax: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DockWindow: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAccessibilityDockingService,
                hwnd: ?HWND,
                hMonitor: ?HMONITOR,
                cyRequested: u32,
                pCallback: ?*IAccessibilityDockingServiceCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAccessibilityDockingService,
                hwnd: ?HWND,
                hMonitor: ?HMONITOR,
                cyRequested: u32,
                pCallback: ?*IAccessibilityDockingServiceCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UndockWindow: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAccessibilityDockingService,
                hwnd: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAccessibilityDockingService,
                hwnd: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAccessibilityDockingService_GetAvailableSize(self: *const T, hMonitor: ?HMONITOR, pcxFixed: ?*u32, pcyMax: ?*u32) HRESULT {
                return @as(*const IAccessibilityDockingService.VTable, @ptrCast(self.vtable)).GetAvailableSize(@as(*const IAccessibilityDockingService, @ptrCast(self)), hMonitor, pcxFixed, pcyMax);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAccessibilityDockingService_DockWindow(self: *const T, hwnd: ?HWND, hMonitor: ?HMONITOR, cyRequested: u32, pCallback: ?*IAccessibilityDockingServiceCallback) HRESULT {
                return @as(*const IAccessibilityDockingService.VTable, @ptrCast(self.vtable)).DockWindow(@as(*const IAccessibilityDockingService, @ptrCast(self)), hwnd, hMonitor, cyRequested, pCallback);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAccessibilityDockingService_UndockWindow(self: *const T, hwnd: ?HWND) HRESULT {
                return @as(*const IAccessibilityDockingService.VTable, @ptrCast(self.vtable)).UndockWindow(@as(*const IAccessibilityDockingService, @ptrCast(self)), hwnd);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IStorageProviderBanners_Value = Guid.initString("5efb46d7-47c0-4b68-acda-ded47c90ec91");
pub const IID_IStorageProviderBanners = &IID_IStorageProviderBanners_Value;
pub const IStorageProviderBanners = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetBanner: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IStorageProviderBanners,
                providerIdentity: ?[*:0]const u16,
                subscriptionId: ?[*:0]const u16,
                contentId: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IStorageProviderBanners,
                providerIdentity: ?[*:0]const u16,
                subscriptionId: ?[*:0]const u16,
                contentId: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ClearBanner: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IStorageProviderBanners,
                providerIdentity: ?[*:0]const u16,
                subscriptionId: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IStorageProviderBanners,
                providerIdentity: ?[*:0]const u16,
                subscriptionId: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ClearAllBanners: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IStorageProviderBanners,
                providerIdentity: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IStorageProviderBanners,
                providerIdentity: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBanner: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IStorageProviderBanners,
                providerIdentity: ?[*:0]const u16,
                subscriptionId: ?[*:0]const u16,
                contentId: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IStorageProviderBanners,
                providerIdentity: ?[*:0]const u16,
                subscriptionId: ?[*:0]const u16,
                contentId: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IStorageProviderBanners_SetBanner(self: *const T, providerIdentity: ?[*:0]const u16, subscriptionId: ?[*:0]const u16, contentId: ?[*:0]const u16) HRESULT {
                return @as(*const IStorageProviderBanners.VTable, @ptrCast(self.vtable)).SetBanner(@as(*const IStorageProviderBanners, @ptrCast(self)), providerIdentity, subscriptionId, contentId);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IStorageProviderBanners_ClearBanner(self: *const T, providerIdentity: ?[*:0]const u16, subscriptionId: ?[*:0]const u16) HRESULT {
                return @as(*const IStorageProviderBanners.VTable, @ptrCast(self.vtable)).ClearBanner(@as(*const IStorageProviderBanners, @ptrCast(self)), providerIdentity, subscriptionId);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IStorageProviderBanners_ClearAllBanners(self: *const T, providerIdentity: ?[*:0]const u16) HRESULT {
                return @as(*const IStorageProviderBanners.VTable, @ptrCast(self.vtable)).ClearAllBanners(@as(*const IStorageProviderBanners, @ptrCast(self)), providerIdentity);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IStorageProviderBanners_GetBanner(self: *const T, providerIdentity: ?[*:0]const u16, subscriptionId: ?[*:0]const u16, contentId: ?*?PWSTR) HRESULT {
                return @as(*const IStorageProviderBanners.VTable, @ptrCast(self.vtable)).GetBanner(@as(*const IStorageProviderBanners, @ptrCast(self)), providerIdentity, subscriptionId, contentId);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IStorageProviderCopyHook_Value = Guid.initString("7bf992a9-af7a-4dba-b2e5-4d080b1ecbc6");
pub const IID_IStorageProviderCopyHook = &IID_IStorageProviderCopyHook_Value;
pub const IStorageProviderCopyHook = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CopyCallback: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IStorageProviderCopyHook,
                hwnd: ?HWND,
                operation: u32,
                flags: u32,
                srcFile: ?[*:0]const u16,
                srcAttribs: u32,
                destFile: ?[*:0]const u16,
                destAttribs: u32,
                result: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IStorageProviderCopyHook,
                hwnd: ?HWND,
                operation: u32,
                flags: u32,
                srcFile: ?[*:0]const u16,
                srcAttribs: u32,
                destFile: ?[*:0]const u16,
                destAttribs: u32,
                result: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IStorageProviderCopyHook_CopyCallback(self: *const T, hwnd: ?HWND, operation: u32, flags: u32, srcFile: ?[*:0]const u16, srcAttribs: u32, destFile: ?[*:0]const u16, destAttribs: u32, result: ?*u32) HRESULT {
                return @as(*const IStorageProviderCopyHook.VTable, @ptrCast(self.vtable)).CopyCallback(@as(*const IStorageProviderCopyHook, @ptrCast(self)), hwnd, operation, flags, srcFile, srcAttribs, destFile, destAttribs, result);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const CLSID_WebBrowser_V1_Value = Guid.initString("eab22ac3-30c1-11cf-a7eb-0000c05bae0b");
pub const CLSID_WebBrowser_V1 = &CLSID_WebBrowser_V1_Value;

const CLSID_WebBrowser_Value = Guid.initString("8856f961-340a-11d0-a96b-00c04fd705a2");
pub const CLSID_WebBrowser = &CLSID_WebBrowser_Value;

const CLSID_InternetExplorer_Value = Guid.initString("0002df01-0000-0000-c000-000000000046");
pub const CLSID_InternetExplorer = &CLSID_InternetExplorer_Value;

const CLSID_InternetExplorerMedium_Value = Guid.initString("d5e8041d-920f-45e9-b8fb-b1deb82c6e5e");
pub const CLSID_InternetExplorerMedium = &CLSID_InternetExplorerMedium_Value;

const CLSID_ShellBrowserWindow_Value = Guid.initString("c08afd90-f2a1-11d1-8455-00a0c91f3880");
pub const CLSID_ShellBrowserWindow = &CLSID_ShellBrowserWindow_Value;

const CLSID_ShellWindows_Value = Guid.initString("9ba05972-f6a8-11cf-a442-00a0c90a8f39");
pub const CLSID_ShellWindows = &CLSID_ShellWindows_Value;

const CLSID_ShellUIHelper_Value = Guid.initString("64ab4bb7-111e-11d1-8f79-00c04fc2fbe1");
pub const CLSID_ShellUIHelper = &CLSID_ShellUIHelper_Value;

const CLSID_ShellNameSpace_Value = Guid.initString("55136805-b2de-11d1-b9f2-00a0c98bc547");
pub const CLSID_ShellNameSpace = &CLSID_ShellNameSpace_Value;

const CLSID_CScriptErrorList_Value = Guid.initString("efd01300-160f-11d2-bb2e-00805ff7efca");
pub const CLSID_CScriptErrorList = &CLSID_CScriptErrorList_Value;

pub const CommandStateChangeConstants = enum(i32) {
    UPDATECOMMANDS = -1,
    NAVIGATEFORWARD = 1,
    NAVIGATEBACK = 2,
};
pub const CSC_UPDATECOMMANDS = CommandStateChangeConstants.UPDATECOMMANDS;
pub const CSC_NAVIGATEFORWARD = CommandStateChangeConstants.NAVIGATEFORWARD;
pub const CSC_NAVIGATEBACK = CommandStateChangeConstants.NAVIGATEBACK;

pub const SecureLockIconConstants = enum(i32) {
    Unsecure = 0,
    Mixed = 1,
    SecureUnknownBits = 2,
    Secure40Bit = 3,
    Secure56Bit = 4,
    SecureFortezza = 5,
    Secure128Bit = 6,
};
pub const secureLockIconUnsecure = SecureLockIconConstants.Unsecure;
pub const secureLockIconMixed = SecureLockIconConstants.Mixed;
pub const secureLockIconSecureUnknownBits = SecureLockIconConstants.SecureUnknownBits;
pub const secureLockIconSecure40Bit = SecureLockIconConstants.Secure40Bit;
pub const secureLockIconSecure56Bit = SecureLockIconConstants.Secure56Bit;
pub const secureLockIconSecureFortezza = SecureLockIconConstants.SecureFortezza;
pub const secureLockIconSecure128Bit = SecureLockIconConstants.Secure128Bit;

pub const NewProcessCauseConstants = enum(i32) {
    t = 1,
};
pub const ProtectedModeRedirect = NewProcessCauseConstants.t;

pub const ShellWindowTypeConstants = enum(i32) {
    EXPLORER = 0,
    BROWSER = 1,
    @"3RDPARTY" = 2,
    CALLBACK = 4,
    DESKTOP = 8,
};
pub const SWC_EXPLORER = ShellWindowTypeConstants.EXPLORER;
pub const SWC_BROWSER = ShellWindowTypeConstants.BROWSER;
pub const SWC_3RDPARTY = ShellWindowTypeConstants.@"3RDPARTY";
pub const SWC_CALLBACK = ShellWindowTypeConstants.CALLBACK;
pub const SWC_DESKTOP = ShellWindowTypeConstants.DESKTOP;

pub const ShellWindowFindWindowOptions = enum(i32) {
    NEEDDISPATCH = 1,
    INCLUDEPENDING = 2,
    COOKIEPASSED = 4,
};
pub const SWFO_NEEDDISPATCH = ShellWindowFindWindowOptions.NEEDDISPATCH;
pub const SWFO_INCLUDEPENDING = ShellWindowFindWindowOptions.INCLUDEPENDING;
pub const SWFO_COOKIEPASSED = ShellWindowFindWindowOptions.COOKIEPASSED;

pub const BrowserNavConstants = enum(i32) {
    OpenInNewWindow = 1,
    NoHistory = 2,
    NoReadFromCache = 4,
    NoWriteToCache = 8,
    AllowAutosearch = 16,
    BrowserBar = 32,
    Hyperlink = 64,
    EnforceRestricted = 128,
    NewWindowsManaged = 256,
    UntrustedForDownload = 512,
    TrustedForActiveX = 1024,
    OpenInNewTab = 2048,
    OpenInBackgroundTab = 4096,
    KeepWordWheelText = 8192,
    VirtualTab = 16384,
    BlockRedirectsXDomain = 32768,
    OpenNewForegroundTab = 65536,
    TravelLogScreenshot = 131072,
    DeferUnload = 262144,
    Speculative = 524288,
    SuggestNewWindow = 1048576,
    SuggestNewTab = 2097152,
    Reserved1 = 4194304,
    HomepageNavigate = 8388608,
    Refresh = 16777216,
    HostNavigation = 33554432,
    Reserved2 = 67108864,
    Reserved3 = 134217728,
    Reserved4 = 268435456,
    Reserved5 = 536870912,
    Reserved6 = 1073741824,
    Reserved7 = -2147483648,
};
pub const navOpenInNewWindow = BrowserNavConstants.OpenInNewWindow;
pub const navNoHistory = BrowserNavConstants.NoHistory;
pub const navNoReadFromCache = BrowserNavConstants.NoReadFromCache;
pub const navNoWriteToCache = BrowserNavConstants.NoWriteToCache;
pub const navAllowAutosearch = BrowserNavConstants.AllowAutosearch;
pub const navBrowserBar = BrowserNavConstants.BrowserBar;
pub const navHyperlink = BrowserNavConstants.Hyperlink;
pub const navEnforceRestricted = BrowserNavConstants.EnforceRestricted;
pub const navNewWindowsManaged = BrowserNavConstants.NewWindowsManaged;
pub const navUntrustedForDownload = BrowserNavConstants.UntrustedForDownload;
pub const navTrustedForActiveX = BrowserNavConstants.TrustedForActiveX;
pub const navOpenInNewTab = BrowserNavConstants.OpenInNewTab;
pub const navOpenInBackgroundTab = BrowserNavConstants.OpenInBackgroundTab;
pub const navKeepWordWheelText = BrowserNavConstants.KeepWordWheelText;
pub const navVirtualTab = BrowserNavConstants.VirtualTab;
pub const navBlockRedirectsXDomain = BrowserNavConstants.BlockRedirectsXDomain;
pub const navOpenNewForegroundTab = BrowserNavConstants.OpenNewForegroundTab;
pub const navTravelLogScreenshot = BrowserNavConstants.TravelLogScreenshot;
pub const navDeferUnload = BrowserNavConstants.DeferUnload;
pub const navSpeculative = BrowserNavConstants.Speculative;
pub const navSuggestNewWindow = BrowserNavConstants.SuggestNewWindow;
pub const navSuggestNewTab = BrowserNavConstants.SuggestNewTab;
pub const navReserved1 = BrowserNavConstants.Reserved1;
pub const navHomepageNavigate = BrowserNavConstants.HomepageNavigate;
pub const navRefresh = BrowserNavConstants.Refresh;
pub const navHostNavigation = BrowserNavConstants.HostNavigation;
pub const navReserved2 = BrowserNavConstants.Reserved2;
pub const navReserved3 = BrowserNavConstants.Reserved3;
pub const navReserved4 = BrowserNavConstants.Reserved4;
pub const navReserved5 = BrowserNavConstants.Reserved5;
pub const navReserved6 = BrowserNavConstants.Reserved6;
pub const navReserved7 = BrowserNavConstants.Reserved7;

pub const RefreshConstants = enum(i32) {
    NORMAL = 0,
    IFEXPIRED = 1,
    COMPLETELY = 3,
};
pub const REFRESH_NORMAL = RefreshConstants.NORMAL;
pub const REFRESH_IFEXPIRED = RefreshConstants.IFEXPIRED;
pub const REFRESH_COMPLETELY = RefreshConstants.COMPLETELY;

const IID_IWebBrowser_Value = Guid.initString("eab22ac1-30c1-11cf-a7eb-0000c05bae0b");
pub const IID_IWebBrowser = &IID_IWebBrowser_Value;
pub const IWebBrowser = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        GoBack: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWebBrowser,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWebBrowser,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GoForward: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWebBrowser,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWebBrowser,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GoHome: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWebBrowser,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWebBrowser,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GoSearch: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWebBrowser,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWebBrowser,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Navigate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWebBrowser,
                URL: ?BSTR,
                Flags: ?*VARIANT,
                TargetFrameName: ?*VARIANT,
                PostData: ?*VARIANT,
                Headers: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWebBrowser,
                URL: ?BSTR,
                Flags: ?*VARIANT,
                TargetFrameName: ?*VARIANT,
                PostData: ?*VARIANT,
                Headers: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Refresh: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWebBrowser,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWebBrowser,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Refresh2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWebBrowser,
                Level: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWebBrowser,
                Level: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Stop: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWebBrowser,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWebBrowser,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Application: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWebBrowser,
                ppDisp: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWebBrowser,
                ppDisp: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Parent: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWebBrowser,
                ppDisp: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWebBrowser,
                ppDisp: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Container: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWebBrowser,
                ppDisp: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWebBrowser,
                ppDisp: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Document: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWebBrowser,
                ppDisp: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWebBrowser,
                ppDisp: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TopLevelContainer: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWebBrowser,
                pBool: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWebBrowser,
                pBool: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Type: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWebBrowser,
                Type: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWebBrowser,
                Type: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Left: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWebBrowser,
                pl: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWebBrowser,
                pl: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Left: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWebBrowser,
                Left: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWebBrowser,
                Left: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Top: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWebBrowser,
                pl: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWebBrowser,
                pl: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Top: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWebBrowser,
                Top: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWebBrowser,
                Top: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Width: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWebBrowser,
                pl: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWebBrowser,
                pl: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Width: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWebBrowser,
                Width: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWebBrowser,
                Width: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Height: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWebBrowser,
                pl: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWebBrowser,
                pl: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Height: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWebBrowser,
                Height: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWebBrowser,
                Height: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LocationName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWebBrowser,
                LocationName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWebBrowser,
                LocationName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LocationURL: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWebBrowser,
                LocationURL: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWebBrowser,
                LocationURL: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Busy: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWebBrowser,
                pBool: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWebBrowser,
                pBool: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWebBrowser_GoBack(self: *const T) HRESULT {
                return @as(*const IWebBrowser.VTable, @ptrCast(self.vtable)).GoBack(@as(*const IWebBrowser, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWebBrowser_GoForward(self: *const T) HRESULT {
                return @as(*const IWebBrowser.VTable, @ptrCast(self.vtable)).GoForward(@as(*const IWebBrowser, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWebBrowser_GoHome(self: *const T) HRESULT {
                return @as(*const IWebBrowser.VTable, @ptrCast(self.vtable)).GoHome(@as(*const IWebBrowser, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWebBrowser_GoSearch(self: *const T) HRESULT {
                return @as(*const IWebBrowser.VTable, @ptrCast(self.vtable)).GoSearch(@as(*const IWebBrowser, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWebBrowser_Navigate(self: *const T, URL: ?BSTR, Flags: ?*VARIANT, TargetFrameName: ?*VARIANT, PostData: ?*VARIANT, Headers: ?*VARIANT) HRESULT {
                return @as(*const IWebBrowser.VTable, @ptrCast(self.vtable)).Navigate(@as(*const IWebBrowser, @ptrCast(self)), URL, Flags, TargetFrameName, PostData, Headers);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWebBrowser_Refresh(self: *const T) HRESULT {
                return @as(*const IWebBrowser.VTable, @ptrCast(self.vtable)).Refresh(@as(*const IWebBrowser, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWebBrowser_Refresh2(self: *const T, Level: ?*VARIANT) HRESULT {
                return @as(*const IWebBrowser.VTable, @ptrCast(self.vtable)).Refresh2(@as(*const IWebBrowser, @ptrCast(self)), Level);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWebBrowser_Stop(self: *const T) HRESULT {
                return @as(*const IWebBrowser.VTable, @ptrCast(self.vtable)).Stop(@as(*const IWebBrowser, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWebBrowser_get_Application(self: *const T, ppDisp: ?*?*IDispatch) HRESULT {
                return @as(*const IWebBrowser.VTable, @ptrCast(self.vtable)).get_Application(@as(*const IWebBrowser, @ptrCast(self)), ppDisp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWebBrowser_get_Parent(self: *const T, ppDisp: ?*?*IDispatch) HRESULT {
                return @as(*const IWebBrowser.VTable, @ptrCast(self.vtable)).get_Parent(@as(*const IWebBrowser, @ptrCast(self)), ppDisp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWebBrowser_get_Container(self: *const T, ppDisp: ?*?*IDispatch) HRESULT {
                return @as(*const IWebBrowser.VTable, @ptrCast(self.vtable)).get_Container(@as(*const IWebBrowser, @ptrCast(self)), ppDisp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWebBrowser_get_Document(self: *const T, ppDisp: ?*?*IDispatch) HRESULT {
                return @as(*const IWebBrowser.VTable, @ptrCast(self.vtable)).get_Document(@as(*const IWebBrowser, @ptrCast(self)), ppDisp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWebBrowser_get_TopLevelContainer(self: *const T, pBool: ?*i16) HRESULT {
                return @as(*const IWebBrowser.VTable, @ptrCast(self.vtable)).get_TopLevelContainer(@as(*const IWebBrowser, @ptrCast(self)), pBool);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWebBrowser_get_Type(self: *const T, Type: ?*?BSTR) HRESULT {
                return @as(*const IWebBrowser.VTable, @ptrCast(self.vtable)).get_Type(@as(*const IWebBrowser, @ptrCast(self)), Type);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWebBrowser_get_Left(self: *const T, pl: ?*i32) HRESULT {
                return @as(*const IWebBrowser.VTable, @ptrCast(self.vtable)).get_Left(@as(*const IWebBrowser, @ptrCast(self)), pl);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWebBrowser_put_Left(self: *const T, Left: i32) HRESULT {
                return @as(*const IWebBrowser.VTable, @ptrCast(self.vtable)).put_Left(@as(*const IWebBrowser, @ptrCast(self)), Left);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWebBrowser_get_Top(self: *const T, pl: ?*i32) HRESULT {
                return @as(*const IWebBrowser.VTable, @ptrCast(self.vtable)).get_Top(@as(*const IWebBrowser, @ptrCast(self)), pl);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWebBrowser_put_Top(self: *const T, Top: i32) HRESULT {
                return @as(*const IWebBrowser.VTable, @ptrCast(self.vtable)).put_Top(@as(*const IWebBrowser, @ptrCast(self)), Top);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWebBrowser_get_Width(self: *const T, pl: ?*i32) HRESULT {
                return @as(*const IWebBrowser.VTable, @ptrCast(self.vtable)).get_Width(@as(*const IWebBrowser, @ptrCast(self)), pl);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWebBrowser_put_Width(self: *const T, Width: i32) HRESULT {
                return @as(*const IWebBrowser.VTable, @ptrCast(self.vtable)).put_Width(@as(*const IWebBrowser, @ptrCast(self)), Width);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWebBrowser_get_Height(self: *const T, pl: ?*i32) HRESULT {
                return @as(*const IWebBrowser.VTable, @ptrCast(self.vtable)).get_Height(@as(*const IWebBrowser, @ptrCast(self)), pl);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWebBrowser_put_Height(self: *const T, Height: i32) HRESULT {
                return @as(*const IWebBrowser.VTable, @ptrCast(self.vtable)).put_Height(@as(*const IWebBrowser, @ptrCast(self)), Height);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWebBrowser_get_LocationName(self: *const T, LocationName: ?*?BSTR) HRESULT {
                return @as(*const IWebBrowser.VTable, @ptrCast(self.vtable)).get_LocationName(@as(*const IWebBrowser, @ptrCast(self)), LocationName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWebBrowser_get_LocationURL(self: *const T, LocationURL: ?*?BSTR) HRESULT {
                return @as(*const IWebBrowser.VTable, @ptrCast(self.vtable)).get_LocationURL(@as(*const IWebBrowser, @ptrCast(self)), LocationURL);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWebBrowser_get_Busy(self: *const T, pBool: ?*i16) HRESULT {
                return @as(*const IWebBrowser.VTable, @ptrCast(self.vtable)).get_Busy(@as(*const IWebBrowser, @ptrCast(self)), pBool);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_DWebBrowserEvents_Value = Guid.initString("eab22ac2-30c1-11cf-a7eb-0000c05bae0b");
pub const IID_DWebBrowserEvents = &IID_DWebBrowserEvents_Value;
pub const DWebBrowserEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWebBrowserApp_Value = Guid.initString("0002df05-0000-0000-c000-000000000046");
pub const IID_IWebBrowserApp = &IID_IWebBrowserApp_Value;
pub const IWebBrowserApp = extern struct {
    pub const VTable = extern struct {
        base: IWebBrowser.VTable,
        Quit: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWebBrowserApp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWebBrowserApp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ClientToWindow: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWebBrowserApp,
                pcx: ?*i32,
                pcy: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWebBrowserApp,
                pcx: ?*i32,
                pcy: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PutProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWebBrowserApp,
                Property: ?BSTR,
                vtValue: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWebBrowserApp,
                Property: ?BSTR,
                vtValue: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWebBrowserApp,
                Property: ?BSTR,
                pvtValue: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWebBrowserApp,
                Property: ?BSTR,
                pvtValue: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWebBrowserApp,
                Name: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWebBrowserApp,
                Name: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HWND: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWebBrowserApp,
                pHWND: ?*SHANDLE_PTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWebBrowserApp,
                pHWND: ?*SHANDLE_PTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FullName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWebBrowserApp,
                FullName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWebBrowserApp,
                FullName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Path: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWebBrowserApp,
                Path: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWebBrowserApp,
                Path: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Visible: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWebBrowserApp,
                pBool: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWebBrowserApp,
                pBool: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Visible: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWebBrowserApp,
                Value: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWebBrowserApp,
                Value: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StatusBar: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWebBrowserApp,
                pBool: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWebBrowserApp,
                pBool: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_StatusBar: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWebBrowserApp,
                Value: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWebBrowserApp,
                Value: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StatusText: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWebBrowserApp,
                StatusText: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWebBrowserApp,
                StatusText: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_StatusText: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWebBrowserApp,
                StatusText: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWebBrowserApp,
                StatusText: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ToolBar: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWebBrowserApp,
                Value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWebBrowserApp,
                Value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ToolBar: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWebBrowserApp,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWebBrowserApp,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MenuBar: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWebBrowserApp,
                Value: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWebBrowserApp,
                Value: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MenuBar: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWebBrowserApp,
                Value: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWebBrowserApp,
                Value: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FullScreen: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWebBrowserApp,
                pbFullScreen: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWebBrowserApp,
                pbFullScreen: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_FullScreen: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWebBrowserApp,
                bFullScreen: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWebBrowserApp,
                bFullScreen: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWebBrowser.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWebBrowserApp_Quit(self: *const T) HRESULT {
                return @as(*const IWebBrowserApp.VTable, @ptrCast(self.vtable)).Quit(@as(*const IWebBrowserApp, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWebBrowserApp_ClientToWindow(self: *const T, pcx: ?*i32, pcy: ?*i32) HRESULT {
                return @as(*const IWebBrowserApp.VTable, @ptrCast(self.vtable)).ClientToWindow(@as(*const IWebBrowserApp, @ptrCast(self)), pcx, pcy);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWebBrowserApp_PutProperty(self: *const T, Property: ?BSTR, vtValue: VARIANT) HRESULT {
                return @as(*const IWebBrowserApp.VTable, @ptrCast(self.vtable)).PutProperty(@as(*const IWebBrowserApp, @ptrCast(self)), Property, vtValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWebBrowserApp_GetProperty(self: *const T, Property: ?BSTR, pvtValue: ?*VARIANT) HRESULT {
                return @as(*const IWebBrowserApp.VTable, @ptrCast(self.vtable)).GetProperty(@as(*const IWebBrowserApp, @ptrCast(self)), Property, pvtValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWebBrowserApp_get_Name(self: *const T, Name: ?*?BSTR) HRESULT {
                return @as(*const IWebBrowserApp.VTable, @ptrCast(self.vtable)).get_Name(@as(*const IWebBrowserApp, @ptrCast(self)), Name);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWebBrowserApp_get_HWND(self: *const T, pHWND: ?*SHANDLE_PTR) HRESULT {
                return @as(*const IWebBrowserApp.VTable, @ptrCast(self.vtable)).get_HWND(@as(*const IWebBrowserApp, @ptrCast(self)), pHWND);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWebBrowserApp_get_FullName(self: *const T, FullName: ?*?BSTR) HRESULT {
                return @as(*const IWebBrowserApp.VTable, @ptrCast(self.vtable)).get_FullName(@as(*const IWebBrowserApp, @ptrCast(self)), FullName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWebBrowserApp_get_Path(self: *const T, Path: ?*?BSTR) HRESULT {
                return @as(*const IWebBrowserApp.VTable, @ptrCast(self.vtable)).get_Path(@as(*const IWebBrowserApp, @ptrCast(self)), Path);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWebBrowserApp_get_Visible(self: *const T, pBool: ?*i16) HRESULT {
                return @as(*const IWebBrowserApp.VTable, @ptrCast(self.vtable)).get_Visible(@as(*const IWebBrowserApp, @ptrCast(self)), pBool);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWebBrowserApp_put_Visible(self: *const T, Value: i16) HRESULT {
                return @as(*const IWebBrowserApp.VTable, @ptrCast(self.vtable)).put_Visible(@as(*const IWebBrowserApp, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWebBrowserApp_get_StatusBar(self: *const T, pBool: ?*i16) HRESULT {
                return @as(*const IWebBrowserApp.VTable, @ptrCast(self.vtable)).get_StatusBar(@as(*const IWebBrowserApp, @ptrCast(self)), pBool);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWebBrowserApp_put_StatusBar(self: *const T, Value: i16) HRESULT {
                return @as(*const IWebBrowserApp.VTable, @ptrCast(self.vtable)).put_StatusBar(@as(*const IWebBrowserApp, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWebBrowserApp_get_StatusText(self: *const T, StatusText: ?*?BSTR) HRESULT {
                return @as(*const IWebBrowserApp.VTable, @ptrCast(self.vtable)).get_StatusText(@as(*const IWebBrowserApp, @ptrCast(self)), StatusText);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWebBrowserApp_put_StatusText(self: *const T, StatusText: ?BSTR) HRESULT {
                return @as(*const IWebBrowserApp.VTable, @ptrCast(self.vtable)).put_StatusText(@as(*const IWebBrowserApp, @ptrCast(self)), StatusText);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWebBrowserApp_get_ToolBar(self: *const T, Value: ?*i32) HRESULT {
                return @as(*const IWebBrowserApp.VTable, @ptrCast(self.vtable)).get_ToolBar(@as(*const IWebBrowserApp, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWebBrowserApp_put_ToolBar(self: *const T, Value: i32) HRESULT {
                return @as(*const IWebBrowserApp.VTable, @ptrCast(self.vtable)).put_ToolBar(@as(*const IWebBrowserApp, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWebBrowserApp_get_MenuBar(self: *const T, Value: ?*i16) HRESULT {
                return @as(*const IWebBrowserApp.VTable, @ptrCast(self.vtable)).get_MenuBar(@as(*const IWebBrowserApp, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWebBrowserApp_put_MenuBar(self: *const T, Value: i16) HRESULT {
                return @as(*const IWebBrowserApp.VTable, @ptrCast(self.vtable)).put_MenuBar(@as(*const IWebBrowserApp, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWebBrowserApp_get_FullScreen(self: *const T, pbFullScreen: ?*i16) HRESULT {
                return @as(*const IWebBrowserApp.VTable, @ptrCast(self.vtable)).get_FullScreen(@as(*const IWebBrowserApp, @ptrCast(self)), pbFullScreen);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWebBrowserApp_put_FullScreen(self: *const T, bFullScreen: i16) HRESULT {
                return @as(*const IWebBrowserApp.VTable, @ptrCast(self.vtable)).put_FullScreen(@as(*const IWebBrowserApp, @ptrCast(self)), bFullScreen);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IWebBrowser2_Value = Guid.initString("d30c1661-cdaf-11d0-8a3e-00c04fc9e26e");
pub const IID_IWebBrowser2 = &IID_IWebBrowser2_Value;
pub const IWebBrowser2 = extern struct {
    pub const VTable = extern struct {
        base: IWebBrowserApp.VTable,
        Navigate2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWebBrowser2,
                URL: ?*VARIANT,
                Flags: ?*VARIANT,
                TargetFrameName: ?*VARIANT,
                PostData: ?*VARIANT,
                Headers: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWebBrowser2,
                URL: ?*VARIANT,
                Flags: ?*VARIANT,
                TargetFrameName: ?*VARIANT,
                PostData: ?*VARIANT,
                Headers: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryStatusWB: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWebBrowser2,
                cmdID: OLECMDID,
                pcmdf: ?*OLECMDF,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWebBrowser2,
                cmdID: OLECMDID,
                pcmdf: ?*OLECMDF,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExecWB: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWebBrowser2,
                cmdID: OLECMDID,
                cmdexecopt: OLECMDEXECOPT,
                pvaIn: ?*VARIANT,
                pvaOut: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWebBrowser2,
                cmdID: OLECMDID,
                cmdexecopt: OLECMDEXECOPT,
                pvaIn: ?*VARIANT,
                pvaOut: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ShowBrowserBar: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWebBrowser2,
                pvaClsid: ?*VARIANT,
                pvarShow: ?*VARIANT,
                pvarSize: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWebBrowser2,
                pvaClsid: ?*VARIANT,
                pvarShow: ?*VARIANT,
                pvarSize: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ReadyState: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWebBrowser2,
                plReadyState: ?*READYSTATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWebBrowser2,
                plReadyState: ?*READYSTATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Offline: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWebBrowser2,
                pbOffline: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWebBrowser2,
                pbOffline: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Offline: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWebBrowser2,
                bOffline: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWebBrowser2,
                bOffline: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Silent: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWebBrowser2,
                pbSilent: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWebBrowser2,
                pbSilent: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Silent: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWebBrowser2,
                bSilent: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWebBrowser2,
                bSilent: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RegisterAsBrowser: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWebBrowser2,
                pbRegister: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWebBrowser2,
                pbRegister: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_RegisterAsBrowser: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWebBrowser2,
                bRegister: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWebBrowser2,
                bRegister: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RegisterAsDropTarget: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWebBrowser2,
                pbRegister: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWebBrowser2,
                pbRegister: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_RegisterAsDropTarget: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWebBrowser2,
                bRegister: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWebBrowser2,
                bRegister: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TheaterMode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWebBrowser2,
                pbRegister: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWebBrowser2,
                pbRegister: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_TheaterMode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWebBrowser2,
                bRegister: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWebBrowser2,
                bRegister: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AddressBar: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWebBrowser2,
                Value: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWebBrowser2,
                Value: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AddressBar: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWebBrowser2,
                Value: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWebBrowser2,
                Value: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Resizable: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWebBrowser2,
                Value: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWebBrowser2,
                Value: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Resizable: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWebBrowser2,
                Value: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWebBrowser2,
                Value: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWebBrowserApp.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWebBrowser2_Navigate2(self: *const T, URL: ?*VARIANT, Flags: ?*VARIANT, TargetFrameName: ?*VARIANT, PostData: ?*VARIANT, Headers: ?*VARIANT) HRESULT {
                return @as(*const IWebBrowser2.VTable, @ptrCast(self.vtable)).Navigate2(@as(*const IWebBrowser2, @ptrCast(self)), URL, Flags, TargetFrameName, PostData, Headers);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWebBrowser2_QueryStatusWB(self: *const T, cmdID: OLECMDID, pcmdf: ?*OLECMDF) HRESULT {
                return @as(*const IWebBrowser2.VTable, @ptrCast(self.vtable)).QueryStatusWB(@as(*const IWebBrowser2, @ptrCast(self)), cmdID, pcmdf);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWebBrowser2_ExecWB(self: *const T, cmdID: OLECMDID, cmdexecopt: OLECMDEXECOPT, pvaIn: ?*VARIANT, pvaOut: ?*VARIANT) HRESULT {
                return @as(*const IWebBrowser2.VTable, @ptrCast(self.vtable)).ExecWB(@as(*const IWebBrowser2, @ptrCast(self)), cmdID, cmdexecopt, pvaIn, pvaOut);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWebBrowser2_ShowBrowserBar(self: *const T, pvaClsid: ?*VARIANT, pvarShow: ?*VARIANT, pvarSize: ?*VARIANT) HRESULT {
                return @as(*const IWebBrowser2.VTable, @ptrCast(self.vtable)).ShowBrowserBar(@as(*const IWebBrowser2, @ptrCast(self)), pvaClsid, pvarShow, pvarSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWebBrowser2_get_ReadyState(self: *const T, plReadyState: ?*READYSTATE) HRESULT {
                return @as(*const IWebBrowser2.VTable, @ptrCast(self.vtable)).get_ReadyState(@as(*const IWebBrowser2, @ptrCast(self)), plReadyState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWebBrowser2_get_Offline(self: *const T, pbOffline: ?*i16) HRESULT {
                return @as(*const IWebBrowser2.VTable, @ptrCast(self.vtable)).get_Offline(@as(*const IWebBrowser2, @ptrCast(self)), pbOffline);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWebBrowser2_put_Offline(self: *const T, bOffline: i16) HRESULT {
                return @as(*const IWebBrowser2.VTable, @ptrCast(self.vtable)).put_Offline(@as(*const IWebBrowser2, @ptrCast(self)), bOffline);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWebBrowser2_get_Silent(self: *const T, pbSilent: ?*i16) HRESULT {
                return @as(*const IWebBrowser2.VTable, @ptrCast(self.vtable)).get_Silent(@as(*const IWebBrowser2, @ptrCast(self)), pbSilent);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWebBrowser2_put_Silent(self: *const T, bSilent: i16) HRESULT {
                return @as(*const IWebBrowser2.VTable, @ptrCast(self.vtable)).put_Silent(@as(*const IWebBrowser2, @ptrCast(self)), bSilent);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWebBrowser2_get_RegisterAsBrowser(self: *const T, pbRegister: ?*i16) HRESULT {
                return @as(*const IWebBrowser2.VTable, @ptrCast(self.vtable)).get_RegisterAsBrowser(@as(*const IWebBrowser2, @ptrCast(self)), pbRegister);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWebBrowser2_put_RegisterAsBrowser(self: *const T, bRegister: i16) HRESULT {
                return @as(*const IWebBrowser2.VTable, @ptrCast(self.vtable)).put_RegisterAsBrowser(@as(*const IWebBrowser2, @ptrCast(self)), bRegister);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWebBrowser2_get_RegisterAsDropTarget(self: *const T, pbRegister: ?*i16) HRESULT {
                return @as(*const IWebBrowser2.VTable, @ptrCast(self.vtable)).get_RegisterAsDropTarget(@as(*const IWebBrowser2, @ptrCast(self)), pbRegister);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWebBrowser2_put_RegisterAsDropTarget(self: *const T, bRegister: i16) HRESULT {
                return @as(*const IWebBrowser2.VTable, @ptrCast(self.vtable)).put_RegisterAsDropTarget(@as(*const IWebBrowser2, @ptrCast(self)), bRegister);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWebBrowser2_get_TheaterMode(self: *const T, pbRegister: ?*i16) HRESULT {
                return @as(*const IWebBrowser2.VTable, @ptrCast(self.vtable)).get_TheaterMode(@as(*const IWebBrowser2, @ptrCast(self)), pbRegister);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWebBrowser2_put_TheaterMode(self: *const T, bRegister: i16) HRESULT {
                return @as(*const IWebBrowser2.VTable, @ptrCast(self.vtable)).put_TheaterMode(@as(*const IWebBrowser2, @ptrCast(self)), bRegister);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWebBrowser2_get_AddressBar(self: *const T, Value: ?*i16) HRESULT {
                return @as(*const IWebBrowser2.VTable, @ptrCast(self.vtable)).get_AddressBar(@as(*const IWebBrowser2, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWebBrowser2_put_AddressBar(self: *const T, Value: i16) HRESULT {
                return @as(*const IWebBrowser2.VTable, @ptrCast(self.vtable)).put_AddressBar(@as(*const IWebBrowser2, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWebBrowser2_get_Resizable(self: *const T, Value: ?*i16) HRESULT {
                return @as(*const IWebBrowser2.VTable, @ptrCast(self.vtable)).get_Resizable(@as(*const IWebBrowser2, @ptrCast(self)), Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWebBrowser2_put_Resizable(self: *const T, Value: i16) HRESULT {
                return @as(*const IWebBrowser2.VTable, @ptrCast(self.vtable)).put_Resizable(@as(*const IWebBrowser2, @ptrCast(self)), Value);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_DWebBrowserEvents2_Value = Guid.initString("34a715a0-6587-11d0-924a-0020afc7ac4d");
pub const IID_DWebBrowserEvents2 = &IID_DWebBrowserEvents2_Value;
pub const DWebBrowserEvents2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_DShellWindowsEvents_Value = Guid.initString("fe4106e0-399a-11d0-a48c-00a0c90a8f39");
pub const IID_DShellWindowsEvents = &IID_DShellWindowsEvents_Value;
pub const DShellWindowsEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IShellWindows_Value = Guid.initString("85cb6900-4d95-11cf-960c-0080c7f4ee85");
pub const IID_IShellWindows = &IID_IShellWindows_Value;
pub const IShellWindows = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IShellWindows,
                Count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IShellWindows,
                Count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Item: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellWindows,
                index: VARIANT,
                Folder: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellWindows,
                index: VARIANT,
                Folder: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        _NewEnum: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellWindows,
                ppunk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellWindows,
                ppunk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Register: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellWindows,
                pid: ?*IDispatch,
                hwnd: i32,
                swClass: i32,
                plCookie: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellWindows,
                pid: ?*IDispatch,
                hwnd: i32,
                swClass: i32,
                plCookie: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RegisterPending: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellWindows,
                lThreadId: i32,
                pvarloc: ?*VARIANT,
                pvarlocRoot: ?*VARIANT,
                swClass: i32,
                plCookie: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellWindows,
                lThreadId: i32,
                pvarloc: ?*VARIANT,
                pvarlocRoot: ?*VARIANT,
                swClass: i32,
                plCookie: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Revoke: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellWindows,
                lCookie: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellWindows,
                lCookie: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnNavigate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellWindows,
                lCookie: i32,
                pvarLoc: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellWindows,
                lCookie: i32,
                pvarLoc: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnActivated: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellWindows,
                lCookie: i32,
                fActive: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellWindows,
                lCookie: i32,
                fActive: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindWindowSW: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellWindows,
                pvarLoc: ?*VARIANT,
                pvarLocRoot: ?*VARIANT,
                swClass: i32,
                phwnd: ?*i32,
                swfwOptions: i32,
                ppdispOut: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellWindows,
                pvarLoc: ?*VARIANT,
                pvarLocRoot: ?*VARIANT,
                swClass: i32,
                phwnd: ?*i32,
                swfwOptions: i32,
                ppdispOut: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnCreated: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellWindows,
                lCookie: i32,
                punk: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellWindows,
                lCookie: i32,
                punk: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ProcessAttachDetach: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellWindows,
                fAttach: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellWindows,
                fAttach: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellWindows_get_Count(self: *const T, Count: ?*i32) HRESULT {
                return @as(*const IShellWindows.VTable, @ptrCast(self.vtable)).get_Count(@as(*const IShellWindows, @ptrCast(self)), Count);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellWindows_Item(self: *const T, index: VARIANT, _param_Folder: ?*?*IDispatch) HRESULT {
                return @as(*const IShellWindows.VTable, @ptrCast(self.vtable)).Item(@as(*const IShellWindows, @ptrCast(self)), index, _param_Folder);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellWindows__NewEnum(self: *const T, ppunk: ?*?*IUnknown) HRESULT {
                return @as(*const IShellWindows.VTable, @ptrCast(self.vtable))._NewEnum(@as(*const IShellWindows, @ptrCast(self)), ppunk);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellWindows_Register(self: *const T, pid: ?*IDispatch, hwnd: i32, swClass: i32, plCookie: ?*i32) HRESULT {
                return @as(*const IShellWindows.VTable, @ptrCast(self.vtable)).Register(@as(*const IShellWindows, @ptrCast(self)), pid, hwnd, swClass, plCookie);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellWindows_RegisterPending(self: *const T, lThreadId: i32, pvarloc: ?*VARIANT, pvarlocRoot: ?*VARIANT, swClass: i32, plCookie: ?*i32) HRESULT {
                return @as(*const IShellWindows.VTable, @ptrCast(self.vtable)).RegisterPending(@as(*const IShellWindows, @ptrCast(self)), lThreadId, pvarloc, pvarlocRoot, swClass, plCookie);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellWindows_Revoke(self: *const T, lCookie: i32) HRESULT {
                return @as(*const IShellWindows.VTable, @ptrCast(self.vtable)).Revoke(@as(*const IShellWindows, @ptrCast(self)), lCookie);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellWindows_OnNavigate(self: *const T, lCookie: i32, pvarLoc: ?*VARIANT) HRESULT {
                return @as(*const IShellWindows.VTable, @ptrCast(self.vtable)).OnNavigate(@as(*const IShellWindows, @ptrCast(self)), lCookie, pvarLoc);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellWindows_OnActivated(self: *const T, lCookie: i32, fActive: i16) HRESULT {
                return @as(*const IShellWindows.VTable, @ptrCast(self.vtable)).OnActivated(@as(*const IShellWindows, @ptrCast(self)), lCookie, fActive);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellWindows_FindWindowSW(self: *const T, pvarLoc: ?*VARIANT, pvarLocRoot: ?*VARIANT, swClass: i32, phwnd: ?*i32, swfwOptions: i32, ppdispOut: ?*?*IDispatch) HRESULT {
                return @as(*const IShellWindows.VTable, @ptrCast(self.vtable)).FindWindowSW(@as(*const IShellWindows, @ptrCast(self)), pvarLoc, pvarLocRoot, swClass, phwnd, swfwOptions, ppdispOut);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellWindows_OnCreated(self: *const T, lCookie: i32, punk: ?*IUnknown) HRESULT {
                return @as(*const IShellWindows.VTable, @ptrCast(self.vtable)).OnCreated(@as(*const IShellWindows, @ptrCast(self)), lCookie, punk);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellWindows_ProcessAttachDetach(self: *const T, fAttach: i16) HRESULT {
                return @as(*const IShellWindows.VTable, @ptrCast(self.vtable)).ProcessAttachDetach(@as(*const IShellWindows, @ptrCast(self)), fAttach);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IShellUIHelper_Value = Guid.initString("729fe2f8-1ea8-11d1-8f85-00c04fc2fbe1");
pub const IID_IShellUIHelper = &IID_IShellUIHelper_Value;
pub const IShellUIHelper = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        ResetFirstBootMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ResetSafeMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RefreshOfflineDesktop: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddFavorite: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper,
                URL: ?BSTR,
                Title: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper,
                URL: ?BSTR,
                Title: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddChannel: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper,
                URL: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper,
                URL: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddDesktopComponent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper,
                URL: ?BSTR,
                Type: ?BSTR,
                Left: ?*VARIANT,
                Top: ?*VARIANT,
                Width: ?*VARIANT,
                Height: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper,
                URL: ?BSTR,
                Type: ?BSTR,
                Left: ?*VARIANT,
                Top: ?*VARIANT,
                Width: ?*VARIANT,
                Height: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsSubscribed: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper,
                URL: ?BSTR,
                pBool: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper,
                URL: ?BSTR,
                pBool: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NavigateAndFind: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper,
                URL: ?BSTR,
                strQuery: ?BSTR,
                varTargetFrame: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper,
                URL: ?BSTR,
                strQuery: ?BSTR,
                varTargetFrame: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ImportExportFavorites: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper,
                fImport: i16,
                strImpExpPath: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper,
                fImport: i16,
                strImpExpPath: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AutoCompleteSaveForm: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper,
                Form: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper,
                Form: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AutoScan: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper,
                strSearch: ?BSTR,
                strFailureUrl: ?BSTR,
                pvarTargetFrame: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper,
                strSearch: ?BSTR,
                strFailureUrl: ?BSTR,
                pvarTargetFrame: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AutoCompleteAttach: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper,
                Reserved: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper,
                Reserved: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ShowBrowserUI: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper,
                bstrName: ?BSTR,
                pvarIn: ?*VARIANT,
                pvarOut: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper,
                bstrName: ?BSTR,
                pvarIn: ?*VARIANT,
                pvarOut: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper_ResetFirstBootMode(self: *const T) HRESULT {
                return @as(*const IShellUIHelper.VTable, @ptrCast(self.vtable)).ResetFirstBootMode(@as(*const IShellUIHelper, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper_ResetSafeMode(self: *const T) HRESULT {
                return @as(*const IShellUIHelper.VTable, @ptrCast(self.vtable)).ResetSafeMode(@as(*const IShellUIHelper, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper_RefreshOfflineDesktop(self: *const T) HRESULT {
                return @as(*const IShellUIHelper.VTable, @ptrCast(self.vtable)).RefreshOfflineDesktop(@as(*const IShellUIHelper, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper_AddFavorite(self: *const T, URL: ?BSTR, Title: ?*VARIANT) HRESULT {
                return @as(*const IShellUIHelper.VTable, @ptrCast(self.vtable)).AddFavorite(@as(*const IShellUIHelper, @ptrCast(self)), URL, Title);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper_AddChannel(self: *const T, URL: ?BSTR) HRESULT {
                return @as(*const IShellUIHelper.VTable, @ptrCast(self.vtable)).AddChannel(@as(*const IShellUIHelper, @ptrCast(self)), URL);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper_AddDesktopComponent(self: *const T, URL: ?BSTR, Type: ?BSTR, Left: ?*VARIANT, Top: ?*VARIANT, Width: ?*VARIANT, Height: ?*VARIANT) HRESULT {
                return @as(*const IShellUIHelper.VTable, @ptrCast(self.vtable)).AddDesktopComponent(@as(*const IShellUIHelper, @ptrCast(self)), URL, Type, Left, Top, Width, Height);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper_IsSubscribed(self: *const T, URL: ?BSTR, pBool: ?*i16) HRESULT {
                return @as(*const IShellUIHelper.VTable, @ptrCast(self.vtable)).IsSubscribed(@as(*const IShellUIHelper, @ptrCast(self)), URL, pBool);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper_NavigateAndFind(self: *const T, URL: ?BSTR, strQuery: ?BSTR, varTargetFrame: ?*VARIANT) HRESULT {
                return @as(*const IShellUIHelper.VTable, @ptrCast(self.vtable)).NavigateAndFind(@as(*const IShellUIHelper, @ptrCast(self)), URL, strQuery, varTargetFrame);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper_ImportExportFavorites(self: *const T, fImport: i16, strImpExpPath: ?BSTR) HRESULT {
                return @as(*const IShellUIHelper.VTable, @ptrCast(self.vtable)).ImportExportFavorites(@as(*const IShellUIHelper, @ptrCast(self)), fImport, strImpExpPath);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper_AutoCompleteSaveForm(self: *const T, Form: ?*VARIANT) HRESULT {
                return @as(*const IShellUIHelper.VTable, @ptrCast(self.vtable)).AutoCompleteSaveForm(@as(*const IShellUIHelper, @ptrCast(self)), Form);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper_AutoScan(self: *const T, strSearch: ?BSTR, strFailureUrl: ?BSTR, pvarTargetFrame: ?*VARIANT) HRESULT {
                return @as(*const IShellUIHelper.VTable, @ptrCast(self.vtable)).AutoScan(@as(*const IShellUIHelper, @ptrCast(self)), strSearch, strFailureUrl, pvarTargetFrame);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper_AutoCompleteAttach(self: *const T, Reserved: ?*VARIANT) HRESULT {
                return @as(*const IShellUIHelper.VTable, @ptrCast(self.vtable)).AutoCompleteAttach(@as(*const IShellUIHelper, @ptrCast(self)), Reserved);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper_ShowBrowserUI(self: *const T, bstrName: ?BSTR, pvarIn: ?*VARIANT, pvarOut: ?*VARIANT) HRESULT {
                return @as(*const IShellUIHelper.VTable, @ptrCast(self.vtable)).ShowBrowserUI(@as(*const IShellUIHelper, @ptrCast(self)), bstrName, pvarIn, pvarOut);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IShellUIHelper2_Value = Guid.initString("a7fe6eda-1932-4281-b881-87b31b8bc52c");
pub const IID_IShellUIHelper2 = &IID_IShellUIHelper2_Value;
pub const IShellUIHelper2 = extern struct {
    pub const VTable = extern struct {
        base: IShellUIHelper.VTable,
        AddSearchProvider: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper2,
                URL: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper2,
                URL: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RunOnceShown: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SkipRunOnce: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CustomizeSettings: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper2,
                fSQM: i16,
                fPhishing: i16,
                bstrLocale: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper2,
                fSQM: i16,
                fPhishing: i16,
                bstrLocale: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SqmEnabled: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper2,
                pfEnabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper2,
                pfEnabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PhishingEnabled: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper2,
                pfEnabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper2,
                pfEnabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BrandImageUri: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper2,
                pbstrUri: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper2,
                pbstrUri: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SkipTabsWelcome: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DiagnoseConnection: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CustomizeClearType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper2,
                fSet: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper2,
                fSet: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsSearchProviderInstalled: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper2,
                URL: ?BSTR,
                pdwResult: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper2,
                URL: ?BSTR,
                pdwResult: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsSearchMigrated: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper2,
                pfMigrated: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper2,
                pfMigrated: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DefaultSearchProvider: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper2,
                pbstrName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper2,
                pbstrName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RunOnceRequiredSettingsComplete: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper2,
                fComplete: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper2,
                fComplete: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RunOnceHasShown: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper2,
                pfShown: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper2,
                pfShown: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SearchGuideUrl: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper2,
                pbstrUrl: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper2,
                pbstrUrl: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IShellUIHelper.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper2_AddSearchProvider(self: *const T, URL: ?BSTR) HRESULT {
                return @as(*const IShellUIHelper2.VTable, @ptrCast(self.vtable)).AddSearchProvider(@as(*const IShellUIHelper2, @ptrCast(self)), URL);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper2_RunOnceShown(self: *const T) HRESULT {
                return @as(*const IShellUIHelper2.VTable, @ptrCast(self.vtable)).RunOnceShown(@as(*const IShellUIHelper2, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper2_SkipRunOnce(self: *const T) HRESULT {
                return @as(*const IShellUIHelper2.VTable, @ptrCast(self.vtable)).SkipRunOnce(@as(*const IShellUIHelper2, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper2_CustomizeSettings(self: *const T, fSQM: i16, fPhishing: i16, bstrLocale: ?BSTR) HRESULT {
                return @as(*const IShellUIHelper2.VTable, @ptrCast(self.vtable)).CustomizeSettings(@as(*const IShellUIHelper2, @ptrCast(self)), fSQM, fPhishing, bstrLocale);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper2_SqmEnabled(self: *const T, pfEnabled: ?*i16) HRESULT {
                return @as(*const IShellUIHelper2.VTable, @ptrCast(self.vtable)).SqmEnabled(@as(*const IShellUIHelper2, @ptrCast(self)), pfEnabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper2_PhishingEnabled(self: *const T, pfEnabled: ?*i16) HRESULT {
                return @as(*const IShellUIHelper2.VTable, @ptrCast(self.vtable)).PhishingEnabled(@as(*const IShellUIHelper2, @ptrCast(self)), pfEnabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper2_BrandImageUri(self: *const T, pbstrUri: ?*?BSTR) HRESULT {
                return @as(*const IShellUIHelper2.VTable, @ptrCast(self.vtable)).BrandImageUri(@as(*const IShellUIHelper2, @ptrCast(self)), pbstrUri);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper2_SkipTabsWelcome(self: *const T) HRESULT {
                return @as(*const IShellUIHelper2.VTable, @ptrCast(self.vtable)).SkipTabsWelcome(@as(*const IShellUIHelper2, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper2_DiagnoseConnection(self: *const T) HRESULT {
                return @as(*const IShellUIHelper2.VTable, @ptrCast(self.vtable)).DiagnoseConnection(@as(*const IShellUIHelper2, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper2_CustomizeClearType(self: *const T, fSet: i16) HRESULT {
                return @as(*const IShellUIHelper2.VTable, @ptrCast(self.vtable)).CustomizeClearType(@as(*const IShellUIHelper2, @ptrCast(self)), fSet);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper2_IsSearchProviderInstalled(self: *const T, URL: ?BSTR, pdwResult: ?*u32) HRESULT {
                return @as(*const IShellUIHelper2.VTable, @ptrCast(self.vtable)).IsSearchProviderInstalled(@as(*const IShellUIHelper2, @ptrCast(self)), URL, pdwResult);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper2_IsSearchMigrated(self: *const T, pfMigrated: ?*i16) HRESULT {
                return @as(*const IShellUIHelper2.VTable, @ptrCast(self.vtable)).IsSearchMigrated(@as(*const IShellUIHelper2, @ptrCast(self)), pfMigrated);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper2_DefaultSearchProvider(self: *const T, pbstrName: ?*?BSTR) HRESULT {
                return @as(*const IShellUIHelper2.VTable, @ptrCast(self.vtable)).DefaultSearchProvider(@as(*const IShellUIHelper2, @ptrCast(self)), pbstrName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper2_RunOnceRequiredSettingsComplete(self: *const T, fComplete: i16) HRESULT {
                return @as(*const IShellUIHelper2.VTable, @ptrCast(self.vtable)).RunOnceRequiredSettingsComplete(@as(*const IShellUIHelper2, @ptrCast(self)), fComplete);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper2_RunOnceHasShown(self: *const T, pfShown: ?*i16) HRESULT {
                return @as(*const IShellUIHelper2.VTable, @ptrCast(self.vtable)).RunOnceHasShown(@as(*const IShellUIHelper2, @ptrCast(self)), pfShown);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper2_SearchGuideUrl(self: *const T, pbstrUrl: ?*?BSTR) HRESULT {
                return @as(*const IShellUIHelper2.VTable, @ptrCast(self.vtable)).SearchGuideUrl(@as(*const IShellUIHelper2, @ptrCast(self)), pbstrUrl);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IShellUIHelper3_Value = Guid.initString("528df2ec-d419-40bc-9b6d-dcdbf9c1b25d");
pub const IID_IShellUIHelper3 = &IID_IShellUIHelper3_Value;
pub const IShellUIHelper3 = extern struct {
    pub const VTable = extern struct {
        base: IShellUIHelper2.VTable,
        AddService: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper3,
                URL: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper3,
                URL: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsServiceInstalled: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper3,
                URL: ?BSTR,
                Verb: ?BSTR,
                pdwResult: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper3,
                URL: ?BSTR,
                Verb: ?BSTR,
                pdwResult: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InPrivateFilteringEnabled: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper3,
                pfEnabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper3,
                pfEnabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddToFavoritesBar: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper3,
                URL: ?BSTR,
                Title: ?BSTR,
                Type: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper3,
                URL: ?BSTR,
                Title: ?BSTR,
                Type: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BuildNewTabPage: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetRecentlyClosedVisible: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper3,
                fVisible: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper3,
                fVisible: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetActivitiesVisible: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper3,
                fVisible: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper3,
                fVisible: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ContentDiscoveryReset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsSuggestedSitesEnabled: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper3,
                pfEnabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper3,
                pfEnabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnableSuggestedSites: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper3,
                fEnable: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper3,
                fEnable: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NavigateToSuggestedSites: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper3,
                bstrRelativeUrl: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper3,
                bstrRelativeUrl: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ShowTabsHelp: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ShowInPrivateHelp: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IShellUIHelper2.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper3_AddService(self: *const T, URL: ?BSTR) HRESULT {
                return @as(*const IShellUIHelper3.VTable, @ptrCast(self.vtable)).AddService(@as(*const IShellUIHelper3, @ptrCast(self)), URL);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper3_IsServiceInstalled(self: *const T, URL: ?BSTR, Verb: ?BSTR, pdwResult: ?*u32) HRESULT {
                return @as(*const IShellUIHelper3.VTable, @ptrCast(self.vtable)).IsServiceInstalled(@as(*const IShellUIHelper3, @ptrCast(self)), URL, Verb, pdwResult);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper3_InPrivateFilteringEnabled(self: *const T, pfEnabled: ?*i16) HRESULT {
                return @as(*const IShellUIHelper3.VTable, @ptrCast(self.vtable)).InPrivateFilteringEnabled(@as(*const IShellUIHelper3, @ptrCast(self)), pfEnabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper3_AddToFavoritesBar(self: *const T, URL: ?BSTR, Title: ?BSTR, Type: ?*VARIANT) HRESULT {
                return @as(*const IShellUIHelper3.VTable, @ptrCast(self.vtable)).AddToFavoritesBar(@as(*const IShellUIHelper3, @ptrCast(self)), URL, Title, Type);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper3_BuildNewTabPage(self: *const T) HRESULT {
                return @as(*const IShellUIHelper3.VTable, @ptrCast(self.vtable)).BuildNewTabPage(@as(*const IShellUIHelper3, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper3_SetRecentlyClosedVisible(self: *const T, fVisible: i16) HRESULT {
                return @as(*const IShellUIHelper3.VTable, @ptrCast(self.vtable)).SetRecentlyClosedVisible(@as(*const IShellUIHelper3, @ptrCast(self)), fVisible);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper3_SetActivitiesVisible(self: *const T, fVisible: i16) HRESULT {
                return @as(*const IShellUIHelper3.VTable, @ptrCast(self.vtable)).SetActivitiesVisible(@as(*const IShellUIHelper3, @ptrCast(self)), fVisible);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper3_ContentDiscoveryReset(self: *const T) HRESULT {
                return @as(*const IShellUIHelper3.VTable, @ptrCast(self.vtable)).ContentDiscoveryReset(@as(*const IShellUIHelper3, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper3_IsSuggestedSitesEnabled(self: *const T, pfEnabled: ?*i16) HRESULT {
                return @as(*const IShellUIHelper3.VTable, @ptrCast(self.vtable)).IsSuggestedSitesEnabled(@as(*const IShellUIHelper3, @ptrCast(self)), pfEnabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper3_EnableSuggestedSites(self: *const T, fEnable: i16) HRESULT {
                return @as(*const IShellUIHelper3.VTable, @ptrCast(self.vtable)).EnableSuggestedSites(@as(*const IShellUIHelper3, @ptrCast(self)), fEnable);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper3_NavigateToSuggestedSites(self: *const T, bstrRelativeUrl: ?BSTR) HRESULT {
                return @as(*const IShellUIHelper3.VTable, @ptrCast(self.vtable)).NavigateToSuggestedSites(@as(*const IShellUIHelper3, @ptrCast(self)), bstrRelativeUrl);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper3_ShowTabsHelp(self: *const T) HRESULT {
                return @as(*const IShellUIHelper3.VTable, @ptrCast(self.vtable)).ShowTabsHelp(@as(*const IShellUIHelper3, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper3_ShowInPrivateHelp(self: *const T) HRESULT {
                return @as(*const IShellUIHelper3.VTable, @ptrCast(self.vtable)).ShowInPrivateHelp(@as(*const IShellUIHelper3, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IShellUIHelper4_Value = Guid.initString("b36e6a53-8073-499e-824c-d776330a333e");
pub const IID_IShellUIHelper4 = &IID_IShellUIHelper4_Value;
pub const IShellUIHelper4 = extern struct {
    pub const VTable = extern struct {
        base: IShellUIHelper3.VTable,
        msIsSiteMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper4,
                pfSiteMode: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper4,
                pfSiteMode: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        msSiteModeShowThumbBar: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper4,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper4,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        msSiteModeAddThumbBarButton: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper4,
                bstrIconURL: ?BSTR,
                bstrTooltip: ?BSTR,
                pvarButtonID: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper4,
                bstrIconURL: ?BSTR,
                bstrTooltip: ?BSTR,
                pvarButtonID: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        msSiteModeUpdateThumbBarButton: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper4,
                ButtonID: VARIANT,
                fEnabled: i16,
                fVisible: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper4,
                ButtonID: VARIANT,
                fEnabled: i16,
                fVisible: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        msSiteModeSetIconOverlay: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper4,
                IconUrl: ?BSTR,
                pvarDescription: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper4,
                IconUrl: ?BSTR,
                pvarDescription: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        msSiteModeClearIconOverlay: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper4,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper4,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        msAddSiteMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper4,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper4,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        msSiteModeCreateJumpList: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper4,
                bstrHeader: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper4,
                bstrHeader: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        msSiteModeAddJumpListItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper4,
                bstrName: ?BSTR,
                bstrActionUri: ?BSTR,
                bstrIconUri: ?BSTR,
                pvarWindowType: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper4,
                bstrName: ?BSTR,
                bstrActionUri: ?BSTR,
                bstrIconUri: ?BSTR,
                pvarWindowType: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        msSiteModeClearJumpList: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper4,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper4,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        msSiteModeShowJumpList: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper4,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper4,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        msSiteModeAddButtonStyle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper4,
                uiButtonID: VARIANT,
                bstrIconUrl: ?BSTR,
                bstrTooltip: ?BSTR,
                pvarStyleID: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper4,
                uiButtonID: VARIANT,
                bstrIconUrl: ?BSTR,
                bstrTooltip: ?BSTR,
                pvarStyleID: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        msSiteModeShowButtonStyle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper4,
                uiButtonID: VARIANT,
                uiStyleID: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper4,
                uiButtonID: VARIANT,
                uiStyleID: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        msSiteModeActivate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper4,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper4,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        msIsSiteModeFirstRun: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper4,
                fPreserveState: i16,
                puiFirstRun: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper4,
                fPreserveState: i16,
                puiFirstRun: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        msAddTrackingProtectionList: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper4,
                URL: ?BSTR,
                bstrFilterName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper4,
                URL: ?BSTR,
                bstrFilterName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        msTrackingProtectionEnabled: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper4,
                pfEnabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper4,
                pfEnabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        msActiveXFilteringEnabled: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper4,
                pfEnabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper4,
                pfEnabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IShellUIHelper3.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper4_msIsSiteMode(self: *const T, pfSiteMode: ?*i16) HRESULT {
                return @as(*const IShellUIHelper4.VTable, @ptrCast(self.vtable)).msIsSiteMode(@as(*const IShellUIHelper4, @ptrCast(self)), pfSiteMode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper4_msSiteModeShowThumbBar(self: *const T) HRESULT {
                return @as(*const IShellUIHelper4.VTable, @ptrCast(self.vtable)).msSiteModeShowThumbBar(@as(*const IShellUIHelper4, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper4_msSiteModeAddThumbBarButton(self: *const T, bstrIconURL: ?BSTR, bstrTooltip: ?BSTR, pvarButtonID: ?*VARIANT) HRESULT {
                return @as(*const IShellUIHelper4.VTable, @ptrCast(self.vtable)).msSiteModeAddThumbBarButton(@as(*const IShellUIHelper4, @ptrCast(self)), bstrIconURL, bstrTooltip, pvarButtonID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper4_msSiteModeUpdateThumbBarButton(self: *const T, ButtonID: VARIANT, fEnabled: i16, fVisible: i16) HRESULT {
                return @as(*const IShellUIHelper4.VTable, @ptrCast(self.vtable)).msSiteModeUpdateThumbBarButton(@as(*const IShellUIHelper4, @ptrCast(self)), ButtonID, fEnabled, fVisible);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper4_msSiteModeSetIconOverlay(self: *const T, IconUrl: ?BSTR, pvarDescription: ?*VARIANT) HRESULT {
                return @as(*const IShellUIHelper4.VTable, @ptrCast(self.vtable)).msSiteModeSetIconOverlay(@as(*const IShellUIHelper4, @ptrCast(self)), IconUrl, pvarDescription);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper4_msSiteModeClearIconOverlay(self: *const T) HRESULT {
                return @as(*const IShellUIHelper4.VTable, @ptrCast(self.vtable)).msSiteModeClearIconOverlay(@as(*const IShellUIHelper4, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper4_msAddSiteMode(self: *const T) HRESULT {
                return @as(*const IShellUIHelper4.VTable, @ptrCast(self.vtable)).msAddSiteMode(@as(*const IShellUIHelper4, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper4_msSiteModeCreateJumpList(self: *const T, bstrHeader: ?BSTR) HRESULT {
                return @as(*const IShellUIHelper4.VTable, @ptrCast(self.vtable)).msSiteModeCreateJumpList(@as(*const IShellUIHelper4, @ptrCast(self)), bstrHeader);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper4_msSiteModeAddJumpListItem(self: *const T, bstrName: ?BSTR, bstrActionUri: ?BSTR, bstrIconUri: ?BSTR, pvarWindowType: ?*VARIANT) HRESULT {
                return @as(*const IShellUIHelper4.VTable, @ptrCast(self.vtable)).msSiteModeAddJumpListItem(@as(*const IShellUIHelper4, @ptrCast(self)), bstrName, bstrActionUri, bstrIconUri, pvarWindowType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper4_msSiteModeClearJumpList(self: *const T) HRESULT {
                return @as(*const IShellUIHelper4.VTable, @ptrCast(self.vtable)).msSiteModeClearJumpList(@as(*const IShellUIHelper4, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper4_msSiteModeShowJumpList(self: *const T) HRESULT {
                return @as(*const IShellUIHelper4.VTable, @ptrCast(self.vtable)).msSiteModeShowJumpList(@as(*const IShellUIHelper4, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper4_msSiteModeAddButtonStyle(self: *const T, uiButtonID: VARIANT, bstrIconUrl: ?BSTR, bstrTooltip: ?BSTR, pvarStyleID: ?*VARIANT) HRESULT {
                return @as(*const IShellUIHelper4.VTable, @ptrCast(self.vtable)).msSiteModeAddButtonStyle(@as(*const IShellUIHelper4, @ptrCast(self)), uiButtonID, bstrIconUrl, bstrTooltip, pvarStyleID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper4_msSiteModeShowButtonStyle(self: *const T, uiButtonID: VARIANT, uiStyleID: VARIANT) HRESULT {
                return @as(*const IShellUIHelper4.VTable, @ptrCast(self.vtable)).msSiteModeShowButtonStyle(@as(*const IShellUIHelper4, @ptrCast(self)), uiButtonID, uiStyleID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper4_msSiteModeActivate(self: *const T) HRESULT {
                return @as(*const IShellUIHelper4.VTable, @ptrCast(self.vtable)).msSiteModeActivate(@as(*const IShellUIHelper4, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper4_msIsSiteModeFirstRun(self: *const T, fPreserveState: i16, puiFirstRun: ?*VARIANT) HRESULT {
                return @as(*const IShellUIHelper4.VTable, @ptrCast(self.vtable)).msIsSiteModeFirstRun(@as(*const IShellUIHelper4, @ptrCast(self)), fPreserveState, puiFirstRun);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper4_msAddTrackingProtectionList(self: *const T, URL: ?BSTR, bstrFilterName: ?BSTR) HRESULT {
                return @as(*const IShellUIHelper4.VTable, @ptrCast(self.vtable)).msAddTrackingProtectionList(@as(*const IShellUIHelper4, @ptrCast(self)), URL, bstrFilterName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper4_msTrackingProtectionEnabled(self: *const T, pfEnabled: ?*i16) HRESULT {
                return @as(*const IShellUIHelper4.VTable, @ptrCast(self.vtable)).msTrackingProtectionEnabled(@as(*const IShellUIHelper4, @ptrCast(self)), pfEnabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper4_msActiveXFilteringEnabled(self: *const T, pfEnabled: ?*i16) HRESULT {
                return @as(*const IShellUIHelper4.VTable, @ptrCast(self.vtable)).msActiveXFilteringEnabled(@as(*const IShellUIHelper4, @ptrCast(self)), pfEnabled);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IShellUIHelper5_Value = Guid.initString("a2a08b09-103d-4d3f-b91c-ea455ca82efa");
pub const IID_IShellUIHelper5 = &IID_IShellUIHelper5_Value;
pub const IShellUIHelper5 = extern struct {
    pub const VTable = extern struct {
        base: IShellUIHelper4.VTable,
        msProvisionNetworks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper5,
                bstrProvisioningXml: ?BSTR,
                puiResult: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper5,
                bstrProvisioningXml: ?BSTR,
                puiResult: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        msReportSafeUrl: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper5,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper5,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        msSiteModeRefreshBadge: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper5,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper5,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        msSiteModeClearBadge: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper5,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper5,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        msDiagnoseConnectionUILess: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper5,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper5,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        msLaunchNetworkClientHelp: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper5,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper5,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        msChangeDefaultBrowser: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper5,
                fChange: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper5,
                fChange: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IShellUIHelper4.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper5_msProvisionNetworks(self: *const T, bstrProvisioningXml: ?BSTR, puiResult: ?*VARIANT) HRESULT {
                return @as(*const IShellUIHelper5.VTable, @ptrCast(self.vtable)).msProvisionNetworks(@as(*const IShellUIHelper5, @ptrCast(self)), bstrProvisioningXml, puiResult);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper5_msReportSafeUrl(self: *const T) HRESULT {
                return @as(*const IShellUIHelper5.VTable, @ptrCast(self.vtable)).msReportSafeUrl(@as(*const IShellUIHelper5, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper5_msSiteModeRefreshBadge(self: *const T) HRESULT {
                return @as(*const IShellUIHelper5.VTable, @ptrCast(self.vtable)).msSiteModeRefreshBadge(@as(*const IShellUIHelper5, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper5_msSiteModeClearBadge(self: *const T) HRESULT {
                return @as(*const IShellUIHelper5.VTable, @ptrCast(self.vtable)).msSiteModeClearBadge(@as(*const IShellUIHelper5, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper5_msDiagnoseConnectionUILess(self: *const T) HRESULT {
                return @as(*const IShellUIHelper5.VTable, @ptrCast(self.vtable)).msDiagnoseConnectionUILess(@as(*const IShellUIHelper5, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper5_msLaunchNetworkClientHelp(self: *const T) HRESULT {
                return @as(*const IShellUIHelper5.VTable, @ptrCast(self.vtable)).msLaunchNetworkClientHelp(@as(*const IShellUIHelper5, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper5_msChangeDefaultBrowser(self: *const T, fChange: i16) HRESULT {
                return @as(*const IShellUIHelper5.VTable, @ptrCast(self.vtable)).msChangeDefaultBrowser(@as(*const IShellUIHelper5, @ptrCast(self)), fChange);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IShellUIHelper6_Value = Guid.initString("987a573e-46ee-4e89-96ab-ddf7f8fdc98c");
pub const IID_IShellUIHelper6 = &IID_IShellUIHelper6_Value;
pub const IShellUIHelper6 = extern struct {
    pub const VTable = extern struct {
        base: IShellUIHelper5.VTable,
        msStopPeriodicTileUpdate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper6,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper6,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        msStartPeriodicTileUpdate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper6,
                pollingUris: VARIANT,
                startTime: VARIANT,
                uiUpdateRecurrence: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper6,
                pollingUris: VARIANT,
                startTime: VARIANT,
                uiUpdateRecurrence: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        msStartPeriodicTileUpdateBatch: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper6,
                pollingUris: VARIANT,
                startTime: VARIANT,
                uiUpdateRecurrence: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper6,
                pollingUris: VARIANT,
                startTime: VARIANT,
                uiUpdateRecurrence: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        msClearTile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper6,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper6,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        msEnableTileNotificationQueue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper6,
                fChange: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper6,
                fChange: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        msPinnedSiteState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper6,
                pvarSiteState: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper6,
                pvarSiteState: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        msEnableTileNotificationQueueForSquare150x150: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper6,
                fChange: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper6,
                fChange: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        msEnableTileNotificationQueueForWide310x150: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper6,
                fChange: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper6,
                fChange: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        msEnableTileNotificationQueueForSquare310x310: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper6,
                fChange: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper6,
                fChange: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        msScheduledTileNotification: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper6,
                bstrNotificationXml: ?BSTR,
                bstrNotificationId: ?BSTR,
                bstrNotificationTag: ?BSTR,
                startTime: VARIANT,
                expirationTime: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper6,
                bstrNotificationXml: ?BSTR,
                bstrNotificationId: ?BSTR,
                bstrNotificationTag: ?BSTR,
                startTime: VARIANT,
                expirationTime: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        msRemoveScheduledTileNotification: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper6,
                bstrNotificationId: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper6,
                bstrNotificationId: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        msStartPeriodicBadgeUpdate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper6,
                pollingUri: ?BSTR,
                startTime: VARIANT,
                uiUpdateRecurrence: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper6,
                pollingUri: ?BSTR,
                startTime: VARIANT,
                uiUpdateRecurrence: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        msStopPeriodicBadgeUpdate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper6,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper6,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        msLaunchInternetOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper6,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper6,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IShellUIHelper5.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper6_msStopPeriodicTileUpdate(self: *const T) HRESULT {
                return @as(*const IShellUIHelper6.VTable, @ptrCast(self.vtable)).msStopPeriodicTileUpdate(@as(*const IShellUIHelper6, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper6_msStartPeriodicTileUpdate(self: *const T, pollingUris: VARIANT, startTime: VARIANT, uiUpdateRecurrence: VARIANT) HRESULT {
                return @as(*const IShellUIHelper6.VTable, @ptrCast(self.vtable)).msStartPeriodicTileUpdate(@as(*const IShellUIHelper6, @ptrCast(self)), pollingUris, startTime, uiUpdateRecurrence);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper6_msStartPeriodicTileUpdateBatch(self: *const T, pollingUris: VARIANT, startTime: VARIANT, uiUpdateRecurrence: VARIANT) HRESULT {
                return @as(*const IShellUIHelper6.VTable, @ptrCast(self.vtable)).msStartPeriodicTileUpdateBatch(@as(*const IShellUIHelper6, @ptrCast(self)), pollingUris, startTime, uiUpdateRecurrence);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper6_msClearTile(self: *const T) HRESULT {
                return @as(*const IShellUIHelper6.VTable, @ptrCast(self.vtable)).msClearTile(@as(*const IShellUIHelper6, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper6_msEnableTileNotificationQueue(self: *const T, fChange: i16) HRESULT {
                return @as(*const IShellUIHelper6.VTable, @ptrCast(self.vtable)).msEnableTileNotificationQueue(@as(*const IShellUIHelper6, @ptrCast(self)), fChange);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper6_msPinnedSiteState(self: *const T, pvarSiteState: ?*VARIANT) HRESULT {
                return @as(*const IShellUIHelper6.VTable, @ptrCast(self.vtable)).msPinnedSiteState(@as(*const IShellUIHelper6, @ptrCast(self)), pvarSiteState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper6_msEnableTileNotificationQueueForSquare150x150(self: *const T, fChange: i16) HRESULT {
                return @as(*const IShellUIHelper6.VTable, @ptrCast(self.vtable)).msEnableTileNotificationQueueForSquare150x150(@as(*const IShellUIHelper6, @ptrCast(self)), fChange);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper6_msEnableTileNotificationQueueForWide310x150(self: *const T, fChange: i16) HRESULT {
                return @as(*const IShellUIHelper6.VTable, @ptrCast(self.vtable)).msEnableTileNotificationQueueForWide310x150(@as(*const IShellUIHelper6, @ptrCast(self)), fChange);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper6_msEnableTileNotificationQueueForSquare310x310(self: *const T, fChange: i16) HRESULT {
                return @as(*const IShellUIHelper6.VTable, @ptrCast(self.vtable)).msEnableTileNotificationQueueForSquare310x310(@as(*const IShellUIHelper6, @ptrCast(self)), fChange);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper6_msScheduledTileNotification(self: *const T, bstrNotificationXml: ?BSTR, bstrNotificationId: ?BSTR, bstrNotificationTag: ?BSTR, startTime: VARIANT, expirationTime: VARIANT) HRESULT {
                return @as(*const IShellUIHelper6.VTable, @ptrCast(self.vtable)).msScheduledTileNotification(@as(*const IShellUIHelper6, @ptrCast(self)), bstrNotificationXml, bstrNotificationId, bstrNotificationTag, startTime, expirationTime);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper6_msRemoveScheduledTileNotification(self: *const T, bstrNotificationId: ?BSTR) HRESULT {
                return @as(*const IShellUIHelper6.VTable, @ptrCast(self.vtable)).msRemoveScheduledTileNotification(@as(*const IShellUIHelper6, @ptrCast(self)), bstrNotificationId);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper6_msStartPeriodicBadgeUpdate(self: *const T, pollingUri: ?BSTR, startTime: VARIANT, uiUpdateRecurrence: VARIANT) HRESULT {
                return @as(*const IShellUIHelper6.VTable, @ptrCast(self.vtable)).msStartPeriodicBadgeUpdate(@as(*const IShellUIHelper6, @ptrCast(self)), pollingUri, startTime, uiUpdateRecurrence);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper6_msStopPeriodicBadgeUpdate(self: *const T) HRESULT {
                return @as(*const IShellUIHelper6.VTable, @ptrCast(self.vtable)).msStopPeriodicBadgeUpdate(@as(*const IShellUIHelper6, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper6_msLaunchInternetOptions(self: *const T) HRESULT {
                return @as(*const IShellUIHelper6.VTable, @ptrCast(self.vtable)).msLaunchInternetOptions(@as(*const IShellUIHelper6, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IShellUIHelper7_Value = Guid.initString("60e567c8-9573-4ab2-a264-637c6c161cb1");
pub const IID_IShellUIHelper7 = &IID_IShellUIHelper7_Value;
pub const IShellUIHelper7 = extern struct {
    pub const VTable = extern struct {
        base: IShellUIHelper6.VTable,
        SetExperimentalFlag: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper7,
                bstrFlagString: ?BSTR,
                vfFlag: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper7,
                bstrFlagString: ?BSTR,
                vfFlag: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExperimentalFlag: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper7,
                bstrFlagString: ?BSTR,
                vfFlag: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper7,
                bstrFlagString: ?BSTR,
                vfFlag: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetExperimentalValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper7,
                bstrValueString: ?BSTR,
                dwValue: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper7,
                bstrValueString: ?BSTR,
                dwValue: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExperimentalValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper7,
                bstrValueString: ?BSTR,
                pdwValue: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper7,
                bstrValueString: ?BSTR,
                pdwValue: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ResetAllExperimentalFlagsAndValues: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper7,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper7,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNeedIEAutoLaunchFlag: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper7,
                bstrUrl: ?BSTR,
                flag: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper7,
                bstrUrl: ?BSTR,
                flag: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetNeedIEAutoLaunchFlag: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper7,
                bstrUrl: ?BSTR,
                flag: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper7,
                bstrUrl: ?BSTR,
                flag: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        HasNeedIEAutoLaunchFlag: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper7,
                bstrUrl: ?BSTR,
                exists: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper7,
                bstrUrl: ?BSTR,
                exists: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LaunchIE: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper7,
                bstrUrl: ?BSTR,
                automated: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper7,
                bstrUrl: ?BSTR,
                automated: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IShellUIHelper6.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper7_SetExperimentalFlag(self: *const T, bstrFlagString: ?BSTR, vfFlag: i16) HRESULT {
                return @as(*const IShellUIHelper7.VTable, @ptrCast(self.vtable)).SetExperimentalFlag(@as(*const IShellUIHelper7, @ptrCast(self)), bstrFlagString, vfFlag);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper7_GetExperimentalFlag(self: *const T, bstrFlagString: ?BSTR, vfFlag: ?*i16) HRESULT {
                return @as(*const IShellUIHelper7.VTable, @ptrCast(self.vtable)).GetExperimentalFlag(@as(*const IShellUIHelper7, @ptrCast(self)), bstrFlagString, vfFlag);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper7_SetExperimentalValue(self: *const T, bstrValueString: ?BSTR, dwValue: u32) HRESULT {
                return @as(*const IShellUIHelper7.VTable, @ptrCast(self.vtable)).SetExperimentalValue(@as(*const IShellUIHelper7, @ptrCast(self)), bstrValueString, dwValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper7_GetExperimentalValue(self: *const T, bstrValueString: ?BSTR, pdwValue: ?*u32) HRESULT {
                return @as(*const IShellUIHelper7.VTable, @ptrCast(self.vtable)).GetExperimentalValue(@as(*const IShellUIHelper7, @ptrCast(self)), bstrValueString, pdwValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper7_ResetAllExperimentalFlagsAndValues(self: *const T) HRESULT {
                return @as(*const IShellUIHelper7.VTable, @ptrCast(self.vtable)).ResetAllExperimentalFlagsAndValues(@as(*const IShellUIHelper7, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper7_GetNeedIEAutoLaunchFlag(self: *const T, bstrUrl: ?BSTR, flag: ?*i16) HRESULT {
                return @as(*const IShellUIHelper7.VTable, @ptrCast(self.vtable)).GetNeedIEAutoLaunchFlag(@as(*const IShellUIHelper7, @ptrCast(self)), bstrUrl, flag);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper7_SetNeedIEAutoLaunchFlag(self: *const T, bstrUrl: ?BSTR, flag: i16) HRESULT {
                return @as(*const IShellUIHelper7.VTable, @ptrCast(self.vtable)).SetNeedIEAutoLaunchFlag(@as(*const IShellUIHelper7, @ptrCast(self)), bstrUrl, flag);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper7_HasNeedIEAutoLaunchFlag(self: *const T, bstrUrl: ?BSTR, exists: ?*i16) HRESULT {
                return @as(*const IShellUIHelper7.VTable, @ptrCast(self.vtable)).HasNeedIEAutoLaunchFlag(@as(*const IShellUIHelper7, @ptrCast(self)), bstrUrl, exists);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper7_LaunchIE(self: *const T, bstrUrl: ?BSTR, automated: i16) HRESULT {
                return @as(*const IShellUIHelper7.VTable, @ptrCast(self.vtable)).LaunchIE(@as(*const IShellUIHelper7, @ptrCast(self)), bstrUrl, automated);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IShellUIHelper8_Value = Guid.initString("66debcf2-05b0-4f07-b49b-b96241a65db2");
pub const IID_IShellUIHelper8 = &IID_IShellUIHelper8_Value;
pub const IShellUIHelper8 = extern struct {
    pub const VTable = extern struct {
        base: IShellUIHelper7.VTable,
        GetCVListData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper8,
                pbstrResult: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper8,
                pbstrResult: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCVListLocalData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper8,
                pbstrResult: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper8,
                pbstrResult: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEMIEListData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper8,
                pbstrResult: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper8,
                pbstrResult: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEMIEListLocalData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper8,
                pbstrResult: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper8,
                pbstrResult: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenFavoritesPane: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenFavoritesSettings: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LaunchInHVSI: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper8,
                bstrUrl: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper8,
                bstrUrl: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IShellUIHelper7.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper8_GetCVListData(self: *const T, pbstrResult: ?*?BSTR) HRESULT {
                return @as(*const IShellUIHelper8.VTable, @ptrCast(self.vtable)).GetCVListData(@as(*const IShellUIHelper8, @ptrCast(self)), pbstrResult);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper8_GetCVListLocalData(self: *const T, pbstrResult: ?*?BSTR) HRESULT {
                return @as(*const IShellUIHelper8.VTable, @ptrCast(self.vtable)).GetCVListLocalData(@as(*const IShellUIHelper8, @ptrCast(self)), pbstrResult);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper8_GetEMIEListData(self: *const T, pbstrResult: ?*?BSTR) HRESULT {
                return @as(*const IShellUIHelper8.VTable, @ptrCast(self.vtable)).GetEMIEListData(@as(*const IShellUIHelper8, @ptrCast(self)), pbstrResult);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper8_GetEMIEListLocalData(self: *const T, pbstrResult: ?*?BSTR) HRESULT {
                return @as(*const IShellUIHelper8.VTable, @ptrCast(self.vtable)).GetEMIEListLocalData(@as(*const IShellUIHelper8, @ptrCast(self)), pbstrResult);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper8_OpenFavoritesPane(self: *const T) HRESULT {
                return @as(*const IShellUIHelper8.VTable, @ptrCast(self.vtable)).OpenFavoritesPane(@as(*const IShellUIHelper8, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper8_OpenFavoritesSettings(self: *const T) HRESULT {
                return @as(*const IShellUIHelper8.VTable, @ptrCast(self.vtable)).OpenFavoritesSettings(@as(*const IShellUIHelper8, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper8_LaunchInHVSI(self: *const T, bstrUrl: ?BSTR) HRESULT {
                return @as(*const IShellUIHelper8.VTable, @ptrCast(self.vtable)).LaunchInHVSI(@as(*const IShellUIHelper8, @ptrCast(self)), bstrUrl);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IShellUIHelper9_Value = Guid.initString("6cdf73b0-7f2f-451f-bc0f-63e0f3284e54");
pub const IID_IShellUIHelper9 = &IID_IShellUIHelper9_Value;
pub const IShellUIHelper9 = extern struct {
    pub const VTable = extern struct {
        base: IShellUIHelper8.VTable,
        GetOSSku: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellUIHelper9,
                pdwResult: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellUIHelper9,
                pdwResult: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IShellUIHelper8.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellUIHelper9_GetOSSku(self: *const T, pdwResult: ?*u32) HRESULT {
                return @as(*const IShellUIHelper9.VTable, @ptrCast(self.vtable)).GetOSSku(@as(*const IShellUIHelper9, @ptrCast(self)), pdwResult);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_DShellNameSpaceEvents_Value = Guid.initString("55136806-b2de-11d1-b9f2-00a0c98bc547");
pub const IID_DShellNameSpaceEvents = &IID_DShellNameSpaceEvents_Value;
pub const DShellNameSpaceEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IShellFavoritesNameSpace_Value = Guid.initString("55136804-b2de-11d1-b9f2-00a0c98bc547");
pub const IID_IShellFavoritesNameSpace = &IID_IShellFavoritesNameSpace_Value;
pub const IShellFavoritesNameSpace = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        MoveSelectionUp: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellFavoritesNameSpace,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellFavoritesNameSpace,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        MoveSelectionDown: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellFavoritesNameSpace,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellFavoritesNameSpace,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ResetSort: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellFavoritesNameSpace,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellFavoritesNameSpace,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NewFolder: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellFavoritesNameSpace,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellFavoritesNameSpace,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Synchronize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellFavoritesNameSpace,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellFavoritesNameSpace,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Import: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellFavoritesNameSpace,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellFavoritesNameSpace,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Export: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellFavoritesNameSpace,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellFavoritesNameSpace,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InvokeContextMenuCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellFavoritesNameSpace,
                strCommand: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellFavoritesNameSpace,
                strCommand: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        MoveSelectionTo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellFavoritesNameSpace,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellFavoritesNameSpace,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SubscriptionsEnabled: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IShellFavoritesNameSpace,
                pBool: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IShellFavoritesNameSpace,
                pBool: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateSubscriptionForSelection: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellFavoritesNameSpace,
                pBool: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellFavoritesNameSpace,
                pBool: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeleteSubscriptionForSelection: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellFavoritesNameSpace,
                pBool: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellFavoritesNameSpace,
                pBool: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetRoot: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellFavoritesNameSpace,
                bstrFullPath: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellFavoritesNameSpace,
                bstrFullPath: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellFavoritesNameSpace_MoveSelectionUp(self: *const T) HRESULT {
                return @as(*const IShellFavoritesNameSpace.VTable, @ptrCast(self.vtable)).MoveSelectionUp(@as(*const IShellFavoritesNameSpace, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellFavoritesNameSpace_MoveSelectionDown(self: *const T) HRESULT {
                return @as(*const IShellFavoritesNameSpace.VTable, @ptrCast(self.vtable)).MoveSelectionDown(@as(*const IShellFavoritesNameSpace, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellFavoritesNameSpace_ResetSort(self: *const T) HRESULT {
                return @as(*const IShellFavoritesNameSpace.VTable, @ptrCast(self.vtable)).ResetSort(@as(*const IShellFavoritesNameSpace, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellFavoritesNameSpace_NewFolder(self: *const T) HRESULT {
                return @as(*const IShellFavoritesNameSpace.VTable, @ptrCast(self.vtable)).NewFolder(@as(*const IShellFavoritesNameSpace, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellFavoritesNameSpace_Synchronize(self: *const T) HRESULT {
                return @as(*const IShellFavoritesNameSpace.VTable, @ptrCast(self.vtable)).Synchronize(@as(*const IShellFavoritesNameSpace, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellFavoritesNameSpace_Import(self: *const T) HRESULT {
                return @as(*const IShellFavoritesNameSpace.VTable, @ptrCast(self.vtable)).Import(@as(*const IShellFavoritesNameSpace, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellFavoritesNameSpace_Export(self: *const T) HRESULT {
                return @as(*const IShellFavoritesNameSpace.VTable, @ptrCast(self.vtable)).Export(@as(*const IShellFavoritesNameSpace, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellFavoritesNameSpace_InvokeContextMenuCommand(self: *const T, strCommand: ?BSTR) HRESULT {
                return @as(*const IShellFavoritesNameSpace.VTable, @ptrCast(self.vtable)).InvokeContextMenuCommand(@as(*const IShellFavoritesNameSpace, @ptrCast(self)), strCommand);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellFavoritesNameSpace_MoveSelectionTo(self: *const T) HRESULT {
                return @as(*const IShellFavoritesNameSpace.VTable, @ptrCast(self.vtable)).MoveSelectionTo(@as(*const IShellFavoritesNameSpace, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellFavoritesNameSpace_get_SubscriptionsEnabled(self: *const T, pBool: ?*i16) HRESULT {
                return @as(*const IShellFavoritesNameSpace.VTable, @ptrCast(self.vtable)).get_SubscriptionsEnabled(@as(*const IShellFavoritesNameSpace, @ptrCast(self)), pBool);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellFavoritesNameSpace_CreateSubscriptionForSelection(self: *const T, pBool: ?*i16) HRESULT {
                return @as(*const IShellFavoritesNameSpace.VTable, @ptrCast(self.vtable)).CreateSubscriptionForSelection(@as(*const IShellFavoritesNameSpace, @ptrCast(self)), pBool);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellFavoritesNameSpace_DeleteSubscriptionForSelection(self: *const T, pBool: ?*i16) HRESULT {
                return @as(*const IShellFavoritesNameSpace.VTable, @ptrCast(self.vtable)).DeleteSubscriptionForSelection(@as(*const IShellFavoritesNameSpace, @ptrCast(self)), pBool);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellFavoritesNameSpace_SetRoot(self: *const T, bstrFullPath: ?BSTR) HRESULT {
                return @as(*const IShellFavoritesNameSpace.VTable, @ptrCast(self.vtable)).SetRoot(@as(*const IShellFavoritesNameSpace, @ptrCast(self)), bstrFullPath);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IShellNameSpace_Value = Guid.initString("e572d3c9-37be-4ae2-825d-d521763e3108");
pub const IID_IShellNameSpace = &IID_IShellNameSpace_Value;
pub const IShellNameSpace = extern struct {
    pub const VTable = extern struct {
        base: IShellFavoritesNameSpace.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EnumOptions: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IShellNameSpace,
                pgrfEnumFlags: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IShellNameSpace,
                pgrfEnumFlags: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_EnumOptions: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IShellNameSpace,
                lVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IShellNameSpace,
                lVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SelectedItem: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IShellNameSpace,
                pItem: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IShellNameSpace,
                pItem: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SelectedItem: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IShellNameSpace,
                pItem: ?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IShellNameSpace,
                pItem: ?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Root: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IShellNameSpace,
                pvar: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IShellNameSpace,
                pvar: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Root: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IShellNameSpace,
                @"var": VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IShellNameSpace,
                @"var": VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Depth: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IShellNameSpace,
                piDepth: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IShellNameSpace,
                piDepth: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Depth: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IShellNameSpace,
                iDepth: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IShellNameSpace,
                iDepth: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Mode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IShellNameSpace,
                puMode: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IShellNameSpace,
                puMode: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Mode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IShellNameSpace,
                uMode: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IShellNameSpace,
                uMode: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Flags: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IShellNameSpace,
                pdwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IShellNameSpace,
                pdwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Flags: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IShellNameSpace,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IShellNameSpace,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_TVFlags: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IShellNameSpace,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IShellNameSpace,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TVFlags: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IShellNameSpace,
                dwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IShellNameSpace,
                dwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Columns: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IShellNameSpace,
                bstrColumns: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IShellNameSpace,
                bstrColumns: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Columns: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IShellNameSpace,
                bstrColumns: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IShellNameSpace,
                bstrColumns: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CountViewTypes: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IShellNameSpace,
                piTypes: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IShellNameSpace,
                piTypes: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetViewType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellNameSpace,
                iType: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellNameSpace,
                iType: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SelectedItems: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellNameSpace,
                ppid: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellNameSpace,
                ppid: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Expand: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellNameSpace,
                @"var": VARIANT,
                iDepth: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellNameSpace,
                @"var": VARIANT,
                iDepth: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnselectAll: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellNameSpace,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellNameSpace,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IShellFavoritesNameSpace.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellNameSpace_get_EnumOptions(self: *const T, pgrfEnumFlags: ?*i32) HRESULT {
                return @as(*const IShellNameSpace.VTable, @ptrCast(self.vtable)).get_EnumOptions(@as(*const IShellNameSpace, @ptrCast(self)), pgrfEnumFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellNameSpace_put_EnumOptions(self: *const T, lVal: i32) HRESULT {
                return @as(*const IShellNameSpace.VTable, @ptrCast(self.vtable)).put_EnumOptions(@as(*const IShellNameSpace, @ptrCast(self)), lVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellNameSpace_get_SelectedItem(self: *const T, pItem: ?*?*IDispatch) HRESULT {
                return @as(*const IShellNameSpace.VTable, @ptrCast(self.vtable)).get_SelectedItem(@as(*const IShellNameSpace, @ptrCast(self)), pItem);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellNameSpace_put_SelectedItem(self: *const T, pItem: ?*IDispatch) HRESULT {
                return @as(*const IShellNameSpace.VTable, @ptrCast(self.vtable)).put_SelectedItem(@as(*const IShellNameSpace, @ptrCast(self)), pItem);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellNameSpace_get_Root(self: *const T, pvar: ?*VARIANT) HRESULT {
                return @as(*const IShellNameSpace.VTable, @ptrCast(self.vtable)).get_Root(@as(*const IShellNameSpace, @ptrCast(self)), pvar);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellNameSpace_put_Root(self: *const T, @"var": VARIANT) HRESULT {
                return @as(*const IShellNameSpace.VTable, @ptrCast(self.vtable)).put_Root(@as(*const IShellNameSpace, @ptrCast(self)), @"var");
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellNameSpace_get_Depth(self: *const T, piDepth: ?*i32) HRESULT {
                return @as(*const IShellNameSpace.VTable, @ptrCast(self.vtable)).get_Depth(@as(*const IShellNameSpace, @ptrCast(self)), piDepth);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellNameSpace_put_Depth(self: *const T, iDepth: i32) HRESULT {
                return @as(*const IShellNameSpace.VTable, @ptrCast(self.vtable)).put_Depth(@as(*const IShellNameSpace, @ptrCast(self)), iDepth);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellNameSpace_get_Mode(self: *const T, puMode: ?*u32) HRESULT {
                return @as(*const IShellNameSpace.VTable, @ptrCast(self.vtable)).get_Mode(@as(*const IShellNameSpace, @ptrCast(self)), puMode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellNameSpace_put_Mode(self: *const T, uMode: u32) HRESULT {
                return @as(*const IShellNameSpace.VTable, @ptrCast(self.vtable)).put_Mode(@as(*const IShellNameSpace, @ptrCast(self)), uMode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellNameSpace_get_Flags(self: *const T, pdwFlags: ?*u32) HRESULT {
                return @as(*const IShellNameSpace.VTable, @ptrCast(self.vtable)).get_Flags(@as(*const IShellNameSpace, @ptrCast(self)), pdwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellNameSpace_put_Flags(self: *const T, dwFlags: u32) HRESULT {
                return @as(*const IShellNameSpace.VTable, @ptrCast(self.vtable)).put_Flags(@as(*const IShellNameSpace, @ptrCast(self)), dwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellNameSpace_put_TVFlags(self: *const T, dwFlags: u32) HRESULT {
                return @as(*const IShellNameSpace.VTable, @ptrCast(self.vtable)).put_TVFlags(@as(*const IShellNameSpace, @ptrCast(self)), dwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellNameSpace_get_TVFlags(self: *const T, dwFlags: ?*u32) HRESULT {
                return @as(*const IShellNameSpace.VTable, @ptrCast(self.vtable)).get_TVFlags(@as(*const IShellNameSpace, @ptrCast(self)), dwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellNameSpace_get_Columns(self: *const T, bstrColumns: ?*?BSTR) HRESULT {
                return @as(*const IShellNameSpace.VTable, @ptrCast(self.vtable)).get_Columns(@as(*const IShellNameSpace, @ptrCast(self)), bstrColumns);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellNameSpace_put_Columns(self: *const T, bstrColumns: ?BSTR) HRESULT {
                return @as(*const IShellNameSpace.VTable, @ptrCast(self.vtable)).put_Columns(@as(*const IShellNameSpace, @ptrCast(self)), bstrColumns);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellNameSpace_get_CountViewTypes(self: *const T, piTypes: ?*i32) HRESULT {
                return @as(*const IShellNameSpace.VTable, @ptrCast(self.vtable)).get_CountViewTypes(@as(*const IShellNameSpace, @ptrCast(self)), piTypes);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellNameSpace_SetViewType(self: *const T, iType: i32) HRESULT {
                return @as(*const IShellNameSpace.VTable, @ptrCast(self.vtable)).SetViewType(@as(*const IShellNameSpace, @ptrCast(self)), iType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellNameSpace_SelectedItems(self: *const T, ppid: ?*?*IDispatch) HRESULT {
                return @as(*const IShellNameSpace.VTable, @ptrCast(self.vtable)).SelectedItems(@as(*const IShellNameSpace, @ptrCast(self)), ppid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellNameSpace_Expand(self: *const T, @"var": VARIANT, iDepth: i32) HRESULT {
                return @as(*const IShellNameSpace.VTable, @ptrCast(self.vtable)).Expand(@as(*const IShellNameSpace, @ptrCast(self)), @"var", iDepth);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellNameSpace_UnselectAll(self: *const T) HRESULT {
                return @as(*const IShellNameSpace.VTable, @ptrCast(self.vtable)).UnselectAll(@as(*const IShellNameSpace, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IScriptErrorList_Value = Guid.initString("f3470f24-15fd-11d2-bb2e-00805ff7efca");
pub const IID_IScriptErrorList = &IID_IScriptErrorList_Value;
pub const IScriptErrorList = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        advanceError: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IScriptErrorList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IScriptErrorList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        retreatError: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IScriptErrorList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IScriptErrorList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        canAdvanceError: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IScriptErrorList,
                pfCanAdvance: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IScriptErrorList,
                pfCanAdvance: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        canRetreatError: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IScriptErrorList,
                pfCanRetreat: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IScriptErrorList,
                pfCanRetreat: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getErrorLine: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IScriptErrorList,
                plLine: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IScriptErrorList,
                plLine: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getErrorChar: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IScriptErrorList,
                plChar: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IScriptErrorList,
                plChar: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getErrorCode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IScriptErrorList,
                plCode: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IScriptErrorList,
                plCode: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getErrorMsg: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IScriptErrorList,
                pstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IScriptErrorList,
                pstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getErrorUrl: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IScriptErrorList,
                pstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IScriptErrorList,
                pstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getAlwaysShowLockState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IScriptErrorList,
                pfAlwaysShowLocked: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IScriptErrorList,
                pfAlwaysShowLocked: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getDetailsPaneOpen: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IScriptErrorList,
                pfDetailsPaneOpen: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IScriptErrorList,
                pfDetailsPaneOpen: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        setDetailsPaneOpen: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IScriptErrorList,
                fDetailsPaneOpen: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IScriptErrorList,
                fDetailsPaneOpen: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getPerErrorDisplay: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IScriptErrorList,
                pfPerErrorDisplay: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IScriptErrorList,
                pfPerErrorDisplay: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        setPerErrorDisplay: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IScriptErrorList,
                fPerErrorDisplay: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IScriptErrorList,
                fPerErrorDisplay: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IScriptErrorList_advanceError(self: *const T) HRESULT {
                return @as(*const IScriptErrorList.VTable, @ptrCast(self.vtable)).advanceError(@as(*const IScriptErrorList, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IScriptErrorList_retreatError(self: *const T) HRESULT {
                return @as(*const IScriptErrorList.VTable, @ptrCast(self.vtable)).retreatError(@as(*const IScriptErrorList, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IScriptErrorList_canAdvanceError(self: *const T, pfCanAdvance: ?*BOOL) HRESULT {
                return @as(*const IScriptErrorList.VTable, @ptrCast(self.vtable)).canAdvanceError(@as(*const IScriptErrorList, @ptrCast(self)), pfCanAdvance);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IScriptErrorList_canRetreatError(self: *const T, pfCanRetreat: ?*BOOL) HRESULT {
                return @as(*const IScriptErrorList.VTable, @ptrCast(self.vtable)).canRetreatError(@as(*const IScriptErrorList, @ptrCast(self)), pfCanRetreat);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IScriptErrorList_getErrorLine(self: *const T, plLine: ?*i32) HRESULT {
                return @as(*const IScriptErrorList.VTable, @ptrCast(self.vtable)).getErrorLine(@as(*const IScriptErrorList, @ptrCast(self)), plLine);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IScriptErrorList_getErrorChar(self: *const T, plChar: ?*i32) HRESULT {
                return @as(*const IScriptErrorList.VTable, @ptrCast(self.vtable)).getErrorChar(@as(*const IScriptErrorList, @ptrCast(self)), plChar);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IScriptErrorList_getErrorCode(self: *const T, plCode: ?*i32) HRESULT {
                return @as(*const IScriptErrorList.VTable, @ptrCast(self.vtable)).getErrorCode(@as(*const IScriptErrorList, @ptrCast(self)), plCode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IScriptErrorList_getErrorMsg(self: *const T, pstr: ?*?BSTR) HRESULT {
                return @as(*const IScriptErrorList.VTable, @ptrCast(self.vtable)).getErrorMsg(@as(*const IScriptErrorList, @ptrCast(self)), pstr);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IScriptErrorList_getErrorUrl(self: *const T, pstr: ?*?BSTR) HRESULT {
                return @as(*const IScriptErrorList.VTable, @ptrCast(self.vtable)).getErrorUrl(@as(*const IScriptErrorList, @ptrCast(self)), pstr);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IScriptErrorList_getAlwaysShowLockState(self: *const T, pfAlwaysShowLocked: ?*BOOL) HRESULT {
                return @as(*const IScriptErrorList.VTable, @ptrCast(self.vtable)).getAlwaysShowLockState(@as(*const IScriptErrorList, @ptrCast(self)), pfAlwaysShowLocked);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IScriptErrorList_getDetailsPaneOpen(self: *const T, pfDetailsPaneOpen: ?*BOOL) HRESULT {
                return @as(*const IScriptErrorList.VTable, @ptrCast(self.vtable)).getDetailsPaneOpen(@as(*const IScriptErrorList, @ptrCast(self)), pfDetailsPaneOpen);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IScriptErrorList_setDetailsPaneOpen(self: *const T, fDetailsPaneOpen: BOOL) HRESULT {
                return @as(*const IScriptErrorList.VTable, @ptrCast(self.vtable)).setDetailsPaneOpen(@as(*const IScriptErrorList, @ptrCast(self)), fDetailsPaneOpen);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IScriptErrorList_getPerErrorDisplay(self: *const T, pfPerErrorDisplay: ?*BOOL) HRESULT {
                return @as(*const IScriptErrorList.VTable, @ptrCast(self.vtable)).getPerErrorDisplay(@as(*const IScriptErrorList, @ptrCast(self)), pfPerErrorDisplay);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IScriptErrorList_setPerErrorDisplay(self: *const T, fPerErrorDisplay: BOOL) HRESULT {
                return @as(*const IScriptErrorList.VTable, @ptrCast(self.vtable)).setPerErrorDisplay(@as(*const IScriptErrorList, @ptrCast(self)), fPerErrorDisplay);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const CLSID_ShellFolderViewOC_Value = Guid.initString("9ba05971-f6a8-11cf-a442-00a0c90a8f39");
pub const CLSID_ShellFolderViewOC = &CLSID_ShellFolderViewOC_Value;

const CLSID_ShellFolderItem_Value = Guid.initString("2fe352ea-fd1f-11d2-b1f4-00c04f8eeb3e");
pub const CLSID_ShellFolderItem = &CLSID_ShellFolderItem_Value;

const CLSID_ShellLinkObject_Value = Guid.initString("11219420-1768-11d1-95be-00609797ea4f");
pub const CLSID_ShellLinkObject = &CLSID_ShellLinkObject_Value;

const CLSID_ShellFolderView_Value = Guid.initString("62112aa1-ebe4-11cf-a5fb-0020afe7292d");
pub const CLSID_ShellFolderView = &CLSID_ShellFolderView_Value;

const CLSID_Shell_Value = Guid.initString("13709620-c279-11ce-a49e-444553540000");
pub const CLSID_Shell = &CLSID_Shell_Value;

const CLSID_ShellDispatchInproc_Value = Guid.initString("0a89a860-d7b1-11ce-8350-444553540000");
pub const CLSID_ShellDispatchInproc = &CLSID_ShellDispatchInproc_Value;

const CLSID_FileSearchBand_Value = Guid.initString("c4ee31f3-4768-11d2-be5c-00a0c9a83da1");
pub const CLSID_FileSearchBand = &CLSID_FileSearchBand_Value;

pub const OfflineFolderStatus = enum(i32) {
    INACTIVE = -1,
    ONLINE = 0,
    OFFLINE = 1,
    SERVERBACK = 2,
    DIRTYCACHE = 3,
};
pub const OFS_INACTIVE = OfflineFolderStatus.INACTIVE;
pub const OFS_ONLINE = OfflineFolderStatus.ONLINE;
pub const OFS_OFFLINE = OfflineFolderStatus.OFFLINE;
pub const OFS_SERVERBACK = OfflineFolderStatus.SERVERBACK;
pub const OFS_DIRTYCACHE = OfflineFolderStatus.DIRTYCACHE;

pub const ShellFolderViewOptions = enum(i32) {
    SHOWALLOBJECTS = 1,
    SHOWEXTENSIONS = 2,
    SHOWCOMPCOLOR = 8,
    SHOWSYSFILES = 32,
    WIN95CLASSIC = 64,
    DOUBLECLICKINWEBVIEW = 128,
    DESKTOPHTML = 512,
};
pub const SFVVO_SHOWALLOBJECTS = ShellFolderViewOptions.SHOWALLOBJECTS;
pub const SFVVO_SHOWEXTENSIONS = ShellFolderViewOptions.SHOWEXTENSIONS;
pub const SFVVO_SHOWCOMPCOLOR = ShellFolderViewOptions.SHOWCOMPCOLOR;
pub const SFVVO_SHOWSYSFILES = ShellFolderViewOptions.SHOWSYSFILES;
pub const SFVVO_WIN95CLASSIC = ShellFolderViewOptions.WIN95CLASSIC;
pub const SFVVO_DOUBLECLICKINWEBVIEW = ShellFolderViewOptions.DOUBLECLICKINWEBVIEW;
pub const SFVVO_DESKTOPHTML = ShellFolderViewOptions.DESKTOPHTML;

pub const ShellSpecialFolderConstants = enum(i32) {
    DESKTOP = 0,
    PROGRAMS = 2,
    CONTROLS = 3,
    PRINTERS = 4,
    PERSONAL = 5,
    FAVORITES = 6,
    STARTUP = 7,
    RECENT = 8,
    SENDTO = 9,
    BITBUCKET = 10,
    STARTMENU = 11,
    DESKTOPDIRECTORY = 16,
    DRIVES = 17,
    NETWORK = 18,
    NETHOOD = 19,
    FONTS = 20,
    TEMPLATES = 21,
    COMMONSTARTMENU = 22,
    COMMONPROGRAMS = 23,
    COMMONSTARTUP = 24,
    COMMONDESKTOPDIR = 25,
    APPDATA = 26,
    PRINTHOOD = 27,
    LOCALAPPDATA = 28,
    ALTSTARTUP = 29,
    COMMONALTSTARTUP = 30,
    COMMONFAVORITES = 31,
    INTERNETCACHE = 32,
    COOKIES = 33,
    HISTORY = 34,
    COMMONAPPDATA = 35,
    WINDOWS = 36,
    SYSTEM = 37,
    PROGRAMFILES = 38,
    MYPICTURES = 39,
    PROFILE = 40,
    SYSTEMx86 = 41,
    PROGRAMFILESx86 = 48,
};
pub const ssfDESKTOP = ShellSpecialFolderConstants.DESKTOP;
pub const ssfPROGRAMS = ShellSpecialFolderConstants.PROGRAMS;
pub const ssfCONTROLS = ShellSpecialFolderConstants.CONTROLS;
pub const ssfPRINTERS = ShellSpecialFolderConstants.PRINTERS;
pub const ssfPERSONAL = ShellSpecialFolderConstants.PERSONAL;
pub const ssfFAVORITES = ShellSpecialFolderConstants.FAVORITES;
pub const ssfSTARTUP = ShellSpecialFolderConstants.STARTUP;
pub const ssfRECENT = ShellSpecialFolderConstants.RECENT;
pub const ssfSENDTO = ShellSpecialFolderConstants.SENDTO;
pub const ssfBITBUCKET = ShellSpecialFolderConstants.BITBUCKET;
pub const ssfSTARTMENU = ShellSpecialFolderConstants.STARTMENU;
pub const ssfDESKTOPDIRECTORY = ShellSpecialFolderConstants.DESKTOPDIRECTORY;
pub const ssfDRIVES = ShellSpecialFolderConstants.DRIVES;
pub const ssfNETWORK = ShellSpecialFolderConstants.NETWORK;
pub const ssfNETHOOD = ShellSpecialFolderConstants.NETHOOD;
pub const ssfFONTS = ShellSpecialFolderConstants.FONTS;
pub const ssfTEMPLATES = ShellSpecialFolderConstants.TEMPLATES;
pub const ssfCOMMONSTARTMENU = ShellSpecialFolderConstants.COMMONSTARTMENU;
pub const ssfCOMMONPROGRAMS = ShellSpecialFolderConstants.COMMONPROGRAMS;
pub const ssfCOMMONSTARTUP = ShellSpecialFolderConstants.COMMONSTARTUP;
pub const ssfCOMMONDESKTOPDIR = ShellSpecialFolderConstants.COMMONDESKTOPDIR;
pub const ssfAPPDATA = ShellSpecialFolderConstants.APPDATA;
pub const ssfPRINTHOOD = ShellSpecialFolderConstants.PRINTHOOD;
pub const ssfLOCALAPPDATA = ShellSpecialFolderConstants.LOCALAPPDATA;
pub const ssfALTSTARTUP = ShellSpecialFolderConstants.ALTSTARTUP;
pub const ssfCOMMONALTSTARTUP = ShellSpecialFolderConstants.COMMONALTSTARTUP;
pub const ssfCOMMONFAVORITES = ShellSpecialFolderConstants.COMMONFAVORITES;
pub const ssfINTERNETCACHE = ShellSpecialFolderConstants.INTERNETCACHE;
pub const ssfCOOKIES = ShellSpecialFolderConstants.COOKIES;
pub const ssfHISTORY = ShellSpecialFolderConstants.HISTORY;
pub const ssfCOMMONAPPDATA = ShellSpecialFolderConstants.COMMONAPPDATA;
pub const ssfWINDOWS = ShellSpecialFolderConstants.WINDOWS;
pub const ssfSYSTEM = ShellSpecialFolderConstants.SYSTEM;
pub const ssfPROGRAMFILES = ShellSpecialFolderConstants.PROGRAMFILES;
pub const ssfMYPICTURES = ShellSpecialFolderConstants.MYPICTURES;
pub const ssfPROFILE = ShellSpecialFolderConstants.PROFILE;
pub const ssfSYSTEMx86 = ShellSpecialFolderConstants.SYSTEMx86;
pub const ssfPROGRAMFILESx86 = ShellSpecialFolderConstants.PROGRAMFILESx86;

const IID_IFolderViewOC_Value = Guid.initString("9ba05970-f6a8-11cf-a442-00a0c90a8f39");
pub const IID_IFolderViewOC = &IID_IFolderViewOC_Value;
pub const IFolderViewOC = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        SetFolderView: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFolderViewOC,
                pdisp: ?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFolderViewOC,
                pdisp: ?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFolderViewOC_SetFolderView(self: *const T, pdisp: ?*IDispatch) HRESULT {
                return @as(*const IFolderViewOC.VTable, @ptrCast(self.vtable)).SetFolderView(@as(*const IFolderViewOC, @ptrCast(self)), pdisp);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_DShellFolderViewEvents_Value = Guid.initString("62112aa2-ebe4-11cf-a5fb-0020afe7292d");
pub const IID_DShellFolderViewEvents = &IID_DShellFolderViewEvents_Value;
pub const DShellFolderViewEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_DFConstraint_Value = Guid.initString("4a3df050-23bd-11d2-939f-00a0c91eedba");
pub const IID_DFConstraint = &IID_DFConstraint_Value;
pub const DFConstraint = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const DFConstraint,
                pbs: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const DFConstraint,
                pbs: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Value: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const DFConstraint,
                pv: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const DFConstraint,
                pv: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn DFConstraint_get_Name(self: *const T, pbs: ?*?BSTR) HRESULT {
                return @as(*const DFConstraint.VTable, @ptrCast(self.vtable)).get_Name(@as(*const DFConstraint, @ptrCast(self)), pbs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn DFConstraint_get_Value(self: *const T, pv: ?*VARIANT) HRESULT {
                return @as(*const DFConstraint.VTable, @ptrCast(self.vtable)).get_Value(@as(*const DFConstraint, @ptrCast(self)), pv);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_FolderItem_Value = Guid.initString("fac32c80-cbe4-11ce-8350-444553540000");
pub const IID_FolderItem = &IID_FolderItem_Value;
pub const FolderItem = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Application: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const FolderItem,
                ppid: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const FolderItem,
                ppid: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Parent: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const FolderItem,
                ppid: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const FolderItem,
                ppid: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const FolderItem,
                pbs: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const FolderItem,
                pbs: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Name: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const FolderItem,
                bs: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const FolderItem,
                bs: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Path: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const FolderItem,
                pbs: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const FolderItem,
                pbs: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_GetLink: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const FolderItem,
                ppid: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const FolderItem,
                ppid: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_GetFolder: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const FolderItem,
                ppid: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const FolderItem,
                ppid: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsLink: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const FolderItem,
                pb: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const FolderItem,
                pb: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsFolder: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const FolderItem,
                pb: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const FolderItem,
                pb: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsFileSystem: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const FolderItem,
                pb: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const FolderItem,
                pb: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsBrowsable: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const FolderItem,
                pb: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const FolderItem,
                pb: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ModifyDate: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const FolderItem,
                pdt: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const FolderItem,
                pdt: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ModifyDate: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const FolderItem,
                dt: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const FolderItem,
                dt: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Size: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const FolderItem,
                pul: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const FolderItem,
                pul: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Type: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const FolderItem,
                pbs: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const FolderItem,
                pbs: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Verbs: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const FolderItem,
                ppfic: ?*?*FolderItemVerbs,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const FolderItem,
                ppfic: ?*?*FolderItemVerbs,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InvokeVerb: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const FolderItem,
                vVerb: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const FolderItem,
                vVerb: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn FolderItem_get_Application(self: *const T, ppid: ?*?*IDispatch) HRESULT {
                return @as(*const FolderItem.VTable, @ptrCast(self.vtable)).get_Application(@as(*const FolderItem, @ptrCast(self)), ppid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn FolderItem_get_Parent(self: *const T, ppid: ?*?*IDispatch) HRESULT {
                return @as(*const FolderItem.VTable, @ptrCast(self.vtable)).get_Parent(@as(*const FolderItem, @ptrCast(self)), ppid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn FolderItem_get_Name(self: *const T, pbs: ?*?BSTR) HRESULT {
                return @as(*const FolderItem.VTable, @ptrCast(self.vtable)).get_Name(@as(*const FolderItem, @ptrCast(self)), pbs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn FolderItem_put_Name(self: *const T, bs: ?BSTR) HRESULT {
                return @as(*const FolderItem.VTable, @ptrCast(self.vtable)).put_Name(@as(*const FolderItem, @ptrCast(self)), bs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn FolderItem_get_Path(self: *const T, pbs: ?*?BSTR) HRESULT {
                return @as(*const FolderItem.VTable, @ptrCast(self.vtable)).get_Path(@as(*const FolderItem, @ptrCast(self)), pbs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn FolderItem_get_GetLink(self: *const T, ppid: ?*?*IDispatch) HRESULT {
                return @as(*const FolderItem.VTable, @ptrCast(self.vtable)).get_GetLink(@as(*const FolderItem, @ptrCast(self)), ppid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn FolderItem_get_GetFolder(self: *const T, ppid: ?*?*IDispatch) HRESULT {
                return @as(*const FolderItem.VTable, @ptrCast(self.vtable)).get_GetFolder(@as(*const FolderItem, @ptrCast(self)), ppid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn FolderItem_get_IsLink(self: *const T, pb: ?*i16) HRESULT {
                return @as(*const FolderItem.VTable, @ptrCast(self.vtable)).get_IsLink(@as(*const FolderItem, @ptrCast(self)), pb);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn FolderItem_get_IsFolder(self: *const T, pb: ?*i16) HRESULT {
                return @as(*const FolderItem.VTable, @ptrCast(self.vtable)).get_IsFolder(@as(*const FolderItem, @ptrCast(self)), pb);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn FolderItem_get_IsFileSystem(self: *const T, pb: ?*i16) HRESULT {
                return @as(*const FolderItem.VTable, @ptrCast(self.vtable)).get_IsFileSystem(@as(*const FolderItem, @ptrCast(self)), pb);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn FolderItem_get_IsBrowsable(self: *const T, pb: ?*i16) HRESULT {
                return @as(*const FolderItem.VTable, @ptrCast(self.vtable)).get_IsBrowsable(@as(*const FolderItem, @ptrCast(self)), pb);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn FolderItem_get_ModifyDate(self: *const T, pdt: ?*f64) HRESULT {
                return @as(*const FolderItem.VTable, @ptrCast(self.vtable)).get_ModifyDate(@as(*const FolderItem, @ptrCast(self)), pdt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn FolderItem_put_ModifyDate(self: *const T, dt: f64) HRESULT {
                return @as(*const FolderItem.VTable, @ptrCast(self.vtable)).put_ModifyDate(@as(*const FolderItem, @ptrCast(self)), dt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn FolderItem_get_Size(self: *const T, pul: ?*i32) HRESULT {
                return @as(*const FolderItem.VTable, @ptrCast(self.vtable)).get_Size(@as(*const FolderItem, @ptrCast(self)), pul);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn FolderItem_get_Type(self: *const T, pbs: ?*?BSTR) HRESULT {
                return @as(*const FolderItem.VTable, @ptrCast(self.vtable)).get_Type(@as(*const FolderItem, @ptrCast(self)), pbs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn FolderItem_Verbs(self: *const T, ppfic: ?*?*FolderItemVerbs) HRESULT {
                return @as(*const FolderItem.VTable, @ptrCast(self.vtable)).Verbs(@as(*const FolderItem, @ptrCast(self)), ppfic);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn FolderItem_InvokeVerb(self: *const T, vVerb: VARIANT) HRESULT {
                return @as(*const FolderItem.VTable, @ptrCast(self.vtable)).InvokeVerb(@as(*const FolderItem, @ptrCast(self)), vVerb);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_FolderItems_Value = Guid.initString("744129e0-cbe5-11ce-8350-444553540000");
pub const IID_FolderItems = &IID_FolderItems_Value;
pub const FolderItems = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const FolderItems,
                plCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const FolderItems,
                plCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Application: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const FolderItems,
                ppid: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const FolderItems,
                ppid: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Parent: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const FolderItems,
                ppid: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const FolderItems,
                ppid: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Item: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const FolderItems,
                index: VARIANT,
                ppid: ?*?*FolderItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const FolderItems,
                index: VARIANT,
                ppid: ?*?*FolderItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        _NewEnum: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const FolderItems,
                ppunk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const FolderItems,
                ppunk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn FolderItems_get_Count(self: *const T, plCount: ?*i32) HRESULT {
                return @as(*const FolderItems.VTable, @ptrCast(self.vtable)).get_Count(@as(*const FolderItems, @ptrCast(self)), plCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn FolderItems_get_Application(self: *const T, ppid: ?*?*IDispatch) HRESULT {
                return @as(*const FolderItems.VTable, @ptrCast(self.vtable)).get_Application(@as(*const FolderItems, @ptrCast(self)), ppid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn FolderItems_get_Parent(self: *const T, ppid: ?*?*IDispatch) HRESULT {
                return @as(*const FolderItems.VTable, @ptrCast(self.vtable)).get_Parent(@as(*const FolderItems, @ptrCast(self)), ppid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn FolderItems_Item(self: *const T, index: VARIANT, ppid: ?*?*FolderItem) HRESULT {
                return @as(*const FolderItems.VTable, @ptrCast(self.vtable)).Item(@as(*const FolderItems, @ptrCast(self)), index, ppid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn FolderItems__NewEnum(self: *const T, ppunk: ?*?*IUnknown) HRESULT {
                return @as(*const FolderItems.VTable, @ptrCast(self.vtable))._NewEnum(@as(*const FolderItems, @ptrCast(self)), ppunk);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_FolderItemVerb_Value = Guid.initString("08ec3e00-50b0-11cf-960c-0080c7f4ee85");
pub const IID_FolderItemVerb = &IID_FolderItemVerb_Value;
pub const FolderItemVerb = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Application: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const FolderItemVerb,
                ppid: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const FolderItemVerb,
                ppid: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Parent: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const FolderItemVerb,
                ppid: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const FolderItemVerb,
                ppid: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const FolderItemVerb,
                pbs: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const FolderItemVerb,
                pbs: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DoIt: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const FolderItemVerb,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const FolderItemVerb,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn FolderItemVerb_get_Application(self: *const T, ppid: ?*?*IDispatch) HRESULT {
                return @as(*const FolderItemVerb.VTable, @ptrCast(self.vtable)).get_Application(@as(*const FolderItemVerb, @ptrCast(self)), ppid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn FolderItemVerb_get_Parent(self: *const T, ppid: ?*?*IDispatch) HRESULT {
                return @as(*const FolderItemVerb.VTable, @ptrCast(self.vtable)).get_Parent(@as(*const FolderItemVerb, @ptrCast(self)), ppid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn FolderItemVerb_get_Name(self: *const T, pbs: ?*?BSTR) HRESULT {
                return @as(*const FolderItemVerb.VTable, @ptrCast(self.vtable)).get_Name(@as(*const FolderItemVerb, @ptrCast(self)), pbs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn FolderItemVerb_DoIt(self: *const T) HRESULT {
                return @as(*const FolderItemVerb.VTable, @ptrCast(self.vtable)).DoIt(@as(*const FolderItemVerb, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_FolderItemVerbs_Value = Guid.initString("1f8352c0-50b0-11cf-960c-0080c7f4ee85");
pub const IID_FolderItemVerbs = &IID_FolderItemVerbs_Value;
pub const FolderItemVerbs = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const FolderItemVerbs,
                plCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const FolderItemVerbs,
                plCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Application: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const FolderItemVerbs,
                ppid: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const FolderItemVerbs,
                ppid: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Parent: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const FolderItemVerbs,
                ppid: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const FolderItemVerbs,
                ppid: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Item: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const FolderItemVerbs,
                index: VARIANT,
                ppid: ?*?*FolderItemVerb,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const FolderItemVerbs,
                index: VARIANT,
                ppid: ?*?*FolderItemVerb,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        _NewEnum: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const FolderItemVerbs,
                ppunk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const FolderItemVerbs,
                ppunk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn FolderItemVerbs_get_Count(self: *const T, plCount: ?*i32) HRESULT {
                return @as(*const FolderItemVerbs.VTable, @ptrCast(self.vtable)).get_Count(@as(*const FolderItemVerbs, @ptrCast(self)), plCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn FolderItemVerbs_get_Application(self: *const T, ppid: ?*?*IDispatch) HRESULT {
                return @as(*const FolderItemVerbs.VTable, @ptrCast(self.vtable)).get_Application(@as(*const FolderItemVerbs, @ptrCast(self)), ppid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn FolderItemVerbs_get_Parent(self: *const T, ppid: ?*?*IDispatch) HRESULT {
                return @as(*const FolderItemVerbs.VTable, @ptrCast(self.vtable)).get_Parent(@as(*const FolderItemVerbs, @ptrCast(self)), ppid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn FolderItemVerbs_Item(self: *const T, index: VARIANT, ppid: ?*?*FolderItemVerb) HRESULT {
                return @as(*const FolderItemVerbs.VTable, @ptrCast(self.vtable)).Item(@as(*const FolderItemVerbs, @ptrCast(self)), index, ppid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn FolderItemVerbs__NewEnum(self: *const T, ppunk: ?*?*IUnknown) HRESULT {
                return @as(*const FolderItemVerbs.VTable, @ptrCast(self.vtable))._NewEnum(@as(*const FolderItemVerbs, @ptrCast(self)), ppunk);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_Folder_Value = Guid.initString("bbcbde60-c3ff-11ce-8350-444553540000");
pub const IID_Folder = &IID_Folder_Value;
pub const Folder = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Title: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const Folder,
                pbs: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const Folder,
                pbs: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Application: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const Folder,
                ppid: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const Folder,
                ppid: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Parent: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const Folder,
                ppid: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const Folder,
                ppid: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ParentFolder: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const Folder,
                ppsf: ?*?*Folder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const Folder,
                ppsf: ?*?*Folder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Items: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const Folder,
                ppid: ?*?*FolderItems,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const Folder,
                ppid: ?*?*FolderItems,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ParseName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const Folder,
                bName: ?BSTR,
                ppid: ?*?*FolderItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const Folder,
                bName: ?BSTR,
                ppid: ?*?*FolderItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NewFolder: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const Folder,
                bName: ?BSTR,
                vOptions: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const Folder,
                bName: ?BSTR,
                vOptions: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        MoveHere: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const Folder,
                vItem: VARIANT,
                vOptions: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const Folder,
                vItem: VARIANT,
                vOptions: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CopyHere: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const Folder,
                vItem: VARIANT,
                vOptions: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const Folder,
                vItem: VARIANT,
                vOptions: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDetailsOf: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const Folder,
                vItem: VARIANT,
                iColumn: i32,
                pbs: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const Folder,
                vItem: VARIANT,
                iColumn: i32,
                pbs: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn Folder_get_Title(self: *const T, pbs: ?*?BSTR) HRESULT {
                return @as(*const Folder.VTable, @ptrCast(self.vtable)).get_Title(@as(*const Folder, @ptrCast(self)), pbs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn Folder_get_Application(self: *const T, ppid: ?*?*IDispatch) HRESULT {
                return @as(*const Folder.VTable, @ptrCast(self.vtable)).get_Application(@as(*const Folder, @ptrCast(self)), ppid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn Folder_get_Parent(self: *const T, ppid: ?*?*IDispatch) HRESULT {
                return @as(*const Folder.VTable, @ptrCast(self.vtable)).get_Parent(@as(*const Folder, @ptrCast(self)), ppid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn Folder_get_ParentFolder(self: *const T, ppsf: ?*?*Folder) HRESULT {
                return @as(*const Folder.VTable, @ptrCast(self.vtable)).get_ParentFolder(@as(*const Folder, @ptrCast(self)), ppsf);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn Folder_Items(self: *const T, ppid: ?*?*FolderItems) HRESULT {
                return @as(*const Folder.VTable, @ptrCast(self.vtable)).Items(@as(*const Folder, @ptrCast(self)), ppid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn Folder_ParseName(self: *const T, bName: ?BSTR, ppid: ?*?*FolderItem) HRESULT {
                return @as(*const Folder.VTable, @ptrCast(self.vtable)).ParseName(@as(*const Folder, @ptrCast(self)), bName, ppid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn Folder_NewFolder(self: *const T, bName: ?BSTR, vOptions: VARIANT) HRESULT {
                return @as(*const Folder.VTable, @ptrCast(self.vtable)).NewFolder(@as(*const Folder, @ptrCast(self)), bName, vOptions);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn Folder_MoveHere(self: *const T, vItem: VARIANT, vOptions: VARIANT) HRESULT {
                return @as(*const Folder.VTable, @ptrCast(self.vtable)).MoveHere(@as(*const Folder, @ptrCast(self)), vItem, vOptions);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn Folder_CopyHere(self: *const T, vItem: VARIANT, vOptions: VARIANT) HRESULT {
                return @as(*const Folder.VTable, @ptrCast(self.vtable)).CopyHere(@as(*const Folder, @ptrCast(self)), vItem, vOptions);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn Folder_GetDetailsOf(self: *const T, vItem: VARIANT, iColumn: i32, pbs: ?*?BSTR) HRESULT {
                return @as(*const Folder.VTable, @ptrCast(self.vtable)).GetDetailsOf(@as(*const Folder, @ptrCast(self)), vItem, iColumn, pbs);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_Folder2_Value = Guid.initString("f0d2d8ef-3890-11d2-bf8b-00c04fb93661");
pub const IID_Folder2 = &IID_Folder2_Value;
pub const Folder2 = extern struct {
    pub const VTable = extern struct {
        base: Folder.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Self: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const Folder2,
                ppfi: ?*?*FolderItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const Folder2,
                ppfi: ?*?*FolderItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_OfflineStatus: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const Folder2,
                pul: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const Folder2,
                pul: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Synchronize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const Folder2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const Folder2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HaveToShowWebViewBarricade: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const Folder2,
                pbHaveToShowWebViewBarricade: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const Folder2,
                pbHaveToShowWebViewBarricade: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DismissedWebViewBarricade: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const Folder2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const Folder2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace Folder.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn Folder2_get_Self(self: *const T, ppfi: ?*?*FolderItem) HRESULT {
                return @as(*const Folder2.VTable, @ptrCast(self.vtable)).get_Self(@as(*const Folder2, @ptrCast(self)), ppfi);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn Folder2_get_OfflineStatus(self: *const T, pul: ?*i32) HRESULT {
                return @as(*const Folder2.VTable, @ptrCast(self.vtable)).get_OfflineStatus(@as(*const Folder2, @ptrCast(self)), pul);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn Folder2_Synchronize(self: *const T) HRESULT {
                return @as(*const Folder2.VTable, @ptrCast(self.vtable)).Synchronize(@as(*const Folder2, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn Folder2_get_HaveToShowWebViewBarricade(self: *const T, pbHaveToShowWebViewBarricade: ?*i16) HRESULT {
                return @as(*const Folder2.VTable, @ptrCast(self.vtable)).get_HaveToShowWebViewBarricade(@as(*const Folder2, @ptrCast(self)), pbHaveToShowWebViewBarricade);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn Folder2_DismissedWebViewBarricade(self: *const T) HRESULT {
                return @as(*const Folder2.VTable, @ptrCast(self.vtable)).DismissedWebViewBarricade(@as(*const Folder2, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_Folder3_Value = Guid.initString("a7ae5f64-c4d7-4d7f-9307-4d24ee54b841");
pub const IID_Folder3 = &IID_Folder3_Value;
pub const Folder3 = extern struct {
    pub const VTable = extern struct {
        base: Folder2.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ShowWebViewBarricade: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const Folder3,
                pbShowWebViewBarricade: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const Folder3,
                pbShowWebViewBarricade: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ShowWebViewBarricade: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const Folder3,
                bShowWebViewBarricade: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const Folder3,
                bShowWebViewBarricade: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace Folder2.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn Folder3_get_ShowWebViewBarricade(self: *const T, pbShowWebViewBarricade: ?*i16) HRESULT {
                return @as(*const Folder3.VTable, @ptrCast(self.vtable)).get_ShowWebViewBarricade(@as(*const Folder3, @ptrCast(self)), pbShowWebViewBarricade);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn Folder3_put_ShowWebViewBarricade(self: *const T, bShowWebViewBarricade: i16) HRESULT {
                return @as(*const Folder3.VTable, @ptrCast(self.vtable)).put_ShowWebViewBarricade(@as(*const Folder3, @ptrCast(self)), bShowWebViewBarricade);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_FolderItem2_Value = Guid.initString("edc817aa-92b8-11d1-b075-00c04fc33aa5");
pub const IID_FolderItem2 = &IID_FolderItem2_Value;
pub const FolderItem2 = extern struct {
    pub const VTable = extern struct {
        base: FolderItem.VTable,
        InvokeVerbEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const FolderItem2,
                vVerb: VARIANT,
                vArgs: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const FolderItem2,
                vVerb: VARIANT,
                vArgs: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExtendedProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const FolderItem2,
                bstrPropName: ?BSTR,
                pvRet: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const FolderItem2,
                bstrPropName: ?BSTR,
                pvRet: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace FolderItem.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn FolderItem2_InvokeVerbEx(self: *const T, vVerb: VARIANT, vArgs: VARIANT) HRESULT {
                return @as(*const FolderItem2.VTable, @ptrCast(self.vtable)).InvokeVerbEx(@as(*const FolderItem2, @ptrCast(self)), vVerb, vArgs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn FolderItem2_ExtendedProperty(self: *const T, bstrPropName: ?BSTR, pvRet: ?*VARIANT) HRESULT {
                return @as(*const FolderItem2.VTable, @ptrCast(self.vtable)).ExtendedProperty(@as(*const FolderItem2, @ptrCast(self)), bstrPropName, pvRet);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_FolderItems2_Value = Guid.initString("c94f0ad0-f363-11d2-a327-00c04f8eec7f");
pub const IID_FolderItems2 = &IID_FolderItems2_Value;
pub const FolderItems2 = extern struct {
    pub const VTable = extern struct {
        base: FolderItems.VTable,
        InvokeVerbEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const FolderItems2,
                vVerb: VARIANT,
                vArgs: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const FolderItems2,
                vVerb: VARIANT,
                vArgs: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace FolderItems.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn FolderItems2_InvokeVerbEx(self: *const T, vVerb: VARIANT, vArgs: VARIANT) HRESULT {
                return @as(*const FolderItems2.VTable, @ptrCast(self.vtable)).InvokeVerbEx(@as(*const FolderItems2, @ptrCast(self)), vVerb, vArgs);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_FolderItems3_Value = Guid.initString("eaa7c309-bbec-49d5-821d-64d966cb667f");
pub const IID_FolderItems3 = &IID_FolderItems3_Value;
pub const FolderItems3 = extern struct {
    pub const VTable = extern struct {
        base: FolderItems2.VTable,
        Filter: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const FolderItems3,
                grfFlags: i32,
                bstrFileSpec: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const FolderItems3,
                grfFlags: i32,
                bstrFileSpec: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Verbs: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const FolderItems3,
                ppfic: ?*?*FolderItemVerbs,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const FolderItems3,
                ppfic: ?*?*FolderItemVerbs,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace FolderItems2.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn FolderItems3_Filter(self: *const T, grfFlags: i32, bstrFileSpec: ?BSTR) HRESULT {
                return @as(*const FolderItems3.VTable, @ptrCast(self.vtable)).Filter(@as(*const FolderItems3, @ptrCast(self)), grfFlags, bstrFileSpec);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn FolderItems3_get_Verbs(self: *const T, ppfic: ?*?*FolderItemVerbs) HRESULT {
                return @as(*const FolderItems3.VTable, @ptrCast(self.vtable)).get_Verbs(@as(*const FolderItems3, @ptrCast(self)), ppfic);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IShellLinkDual_Value = Guid.initString("88a05c00-f000-11ce-8350-444553540000");
pub const IID_IShellLinkDual = &IID_IShellLinkDual_Value;
pub const IShellLinkDual = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Path: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IShellLinkDual,
                pbs: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IShellLinkDual,
                pbs: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Path: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IShellLinkDual,
                bs: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IShellLinkDual,
                bs: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Description: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IShellLinkDual,
                pbs: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IShellLinkDual,
                pbs: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Description: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IShellLinkDual,
                bs: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IShellLinkDual,
                bs: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_WorkingDirectory: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IShellLinkDual,
                pbs: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IShellLinkDual,
                pbs: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_WorkingDirectory: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IShellLinkDual,
                bs: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IShellLinkDual,
                bs: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Arguments: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IShellLinkDual,
                pbs: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IShellLinkDual,
                pbs: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Arguments: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IShellLinkDual,
                bs: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IShellLinkDual,
                bs: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Hotkey: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IShellLinkDual,
                piHK: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IShellLinkDual,
                piHK: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Hotkey: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IShellLinkDual,
                iHK: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IShellLinkDual,
                iHK: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ShowCommand: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IShellLinkDual,
                piShowCommand: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IShellLinkDual,
                piShowCommand: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ShowCommand: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IShellLinkDual,
                iShowCommand: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IShellLinkDual,
                iShowCommand: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Resolve: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellLinkDual,
                fFlags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellLinkDual,
                fFlags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIconLocation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellLinkDual,
                pbs: ?*?BSTR,
                piIcon: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellLinkDual,
                pbs: ?*?BSTR,
                piIcon: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetIconLocation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellLinkDual,
                bs: ?BSTR,
                iIcon: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellLinkDual,
                bs: ?BSTR,
                iIcon: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Save: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellLinkDual,
                vWhere: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellLinkDual,
                vWhere: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellLinkDual_get_Path(self: *const T, pbs: ?*?BSTR) HRESULT {
                return @as(*const IShellLinkDual.VTable, @ptrCast(self.vtable)).get_Path(@as(*const IShellLinkDual, @ptrCast(self)), pbs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellLinkDual_put_Path(self: *const T, bs: ?BSTR) HRESULT {
                return @as(*const IShellLinkDual.VTable, @ptrCast(self.vtable)).put_Path(@as(*const IShellLinkDual, @ptrCast(self)), bs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellLinkDual_get_Description(self: *const T, pbs: ?*?BSTR) HRESULT {
                return @as(*const IShellLinkDual.VTable, @ptrCast(self.vtable)).get_Description(@as(*const IShellLinkDual, @ptrCast(self)), pbs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellLinkDual_put_Description(self: *const T, bs: ?BSTR) HRESULT {
                return @as(*const IShellLinkDual.VTable, @ptrCast(self.vtable)).put_Description(@as(*const IShellLinkDual, @ptrCast(self)), bs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellLinkDual_get_WorkingDirectory(self: *const T, pbs: ?*?BSTR) HRESULT {
                return @as(*const IShellLinkDual.VTable, @ptrCast(self.vtable)).get_WorkingDirectory(@as(*const IShellLinkDual, @ptrCast(self)), pbs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellLinkDual_put_WorkingDirectory(self: *const T, bs: ?BSTR) HRESULT {
                return @as(*const IShellLinkDual.VTable, @ptrCast(self.vtable)).put_WorkingDirectory(@as(*const IShellLinkDual, @ptrCast(self)), bs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellLinkDual_get_Arguments(self: *const T, pbs: ?*?BSTR) HRESULT {
                return @as(*const IShellLinkDual.VTable, @ptrCast(self.vtable)).get_Arguments(@as(*const IShellLinkDual, @ptrCast(self)), pbs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellLinkDual_put_Arguments(self: *const T, bs: ?BSTR) HRESULT {
                return @as(*const IShellLinkDual.VTable, @ptrCast(self.vtable)).put_Arguments(@as(*const IShellLinkDual, @ptrCast(self)), bs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellLinkDual_get_Hotkey(self: *const T, piHK: ?*i32) HRESULT {
                return @as(*const IShellLinkDual.VTable, @ptrCast(self.vtable)).get_Hotkey(@as(*const IShellLinkDual, @ptrCast(self)), piHK);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellLinkDual_put_Hotkey(self: *const T, iHK: i32) HRESULT {
                return @as(*const IShellLinkDual.VTable, @ptrCast(self.vtable)).put_Hotkey(@as(*const IShellLinkDual, @ptrCast(self)), iHK);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellLinkDual_get_ShowCommand(self: *const T, piShowCommand: ?*i32) HRESULT {
                return @as(*const IShellLinkDual.VTable, @ptrCast(self.vtable)).get_ShowCommand(@as(*const IShellLinkDual, @ptrCast(self)), piShowCommand);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellLinkDual_put_ShowCommand(self: *const T, iShowCommand: i32) HRESULT {
                return @as(*const IShellLinkDual.VTable, @ptrCast(self.vtable)).put_ShowCommand(@as(*const IShellLinkDual, @ptrCast(self)), iShowCommand);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellLinkDual_Resolve(self: *const T, fFlags: i32) HRESULT {
                return @as(*const IShellLinkDual.VTable, @ptrCast(self.vtable)).Resolve(@as(*const IShellLinkDual, @ptrCast(self)), fFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellLinkDual_GetIconLocation(self: *const T, pbs: ?*?BSTR, piIcon: ?*i32) HRESULT {
                return @as(*const IShellLinkDual.VTable, @ptrCast(self.vtable)).GetIconLocation(@as(*const IShellLinkDual, @ptrCast(self)), pbs, piIcon);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellLinkDual_SetIconLocation(self: *const T, bs: ?BSTR, iIcon: i32) HRESULT {
                return @as(*const IShellLinkDual.VTable, @ptrCast(self.vtable)).SetIconLocation(@as(*const IShellLinkDual, @ptrCast(self)), bs, iIcon);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellLinkDual_Save(self: *const T, vWhere: VARIANT) HRESULT {
                return @as(*const IShellLinkDual.VTable, @ptrCast(self.vtable)).Save(@as(*const IShellLinkDual, @ptrCast(self)), vWhere);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IShellLinkDual2_Value = Guid.initString("317ee249-f12e-11d2-b1e4-00c04f8eeb3e");
pub const IID_IShellLinkDual2 = &IID_IShellLinkDual2_Value;
pub const IShellLinkDual2 = extern struct {
    pub const VTable = extern struct {
        base: IShellLinkDual.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Target: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IShellLinkDual2,
                ppfi: ?*?*FolderItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IShellLinkDual2,
                ppfi: ?*?*FolderItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IShellLinkDual.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellLinkDual2_get_Target(self: *const T, ppfi: ?*?*FolderItem) HRESULT {
                return @as(*const IShellLinkDual2.VTable, @ptrCast(self.vtable)).get_Target(@as(*const IShellLinkDual2, @ptrCast(self)), ppfi);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IShellFolderViewDual_Value = Guid.initString("e7a1af80-4d96-11cf-960c-0080c7f4ee85");
pub const IID_IShellFolderViewDual = &IID_IShellFolderViewDual_Value;
pub const IShellFolderViewDual = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Application: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IShellFolderViewDual,
                ppid: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IShellFolderViewDual,
                ppid: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Parent: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IShellFolderViewDual,
                ppid: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IShellFolderViewDual,
                ppid: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Folder: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IShellFolderViewDual,
                ppid: ?*?*Folder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IShellFolderViewDual,
                ppid: ?*?*Folder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SelectedItems: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellFolderViewDual,
                ppid: ?*?*FolderItems,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellFolderViewDual,
                ppid: ?*?*FolderItems,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FocusedItem: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IShellFolderViewDual,
                ppid: ?*?*FolderItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IShellFolderViewDual,
                ppid: ?*?*FolderItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SelectItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellFolderViewDual,
                pvfi: ?*VARIANT,
                dwFlags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellFolderViewDual,
                pvfi: ?*VARIANT,
                dwFlags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PopupItemMenu: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellFolderViewDual,
                pfi: ?*FolderItem,
                vx: VARIANT,
                vy: VARIANT,
                pbs: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellFolderViewDual,
                pfi: ?*FolderItem,
                vx: VARIANT,
                vy: VARIANT,
                pbs: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Script: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IShellFolderViewDual,
                ppDisp: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IShellFolderViewDual,
                ppDisp: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ViewOptions: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IShellFolderViewDual,
                plViewOptions: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IShellFolderViewDual,
                plViewOptions: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellFolderViewDual_get_Application(self: *const T, ppid: ?*?*IDispatch) HRESULT {
                return @as(*const IShellFolderViewDual.VTable, @ptrCast(self.vtable)).get_Application(@as(*const IShellFolderViewDual, @ptrCast(self)), ppid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellFolderViewDual_get_Parent(self: *const T, ppid: ?*?*IDispatch) HRESULT {
                return @as(*const IShellFolderViewDual.VTable, @ptrCast(self.vtable)).get_Parent(@as(*const IShellFolderViewDual, @ptrCast(self)), ppid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellFolderViewDual_get_Folder(self: *const T, ppid: ?*?*Folder) HRESULT {
                return @as(*const IShellFolderViewDual.VTable, @ptrCast(self.vtable)).get_Folder(@as(*const IShellFolderViewDual, @ptrCast(self)), ppid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellFolderViewDual_SelectedItems(self: *const T, ppid: ?*?*FolderItems) HRESULT {
                return @as(*const IShellFolderViewDual.VTable, @ptrCast(self.vtable)).SelectedItems(@as(*const IShellFolderViewDual, @ptrCast(self)), ppid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellFolderViewDual_get_FocusedItem(self: *const T, ppid: ?*?*FolderItem) HRESULT {
                return @as(*const IShellFolderViewDual.VTable, @ptrCast(self.vtable)).get_FocusedItem(@as(*const IShellFolderViewDual, @ptrCast(self)), ppid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellFolderViewDual_SelectItem(self: *const T, pvfi: ?*VARIANT, dwFlags: i32) HRESULT {
                return @as(*const IShellFolderViewDual.VTable, @ptrCast(self.vtable)).SelectItem(@as(*const IShellFolderViewDual, @ptrCast(self)), pvfi, dwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellFolderViewDual_PopupItemMenu(self: *const T, pfi: ?*FolderItem, vx: VARIANT, vy: VARIANT, pbs: ?*?BSTR) HRESULT {
                return @as(*const IShellFolderViewDual.VTable, @ptrCast(self.vtable)).PopupItemMenu(@as(*const IShellFolderViewDual, @ptrCast(self)), pfi, vx, vy, pbs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellFolderViewDual_get_Script(self: *const T, ppDisp: ?*?*IDispatch) HRESULT {
                return @as(*const IShellFolderViewDual.VTable, @ptrCast(self.vtable)).get_Script(@as(*const IShellFolderViewDual, @ptrCast(self)), ppDisp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellFolderViewDual_get_ViewOptions(self: *const T, plViewOptions: ?*i32) HRESULT {
                return @as(*const IShellFolderViewDual.VTable, @ptrCast(self.vtable)).get_ViewOptions(@as(*const IShellFolderViewDual, @ptrCast(self)), plViewOptions);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IShellFolderViewDual2_Value = Guid.initString("31c147b6-0ade-4a3c-b514-ddf932ef6d17");
pub const IID_IShellFolderViewDual2 = &IID_IShellFolderViewDual2_Value;
pub const IShellFolderViewDual2 = extern struct {
    pub const VTable = extern struct {
        base: IShellFolderViewDual.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentViewMode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IShellFolderViewDual2,
                pViewMode: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IShellFolderViewDual2,
                pViewMode: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_CurrentViewMode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IShellFolderViewDual2,
                ViewMode: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IShellFolderViewDual2,
                ViewMode: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SelectItemRelative: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellFolderViewDual2,
                iRelative: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellFolderViewDual2,
                iRelative: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IShellFolderViewDual.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellFolderViewDual2_get_CurrentViewMode(self: *const T, pViewMode: ?*u32) HRESULT {
                return @as(*const IShellFolderViewDual2.VTable, @ptrCast(self.vtable)).get_CurrentViewMode(@as(*const IShellFolderViewDual2, @ptrCast(self)), pViewMode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellFolderViewDual2_put_CurrentViewMode(self: *const T, ViewMode: u32) HRESULT {
                return @as(*const IShellFolderViewDual2.VTable, @ptrCast(self.vtable)).put_CurrentViewMode(@as(*const IShellFolderViewDual2, @ptrCast(self)), ViewMode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellFolderViewDual2_SelectItemRelative(self: *const T, iRelative: i32) HRESULT {
                return @as(*const IShellFolderViewDual2.VTable, @ptrCast(self.vtable)).SelectItemRelative(@as(*const IShellFolderViewDual2, @ptrCast(self)), iRelative);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IShellFolderViewDual3_Value = Guid.initString("29ec8e6c-46d3-411f-baaa-611a6c9cac66");
pub const IID_IShellFolderViewDual3 = &IID_IShellFolderViewDual3_Value;
pub const IShellFolderViewDual3 = extern struct {
    pub const VTable = extern struct {
        base: IShellFolderViewDual2.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_GroupBy: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IShellFolderViewDual3,
                pbstrGroupBy: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IShellFolderViewDual3,
                pbstrGroupBy: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_GroupBy: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IShellFolderViewDual3,
                bstrGroupBy: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IShellFolderViewDual3,
                bstrGroupBy: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FolderFlags: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IShellFolderViewDual3,
                pdwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IShellFolderViewDual3,
                pdwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_FolderFlags: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IShellFolderViewDual3,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IShellFolderViewDual3,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SortColumns: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IShellFolderViewDual3,
                pbstrSortColumns: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IShellFolderViewDual3,
                pbstrSortColumns: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SortColumns: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IShellFolderViewDual3,
                bstrSortColumns: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IShellFolderViewDual3,
                bstrSortColumns: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_IconSize: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IShellFolderViewDual3,
                iIconSize: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IShellFolderViewDual3,
                iIconSize: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IconSize: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IShellFolderViewDual3,
                piIconSize: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IShellFolderViewDual3,
                piIconSize: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FilterView: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellFolderViewDual3,
                bstrFilterText: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellFolderViewDual3,
                bstrFilterText: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IShellFolderViewDual2.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellFolderViewDual3_get_GroupBy(self: *const T, pbstrGroupBy: ?*?BSTR) HRESULT {
                return @as(*const IShellFolderViewDual3.VTable, @ptrCast(self.vtable)).get_GroupBy(@as(*const IShellFolderViewDual3, @ptrCast(self)), pbstrGroupBy);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellFolderViewDual3_put_GroupBy(self: *const T, bstrGroupBy: ?BSTR) HRESULT {
                return @as(*const IShellFolderViewDual3.VTable, @ptrCast(self.vtable)).put_GroupBy(@as(*const IShellFolderViewDual3, @ptrCast(self)), bstrGroupBy);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellFolderViewDual3_get_FolderFlags(self: *const T, pdwFlags: ?*u32) HRESULT {
                return @as(*const IShellFolderViewDual3.VTable, @ptrCast(self.vtable)).get_FolderFlags(@as(*const IShellFolderViewDual3, @ptrCast(self)), pdwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellFolderViewDual3_put_FolderFlags(self: *const T, dwFlags: u32) HRESULT {
                return @as(*const IShellFolderViewDual3.VTable, @ptrCast(self.vtable)).put_FolderFlags(@as(*const IShellFolderViewDual3, @ptrCast(self)), dwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellFolderViewDual3_get_SortColumns(self: *const T, pbstrSortColumns: ?*?BSTR) HRESULT {
                return @as(*const IShellFolderViewDual3.VTable, @ptrCast(self.vtable)).get_SortColumns(@as(*const IShellFolderViewDual3, @ptrCast(self)), pbstrSortColumns);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellFolderViewDual3_put_SortColumns(self: *const T, bstrSortColumns: ?BSTR) HRESULT {
                return @as(*const IShellFolderViewDual3.VTable, @ptrCast(self.vtable)).put_SortColumns(@as(*const IShellFolderViewDual3, @ptrCast(self)), bstrSortColumns);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellFolderViewDual3_put_IconSize(self: *const T, iIconSize: i32) HRESULT {
                return @as(*const IShellFolderViewDual3.VTable, @ptrCast(self.vtable)).put_IconSize(@as(*const IShellFolderViewDual3, @ptrCast(self)), iIconSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellFolderViewDual3_get_IconSize(self: *const T, piIconSize: ?*i32) HRESULT {
                return @as(*const IShellFolderViewDual3.VTable, @ptrCast(self.vtable)).get_IconSize(@as(*const IShellFolderViewDual3, @ptrCast(self)), piIconSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellFolderViewDual3_FilterView(self: *const T, bstrFilterText: ?BSTR) HRESULT {
                return @as(*const IShellFolderViewDual3.VTable, @ptrCast(self.vtable)).FilterView(@as(*const IShellFolderViewDual3, @ptrCast(self)), bstrFilterText);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IShellDispatch_Value = Guid.initString("d8f015c0-c278-11ce-a49e-444553540000");
pub const IID_IShellDispatch = &IID_IShellDispatch_Value;
pub const IShellDispatch = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Application: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IShellDispatch,
                ppid: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IShellDispatch,
                ppid: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Parent: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IShellDispatch,
                ppid: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IShellDispatch,
                ppid: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NameSpace: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellDispatch,
                vDir: VARIANT,
                ppsdf: ?*?*Folder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellDispatch,
                vDir: VARIANT,
                ppsdf: ?*?*Folder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BrowseForFolder: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellDispatch,
                Hwnd: i32,
                Title: ?BSTR,
                Options: i32,
                RootFolder: VARIANT,
                ppsdf: ?*?*Folder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellDispatch,
                Hwnd: i32,
                Title: ?BSTR,
                Options: i32,
                RootFolder: VARIANT,
                ppsdf: ?*?*Folder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Windows: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellDispatch,
                ppid: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellDispatch,
                ppid: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Open: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellDispatch,
                vDir: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellDispatch,
                vDir: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Explore: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellDispatch,
                vDir: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellDispatch,
                vDir: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        MinimizeAll: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UndoMinimizeALL: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FileRun: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CascadeWindows: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TileVertically: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TileHorizontally: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ShutdownWindows: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Suspend: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EjectPC: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TrayProperties: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Help: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindFiles: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindComputer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RefreshMenu: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ControlPanelItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellDispatch,
                bstrDir: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellDispatch,
                bstrDir: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellDispatch_get_Application(self: *const T, ppid: ?*?*IDispatch) HRESULT {
                return @as(*const IShellDispatch.VTable, @ptrCast(self.vtable)).get_Application(@as(*const IShellDispatch, @ptrCast(self)), ppid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellDispatch_get_Parent(self: *const T, ppid: ?*?*IDispatch) HRESULT {
                return @as(*const IShellDispatch.VTable, @ptrCast(self.vtable)).get_Parent(@as(*const IShellDispatch, @ptrCast(self)), ppid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellDispatch_NameSpace(self: *const T, vDir: VARIANT, ppsdf: ?*?*Folder) HRESULT {
                return @as(*const IShellDispatch.VTable, @ptrCast(self.vtable)).NameSpace(@as(*const IShellDispatch, @ptrCast(self)), vDir, ppsdf);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellDispatch_BrowseForFolder(self: *const T, Hwnd: i32, Title: ?BSTR, Options: i32, RootFolder: VARIANT, ppsdf: ?*?*Folder) HRESULT {
                return @as(*const IShellDispatch.VTable, @ptrCast(self.vtable)).BrowseForFolder(@as(*const IShellDispatch, @ptrCast(self)), Hwnd, Title, Options, RootFolder, ppsdf);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellDispatch_Windows(self: *const T, ppid: ?*?*IDispatch) HRESULT {
                return @as(*const IShellDispatch.VTable, @ptrCast(self.vtable)).Windows(@as(*const IShellDispatch, @ptrCast(self)), ppid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellDispatch_Open(self: *const T, vDir: VARIANT) HRESULT {
                return @as(*const IShellDispatch.VTable, @ptrCast(self.vtable)).Open(@as(*const IShellDispatch, @ptrCast(self)), vDir);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellDispatch_Explore(self: *const T, vDir: VARIANT) HRESULT {
                return @as(*const IShellDispatch.VTable, @ptrCast(self.vtable)).Explore(@as(*const IShellDispatch, @ptrCast(self)), vDir);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellDispatch_MinimizeAll(self: *const T) HRESULT {
                return @as(*const IShellDispatch.VTable, @ptrCast(self.vtable)).MinimizeAll(@as(*const IShellDispatch, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellDispatch_UndoMinimizeALL(self: *const T) HRESULT {
                return @as(*const IShellDispatch.VTable, @ptrCast(self.vtable)).UndoMinimizeALL(@as(*const IShellDispatch, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellDispatch_FileRun(self: *const T) HRESULT {
                return @as(*const IShellDispatch.VTable, @ptrCast(self.vtable)).FileRun(@as(*const IShellDispatch, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellDispatch_CascadeWindows(self: *const T) HRESULT {
                return @as(*const IShellDispatch.VTable, @ptrCast(self.vtable)).CascadeWindows(@as(*const IShellDispatch, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellDispatch_TileVertically(self: *const T) HRESULT {
                return @as(*const IShellDispatch.VTable, @ptrCast(self.vtable)).TileVertically(@as(*const IShellDispatch, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellDispatch_TileHorizontally(self: *const T) HRESULT {
                return @as(*const IShellDispatch.VTable, @ptrCast(self.vtable)).TileHorizontally(@as(*const IShellDispatch, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellDispatch_ShutdownWindows(self: *const T) HRESULT {
                return @as(*const IShellDispatch.VTable, @ptrCast(self.vtable)).ShutdownWindows(@as(*const IShellDispatch, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellDispatch_Suspend(self: *const T) HRESULT {
                return @as(*const IShellDispatch.VTable, @ptrCast(self.vtable)).Suspend(@as(*const IShellDispatch, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellDispatch_EjectPC(self: *const T) HRESULT {
                return @as(*const IShellDispatch.VTable, @ptrCast(self.vtable)).EjectPC(@as(*const IShellDispatch, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellDispatch_SetTime(self: *const T) HRESULT {
                return @as(*const IShellDispatch.VTable, @ptrCast(self.vtable)).SetTime(@as(*const IShellDispatch, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellDispatch_TrayProperties(self: *const T) HRESULT {
                return @as(*const IShellDispatch.VTable, @ptrCast(self.vtable)).TrayProperties(@as(*const IShellDispatch, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellDispatch_Help(self: *const T) HRESULT {
                return @as(*const IShellDispatch.VTable, @ptrCast(self.vtable)).Help(@as(*const IShellDispatch, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellDispatch_FindFiles(self: *const T) HRESULT {
                return @as(*const IShellDispatch.VTable, @ptrCast(self.vtable)).FindFiles(@as(*const IShellDispatch, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellDispatch_FindComputer(self: *const T) HRESULT {
                return @as(*const IShellDispatch.VTable, @ptrCast(self.vtable)).FindComputer(@as(*const IShellDispatch, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellDispatch_RefreshMenu(self: *const T) HRESULT {
                return @as(*const IShellDispatch.VTable, @ptrCast(self.vtable)).RefreshMenu(@as(*const IShellDispatch, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellDispatch_ControlPanelItem(self: *const T, bstrDir: ?BSTR) HRESULT {
                return @as(*const IShellDispatch.VTable, @ptrCast(self.vtable)).ControlPanelItem(@as(*const IShellDispatch, @ptrCast(self)), bstrDir);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IShellDispatch2_Value = Guid.initString("a4c6892c-3ba9-11d2-9dea-00c04fb16162");
pub const IID_IShellDispatch2 = &IID_IShellDispatch2_Value;
pub const IShellDispatch2 = extern struct {
    pub const VTable = extern struct {
        base: IShellDispatch.VTable,
        IsRestricted: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellDispatch2,
                Group: ?BSTR,
                Restriction: ?BSTR,
                plRestrictValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellDispatch2,
                Group: ?BSTR,
                Restriction: ?BSTR,
                plRestrictValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ShellExecute: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellDispatch2,
                File: ?BSTR,
                vArgs: VARIANT,
                vDir: VARIANT,
                vOperation: VARIANT,
                vShow: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellDispatch2,
                File: ?BSTR,
                vArgs: VARIANT,
                vDir: VARIANT,
                vOperation: VARIANT,
                vShow: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindPrinter: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellDispatch2,
                name: ?BSTR,
                location: ?BSTR,
                model: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellDispatch2,
                name: ?BSTR,
                location: ?BSTR,
                model: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSystemInformation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellDispatch2,
                name: ?BSTR,
                pv: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellDispatch2,
                name: ?BSTR,
                pv: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ServiceStart: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellDispatch2,
                ServiceName: ?BSTR,
                Persistent: VARIANT,
                pSuccess: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellDispatch2,
                ServiceName: ?BSTR,
                Persistent: VARIANT,
                pSuccess: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ServiceStop: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellDispatch2,
                ServiceName: ?BSTR,
                Persistent: VARIANT,
                pSuccess: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellDispatch2,
                ServiceName: ?BSTR,
                Persistent: VARIANT,
                pSuccess: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsServiceRunning: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellDispatch2,
                ServiceName: ?BSTR,
                pRunning: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellDispatch2,
                ServiceName: ?BSTR,
                pRunning: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CanStartStopService: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellDispatch2,
                ServiceName: ?BSTR,
                pCanStartStop: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellDispatch2,
                ServiceName: ?BSTR,
                pCanStartStop: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ShowBrowserBar: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellDispatch2,
                bstrClsid: ?BSTR,
                bShow: VARIANT,
                pSuccess: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellDispatch2,
                bstrClsid: ?BSTR,
                bShow: VARIANT,
                pSuccess: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IShellDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellDispatch2_IsRestricted(self: *const T, Group: ?BSTR, Restriction: ?BSTR, plRestrictValue: ?*i32) HRESULT {
                return @as(*const IShellDispatch2.VTable, @ptrCast(self.vtable)).IsRestricted(@as(*const IShellDispatch2, @ptrCast(self)), Group, Restriction, plRestrictValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellDispatch2_ShellExecute(self: *const T, File: ?BSTR, vArgs: VARIANT, vDir: VARIANT, vOperation: VARIANT, vShow: VARIANT) HRESULT {
                return @as(*const IShellDispatch2.VTable, @ptrCast(self.vtable)).ShellExecute(@as(*const IShellDispatch2, @ptrCast(self)), File, vArgs, vDir, vOperation, vShow);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellDispatch2_FindPrinter(self: *const T, name: ?BSTR, location: ?BSTR, model: ?BSTR) HRESULT {
                return @as(*const IShellDispatch2.VTable, @ptrCast(self.vtable)).FindPrinter(@as(*const IShellDispatch2, @ptrCast(self)), name, location, model);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellDispatch2_GetSystemInformation(self: *const T, name: ?BSTR, pv: ?*VARIANT) HRESULT {
                return @as(*const IShellDispatch2.VTable, @ptrCast(self.vtable)).GetSystemInformation(@as(*const IShellDispatch2, @ptrCast(self)), name, pv);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellDispatch2_ServiceStart(self: *const T, ServiceName: ?BSTR, Persistent: VARIANT, pSuccess: ?*VARIANT) HRESULT {
                return @as(*const IShellDispatch2.VTable, @ptrCast(self.vtable)).ServiceStart(@as(*const IShellDispatch2, @ptrCast(self)), ServiceName, Persistent, pSuccess);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellDispatch2_ServiceStop(self: *const T, ServiceName: ?BSTR, Persistent: VARIANT, pSuccess: ?*VARIANT) HRESULT {
                return @as(*const IShellDispatch2.VTable, @ptrCast(self.vtable)).ServiceStop(@as(*const IShellDispatch2, @ptrCast(self)), ServiceName, Persistent, pSuccess);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellDispatch2_IsServiceRunning(self: *const T, ServiceName: ?BSTR, pRunning: ?*VARIANT) HRESULT {
                return @as(*const IShellDispatch2.VTable, @ptrCast(self.vtable)).IsServiceRunning(@as(*const IShellDispatch2, @ptrCast(self)), ServiceName, pRunning);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellDispatch2_CanStartStopService(self: *const T, ServiceName: ?BSTR, pCanStartStop: ?*VARIANT) HRESULT {
                return @as(*const IShellDispatch2.VTable, @ptrCast(self.vtable)).CanStartStopService(@as(*const IShellDispatch2, @ptrCast(self)), ServiceName, pCanStartStop);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellDispatch2_ShowBrowserBar(self: *const T, bstrClsid: ?BSTR, bShow: VARIANT, pSuccess: ?*VARIANT) HRESULT {
                return @as(*const IShellDispatch2.VTable, @ptrCast(self.vtable)).ShowBrowserBar(@as(*const IShellDispatch2, @ptrCast(self)), bstrClsid, bShow, pSuccess);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IShellDispatch3_Value = Guid.initString("177160ca-bb5a-411c-841d-bd38facdeaa0");
pub const IID_IShellDispatch3 = &IID_IShellDispatch3_Value;
pub const IShellDispatch3 = extern struct {
    pub const VTable = extern struct {
        base: IShellDispatch2.VTable,
        AddToRecent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellDispatch3,
                varFile: VARIANT,
                bstrCategory: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellDispatch3,
                varFile: VARIANT,
                bstrCategory: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IShellDispatch2.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellDispatch3_AddToRecent(self: *const T, varFile: VARIANT, bstrCategory: ?BSTR) HRESULT {
                return @as(*const IShellDispatch3.VTable, @ptrCast(self.vtable)).AddToRecent(@as(*const IShellDispatch3, @ptrCast(self)), varFile, bstrCategory);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IShellDispatch4_Value = Guid.initString("efd84b2d-4bcf-4298-be25-eb542a59fbda");
pub const IID_IShellDispatch4 = &IID_IShellDispatch4_Value;
pub const IShellDispatch4 = extern struct {
    pub const VTable = extern struct {
        base: IShellDispatch3.VTable,
        WindowsSecurity: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellDispatch4,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellDispatch4,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ToggleDesktop: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellDispatch4,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellDispatch4,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExplorerPolicy: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellDispatch4,
                bstrPolicyName: ?BSTR,
                pValue: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellDispatch4,
                bstrPolicyName: ?BSTR,
                pValue: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSetting: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellDispatch4,
                lSetting: i32,
                pResult: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellDispatch4,
                lSetting: i32,
                pResult: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IShellDispatch3.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellDispatch4_WindowsSecurity(self: *const T) HRESULT {
                return @as(*const IShellDispatch4.VTable, @ptrCast(self.vtable)).WindowsSecurity(@as(*const IShellDispatch4, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellDispatch4_ToggleDesktop(self: *const T) HRESULT {
                return @as(*const IShellDispatch4.VTable, @ptrCast(self.vtable)).ToggleDesktop(@as(*const IShellDispatch4, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellDispatch4_ExplorerPolicy(self: *const T, bstrPolicyName: ?BSTR, pValue: ?*VARIANT) HRESULT {
                return @as(*const IShellDispatch4.VTable, @ptrCast(self.vtable)).ExplorerPolicy(@as(*const IShellDispatch4, @ptrCast(self)), bstrPolicyName, pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellDispatch4_GetSetting(self: *const T, lSetting: i32, pResult: ?*i16) HRESULT {
                return @as(*const IShellDispatch4.VTable, @ptrCast(self.vtable)).GetSetting(@as(*const IShellDispatch4, @ptrCast(self)), lSetting, pResult);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IShellDispatch5_Value = Guid.initString("866738b9-6cf2-4de8-8767-f794ebe74f4e");
pub const IID_IShellDispatch5 = &IID_IShellDispatch5_Value;
pub const IShellDispatch5 = extern struct {
    pub const VTable = extern struct {
        base: IShellDispatch4.VTable,
        WindowSwitcher: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellDispatch5,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellDispatch5,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IShellDispatch4.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellDispatch5_WindowSwitcher(self: *const T) HRESULT {
                return @as(*const IShellDispatch5.VTable, @ptrCast(self.vtable)).WindowSwitcher(@as(*const IShellDispatch5, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IShellDispatch6_Value = Guid.initString("286e6f1b-7113-4355-9562-96b7e9d64c54");
pub const IID_IShellDispatch6 = &IID_IShellDispatch6_Value;
pub const IShellDispatch6 = extern struct {
    pub const VTable = extern struct {
        base: IShellDispatch5.VTable,
        SearchCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellDispatch6,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellDispatch6,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IShellDispatch5.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellDispatch6_SearchCommand(self: *const T) HRESULT {
                return @as(*const IShellDispatch6.VTable, @ptrCast(self.vtable)).SearchCommand(@as(*const IShellDispatch6, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IFileSearchBand_Value = Guid.initString("2d91eea1-9932-11d2-be86-00a0c9a83da1");
pub const IID_IFileSearchBand = &IID_IFileSearchBand_Value;
pub const IFileSearchBand = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        SetFocus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileSearchBand,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileSearchBand,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSearchParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileSearchBand,
                pbstrSearchID: ?*?BSTR,
                bNavToResults: i16,
                pvarScope: ?*VARIANT,
                pvarQueryFile: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileSearchBand,
                pbstrSearchID: ?*?BSTR,
                bNavToResults: i16,
                pvarScope: ?*VARIANT,
                pvarQueryFile: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SearchID: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFileSearchBand,
                pbstrSearchID: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFileSearchBand,
                pbstrSearchID: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Scope: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFileSearchBand,
                pvarScope: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFileSearchBand,
                pvarScope: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_QueryFile: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFileSearchBand,
                pvarFile: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFileSearchBand,
                pvarFile: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileSearchBand_SetFocus(self: *const T) HRESULT {
                return @as(*const IFileSearchBand.VTable, @ptrCast(self.vtable)).SetFocus(@as(*const IFileSearchBand, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileSearchBand_SetSearchParameters(self: *const T, pbstrSearchID: ?*?BSTR, bNavToResults: i16, pvarScope: ?*VARIANT, pvarQueryFile: ?*VARIANT) HRESULT {
                return @as(*const IFileSearchBand.VTable, @ptrCast(self.vtable)).SetSearchParameters(@as(*const IFileSearchBand, @ptrCast(self)), pbstrSearchID, bNavToResults, pvarScope, pvarQueryFile);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileSearchBand_get_SearchID(self: *const T, pbstrSearchID: ?*?BSTR) HRESULT {
                return @as(*const IFileSearchBand.VTable, @ptrCast(self.vtable)).get_SearchID(@as(*const IFileSearchBand, @ptrCast(self)), pbstrSearchID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileSearchBand_get_Scope(self: *const T, pvarScope: ?*VARIANT) HRESULT {
                return @as(*const IFileSearchBand.VTable, @ptrCast(self.vtable)).get_Scope(@as(*const IFileSearchBand, @ptrCast(self)), pvarScope);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileSearchBand_get_QueryFile(self: *const T, pvarFile: ?*VARIANT) HRESULT {
                return @as(*const IFileSearchBand.VTable, @ptrCast(self.vtable)).get_QueryFile(@as(*const IFileSearchBand, @ptrCast(self)), pvarFile);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWebWizardHost_Value = Guid.initString("18bcc359-4990-4bfb-b951-3c83702be5f9");
pub const IID_IWebWizardHost = &IID_IWebWizardHost_Value;
pub const IWebWizardHost = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        FinalBack: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWebWizardHost,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWebWizardHost,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FinalNext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWebWizardHost,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWebWizardHost,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Cancel: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWebWizardHost,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWebWizardHost,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Caption: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWebWizardHost,
                bstrCaption: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWebWizardHost,
                bstrCaption: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Caption: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWebWizardHost,
                pbstrCaption: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWebWizardHost,
                pbstrCaption: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Property: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWebWizardHost,
                bstrPropertyName: ?BSTR,
                pvProperty: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWebWizardHost,
                bstrPropertyName: ?BSTR,
                pvProperty: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Property: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWebWizardHost,
                bstrPropertyName: ?BSTR,
                pvProperty: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWebWizardHost,
                bstrPropertyName: ?BSTR,
                pvProperty: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetWizardButtons: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWebWizardHost,
                vfEnableBack: i16,
                vfEnableNext: i16,
                vfLastPage: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWebWizardHost,
                vfEnableBack: i16,
                vfEnableNext: i16,
                vfLastPage: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetHeaderText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWebWizardHost,
                bstrHeaderTitle: ?BSTR,
                bstrHeaderSubtitle: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWebWizardHost,
                bstrHeaderTitle: ?BSTR,
                bstrHeaderSubtitle: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWebWizardHost_FinalBack(self: *const T) HRESULT {
                return @as(*const IWebWizardHost.VTable, @ptrCast(self.vtable)).FinalBack(@as(*const IWebWizardHost, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWebWizardHost_FinalNext(self: *const T) HRESULT {
                return @as(*const IWebWizardHost.VTable, @ptrCast(self.vtable)).FinalNext(@as(*const IWebWizardHost, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWebWizardHost_Cancel(self: *const T) HRESULT {
                return @as(*const IWebWizardHost.VTable, @ptrCast(self.vtable)).Cancel(@as(*const IWebWizardHost, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWebWizardHost_put_Caption(self: *const T, bstrCaption: ?BSTR) HRESULT {
                return @as(*const IWebWizardHost.VTable, @ptrCast(self.vtable)).put_Caption(@as(*const IWebWizardHost, @ptrCast(self)), bstrCaption);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWebWizardHost_get_Caption(self: *const T, pbstrCaption: ?*?BSTR) HRESULT {
                return @as(*const IWebWizardHost.VTable, @ptrCast(self.vtable)).get_Caption(@as(*const IWebWizardHost, @ptrCast(self)), pbstrCaption);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWebWizardHost_put_Property(self: *const T, bstrPropertyName: ?BSTR, pvProperty: ?*VARIANT) HRESULT {
                return @as(*const IWebWizardHost.VTable, @ptrCast(self.vtable)).put_Property(@as(*const IWebWizardHost, @ptrCast(self)), bstrPropertyName, pvProperty);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWebWizardHost_get_Property(self: *const T, bstrPropertyName: ?BSTR, pvProperty: ?*VARIANT) HRESULT {
                return @as(*const IWebWizardHost.VTable, @ptrCast(self.vtable)).get_Property(@as(*const IWebWizardHost, @ptrCast(self)), bstrPropertyName, pvProperty);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWebWizardHost_SetWizardButtons(self: *const T, vfEnableBack: i16, vfEnableNext: i16, vfLastPage: i16) HRESULT {
                return @as(*const IWebWizardHost.VTable, @ptrCast(self.vtable)).SetWizardButtons(@as(*const IWebWizardHost, @ptrCast(self)), vfEnableBack, vfEnableNext, vfLastPage);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWebWizardHost_SetHeaderText(self: *const T, bstrHeaderTitle: ?BSTR, bstrHeaderSubtitle: ?BSTR) HRESULT {
                return @as(*const IWebWizardHost.VTable, @ptrCast(self.vtable)).SetHeaderText(@as(*const IWebWizardHost, @ptrCast(self)), bstrHeaderTitle, bstrHeaderSubtitle);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWebWizardHost2_Value = Guid.initString("f9c013dc-3c23-4041-8e39-cfb402f7ea59");
pub const IID_IWebWizardHost2 = &IID_IWebWizardHost2_Value;
pub const IWebWizardHost2 = extern struct {
    pub const VTable = extern struct {
        base: IWebWizardHost.VTable,
        SignString: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWebWizardHost2,
                value: ?BSTR,
                signedValue: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWebWizardHost2,
                value: ?BSTR,
                signedValue: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWebWizardHost.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWebWizardHost2_SignString(self: *const T, value: ?BSTR, signedValue: ?*?BSTR) HRESULT {
                return @as(*const IWebWizardHost2.VTable, @ptrCast(self.vtable)).SignString(@as(*const IWebWizardHost2, @ptrCast(self)), value, signedValue);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_INewWDEvents_Value = Guid.initString("0751c551-7568-41c9-8e5b-e22e38919236");
pub const IID_INewWDEvents = &IID_INewWDEvents_Value;
pub const INewWDEvents = extern struct {
    pub const VTable = extern struct {
        base: IWebWizardHost.VTable,
        PassportAuthenticate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INewWDEvents,
                bstrSignInUrl: ?BSTR,
                pvfAuthenitcated: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INewWDEvents,
                bstrSignInUrl: ?BSTR,
                pvfAuthenitcated: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWebWizardHost.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INewWDEvents_PassportAuthenticate(self: *const T, bstrSignInUrl: ?BSTR, pvfAuthenitcated: ?*i16) HRESULT {
                return @as(*const INewWDEvents.VTable, @ptrCast(self.vtable)).PassportAuthenticate(@as(*const INewWDEvents, @ptrCast(self)), bstrSignInUrl, pvfAuthenitcated);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAutoComplete_Value = Guid.initString("00bb2762-6a77-11d0-a535-00c04fd7d062");
pub const IID_IAutoComplete = &IID_IAutoComplete_Value;
pub const IAutoComplete = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Init: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAutoComplete,
                hwndEdit: ?HWND,
                punkACL: ?*IUnknown,
                pwszRegKeyPath: ?[*:0]const u16,
                pwszQuickComplete: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAutoComplete,
                hwndEdit: ?HWND,
                punkACL: ?*IUnknown,
                pwszRegKeyPath: ?[*:0]const u16,
                pwszQuickComplete: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Enable: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAutoComplete,
                fEnable: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAutoComplete,
                fEnable: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAutoComplete_Init(self: *const T, hwndEdit: ?HWND, punkACL: ?*IUnknown, pwszRegKeyPath: ?[*:0]const u16, pwszQuickComplete: ?[*:0]const u16) HRESULT {
                return @as(*const IAutoComplete.VTable, @ptrCast(self.vtable)).Init(@as(*const IAutoComplete, @ptrCast(self)), hwndEdit, punkACL, pwszRegKeyPath, pwszQuickComplete);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAutoComplete_Enable(self: *const T, fEnable: BOOL) HRESULT {
                return @as(*const IAutoComplete.VTable, @ptrCast(self.vtable)).Enable(@as(*const IAutoComplete, @ptrCast(self)), fEnable);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const AUTOCOMPLETEOPTIONS = enum(i32) {
    NONE = 0,
    AUTOSUGGEST = 1,
    AUTOAPPEND = 2,
    SEARCH = 4,
    FILTERPREFIXES = 8,
    USETAB = 16,
    UPDOWNKEYDROPSLIST = 32,
    RTLREADING = 64,
    WORD_FILTER = 128,
    NOPREFIXFILTERING = 256,
};
pub const ACO_NONE = AUTOCOMPLETEOPTIONS.NONE;
pub const ACO_AUTOSUGGEST = AUTOCOMPLETEOPTIONS.AUTOSUGGEST;
pub const ACO_AUTOAPPEND = AUTOCOMPLETEOPTIONS.AUTOAPPEND;
pub const ACO_SEARCH = AUTOCOMPLETEOPTIONS.SEARCH;
pub const ACO_FILTERPREFIXES = AUTOCOMPLETEOPTIONS.FILTERPREFIXES;
pub const ACO_USETAB = AUTOCOMPLETEOPTIONS.USETAB;
pub const ACO_UPDOWNKEYDROPSLIST = AUTOCOMPLETEOPTIONS.UPDOWNKEYDROPSLIST;
pub const ACO_RTLREADING = AUTOCOMPLETEOPTIONS.RTLREADING;
pub const ACO_WORD_FILTER = AUTOCOMPLETEOPTIONS.WORD_FILTER;
pub const ACO_NOPREFIXFILTERING = AUTOCOMPLETEOPTIONS.NOPREFIXFILTERING;

// TODO: this type is limited to platform 'windows5.0'
const IID_IAutoComplete2_Value = Guid.initString("eac04bc0-3791-11d2-bb95-0060977b464c");
pub const IID_IAutoComplete2 = &IID_IAutoComplete2_Value;
pub const IAutoComplete2 = extern struct {
    pub const VTable = extern struct {
        base: IAutoComplete.VTable,
        SetOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAutoComplete2,
                dwFlag: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAutoComplete2,
                dwFlag: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAutoComplete2,
                pdwFlag: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAutoComplete2,
                pdwFlag: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IAutoComplete.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAutoComplete2_SetOptions(self: *const T, dwFlag: u32) HRESULT {
                return @as(*const IAutoComplete2.VTable, @ptrCast(self.vtable)).SetOptions(@as(*const IAutoComplete2, @ptrCast(self)), dwFlag);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAutoComplete2_GetOptions(self: *const T, pdwFlag: ?*u32) HRESULT {
                return @as(*const IAutoComplete2.VTable, @ptrCast(self.vtable)).GetOptions(@as(*const IAutoComplete2, @ptrCast(self)), pdwFlag);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const ACENUMOPTION = enum(i32) {
    NONE = 0,
    MOSTRECENTFIRST = 1,
    FIRSTUNUSED = 65536,
};
pub const ACEO_NONE = ACENUMOPTION.NONE;
pub const ACEO_MOSTRECENTFIRST = ACENUMOPTION.MOSTRECENTFIRST;
pub const ACEO_FIRSTUNUSED = ACENUMOPTION.FIRSTUNUSED;

const IID_IEnumACString_Value = Guid.initString("8e74c210-cf9d-4eaf-a403-7356428f0a5a");
pub const IID_IEnumACString = &IID_IEnumACString_Value;
pub const IEnumACString = extern struct {
    pub const VTable = extern struct {
        base: IEnumString.VTable,
        NextItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumACString,
                pszUrl: ?[*:0]u16,
                cchMax: u32,
                pulSortIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumACString,
                pszUrl: ?[*:0]u16,
                cchMax: u32,
                pulSortIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEnumOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumACString,
                dwOptions: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumACString,
                dwOptions: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEnumOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumACString,
                pdwOptions: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumACString,
                pdwOptions: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IEnumString.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumACString_NextItem(self: *const T, pszUrl: ?[*:0]u16, cchMax: u32, pulSortIndex: ?*u32) HRESULT {
                return @as(*const IEnumACString.VTable, @ptrCast(self.vtable)).NextItem(@as(*const IEnumACString, @ptrCast(self)), pszUrl, cchMax, pulSortIndex);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumACString_SetEnumOptions(self: *const T, dwOptions: u32) HRESULT {
                return @as(*const IEnumACString.VTable, @ptrCast(self.vtable)).SetEnumOptions(@as(*const IEnumACString, @ptrCast(self)), dwOptions);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumACString_GetEnumOptions(self: *const T, pdwOptions: ?*u32) HRESULT {
                return @as(*const IEnumACString.VTable, @ptrCast(self.vtable)).GetEnumOptions(@as(*const IEnumACString, @ptrCast(self)), pdwOptions);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IDataObjectAsyncCapability_Value = Guid.initString("3d8b0590-f691-11d2-8ea9-006097df5bd4");
pub const IID_IDataObjectAsyncCapability = &IID_IDataObjectAsyncCapability_Value;
pub const IDataObjectAsyncCapability = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetAsyncMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataObjectAsyncCapability,
                fDoOpAsync: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataObjectAsyncCapability,
                fDoOpAsync: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAsyncMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataObjectAsyncCapability,
                pfIsOpAsync: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataObjectAsyncCapability,
                pfIsOpAsync: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartOperation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataObjectAsyncCapability,
                pbcReserved: ?*IBindCtx,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataObjectAsyncCapability,
                pbcReserved: ?*IBindCtx,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InOperation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataObjectAsyncCapability,
                pfInAsyncOp: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataObjectAsyncCapability,
                pfInAsyncOp: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndOperation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataObjectAsyncCapability,
                hResult: HRESULT,
                pbcReserved: ?*IBindCtx,
                dwEffects: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataObjectAsyncCapability,
                hResult: HRESULT,
                pbcReserved: ?*IBindCtx,
                dwEffects: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataObjectAsyncCapability_SetAsyncMode(self: *const T, fDoOpAsync: BOOL) HRESULT {
                return @as(*const IDataObjectAsyncCapability.VTable, @ptrCast(self.vtable)).SetAsyncMode(@as(*const IDataObjectAsyncCapability, @ptrCast(self)), fDoOpAsync);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataObjectAsyncCapability_GetAsyncMode(self: *const T, pfIsOpAsync: ?*BOOL) HRESULT {
                return @as(*const IDataObjectAsyncCapability.VTable, @ptrCast(self.vtable)).GetAsyncMode(@as(*const IDataObjectAsyncCapability, @ptrCast(self)), pfIsOpAsync);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataObjectAsyncCapability_StartOperation(self: *const T, pbcReserved: ?*IBindCtx) HRESULT {
                return @as(*const IDataObjectAsyncCapability.VTable, @ptrCast(self.vtable)).StartOperation(@as(*const IDataObjectAsyncCapability, @ptrCast(self)), pbcReserved);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataObjectAsyncCapability_InOperation(self: *const T, pfInAsyncOp: ?*BOOL) HRESULT {
                return @as(*const IDataObjectAsyncCapability.VTable, @ptrCast(self.vtable)).InOperation(@as(*const IDataObjectAsyncCapability, @ptrCast(self)), pfInAsyncOp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataObjectAsyncCapability_EndOperation(self: *const T, hResult: HRESULT, pbcReserved: ?*IBindCtx, dwEffects: u32) HRESULT {
                return @as(*const IDataObjectAsyncCapability.VTable, @ptrCast(self.vtable)).EndOperation(@as(*const IDataObjectAsyncCapability, @ptrCast(self)), hResult, pbcReserved, dwEffects);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IExtractIconA_Value = Guid.initString("000214eb-0000-0000-c000-000000000046");
pub const IID_IExtractIconA = &IID_IExtractIconA_Value;
pub const IExtractIconA = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetIconLocation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IExtractIconA,
                uFlags: u32,
                pszIconFile: [*:0]u8,
                cchMax: u32,
                piIndex: ?*i32,
                pwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IExtractIconA,
                uFlags: u32,
                pszIconFile: [*:0]u8,
                cchMax: u32,
                piIndex: ?*i32,
                pwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Extract: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IExtractIconA,
                pszFile: ?[*:0]const u8,
                nIconIndex: u32,
                phiconLarge: ?*?HICON,
                phiconSmall: ?*?HICON,
                nIconSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IExtractIconA,
                pszFile: ?[*:0]const u8,
                nIconIndex: u32,
                phiconLarge: ?*?HICON,
                phiconSmall: ?*?HICON,
                nIconSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IExtractIconA_GetIconLocation(self: *const T, uFlags: u32, pszIconFile: [*:0]u8, cchMax: u32, piIndex: ?*i32, pwFlags: ?*u32) HRESULT {
                return @as(*const IExtractIconA.VTable, @ptrCast(self.vtable)).GetIconLocation(@as(*const IExtractIconA, @ptrCast(self)), uFlags, pszIconFile, cchMax, piIndex, pwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IExtractIconA_Extract(self: *const T, pszFile: ?[*:0]const u8, nIconIndex: u32, phiconLarge: ?*?HICON, phiconSmall: ?*?HICON, nIconSize: u32) HRESULT {
                return @as(*const IExtractIconA.VTable, @ptrCast(self.vtable)).Extract(@as(*const IExtractIconA, @ptrCast(self)), pszFile, nIconIndex, phiconLarge, phiconSmall, nIconSize);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IExtractIconW_Value = Guid.initString("000214fa-0000-0000-c000-000000000046");
pub const IID_IExtractIconW = &IID_IExtractIconW_Value;
pub const IExtractIconW = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetIconLocation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IExtractIconW,
                uFlags: u32,
                pszIconFile: [*:0]u16,
                cchMax: u32,
                piIndex: ?*i32,
                pwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IExtractIconW,
                uFlags: u32,
                pszIconFile: [*:0]u16,
                cchMax: u32,
                piIndex: ?*i32,
                pwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Extract: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IExtractIconW,
                pszFile: ?[*:0]const u16,
                nIconIndex: u32,
                phiconLarge: ?*?HICON,
                phiconSmall: ?*?HICON,
                nIconSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IExtractIconW,
                pszFile: ?[*:0]const u16,
                nIconIndex: u32,
                phiconLarge: ?*?HICON,
                phiconSmall: ?*?HICON,
                nIconSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IExtractIconW_GetIconLocation(self: *const T, uFlags: u32, pszIconFile: [*:0]u16, cchMax: u32, piIndex: ?*i32, pwFlags: ?*u32) HRESULT {
                return @as(*const IExtractIconW.VTable, @ptrCast(self.vtable)).GetIconLocation(@as(*const IExtractIconW, @ptrCast(self)), uFlags, pszIconFile, cchMax, piIndex, pwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IExtractIconW_Extract(self: *const T, pszFile: ?[*:0]const u16, nIconIndex: u32, phiconLarge: ?*?HICON, phiconSmall: ?*?HICON, nIconSize: u32) HRESULT {
                return @as(*const IExtractIconW.VTable, @ptrCast(self.vtable)).Extract(@as(*const IExtractIconW, @ptrCast(self)), pszFile, nIconIndex, phiconLarge, phiconSmall, nIconSize);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IShellIconOverlayManager_Value = Guid.initString("f10b5e34-dd3b-42a7-aa7d-2f4ec54bb09b");
pub const IID_IShellIconOverlayManager = &IID_IShellIconOverlayManager_Value;
pub const IShellIconOverlayManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetFileOverlayInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellIconOverlayManager,
                pwszPath: ?[*:0]const u16,
                dwAttrib: u32,
                pIndex: ?*i32,
                dwflags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellIconOverlayManager,
                pwszPath: ?[*:0]const u16,
                dwAttrib: u32,
                pIndex: ?*i32,
                dwflags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetReservedOverlayInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellIconOverlayManager,
                pwszPath: ?[*:0]const u16,
                dwAttrib: u32,
                pIndex: ?*i32,
                dwflags: u32,
                iReservedID: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellIconOverlayManager,
                pwszPath: ?[*:0]const u16,
                dwAttrib: u32,
                pIndex: ?*i32,
                dwflags: u32,
                iReservedID: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RefreshOverlayImages: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellIconOverlayManager,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellIconOverlayManager,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LoadNonloadedOverlayIdentifiers: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellIconOverlayManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellIconOverlayManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OverlayIndexFromImageIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellIconOverlayManager,
                iImage: i32,
                piIndex: ?*i32,
                fAdd: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellIconOverlayManager,
                iImage: i32,
                piIndex: ?*i32,
                fAdd: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellIconOverlayManager_GetFileOverlayInfo(self: *const T, pwszPath: ?[*:0]const u16, dwAttrib: u32, pIndex: ?*i32, dwflags: u32) HRESULT {
                return @as(*const IShellIconOverlayManager.VTable, @ptrCast(self.vtable)).GetFileOverlayInfo(@as(*const IShellIconOverlayManager, @ptrCast(self)), pwszPath, dwAttrib, pIndex, dwflags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellIconOverlayManager_GetReservedOverlayInfo(self: *const T, pwszPath: ?[*:0]const u16, dwAttrib: u32, pIndex: ?*i32, dwflags: u32, iReservedID: i32) HRESULT {
                return @as(*const IShellIconOverlayManager.VTable, @ptrCast(self.vtable)).GetReservedOverlayInfo(@as(*const IShellIconOverlayManager, @ptrCast(self)), pwszPath, dwAttrib, pIndex, dwflags, iReservedID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellIconOverlayManager_RefreshOverlayImages(self: *const T, dwFlags: u32) HRESULT {
                return @as(*const IShellIconOverlayManager.VTable, @ptrCast(self.vtable)).RefreshOverlayImages(@as(*const IShellIconOverlayManager, @ptrCast(self)), dwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellIconOverlayManager_LoadNonloadedOverlayIdentifiers(self: *const T) HRESULT {
                return @as(*const IShellIconOverlayManager.VTable, @ptrCast(self.vtable)).LoadNonloadedOverlayIdentifiers(@as(*const IShellIconOverlayManager, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellIconOverlayManager_OverlayIndexFromImageIndex(self: *const T, iImage: i32, piIndex: ?*i32, fAdd: BOOL) HRESULT {
                return @as(*const IShellIconOverlayManager.VTable, @ptrCast(self.vtable)).OverlayIndexFromImageIndex(@as(*const IShellIconOverlayManager, @ptrCast(self)), iImage, piIndex, fAdd);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IShellIconOverlay_Value = Guid.initString("7d688a70-c613-11d0-999b-00c04fd655e1");
pub const IID_IShellIconOverlay = &IID_IShellIconOverlay_Value;
pub const IShellIconOverlay = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetOverlayIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellIconOverlay,
                pidl: ?*ITEMIDLIST,
                pIndex: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellIconOverlay,
                pidl: ?*ITEMIDLIST,
                pIndex: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOverlayIconIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellIconOverlay,
                pidl: ?*ITEMIDLIST,
                pIconIndex: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellIconOverlay,
                pidl: ?*ITEMIDLIST,
                pIconIndex: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellIconOverlay_GetOverlayIndex(self: *const T, pidl: ?*ITEMIDLIST, pIndex: ?*i32) HRESULT {
                return @as(*const IShellIconOverlay.VTable, @ptrCast(self.vtable)).GetOverlayIndex(@as(*const IShellIconOverlay, @ptrCast(self)), pidl, pIndex);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellIconOverlay_GetOverlayIconIndex(self: *const T, pidl: ?*ITEMIDLIST, pIconIndex: ?*i32) HRESULT {
                return @as(*const IShellIconOverlay.VTable, @ptrCast(self.vtable)).GetOverlayIconIndex(@as(*const IShellIconOverlay, @ptrCast(self)), pidl, pIconIndex);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SHELL_LINK_DATA_FLAGS = enum(i32) {
    DEFAULT = 0,
    HAS_ID_LIST = 1,
    HAS_LINK_INFO = 2,
    HAS_NAME = 4,
    HAS_RELPATH = 8,
    HAS_WORKINGDIR = 16,
    HAS_ARGS = 32,
    HAS_ICONLOCATION = 64,
    UNICODE = 128,
    FORCE_NO_LINKINFO = 256,
    HAS_EXP_SZ = 512,
    RUN_IN_SEPARATE = 1024,
    HAS_DARWINID = 4096,
    RUNAS_USER = 8192,
    HAS_EXP_ICON_SZ = 16384,
    NO_PIDL_ALIAS = 32768,
    FORCE_UNCNAME = 65536,
    RUN_WITH_SHIMLAYER = 131072,
    FORCE_NO_LINKTRACK = 262144,
    ENABLE_TARGET_METADATA = 524288,
    DISABLE_LINK_PATH_TRACKING = 1048576,
    DISABLE_KNOWNFOLDER_RELATIVE_TRACKING = 2097152,
    NO_KF_ALIAS = 4194304,
    ALLOW_LINK_TO_LINK = 8388608,
    UNALIAS_ON_SAVE = 16777216,
    PREFER_ENVIRONMENT_PATH = 33554432,
    KEEP_LOCAL_IDLIST_FOR_UNC_TARGET = 67108864,
    PERSIST_VOLUME_ID_RELATIVE = 134217728,
    VALID = 268433407,
    RESERVED = -2147483648,
};
pub const SLDF_DEFAULT = SHELL_LINK_DATA_FLAGS.DEFAULT;
pub const SLDF_HAS_ID_LIST = SHELL_LINK_DATA_FLAGS.HAS_ID_LIST;
pub const SLDF_HAS_LINK_INFO = SHELL_LINK_DATA_FLAGS.HAS_LINK_INFO;
pub const SLDF_HAS_NAME = SHELL_LINK_DATA_FLAGS.HAS_NAME;
pub const SLDF_HAS_RELPATH = SHELL_LINK_DATA_FLAGS.HAS_RELPATH;
pub const SLDF_HAS_WORKINGDIR = SHELL_LINK_DATA_FLAGS.HAS_WORKINGDIR;
pub const SLDF_HAS_ARGS = SHELL_LINK_DATA_FLAGS.HAS_ARGS;
pub const SLDF_HAS_ICONLOCATION = SHELL_LINK_DATA_FLAGS.HAS_ICONLOCATION;
pub const SLDF_UNICODE = SHELL_LINK_DATA_FLAGS.UNICODE;
pub const SLDF_FORCE_NO_LINKINFO = SHELL_LINK_DATA_FLAGS.FORCE_NO_LINKINFO;
pub const SLDF_HAS_EXP_SZ = SHELL_LINK_DATA_FLAGS.HAS_EXP_SZ;
pub const SLDF_RUN_IN_SEPARATE = SHELL_LINK_DATA_FLAGS.RUN_IN_SEPARATE;
pub const SLDF_HAS_DARWINID = SHELL_LINK_DATA_FLAGS.HAS_DARWINID;
pub const SLDF_RUNAS_USER = SHELL_LINK_DATA_FLAGS.RUNAS_USER;
pub const SLDF_HAS_EXP_ICON_SZ = SHELL_LINK_DATA_FLAGS.HAS_EXP_ICON_SZ;
pub const SLDF_NO_PIDL_ALIAS = SHELL_LINK_DATA_FLAGS.NO_PIDL_ALIAS;
pub const SLDF_FORCE_UNCNAME = SHELL_LINK_DATA_FLAGS.FORCE_UNCNAME;
pub const SLDF_RUN_WITH_SHIMLAYER = SHELL_LINK_DATA_FLAGS.RUN_WITH_SHIMLAYER;
pub const SLDF_FORCE_NO_LINKTRACK = SHELL_LINK_DATA_FLAGS.FORCE_NO_LINKTRACK;
pub const SLDF_ENABLE_TARGET_METADATA = SHELL_LINK_DATA_FLAGS.ENABLE_TARGET_METADATA;
pub const SLDF_DISABLE_LINK_PATH_TRACKING = SHELL_LINK_DATA_FLAGS.DISABLE_LINK_PATH_TRACKING;
pub const SLDF_DISABLE_KNOWNFOLDER_RELATIVE_TRACKING = SHELL_LINK_DATA_FLAGS.DISABLE_KNOWNFOLDER_RELATIVE_TRACKING;
pub const SLDF_NO_KF_ALIAS = SHELL_LINK_DATA_FLAGS.NO_KF_ALIAS;
pub const SLDF_ALLOW_LINK_TO_LINK = SHELL_LINK_DATA_FLAGS.ALLOW_LINK_TO_LINK;
pub const SLDF_UNALIAS_ON_SAVE = SHELL_LINK_DATA_FLAGS.UNALIAS_ON_SAVE;
pub const SLDF_PREFER_ENVIRONMENT_PATH = SHELL_LINK_DATA_FLAGS.PREFER_ENVIRONMENT_PATH;
pub const SLDF_KEEP_LOCAL_IDLIST_FOR_UNC_TARGET = SHELL_LINK_DATA_FLAGS.KEEP_LOCAL_IDLIST_FOR_UNC_TARGET;
pub const SLDF_PERSIST_VOLUME_ID_RELATIVE = SHELL_LINK_DATA_FLAGS.PERSIST_VOLUME_ID_RELATIVE;
pub const SLDF_VALID = SHELL_LINK_DATA_FLAGS.VALID;
pub const SLDF_RESERVED = SHELL_LINK_DATA_FLAGS.RESERVED;

pub const DATABLOCK_HEADER = extern struct {
    cbSize: u32 align(1),
    dwSignature: u32 align(1),
};

pub const NT_CONSOLE_PROPS = extern struct {
    dbh: DATABLOCK_HEADER align(1),
    wFillAttribute: u16 align(1),
    wPopupFillAttribute: u16 align(1),
    dwScreenBufferSize: COORD align(1),
    dwWindowSize: COORD align(1),
    dwWindowOrigin: COORD align(1),
    nFont: u32 align(1),
    nInputBufferSize: u32 align(1),
    dwFontSize: COORD align(1),
    uFontFamily: u32 align(1),
    uFontWeight: u32 align(1),
    FaceName: [32]u16 align(1),
    uCursorSize: u32 align(1),
    bFullScreen: BOOL align(1),
    bQuickEdit: BOOL align(1),
    bInsertMode: BOOL align(1),
    bAutoPosition: BOOL align(1),
    uHistoryBufferSize: u32 align(1),
    uNumberOfHistoryBuffers: u32 align(1),
    bHistoryNoDup: BOOL align(1),
    ColorTable: [16]u32 align(1),
};

pub const NT_FE_CONSOLE_PROPS = extern struct {
    dbh: DATABLOCK_HEADER align(1),
    uCodePage: u32 align(1),
};

pub const EXP_DARWIN_LINK = extern struct {
    dbh: DATABLOCK_HEADER align(1),
    szDarwinID: [260]CHAR align(1),
    szwDarwinID: [260]u16 align(1),
};

pub const EXP_SPECIAL_FOLDER = extern struct {
    cbSize: u32 align(1),
    dwSignature: u32 align(1),
    idSpecialFolder: u32 align(1),
    cbOffset: u32 align(1),
};

pub const EXP_SZ_LINK = extern struct {
    cbSize: u32 align(1),
    dwSignature: u32 align(1),
    szTarget: [260]CHAR align(1),
    swzTarget: [260]u16 align(1),
};

pub const EXP_PROPERTYSTORAGE = extern struct {
    cbSize: u32 align(1),
    dwSignature: u32 align(1),
    abPropertyStorage: [1]u8 align(1),
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IURLSearchHook_Value = Guid.initString("ac60f6a0-0fd9-11d0-99cb-00c04fd64497");
pub const IID_IURLSearchHook = &IID_IURLSearchHook_Value;
pub const IURLSearchHook = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Translate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IURLSearchHook,
                pwszSearchURL: [*:0]u16,
                cchBufferSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IURLSearchHook,
                pwszSearchURL: [*:0]u16,
                cchBufferSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IURLSearchHook_Translate(self: *const T, pwszSearchURL: [*:0]u16, cchBufferSize: u32) HRESULT {
                return @as(*const IURLSearchHook.VTable, @ptrCast(self.vtable)).Translate(@as(*const IURLSearchHook, @ptrCast(self)), pwszSearchURL, cchBufferSize);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ISearchContext_Value = Guid.initString("09f656a2-41af-480c-88f7-16cc0d164615");
pub const IID_ISearchContext = &IID_ISearchContext_Value;
pub const ISearchContext = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSearchUrl: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISearchContext,
                pbstrSearchUrl: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISearchContext,
                pbstrSearchUrl: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSearchText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISearchContext,
                pbstrSearchText: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISearchContext,
                pbstrSearchText: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSearchStyle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISearchContext,
                pdwSearchStyle: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISearchContext,
                pdwSearchStyle: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchContext_GetSearchUrl(self: *const T, pbstrSearchUrl: ?*?BSTR) HRESULT {
                return @as(*const ISearchContext.VTable, @ptrCast(self.vtable)).GetSearchUrl(@as(*const ISearchContext, @ptrCast(self)), pbstrSearchUrl);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchContext_GetSearchText(self: *const T, pbstrSearchText: ?*?BSTR) HRESULT {
                return @as(*const ISearchContext.VTable, @ptrCast(self.vtable)).GetSearchText(@as(*const ISearchContext, @ptrCast(self)), pbstrSearchText);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISearchContext_GetSearchStyle(self: *const T, pdwSearchStyle: ?*u32) HRESULT {
                return @as(*const ISearchContext.VTable, @ptrCast(self.vtable)).GetSearchStyle(@as(*const ISearchContext, @ptrCast(self)), pdwSearchStyle);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IURLSearchHook2_Value = Guid.initString("5ee44da4-6d32-46e3-86bc-07540dedd0e0");
pub const IID_IURLSearchHook2 = &IID_IURLSearchHook2_Value;
pub const IURLSearchHook2 = extern struct {
    pub const VTable = extern struct {
        base: IURLSearchHook.VTable,
        TranslateWithSearchContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IURLSearchHook2,
                pwszSearchURL: [*:0]u16,
                cchBufferSize: u32,
                pSearchContext: ?*ISearchContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IURLSearchHook2,
                pwszSearchURL: [*:0]u16,
                cchBufferSize: u32,
                pSearchContext: ?*ISearchContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IURLSearchHook.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IURLSearchHook2_TranslateWithSearchContext(self: *const T, pwszSearchURL: [*:0]u16, cchBufferSize: u32, pSearchContext: ?*ISearchContext) HRESULT {
                return @as(*const IURLSearchHook2.VTable, @ptrCast(self.vtable)).TranslateWithSearchContext(@as(*const IURLSearchHook2, @ptrCast(self)), pwszSearchURL, cchBufferSize, pSearchContext);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SHGFP_TYPE = enum(i32) {
    CURRENT = 0,
    DEFAULT = 1,
};
pub const SHGFP_TYPE_CURRENT = SHGFP_TYPE.CURRENT;
pub const SHGFP_TYPE_DEFAULT = SHGFP_TYPE.DEFAULT;

pub const KNOWN_FOLDER_FLAG = enum(i32) {
    DEFAULT = 0,
    FORCE_APP_DATA_REDIRECTION = 524288,
    RETURN_FILTER_REDIRECTION_TARGET = 262144,
    FORCE_PACKAGE_REDIRECTION = 131072,
    NO_PACKAGE_REDIRECTION = 65536,
    // FORCE_APPCONTAINER_REDIRECTION = 131072, this enum value conflicts with FORCE_PACKAGE_REDIRECTION
    // NO_APPCONTAINER_REDIRECTION = 65536, this enum value conflicts with NO_PACKAGE_REDIRECTION
    CREATE = 32768,
    DONT_VERIFY = 16384,
    DONT_UNEXPAND = 8192,
    NO_ALIAS = 4096,
    INIT = 2048,
    DEFAULT_PATH = 1024,
    NOT_PARENT_RELATIVE = 512,
    SIMPLE_IDLIST = 256,
    ALIAS_ONLY = -2147483648,
};
pub const KF_FLAG_DEFAULT = KNOWN_FOLDER_FLAG.DEFAULT;
pub const KF_FLAG_FORCE_APP_DATA_REDIRECTION = KNOWN_FOLDER_FLAG.FORCE_APP_DATA_REDIRECTION;
pub const KF_FLAG_RETURN_FILTER_REDIRECTION_TARGET = KNOWN_FOLDER_FLAG.RETURN_FILTER_REDIRECTION_TARGET;
pub const KF_FLAG_FORCE_PACKAGE_REDIRECTION = KNOWN_FOLDER_FLAG.FORCE_PACKAGE_REDIRECTION;
pub const KF_FLAG_NO_PACKAGE_REDIRECTION = KNOWN_FOLDER_FLAG.NO_PACKAGE_REDIRECTION;
pub const KF_FLAG_FORCE_APPCONTAINER_REDIRECTION = KNOWN_FOLDER_FLAG.FORCE_PACKAGE_REDIRECTION;
pub const KF_FLAG_NO_APPCONTAINER_REDIRECTION = KNOWN_FOLDER_FLAG.NO_PACKAGE_REDIRECTION;
pub const KF_FLAG_CREATE = KNOWN_FOLDER_FLAG.CREATE;
pub const KF_FLAG_DONT_VERIFY = KNOWN_FOLDER_FLAG.DONT_VERIFY;
pub const KF_FLAG_DONT_UNEXPAND = KNOWN_FOLDER_FLAG.DONT_UNEXPAND;
pub const KF_FLAG_NO_ALIAS = KNOWN_FOLDER_FLAG.NO_ALIAS;
pub const KF_FLAG_INIT = KNOWN_FOLDER_FLAG.INIT;
pub const KF_FLAG_DEFAULT_PATH = KNOWN_FOLDER_FLAG.DEFAULT_PATH;
pub const KF_FLAG_NOT_PARENT_RELATIVE = KNOWN_FOLDER_FLAG.NOT_PARENT_RELATIVE;
pub const KF_FLAG_SIMPLE_IDLIST = KNOWN_FOLDER_FLAG.SIMPLE_IDLIST;
pub const KF_FLAG_ALIAS_ONLY = KNOWN_FOLDER_FLAG.ALIAS_ONLY;

pub const SHFOLDERCUSTOMSETTINGS = extern struct {
    dwSize: u32,
    dwMask: u32,
    pvid: ?*Guid,
    pszWebViewTemplate: ?PWSTR,
    cchWebViewTemplate: u32,
    pszWebViewTemplateVersion: ?PWSTR,
    pszInfoTip: ?PWSTR,
    cchInfoTip: u32,
    pclsid: ?*Guid,
    dwFlags: u32,
    pszIconFile: ?PWSTR,
    cchIconFile: u32,
    iIconIndex: i32,
    pszLogo: ?PWSTR,
    cchLogo: u32,
};

pub const BFFCALLBACK = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        hwnd: ?HWND,
        uMsg: u32,
        lParam: LPARAM,
        lpData: LPARAM,
    ) callconv(@import("std").os.windows.WINAPI) i32,
    else => *const fn (
        hwnd: ?HWND,
        uMsg: u32,
        lParam: LPARAM,
        lpData: LPARAM,
    ) callconv(@import("std").os.windows.WINAPI) i32,
};

pub const BROWSEINFOA = extern struct {
    hwndOwner: ?HWND,
    pidlRoot: ?*ITEMIDLIST,
    pszDisplayName: ?PSTR,
    lpszTitle: ?[*:0]const u8,
    ulFlags: u32,
    lpfn: ?BFFCALLBACK,
    lParam: LPARAM,
    iImage: i32,
};

pub const BROWSEINFOW = extern struct {
    hwndOwner: ?HWND,
    pidlRoot: ?*ITEMIDLIST,
    pszDisplayName: ?PWSTR,
    lpszTitle: ?[*:0]const u16,
    ulFlags: u32,
    lpfn: ?BFFCALLBACK,
    lParam: LPARAM,
    iImage: i32,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IShellDetails_Value = Guid.initString("000214ec-0000-0000-c000-000000000046");
pub const IID_IShellDetails = &IID_IShellDetails_Value;
pub const IShellDetails = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDetailsOf: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellDetails,
                pidl: ?*ITEMIDLIST,
                iColumn: u32,
                pDetails: ?*SHELLDETAILS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellDetails,
                pidl: ?*ITEMIDLIST,
                iColumn: u32,
                pDetails: ?*SHELLDETAILS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ColumnClick: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellDetails,
                iColumn: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellDetails,
                iColumn: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellDetails_GetDetailsOf(self: *const T, pidl: ?*ITEMIDLIST, iColumn: u32, pDetails: ?*SHELLDETAILS) HRESULT {
                return @as(*const IShellDetails.VTable, @ptrCast(self.vtable)).GetDetailsOf(@as(*const IShellDetails, @ptrCast(self)), pidl, iColumn, pDetails);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellDetails_ColumnClick(self: *const T, iColumn: u32) HRESULT {
                return @as(*const IShellDetails.VTable, @ptrCast(self.vtable)).ColumnClick(@as(*const IShellDetails, @ptrCast(self)), iColumn);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IObjMgr_Value = Guid.initString("00bb2761-6a77-11d0-a535-00c04fd7d062");
pub const IID_IObjMgr = &IID_IObjMgr_Value;
pub const IObjMgr = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Append: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IObjMgr,
                punk: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IObjMgr,
                punk: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Remove: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IObjMgr,
                punk: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IObjMgr,
                punk: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IObjMgr_Append(self: *const T, punk: ?*IUnknown) HRESULT {
                return @as(*const IObjMgr.VTable, @ptrCast(self.vtable)).Append(@as(*const IObjMgr, @ptrCast(self)), punk);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IObjMgr_Remove(self: *const T, punk: ?*IUnknown) HRESULT {
                return @as(*const IObjMgr.VTable, @ptrCast(self.vtable)).Remove(@as(*const IObjMgr, @ptrCast(self)), punk);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IACList_Value = Guid.initString("77a130b0-94fd-11d0-a544-00c04fd7d062");
pub const IID_IACList = &IID_IACList_Value;
pub const IACList = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Expand: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IACList,
                pszExpand: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IACList,
                pszExpand: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IACList_Expand(self: *const T, pszExpand: ?[*:0]const u16) HRESULT {
                return @as(*const IACList.VTable, @ptrCast(self.vtable)).Expand(@as(*const IACList, @ptrCast(self)), pszExpand);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const AUTOCOMPLETELISTOPTIONS = enum(i32) {
    NONE = 0,
    CURRENTDIR = 1,
    MYCOMPUTER = 2,
    DESKTOP = 4,
    FAVORITES = 8,
    FILESYSONLY = 16,
    FILESYSDIRS = 32,
    VIRTUALNAMESPACE = 64,
};
pub const ACLO_NONE = AUTOCOMPLETELISTOPTIONS.NONE;
pub const ACLO_CURRENTDIR = AUTOCOMPLETELISTOPTIONS.CURRENTDIR;
pub const ACLO_MYCOMPUTER = AUTOCOMPLETELISTOPTIONS.MYCOMPUTER;
pub const ACLO_DESKTOP = AUTOCOMPLETELISTOPTIONS.DESKTOP;
pub const ACLO_FAVORITES = AUTOCOMPLETELISTOPTIONS.FAVORITES;
pub const ACLO_FILESYSONLY = AUTOCOMPLETELISTOPTIONS.FILESYSONLY;
pub const ACLO_FILESYSDIRS = AUTOCOMPLETELISTOPTIONS.FILESYSDIRS;
pub const ACLO_VIRTUALNAMESPACE = AUTOCOMPLETELISTOPTIONS.VIRTUALNAMESPACE;

// TODO: this type is limited to platform 'windows5.0'
const IID_IACList2_Value = Guid.initString("470141a0-5186-11d2-bbb6-0060977b464c");
pub const IID_IACList2 = &IID_IACList2_Value;
pub const IACList2 = extern struct {
    pub const VTable = extern struct {
        base: IACList.VTable,
        SetOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IACList2,
                dwFlag: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IACList2,
                dwFlag: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IACList2,
                pdwFlag: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IACList2,
                pdwFlag: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IACList.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IACList2_SetOptions(self: *const T, dwFlag: u32) HRESULT {
                return @as(*const IACList2.VTable, @ptrCast(self.vtable)).SetOptions(@as(*const IACList2, @ptrCast(self)), dwFlag);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IACList2_GetOptions(self: *const T, pdwFlag: ?*u32) HRESULT {
                return @as(*const IACList2.VTable, @ptrCast(self.vtable)).GetOptions(@as(*const IACList2, @ptrCast(self)), pdwFlag);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IProgressDialog_Value = Guid.initString("ebbc7c04-315e-11d2-b62f-006097df5bd4");
pub const IID_IProgressDialog = &IID_IProgressDialog_Value;
pub const IProgressDialog = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        StartProgressDialog: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IProgressDialog,
                hwndParent: ?HWND,
                punkEnableModless: ?*IUnknown,
                dwFlags: u32,
                pvResevered: ?*const anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IProgressDialog,
                hwndParent: ?HWND,
                punkEnableModless: ?*IUnknown,
                dwFlags: u32,
                pvResevered: ?*const anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StopProgressDialog: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IProgressDialog,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IProgressDialog,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTitle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IProgressDialog,
                pwzTitle: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IProgressDialog,
                pwzTitle: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetAnimation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IProgressDialog,
                hInstAnimation: ?HINSTANCE,
                idAnimation: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IProgressDialog,
                hInstAnimation: ?HINSTANCE,
                idAnimation: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        HasUserCancelled: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IProgressDialog,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
            else => *const fn (
                self: *const IProgressDialog,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
        },
        SetProgress: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IProgressDialog,
                dwCompleted: u32,
                dwTotal: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IProgressDialog,
                dwCompleted: u32,
                dwTotal: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetProgress64: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IProgressDialog,
                ullCompleted: u64,
                ullTotal: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IProgressDialog,
                ullCompleted: u64,
                ullTotal: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetLine: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IProgressDialog,
                dwLineNum: u32,
                pwzString: ?[*:0]const u16,
                fCompactPath: BOOL,
                pvResevered: ?*const anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IProgressDialog,
                dwLineNum: u32,
                pwzString: ?[*:0]const u16,
                fCompactPath: BOOL,
                pvResevered: ?*const anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCancelMsg: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IProgressDialog,
                pwzCancelMsg: ?[*:0]const u16,
                pvResevered: ?*const anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IProgressDialog,
                pwzCancelMsg: ?[*:0]const u16,
                pvResevered: ?*const anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Timer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IProgressDialog,
                dwTimerAction: u32,
                pvResevered: ?*const anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IProgressDialog,
                dwTimerAction: u32,
                pvResevered: ?*const anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IProgressDialog_StartProgressDialog(self: *const T, hwndParent: ?HWND, punkEnableModless: ?*IUnknown, dwFlags: u32, pvResevered: ?*const anyopaque) HRESULT {
                return @as(*const IProgressDialog.VTable, @ptrCast(self.vtable)).StartProgressDialog(@as(*const IProgressDialog, @ptrCast(self)), hwndParent, punkEnableModless, dwFlags, pvResevered);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IProgressDialog_StopProgressDialog(self: *const T) HRESULT {
                return @as(*const IProgressDialog.VTable, @ptrCast(self.vtable)).StopProgressDialog(@as(*const IProgressDialog, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IProgressDialog_SetTitle(self: *const T, pwzTitle: ?[*:0]const u16) HRESULT {
                return @as(*const IProgressDialog.VTable, @ptrCast(self.vtable)).SetTitle(@as(*const IProgressDialog, @ptrCast(self)), pwzTitle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IProgressDialog_SetAnimation(self: *const T, hInstAnimation: ?HINSTANCE, idAnimation: u32) HRESULT {
                return @as(*const IProgressDialog.VTable, @ptrCast(self.vtable)).SetAnimation(@as(*const IProgressDialog, @ptrCast(self)), hInstAnimation, idAnimation);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IProgressDialog_HasUserCancelled(self: *const T) BOOL {
                return @as(*const IProgressDialog.VTable, @ptrCast(self.vtable)).HasUserCancelled(@as(*const IProgressDialog, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IProgressDialog_SetProgress(self: *const T, dwCompleted: u32, dwTotal: u32) HRESULT {
                return @as(*const IProgressDialog.VTable, @ptrCast(self.vtable)).SetProgress(@as(*const IProgressDialog, @ptrCast(self)), dwCompleted, dwTotal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IProgressDialog_SetProgress64(self: *const T, ullCompleted: u64, ullTotal: u64) HRESULT {
                return @as(*const IProgressDialog.VTable, @ptrCast(self.vtable)).SetProgress64(@as(*const IProgressDialog, @ptrCast(self)), ullCompleted, ullTotal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IProgressDialog_SetLine(self: *const T, dwLineNum: u32, pwzString: ?[*:0]const u16, fCompactPath: BOOL, pvResevered: ?*const anyopaque) HRESULT {
                return @as(*const IProgressDialog.VTable, @ptrCast(self.vtable)).SetLine(@as(*const IProgressDialog, @ptrCast(self)), dwLineNum, pwzString, fCompactPath, pvResevered);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IProgressDialog_SetCancelMsg(self: *const T, pwzCancelMsg: ?[*:0]const u16, pvResevered: ?*const anyopaque) HRESULT {
                return @as(*const IProgressDialog.VTable, @ptrCast(self.vtable)).SetCancelMsg(@as(*const IProgressDialog, @ptrCast(self)), pwzCancelMsg, pvResevered);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IProgressDialog_Timer(self: *const T, dwTimerAction: u32, pvResevered: ?*const anyopaque) HRESULT {
                return @as(*const IProgressDialog.VTable, @ptrCast(self.vtable)).Timer(@as(*const IProgressDialog, @ptrCast(self)), dwTimerAction, pvResevered);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IDockingWindowSite_Value = Guid.initString("2a342fc2-7b26-11d0-8ca9-00a0c92dbfe8");
pub const IID_IDockingWindowSite = &IID_IDockingWindowSite_Value;
pub const IDockingWindowSite = extern struct {
    pub const VTable = extern struct {
        base: IOleWindow.VTable,
        GetBorderDW: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDockingWindowSite,
                punkObj: ?*IUnknown,
                prcBorder: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDockingWindowSite,
                punkObj: ?*IUnknown,
                prcBorder: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RequestBorderSpaceDW: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDockingWindowSite,
                punkObj: ?*IUnknown,
                pbw: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDockingWindowSite,
                punkObj: ?*IUnknown,
                pbw: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetBorderSpaceDW: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDockingWindowSite,
                punkObj: ?*IUnknown,
                pbw: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDockingWindowSite,
                punkObj: ?*IUnknown,
                pbw: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IOleWindow.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDockingWindowSite_GetBorderDW(self: *const T, punkObj: ?*IUnknown, prcBorder: ?*RECT) HRESULT {
                return @as(*const IDockingWindowSite.VTable, @ptrCast(self.vtable)).GetBorderDW(@as(*const IDockingWindowSite, @ptrCast(self)), punkObj, prcBorder);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDockingWindowSite_RequestBorderSpaceDW(self: *const T, punkObj: ?*IUnknown, pbw: ?*RECT) HRESULT {
                return @as(*const IDockingWindowSite.VTable, @ptrCast(self.vtable)).RequestBorderSpaceDW(@as(*const IDockingWindowSite, @ptrCast(self)), punkObj, pbw);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDockingWindowSite_SetBorderSpaceDW(self: *const T, punkObj: ?*IUnknown, pbw: ?*RECT) HRESULT {
                return @as(*const IDockingWindowSite.VTable, @ptrCast(self.vtable)).SetBorderSpaceDW(@as(*const IDockingWindowSite, @ptrCast(self)), punkObj, pbw);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const NRESARRAY = extern struct {
    cItems: u32,
    nr: [1]NETRESOURCEA,
};

pub const CIDA = extern struct {
    cidl: u32 align(1),
    aoffset: [1]u32 align(1),
};

pub const FD_FLAGS = enum(i32) {
    CLSID = 1,
    SIZEPOINT = 2,
    ATTRIBUTES = 4,
    CREATETIME = 8,
    ACCESSTIME = 16,
    WRITESTIME = 32,
    FILESIZE = 64,
    PROGRESSUI = 16384,
    LINKUI = 32768,
    UNICODE = -2147483648,
};
pub const FD_CLSID = FD_FLAGS.CLSID;
pub const FD_SIZEPOINT = FD_FLAGS.SIZEPOINT;
pub const FD_ATTRIBUTES = FD_FLAGS.ATTRIBUTES;
pub const FD_CREATETIME = FD_FLAGS.CREATETIME;
pub const FD_ACCESSTIME = FD_FLAGS.ACCESSTIME;
pub const FD_WRITESTIME = FD_FLAGS.WRITESTIME;
pub const FD_FILESIZE = FD_FLAGS.FILESIZE;
pub const FD_PROGRESSUI = FD_FLAGS.PROGRESSUI;
pub const FD_LINKUI = FD_FLAGS.LINKUI;
pub const FD_UNICODE = FD_FLAGS.UNICODE;

pub const FILEDESCRIPTORA = extern struct {
    dwFlags: u32 align(1),
    clsid: Guid align(1),
    sizel: SIZE align(1),
    pointl: POINTL align(1),
    dwFileAttributes: u32 align(1),
    ftCreationTime: FILETIME align(1),
    ftLastAccessTime: FILETIME align(1),
    ftLastWriteTime: FILETIME align(1),
    nFileSizeHigh: u32 align(1),
    nFileSizeLow: u32 align(1),
    cFileName: [260]CHAR align(1),
};

pub const FILEDESCRIPTORW = extern struct {
    dwFlags: u32 align(1),
    clsid: Guid align(1),
    sizel: SIZE align(1),
    pointl: POINTL align(1),
    dwFileAttributes: u32 align(1),
    ftCreationTime: FILETIME align(1),
    ftLastAccessTime: FILETIME align(1),
    ftLastWriteTime: FILETIME align(1),
    nFileSizeHigh: u32 align(1),
    nFileSizeLow: u32 align(1),
    cFileName: [260]u16 align(1),
};

// TODO: not generating this type because array of 'win32.ui.shell.FILEDESCRIPTORA' not allowed in packed struct due to padding bits
pub const FILEGROUPDESCRIPTORA = usize;

pub const FILEGROUPDESCRIPTORW = extern struct {
    cItems: u32 align(1),
    fgd: [1]FILEDESCRIPTORW align(1),
};

pub const DROPFILES = extern struct {
    pFiles: u32 align(1),
    pt: POINT align(1),
    fNC: BOOL align(1),
    fWide: BOOL align(1),
};

pub const FILE_ATTRIBUTES_ARRAY = extern struct {
    cItems: u32 align(1),
    dwSumFileAttributes: u32 align(1),
    dwProductFileAttributes: u32 align(1),
    rgdwFileAttributes: [1]u32 align(1),
};

pub const DROPIMAGETYPE = enum(i32) {
    INVALID = -1,
    NONE = 0,
    COPY = 1,
    MOVE = 2,
    LINK = 4,
    LABEL = 6,
    WARNING = 7,
    NOIMAGE = 8,
};
pub const DROPIMAGE_INVALID = DROPIMAGETYPE.INVALID;
pub const DROPIMAGE_NONE = DROPIMAGETYPE.NONE;
pub const DROPIMAGE_COPY = DROPIMAGETYPE.COPY;
pub const DROPIMAGE_MOVE = DROPIMAGETYPE.MOVE;
pub const DROPIMAGE_LINK = DROPIMAGETYPE.LINK;
pub const DROPIMAGE_LABEL = DROPIMAGETYPE.LABEL;
pub const DROPIMAGE_WARNING = DROPIMAGETYPE.WARNING;
pub const DROPIMAGE_NOIMAGE = DROPIMAGETYPE.NOIMAGE;

pub const DROPDESCRIPTION = extern struct {
    type: DROPIMAGETYPE align(1),
    szMessage: [260]u16 align(1),
    szInsert: [260]u16 align(1),
};

pub const SHChangeNotifyEntry = extern struct {
    pidl: ?*ITEMIDLIST align(1),
    fRecursive: BOOL align(1),
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IShellChangeNotify_Value = Guid.initString("d82be2b1-5764-11d0-a96e-00c04fd705a2");
pub const IID_IShellChangeNotify = &IID_IShellChangeNotify_Value;
pub const IShellChangeNotify = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellChangeNotify,
                lEvent: i32,
                pidl1: ?*ITEMIDLIST,
                pidl2: ?*ITEMIDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellChangeNotify,
                lEvent: i32,
                pidl1: ?*ITEMIDLIST,
                pidl2: ?*ITEMIDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellChangeNotify_OnChange(self: *const T, lEvent: i32, pidl1: ?*ITEMIDLIST, pidl2: ?*ITEMIDLIST) HRESULT {
                return @as(*const IShellChangeNotify.VTable, @ptrCast(self.vtable)).OnChange(@as(*const IShellChangeNotify, @ptrCast(self)), lEvent, pidl1, pidl2);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IQueryInfo_Value = Guid.initString("00021500-0000-0000-c000-000000000046");
pub const IID_IQueryInfo = &IID_IQueryInfo_Value;
pub const IQueryInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetInfoTip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IQueryInfo,
                dwFlags: QITIPF_FLAGS,
                ppwszTip: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IQueryInfo,
                dwFlags: QITIPF_FLAGS,
                ppwszTip: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInfoFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IQueryInfo,
                pdwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IQueryInfo,
                pdwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IQueryInfo_GetInfoTip(self: *const T, dwFlags: QITIPF_FLAGS, ppwszTip: ?*?PWSTR) HRESULT {
                return @as(*const IQueryInfo.VTable, @ptrCast(self.vtable)).GetInfoTip(@as(*const IQueryInfo, @ptrCast(self)), dwFlags, ppwszTip);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IQueryInfo_GetInfoFlags(self: *const T, pdwFlags: ?*u32) HRESULT {
                return @as(*const IQueryInfo.VTable, @ptrCast(self.vtable)).GetInfoFlags(@as(*const IQueryInfo, @ptrCast(self)), pdwFlags);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SHARD = enum(i32) {
    PIDL = 1,
    PATHA = 2,
    PATHW = 3,
    APPIDINFO = 4,
    APPIDINFOIDLIST = 5,
    LINK = 6,
    APPIDINFOLINK = 7,
    SHELLITEM = 8,
};
pub const SHARD_PIDL = SHARD.PIDL;
pub const SHARD_PATHA = SHARD.PATHA;
pub const SHARD_PATHW = SHARD.PATHW;
pub const SHARD_APPIDINFO = SHARD.APPIDINFO;
pub const SHARD_APPIDINFOIDLIST = SHARD.APPIDINFOIDLIST;
pub const SHARD_LINK = SHARD.LINK;
pub const SHARD_APPIDINFOLINK = SHARD.APPIDINFOLINK;
pub const SHARD_SHELLITEM = SHARD.SHELLITEM;

pub const SHARDAPPIDINFO = extern struct {
    psi: ?*IShellItem align(1),
    pszAppID: ?[*:0]const u16 align(1),
};

pub const SHARDAPPIDINFOIDLIST = extern struct {
    pidl: ?*ITEMIDLIST align(1),
    pszAppID: ?[*:0]const u16 align(1),
};

pub const SHARDAPPIDINFOLINK = extern struct {
    psl: ?*IShellLinkA align(1),
    pszAppID: ?[*:0]const u16 align(1),
};

pub const SHChangeDWORDAsIDList = extern struct {
    cb: u16 align(1),
    dwItem1: u32 align(1),
    dwItem2: u32 align(1),
    cbZero: u16 align(1),
};

pub const SHChangeUpdateImageIDList = extern struct {
    cb: u16 align(1),
    iIconIndex: i32 align(1),
    iCurIndex: i32 align(1),
    uFlags: u32 align(1),
    dwProcessID: u32 align(1),
    szName: [260]u16 align(1),
    cbZero: u16 align(1),
};

pub const SCNRT_STATUS = enum(i32) {
    ENABLE = 0,
    DISABLE = 1,
};
pub const SCNRT_ENABLE = SCNRT_STATUS.ENABLE;
pub const SCNRT_DISABLE = SCNRT_STATUS.DISABLE;

pub const SHDESCRIPTIONID = extern struct {
    dwDescriptionId: SHDID_ID,
    clsid: Guid,
};

pub const AUTO_SCROLL_DATA = extern struct {
    iNextSample: i32 align(1),
    dwLastScroll: u32 align(1),
    bFull: BOOL align(1),
    pts: [3]POINT align(1),
    dwTimes: [3]u32 align(1),
};

pub const CABINETSTATE = extern struct {
    cLength: u16 align(1),
    nVersion: u16 align(1),
    _bitfield: i32 align(1),
    fMenuEnumFilter: u32 align(1),
};

pub const RESTRICTIONS = enum(i32) {
    NONE = 0,
    NORUN = 1,
    NOCLOSE = 2,
    NOSAVESET = 4,
    NOFILEMENU = 8,
    NOSETFOLDERS = 16,
    NOSETTASKBAR = 32,
    NODESKTOP = 64,
    NOFIND = 128,
    NODRIVES = 256,
    NODRIVEAUTORUN = 512,
    NODRIVETYPEAUTORUN = 1024,
    NONETHOOD = 2048,
    STARTBANNER = 4096,
    RESTRICTRUN = 8192,
    NOPRINTERTABS = 16384,
    NOPRINTERDELETE = 32768,
    NOPRINTERADD = 65536,
    NOSTARTMENUSUBFOLDERS = 131072,
    MYDOCSONNET = 262144,
    NOEXITTODOS = 524288,
    ENFORCESHELLEXTSECURITY = 1048576,
    LINKRESOLVEIGNORELINKINFO = 2097152,
    NOCOMMONGROUPS = 4194304,
    SEPARATEDESKTOPPROCESS = 8388608,
    NOWEB = 16777216,
    NOTRAYCONTEXTMENU = 33554432,
    NOVIEWCONTEXTMENU = 67108864,
    NONETCONNECTDISCONNECT = 134217728,
    STARTMENULOGOFF = 268435456,
    NOSETTINGSASSIST = 536870912,
    NOINTERNETICON = 1073741825,
    NORECENTDOCSHISTORY = 1073741826,
    NORECENTDOCSMENU = 1073741827,
    NOACTIVEDESKTOP = 1073741828,
    NOACTIVEDESKTOPCHANGES = 1073741829,
    NOFAVORITESMENU = 1073741830,
    CLEARRECENTDOCSONEXIT = 1073741831,
    CLASSICSHELL = 1073741832,
    NOCUSTOMIZEWEBVIEW = 1073741833,
    NOHTMLWALLPAPER = 1073741840,
    NOCHANGINGWALLPAPER = 1073741841,
    NODESKCOMP = 1073741842,
    NOADDDESKCOMP = 1073741843,
    NODELDESKCOMP = 1073741844,
    NOCLOSEDESKCOMP = 1073741845,
    NOCLOSE_DRAGDROPBAND = 1073741846,
    NOMOVINGBAND = 1073741847,
    NOEDITDESKCOMP = 1073741848,
    NORESOLVESEARCH = 1073741849,
    NORESOLVETRACK = 1073741850,
    FORCECOPYACLWITHFILE = 1073741851,
    NOFORGETSOFTWAREUPDATE = 1073741853,
    NOSETACTIVEDESKTOP = 1073741854,
    NOUPDATEWINDOWS = 1073741855,
    NOCHANGESTARMENU = 1073741856,
    NOFOLDEROPTIONS = 1073741857,
    HASFINDCOMPUTERS = 1073741858,
    INTELLIMENUS = 1073741859,
    RUNDLGMEMCHECKBOX = 1073741860,
    ARP_ShowPostSetup = 1073741861,
    NOCSC = 1073741862,
    NOCONTROLPANEL = 1073741863,
    ENUMWORKGROUP = 1073741864,
    ARP_NOARP = 1073741865,
    ARP_NOREMOVEPAGE = 1073741866,
    ARP_NOADDPAGE = 1073741867,
    ARP_NOWINSETUPPAGE = 1073741868,
    GREYMSIADS = 1073741869,
    NOCHANGEMAPPEDDRIVELABEL = 1073741870,
    NOCHANGEMAPPEDDRIVECOMMENT = 1073741871,
    MaxRecentDocs = 1073741872,
    NONETWORKCONNECTIONS = 1073741873,
    FORCESTARTMENULOGOFF = 1073741874,
    NOWEBVIEW = 1073741875,
    NOCUSTOMIZETHISFOLDER = 1073741876,
    NOENCRYPTION = 1073741877,
    DONTSHOWSUPERHIDDEN = 1073741879,
    NOSHELLSEARCHBUTTON = 1073741880,
    NOHARDWARETAB = 1073741881,
    NORUNASINSTALLPROMPT = 1073741882,
    PROMPTRUNASINSTALLNETPATH = 1073741883,
    NOMANAGEMYCOMPUTERVERB = 1073741884,
    DISALLOWRUN = 1073741886,
    NOWELCOMESCREEN = 1073741887,
    RESTRICTCPL = 1073741888,
    DISALLOWCPL = 1073741889,
    NOSMBALLOONTIP = 1073741890,
    NOSMHELP = 1073741891,
    NOWINKEYS = 1073741892,
    NOENCRYPTONMOVE = 1073741893,
    NOLOCALMACHINERUN = 1073741894,
    NOCURRENTUSERRUN = 1073741895,
    NOLOCALMACHINERUNONCE = 1073741896,
    NOCURRENTUSERRUNONCE = 1073741897,
    FORCEACTIVEDESKTOPON = 1073741898,
    NOVIEWONDRIVE = 1073741900,
    NONETCRAWL = 1073741901,
    NOSHAREDDOCUMENTS = 1073741902,
    NOSMMYDOCS = 1073741903,
    NOSMMYPICS = 1073741904,
    ALLOWBITBUCKDRIVES = 1073741905,
    NONLEGACYSHELLMODE = 1073741906,
    NOCONTROLPANELBARRICADE = 1073741907,
    NOSTARTPAGE = 1073741908,
    NOAUTOTRAYNOTIFY = 1073741909,
    NOTASKGROUPING = 1073741910,
    NOCDBURNING = 1073741911,
    MYCOMPNOPROP = 1073741912,
    MYDOCSNOPROP = 1073741913,
    NOSTARTPANEL = 1073741914,
    NODISPLAYAPPEARANCEPAGE = 1073741915,
    NOTHEMESTAB = 1073741916,
    NOVISUALSTYLECHOICE = 1073741917,
    NOSIZECHOICE = 1073741918,
    NOCOLORCHOICE = 1073741919,
    SETVISUALSTYLE = 1073741920,
    STARTRUNNOHOMEPATH = 1073741921,
    NOUSERNAMEINSTARTPANEL = 1073741922,
    NOMYCOMPUTERICON = 1073741923,
    NOSMNETWORKPLACES = 1073741924,
    NOSMPINNEDLIST = 1073741925,
    NOSMMYMUSIC = 1073741926,
    NOSMEJECTPC = 1073741927,
    NOSMMOREPROGRAMS = 1073741928,
    NOSMMFUPROGRAMS = 1073741929,
    NOTRAYITEMSDISPLAY = 1073741930,
    NOTOOLBARSONTASKBAR = 1073741931,
    NOSMCONFIGUREPROGRAMS = 1073741935,
    HIDECLOCK = 1073741936,
    NOLOWDISKSPACECHECKS = 1073741937,
    NOENTIRENETWORK = 1073741938,
    NODESKTOPCLEANUP = 1073741939,
    BITBUCKNUKEONDELETE = 1073741940,
    BITBUCKCONFIRMDELETE = 1073741941,
    BITBUCKNOPROP = 1073741942,
    NODISPBACKGROUND = 1073741943,
    NODISPSCREENSAVEPG = 1073741944,
    NODISPSETTINGSPG = 1073741945,
    NODISPSCREENSAVEPREVIEW = 1073741946,
    NODISPLAYCPL = 1073741947,
    HIDERUNASVERB = 1073741948,
    NOTHUMBNAILCACHE = 1073741949,
    NOSTRCMPLOGICAL = 1073741950,
    NOPUBLISHWIZARD = 1073741951,
    NOONLINEPRINTSWIZARD = 1073741952,
    NOWEBSERVICES = 1073741953,
    ALLOWUNHASHEDWEBVIEW = 1073741954,
    ALLOWLEGACYWEBVIEW = 1073741955,
    REVERTWEBVIEWSECURITY = 1073741956,
    INHERITCONSOLEHANDLES = 1073741958,
    NOREMOTERECURSIVEEVENTS = 1073741961,
    NOREMOTECHANGENOTIFY = 1073741969,
    NOENUMENTIRENETWORK = 1073741971,
    NOINTERNETOPENWITH = 1073741973,
    DONTRETRYBADNETNAME = 1073741979,
    ALLOWFILECLSIDJUNCTIONS = 1073741980,
    NOUPNPINSTALL = 1073741981,
    ARP_DONTGROUPPATCHES = 1073741996,
    ARP_NOCHOOSEPROGRAMSPAGE = 1073741997,
    NODISCONNECT = 1090519041,
    NOSECURITY = 1090519042,
    NOFILEASSOCIATE = 1090519043,
    ALLOWCOMMENTTOGGLE = 1090519044,
};
pub const REST_NONE = RESTRICTIONS.NONE;
pub const REST_NORUN = RESTRICTIONS.NORUN;
pub const REST_NOCLOSE = RESTRICTIONS.NOCLOSE;
pub const REST_NOSAVESET = RESTRICTIONS.NOSAVESET;
pub const REST_NOFILEMENU = RESTRICTIONS.NOFILEMENU;
pub const REST_NOSETFOLDERS = RESTRICTIONS.NOSETFOLDERS;
pub const REST_NOSETTASKBAR = RESTRICTIONS.NOSETTASKBAR;
pub const REST_NODESKTOP = RESTRICTIONS.NODESKTOP;
pub const REST_NOFIND = RESTRICTIONS.NOFIND;
pub const REST_NODRIVES = RESTRICTIONS.NODRIVES;
pub const REST_NODRIVEAUTORUN = RESTRICTIONS.NODRIVEAUTORUN;
pub const REST_NODRIVETYPEAUTORUN = RESTRICTIONS.NODRIVETYPEAUTORUN;
pub const REST_NONETHOOD = RESTRICTIONS.NONETHOOD;
pub const REST_STARTBANNER = RESTRICTIONS.STARTBANNER;
pub const REST_RESTRICTRUN = RESTRICTIONS.RESTRICTRUN;
pub const REST_NOPRINTERTABS = RESTRICTIONS.NOPRINTERTABS;
pub const REST_NOPRINTERDELETE = RESTRICTIONS.NOPRINTERDELETE;
pub const REST_NOPRINTERADD = RESTRICTIONS.NOPRINTERADD;
pub const REST_NOSTARTMENUSUBFOLDERS = RESTRICTIONS.NOSTARTMENUSUBFOLDERS;
pub const REST_MYDOCSONNET = RESTRICTIONS.MYDOCSONNET;
pub const REST_NOEXITTODOS = RESTRICTIONS.NOEXITTODOS;
pub const REST_ENFORCESHELLEXTSECURITY = RESTRICTIONS.ENFORCESHELLEXTSECURITY;
pub const REST_LINKRESOLVEIGNORELINKINFO = RESTRICTIONS.LINKRESOLVEIGNORELINKINFO;
pub const REST_NOCOMMONGROUPS = RESTRICTIONS.NOCOMMONGROUPS;
pub const REST_SEPARATEDESKTOPPROCESS = RESTRICTIONS.SEPARATEDESKTOPPROCESS;
pub const REST_NOWEB = RESTRICTIONS.NOWEB;
pub const REST_NOTRAYCONTEXTMENU = RESTRICTIONS.NOTRAYCONTEXTMENU;
pub const REST_NOVIEWCONTEXTMENU = RESTRICTIONS.NOVIEWCONTEXTMENU;
pub const REST_NONETCONNECTDISCONNECT = RESTRICTIONS.NONETCONNECTDISCONNECT;
pub const REST_STARTMENULOGOFF = RESTRICTIONS.STARTMENULOGOFF;
pub const REST_NOSETTINGSASSIST = RESTRICTIONS.NOSETTINGSASSIST;
pub const REST_NOINTERNETICON = RESTRICTIONS.NOINTERNETICON;
pub const REST_NORECENTDOCSHISTORY = RESTRICTIONS.NORECENTDOCSHISTORY;
pub const REST_NORECENTDOCSMENU = RESTRICTIONS.NORECENTDOCSMENU;
pub const REST_NOACTIVEDESKTOP = RESTRICTIONS.NOACTIVEDESKTOP;
pub const REST_NOACTIVEDESKTOPCHANGES = RESTRICTIONS.NOACTIVEDESKTOPCHANGES;
pub const REST_NOFAVORITESMENU = RESTRICTIONS.NOFAVORITESMENU;
pub const REST_CLEARRECENTDOCSONEXIT = RESTRICTIONS.CLEARRECENTDOCSONEXIT;
pub const REST_CLASSICSHELL = RESTRICTIONS.CLASSICSHELL;
pub const REST_NOCUSTOMIZEWEBVIEW = RESTRICTIONS.NOCUSTOMIZEWEBVIEW;
pub const REST_NOHTMLWALLPAPER = RESTRICTIONS.NOHTMLWALLPAPER;
pub const REST_NOCHANGINGWALLPAPER = RESTRICTIONS.NOCHANGINGWALLPAPER;
pub const REST_NODESKCOMP = RESTRICTIONS.NODESKCOMP;
pub const REST_NOADDDESKCOMP = RESTRICTIONS.NOADDDESKCOMP;
pub const REST_NODELDESKCOMP = RESTRICTIONS.NODELDESKCOMP;
pub const REST_NOCLOSEDESKCOMP = RESTRICTIONS.NOCLOSEDESKCOMP;
pub const REST_NOCLOSE_DRAGDROPBAND = RESTRICTIONS.NOCLOSE_DRAGDROPBAND;
pub const REST_NOMOVINGBAND = RESTRICTIONS.NOMOVINGBAND;
pub const REST_NOEDITDESKCOMP = RESTRICTIONS.NOEDITDESKCOMP;
pub const REST_NORESOLVESEARCH = RESTRICTIONS.NORESOLVESEARCH;
pub const REST_NORESOLVETRACK = RESTRICTIONS.NORESOLVETRACK;
pub const REST_FORCECOPYACLWITHFILE = RESTRICTIONS.FORCECOPYACLWITHFILE;
pub const REST_NOFORGETSOFTWAREUPDATE = RESTRICTIONS.NOFORGETSOFTWAREUPDATE;
pub const REST_NOSETACTIVEDESKTOP = RESTRICTIONS.NOSETACTIVEDESKTOP;
pub const REST_NOUPDATEWINDOWS = RESTRICTIONS.NOUPDATEWINDOWS;
pub const REST_NOCHANGESTARMENU = RESTRICTIONS.NOCHANGESTARMENU;
pub const REST_NOFOLDEROPTIONS = RESTRICTIONS.NOFOLDEROPTIONS;
pub const REST_HASFINDCOMPUTERS = RESTRICTIONS.HASFINDCOMPUTERS;
pub const REST_INTELLIMENUS = RESTRICTIONS.INTELLIMENUS;
pub const REST_RUNDLGMEMCHECKBOX = RESTRICTIONS.RUNDLGMEMCHECKBOX;
pub const REST_ARP_ShowPostSetup = RESTRICTIONS.ARP_ShowPostSetup;
pub const REST_NOCSC = RESTRICTIONS.NOCSC;
pub const REST_NOCONTROLPANEL = RESTRICTIONS.NOCONTROLPANEL;
pub const REST_ENUMWORKGROUP = RESTRICTIONS.ENUMWORKGROUP;
pub const REST_ARP_NOARP = RESTRICTIONS.ARP_NOARP;
pub const REST_ARP_NOREMOVEPAGE = RESTRICTIONS.ARP_NOREMOVEPAGE;
pub const REST_ARP_NOADDPAGE = RESTRICTIONS.ARP_NOADDPAGE;
pub const REST_ARP_NOWINSETUPPAGE = RESTRICTIONS.ARP_NOWINSETUPPAGE;
pub const REST_GREYMSIADS = RESTRICTIONS.GREYMSIADS;
pub const REST_NOCHANGEMAPPEDDRIVELABEL = RESTRICTIONS.NOCHANGEMAPPEDDRIVELABEL;
pub const REST_NOCHANGEMAPPEDDRIVECOMMENT = RESTRICTIONS.NOCHANGEMAPPEDDRIVECOMMENT;
pub const REST_MaxRecentDocs = RESTRICTIONS.MaxRecentDocs;
pub const REST_NONETWORKCONNECTIONS = RESTRICTIONS.NONETWORKCONNECTIONS;
pub const REST_FORCESTARTMENULOGOFF = RESTRICTIONS.FORCESTARTMENULOGOFF;
pub const REST_NOWEBVIEW = RESTRICTIONS.NOWEBVIEW;
pub const REST_NOCUSTOMIZETHISFOLDER = RESTRICTIONS.NOCUSTOMIZETHISFOLDER;
pub const REST_NOENCRYPTION = RESTRICTIONS.NOENCRYPTION;
pub const REST_DONTSHOWSUPERHIDDEN = RESTRICTIONS.DONTSHOWSUPERHIDDEN;
pub const REST_NOSHELLSEARCHBUTTON = RESTRICTIONS.NOSHELLSEARCHBUTTON;
pub const REST_NOHARDWARETAB = RESTRICTIONS.NOHARDWARETAB;
pub const REST_NORUNASINSTALLPROMPT = RESTRICTIONS.NORUNASINSTALLPROMPT;
pub const REST_PROMPTRUNASINSTALLNETPATH = RESTRICTIONS.PROMPTRUNASINSTALLNETPATH;
pub const REST_NOMANAGEMYCOMPUTERVERB = RESTRICTIONS.NOMANAGEMYCOMPUTERVERB;
pub const REST_DISALLOWRUN = RESTRICTIONS.DISALLOWRUN;
pub const REST_NOWELCOMESCREEN = RESTRICTIONS.NOWELCOMESCREEN;
pub const REST_RESTRICTCPL = RESTRICTIONS.RESTRICTCPL;
pub const REST_DISALLOWCPL = RESTRICTIONS.DISALLOWCPL;
pub const REST_NOSMBALLOONTIP = RESTRICTIONS.NOSMBALLOONTIP;
pub const REST_NOSMHELP = RESTRICTIONS.NOSMHELP;
pub const REST_NOWINKEYS = RESTRICTIONS.NOWINKEYS;
pub const REST_NOENCRYPTONMOVE = RESTRICTIONS.NOENCRYPTONMOVE;
pub const REST_NOLOCALMACHINERUN = RESTRICTIONS.NOLOCALMACHINERUN;
pub const REST_NOCURRENTUSERRUN = RESTRICTIONS.NOCURRENTUSERRUN;
pub const REST_NOLOCALMACHINERUNONCE = RESTRICTIONS.NOLOCALMACHINERUNONCE;
pub const REST_NOCURRENTUSERRUNONCE = RESTRICTIONS.NOCURRENTUSERRUNONCE;
pub const REST_FORCEACTIVEDESKTOPON = RESTRICTIONS.FORCEACTIVEDESKTOPON;
pub const REST_NOVIEWONDRIVE = RESTRICTIONS.NOVIEWONDRIVE;
pub const REST_NONETCRAWL = RESTRICTIONS.NONETCRAWL;
pub const REST_NOSHAREDDOCUMENTS = RESTRICTIONS.NOSHAREDDOCUMENTS;
pub const REST_NOSMMYDOCS = RESTRICTIONS.NOSMMYDOCS;
pub const REST_NOSMMYPICS = RESTRICTIONS.NOSMMYPICS;
pub const REST_ALLOWBITBUCKDRIVES = RESTRICTIONS.ALLOWBITBUCKDRIVES;
pub const REST_NONLEGACYSHELLMODE = RESTRICTIONS.NONLEGACYSHELLMODE;
pub const REST_NOCONTROLPANELBARRICADE = RESTRICTIONS.NOCONTROLPANELBARRICADE;
pub const REST_NOSTARTPAGE = RESTRICTIONS.NOSTARTPAGE;
pub const REST_NOAUTOTRAYNOTIFY = RESTRICTIONS.NOAUTOTRAYNOTIFY;
pub const REST_NOTASKGROUPING = RESTRICTIONS.NOTASKGROUPING;
pub const REST_NOCDBURNING = RESTRICTIONS.NOCDBURNING;
pub const REST_MYCOMPNOPROP = RESTRICTIONS.MYCOMPNOPROP;
pub const REST_MYDOCSNOPROP = RESTRICTIONS.MYDOCSNOPROP;
pub const REST_NOSTARTPANEL = RESTRICTIONS.NOSTARTPANEL;
pub const REST_NODISPLAYAPPEARANCEPAGE = RESTRICTIONS.NODISPLAYAPPEARANCEPAGE;
pub const REST_NOTHEMESTAB = RESTRICTIONS.NOTHEMESTAB;
pub const REST_NOVISUALSTYLECHOICE = RESTRICTIONS.NOVISUALSTYLECHOICE;
pub const REST_NOSIZECHOICE = RESTRICTIONS.NOSIZECHOICE;
pub const REST_NOCOLORCHOICE = RESTRICTIONS.NOCOLORCHOICE;
pub const REST_SETVISUALSTYLE = RESTRICTIONS.SETVISUALSTYLE;
pub const REST_STARTRUNNOHOMEPATH = RESTRICTIONS.STARTRUNNOHOMEPATH;
pub const REST_NOUSERNAMEINSTARTPANEL = RESTRICTIONS.NOUSERNAMEINSTARTPANEL;
pub const REST_NOMYCOMPUTERICON = RESTRICTIONS.NOMYCOMPUTERICON;
pub const REST_NOSMNETWORKPLACES = RESTRICTIONS.NOSMNETWORKPLACES;
pub const REST_NOSMPINNEDLIST = RESTRICTIONS.NOSMPINNEDLIST;
pub const REST_NOSMMYMUSIC = RESTRICTIONS.NOSMMYMUSIC;
pub const REST_NOSMEJECTPC = RESTRICTIONS.NOSMEJECTPC;
pub const REST_NOSMMOREPROGRAMS = RESTRICTIONS.NOSMMOREPROGRAMS;
pub const REST_NOSMMFUPROGRAMS = RESTRICTIONS.NOSMMFUPROGRAMS;
pub const REST_NOTRAYITEMSDISPLAY = RESTRICTIONS.NOTRAYITEMSDISPLAY;
pub const REST_NOTOOLBARSONTASKBAR = RESTRICTIONS.NOTOOLBARSONTASKBAR;
pub const REST_NOSMCONFIGUREPROGRAMS = RESTRICTIONS.NOSMCONFIGUREPROGRAMS;
pub const REST_HIDECLOCK = RESTRICTIONS.HIDECLOCK;
pub const REST_NOLOWDISKSPACECHECKS = RESTRICTIONS.NOLOWDISKSPACECHECKS;
pub const REST_NOENTIRENETWORK = RESTRICTIONS.NOENTIRENETWORK;
pub const REST_NODESKTOPCLEANUP = RESTRICTIONS.NODESKTOPCLEANUP;
pub const REST_BITBUCKNUKEONDELETE = RESTRICTIONS.BITBUCKNUKEONDELETE;
pub const REST_BITBUCKCONFIRMDELETE = RESTRICTIONS.BITBUCKCONFIRMDELETE;
pub const REST_BITBUCKNOPROP = RESTRICTIONS.BITBUCKNOPROP;
pub const REST_NODISPBACKGROUND = RESTRICTIONS.NODISPBACKGROUND;
pub const REST_NODISPSCREENSAVEPG = RESTRICTIONS.NODISPSCREENSAVEPG;
pub const REST_NODISPSETTINGSPG = RESTRICTIONS.NODISPSETTINGSPG;
pub const REST_NODISPSCREENSAVEPREVIEW = RESTRICTIONS.NODISPSCREENSAVEPREVIEW;
pub const REST_NODISPLAYCPL = RESTRICTIONS.NODISPLAYCPL;
pub const REST_HIDERUNASVERB = RESTRICTIONS.HIDERUNASVERB;
pub const REST_NOTHUMBNAILCACHE = RESTRICTIONS.NOTHUMBNAILCACHE;
pub const REST_NOSTRCMPLOGICAL = RESTRICTIONS.NOSTRCMPLOGICAL;
pub const REST_NOPUBLISHWIZARD = RESTRICTIONS.NOPUBLISHWIZARD;
pub const REST_NOONLINEPRINTSWIZARD = RESTRICTIONS.NOONLINEPRINTSWIZARD;
pub const REST_NOWEBSERVICES = RESTRICTIONS.NOWEBSERVICES;
pub const REST_ALLOWUNHASHEDWEBVIEW = RESTRICTIONS.ALLOWUNHASHEDWEBVIEW;
pub const REST_ALLOWLEGACYWEBVIEW = RESTRICTIONS.ALLOWLEGACYWEBVIEW;
pub const REST_REVERTWEBVIEWSECURITY = RESTRICTIONS.REVERTWEBVIEWSECURITY;
pub const REST_INHERITCONSOLEHANDLES = RESTRICTIONS.INHERITCONSOLEHANDLES;
pub const REST_NOREMOTERECURSIVEEVENTS = RESTRICTIONS.NOREMOTERECURSIVEEVENTS;
pub const REST_NOREMOTECHANGENOTIFY = RESTRICTIONS.NOREMOTECHANGENOTIFY;
pub const REST_NOENUMENTIRENETWORK = RESTRICTIONS.NOENUMENTIRENETWORK;
pub const REST_NOINTERNETOPENWITH = RESTRICTIONS.NOINTERNETOPENWITH;
pub const REST_DONTRETRYBADNETNAME = RESTRICTIONS.DONTRETRYBADNETNAME;
pub const REST_ALLOWFILECLSIDJUNCTIONS = RESTRICTIONS.ALLOWFILECLSIDJUNCTIONS;
pub const REST_NOUPNPINSTALL = RESTRICTIONS.NOUPNPINSTALL;
pub const REST_ARP_DONTGROUPPATCHES = RESTRICTIONS.ARP_DONTGROUPPATCHES;
pub const REST_ARP_NOCHOOSEPROGRAMSPAGE = RESTRICTIONS.ARP_NOCHOOSEPROGRAMSPAGE;
pub const REST_NODISCONNECT = RESTRICTIONS.NODISCONNECT;
pub const REST_NOSECURITY = RESTRICTIONS.NOSECURITY;
pub const REST_NOFILEASSOCIATE = RESTRICTIONS.NOFILEASSOCIATE;
pub const REST_ALLOWCOMMENTTOGGLE = RESTRICTIONS.ALLOWCOMMENTTOGGLE;

pub const OPEN_AS_INFO_FLAGS = enum(u32) {
    ALLOW_REGISTRATION = 1,
    REGISTER_EXT = 2,
    EXEC = 4,
    FORCE_REGISTRATION = 8,
    HIDE_REGISTRATION = 32,
    URL_PROTOCOL = 64,
    FILE_IS_URI = 128,
    _,
    pub fn initFlags(o: struct {
        ALLOW_REGISTRATION: u1 = 0,
        REGISTER_EXT: u1 = 0,
        EXEC: u1 = 0,
        FORCE_REGISTRATION: u1 = 0,
        HIDE_REGISTRATION: u1 = 0,
        URL_PROTOCOL: u1 = 0,
        FILE_IS_URI: u1 = 0,
    }) OPEN_AS_INFO_FLAGS {
        return @as(OPEN_AS_INFO_FLAGS, @enumFromInt((if (o.ALLOW_REGISTRATION == 1) @intFromEnum(OPEN_AS_INFO_FLAGS.ALLOW_REGISTRATION) else 0) | (if (o.REGISTER_EXT == 1) @intFromEnum(OPEN_AS_INFO_FLAGS.REGISTER_EXT) else 0) | (if (o.EXEC == 1) @intFromEnum(OPEN_AS_INFO_FLAGS.EXEC) else 0) | (if (o.FORCE_REGISTRATION == 1) @intFromEnum(OPEN_AS_INFO_FLAGS.FORCE_REGISTRATION) else 0) | (if (o.HIDE_REGISTRATION == 1) @intFromEnum(OPEN_AS_INFO_FLAGS.HIDE_REGISTRATION) else 0) | (if (o.URL_PROTOCOL == 1) @intFromEnum(OPEN_AS_INFO_FLAGS.URL_PROTOCOL) else 0) | (if (o.FILE_IS_URI == 1) @intFromEnum(OPEN_AS_INFO_FLAGS.FILE_IS_URI) else 0)));
    }
};
pub const OAIF_ALLOW_REGISTRATION = OPEN_AS_INFO_FLAGS.ALLOW_REGISTRATION;
pub const OAIF_REGISTER_EXT = OPEN_AS_INFO_FLAGS.REGISTER_EXT;
pub const OAIF_EXEC = OPEN_AS_INFO_FLAGS.EXEC;
pub const OAIF_FORCE_REGISTRATION = OPEN_AS_INFO_FLAGS.FORCE_REGISTRATION;
pub const OAIF_HIDE_REGISTRATION = OPEN_AS_INFO_FLAGS.HIDE_REGISTRATION;
pub const OAIF_URL_PROTOCOL = OPEN_AS_INFO_FLAGS.URL_PROTOCOL;
pub const OAIF_FILE_IS_URI = OPEN_AS_INFO_FLAGS.FILE_IS_URI;

pub const OPENASINFO = extern struct {
    pcszFile: ?[*:0]const u16,
    pcszClass: ?[*:0]const u16,
    oaifInFlags: OPEN_AS_INFO_FLAGS,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IShellFolderViewCB_Value = Guid.initString("2047e320-f2a9-11ce-ae65-08002b2e1262");
pub const IID_IShellFolderViewCB = &IID_IShellFolderViewCB_Value;
pub const IShellFolderViewCB = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        MessageSFVCB: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellFolderViewCB,
                uMsg: SFVM_MESSAGE_ID,
                wParam: WPARAM,
                lParam: LPARAM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellFolderViewCB,
                uMsg: SFVM_MESSAGE_ID,
                wParam: WPARAM,
                lParam: LPARAM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellFolderViewCB_MessageSFVCB(self: *const T, uMsg: SFVM_MESSAGE_ID, wParam: WPARAM, lParam: LPARAM) HRESULT {
                return @as(*const IShellFolderViewCB.VTable, @ptrCast(self.vtable)).MessageSFVCB(@as(*const IShellFolderViewCB, @ptrCast(self)), uMsg, wParam, lParam);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const QCMINFO_IDMAP_PLACEMENT = extern struct {
    id: u32,
    fFlags: u32,
};

pub const QCMINFO_IDMAP = extern struct {
    nMaxIds: u32,
    pIdList: [1]QCMINFO_IDMAP_PLACEMENT,
};

pub const QCMINFO = extern struct {
    hmenu: ?HMENU,
    indexMenu: u32,
    idCmdFirst: u32,
    idCmdLast: u32,
    pIdMap: ?*const QCMINFO_IDMAP,
};

pub const DETAILSINFO = extern struct {
    pidl: ?*ITEMIDLIST,
    fmt: i32,
    cxChar: i32,
    str: STRRET,
    iImage: i32,
};

pub const SFVM_PROPPAGE_DATA = extern struct {
    dwReserved: u32,
    pfn: ?LPFNSVADDPROPSHEETPAGE,
    lParam: LPARAM,
};

pub const SFVM_HELPTOPIC_DATA = extern struct {
    wszHelpFile: [260]u16,
    wszHelpTopic: [260]u16,
};

pub const ITEMSPACING = extern struct {
    cxSmall: i32,
    cySmall: i32,
    cxLarge: i32,
    cyLarge: i32,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IShellFolderView_Value = Guid.initString("37a378c0-f82d-11ce-ae65-08002b2e1262");
pub const IID_IShellFolderView = &IID_IShellFolderView_Value;
pub const IShellFolderView = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Rearrange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellFolderView,
                lParamSort: LPARAM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellFolderView,
                lParamSort: LPARAM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetArrangeParam: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellFolderView,
                plParamSort: ?*LPARAM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellFolderView,
                plParamSort: ?*LPARAM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ArrangeGrid: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellFolderView,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellFolderView,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AutoArrange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellFolderView,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellFolderView,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAutoArrange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellFolderView,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellFolderView,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellFolderView,
                pidl: ?*ITEMIDLIST,
                puItem: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellFolderView,
                pidl: ?*ITEMIDLIST,
                puItem: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellFolderView,
                ppidl: ?*?*ITEMIDLIST,
                uItem: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellFolderView,
                ppidl: ?*?*ITEMIDLIST,
                uItem: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellFolderView,
                pidl: ?*ITEMIDLIST,
                puItem: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellFolderView,
                pidl: ?*ITEMIDLIST,
                puItem: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetObjectCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellFolderView,
                puCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellFolderView,
                puCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetObjectCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellFolderView,
                uCount: u32,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellFolderView,
                uCount: u32,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UpdateObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellFolderView,
                pidlOld: ?*ITEMIDLIST,
                pidlNew: ?*ITEMIDLIST,
                puItem: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellFolderView,
                pidlOld: ?*ITEMIDLIST,
                pidlNew: ?*ITEMIDLIST,
                puItem: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RefreshObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellFolderView,
                pidl: ?*ITEMIDLIST,
                puItem: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellFolderView,
                pidl: ?*ITEMIDLIST,
                puItem: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetRedraw: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellFolderView,
                bRedraw: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellFolderView,
                bRedraw: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSelectedCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellFolderView,
                puSelected: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellFolderView,
                puSelected: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSelectedObjects: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellFolderView,
                pppidl: ?*?*?*ITEMIDLIST,
                puItems: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellFolderView,
                pppidl: ?*?*?*ITEMIDLIST,
                puItems: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsDropOnSource: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellFolderView,
                pDropTarget: ?*IDropTarget,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellFolderView,
                pDropTarget: ?*IDropTarget,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDragPoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellFolderView,
                ppt: ?*POINT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellFolderView,
                ppt: ?*POINT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDropPoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellFolderView,
                ppt: ?*POINT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellFolderView,
                ppt: ?*POINT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        MoveIcons: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellFolderView,
                pDataObject: ?*IDataObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellFolderView,
                pDataObject: ?*IDataObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetItemPos: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellFolderView,
                pidl: ?*ITEMIDLIST,
                ppt: ?*POINT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellFolderView,
                pidl: ?*ITEMIDLIST,
                ppt: ?*POINT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsBkDropTarget: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellFolderView,
                pDropTarget: ?*IDropTarget,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellFolderView,
                pDropTarget: ?*IDropTarget,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetClipboard: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellFolderView,
                bMove: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellFolderView,
                bMove: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPoints: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellFolderView,
                pDataObject: ?*IDataObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellFolderView,
                pDataObject: ?*IDataObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetItemSpacing: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellFolderView,
                pSpacing: ?*ITEMSPACING,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellFolderView,
                pSpacing: ?*ITEMSPACING,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCallback: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellFolderView,
                pNewCB: ?*IShellFolderViewCB,
                ppOldCB: ?*?*IShellFolderViewCB,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellFolderView,
                pNewCB: ?*IShellFolderViewCB,
                ppOldCB: ?*?*IShellFolderViewCB,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Select: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellFolderView,
                dwFlags: SFVS_SELECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellFolderView,
                dwFlags: SFVS_SELECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QuerySupport: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellFolderView,
                pdwSupport: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellFolderView,
                pdwSupport: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetAutomationObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellFolderView,
                pdisp: ?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellFolderView,
                pdisp: ?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellFolderView_Rearrange(self: *const T, lParamSort: LPARAM) HRESULT {
                return @as(*const IShellFolderView.VTable, @ptrCast(self.vtable)).Rearrange(@as(*const IShellFolderView, @ptrCast(self)), lParamSort);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellFolderView_GetArrangeParam(self: *const T, plParamSort: ?*LPARAM) HRESULT {
                return @as(*const IShellFolderView.VTable, @ptrCast(self.vtable)).GetArrangeParam(@as(*const IShellFolderView, @ptrCast(self)), plParamSort);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellFolderView_ArrangeGrid(self: *const T) HRESULT {
                return @as(*const IShellFolderView.VTable, @ptrCast(self.vtable)).ArrangeGrid(@as(*const IShellFolderView, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellFolderView_AutoArrange(self: *const T) HRESULT {
                return @as(*const IShellFolderView.VTable, @ptrCast(self.vtable)).AutoArrange(@as(*const IShellFolderView, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellFolderView_GetAutoArrange(self: *const T) HRESULT {
                return @as(*const IShellFolderView.VTable, @ptrCast(self.vtable)).GetAutoArrange(@as(*const IShellFolderView, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellFolderView_AddObject(self: *const T, pidl: ?*ITEMIDLIST, puItem: ?*u32) HRESULT {
                return @as(*const IShellFolderView.VTable, @ptrCast(self.vtable)).AddObject(@as(*const IShellFolderView, @ptrCast(self)), pidl, puItem);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellFolderView_GetObject(self: *const T, ppidl: ?*?*ITEMIDLIST, uItem: u32) HRESULT {
                return @as(*const IShellFolderView.VTable, @ptrCast(self.vtable)).GetObject(@as(*const IShellFolderView, @ptrCast(self)), ppidl, uItem);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellFolderView_RemoveObject(self: *const T, pidl: ?*ITEMIDLIST, puItem: ?*u32) HRESULT {
                return @as(*const IShellFolderView.VTable, @ptrCast(self.vtable)).RemoveObject(@as(*const IShellFolderView, @ptrCast(self)), pidl, puItem);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellFolderView_GetObjectCount(self: *const T, puCount: ?*u32) HRESULT {
                return @as(*const IShellFolderView.VTable, @ptrCast(self.vtable)).GetObjectCount(@as(*const IShellFolderView, @ptrCast(self)), puCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellFolderView_SetObjectCount(self: *const T, uCount: u32, dwFlags: u32) HRESULT {
                return @as(*const IShellFolderView.VTable, @ptrCast(self.vtable)).SetObjectCount(@as(*const IShellFolderView, @ptrCast(self)), uCount, dwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellFolderView_UpdateObject(self: *const T, pidlOld: ?*ITEMIDLIST, pidlNew: ?*ITEMIDLIST, puItem: ?*u32) HRESULT {
                return @as(*const IShellFolderView.VTable, @ptrCast(self.vtable)).UpdateObject(@as(*const IShellFolderView, @ptrCast(self)), pidlOld, pidlNew, puItem);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellFolderView_RefreshObject(self: *const T, pidl: ?*ITEMIDLIST, puItem: ?*u32) HRESULT {
                return @as(*const IShellFolderView.VTable, @ptrCast(self.vtable)).RefreshObject(@as(*const IShellFolderView, @ptrCast(self)), pidl, puItem);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellFolderView_SetRedraw(self: *const T, bRedraw: BOOL) HRESULT {
                return @as(*const IShellFolderView.VTable, @ptrCast(self.vtable)).SetRedraw(@as(*const IShellFolderView, @ptrCast(self)), bRedraw);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellFolderView_GetSelectedCount(self: *const T, puSelected: ?*u32) HRESULT {
                return @as(*const IShellFolderView.VTable, @ptrCast(self.vtable)).GetSelectedCount(@as(*const IShellFolderView, @ptrCast(self)), puSelected);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellFolderView_GetSelectedObjects(self: *const T, pppidl: ?*?*?*ITEMIDLIST, puItems: ?*u32) HRESULT {
                return @as(*const IShellFolderView.VTable, @ptrCast(self.vtable)).GetSelectedObjects(@as(*const IShellFolderView, @ptrCast(self)), pppidl, puItems);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellFolderView_IsDropOnSource(self: *const T, pDropTarget: ?*IDropTarget) HRESULT {
                return @as(*const IShellFolderView.VTable, @ptrCast(self.vtable)).IsDropOnSource(@as(*const IShellFolderView, @ptrCast(self)), pDropTarget);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellFolderView_GetDragPoint(self: *const T, ppt: ?*POINT) HRESULT {
                return @as(*const IShellFolderView.VTable, @ptrCast(self.vtable)).GetDragPoint(@as(*const IShellFolderView, @ptrCast(self)), ppt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellFolderView_GetDropPoint(self: *const T, ppt: ?*POINT) HRESULT {
                return @as(*const IShellFolderView.VTable, @ptrCast(self.vtable)).GetDropPoint(@as(*const IShellFolderView, @ptrCast(self)), ppt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellFolderView_MoveIcons(self: *const T, pDataObject: ?*IDataObject) HRESULT {
                return @as(*const IShellFolderView.VTable, @ptrCast(self.vtable)).MoveIcons(@as(*const IShellFolderView, @ptrCast(self)), pDataObject);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellFolderView_SetItemPos(self: *const T, pidl: ?*ITEMIDLIST, ppt: ?*POINT) HRESULT {
                return @as(*const IShellFolderView.VTable, @ptrCast(self.vtable)).SetItemPos(@as(*const IShellFolderView, @ptrCast(self)), pidl, ppt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellFolderView_IsBkDropTarget(self: *const T, pDropTarget: ?*IDropTarget) HRESULT {
                return @as(*const IShellFolderView.VTable, @ptrCast(self.vtable)).IsBkDropTarget(@as(*const IShellFolderView, @ptrCast(self)), pDropTarget);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellFolderView_SetClipboard(self: *const T, bMove: BOOL) HRESULT {
                return @as(*const IShellFolderView.VTable, @ptrCast(self.vtable)).SetClipboard(@as(*const IShellFolderView, @ptrCast(self)), bMove);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellFolderView_SetPoints(self: *const T, pDataObject: ?*IDataObject) HRESULT {
                return @as(*const IShellFolderView.VTable, @ptrCast(self.vtable)).SetPoints(@as(*const IShellFolderView, @ptrCast(self)), pDataObject);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellFolderView_GetItemSpacing(self: *const T, pSpacing: ?*ITEMSPACING) HRESULT {
                return @as(*const IShellFolderView.VTable, @ptrCast(self.vtable)).GetItemSpacing(@as(*const IShellFolderView, @ptrCast(self)), pSpacing);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellFolderView_SetCallback(self: *const T, pNewCB: ?*IShellFolderViewCB, ppOldCB: ?*?*IShellFolderViewCB) HRESULT {
                return @as(*const IShellFolderView.VTable, @ptrCast(self.vtable)).SetCallback(@as(*const IShellFolderView, @ptrCast(self)), pNewCB, ppOldCB);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellFolderView_Select(self: *const T, dwFlags: SFVS_SELECT) HRESULT {
                return @as(*const IShellFolderView.VTable, @ptrCast(self.vtable)).Select(@as(*const IShellFolderView, @ptrCast(self)), dwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellFolderView_QuerySupport(self: *const T, pdwSupport: ?*u32) HRESULT {
                return @as(*const IShellFolderView.VTable, @ptrCast(self.vtable)).QuerySupport(@as(*const IShellFolderView, @ptrCast(self)), pdwSupport);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellFolderView_SetAutomationObject(self: *const T, pdisp: ?*IDispatch) HRESULT {
                return @as(*const IShellFolderView.VTable, @ptrCast(self.vtable)).SetAutomationObject(@as(*const IShellFolderView, @ptrCast(self)), pdisp);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SFV_CREATE = extern struct {
    cbSize: u32,
    pshf: ?*IShellFolder,
    psvOuter: ?*IShellView,
    psfvcb: ?*IShellFolderViewCB,
};

pub const LPFNDFMCALLBACK = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        psf: ?*IShellFolder,
        hwnd: ?HWND,
        pdtobj: ?*IDataObject,
        uMsg: u32,
        wParam: WPARAM,
        lParam: LPARAM,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn (
        psf: ?*IShellFolder,
        hwnd: ?HWND,
        pdtobj: ?*IDataObject,
        uMsg: u32,
        wParam: WPARAM,
        lParam: LPARAM,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
};

pub const DEFCONTEXTMENU = extern struct {
    hwnd: ?HWND,
    pcmcb: ?*IContextMenuCB,
    pidlFolder: ?*ITEMIDLIST,
    psf: ?*IShellFolder,
    cidl: u32,
    apidl: ?*?*ITEMIDLIST,
    punkAssociationInfo: ?*IUnknown,
    cKeys: u32,
    aKeys: ?*const ?HKEY,
};

pub const DFMICS = extern struct {
    cbSize: u32,
    fMask: u32,
    lParam: LPARAM,
    idCmdFirst: u32,
    idDefMax: u32,
    pici: ?*CMINVOKECOMMANDINFO,
    punkSite: ?*IUnknown,
};

pub const LPFNVIEWCALLBACK = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        psvOuter: ?*IShellView,
        psf: ?*IShellFolder,
        hwndMain: ?HWND,
        uMsg: u32,
        wParam: WPARAM,
        lParam: LPARAM,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn (
        psvOuter: ?*IShellView,
        psf: ?*IShellFolder,
        hwndMain: ?HWND,
        uMsg: u32,
        wParam: WPARAM,
        lParam: LPARAM,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
};

pub const CSFV = extern struct {
    cbSize: u32,
    pshf: ?*IShellFolder,
    psvOuter: ?*IShellView,
    pidl: ?*ITEMIDLIST,
    lEvents: i32,
    pfnCallback: ?LPFNVIEWCALLBACK,
    fvm: FOLDERVIEWMODE,
};

pub const SHELLSTATEA = extern struct {
    _bitfield1: i32 align(1),
    dwWin95Unused: u32 align(1),
    uWin95Unused: u32 align(1),
    lParamSort: i32 align(1),
    iSortDirection: i32 align(1),
    version: u32 align(1),
    uNotUsed: u32 align(1),
    _bitfield2: i32 align(1),
};

pub const SHELLSTATEW = extern struct {
    _bitfield1: i32 align(1),
    dwWin95Unused: u32 align(1),
    uWin95Unused: u32 align(1),
    lParamSort: i32 align(1),
    iSortDirection: i32 align(1),
    version: u32 align(1),
    uNotUsed: u32 align(1),
    _bitfield2: i32 align(1),
};

pub const SHELLFLAGSTATE = extern struct {
    _bitfield: i32 align(1),
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_INamedPropertyBag_Value = Guid.initString("fb700430-952c-11d1-946f-000000000000");
pub const IID_INamedPropertyBag = &IID_INamedPropertyBag_Value;
pub const INamedPropertyBag = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ReadPropertyNPB: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INamedPropertyBag,
                pszBagname: ?[*:0]const u16,
                pszPropName: ?[*:0]const u16,
                pVar: ?*PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INamedPropertyBag,
                pszBagname: ?[*:0]const u16,
                pszPropName: ?[*:0]const u16,
                pVar: ?*PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WritePropertyNPB: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INamedPropertyBag,
                pszBagname: ?[*:0]const u16,
                pszPropName: ?[*:0]const u16,
                pVar: ?*PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INamedPropertyBag,
                pszBagname: ?[*:0]const u16,
                pszPropName: ?[*:0]const u16,
                pVar: ?*PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemovePropertyNPB: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INamedPropertyBag,
                pszBagname: ?[*:0]const u16,
                pszPropName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INamedPropertyBag,
                pszBagname: ?[*:0]const u16,
                pszPropName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INamedPropertyBag_ReadPropertyNPB(self: *const T, pszBagname: ?[*:0]const u16, pszPropName: ?[*:0]const u16, pVar: ?*PROPVARIANT) HRESULT {
                return @as(*const INamedPropertyBag.VTable, @ptrCast(self.vtable)).ReadPropertyNPB(@as(*const INamedPropertyBag, @ptrCast(self)), pszBagname, pszPropName, pVar);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INamedPropertyBag_WritePropertyNPB(self: *const T, pszBagname: ?[*:0]const u16, pszPropName: ?[*:0]const u16, pVar: ?*PROPVARIANT) HRESULT {
                return @as(*const INamedPropertyBag.VTable, @ptrCast(self.vtable)).WritePropertyNPB(@as(*const INamedPropertyBag, @ptrCast(self)), pszBagname, pszPropName, pVar);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INamedPropertyBag_RemovePropertyNPB(self: *const T, pszBagname: ?[*:0]const u16, pszPropName: ?[*:0]const u16) HRESULT {
                return @as(*const INamedPropertyBag.VTable, @ptrCast(self.vtable)).RemovePropertyNPB(@as(*const INamedPropertyBag, @ptrCast(self)), pszBagname, pszPropName);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const IESHORTCUTFLAGS = enum(i32) {
    NEWBROWSER = 1,
    OPENNEWTAB = 2,
    FORCENAVIGATE = 4,
    BACKGROUNDTAB = 8,
};
pub const IESHORTCUT_NEWBROWSER = IESHORTCUTFLAGS.NEWBROWSER;
pub const IESHORTCUT_OPENNEWTAB = IESHORTCUTFLAGS.OPENNEWTAB;
pub const IESHORTCUT_FORCENAVIGATE = IESHORTCUTFLAGS.FORCENAVIGATE;
pub const IESHORTCUT_BACKGROUNDTAB = IESHORTCUTFLAGS.BACKGROUNDTAB;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_INewShortcutHookA_Value = Guid.initString("000214e1-0000-0000-c000-000000000046");
pub const IID_INewShortcutHookA = &IID_INewShortcutHookA_Value;
pub const INewShortcutHookA = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetReferent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INewShortcutHookA,
                pcszReferent: ?[*:0]const u8,
                hwnd: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INewShortcutHookA,
                pcszReferent: ?[*:0]const u8,
                hwnd: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetReferent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INewShortcutHookA,
                pszReferent: [*:0]u8,
                cchReferent: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INewShortcutHookA,
                pszReferent: [*:0]u8,
                cchReferent: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFolder: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INewShortcutHookA,
                pcszFolder: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INewShortcutHookA,
                pcszFolder: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFolder: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INewShortcutHookA,
                pszFolder: [*:0]u8,
                cchFolder: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INewShortcutHookA,
                pszFolder: [*:0]u8,
                cchFolder: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INewShortcutHookA,
                pszName: [*:0]u8,
                cchName: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INewShortcutHookA,
                pszName: [*:0]u8,
                cchName: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExtension: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INewShortcutHookA,
                pszExtension: [*:0]u8,
                cchExtension: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INewShortcutHookA,
                pszExtension: [*:0]u8,
                cchExtension: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INewShortcutHookA_SetReferent(self: *const T, pcszReferent: ?[*:0]const u8, hwnd: ?HWND) HRESULT {
                return @as(*const INewShortcutHookA.VTable, @ptrCast(self.vtable)).SetReferent(@as(*const INewShortcutHookA, @ptrCast(self)), pcszReferent, hwnd);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INewShortcutHookA_GetReferent(self: *const T, pszReferent: [*:0]u8, cchReferent: i32) HRESULT {
                return @as(*const INewShortcutHookA.VTable, @ptrCast(self.vtable)).GetReferent(@as(*const INewShortcutHookA, @ptrCast(self)), pszReferent, cchReferent);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INewShortcutHookA_SetFolder(self: *const T, pcszFolder: ?[*:0]const u8) HRESULT {
                return @as(*const INewShortcutHookA.VTable, @ptrCast(self.vtable)).SetFolder(@as(*const INewShortcutHookA, @ptrCast(self)), pcszFolder);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INewShortcutHookA_GetFolder(self: *const T, pszFolder: [*:0]u8, cchFolder: i32) HRESULT {
                return @as(*const INewShortcutHookA.VTable, @ptrCast(self.vtable)).GetFolder(@as(*const INewShortcutHookA, @ptrCast(self)), pszFolder, cchFolder);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INewShortcutHookA_GetName(self: *const T, pszName: [*:0]u8, cchName: i32) HRESULT {
                return @as(*const INewShortcutHookA.VTable, @ptrCast(self.vtable)).GetName(@as(*const INewShortcutHookA, @ptrCast(self)), pszName, cchName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INewShortcutHookA_GetExtension(self: *const T, pszExtension: [*:0]u8, cchExtension: i32) HRESULT {
                return @as(*const INewShortcutHookA.VTable, @ptrCast(self.vtable)).GetExtension(@as(*const INewShortcutHookA, @ptrCast(self)), pszExtension, cchExtension);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_INewShortcutHookW_Value = Guid.initString("000214f7-0000-0000-c000-000000000046");
pub const IID_INewShortcutHookW = &IID_INewShortcutHookW_Value;
pub const INewShortcutHookW = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetReferent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INewShortcutHookW,
                pcszReferent: ?[*:0]const u16,
                hwnd: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INewShortcutHookW,
                pcszReferent: ?[*:0]const u16,
                hwnd: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetReferent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INewShortcutHookW,
                pszReferent: [*:0]u16,
                cchReferent: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INewShortcutHookW,
                pszReferent: [*:0]u16,
                cchReferent: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFolder: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INewShortcutHookW,
                pcszFolder: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INewShortcutHookW,
                pcszFolder: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFolder: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INewShortcutHookW,
                pszFolder: [*:0]u16,
                cchFolder: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INewShortcutHookW,
                pszFolder: [*:0]u16,
                cchFolder: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INewShortcutHookW,
                pszName: [*:0]u16,
                cchName: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INewShortcutHookW,
                pszName: [*:0]u16,
                cchName: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExtension: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INewShortcutHookW,
                pszExtension: [*:0]u16,
                cchExtension: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INewShortcutHookW,
                pszExtension: [*:0]u16,
                cchExtension: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INewShortcutHookW_SetReferent(self: *const T, pcszReferent: ?[*:0]const u16, hwnd: ?HWND) HRESULT {
                return @as(*const INewShortcutHookW.VTable, @ptrCast(self.vtable)).SetReferent(@as(*const INewShortcutHookW, @ptrCast(self)), pcszReferent, hwnd);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INewShortcutHookW_GetReferent(self: *const T, pszReferent: [*:0]u16, cchReferent: i32) HRESULT {
                return @as(*const INewShortcutHookW.VTable, @ptrCast(self.vtable)).GetReferent(@as(*const INewShortcutHookW, @ptrCast(self)), pszReferent, cchReferent);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INewShortcutHookW_SetFolder(self: *const T, pcszFolder: ?[*:0]const u16) HRESULT {
                return @as(*const INewShortcutHookW.VTable, @ptrCast(self.vtable)).SetFolder(@as(*const INewShortcutHookW, @ptrCast(self)), pcszFolder);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INewShortcutHookW_GetFolder(self: *const T, pszFolder: [*:0]u16, cchFolder: i32) HRESULT {
                return @as(*const INewShortcutHookW.VTable, @ptrCast(self.vtable)).GetFolder(@as(*const INewShortcutHookW, @ptrCast(self)), pszFolder, cchFolder);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INewShortcutHookW_GetName(self: *const T, pszName: [*:0]u16, cchName: i32) HRESULT {
                return @as(*const INewShortcutHookW.VTable, @ptrCast(self.vtable)).GetName(@as(*const INewShortcutHookW, @ptrCast(self)), pszName, cchName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INewShortcutHookW_GetExtension(self: *const T, pszExtension: [*:0]u16, cchExtension: i32) HRESULT {
                return @as(*const INewShortcutHookW.VTable, @ptrCast(self.vtable)).GetExtension(@as(*const INewShortcutHookW, @ptrCast(self)), pszExtension, cchExtension);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ICopyHookA_Value = Guid.initString("000214ef-0000-0000-c000-000000000046");
pub const IID_ICopyHookA = &IID_ICopyHookA_Value;
pub const ICopyHookA = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CopyCallback: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICopyHookA,
                hwnd: ?HWND,
                wFunc: u32,
                wFlags: u32,
                pszSrcFile: ?[*:0]const u8,
                dwSrcAttribs: u32,
                pszDestFile: ?[*:0]const u8,
                dwDestAttribs: u32,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn (
                self: *const ICopyHookA,
                hwnd: ?HWND,
                wFunc: u32,
                wFlags: u32,
                pszSrcFile: ?[*:0]const u8,
                dwSrcAttribs: u32,
                pszDestFile: ?[*:0]const u8,
                dwDestAttribs: u32,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICopyHookA_CopyCallback(self: *const T, hwnd: ?HWND, wFunc: u32, wFlags: u32, pszSrcFile: ?[*:0]const u8, dwSrcAttribs: u32, pszDestFile: ?[*:0]const u8, dwDestAttribs: u32) u32 {
                return @as(*const ICopyHookA.VTable, @ptrCast(self.vtable)).CopyCallback(@as(*const ICopyHookA, @ptrCast(self)), hwnd, wFunc, wFlags, pszSrcFile, dwSrcAttribs, pszDestFile, dwDestAttribs);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ICopyHookW_Value = Guid.initString("000214fc-0000-0000-c000-000000000046");
pub const IID_ICopyHookW = &IID_ICopyHookW_Value;
pub const ICopyHookW = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CopyCallback: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICopyHookW,
                hwnd: ?HWND,
                wFunc: u32,
                wFlags: u32,
                pszSrcFile: ?[*:0]const u16,
                dwSrcAttribs: u32,
                pszDestFile: ?[*:0]const u16,
                dwDestAttribs: u32,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn (
                self: *const ICopyHookW,
                hwnd: ?HWND,
                wFunc: u32,
                wFlags: u32,
                pszSrcFile: ?[*:0]const u16,
                dwSrcAttribs: u32,
                pszDestFile: ?[*:0]const u16,
                dwDestAttribs: u32,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICopyHookW_CopyCallback(self: *const T, hwnd: ?HWND, wFunc: u32, wFlags: u32, pszSrcFile: ?[*:0]const u16, dwSrcAttribs: u32, pszDestFile: ?[*:0]const u16, dwDestAttribs: u32) u32 {
                return @as(*const ICopyHookW.VTable, @ptrCast(self.vtable)).CopyCallback(@as(*const ICopyHookW, @ptrCast(self)), hwnd, wFunc, wFlags, pszSrcFile, dwSrcAttribs, pszDestFile, dwDestAttribs);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ICurrentWorkingDirectory_Value = Guid.initString("91956d21-9276-11d1-921a-006097df5bd4");
pub const IID_ICurrentWorkingDirectory = &IID_ICurrentWorkingDirectory_Value;
pub const ICurrentWorkingDirectory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDirectory: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICurrentWorkingDirectory,
                pwzPath: [*:0]u16,
                cchSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICurrentWorkingDirectory,
                pwzPath: [*:0]u16,
                cchSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDirectory: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICurrentWorkingDirectory,
                pwzPath: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICurrentWorkingDirectory,
                pwzPath: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICurrentWorkingDirectory_GetDirectory(self: *const T, pwzPath: [*:0]u16, cchSize: u32) HRESULT {
                return @as(*const ICurrentWorkingDirectory.VTable, @ptrCast(self.vtable)).GetDirectory(@as(*const ICurrentWorkingDirectory, @ptrCast(self)), pwzPath, cchSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICurrentWorkingDirectory_SetDirectory(self: *const T, pwzPath: ?[*:0]const u16) HRESULT {
                return @as(*const ICurrentWorkingDirectory.VTable, @ptrCast(self.vtable)).SetDirectory(@as(*const ICurrentWorkingDirectory, @ptrCast(self)), pwzPath);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IDockingWindowFrame_Value = Guid.initString("47d2657a-7b27-11d0-8ca9-00a0c92dbfe8");
pub const IID_IDockingWindowFrame = &IID_IDockingWindowFrame_Value;
pub const IDockingWindowFrame = extern struct {
    pub const VTable = extern struct {
        base: IOleWindow.VTable,
        AddToolbar: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDockingWindowFrame,
                punkSrc: ?*IUnknown,
                pwszItem: ?[*:0]const u16,
                dwAddFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDockingWindowFrame,
                punkSrc: ?*IUnknown,
                pwszItem: ?[*:0]const u16,
                dwAddFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveToolbar: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDockingWindowFrame,
                punkSrc: ?*IUnknown,
                dwRemoveFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDockingWindowFrame,
                punkSrc: ?*IUnknown,
                dwRemoveFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindToolbar: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDockingWindowFrame,
                pwszItem: ?[*:0]const u16,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDockingWindowFrame,
                pwszItem: ?[*:0]const u16,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IOleWindow.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDockingWindowFrame_AddToolbar(self: *const T, punkSrc: ?*IUnknown, pwszItem: ?[*:0]const u16, dwAddFlags: u32) HRESULT {
                return @as(*const IDockingWindowFrame.VTable, @ptrCast(self.vtable)).AddToolbar(@as(*const IDockingWindowFrame, @ptrCast(self)), punkSrc, pwszItem, dwAddFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDockingWindowFrame_RemoveToolbar(self: *const T, punkSrc: ?*IUnknown, dwRemoveFlags: u32) HRESULT {
                return @as(*const IDockingWindowFrame.VTable, @ptrCast(self.vtable)).RemoveToolbar(@as(*const IDockingWindowFrame, @ptrCast(self)), punkSrc, dwRemoveFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDockingWindowFrame_FindToolbar(self: *const T, pwszItem: ?[*:0]const u16, riid: ?*const Guid, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const IDockingWindowFrame.VTable, @ptrCast(self.vtable)).FindToolbar(@as(*const IDockingWindowFrame, @ptrCast(self)), pwszItem, riid, ppv);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IThumbnailCapture_Value = Guid.initString("4ea39266-7211-409f-b622-f63dbd16c533");
pub const IID_IThumbnailCapture = &IID_IThumbnailCapture_Value;
pub const IThumbnailCapture = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CaptureThumbnail: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IThumbnailCapture,
                pMaxSize: ?*const SIZE,
                pHTMLDoc2: ?*IUnknown,
                phbmThumbnail: ?*?HBITMAP,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IThumbnailCapture,
                pMaxSize: ?*const SIZE,
                pHTMLDoc2: ?*IUnknown,
                phbmThumbnail: ?*?HBITMAP,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IThumbnailCapture_CaptureThumbnail(self: *const T, pMaxSize: ?*const SIZE, pHTMLDoc2: ?*IUnknown, phbmThumbnail: ?*?HBITMAP) HRESULT {
                return @as(*const IThumbnailCapture.VTable, @ptrCast(self.vtable)).CaptureThumbnail(@as(*const IThumbnailCapture, @ptrCast(self)), pMaxSize, pHTMLDoc2, phbmThumbnail);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const BANDINFOSFB = extern struct {
    dwMask: u32,
    dwStateMask: u32,
    dwState: u32,
    crBkgnd: u32,
    crBtnLt: u32,
    crBtnDk: u32,
    wViewMode: u16,
    wAlign: u16,
    psf: ?*IShellFolder,
    pidl: ?*ITEMIDLIST,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IShellFolderBand_Value = Guid.initString("7fe80cc8-c247-11d0-b93a-00a0c90312e1");
pub const IID_IShellFolderBand = &IID_IShellFolderBand_Value;
pub const IShellFolderBand = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        InitializeSFB: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellFolderBand,
                psf: ?*IShellFolder,
                pidl: ?*ITEMIDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellFolderBand,
                psf: ?*IShellFolder,
                pidl: ?*ITEMIDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetBandInfoSFB: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellFolderBand,
                pbi: ?*BANDINFOSFB,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellFolderBand,
                pbi: ?*BANDINFOSFB,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBandInfoSFB: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellFolderBand,
                pbi: ?*BANDINFOSFB,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellFolderBand,
                pbi: ?*BANDINFOSFB,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellFolderBand_InitializeSFB(self: *const T, psf: ?*IShellFolder, pidl: ?*ITEMIDLIST) HRESULT {
                return @as(*const IShellFolderBand.VTable, @ptrCast(self.vtable)).InitializeSFB(@as(*const IShellFolderBand, @ptrCast(self)), psf, pidl);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellFolderBand_SetBandInfoSFB(self: *const T, pbi: ?*BANDINFOSFB) HRESULT {
                return @as(*const IShellFolderBand.VTable, @ptrCast(self.vtable)).SetBandInfoSFB(@as(*const IShellFolderBand, @ptrCast(self)), pbi);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellFolderBand_GetBandInfoSFB(self: *const T, pbi: ?*BANDINFOSFB) HRESULT {
                return @as(*const IShellFolderBand.VTable, @ptrCast(self.vtable)).GetBandInfoSFB(@as(*const IShellFolderBand, @ptrCast(self)), pbi);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDeskBarClient_Value = Guid.initString("eb0fe175-1a3a-11d0-89b3-00a0c90a90ac");
pub const IID_IDeskBarClient = &IID_IDeskBarClient_Value;
pub const IDeskBarClient = extern struct {
    pub const VTable = extern struct {
        base: IOleWindow.VTable,
        SetDeskBarSite: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDeskBarClient,
                punkSite: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDeskBarClient,
                punkSite: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetModeDBC: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDeskBarClient,
                dwMode: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDeskBarClient,
                dwMode: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UIActivateDBC: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDeskBarClient,
                dwState: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDeskBarClient,
                dwState: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDeskBarClient,
                dwWhich: u32,
                prc: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDeskBarClient,
                dwWhich: u32,
                prc: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IOleWindow.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDeskBarClient_SetDeskBarSite(self: *const T, punkSite: ?*IUnknown) HRESULT {
                return @as(*const IDeskBarClient.VTable, @ptrCast(self.vtable)).SetDeskBarSite(@as(*const IDeskBarClient, @ptrCast(self)), punkSite);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDeskBarClient_SetModeDBC(self: *const T, dwMode: u32) HRESULT {
                return @as(*const IDeskBarClient.VTable, @ptrCast(self.vtable)).SetModeDBC(@as(*const IDeskBarClient, @ptrCast(self)), dwMode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDeskBarClient_UIActivateDBC(self: *const T, dwState: u32) HRESULT {
                return @as(*const IDeskBarClient.VTable, @ptrCast(self.vtable)).UIActivateDBC(@as(*const IDeskBarClient, @ptrCast(self)), dwState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDeskBarClient_GetSize(self: *const T, dwWhich: u32, prc: ?*RECT) HRESULT {
                return @as(*const IDeskBarClient.VTable, @ptrCast(self.vtable)).GetSize(@as(*const IDeskBarClient, @ptrCast(self)), dwWhich, prc);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SHCOLUMNINFO = extern struct {
    scid: PROPERTYKEY align(1),
    vt: u16 align(1),
    fmt: u32 align(1),
    cChars: u32 align(1),
    csFlags: u32 align(1),
    wszTitle: [80]u16 align(1),
    wszDescription: [128]u16 align(1),
};

pub const SHCOLUMNINIT = extern struct {
    dwFlags: u32,
    dwReserved: u32,
    wszFolder: [260]u16,
};

pub const SHCOLUMNDATA = extern struct {
    dwFlags: u32,
    dwFileAttributes: u32,
    dwReserved: u32,
    pwszExt: ?PWSTR,
    wszFile: [260]u16,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IColumnProvider_Value = Guid.initString("e8025004-1c42-11d2-be2c-00a0c9a83da1");
pub const IID_IColumnProvider = &IID_IColumnProvider_Value;
pub const IColumnProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IColumnProvider,
                psci: ?*SHCOLUMNINIT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IColumnProvider,
                psci: ?*SHCOLUMNINIT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetColumnInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IColumnProvider,
                dwIndex: u32,
                psci: ?*SHCOLUMNINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IColumnProvider,
                dwIndex: u32,
                psci: ?*SHCOLUMNINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetItemData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IColumnProvider,
                pscid: ?*PROPERTYKEY,
                pscd: ?*SHCOLUMNDATA,
                pvarData: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IColumnProvider,
                pscid: ?*PROPERTYKEY,
                pscd: ?*SHCOLUMNDATA,
                pvarData: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IColumnProvider_Initialize(self: *const T, psci: ?*SHCOLUMNINIT) HRESULT {
                return @as(*const IColumnProvider.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IColumnProvider, @ptrCast(self)), psci);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IColumnProvider_GetColumnInfo(self: *const T, dwIndex: u32, psci: ?*SHCOLUMNINFO) HRESULT {
                return @as(*const IColumnProvider.VTable, @ptrCast(self.vtable)).GetColumnInfo(@as(*const IColumnProvider, @ptrCast(self)), dwIndex, psci);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IColumnProvider_GetItemData(self: *const T, pscid: ?*PROPERTYKEY, pscd: ?*SHCOLUMNDATA, pvarData: ?*VARIANT) HRESULT {
                return @as(*const IColumnProvider.VTable, @ptrCast(self.vtable)).GetItemData(@as(*const IColumnProvider, @ptrCast(self)), pscid, pscd, pvarData);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SHChangeProductKeyAsIDList = extern struct {
    cb: u16 align(1),
    wszProductKey: [39]u16 align(1),
    cbZero: u16 align(1),
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IDocViewSite_Value = Guid.initString("87d605e0-c511-11cf-89a9-00a0c9054129");
pub const IID_IDocViewSite = &IID_IDocViewSite_Value;
pub const IDocViewSite = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnSetTitle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDocViewSite,
                pvTitle: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDocViewSite,
                pvTitle: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDocViewSite_OnSetTitle(self: *const T, pvTitle: ?*VARIANT) HRESULT {
                return @as(*const IDocViewSite.VTable, @ptrCast(self.vtable)).OnSetTitle(@as(*const IDocViewSite, @ptrCast(self)), pvTitle);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IInitializeObject_Value = Guid.initString("4622ad16-ff23-11d0-8d34-00a0c90f2719");
pub const IID_IInitializeObject = &IID_IInitializeObject_Value;
pub const IInitializeObject = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInitializeObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInitializeObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInitializeObject_Initialize(self: *const T) HRESULT {
                return @as(*const IInitializeObject.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IInitializeObject, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IBanneredBar_Value = Guid.initString("596a9a94-013e-11d1-8d34-00a0c90f2719");
pub const IID_IBanneredBar = &IID_IBanneredBar_Value;
pub const IBanneredBar = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetIconSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBanneredBar,
                iIcon: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBanneredBar,
                iIcon: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIconSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBanneredBar,
                piIcon: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBanneredBar,
                piIcon: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetBitmap: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBanneredBar,
                hBitmap: ?HBITMAP,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBanneredBar,
                hBitmap: ?HBITMAP,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBitmap: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBanneredBar,
                phBitmap: ?*?HBITMAP,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBanneredBar,
                phBitmap: ?*?HBITMAP,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBanneredBar_SetIconSize(self: *const T, iIcon: u32) HRESULT {
                return @as(*const IBanneredBar.VTable, @ptrCast(self.vtable)).SetIconSize(@as(*const IBanneredBar, @ptrCast(self)), iIcon);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBanneredBar_GetIconSize(self: *const T, piIcon: ?*u32) HRESULT {
                return @as(*const IBanneredBar.VTable, @ptrCast(self.vtable)).GetIconSize(@as(*const IBanneredBar, @ptrCast(self)), piIcon);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBanneredBar_SetBitmap(self: *const T, hBitmap: ?HBITMAP) HRESULT {
                return @as(*const IBanneredBar.VTable, @ptrCast(self.vtable)).SetBitmap(@as(*const IBanneredBar, @ptrCast(self)), hBitmap);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBanneredBar_GetBitmap(self: *const T, phBitmap: ?*?HBITMAP) HRESULT {
                return @as(*const IBanneredBar.VTable, @ptrCast(self.vtable)).GetBitmap(@as(*const IBanneredBar, @ptrCast(self)), phBitmap);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const TBINFO = extern struct {
    cbuttons: u32,
    uFlags: u32,
};

pub const SFV_SETITEMPOS = extern struct {
    pidl: ?*ITEMIDLIST,
    pt: POINT,
};

pub const AASHELLMENUFILENAME = extern struct {
    cbTotal: i16,
    rgbReserved: [12]u8,
    szFileName: [1]u16,
};

pub const AASHELLMENUITEM = extern struct {
    lpReserved1: ?*anyopaque,
    iReserved: i32,
    uiReserved: u32,
    lpName: ?*AASHELLMENUFILENAME,
    psz: ?PWSTR,
};

pub const DISPLAY_DEVICE_TYPE = enum(i32) {
    PRIMARY = 0,
    IMMERSIVE = 1,
};
pub const DEVICE_PRIMARY = DISPLAY_DEVICE_TYPE.PRIMARY;
pub const DEVICE_IMMERSIVE = DISPLAY_DEVICE_TYPE.IMMERSIVE;

pub const SCALE_CHANGE_FLAGS = enum(u32) {
    VALUE_NONE = 0,
    SCALE = 1,
    PHYSICAL = 2,
    _,
    pub fn initFlags(o: struct {
        VALUE_NONE: u1 = 0,
        SCALE: u1 = 0,
        PHYSICAL: u1 = 0,
    }) SCALE_CHANGE_FLAGS {
        return @as(SCALE_CHANGE_FLAGS, @enumFromInt((if (o.VALUE_NONE == 1) @intFromEnum(SCALE_CHANGE_FLAGS.VALUE_NONE) else 0) | (if (o.SCALE == 1) @intFromEnum(SCALE_CHANGE_FLAGS.SCALE) else 0) | (if (o.PHYSICAL == 1) @intFromEnum(SCALE_CHANGE_FLAGS.PHYSICAL) else 0)));
    }
};
pub const SCF_VALUE_NONE = SCALE_CHANGE_FLAGS.VALUE_NONE;
pub const SCF_SCALE = SCALE_CHANGE_FLAGS.SCALE;
pub const SCF_PHYSICAL = SCALE_CHANGE_FLAGS.PHYSICAL;

pub const SHELL_UI_COMPONENT = enum(i32) {
    TASKBARS = 0,
    NOTIFICATIONAREA = 1,
    DESKBAND = 2,
};
pub const SHELL_UI_COMPONENT_TASKBARS = SHELL_UI_COMPONENT.TASKBARS;
pub const SHELL_UI_COMPONENT_NOTIFICATIONAREA = SHELL_UI_COMPONENT.NOTIFICATIONAREA;
pub const SHELL_UI_COMPONENT_DESKBAND = SHELL_UI_COMPONENT.DESKBAND;

pub const ASSOCCLASS = enum(i32) {
    SHELL_KEY = 0,
    PROGID_KEY = 1,
    PROGID_STR = 2,
    CLSID_KEY = 3,
    CLSID_STR = 4,
    APP_KEY = 5,
    APP_STR = 6,
    SYSTEM_STR = 7,
    FOLDER = 8,
    STAR = 9,
    FIXED_PROGID_STR = 10,
    PROTOCOL_STR = 11,
};
pub const ASSOCCLASS_SHELL_KEY = ASSOCCLASS.SHELL_KEY;
pub const ASSOCCLASS_PROGID_KEY = ASSOCCLASS.PROGID_KEY;
pub const ASSOCCLASS_PROGID_STR = ASSOCCLASS.PROGID_STR;
pub const ASSOCCLASS_CLSID_KEY = ASSOCCLASS.CLSID_KEY;
pub const ASSOCCLASS_CLSID_STR = ASSOCCLASS.CLSID_STR;
pub const ASSOCCLASS_APP_KEY = ASSOCCLASS.APP_KEY;
pub const ASSOCCLASS_APP_STR = ASSOCCLASS.APP_STR;
pub const ASSOCCLASS_SYSTEM_STR = ASSOCCLASS.SYSTEM_STR;
pub const ASSOCCLASS_FOLDER = ASSOCCLASS.FOLDER;
pub const ASSOCCLASS_STAR = ASSOCCLASS.STAR;
pub const ASSOCCLASS_FIXED_PROGID_STR = ASSOCCLASS.FIXED_PROGID_STR;
pub const ASSOCCLASS_PROTOCOL_STR = ASSOCCLASS.PROTOCOL_STR;

pub const QUERY_USER_NOTIFICATION_STATE = enum(i32) {
    NOT_PRESENT = 1,
    BUSY = 2,
    RUNNING_D3D_FULL_SCREEN = 3,
    PRESENTATION_MODE = 4,
    ACCEPTS_NOTIFICATIONS = 5,
    QUIET_TIME = 6,
    APP = 7,
};
pub const QUNS_NOT_PRESENT = QUERY_USER_NOTIFICATION_STATE.NOT_PRESENT;
pub const QUNS_BUSY = QUERY_USER_NOTIFICATION_STATE.BUSY;
pub const QUNS_RUNNING_D3D_FULL_SCREEN = QUERY_USER_NOTIFICATION_STATE.RUNNING_D3D_FULL_SCREEN;
pub const QUNS_PRESENTATION_MODE = QUERY_USER_NOTIFICATION_STATE.PRESENTATION_MODE;
pub const QUNS_ACCEPTS_NOTIFICATIONS = QUERY_USER_NOTIFICATION_STATE.ACCEPTS_NOTIFICATIONS;
pub const QUNS_QUIET_TIME = QUERY_USER_NOTIFICATION_STATE.QUIET_TIME;
pub const QUNS_APP = QUERY_USER_NOTIFICATION_STATE.APP;

pub const SHSTOCKICONID = enum(i32) {
    DOCNOASSOC = 0,
    DOCASSOC = 1,
    APPLICATION = 2,
    FOLDER = 3,
    FOLDEROPEN = 4,
    DRIVE525 = 5,
    DRIVE35 = 6,
    DRIVEREMOVE = 7,
    DRIVEFIXED = 8,
    DRIVENET = 9,
    DRIVENETDISABLED = 10,
    DRIVECD = 11,
    DRIVERAM = 12,
    WORLD = 13,
    SERVER = 15,
    PRINTER = 16,
    MYNETWORK = 17,
    FIND = 22,
    HELP = 23,
    SHARE = 28,
    LINK = 29,
    SLOWFILE = 30,
    RECYCLER = 31,
    RECYCLERFULL = 32,
    MEDIACDAUDIO = 40,
    LOCK = 47,
    AUTOLIST = 49,
    PRINTERNET = 50,
    SERVERSHARE = 51,
    PRINTERFAX = 52,
    PRINTERFAXNET = 53,
    PRINTERFILE = 54,
    STACK = 55,
    MEDIASVCD = 56,
    STUFFEDFOLDER = 57,
    DRIVEUNKNOWN = 58,
    DRIVEDVD = 59,
    MEDIADVD = 60,
    MEDIADVDRAM = 61,
    MEDIADVDRW = 62,
    MEDIADVDR = 63,
    MEDIADVDROM = 64,
    MEDIACDAUDIOPLUS = 65,
    MEDIACDRW = 66,
    MEDIACDR = 67,
    MEDIACDBURN = 68,
    MEDIABLANKCD = 69,
    MEDIACDROM = 70,
    AUDIOFILES = 71,
    IMAGEFILES = 72,
    VIDEOFILES = 73,
    MIXEDFILES = 74,
    FOLDERBACK = 75,
    FOLDERFRONT = 76,
    SHIELD = 77,
    WARNING = 78,
    INFO = 79,
    ERROR = 80,
    KEY = 81,
    SOFTWARE = 82,
    RENAME = 83,
    DELETE = 84,
    MEDIAAUDIODVD = 85,
    MEDIAMOVIEDVD = 86,
    MEDIAENHANCEDCD = 87,
    MEDIAENHANCEDDVD = 88,
    MEDIAHDDVD = 89,
    MEDIABLURAY = 90,
    MEDIAVCD = 91,
    MEDIADVDPLUSR = 92,
    MEDIADVDPLUSRW = 93,
    DESKTOPPC = 94,
    MOBILEPC = 95,
    USERS = 96,
    MEDIASMARTMEDIA = 97,
    MEDIACOMPACTFLASH = 98,
    DEVICECELLPHONE = 99,
    DEVICECAMERA = 100,
    DEVICEVIDEOCAMERA = 101,
    DEVICEAUDIOPLAYER = 102,
    NETWORKCONNECT = 103,
    INTERNET = 104,
    ZIPFILE = 105,
    SETTINGS = 106,
    DRIVEHDDVD = 132,
    DRIVEBD = 133,
    MEDIAHDDVDROM = 134,
    MEDIAHDDVDR = 135,
    MEDIAHDDVDRAM = 136,
    MEDIABDROM = 137,
    MEDIABDR = 138,
    MEDIABDRE = 139,
    CLUSTEREDDRIVE = 140,
    MAX_ICONS = 181,
};
pub const SIID_DOCNOASSOC = SHSTOCKICONID.DOCNOASSOC;
pub const SIID_DOCASSOC = SHSTOCKICONID.DOCASSOC;
pub const SIID_APPLICATION = SHSTOCKICONID.APPLICATION;
pub const SIID_FOLDER = SHSTOCKICONID.FOLDER;
pub const SIID_FOLDEROPEN = SHSTOCKICONID.FOLDEROPEN;
pub const SIID_DRIVE525 = SHSTOCKICONID.DRIVE525;
pub const SIID_DRIVE35 = SHSTOCKICONID.DRIVE35;
pub const SIID_DRIVEREMOVE = SHSTOCKICONID.DRIVEREMOVE;
pub const SIID_DRIVEFIXED = SHSTOCKICONID.DRIVEFIXED;
pub const SIID_DRIVENET = SHSTOCKICONID.DRIVENET;
pub const SIID_DRIVENETDISABLED = SHSTOCKICONID.DRIVENETDISABLED;
pub const SIID_DRIVECD = SHSTOCKICONID.DRIVECD;
pub const SIID_DRIVERAM = SHSTOCKICONID.DRIVERAM;
pub const SIID_WORLD = SHSTOCKICONID.WORLD;
pub const SIID_SERVER = SHSTOCKICONID.SERVER;
pub const SIID_PRINTER = SHSTOCKICONID.PRINTER;
pub const SIID_MYNETWORK = SHSTOCKICONID.MYNETWORK;
pub const SIID_FIND = SHSTOCKICONID.FIND;
pub const SIID_HELP = SHSTOCKICONID.HELP;
pub const SIID_SHARE = SHSTOCKICONID.SHARE;
pub const SIID_LINK = SHSTOCKICONID.LINK;
pub const SIID_SLOWFILE = SHSTOCKICONID.SLOWFILE;
pub const SIID_RECYCLER = SHSTOCKICONID.RECYCLER;
pub const SIID_RECYCLERFULL = SHSTOCKICONID.RECYCLERFULL;
pub const SIID_MEDIACDAUDIO = SHSTOCKICONID.MEDIACDAUDIO;
pub const SIID_LOCK = SHSTOCKICONID.LOCK;
pub const SIID_AUTOLIST = SHSTOCKICONID.AUTOLIST;
pub const SIID_PRINTERNET = SHSTOCKICONID.PRINTERNET;
pub const SIID_SERVERSHARE = SHSTOCKICONID.SERVERSHARE;
pub const SIID_PRINTERFAX = SHSTOCKICONID.PRINTERFAX;
pub const SIID_PRINTERFAXNET = SHSTOCKICONID.PRINTERFAXNET;
pub const SIID_PRINTERFILE = SHSTOCKICONID.PRINTERFILE;
pub const SIID_STACK = SHSTOCKICONID.STACK;
pub const SIID_MEDIASVCD = SHSTOCKICONID.MEDIASVCD;
pub const SIID_STUFFEDFOLDER = SHSTOCKICONID.STUFFEDFOLDER;
pub const SIID_DRIVEUNKNOWN = SHSTOCKICONID.DRIVEUNKNOWN;
pub const SIID_DRIVEDVD = SHSTOCKICONID.DRIVEDVD;
pub const SIID_MEDIADVD = SHSTOCKICONID.MEDIADVD;
pub const SIID_MEDIADVDRAM = SHSTOCKICONID.MEDIADVDRAM;
pub const SIID_MEDIADVDRW = SHSTOCKICONID.MEDIADVDRW;
pub const SIID_MEDIADVDR = SHSTOCKICONID.MEDIADVDR;
pub const SIID_MEDIADVDROM = SHSTOCKICONID.MEDIADVDROM;
pub const SIID_MEDIACDAUDIOPLUS = SHSTOCKICONID.MEDIACDAUDIOPLUS;
pub const SIID_MEDIACDRW = SHSTOCKICONID.MEDIACDRW;
pub const SIID_MEDIACDR = SHSTOCKICONID.MEDIACDR;
pub const SIID_MEDIACDBURN = SHSTOCKICONID.MEDIACDBURN;
pub const SIID_MEDIABLANKCD = SHSTOCKICONID.MEDIABLANKCD;
pub const SIID_MEDIACDROM = SHSTOCKICONID.MEDIACDROM;
pub const SIID_AUDIOFILES = SHSTOCKICONID.AUDIOFILES;
pub const SIID_IMAGEFILES = SHSTOCKICONID.IMAGEFILES;
pub const SIID_VIDEOFILES = SHSTOCKICONID.VIDEOFILES;
pub const SIID_MIXEDFILES = SHSTOCKICONID.MIXEDFILES;
pub const SIID_FOLDERBACK = SHSTOCKICONID.FOLDERBACK;
pub const SIID_FOLDERFRONT = SHSTOCKICONID.FOLDERFRONT;
pub const SIID_SHIELD = SHSTOCKICONID.SHIELD;
pub const SIID_WARNING = SHSTOCKICONID.WARNING;
pub const SIID_INFO = SHSTOCKICONID.INFO;
pub const SIID_ERROR = SHSTOCKICONID.ERROR;
pub const SIID_KEY = SHSTOCKICONID.KEY;
pub const SIID_SOFTWARE = SHSTOCKICONID.SOFTWARE;
pub const SIID_RENAME = SHSTOCKICONID.RENAME;
pub const SIID_DELETE = SHSTOCKICONID.DELETE;
pub const SIID_MEDIAAUDIODVD = SHSTOCKICONID.MEDIAAUDIODVD;
pub const SIID_MEDIAMOVIEDVD = SHSTOCKICONID.MEDIAMOVIEDVD;
pub const SIID_MEDIAENHANCEDCD = SHSTOCKICONID.MEDIAENHANCEDCD;
pub const SIID_MEDIAENHANCEDDVD = SHSTOCKICONID.MEDIAENHANCEDDVD;
pub const SIID_MEDIAHDDVD = SHSTOCKICONID.MEDIAHDDVD;
pub const SIID_MEDIABLURAY = SHSTOCKICONID.MEDIABLURAY;
pub const SIID_MEDIAVCD = SHSTOCKICONID.MEDIAVCD;
pub const SIID_MEDIADVDPLUSR = SHSTOCKICONID.MEDIADVDPLUSR;
pub const SIID_MEDIADVDPLUSRW = SHSTOCKICONID.MEDIADVDPLUSRW;
pub const SIID_DESKTOPPC = SHSTOCKICONID.DESKTOPPC;
pub const SIID_MOBILEPC = SHSTOCKICONID.MOBILEPC;
pub const SIID_USERS = SHSTOCKICONID.USERS;
pub const SIID_MEDIASMARTMEDIA = SHSTOCKICONID.MEDIASMARTMEDIA;
pub const SIID_MEDIACOMPACTFLASH = SHSTOCKICONID.MEDIACOMPACTFLASH;
pub const SIID_DEVICECELLPHONE = SHSTOCKICONID.DEVICECELLPHONE;
pub const SIID_DEVICECAMERA = SHSTOCKICONID.DEVICECAMERA;
pub const SIID_DEVICEVIDEOCAMERA = SHSTOCKICONID.DEVICEVIDEOCAMERA;
pub const SIID_DEVICEAUDIOPLAYER = SHSTOCKICONID.DEVICEAUDIOPLAYER;
pub const SIID_NETWORKCONNECT = SHSTOCKICONID.NETWORKCONNECT;
pub const SIID_INTERNET = SHSTOCKICONID.INTERNET;
pub const SIID_ZIPFILE = SHSTOCKICONID.ZIPFILE;
pub const SIID_SETTINGS = SHSTOCKICONID.SETTINGS;
pub const SIID_DRIVEHDDVD = SHSTOCKICONID.DRIVEHDDVD;
pub const SIID_DRIVEBD = SHSTOCKICONID.DRIVEBD;
pub const SIID_MEDIAHDDVDROM = SHSTOCKICONID.MEDIAHDDVDROM;
pub const SIID_MEDIAHDDVDR = SHSTOCKICONID.MEDIAHDDVDR;
pub const SIID_MEDIAHDDVDRAM = SHSTOCKICONID.MEDIAHDDVDRAM;
pub const SIID_MEDIABDROM = SHSTOCKICONID.MEDIABDROM;
pub const SIID_MEDIABDR = SHSTOCKICONID.MEDIABDR;
pub const SIID_MEDIABDRE = SHSTOCKICONID.MEDIABDRE;
pub const SIID_CLUSTEREDDRIVE = SHSTOCKICONID.CLUSTEREDDRIVE;
pub const SIID_MAX_ICONS = SHSTOCKICONID.MAX_ICONS;

pub const PFNCANSHAREFOLDERW = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        pszPath: ?[*:0]const u16,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn (
        pszPath: ?[*:0]const u16,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
};

pub const PFNSHOWSHAREFOLDERUIW = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        hwndParent: ?HWND,
        pszPath: ?[*:0]const u16,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn (
        hwndParent: ?HWND,
        pszPath: ?[*:0]const u16,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
};

pub const NC_ADDRESS = extern struct {
    pub const NET_ADDRESS_INFO = extern struct {
        placeholder: usize, // TODO: why is this type empty?
    };
    pAddrInfo: ?*NET_ADDRESS_INFO,
    PortNumber: u16,
    PrefixLength: u8,
};

pub const SFBS_FLAGS = enum(i32) {
    ROUND_TO_NEAREST_DISPLAYED_DIGIT = 1,
    TRUNCATE_UNDISPLAYED_DECIMAL_DIGITS = 2,
};
pub const SFBS_FLAGS_ROUND_TO_NEAREST_DISPLAYED_DIGIT = SFBS_FLAGS.ROUND_TO_NEAREST_DISPLAYED_DIGIT;
pub const SFBS_FLAGS_TRUNCATE_UNDISPLAYED_DECIMAL_DIGITS = SFBS_FLAGS.TRUNCATE_UNDISPLAYED_DECIMAL_DIGITS;

pub const URL_SCHEME = enum(i32) {
    INVALID = -1,
    UNKNOWN = 0,
    FTP = 1,
    HTTP = 2,
    GOPHER = 3,
    MAILTO = 4,
    NEWS = 5,
    NNTP = 6,
    TELNET = 7,
    WAIS = 8,
    FILE = 9,
    MK = 10,
    HTTPS = 11,
    SHELL = 12,
    SNEWS = 13,
    LOCAL = 14,
    JAVASCRIPT = 15,
    VBSCRIPT = 16,
    ABOUT = 17,
    RES = 18,
    MSSHELLROOTED = 19,
    MSSHELLIDLIST = 20,
    MSHELP = 21,
    MSSHELLDEVICE = 22,
    WILDCARD = 23,
    SEARCH_MS = 24,
    SEARCH = 25,
    KNOWNFOLDER = 26,
    MAXVALUE = 27,
};
pub const URL_SCHEME_INVALID = URL_SCHEME.INVALID;
pub const URL_SCHEME_UNKNOWN = URL_SCHEME.UNKNOWN;
pub const URL_SCHEME_FTP = URL_SCHEME.FTP;
pub const URL_SCHEME_HTTP = URL_SCHEME.HTTP;
pub const URL_SCHEME_GOPHER = URL_SCHEME.GOPHER;
pub const URL_SCHEME_MAILTO = URL_SCHEME.MAILTO;
pub const URL_SCHEME_NEWS = URL_SCHEME.NEWS;
pub const URL_SCHEME_NNTP = URL_SCHEME.NNTP;
pub const URL_SCHEME_TELNET = URL_SCHEME.TELNET;
pub const URL_SCHEME_WAIS = URL_SCHEME.WAIS;
pub const URL_SCHEME_FILE = URL_SCHEME.FILE;
pub const URL_SCHEME_MK = URL_SCHEME.MK;
pub const URL_SCHEME_HTTPS = URL_SCHEME.HTTPS;
pub const URL_SCHEME_SHELL = URL_SCHEME.SHELL;
pub const URL_SCHEME_SNEWS = URL_SCHEME.SNEWS;
pub const URL_SCHEME_LOCAL = URL_SCHEME.LOCAL;
pub const URL_SCHEME_JAVASCRIPT = URL_SCHEME.JAVASCRIPT;
pub const URL_SCHEME_VBSCRIPT = URL_SCHEME.VBSCRIPT;
pub const URL_SCHEME_ABOUT = URL_SCHEME.ABOUT;
pub const URL_SCHEME_RES = URL_SCHEME.RES;
pub const URL_SCHEME_MSSHELLROOTED = URL_SCHEME.MSSHELLROOTED;
pub const URL_SCHEME_MSSHELLIDLIST = URL_SCHEME.MSSHELLIDLIST;
pub const URL_SCHEME_MSHELP = URL_SCHEME.MSHELP;
pub const URL_SCHEME_MSSHELLDEVICE = URL_SCHEME.MSSHELLDEVICE;
pub const URL_SCHEME_WILDCARD = URL_SCHEME.WILDCARD;
pub const URL_SCHEME_SEARCH_MS = URL_SCHEME.SEARCH_MS;
pub const URL_SCHEME_SEARCH = URL_SCHEME.SEARCH;
pub const URL_SCHEME_KNOWNFOLDER = URL_SCHEME.KNOWNFOLDER;
pub const URL_SCHEME_MAXVALUE = URL_SCHEME.MAXVALUE;

pub const URL_PART = enum(i32) {
    NONE = 0,
    SCHEME = 1,
    HOSTNAME = 2,
    USERNAME = 3,
    PASSWORD = 4,
    PORT = 5,
    QUERY = 6,
};
pub const URL_PART_NONE = URL_PART.NONE;
pub const URL_PART_SCHEME = URL_PART.SCHEME;
pub const URL_PART_HOSTNAME = URL_PART.HOSTNAME;
pub const URL_PART_USERNAME = URL_PART.USERNAME;
pub const URL_PART_PASSWORD = URL_PART.PASSWORD;
pub const URL_PART_PORT = URL_PART.PORT;
pub const URL_PART_QUERY = URL_PART.QUERY;

pub const URLIS = enum(i32) {
    URL = 0,
    OPAQUE = 1,
    NOHISTORY = 2,
    FILEURL = 3,
    APPLIABLE = 4,
    DIRECTORY = 5,
    HASQUERY = 6,
};
pub const URLIS_URL = URLIS.URL;
pub const URLIS_OPAQUE = URLIS.OPAQUE;
pub const URLIS_NOHISTORY = URLIS.NOHISTORY;
pub const URLIS_FILEURL = URLIS.FILEURL;
pub const URLIS_APPLIABLE = URLIS.APPLIABLE;
pub const URLIS_DIRECTORY = URLIS.DIRECTORY;
pub const URLIS_HASQUERY = URLIS.HASQUERY;

pub const PARSEDURLA = extern struct {
    cbSize: u32,
    pszProtocol: ?[*:0]const u8,
    cchProtocol: u32,
    pszSuffix: ?[*:0]const u8,
    cchSuffix: u32,
    nScheme: u32,
};

pub const PARSEDURLW = extern struct {
    cbSize: u32,
    pszProtocol: ?[*:0]const u16,
    cchProtocol: u32,
    pszSuffix: ?[*:0]const u16,
    cchSuffix: u32,
    nScheme: u32,
};

pub const SHREGDEL_FLAGS = enum(i32) {
    DEFAULT = 0,
    HKCU = 1,
    HKLM = 16,
    BOTH = 17,
};
pub const SHREGDEL_DEFAULT = SHREGDEL_FLAGS.DEFAULT;
pub const SHREGDEL_HKCU = SHREGDEL_FLAGS.HKCU;
pub const SHREGDEL_HKLM = SHREGDEL_FLAGS.HKLM;
pub const SHREGDEL_BOTH = SHREGDEL_FLAGS.BOTH;

pub const SHREGENUM_FLAGS = enum(i32) {
    DEFAULT = 0,
    HKCU = 1,
    HKLM = 16,
    BOTH = 17,
};
pub const SHREGENUM_DEFAULT = SHREGENUM_FLAGS.DEFAULT;
pub const SHREGENUM_HKCU = SHREGENUM_FLAGS.HKCU;
pub const SHREGENUM_HKLM = SHREGENUM_FLAGS.HKLM;
pub const SHREGENUM_BOTH = SHREGENUM_FLAGS.BOTH;

pub const ASSOCSTR = enum(i32) {
    COMMAND = 1,
    EXECUTABLE = 2,
    FRIENDLYDOCNAME = 3,
    FRIENDLYAPPNAME = 4,
    NOOPEN = 5,
    SHELLNEWVALUE = 6,
    DDECOMMAND = 7,
    DDEIFEXEC = 8,
    DDEAPPLICATION = 9,
    DDETOPIC = 10,
    INFOTIP = 11,
    QUICKTIP = 12,
    TILEINFO = 13,
    CONTENTTYPE = 14,
    DEFAULTICON = 15,
    SHELLEXTENSION = 16,
    DROPTARGET = 17,
    DELEGATEEXECUTE = 18,
    SUPPORTED_URI_PROTOCOLS = 19,
    PROGID = 20,
    APPID = 21,
    APPPUBLISHER = 22,
    APPICONREFERENCE = 23,
    MAX = 24,
};
pub const ASSOCSTR_COMMAND = ASSOCSTR.COMMAND;
pub const ASSOCSTR_EXECUTABLE = ASSOCSTR.EXECUTABLE;
pub const ASSOCSTR_FRIENDLYDOCNAME = ASSOCSTR.FRIENDLYDOCNAME;
pub const ASSOCSTR_FRIENDLYAPPNAME = ASSOCSTR.FRIENDLYAPPNAME;
pub const ASSOCSTR_NOOPEN = ASSOCSTR.NOOPEN;
pub const ASSOCSTR_SHELLNEWVALUE = ASSOCSTR.SHELLNEWVALUE;
pub const ASSOCSTR_DDECOMMAND = ASSOCSTR.DDECOMMAND;
pub const ASSOCSTR_DDEIFEXEC = ASSOCSTR.DDEIFEXEC;
pub const ASSOCSTR_DDEAPPLICATION = ASSOCSTR.DDEAPPLICATION;
pub const ASSOCSTR_DDETOPIC = ASSOCSTR.DDETOPIC;
pub const ASSOCSTR_INFOTIP = ASSOCSTR.INFOTIP;
pub const ASSOCSTR_QUICKTIP = ASSOCSTR.QUICKTIP;
pub const ASSOCSTR_TILEINFO = ASSOCSTR.TILEINFO;
pub const ASSOCSTR_CONTENTTYPE = ASSOCSTR.CONTENTTYPE;
pub const ASSOCSTR_DEFAULTICON = ASSOCSTR.DEFAULTICON;
pub const ASSOCSTR_SHELLEXTENSION = ASSOCSTR.SHELLEXTENSION;
pub const ASSOCSTR_DROPTARGET = ASSOCSTR.DROPTARGET;
pub const ASSOCSTR_DELEGATEEXECUTE = ASSOCSTR.DELEGATEEXECUTE;
pub const ASSOCSTR_SUPPORTED_URI_PROTOCOLS = ASSOCSTR.SUPPORTED_URI_PROTOCOLS;
pub const ASSOCSTR_PROGID = ASSOCSTR.PROGID;
pub const ASSOCSTR_APPID = ASSOCSTR.APPID;
pub const ASSOCSTR_APPPUBLISHER = ASSOCSTR.APPPUBLISHER;
pub const ASSOCSTR_APPICONREFERENCE = ASSOCSTR.APPICONREFERENCE;
pub const ASSOCSTR_MAX = ASSOCSTR.MAX;

pub const ASSOCKEY = enum(i32) {
    SHELLEXECCLASS = 1,
    APP = 2,
    CLASS = 3,
    BASECLASS = 4,
    MAX = 5,
};
pub const ASSOCKEY_SHELLEXECCLASS = ASSOCKEY.SHELLEXECCLASS;
pub const ASSOCKEY_APP = ASSOCKEY.APP;
pub const ASSOCKEY_CLASS = ASSOCKEY.CLASS;
pub const ASSOCKEY_BASECLASS = ASSOCKEY.BASECLASS;
pub const ASSOCKEY_MAX = ASSOCKEY.MAX;

pub const ASSOCDATA = enum(i32) {
    MSIDESCRIPTOR = 1,
    NOACTIVATEHANDLER = 2,
    UNUSED1 = 3,
    HASPERUSERASSOC = 4,
    EDITFLAGS = 5,
    VALUE = 6,
    MAX = 7,
};
pub const ASSOCDATA_MSIDESCRIPTOR = ASSOCDATA.MSIDESCRIPTOR;
pub const ASSOCDATA_NOACTIVATEHANDLER = ASSOCDATA.NOACTIVATEHANDLER;
pub const ASSOCDATA_UNUSED1 = ASSOCDATA.UNUSED1;
pub const ASSOCDATA_HASPERUSERASSOC = ASSOCDATA.HASPERUSERASSOC;
pub const ASSOCDATA_EDITFLAGS = ASSOCDATA.EDITFLAGS;
pub const ASSOCDATA_VALUE = ASSOCDATA.VALUE;
pub const ASSOCDATA_MAX = ASSOCDATA.MAX;

pub const ASSOCENUM = enum(i32) {
    E = 0,
};
pub const ASSOCENUM_NONE = ASSOCENUM.E;

pub const FILETYPEATTRIBUTEFLAGS = enum(i32) {
    None = 0,
    Exclude = 1,
    Show = 2,
    HasExtension = 4,
    NoEdit = 8,
    NoRemove = 16,
    NoNewVerb = 32,
    NoEditVerb = 64,
    NoRemoveVerb = 128,
    NoEditDesc = 256,
    NoEditIcon = 512,
    NoEditDflt = 1024,
    NoEditVerbCmd = 2048,
    NoEditVerbExe = 4096,
    NoDDE = 8192,
    NoEditMIME = 32768,
    OpenIsSafe = 65536,
    AlwaysUnsafe = 131072,
    NoRecentDocs = 1048576,
    SafeForElevation = 2097152,
    AlwaysUseDirectInvoke = 4194304,
};
pub const FTA_None = FILETYPEATTRIBUTEFLAGS.None;
pub const FTA_Exclude = FILETYPEATTRIBUTEFLAGS.Exclude;
pub const FTA_Show = FILETYPEATTRIBUTEFLAGS.Show;
pub const FTA_HasExtension = FILETYPEATTRIBUTEFLAGS.HasExtension;
pub const FTA_NoEdit = FILETYPEATTRIBUTEFLAGS.NoEdit;
pub const FTA_NoRemove = FILETYPEATTRIBUTEFLAGS.NoRemove;
pub const FTA_NoNewVerb = FILETYPEATTRIBUTEFLAGS.NoNewVerb;
pub const FTA_NoEditVerb = FILETYPEATTRIBUTEFLAGS.NoEditVerb;
pub const FTA_NoRemoveVerb = FILETYPEATTRIBUTEFLAGS.NoRemoveVerb;
pub const FTA_NoEditDesc = FILETYPEATTRIBUTEFLAGS.NoEditDesc;
pub const FTA_NoEditIcon = FILETYPEATTRIBUTEFLAGS.NoEditIcon;
pub const FTA_NoEditDflt = FILETYPEATTRIBUTEFLAGS.NoEditDflt;
pub const FTA_NoEditVerbCmd = FILETYPEATTRIBUTEFLAGS.NoEditVerbCmd;
pub const FTA_NoEditVerbExe = FILETYPEATTRIBUTEFLAGS.NoEditVerbExe;
pub const FTA_NoDDE = FILETYPEATTRIBUTEFLAGS.NoDDE;
pub const FTA_NoEditMIME = FILETYPEATTRIBUTEFLAGS.NoEditMIME;
pub const FTA_OpenIsSafe = FILETYPEATTRIBUTEFLAGS.OpenIsSafe;
pub const FTA_AlwaysUnsafe = FILETYPEATTRIBUTEFLAGS.AlwaysUnsafe;
pub const FTA_NoRecentDocs = FILETYPEATTRIBUTEFLAGS.NoRecentDocs;
pub const FTA_SafeForElevation = FILETYPEATTRIBUTEFLAGS.SafeForElevation;
pub const FTA_AlwaysUseDirectInvoke = FILETYPEATTRIBUTEFLAGS.AlwaysUseDirectInvoke;

// TODO: this type is limited to platform 'windows5.0'
const IID_IQueryAssociations_Value = Guid.initString("c46ca590-3c3f-11d2-bee6-0000f805ca57");
pub const IID_IQueryAssociations = &IID_IQueryAssociations_Value;
pub const IQueryAssociations = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Init: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IQueryAssociations,
                flags: u32,
                pszAssoc: ?[*:0]const u16,
                hkProgid: ?HKEY,
                hwnd: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IQueryAssociations,
                flags: u32,
                pszAssoc: ?[*:0]const u16,
                hkProgid: ?HKEY,
                hwnd: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetString: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IQueryAssociations,
                flags: u32,
                str: ASSOCSTR,
                pszExtra: ?[*:0]const u16,
                pszOut: ?[*:0]u16,
                pcchOut: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IQueryAssociations,
                flags: u32,
                str: ASSOCSTR,
                pszExtra: ?[*:0]const u16,
                pszOut: ?[*:0]u16,
                pcchOut: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetKey: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IQueryAssociations,
                flags: u32,
                key: ASSOCKEY,
                pszExtra: ?[*:0]const u16,
                phkeyOut: ?*?HKEY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IQueryAssociations,
                flags: u32,
                key: ASSOCKEY,
                pszExtra: ?[*:0]const u16,
                phkeyOut: ?*?HKEY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IQueryAssociations,
                flags: u32,
                data: ASSOCDATA,
                pszExtra: ?[*:0]const u16,
                // TODO: what to do with BytesParamIndex 4?
                pvOut: ?*anyopaque,
                pcbOut: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IQueryAssociations,
                flags: u32,
                data: ASSOCDATA,
                pszExtra: ?[*:0]const u16,
                // TODO: what to do with BytesParamIndex 4?
                pvOut: ?*anyopaque,
                pcbOut: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEnum: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IQueryAssociations,
                flags: u32,
                assocenum: ASSOCENUM,
                pszExtra: ?[*:0]const u16,
                riid: ?*const Guid,
                ppvOut: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IQueryAssociations,
                flags: u32,
                assocenum: ASSOCENUM,
                pszExtra: ?[*:0]const u16,
                riid: ?*const Guid,
                ppvOut: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IQueryAssociations_Init(self: *const T, flags: u32, pszAssoc: ?[*:0]const u16, hkProgid: ?HKEY, hwnd: ?HWND) HRESULT {
                return @as(*const IQueryAssociations.VTable, @ptrCast(self.vtable)).Init(@as(*const IQueryAssociations, @ptrCast(self)), flags, pszAssoc, hkProgid, hwnd);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IQueryAssociations_GetString(self: *const T, flags: u32, str: ASSOCSTR, pszExtra: ?[*:0]const u16, pszOut: ?[*:0]u16, pcchOut: ?*u32) HRESULT {
                return @as(*const IQueryAssociations.VTable, @ptrCast(self.vtable)).GetString(@as(*const IQueryAssociations, @ptrCast(self)), flags, str, pszExtra, pszOut, pcchOut);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IQueryAssociations_GetKey(self: *const T, flags: u32, key: ASSOCKEY, pszExtra: ?[*:0]const u16, phkeyOut: ?*?HKEY) HRESULT {
                return @as(*const IQueryAssociations.VTable, @ptrCast(self.vtable)).GetKey(@as(*const IQueryAssociations, @ptrCast(self)), flags, key, pszExtra, phkeyOut);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IQueryAssociations_GetData(self: *const T, flags: u32, data: ASSOCDATA, pszExtra: ?[*:0]const u16, pvOut: ?*anyopaque, pcbOut: ?*u32) HRESULT {
                return @as(*const IQueryAssociations.VTable, @ptrCast(self.vtable)).GetData(@as(*const IQueryAssociations, @ptrCast(self)), flags, data, pszExtra, pvOut, pcbOut);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IQueryAssociations_GetEnum(self: *const T, flags: u32, assocenum: ASSOCENUM, pszExtra: ?[*:0]const u16, riid: ?*const Guid, ppvOut: ?*?*anyopaque) HRESULT {
                return @as(*const IQueryAssociations.VTable, @ptrCast(self.vtable)).GetEnum(@as(*const IQueryAssociations, @ptrCast(self)), flags, assocenum, pszExtra, riid, ppvOut);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SHGLOBALCOUNTER = enum(i32) {
    GLOBALCOUNTER_SEARCHMANAGER = 0,
    GLOBALCOUNTER_SEARCHOPTIONS = 1,
    GLOBALCOUNTER_FOLDERSETTINGSCHANGE = 2,
    GLOBALCOUNTER_RATINGS = 3,
    GLOBALCOUNTER_APPROVEDSITES = 4,
    GLOBALCOUNTER_RESTRICTIONS = 5,
    GLOBALCOUNTER_SHELLSETTINGSCHANGED = 6,
    GLOBALCOUNTER_SYSTEMPIDLCHANGE = 7,
    GLOBALCOUNTER_OVERLAYMANAGER = 8,
    GLOBALCOUNTER_QUERYASSOCIATIONS = 9,
    GLOBALCOUNTER_IESESSIONS = 10,
    GLOBALCOUNTER_IEONLY_SESSIONS = 11,
    GLOBALCOUNTER_APPLICATION_DESTINATIONS = 12,
    __UNUSED_RECYCLE_WAS_GLOBALCOUNTER_CSCSYNCINPROGRESS = 13,
    GLOBALCOUNTER_BITBUCKETNUMDELETERS = 14,
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_SHARES = 15,
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_A = 16,
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_B = 17,
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_C = 18,
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_D = 19,
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_E = 20,
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_F = 21,
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_G = 22,
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_H = 23,
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_I = 24,
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_J = 25,
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_K = 26,
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_L = 27,
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_M = 28,
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_N = 29,
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_O = 30,
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_P = 31,
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_Q = 32,
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_R = 33,
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_S = 34,
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_T = 35,
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_U = 36,
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_V = 37,
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_W = 38,
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_X = 39,
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_Y = 40,
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_Z = 41,
    __UNUSED_RECYCLE_WAS_GLOBALCOUNTER_RECYCLEDIRTYCOUNT_SERVERDRIVE = 42,
    __UNUSED_RECYCLE_WAS_GLOBALCOUNTER_RECYCLEGLOBALDIRTYCOUNT = 43,
    GLOBALCOUNTER_RECYCLEBINENUM = 44,
    GLOBALCOUNTER_RECYCLEBINCORRUPTED = 45,
    GLOBALCOUNTER_RATINGS_STATECOUNTER = 46,
    GLOBALCOUNTER_PRIVATE_PROFILE_CACHE = 47,
    GLOBALCOUNTER_INTERNETTOOLBAR_LAYOUT = 48,
    GLOBALCOUNTER_FOLDERDEFINITION_CACHE = 49,
    GLOBALCOUNTER_COMMONPLACES_LIST_CACHE = 50,
    GLOBALCOUNTER_PRIVATE_PROFILE_CACHE_MACHINEWIDE = 51,
    GLOBALCOUNTER_ASSOCCHANGED = 52,
    GLOBALCOUNTER_APP_ITEMS_STATE_STORE_CACHE = 53,
    GLOBALCOUNTER_SETTINGSYNC_ENABLED = 54,
    GLOBALCOUNTER_APPSFOLDER_FILETYPEASSOCIATION_COUNTER = 55,
    GLOBALCOUNTER_USERINFOCHANGED = 56,
    GLOBALCOUNTER_SYNC_ENGINE_INFORMATION_CACHE_MACHINEWIDE = 57,
    GLOBALCOUNTER_BANNERS_DATAMODEL_CACHE_MACHINEWIDE = 58,
    GLOBALCOUNTER_MAXIMUMVALUE = 59,
};
pub const GLOBALCOUNTER_SEARCHMANAGER = SHGLOBALCOUNTER.GLOBALCOUNTER_SEARCHMANAGER;
pub const GLOBALCOUNTER_SEARCHOPTIONS = SHGLOBALCOUNTER.GLOBALCOUNTER_SEARCHOPTIONS;
pub const GLOBALCOUNTER_FOLDERSETTINGSCHANGE = SHGLOBALCOUNTER.GLOBALCOUNTER_FOLDERSETTINGSCHANGE;
pub const GLOBALCOUNTER_RATINGS = SHGLOBALCOUNTER.GLOBALCOUNTER_RATINGS;
pub const GLOBALCOUNTER_APPROVEDSITES = SHGLOBALCOUNTER.GLOBALCOUNTER_APPROVEDSITES;
pub const GLOBALCOUNTER_RESTRICTIONS = SHGLOBALCOUNTER.GLOBALCOUNTER_RESTRICTIONS;
pub const GLOBALCOUNTER_SHELLSETTINGSCHANGED = SHGLOBALCOUNTER.GLOBALCOUNTER_SHELLSETTINGSCHANGED;
pub const GLOBALCOUNTER_SYSTEMPIDLCHANGE = SHGLOBALCOUNTER.GLOBALCOUNTER_SYSTEMPIDLCHANGE;
pub const GLOBALCOUNTER_OVERLAYMANAGER = SHGLOBALCOUNTER.GLOBALCOUNTER_OVERLAYMANAGER;
pub const GLOBALCOUNTER_QUERYASSOCIATIONS = SHGLOBALCOUNTER.GLOBALCOUNTER_QUERYASSOCIATIONS;
pub const GLOBALCOUNTER_IESESSIONS = SHGLOBALCOUNTER.GLOBALCOUNTER_IESESSIONS;
pub const GLOBALCOUNTER_IEONLY_SESSIONS = SHGLOBALCOUNTER.GLOBALCOUNTER_IEONLY_SESSIONS;
pub const GLOBALCOUNTER_APPLICATION_DESTINATIONS = SHGLOBALCOUNTER.GLOBALCOUNTER_APPLICATION_DESTINATIONS;
pub const __UNUSED_RECYCLE_WAS_GLOBALCOUNTER_CSCSYNCINPROGRESS = SHGLOBALCOUNTER.__UNUSED_RECYCLE_WAS_GLOBALCOUNTER_CSCSYNCINPROGRESS;
pub const GLOBALCOUNTER_BITBUCKETNUMDELETERS = SHGLOBALCOUNTER.GLOBALCOUNTER_BITBUCKETNUMDELETERS;
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_SHARES = SHGLOBALCOUNTER.GLOBALCOUNTER_RECYCLEDIRTYCOUNT_SHARES;
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_A = SHGLOBALCOUNTER.GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_A;
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_B = SHGLOBALCOUNTER.GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_B;
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_C = SHGLOBALCOUNTER.GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_C;
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_D = SHGLOBALCOUNTER.GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_D;
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_E = SHGLOBALCOUNTER.GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_E;
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_F = SHGLOBALCOUNTER.GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_F;
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_G = SHGLOBALCOUNTER.GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_G;
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_H = SHGLOBALCOUNTER.GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_H;
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_I = SHGLOBALCOUNTER.GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_I;
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_J = SHGLOBALCOUNTER.GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_J;
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_K = SHGLOBALCOUNTER.GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_K;
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_L = SHGLOBALCOUNTER.GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_L;
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_M = SHGLOBALCOUNTER.GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_M;
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_N = SHGLOBALCOUNTER.GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_N;
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_O = SHGLOBALCOUNTER.GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_O;
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_P = SHGLOBALCOUNTER.GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_P;
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_Q = SHGLOBALCOUNTER.GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_Q;
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_R = SHGLOBALCOUNTER.GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_R;
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_S = SHGLOBALCOUNTER.GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_S;
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_T = SHGLOBALCOUNTER.GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_T;
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_U = SHGLOBALCOUNTER.GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_U;
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_V = SHGLOBALCOUNTER.GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_V;
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_W = SHGLOBALCOUNTER.GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_W;
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_X = SHGLOBALCOUNTER.GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_X;
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_Y = SHGLOBALCOUNTER.GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_Y;
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_Z = SHGLOBALCOUNTER.GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_Z;
pub const __UNUSED_RECYCLE_WAS_GLOBALCOUNTER_RECYCLEDIRTYCOUNT_SERVERDRIVE = SHGLOBALCOUNTER.__UNUSED_RECYCLE_WAS_GLOBALCOUNTER_RECYCLEDIRTYCOUNT_SERVERDRIVE;
pub const __UNUSED_RECYCLE_WAS_GLOBALCOUNTER_RECYCLEGLOBALDIRTYCOUNT = SHGLOBALCOUNTER.__UNUSED_RECYCLE_WAS_GLOBALCOUNTER_RECYCLEGLOBALDIRTYCOUNT;
pub const GLOBALCOUNTER_RECYCLEBINENUM = SHGLOBALCOUNTER.GLOBALCOUNTER_RECYCLEBINENUM;
pub const GLOBALCOUNTER_RECYCLEBINCORRUPTED = SHGLOBALCOUNTER.GLOBALCOUNTER_RECYCLEBINCORRUPTED;
pub const GLOBALCOUNTER_RATINGS_STATECOUNTER = SHGLOBALCOUNTER.GLOBALCOUNTER_RATINGS_STATECOUNTER;
pub const GLOBALCOUNTER_PRIVATE_PROFILE_CACHE = SHGLOBALCOUNTER.GLOBALCOUNTER_PRIVATE_PROFILE_CACHE;
pub const GLOBALCOUNTER_INTERNETTOOLBAR_LAYOUT = SHGLOBALCOUNTER.GLOBALCOUNTER_INTERNETTOOLBAR_LAYOUT;
pub const GLOBALCOUNTER_FOLDERDEFINITION_CACHE = SHGLOBALCOUNTER.GLOBALCOUNTER_FOLDERDEFINITION_CACHE;
pub const GLOBALCOUNTER_COMMONPLACES_LIST_CACHE = SHGLOBALCOUNTER.GLOBALCOUNTER_COMMONPLACES_LIST_CACHE;
pub const GLOBALCOUNTER_PRIVATE_PROFILE_CACHE_MACHINEWIDE = SHGLOBALCOUNTER.GLOBALCOUNTER_PRIVATE_PROFILE_CACHE_MACHINEWIDE;
pub const GLOBALCOUNTER_ASSOCCHANGED = SHGLOBALCOUNTER.GLOBALCOUNTER_ASSOCCHANGED;
pub const GLOBALCOUNTER_APP_ITEMS_STATE_STORE_CACHE = SHGLOBALCOUNTER.GLOBALCOUNTER_APP_ITEMS_STATE_STORE_CACHE;
pub const GLOBALCOUNTER_SETTINGSYNC_ENABLED = SHGLOBALCOUNTER.GLOBALCOUNTER_SETTINGSYNC_ENABLED;
pub const GLOBALCOUNTER_APPSFOLDER_FILETYPEASSOCIATION_COUNTER = SHGLOBALCOUNTER.GLOBALCOUNTER_APPSFOLDER_FILETYPEASSOCIATION_COUNTER;
pub const GLOBALCOUNTER_USERINFOCHANGED = SHGLOBALCOUNTER.GLOBALCOUNTER_USERINFOCHANGED;
pub const GLOBALCOUNTER_SYNC_ENGINE_INFORMATION_CACHE_MACHINEWIDE = SHGLOBALCOUNTER.GLOBALCOUNTER_SYNC_ENGINE_INFORMATION_CACHE_MACHINEWIDE;
pub const GLOBALCOUNTER_BANNERS_DATAMODEL_CACHE_MACHINEWIDE = SHGLOBALCOUNTER.GLOBALCOUNTER_BANNERS_DATAMODEL_CACHE_MACHINEWIDE;
pub const GLOBALCOUNTER_MAXIMUMVALUE = SHGLOBALCOUNTER.GLOBALCOUNTER_MAXIMUMVALUE;

pub const QITAB = extern struct {
    piid: ?*const Guid,
    dwOffset: u32,
};

pub const DLLVERSIONINFO = extern struct {
    cbSize: u32,
    dwMajorVersion: u32,
    dwMinorVersion: u32,
    dwBuildNumber: u32,
    dwPlatformID: u32,
};

pub const DLLVERSIONINFO2 = extern struct {
    info1: DLLVERSIONINFO,
    dwFlags: u32,
    ullVersion: u64,
};

pub const DLLGETVERSIONPROC = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        param0: ?*DLLVERSIONINFO,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn (
        param0: ?*DLLVERSIONINFO,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
};

pub const APPINFODATAFLAGS = enum(i32) {
    DISPLAYNAME = 1,
    VERSION = 2,
    PUBLISHER = 4,
    PRODUCTID = 8,
    REGISTEREDOWNER = 16,
    REGISTEREDCOMPANY = 32,
    LANGUAGE = 64,
    SUPPORTURL = 128,
    SUPPORTTELEPHONE = 256,
    HELPLINK = 512,
    INSTALLLOCATION = 1024,
    INSTALLSOURCE = 2048,
    INSTALLDATE = 4096,
    CONTACT = 16384,
    COMMENTS = 32768,
    IMAGE = 131072,
    READMEURL = 262144,
    UPDATEINFOURL = 524288,
};
pub const AIM_DISPLAYNAME = APPINFODATAFLAGS.DISPLAYNAME;
pub const AIM_VERSION = APPINFODATAFLAGS.VERSION;
pub const AIM_PUBLISHER = APPINFODATAFLAGS.PUBLISHER;
pub const AIM_PRODUCTID = APPINFODATAFLAGS.PRODUCTID;
pub const AIM_REGISTEREDOWNER = APPINFODATAFLAGS.REGISTEREDOWNER;
pub const AIM_REGISTEREDCOMPANY = APPINFODATAFLAGS.REGISTEREDCOMPANY;
pub const AIM_LANGUAGE = APPINFODATAFLAGS.LANGUAGE;
pub const AIM_SUPPORTURL = APPINFODATAFLAGS.SUPPORTURL;
pub const AIM_SUPPORTTELEPHONE = APPINFODATAFLAGS.SUPPORTTELEPHONE;
pub const AIM_HELPLINK = APPINFODATAFLAGS.HELPLINK;
pub const AIM_INSTALLLOCATION = APPINFODATAFLAGS.INSTALLLOCATION;
pub const AIM_INSTALLSOURCE = APPINFODATAFLAGS.INSTALLSOURCE;
pub const AIM_INSTALLDATE = APPINFODATAFLAGS.INSTALLDATE;
pub const AIM_CONTACT = APPINFODATAFLAGS.CONTACT;
pub const AIM_COMMENTS = APPINFODATAFLAGS.COMMENTS;
pub const AIM_IMAGE = APPINFODATAFLAGS.IMAGE;
pub const AIM_READMEURL = APPINFODATAFLAGS.READMEURL;
pub const AIM_UPDATEINFOURL = APPINFODATAFLAGS.UPDATEINFOURL;

pub const APPINFODATA = extern struct {
    cbSize: u32,
    dwMask: u32,
    pszDisplayName: ?PWSTR,
    pszVersion: ?PWSTR,
    pszPublisher: ?PWSTR,
    pszProductID: ?PWSTR,
    pszRegisteredOwner: ?PWSTR,
    pszRegisteredCompany: ?PWSTR,
    pszLanguage: ?PWSTR,
    pszSupportUrl: ?PWSTR,
    pszSupportTelephone: ?PWSTR,
    pszHelpLink: ?PWSTR,
    pszInstallLocation: ?PWSTR,
    pszInstallSource: ?PWSTR,
    pszInstallDate: ?PWSTR,
    pszContact: ?PWSTR,
    pszComments: ?PWSTR,
    pszImage: ?PWSTR,
    pszReadmeUrl: ?PWSTR,
    pszUpdateInfoUrl: ?PWSTR,
};

pub const APPACTIONFLAGS = enum(i32) {
    INSTALL = 1,
    UNINSTALL = 2,
    MODIFY = 4,
    REPAIR = 8,
    UPGRADE = 16,
    CANGETSIZE = 32,
    MODIFYREMOVE = 128,
    ADDLATER = 256,
    UNSCHEDULE = 512,
};
pub const APPACTION_INSTALL = APPACTIONFLAGS.INSTALL;
pub const APPACTION_UNINSTALL = APPACTIONFLAGS.UNINSTALL;
pub const APPACTION_MODIFY = APPACTIONFLAGS.MODIFY;
pub const APPACTION_REPAIR = APPACTIONFLAGS.REPAIR;
pub const APPACTION_UPGRADE = APPACTIONFLAGS.UPGRADE;
pub const APPACTION_CANGETSIZE = APPACTIONFLAGS.CANGETSIZE;
pub const APPACTION_MODIFYREMOVE = APPACTIONFLAGS.MODIFYREMOVE;
pub const APPACTION_ADDLATER = APPACTIONFLAGS.ADDLATER;
pub const APPACTION_UNSCHEDULE = APPACTIONFLAGS.UNSCHEDULE;

pub const SLOWAPPINFO = extern struct {
    ullSize: u64,
    ftLastUsed: FILETIME,
    iTimesUsed: i32,
    pszImage: ?PWSTR,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IShellApp_Value = Guid.initString("a3e14960-935f-11d1-b8b8-006008059382");
pub const IID_IShellApp = &IID_IShellApp_Value;
pub const IShellApp = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetAppInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellApp,
                pai: ?*APPINFODATA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellApp,
                pai: ?*APPINFODATA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPossibleActions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellApp,
                pdwActions: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellApp,
                pdwActions: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSlowAppInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellApp,
                psaid: ?*SLOWAPPINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellApp,
                psaid: ?*SLOWAPPINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCachedSlowAppInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellApp,
                psaid: ?*SLOWAPPINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellApp,
                psaid: ?*SLOWAPPINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsInstalled: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellApp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellApp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellApp_GetAppInfo(self: *const T, pai: ?*APPINFODATA) HRESULT {
                return @as(*const IShellApp.VTable, @ptrCast(self.vtable)).GetAppInfo(@as(*const IShellApp, @ptrCast(self)), pai);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellApp_GetPossibleActions(self: *const T, pdwActions: ?*u32) HRESULT {
                return @as(*const IShellApp.VTable, @ptrCast(self.vtable)).GetPossibleActions(@as(*const IShellApp, @ptrCast(self)), pdwActions);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellApp_GetSlowAppInfo(self: *const T, psaid: ?*SLOWAPPINFO) HRESULT {
                return @as(*const IShellApp.VTable, @ptrCast(self.vtable)).GetSlowAppInfo(@as(*const IShellApp, @ptrCast(self)), psaid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellApp_GetCachedSlowAppInfo(self: *const T, psaid: ?*SLOWAPPINFO) HRESULT {
                return @as(*const IShellApp.VTable, @ptrCast(self.vtable)).GetCachedSlowAppInfo(@as(*const IShellApp, @ptrCast(self)), psaid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellApp_IsInstalled(self: *const T) HRESULT {
                return @as(*const IShellApp.VTable, @ptrCast(self.vtable)).IsInstalled(@as(*const IShellApp, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const PUBAPPINFOFLAGS = enum(i32) {
    SOURCE = 1,
    ASSIGNEDTIME = 2,
    PUBLISHEDTIME = 4,
    SCHEDULEDTIME = 8,
    EXPIRETIME = 16,
};
pub const PAI_SOURCE = PUBAPPINFOFLAGS.SOURCE;
pub const PAI_ASSIGNEDTIME = PUBAPPINFOFLAGS.ASSIGNEDTIME;
pub const PAI_PUBLISHEDTIME = PUBAPPINFOFLAGS.PUBLISHEDTIME;
pub const PAI_SCHEDULEDTIME = PUBAPPINFOFLAGS.SCHEDULEDTIME;
pub const PAI_EXPIRETIME = PUBAPPINFOFLAGS.EXPIRETIME;

pub const PUBAPPINFO = extern struct {
    cbSize: u32,
    dwMask: u32,
    pszSource: ?PWSTR,
    stAssigned: SYSTEMTIME,
    stPublished: SYSTEMTIME,
    stScheduled: SYSTEMTIME,
    stExpire: SYSTEMTIME,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IPublishedApp_Value = Guid.initString("1bc752e0-9046-11d1-b8b3-006008059382");
pub const IID_IPublishedApp = &IID_IPublishedApp_Value;
pub const IPublishedApp = extern struct {
    pub const VTable = extern struct {
        base: IShellApp.VTable,
        Install: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPublishedApp,
                pstInstall: ?*SYSTEMTIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPublishedApp,
                pstInstall: ?*SYSTEMTIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPublishedAppInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPublishedApp,
                ppai: ?*PUBAPPINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPublishedApp,
                ppai: ?*PUBAPPINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Unschedule: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPublishedApp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPublishedApp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IShellApp.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPublishedApp_Install(self: *const T, pstInstall: ?*SYSTEMTIME) HRESULT {
                return @as(*const IPublishedApp.VTable, @ptrCast(self.vtable)).Install(@as(*const IPublishedApp, @ptrCast(self)), pstInstall);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPublishedApp_GetPublishedAppInfo(self: *const T, ppai: ?*PUBAPPINFO) HRESULT {
                return @as(*const IPublishedApp.VTable, @ptrCast(self.vtable)).GetPublishedAppInfo(@as(*const IPublishedApp, @ptrCast(self)), ppai);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPublishedApp_Unschedule(self: *const T) HRESULT {
                return @as(*const IPublishedApp.VTable, @ptrCast(self.vtable)).Unschedule(@as(*const IPublishedApp, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IPublishedApp2_Value = Guid.initString("12b81347-1b3a-4a04-aa61-3f768b67fd7e");
pub const IID_IPublishedApp2 = &IID_IPublishedApp2_Value;
pub const IPublishedApp2 = extern struct {
    pub const VTable = extern struct {
        base: IPublishedApp.VTable,
        Install2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPublishedApp2,
                pstInstall: ?*SYSTEMTIME,
                hwndParent: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPublishedApp2,
                pstInstall: ?*SYSTEMTIME,
                hwndParent: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IPublishedApp.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPublishedApp2_Install2(self: *const T, pstInstall: ?*SYSTEMTIME, hwndParent: ?HWND) HRESULT {
                return @as(*const IPublishedApp2.VTable, @ptrCast(self.vtable)).Install2(@as(*const IPublishedApp2, @ptrCast(self)), pstInstall, hwndParent);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IEnumPublishedApps_Value = Guid.initString("0b124f8c-91f0-11d1-b8b5-006008059382");
pub const IID_IEnumPublishedApps = &IID_IEnumPublishedApps_Value;
pub const IEnumPublishedApps = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumPublishedApps,
                pia: ?*?*IPublishedApp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumPublishedApps,
                pia: ?*?*IPublishedApp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumPublishedApps,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumPublishedApps,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumPublishedApps_Next(self: *const T, pia: ?*?*IPublishedApp) HRESULT {
                return @as(*const IEnumPublishedApps.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumPublishedApps, @ptrCast(self)), pia);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumPublishedApps_Reset(self: *const T) HRESULT {
                return @as(*const IEnumPublishedApps.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumPublishedApps, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IAppPublisher_Value = Guid.initString("07250a10-9cf9-11d1-9076-006008059382");
pub const IID_IAppPublisher = &IID_IAppPublisher_Value;
pub const IAppPublisher = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetNumberOfCategories: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAppPublisher,
                pdwCat: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAppPublisher,
                pdwCat: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCategories: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAppPublisher,
                pAppCategoryList: ?*APPCATEGORYINFOLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAppPublisher,
                pAppCategoryList: ?*APPCATEGORYINFOLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberOfApps: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAppPublisher,
                pdwApps: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAppPublisher,
                pdwApps: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumApps: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAppPublisher,
                pAppCategoryId: ?*Guid,
                ppepa: ?*?*IEnumPublishedApps,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAppPublisher,
                pAppCategoryId: ?*Guid,
                ppepa: ?*?*IEnumPublishedApps,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAppPublisher_GetNumberOfCategories(self: *const T, pdwCat: ?*u32) HRESULT {
                return @as(*const IAppPublisher.VTable, @ptrCast(self.vtable)).GetNumberOfCategories(@as(*const IAppPublisher, @ptrCast(self)), pdwCat);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAppPublisher_GetCategories(self: *const T, pAppCategoryList: ?*APPCATEGORYINFOLIST) HRESULT {
                return @as(*const IAppPublisher.VTable, @ptrCast(self.vtable)).GetCategories(@as(*const IAppPublisher, @ptrCast(self)), pAppCategoryList);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAppPublisher_GetNumberOfApps(self: *const T, pdwApps: ?*u32) HRESULT {
                return @as(*const IAppPublisher.VTable, @ptrCast(self.vtable)).GetNumberOfApps(@as(*const IAppPublisher, @ptrCast(self)), pdwApps);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAppPublisher_EnumApps(self: *const T, pAppCategoryId: ?*Guid, ppepa: ?*?*IEnumPublishedApps) HRESULT {
                return @as(*const IAppPublisher.VTable, @ptrCast(self.vtable)).EnumApps(@as(*const IAppPublisher, @ptrCast(self)), pAppCategoryId, ppepa);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const CLSID_PasswordCredentialProvider_Value = Guid.initString("60b78e88-ead8-445c-9cfd-0b87f74ea6cd");
pub const CLSID_PasswordCredentialProvider = &CLSID_PasswordCredentialProvider_Value;

const CLSID_V1PasswordCredentialProvider_Value = Guid.initString("6f45dc1e-5384-457a-bc13-2cd81b0d28ed");
pub const CLSID_V1PasswordCredentialProvider = &CLSID_V1PasswordCredentialProvider_Value;

const CLSID_PINLogonCredentialProvider_Value = Guid.initString("cb82ea12-9f71-446d-89e1-8d0924e1256e");
pub const CLSID_PINLogonCredentialProvider = &CLSID_PINLogonCredentialProvider_Value;

const CLSID_NPCredentialProvider_Value = Guid.initString("3dd6bec0-8193-4ffe-ae25-e08e39ea4063");
pub const CLSID_NPCredentialProvider = &CLSID_NPCredentialProvider_Value;

const CLSID_SmartcardCredentialProvider_Value = Guid.initString("8fd7e19c-3bf7-489b-a72c-846ab3678c96");
pub const CLSID_SmartcardCredentialProvider = &CLSID_SmartcardCredentialProvider_Value;

const CLSID_V1SmartcardCredentialProvider_Value = Guid.initString("8bf9a910-a8ff-457f-999f-a5ca10b4a885");
pub const CLSID_V1SmartcardCredentialProvider = &CLSID_V1SmartcardCredentialProvider_Value;

const CLSID_SmartcardPinProvider_Value = Guid.initString("94596c7e-3744-41ce-893e-bbf09122f76a");
pub const CLSID_SmartcardPinProvider = &CLSID_SmartcardPinProvider_Value;

const CLSID_SmartcardReaderSelectionProvider_Value = Guid.initString("1b283861-754f-4022-ad47-a5eaaa618894");
pub const CLSID_SmartcardReaderSelectionProvider = &CLSID_SmartcardReaderSelectionProvider_Value;

const CLSID_SmartcardWinRTProvider_Value = Guid.initString("1ee7337f-85ac-45e2-a23c-37c753209769");
pub const CLSID_SmartcardWinRTProvider = &CLSID_SmartcardWinRTProvider_Value;

const CLSID_GenericCredentialProvider_Value = Guid.initString("25cbb996-92ed-457e-b28c-4774084bd562");
pub const CLSID_GenericCredentialProvider = &CLSID_GenericCredentialProvider_Value;

const CLSID_RASProvider_Value = Guid.initString("5537e283-b1e7-4ef8-9c6e-7ab0afe5056d");
pub const CLSID_RASProvider = &CLSID_RASProvider_Value;

const CLSID_OnexCredentialProvider_Value = Guid.initString("07aa0886-cc8d-4e19-a410-1c75af686e62");
pub const CLSID_OnexCredentialProvider = &CLSID_OnexCredentialProvider_Value;

const CLSID_OnexPlapSmartcardCredentialProvider_Value = Guid.initString("33c86cd6-705f-4ba1-9adb-67070b837775");
pub const CLSID_OnexPlapSmartcardCredentialProvider = &CLSID_OnexPlapSmartcardCredentialProvider_Value;

const CLSID_VaultProvider_Value = Guid.initString("503739d0-4c5e-4cfd-b3ba-d881334f0df2");
pub const CLSID_VaultProvider = &CLSID_VaultProvider_Value;

const CLSID_WinBioCredentialProvider_Value = Guid.initString("bec09223-b018-416d-a0ac-523971b639f5");
pub const CLSID_WinBioCredentialProvider = &CLSID_WinBioCredentialProvider_Value;

const CLSID_V1WinBioCredentialProvider_Value = Guid.initString("ac3ac249-e820-4343-a65b-377ac634dc09");
pub const CLSID_V1WinBioCredentialProvider = &CLSID_V1WinBioCredentialProvider_Value;

pub const CREDENTIAL_PROVIDER_USAGE_SCENARIO = enum(i32) {
    INVALID = 0,
    LOGON = 1,
    UNLOCK_WORKSTATION = 2,
    CHANGE_PASSWORD = 3,
    CREDUI = 4,
    PLAP = 5,
};
pub const CPUS_INVALID = CREDENTIAL_PROVIDER_USAGE_SCENARIO.INVALID;
pub const CPUS_LOGON = CREDENTIAL_PROVIDER_USAGE_SCENARIO.LOGON;
pub const CPUS_UNLOCK_WORKSTATION = CREDENTIAL_PROVIDER_USAGE_SCENARIO.UNLOCK_WORKSTATION;
pub const CPUS_CHANGE_PASSWORD = CREDENTIAL_PROVIDER_USAGE_SCENARIO.CHANGE_PASSWORD;
pub const CPUS_CREDUI = CREDENTIAL_PROVIDER_USAGE_SCENARIO.CREDUI;
pub const CPUS_PLAP = CREDENTIAL_PROVIDER_USAGE_SCENARIO.PLAP;

pub const CREDENTIAL_PROVIDER_FIELD_TYPE = enum(i32) {
    INVALID = 0,
    LARGE_TEXT = 1,
    SMALL_TEXT = 2,
    COMMAND_LINK = 3,
    EDIT_TEXT = 4,
    PASSWORD_TEXT = 5,
    TILE_IMAGE = 6,
    CHECKBOX = 7,
    COMBOBOX = 8,
    SUBMIT_BUTTON = 9,
};
pub const CPFT_INVALID = CREDENTIAL_PROVIDER_FIELD_TYPE.INVALID;
pub const CPFT_LARGE_TEXT = CREDENTIAL_PROVIDER_FIELD_TYPE.LARGE_TEXT;
pub const CPFT_SMALL_TEXT = CREDENTIAL_PROVIDER_FIELD_TYPE.SMALL_TEXT;
pub const CPFT_COMMAND_LINK = CREDENTIAL_PROVIDER_FIELD_TYPE.COMMAND_LINK;
pub const CPFT_EDIT_TEXT = CREDENTIAL_PROVIDER_FIELD_TYPE.EDIT_TEXT;
pub const CPFT_PASSWORD_TEXT = CREDENTIAL_PROVIDER_FIELD_TYPE.PASSWORD_TEXT;
pub const CPFT_TILE_IMAGE = CREDENTIAL_PROVIDER_FIELD_TYPE.TILE_IMAGE;
pub const CPFT_CHECKBOX = CREDENTIAL_PROVIDER_FIELD_TYPE.CHECKBOX;
pub const CPFT_COMBOBOX = CREDENTIAL_PROVIDER_FIELD_TYPE.COMBOBOX;
pub const CPFT_SUBMIT_BUTTON = CREDENTIAL_PROVIDER_FIELD_TYPE.SUBMIT_BUTTON;

pub const CREDENTIAL_PROVIDER_FIELD_STATE = enum(i32) {
    HIDDEN = 0,
    DISPLAY_IN_SELECTED_TILE = 1,
    DISPLAY_IN_DESELECTED_TILE = 2,
    DISPLAY_IN_BOTH = 3,
};
pub const CPFS_HIDDEN = CREDENTIAL_PROVIDER_FIELD_STATE.HIDDEN;
pub const CPFS_DISPLAY_IN_SELECTED_TILE = CREDENTIAL_PROVIDER_FIELD_STATE.DISPLAY_IN_SELECTED_TILE;
pub const CPFS_DISPLAY_IN_DESELECTED_TILE = CREDENTIAL_PROVIDER_FIELD_STATE.DISPLAY_IN_DESELECTED_TILE;
pub const CPFS_DISPLAY_IN_BOTH = CREDENTIAL_PROVIDER_FIELD_STATE.DISPLAY_IN_BOTH;

pub const CREDENTIAL_PROVIDER_FIELD_INTERACTIVE_STATE = enum(i32) {
    NONE = 0,
    READONLY = 1,
    DISABLED = 2,
    FOCUSED = 3,
};
pub const CPFIS_NONE = CREDENTIAL_PROVIDER_FIELD_INTERACTIVE_STATE.NONE;
pub const CPFIS_READONLY = CREDENTIAL_PROVIDER_FIELD_INTERACTIVE_STATE.READONLY;
pub const CPFIS_DISABLED = CREDENTIAL_PROVIDER_FIELD_INTERACTIVE_STATE.DISABLED;
pub const CPFIS_FOCUSED = CREDENTIAL_PROVIDER_FIELD_INTERACTIVE_STATE.FOCUSED;

pub const CREDENTIAL_PROVIDER_FIELD_DESCRIPTOR = extern struct {
    dwFieldID: u32,
    cpft: CREDENTIAL_PROVIDER_FIELD_TYPE,
    pszLabel: ?PWSTR,
    guidFieldType: Guid,
};

pub const CREDENTIAL_PROVIDER_GET_SERIALIZATION_RESPONSE = enum(i32) {
    NO_CREDENTIAL_NOT_FINISHED = 0,
    NO_CREDENTIAL_FINISHED = 1,
    RETURN_CREDENTIAL_FINISHED = 2,
    RETURN_NO_CREDENTIAL_FINISHED = 3,
};
pub const CPGSR_NO_CREDENTIAL_NOT_FINISHED = CREDENTIAL_PROVIDER_GET_SERIALIZATION_RESPONSE.NO_CREDENTIAL_NOT_FINISHED;
pub const CPGSR_NO_CREDENTIAL_FINISHED = CREDENTIAL_PROVIDER_GET_SERIALIZATION_RESPONSE.NO_CREDENTIAL_FINISHED;
pub const CPGSR_RETURN_CREDENTIAL_FINISHED = CREDENTIAL_PROVIDER_GET_SERIALIZATION_RESPONSE.RETURN_CREDENTIAL_FINISHED;
pub const CPGSR_RETURN_NO_CREDENTIAL_FINISHED = CREDENTIAL_PROVIDER_GET_SERIALIZATION_RESPONSE.RETURN_NO_CREDENTIAL_FINISHED;

pub const CREDENTIAL_PROVIDER_STATUS_ICON = enum(i32) {
    NONE = 0,
    ERROR = 1,
    WARNING = 2,
    SUCCESS = 3,
};
pub const CPSI_NONE = CREDENTIAL_PROVIDER_STATUS_ICON.NONE;
pub const CPSI_ERROR = CREDENTIAL_PROVIDER_STATUS_ICON.ERROR;
pub const CPSI_WARNING = CREDENTIAL_PROVIDER_STATUS_ICON.WARNING;
pub const CPSI_SUCCESS = CREDENTIAL_PROVIDER_STATUS_ICON.SUCCESS;

pub const CREDENTIAL_PROVIDER_CREDENTIAL_SERIALIZATION = extern struct {
    ulAuthenticationPackage: u32,
    clsidCredentialProvider: Guid,
    cbSerialization: u32,
    rgbSerialization: ?*u8,
};

pub const CREDENTIAL_PROVIDER_ACCOUNT_OPTIONS = enum(i32) {
    NONE = 0,
    EMPTY_LOCAL = 1,
    EMPTY_CONNECTED = 2,
};
pub const CPAO_NONE = CREDENTIAL_PROVIDER_ACCOUNT_OPTIONS.NONE;
pub const CPAO_EMPTY_LOCAL = CREDENTIAL_PROVIDER_ACCOUNT_OPTIONS.EMPTY_LOCAL;
pub const CPAO_EMPTY_CONNECTED = CREDENTIAL_PROVIDER_ACCOUNT_OPTIONS.EMPTY_CONNECTED;

pub const CREDENTIAL_PROVIDER_CREDENTIAL_FIELD_OPTIONS = enum(i32) {
    NONE = 0,
    ENABLE_PASSWORD_REVEAL = 1,
    IS_EMAIL_ADDRESS = 2,
    ENABLE_TOUCH_KEYBOARD_AUTO_INVOKE = 4,
    NUMBERS_ONLY = 8,
    SHOW_ENGLISH_KEYBOARD = 16,
};
pub const CPCFO_NONE = CREDENTIAL_PROVIDER_CREDENTIAL_FIELD_OPTIONS.NONE;
pub const CPCFO_ENABLE_PASSWORD_REVEAL = CREDENTIAL_PROVIDER_CREDENTIAL_FIELD_OPTIONS.ENABLE_PASSWORD_REVEAL;
pub const CPCFO_IS_EMAIL_ADDRESS = CREDENTIAL_PROVIDER_CREDENTIAL_FIELD_OPTIONS.IS_EMAIL_ADDRESS;
pub const CPCFO_ENABLE_TOUCH_KEYBOARD_AUTO_INVOKE = CREDENTIAL_PROVIDER_CREDENTIAL_FIELD_OPTIONS.ENABLE_TOUCH_KEYBOARD_AUTO_INVOKE;
pub const CPCFO_NUMBERS_ONLY = CREDENTIAL_PROVIDER_CREDENTIAL_FIELD_OPTIONS.NUMBERS_ONLY;
pub const CPCFO_SHOW_ENGLISH_KEYBOARD = CREDENTIAL_PROVIDER_CREDENTIAL_FIELD_OPTIONS.SHOW_ENGLISH_KEYBOARD;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ICredentialProviderCredential_Value = Guid.initString("63913a93-40c1-481a-818d-4072ff8c70cc");
pub const IID_ICredentialProviderCredential = &IID_ICredentialProviderCredential_Value;
pub const ICredentialProviderCredential = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Advise: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICredentialProviderCredential,
                pcpce: ?*ICredentialProviderCredentialEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICredentialProviderCredential,
                pcpce: ?*ICredentialProviderCredentialEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnAdvise: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICredentialProviderCredential,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICredentialProviderCredential,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSelected: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICredentialProviderCredential,
                pbAutoLogon: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICredentialProviderCredential,
                pbAutoLogon: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDeselected: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICredentialProviderCredential,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICredentialProviderCredential,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFieldState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICredentialProviderCredential,
                dwFieldID: u32,
                pcpfs: ?*CREDENTIAL_PROVIDER_FIELD_STATE,
                pcpfis: ?*CREDENTIAL_PROVIDER_FIELD_INTERACTIVE_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICredentialProviderCredential,
                dwFieldID: u32,
                pcpfs: ?*CREDENTIAL_PROVIDER_FIELD_STATE,
                pcpfis: ?*CREDENTIAL_PROVIDER_FIELD_INTERACTIVE_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStringValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICredentialProviderCredential,
                dwFieldID: u32,
                ppsz: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICredentialProviderCredential,
                dwFieldID: u32,
                ppsz: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBitmapValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICredentialProviderCredential,
                dwFieldID: u32,
                phbmp: ?*?HBITMAP,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICredentialProviderCredential,
                dwFieldID: u32,
                phbmp: ?*?HBITMAP,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCheckboxValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICredentialProviderCredential,
                dwFieldID: u32,
                pbChecked: ?*BOOL,
                ppszLabel: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICredentialProviderCredential,
                dwFieldID: u32,
                pbChecked: ?*BOOL,
                ppszLabel: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSubmitButtonValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICredentialProviderCredential,
                dwFieldID: u32,
                pdwAdjacentTo: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICredentialProviderCredential,
                dwFieldID: u32,
                pdwAdjacentTo: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetComboBoxValueCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICredentialProviderCredential,
                dwFieldID: u32,
                pcItems: ?*u32,
                pdwSelectedItem: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICredentialProviderCredential,
                dwFieldID: u32,
                pcItems: ?*u32,
                pdwSelectedItem: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetComboBoxValueAt: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICredentialProviderCredential,
                dwFieldID: u32,
                dwItem: u32,
                ppszItem: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICredentialProviderCredential,
                dwFieldID: u32,
                dwItem: u32,
                ppszItem: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetStringValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICredentialProviderCredential,
                dwFieldID: u32,
                psz: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICredentialProviderCredential,
                dwFieldID: u32,
                psz: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCheckboxValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICredentialProviderCredential,
                dwFieldID: u32,
                bChecked: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICredentialProviderCredential,
                dwFieldID: u32,
                bChecked: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetComboBoxSelectedValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICredentialProviderCredential,
                dwFieldID: u32,
                dwSelectedItem: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICredentialProviderCredential,
                dwFieldID: u32,
                dwSelectedItem: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CommandLinkClicked: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICredentialProviderCredential,
                dwFieldID: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICredentialProviderCredential,
                dwFieldID: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSerialization: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICredentialProviderCredential,
                pcpgsr: ?*CREDENTIAL_PROVIDER_GET_SERIALIZATION_RESPONSE,
                pcpcs: ?*CREDENTIAL_PROVIDER_CREDENTIAL_SERIALIZATION,
                ppszOptionalStatusText: ?*?PWSTR,
                pcpsiOptionalStatusIcon: ?*CREDENTIAL_PROVIDER_STATUS_ICON,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICredentialProviderCredential,
                pcpgsr: ?*CREDENTIAL_PROVIDER_GET_SERIALIZATION_RESPONSE,
                pcpcs: ?*CREDENTIAL_PROVIDER_CREDENTIAL_SERIALIZATION,
                ppszOptionalStatusText: ?*?PWSTR,
                pcpsiOptionalStatusIcon: ?*CREDENTIAL_PROVIDER_STATUS_ICON,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReportResult: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICredentialProviderCredential,
                ntsStatus: NTSTATUS,
                ntsSubstatus: NTSTATUS,
                ppszOptionalStatusText: ?*?PWSTR,
                pcpsiOptionalStatusIcon: ?*CREDENTIAL_PROVIDER_STATUS_ICON,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICredentialProviderCredential,
                ntsStatus: NTSTATUS,
                ntsSubstatus: NTSTATUS,
                ppszOptionalStatusText: ?*?PWSTR,
                pcpsiOptionalStatusIcon: ?*CREDENTIAL_PROVIDER_STATUS_ICON,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICredentialProviderCredential_Advise(self: *const T, pcpce: ?*ICredentialProviderCredentialEvents) HRESULT {
                return @as(*const ICredentialProviderCredential.VTable, @ptrCast(self.vtable)).Advise(@as(*const ICredentialProviderCredential, @ptrCast(self)), pcpce);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICredentialProviderCredential_UnAdvise(self: *const T) HRESULT {
                return @as(*const ICredentialProviderCredential.VTable, @ptrCast(self.vtable)).UnAdvise(@as(*const ICredentialProviderCredential, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICredentialProviderCredential_SetSelected(self: *const T, pbAutoLogon: ?*BOOL) HRESULT {
                return @as(*const ICredentialProviderCredential.VTable, @ptrCast(self.vtable)).SetSelected(@as(*const ICredentialProviderCredential, @ptrCast(self)), pbAutoLogon);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICredentialProviderCredential_SetDeselected(self: *const T) HRESULT {
                return @as(*const ICredentialProviderCredential.VTable, @ptrCast(self.vtable)).SetDeselected(@as(*const ICredentialProviderCredential, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICredentialProviderCredential_GetFieldState(self: *const T, dwFieldID: u32, pcpfs: ?*CREDENTIAL_PROVIDER_FIELD_STATE, pcpfis: ?*CREDENTIAL_PROVIDER_FIELD_INTERACTIVE_STATE) HRESULT {
                return @as(*const ICredentialProviderCredential.VTable, @ptrCast(self.vtable)).GetFieldState(@as(*const ICredentialProviderCredential, @ptrCast(self)), dwFieldID, pcpfs, pcpfis);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICredentialProviderCredential_GetStringValue(self: *const T, dwFieldID: u32, ppsz: ?*?PWSTR) HRESULT {
                return @as(*const ICredentialProviderCredential.VTable, @ptrCast(self.vtable)).GetStringValue(@as(*const ICredentialProviderCredential, @ptrCast(self)), dwFieldID, ppsz);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICredentialProviderCredential_GetBitmapValue(self: *const T, dwFieldID: u32, phbmp: ?*?HBITMAP) HRESULT {
                return @as(*const ICredentialProviderCredential.VTable, @ptrCast(self.vtable)).GetBitmapValue(@as(*const ICredentialProviderCredential, @ptrCast(self)), dwFieldID, phbmp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICredentialProviderCredential_GetCheckboxValue(self: *const T, dwFieldID: u32, pbChecked: ?*BOOL, ppszLabel: ?*?PWSTR) HRESULT {
                return @as(*const ICredentialProviderCredential.VTable, @ptrCast(self.vtable)).GetCheckboxValue(@as(*const ICredentialProviderCredential, @ptrCast(self)), dwFieldID, pbChecked, ppszLabel);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICredentialProviderCredential_GetSubmitButtonValue(self: *const T, dwFieldID: u32, pdwAdjacentTo: ?*u32) HRESULT {
                return @as(*const ICredentialProviderCredential.VTable, @ptrCast(self.vtable)).GetSubmitButtonValue(@as(*const ICredentialProviderCredential, @ptrCast(self)), dwFieldID, pdwAdjacentTo);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICredentialProviderCredential_GetComboBoxValueCount(self: *const T, dwFieldID: u32, pcItems: ?*u32, pdwSelectedItem: ?*u32) HRESULT {
                return @as(*const ICredentialProviderCredential.VTable, @ptrCast(self.vtable)).GetComboBoxValueCount(@as(*const ICredentialProviderCredential, @ptrCast(self)), dwFieldID, pcItems, pdwSelectedItem);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICredentialProviderCredential_GetComboBoxValueAt(self: *const T, dwFieldID: u32, dwItem: u32, ppszItem: ?*?PWSTR) HRESULT {
                return @as(*const ICredentialProviderCredential.VTable, @ptrCast(self.vtable)).GetComboBoxValueAt(@as(*const ICredentialProviderCredential, @ptrCast(self)), dwFieldID, dwItem, ppszItem);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICredentialProviderCredential_SetStringValue(self: *const T, dwFieldID: u32, psz: ?[*:0]const u16) HRESULT {
                return @as(*const ICredentialProviderCredential.VTable, @ptrCast(self.vtable)).SetStringValue(@as(*const ICredentialProviderCredential, @ptrCast(self)), dwFieldID, psz);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICredentialProviderCredential_SetCheckboxValue(self: *const T, dwFieldID: u32, bChecked: BOOL) HRESULT {
                return @as(*const ICredentialProviderCredential.VTable, @ptrCast(self.vtable)).SetCheckboxValue(@as(*const ICredentialProviderCredential, @ptrCast(self)), dwFieldID, bChecked);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICredentialProviderCredential_SetComboBoxSelectedValue(self: *const T, dwFieldID: u32, dwSelectedItem: u32) HRESULT {
                return @as(*const ICredentialProviderCredential.VTable, @ptrCast(self.vtable)).SetComboBoxSelectedValue(@as(*const ICredentialProviderCredential, @ptrCast(self)), dwFieldID, dwSelectedItem);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICredentialProviderCredential_CommandLinkClicked(self: *const T, dwFieldID: u32) HRESULT {
                return @as(*const ICredentialProviderCredential.VTable, @ptrCast(self.vtable)).CommandLinkClicked(@as(*const ICredentialProviderCredential, @ptrCast(self)), dwFieldID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICredentialProviderCredential_GetSerialization(self: *const T, pcpgsr: ?*CREDENTIAL_PROVIDER_GET_SERIALIZATION_RESPONSE, pcpcs: ?*CREDENTIAL_PROVIDER_CREDENTIAL_SERIALIZATION, ppszOptionalStatusText: ?*?PWSTR, pcpsiOptionalStatusIcon: ?*CREDENTIAL_PROVIDER_STATUS_ICON) HRESULT {
                return @as(*const ICredentialProviderCredential.VTable, @ptrCast(self.vtable)).GetSerialization(@as(*const ICredentialProviderCredential, @ptrCast(self)), pcpgsr, pcpcs, ppszOptionalStatusText, pcpsiOptionalStatusIcon);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICredentialProviderCredential_ReportResult(self: *const T, ntsStatus: NTSTATUS, ntsSubstatus: NTSTATUS, ppszOptionalStatusText: ?*?PWSTR, pcpsiOptionalStatusIcon: ?*CREDENTIAL_PROVIDER_STATUS_ICON) HRESULT {
                return @as(*const ICredentialProviderCredential.VTable, @ptrCast(self.vtable)).ReportResult(@as(*const ICredentialProviderCredential, @ptrCast(self)), ntsStatus, ntsSubstatus, ppszOptionalStatusText, pcpsiOptionalStatusIcon);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IQueryContinueWithStatus_Value = Guid.initString("9090be5b-502b-41fb-bccc-0049a6c7254b");
pub const IID_IQueryContinueWithStatus = &IID_IQueryContinueWithStatus_Value;
pub const IQueryContinueWithStatus = extern struct {
    pub const VTable = extern struct {
        base: IQueryContinue.VTable,
        SetStatusMessage: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IQueryContinueWithStatus,
                psz: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IQueryContinueWithStatus,
                psz: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IQueryContinue.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IQueryContinueWithStatus_SetStatusMessage(self: *const T, psz: ?[*:0]const u16) HRESULT {
                return @as(*const IQueryContinueWithStatus.VTable, @ptrCast(self.vtable)).SetStatusMessage(@as(*const IQueryContinueWithStatus, @ptrCast(self)), psz);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IConnectableCredentialProviderCredential_Value = Guid.initString("9387928b-ac75-4bf9-8ab2-2b93c4a55290");
pub const IID_IConnectableCredentialProviderCredential = &IID_IConnectableCredentialProviderCredential_Value;
pub const IConnectableCredentialProviderCredential = extern struct {
    pub const VTable = extern struct {
        base: ICredentialProviderCredential.VTable,
        Connect: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IConnectableCredentialProviderCredential,
                pqcws: ?*IQueryContinueWithStatus,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IConnectableCredentialProviderCredential,
                pqcws: ?*IQueryContinueWithStatus,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Disconnect: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IConnectableCredentialProviderCredential,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IConnectableCredentialProviderCredential,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ICredentialProviderCredential.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IConnectableCredentialProviderCredential_Connect(self: *const T, pqcws: ?*IQueryContinueWithStatus) HRESULT {
                return @as(*const IConnectableCredentialProviderCredential.VTable, @ptrCast(self.vtable)).Connect(@as(*const IConnectableCredentialProviderCredential, @ptrCast(self)), pqcws);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IConnectableCredentialProviderCredential_Disconnect(self: *const T) HRESULT {
                return @as(*const IConnectableCredentialProviderCredential.VTable, @ptrCast(self.vtable)).Disconnect(@as(*const IConnectableCredentialProviderCredential, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ICredentialProviderCredentialEvents_Value = Guid.initString("fa6fa76b-66b7-4b11-95f1-86171118e816");
pub const IID_ICredentialProviderCredentialEvents = &IID_ICredentialProviderCredentialEvents_Value;
pub const ICredentialProviderCredentialEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetFieldState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICredentialProviderCredentialEvents,
                pcpc: ?*ICredentialProviderCredential,
                dwFieldID: u32,
                cpfs: CREDENTIAL_PROVIDER_FIELD_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICredentialProviderCredentialEvents,
                pcpc: ?*ICredentialProviderCredential,
                dwFieldID: u32,
                cpfs: CREDENTIAL_PROVIDER_FIELD_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFieldInteractiveState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICredentialProviderCredentialEvents,
                pcpc: ?*ICredentialProviderCredential,
                dwFieldID: u32,
                cpfis: CREDENTIAL_PROVIDER_FIELD_INTERACTIVE_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICredentialProviderCredentialEvents,
                pcpc: ?*ICredentialProviderCredential,
                dwFieldID: u32,
                cpfis: CREDENTIAL_PROVIDER_FIELD_INTERACTIVE_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFieldString: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICredentialProviderCredentialEvents,
                pcpc: ?*ICredentialProviderCredential,
                dwFieldID: u32,
                psz: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICredentialProviderCredentialEvents,
                pcpc: ?*ICredentialProviderCredential,
                dwFieldID: u32,
                psz: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFieldCheckbox: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICredentialProviderCredentialEvents,
                pcpc: ?*ICredentialProviderCredential,
                dwFieldID: u32,
                bChecked: BOOL,
                pszLabel: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICredentialProviderCredentialEvents,
                pcpc: ?*ICredentialProviderCredential,
                dwFieldID: u32,
                bChecked: BOOL,
                pszLabel: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFieldBitmap: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICredentialProviderCredentialEvents,
                pcpc: ?*ICredentialProviderCredential,
                dwFieldID: u32,
                hbmp: ?HBITMAP,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICredentialProviderCredentialEvents,
                pcpc: ?*ICredentialProviderCredential,
                dwFieldID: u32,
                hbmp: ?HBITMAP,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFieldComboBoxSelectedItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICredentialProviderCredentialEvents,
                pcpc: ?*ICredentialProviderCredential,
                dwFieldID: u32,
                dwSelectedItem: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICredentialProviderCredentialEvents,
                pcpc: ?*ICredentialProviderCredential,
                dwFieldID: u32,
                dwSelectedItem: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeleteFieldComboBoxItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICredentialProviderCredentialEvents,
                pcpc: ?*ICredentialProviderCredential,
                dwFieldID: u32,
                dwItem: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICredentialProviderCredentialEvents,
                pcpc: ?*ICredentialProviderCredential,
                dwFieldID: u32,
                dwItem: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AppendFieldComboBoxItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICredentialProviderCredentialEvents,
                pcpc: ?*ICredentialProviderCredential,
                dwFieldID: u32,
                pszItem: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICredentialProviderCredentialEvents,
                pcpc: ?*ICredentialProviderCredential,
                dwFieldID: u32,
                pszItem: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFieldSubmitButton: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICredentialProviderCredentialEvents,
                pcpc: ?*ICredentialProviderCredential,
                dwFieldID: u32,
                dwAdjacentTo: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICredentialProviderCredentialEvents,
                pcpc: ?*ICredentialProviderCredential,
                dwFieldID: u32,
                dwAdjacentTo: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnCreatingWindow: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICredentialProviderCredentialEvents,
                phwndOwner: ?*?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICredentialProviderCredentialEvents,
                phwndOwner: ?*?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICredentialProviderCredentialEvents_SetFieldState(self: *const T, pcpc: ?*ICredentialProviderCredential, dwFieldID: u32, cpfs: CREDENTIAL_PROVIDER_FIELD_STATE) HRESULT {
                return @as(*const ICredentialProviderCredentialEvents.VTable, @ptrCast(self.vtable)).SetFieldState(@as(*const ICredentialProviderCredentialEvents, @ptrCast(self)), pcpc, dwFieldID, cpfs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICredentialProviderCredentialEvents_SetFieldInteractiveState(self: *const T, pcpc: ?*ICredentialProviderCredential, dwFieldID: u32, cpfis: CREDENTIAL_PROVIDER_FIELD_INTERACTIVE_STATE) HRESULT {
                return @as(*const ICredentialProviderCredentialEvents.VTable, @ptrCast(self.vtable)).SetFieldInteractiveState(@as(*const ICredentialProviderCredentialEvents, @ptrCast(self)), pcpc, dwFieldID, cpfis);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICredentialProviderCredentialEvents_SetFieldString(self: *const T, pcpc: ?*ICredentialProviderCredential, dwFieldID: u32, psz: ?[*:0]const u16) HRESULT {
                return @as(*const ICredentialProviderCredentialEvents.VTable, @ptrCast(self.vtable)).SetFieldString(@as(*const ICredentialProviderCredentialEvents, @ptrCast(self)), pcpc, dwFieldID, psz);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICredentialProviderCredentialEvents_SetFieldCheckbox(self: *const T, pcpc: ?*ICredentialProviderCredential, dwFieldID: u32, bChecked: BOOL, pszLabel: ?[*:0]const u16) HRESULT {
                return @as(*const ICredentialProviderCredentialEvents.VTable, @ptrCast(self.vtable)).SetFieldCheckbox(@as(*const ICredentialProviderCredentialEvents, @ptrCast(self)), pcpc, dwFieldID, bChecked, pszLabel);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICredentialProviderCredentialEvents_SetFieldBitmap(self: *const T, pcpc: ?*ICredentialProviderCredential, dwFieldID: u32, hbmp: ?HBITMAP) HRESULT {
                return @as(*const ICredentialProviderCredentialEvents.VTable, @ptrCast(self.vtable)).SetFieldBitmap(@as(*const ICredentialProviderCredentialEvents, @ptrCast(self)), pcpc, dwFieldID, hbmp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICredentialProviderCredentialEvents_SetFieldComboBoxSelectedItem(self: *const T, pcpc: ?*ICredentialProviderCredential, dwFieldID: u32, dwSelectedItem: u32) HRESULT {
                return @as(*const ICredentialProviderCredentialEvents.VTable, @ptrCast(self.vtable)).SetFieldComboBoxSelectedItem(@as(*const ICredentialProviderCredentialEvents, @ptrCast(self)), pcpc, dwFieldID, dwSelectedItem);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICredentialProviderCredentialEvents_DeleteFieldComboBoxItem(self: *const T, pcpc: ?*ICredentialProviderCredential, dwFieldID: u32, dwItem: u32) HRESULT {
                return @as(*const ICredentialProviderCredentialEvents.VTable, @ptrCast(self.vtable)).DeleteFieldComboBoxItem(@as(*const ICredentialProviderCredentialEvents, @ptrCast(self)), pcpc, dwFieldID, dwItem);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICredentialProviderCredentialEvents_AppendFieldComboBoxItem(self: *const T, pcpc: ?*ICredentialProviderCredential, dwFieldID: u32, pszItem: ?[*:0]const u16) HRESULT {
                return @as(*const ICredentialProviderCredentialEvents.VTable, @ptrCast(self.vtable)).AppendFieldComboBoxItem(@as(*const ICredentialProviderCredentialEvents, @ptrCast(self)), pcpc, dwFieldID, pszItem);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICredentialProviderCredentialEvents_SetFieldSubmitButton(self: *const T, pcpc: ?*ICredentialProviderCredential, dwFieldID: u32, dwAdjacentTo: u32) HRESULT {
                return @as(*const ICredentialProviderCredentialEvents.VTable, @ptrCast(self.vtable)).SetFieldSubmitButton(@as(*const ICredentialProviderCredentialEvents, @ptrCast(self)), pcpc, dwFieldID, dwAdjacentTo);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICredentialProviderCredentialEvents_OnCreatingWindow(self: *const T, phwndOwner: ?*?HWND) HRESULT {
                return @as(*const ICredentialProviderCredentialEvents.VTable, @ptrCast(self.vtable)).OnCreatingWindow(@as(*const ICredentialProviderCredentialEvents, @ptrCast(self)), phwndOwner);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ICredentialProvider_Value = Guid.initString("d27c3481-5a1c-45b2-8aaa-c20ebbe8229e");
pub const IID_ICredentialProvider = &IID_ICredentialProvider_Value;
pub const ICredentialProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetUsageScenario: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICredentialProvider,
                cpus: CREDENTIAL_PROVIDER_USAGE_SCENARIO,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICredentialProvider,
                cpus: CREDENTIAL_PROVIDER_USAGE_SCENARIO,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSerialization: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICredentialProvider,
                pcpcs: ?*const CREDENTIAL_PROVIDER_CREDENTIAL_SERIALIZATION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICredentialProvider,
                pcpcs: ?*const CREDENTIAL_PROVIDER_CREDENTIAL_SERIALIZATION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Advise: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICredentialProvider,
                pcpe: ?*ICredentialProviderEvents,
                upAdviseContext: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICredentialProvider,
                pcpe: ?*ICredentialProviderEvents,
                upAdviseContext: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnAdvise: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICredentialProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICredentialProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFieldDescriptorCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICredentialProvider,
                pdwCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICredentialProvider,
                pdwCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFieldDescriptorAt: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICredentialProvider,
                dwIndex: u32,
                ppcpfd: ?*?*CREDENTIAL_PROVIDER_FIELD_DESCRIPTOR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICredentialProvider,
                dwIndex: u32,
                ppcpfd: ?*?*CREDENTIAL_PROVIDER_FIELD_DESCRIPTOR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCredentialCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICredentialProvider,
                pdwCount: ?*u32,
                pdwDefault: ?*u32,
                pbAutoLogonWithDefault: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICredentialProvider,
                pdwCount: ?*u32,
                pdwDefault: ?*u32,
                pbAutoLogonWithDefault: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCredentialAt: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICredentialProvider,
                dwIndex: u32,
                ppcpc: ?*?*ICredentialProviderCredential,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICredentialProvider,
                dwIndex: u32,
                ppcpc: ?*?*ICredentialProviderCredential,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICredentialProvider_SetUsageScenario(self: *const T, cpus: CREDENTIAL_PROVIDER_USAGE_SCENARIO, dwFlags: u32) HRESULT {
                return @as(*const ICredentialProvider.VTable, @ptrCast(self.vtable)).SetUsageScenario(@as(*const ICredentialProvider, @ptrCast(self)), cpus, dwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICredentialProvider_SetSerialization(self: *const T, pcpcs: ?*const CREDENTIAL_PROVIDER_CREDENTIAL_SERIALIZATION) HRESULT {
                return @as(*const ICredentialProvider.VTable, @ptrCast(self.vtable)).SetSerialization(@as(*const ICredentialProvider, @ptrCast(self)), pcpcs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICredentialProvider_Advise(self: *const T, pcpe: ?*ICredentialProviderEvents, upAdviseContext: usize) HRESULT {
                return @as(*const ICredentialProvider.VTable, @ptrCast(self.vtable)).Advise(@as(*const ICredentialProvider, @ptrCast(self)), pcpe, upAdviseContext);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICredentialProvider_UnAdvise(self: *const T) HRESULT {
                return @as(*const ICredentialProvider.VTable, @ptrCast(self.vtable)).UnAdvise(@as(*const ICredentialProvider, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICredentialProvider_GetFieldDescriptorCount(self: *const T, pdwCount: ?*u32) HRESULT {
                return @as(*const ICredentialProvider.VTable, @ptrCast(self.vtable)).GetFieldDescriptorCount(@as(*const ICredentialProvider, @ptrCast(self)), pdwCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICredentialProvider_GetFieldDescriptorAt(self: *const T, dwIndex: u32, ppcpfd: ?*?*CREDENTIAL_PROVIDER_FIELD_DESCRIPTOR) HRESULT {
                return @as(*const ICredentialProvider.VTable, @ptrCast(self.vtable)).GetFieldDescriptorAt(@as(*const ICredentialProvider, @ptrCast(self)), dwIndex, ppcpfd);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICredentialProvider_GetCredentialCount(self: *const T, pdwCount: ?*u32, pdwDefault: ?*u32, pbAutoLogonWithDefault: ?*BOOL) HRESULT {
                return @as(*const ICredentialProvider.VTable, @ptrCast(self.vtable)).GetCredentialCount(@as(*const ICredentialProvider, @ptrCast(self)), pdwCount, pdwDefault, pbAutoLogonWithDefault);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICredentialProvider_GetCredentialAt(self: *const T, dwIndex: u32, ppcpc: ?*?*ICredentialProviderCredential) HRESULT {
                return @as(*const ICredentialProvider.VTable, @ptrCast(self.vtable)).GetCredentialAt(@as(*const ICredentialProvider, @ptrCast(self)), dwIndex, ppcpc);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ICredentialProviderEvents_Value = Guid.initString("34201e5a-a787-41a3-a5a4-bd6dcf2a854e");
pub const IID_ICredentialProviderEvents = &IID_ICredentialProviderEvents_Value;
pub const ICredentialProviderEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CredentialsChanged: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICredentialProviderEvents,
                upAdviseContext: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICredentialProviderEvents,
                upAdviseContext: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICredentialProviderEvents_CredentialsChanged(self: *const T, upAdviseContext: usize) HRESULT {
                return @as(*const ICredentialProviderEvents.VTable, @ptrCast(self.vtable)).CredentialsChanged(@as(*const ICredentialProviderEvents, @ptrCast(self)), upAdviseContext);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ICredentialProviderFilter_Value = Guid.initString("a5da53f9-d475-4080-a120-910c4a739880");
pub const IID_ICredentialProviderFilter = &IID_ICredentialProviderFilter_Value;
pub const ICredentialProviderFilter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Filter: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICredentialProviderFilter,
                cpus: CREDENTIAL_PROVIDER_USAGE_SCENARIO,
                dwFlags: u32,
                rgclsidProviders: [*]Guid,
                rgbAllow: [*]BOOL,
                cProviders: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICredentialProviderFilter,
                cpus: CREDENTIAL_PROVIDER_USAGE_SCENARIO,
                dwFlags: u32,
                rgclsidProviders: [*]Guid,
                rgbAllow: [*]BOOL,
                cProviders: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UpdateRemoteCredential: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICredentialProviderFilter,
                pcpcsIn: ?*const CREDENTIAL_PROVIDER_CREDENTIAL_SERIALIZATION,
                pcpcsOut: ?*CREDENTIAL_PROVIDER_CREDENTIAL_SERIALIZATION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICredentialProviderFilter,
                pcpcsIn: ?*const CREDENTIAL_PROVIDER_CREDENTIAL_SERIALIZATION,
                pcpcsOut: ?*CREDENTIAL_PROVIDER_CREDENTIAL_SERIALIZATION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICredentialProviderFilter_Filter(self: *const T, cpus: CREDENTIAL_PROVIDER_USAGE_SCENARIO, dwFlags: u32, rgclsidProviders: [*]Guid, rgbAllow: [*]BOOL, cProviders: u32) HRESULT {
                return @as(*const ICredentialProviderFilter.VTable, @ptrCast(self.vtable)).Filter(@as(*const ICredentialProviderFilter, @ptrCast(self)), cpus, dwFlags, rgclsidProviders, rgbAllow, cProviders);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICredentialProviderFilter_UpdateRemoteCredential(self: *const T, pcpcsIn: ?*const CREDENTIAL_PROVIDER_CREDENTIAL_SERIALIZATION, pcpcsOut: ?*CREDENTIAL_PROVIDER_CREDENTIAL_SERIALIZATION) HRESULT {
                return @as(*const ICredentialProviderFilter.VTable, @ptrCast(self.vtable)).UpdateRemoteCredential(@as(*const ICredentialProviderFilter, @ptrCast(self)), pcpcsIn, pcpcsOut);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ICredentialProviderCredential2_Value = Guid.initString("fd672c54-40ea-4d6e-9b49-cfb1a7507bd7");
pub const IID_ICredentialProviderCredential2 = &IID_ICredentialProviderCredential2_Value;
pub const ICredentialProviderCredential2 = extern struct {
    pub const VTable = extern struct {
        base: ICredentialProviderCredential.VTable,
        GetUserSid: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICredentialProviderCredential2,
                sid: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICredentialProviderCredential2,
                sid: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ICredentialProviderCredential.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICredentialProviderCredential2_GetUserSid(self: *const T, sid: ?*?PWSTR) HRESULT {
                return @as(*const ICredentialProviderCredential2.VTable, @ptrCast(self.vtable)).GetUserSid(@as(*const ICredentialProviderCredential2, @ptrCast(self)), sid);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ICredentialProviderCredentialWithFieldOptions_Value = Guid.initString("dbc6fb30-c843-49e3-a645-573e6f39446a");
pub const IID_ICredentialProviderCredentialWithFieldOptions = &IID_ICredentialProviderCredentialWithFieldOptions_Value;
pub const ICredentialProviderCredentialWithFieldOptions = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetFieldOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICredentialProviderCredentialWithFieldOptions,
                fieldID: u32,
                options: ?*CREDENTIAL_PROVIDER_CREDENTIAL_FIELD_OPTIONS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICredentialProviderCredentialWithFieldOptions,
                fieldID: u32,
                options: ?*CREDENTIAL_PROVIDER_CREDENTIAL_FIELD_OPTIONS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICredentialProviderCredentialWithFieldOptions_GetFieldOptions(self: *const T, fieldID: u32, options: ?*CREDENTIAL_PROVIDER_CREDENTIAL_FIELD_OPTIONS) HRESULT {
                return @as(*const ICredentialProviderCredentialWithFieldOptions.VTable, @ptrCast(self.vtable)).GetFieldOptions(@as(*const ICredentialProviderCredentialWithFieldOptions, @ptrCast(self)), fieldID, options);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ICredentialProviderCredentialEvents2_Value = Guid.initString("b53c00b6-9922-4b78-b1f4-ddfe774dc39b");
pub const IID_ICredentialProviderCredentialEvents2 = &IID_ICredentialProviderCredentialEvents2_Value;
pub const ICredentialProviderCredentialEvents2 = extern struct {
    pub const VTable = extern struct {
        base: ICredentialProviderCredentialEvents.VTable,
        BeginFieldUpdates: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICredentialProviderCredentialEvents2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICredentialProviderCredentialEvents2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndFieldUpdates: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICredentialProviderCredentialEvents2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICredentialProviderCredentialEvents2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFieldOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICredentialProviderCredentialEvents2,
                credential: ?*ICredentialProviderCredential,
                fieldID: u32,
                options: CREDENTIAL_PROVIDER_CREDENTIAL_FIELD_OPTIONS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICredentialProviderCredentialEvents2,
                credential: ?*ICredentialProviderCredential,
                fieldID: u32,
                options: CREDENTIAL_PROVIDER_CREDENTIAL_FIELD_OPTIONS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ICredentialProviderCredentialEvents.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICredentialProviderCredentialEvents2_BeginFieldUpdates(self: *const T) HRESULT {
                return @as(*const ICredentialProviderCredentialEvents2.VTable, @ptrCast(self.vtable)).BeginFieldUpdates(@as(*const ICredentialProviderCredentialEvents2, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICredentialProviderCredentialEvents2_EndFieldUpdates(self: *const T) HRESULT {
                return @as(*const ICredentialProviderCredentialEvents2.VTable, @ptrCast(self.vtable)).EndFieldUpdates(@as(*const ICredentialProviderCredentialEvents2, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICredentialProviderCredentialEvents2_SetFieldOptions(self: *const T, credential: ?*ICredentialProviderCredential, fieldID: u32, options: CREDENTIAL_PROVIDER_CREDENTIAL_FIELD_OPTIONS) HRESULT {
                return @as(*const ICredentialProviderCredentialEvents2.VTable, @ptrCast(self.vtable)).SetFieldOptions(@as(*const ICredentialProviderCredentialEvents2, @ptrCast(self)), credential, fieldID, options);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ICredentialProviderUser_Value = Guid.initString("13793285-3ea6-40fd-b420-15f47da41fbb");
pub const IID_ICredentialProviderUser = &IID_ICredentialProviderUser_Value;
pub const ICredentialProviderUser = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSid: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICredentialProviderUser,
                sid: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICredentialProviderUser,
                sid: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProviderID: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICredentialProviderUser,
                providerID: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICredentialProviderUser,
                providerID: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStringValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICredentialProviderUser,
                key: ?*const PROPERTYKEY,
                stringValue: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICredentialProviderUser,
                key: ?*const PROPERTYKEY,
                stringValue: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICredentialProviderUser,
                key: ?*const PROPERTYKEY,
                value: ?*PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICredentialProviderUser,
                key: ?*const PROPERTYKEY,
                value: ?*PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICredentialProviderUser_GetSid(self: *const T, sid: ?*?PWSTR) HRESULT {
                return @as(*const ICredentialProviderUser.VTable, @ptrCast(self.vtable)).GetSid(@as(*const ICredentialProviderUser, @ptrCast(self)), sid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICredentialProviderUser_GetProviderID(self: *const T, providerID: ?*Guid) HRESULT {
                return @as(*const ICredentialProviderUser.VTable, @ptrCast(self.vtable)).GetProviderID(@as(*const ICredentialProviderUser, @ptrCast(self)), providerID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICredentialProviderUser_GetStringValue(self: *const T, key: ?*const PROPERTYKEY, stringValue: ?*?PWSTR) HRESULT {
                return @as(*const ICredentialProviderUser.VTable, @ptrCast(self.vtable)).GetStringValue(@as(*const ICredentialProviderUser, @ptrCast(self)), key, stringValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICredentialProviderUser_GetValue(self: *const T, key: ?*const PROPERTYKEY, value: ?*PROPVARIANT) HRESULT {
                return @as(*const ICredentialProviderUser.VTable, @ptrCast(self.vtable)).GetValue(@as(*const ICredentialProviderUser, @ptrCast(self)), key, value);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ICredentialProviderUserArray_Value = Guid.initString("90c119ae-0f18-4520-a1f1-114366a40fe8");
pub const IID_ICredentialProviderUserArray = &IID_ICredentialProviderUserArray_Value;
pub const ICredentialProviderUserArray = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetProviderFilter: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICredentialProviderUserArray,
                guidProviderToFilterTo: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICredentialProviderUserArray,
                guidProviderToFilterTo: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAccountOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICredentialProviderUserArray,
                credentialProviderAccountOptions: ?*CREDENTIAL_PROVIDER_ACCOUNT_OPTIONS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICredentialProviderUserArray,
                credentialProviderAccountOptions: ?*CREDENTIAL_PROVIDER_ACCOUNT_OPTIONS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICredentialProviderUserArray,
                userCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICredentialProviderUserArray,
                userCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAt: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICredentialProviderUserArray,
                userIndex: u32,
                user: ?*?*ICredentialProviderUser,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICredentialProviderUserArray,
                userIndex: u32,
                user: ?*?*ICredentialProviderUser,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICredentialProviderUserArray_SetProviderFilter(self: *const T, guidProviderToFilterTo: ?*const Guid) HRESULT {
                return @as(*const ICredentialProviderUserArray.VTable, @ptrCast(self.vtable)).SetProviderFilter(@as(*const ICredentialProviderUserArray, @ptrCast(self)), guidProviderToFilterTo);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICredentialProviderUserArray_GetAccountOptions(self: *const T, credentialProviderAccountOptions: ?*CREDENTIAL_PROVIDER_ACCOUNT_OPTIONS) HRESULT {
                return @as(*const ICredentialProviderUserArray.VTable, @ptrCast(self.vtable)).GetAccountOptions(@as(*const ICredentialProviderUserArray, @ptrCast(self)), credentialProviderAccountOptions);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICredentialProviderUserArray_GetCount(self: *const T, userCount: ?*u32) HRESULT {
                return @as(*const ICredentialProviderUserArray.VTable, @ptrCast(self.vtable)).GetCount(@as(*const ICredentialProviderUserArray, @ptrCast(self)), userCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICredentialProviderUserArray_GetAt(self: *const T, userIndex: u32, user: ?*?*ICredentialProviderUser) HRESULT {
                return @as(*const ICredentialProviderUserArray.VTable, @ptrCast(self.vtable)).GetAt(@as(*const ICredentialProviderUserArray, @ptrCast(self)), userIndex, user);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ICredentialProviderSetUserArray_Value = Guid.initString("095c1484-1c0c-4388-9c6d-500e61bf84bd");
pub const IID_ICredentialProviderSetUserArray = &IID_ICredentialProviderSetUserArray_Value;
pub const ICredentialProviderSetUserArray = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetUserArray: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICredentialProviderSetUserArray,
                users: ?*ICredentialProviderUserArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICredentialProviderSetUserArray,
                users: ?*ICredentialProviderUserArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICredentialProviderSetUserArray_SetUserArray(self: *const T, users: ?*ICredentialProviderUserArray) HRESULT {
                return @as(*const ICredentialProviderSetUserArray.VTable, @ptrCast(self.vtable)).SetUserArray(@as(*const ICredentialProviderSetUserArray, @ptrCast(self)), users);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const CLSID_SyncMgrClient_Value = Guid.initString("1202db60-1dac-42c5-aed5-1abdd432248e");
pub const CLSID_SyncMgrClient = &CLSID_SyncMgrClient_Value;

const CLSID_SyncMgrControl_Value = Guid.initString("1a1f4206-0688-4e7f-be03-d82ec69df9a5");
pub const CLSID_SyncMgrControl = &CLSID_SyncMgrControl_Value;

const CLSID_SyncMgrScheduleWizard_Value = Guid.initString("8d8b8e30-c451-421b-8553-d2976afa648c");
pub const CLSID_SyncMgrScheduleWizard = &CLSID_SyncMgrScheduleWizard_Value;

const CLSID_SyncMgrFolder_Value = Guid.initString("9c73f5e5-7ae7-4e32-a8e8-8d23b85255bf");
pub const CLSID_SyncMgrFolder = &CLSID_SyncMgrFolder_Value;

const CLSID_SyncSetupFolder_Value = Guid.initString("2e9e59c0-b437-4981-a647-9c34b9b90891");
pub const CLSID_SyncSetupFolder = &CLSID_SyncSetupFolder_Value;

const CLSID_ConflictFolder_Value = Guid.initString("289978ac-a101-4341-a817-21eba7fd046d");
pub const CLSID_ConflictFolder = &CLSID_ConflictFolder_Value;

const CLSID_SyncResultsFolder_Value = Guid.initString("71d99464-3b6b-475c-b241-e15883207529");
pub const CLSID_SyncResultsFolder = &CLSID_SyncResultsFolder_Value;

const CLSID_SimpleConflictPresenter_Value = Guid.initString("7a0f6ab7-ed84-46b6-b47e-02aa159a152b");
pub const CLSID_SimpleConflictPresenter = &CLSID_SimpleConflictPresenter_Value;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ISyncMgrHandlerCollection_Value = Guid.initString("a7f337a3-d20b-45cb-9ed7-87d094ca5045");
pub const IID_ISyncMgrHandlerCollection = &IID_ISyncMgrHandlerCollection_Value;
pub const ISyncMgrHandlerCollection = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetHandlerEnumerator: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrHandlerCollection,
                ppenum: ?*?*IEnumString,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrHandlerCollection,
                ppenum: ?*?*IEnumString,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BindToHandler: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrHandlerCollection,
                pszHandlerID: ?[*:0]const u16,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrHandlerCollection,
                pszHandlerID: ?[*:0]const u16,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrHandlerCollection_GetHandlerEnumerator(self: *const T, ppenum: ?*?*IEnumString) HRESULT {
                return @as(*const ISyncMgrHandlerCollection.VTable, @ptrCast(self.vtable)).GetHandlerEnumerator(@as(*const ISyncMgrHandlerCollection, @ptrCast(self)), ppenum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrHandlerCollection_BindToHandler(self: *const T, pszHandlerID: ?[*:0]const u16, riid: ?*const Guid, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const ISyncMgrHandlerCollection.VTable, @ptrCast(self.vtable)).BindToHandler(@as(*const ISyncMgrHandlerCollection, @ptrCast(self)), pszHandlerID, riid, ppv);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SYNCMGR_HANDLER_CAPABILITIES = enum(i32) {
    NONE = 0,
    PROVIDES_ICON = 1,
    EVENT_STORE = 2,
    CONFLICT_STORE = 4,
    SUPPORTS_CONCURRENT_SESSIONS = 16,
    CAN_BROWSE_CONTENT = 65536,
    CAN_SHOW_SCHEDULE = 131072,
    QUERY_BEFORE_ACTIVATE = 1048576,
    QUERY_BEFORE_DEACTIVATE = 2097152,
    QUERY_BEFORE_ENABLE = 4194304,
    QUERY_BEFORE_DISABLE = 8388608,
    VALID_MASK = 15925271,
};
pub const SYNCMGR_HCM_NONE = SYNCMGR_HANDLER_CAPABILITIES.NONE;
pub const SYNCMGR_HCM_PROVIDES_ICON = SYNCMGR_HANDLER_CAPABILITIES.PROVIDES_ICON;
pub const SYNCMGR_HCM_EVENT_STORE = SYNCMGR_HANDLER_CAPABILITIES.EVENT_STORE;
pub const SYNCMGR_HCM_CONFLICT_STORE = SYNCMGR_HANDLER_CAPABILITIES.CONFLICT_STORE;
pub const SYNCMGR_HCM_SUPPORTS_CONCURRENT_SESSIONS = SYNCMGR_HANDLER_CAPABILITIES.SUPPORTS_CONCURRENT_SESSIONS;
pub const SYNCMGR_HCM_CAN_BROWSE_CONTENT = SYNCMGR_HANDLER_CAPABILITIES.CAN_BROWSE_CONTENT;
pub const SYNCMGR_HCM_CAN_SHOW_SCHEDULE = SYNCMGR_HANDLER_CAPABILITIES.CAN_SHOW_SCHEDULE;
pub const SYNCMGR_HCM_QUERY_BEFORE_ACTIVATE = SYNCMGR_HANDLER_CAPABILITIES.QUERY_BEFORE_ACTIVATE;
pub const SYNCMGR_HCM_QUERY_BEFORE_DEACTIVATE = SYNCMGR_HANDLER_CAPABILITIES.QUERY_BEFORE_DEACTIVATE;
pub const SYNCMGR_HCM_QUERY_BEFORE_ENABLE = SYNCMGR_HANDLER_CAPABILITIES.QUERY_BEFORE_ENABLE;
pub const SYNCMGR_HCM_QUERY_BEFORE_DISABLE = SYNCMGR_HANDLER_CAPABILITIES.QUERY_BEFORE_DISABLE;
pub const SYNCMGR_HCM_VALID_MASK = SYNCMGR_HANDLER_CAPABILITIES.VALID_MASK;

pub const SYNCMGR_HANDLER_POLICIES = enum(i32) {
    NONE = 0,
    PREVENT_ACTIVATE = 1,
    PREVENT_DEACTIVATE = 2,
    PREVENT_ENABLE = 4,
    PREVENT_DISABLE = 8,
    PREVENT_START_SYNC = 16,
    PREVENT_STOP_SYNC = 32,
    DISABLE_ENABLE = 256,
    DISABLE_DISABLE = 512,
    DISABLE_START_SYNC = 1024,
    DISABLE_STOP_SYNC = 2048,
    DISABLE_BROWSE = 4096,
    DISABLE_SCHEDULE = 8192,
    HIDDEN_BY_DEFAULT = 65536,
    BACKGROUND_SYNC_ONLY = 48,
    VALID_MASK = 77631,
};
pub const SYNCMGR_HPM_NONE = SYNCMGR_HANDLER_POLICIES.NONE;
pub const SYNCMGR_HPM_PREVENT_ACTIVATE = SYNCMGR_HANDLER_POLICIES.PREVENT_ACTIVATE;
pub const SYNCMGR_HPM_PREVENT_DEACTIVATE = SYNCMGR_HANDLER_POLICIES.PREVENT_DEACTIVATE;
pub const SYNCMGR_HPM_PREVENT_ENABLE = SYNCMGR_HANDLER_POLICIES.PREVENT_ENABLE;
pub const SYNCMGR_HPM_PREVENT_DISABLE = SYNCMGR_HANDLER_POLICIES.PREVENT_DISABLE;
pub const SYNCMGR_HPM_PREVENT_START_SYNC = SYNCMGR_HANDLER_POLICIES.PREVENT_START_SYNC;
pub const SYNCMGR_HPM_PREVENT_STOP_SYNC = SYNCMGR_HANDLER_POLICIES.PREVENT_STOP_SYNC;
pub const SYNCMGR_HPM_DISABLE_ENABLE = SYNCMGR_HANDLER_POLICIES.DISABLE_ENABLE;
pub const SYNCMGR_HPM_DISABLE_DISABLE = SYNCMGR_HANDLER_POLICIES.DISABLE_DISABLE;
pub const SYNCMGR_HPM_DISABLE_START_SYNC = SYNCMGR_HANDLER_POLICIES.DISABLE_START_SYNC;
pub const SYNCMGR_HPM_DISABLE_STOP_SYNC = SYNCMGR_HANDLER_POLICIES.DISABLE_STOP_SYNC;
pub const SYNCMGR_HPM_DISABLE_BROWSE = SYNCMGR_HANDLER_POLICIES.DISABLE_BROWSE;
pub const SYNCMGR_HPM_DISABLE_SCHEDULE = SYNCMGR_HANDLER_POLICIES.DISABLE_SCHEDULE;
pub const SYNCMGR_HPM_HIDDEN_BY_DEFAULT = SYNCMGR_HANDLER_POLICIES.HIDDEN_BY_DEFAULT;
pub const SYNCMGR_HPM_BACKGROUND_SYNC_ONLY = SYNCMGR_HANDLER_POLICIES.BACKGROUND_SYNC_ONLY;
pub const SYNCMGR_HPM_VALID_MASK = SYNCMGR_HANDLER_POLICIES.VALID_MASK;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ISyncMgrHandler_Value = Guid.initString("04ec2e43-ac77-49f9-9b98-0307ef7a72a2");
pub const IID_ISyncMgrHandler = &IID_ISyncMgrHandler_Value;
pub const ISyncMgrHandler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrHandler,
                ppszName: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrHandler,
                ppszName: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetHandlerInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrHandler,
                ppHandlerInfo: ?*?*ISyncMgrHandlerInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrHandler,
                ppHandlerInfo: ?*?*ISyncMgrHandlerInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrHandler,
                rguidObjectID: ?*const Guid,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrHandler,
                rguidObjectID: ?*const Guid,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCapabilities: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrHandler,
                pmCapabilities: ?*SYNCMGR_HANDLER_CAPABILITIES,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrHandler,
                pmCapabilities: ?*SYNCMGR_HANDLER_CAPABILITIES,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPolicies: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrHandler,
                pmPolicies: ?*SYNCMGR_HANDLER_POLICIES,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrHandler,
                pmPolicies: ?*SYNCMGR_HANDLER_POLICIES,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Activate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrHandler,
                fActivate: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrHandler,
                fActivate: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Enable: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrHandler,
                fEnable: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrHandler,
                fEnable: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Synchronize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrHandler,
                ppszItemIDs: [*]?PWSTR,
                cItems: u32,
                hwndOwner: ?HWND,
                pSessionCreator: ?*ISyncMgrSessionCreator,
                punk: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrHandler,
                ppszItemIDs: [*]?PWSTR,
                cItems: u32,
                hwndOwner: ?HWND,
                pSessionCreator: ?*ISyncMgrSessionCreator,
                punk: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrHandler_GetName(self: *const T, ppszName: ?*?PWSTR) HRESULT {
                return @as(*const ISyncMgrHandler.VTable, @ptrCast(self.vtable)).GetName(@as(*const ISyncMgrHandler, @ptrCast(self)), ppszName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrHandler_GetHandlerInfo(self: *const T, ppHandlerInfo: ?*?*ISyncMgrHandlerInfo) HRESULT {
                return @as(*const ISyncMgrHandler.VTable, @ptrCast(self.vtable)).GetHandlerInfo(@as(*const ISyncMgrHandler, @ptrCast(self)), ppHandlerInfo);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrHandler_GetObject(self: *const T, rguidObjectID: ?*const Guid, riid: ?*const Guid, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const ISyncMgrHandler.VTable, @ptrCast(self.vtable)).GetObject(@as(*const ISyncMgrHandler, @ptrCast(self)), rguidObjectID, riid, ppv);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrHandler_GetCapabilities(self: *const T, pmCapabilities: ?*SYNCMGR_HANDLER_CAPABILITIES) HRESULT {
                return @as(*const ISyncMgrHandler.VTable, @ptrCast(self.vtable)).GetCapabilities(@as(*const ISyncMgrHandler, @ptrCast(self)), pmCapabilities);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrHandler_GetPolicies(self: *const T, pmPolicies: ?*SYNCMGR_HANDLER_POLICIES) HRESULT {
                return @as(*const ISyncMgrHandler.VTable, @ptrCast(self.vtable)).GetPolicies(@as(*const ISyncMgrHandler, @ptrCast(self)), pmPolicies);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrHandler_Activate(self: *const T, fActivate: BOOL) HRESULT {
                return @as(*const ISyncMgrHandler.VTable, @ptrCast(self.vtable)).Activate(@as(*const ISyncMgrHandler, @ptrCast(self)), fActivate);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrHandler_Enable(self: *const T, fEnable: BOOL) HRESULT {
                return @as(*const ISyncMgrHandler.VTable, @ptrCast(self.vtable)).Enable(@as(*const ISyncMgrHandler, @ptrCast(self)), fEnable);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrHandler_Synchronize(self: *const T, ppszItemIDs: [*]?PWSTR, cItems: u32, hwndOwner: ?HWND, pSessionCreator: ?*ISyncMgrSessionCreator, punk: ?*IUnknown) HRESULT {
                return @as(*const ISyncMgrHandler.VTable, @ptrCast(self.vtable)).Synchronize(@as(*const ISyncMgrHandler, @ptrCast(self)), ppszItemIDs, cItems, hwndOwner, pSessionCreator, punk);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SYNCMGR_HANDLER_TYPE = enum(i32) {
    UNSPECIFIED = 0,
    APPLICATION = 1,
    DEVICE = 2,
    FOLDER = 3,
    SERVICE = 4,
    COMPUTER = 5,
    // MIN = 0, this enum value conflicts with UNSPECIFIED
    // MAX = 5, this enum value conflicts with COMPUTER
};
pub const SYNCMGR_HT_UNSPECIFIED = SYNCMGR_HANDLER_TYPE.UNSPECIFIED;
pub const SYNCMGR_HT_APPLICATION = SYNCMGR_HANDLER_TYPE.APPLICATION;
pub const SYNCMGR_HT_DEVICE = SYNCMGR_HANDLER_TYPE.DEVICE;
pub const SYNCMGR_HT_FOLDER = SYNCMGR_HANDLER_TYPE.FOLDER;
pub const SYNCMGR_HT_SERVICE = SYNCMGR_HANDLER_TYPE.SERVICE;
pub const SYNCMGR_HT_COMPUTER = SYNCMGR_HANDLER_TYPE.COMPUTER;
pub const SYNCMGR_HT_MIN = SYNCMGR_HANDLER_TYPE.UNSPECIFIED;
pub const SYNCMGR_HT_MAX = SYNCMGR_HANDLER_TYPE.COMPUTER;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ISyncMgrHandlerInfo_Value = Guid.initString("4ff1d798-ecf7-4524-aa81-1e362a0aef3a");
pub const IID_ISyncMgrHandlerInfo = &IID_ISyncMgrHandlerInfo_Value;
pub const ISyncMgrHandlerInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrHandlerInfo,
                pnType: ?*SYNCMGR_HANDLER_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrHandlerInfo,
                pnType: ?*SYNCMGR_HANDLER_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTypeLabel: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrHandlerInfo,
                ppszTypeLabel: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrHandlerInfo,
                ppszTypeLabel: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetComment: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrHandlerInfo,
                ppszComment: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrHandlerInfo,
                ppszComment: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLastSyncTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrHandlerInfo,
                pftLastSync: ?*FILETIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrHandlerInfo,
                pftLastSync: ?*FILETIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsActive: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrHandlerInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrHandlerInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsEnabled: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrHandlerInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrHandlerInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsConnected: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrHandlerInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrHandlerInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrHandlerInfo_GetType(self: *const T, pnType: ?*SYNCMGR_HANDLER_TYPE) HRESULT {
                return @as(*const ISyncMgrHandlerInfo.VTable, @ptrCast(self.vtable)).GetType(@as(*const ISyncMgrHandlerInfo, @ptrCast(self)), pnType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrHandlerInfo_GetTypeLabel(self: *const T, ppszTypeLabel: ?*?PWSTR) HRESULT {
                return @as(*const ISyncMgrHandlerInfo.VTable, @ptrCast(self.vtable)).GetTypeLabel(@as(*const ISyncMgrHandlerInfo, @ptrCast(self)), ppszTypeLabel);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrHandlerInfo_GetComment(self: *const T, ppszComment: ?*?PWSTR) HRESULT {
                return @as(*const ISyncMgrHandlerInfo.VTable, @ptrCast(self.vtable)).GetComment(@as(*const ISyncMgrHandlerInfo, @ptrCast(self)), ppszComment);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrHandlerInfo_GetLastSyncTime(self: *const T, pftLastSync: ?*FILETIME) HRESULT {
                return @as(*const ISyncMgrHandlerInfo.VTable, @ptrCast(self.vtable)).GetLastSyncTime(@as(*const ISyncMgrHandlerInfo, @ptrCast(self)), pftLastSync);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrHandlerInfo_IsActive(self: *const T) HRESULT {
                return @as(*const ISyncMgrHandlerInfo.VTable, @ptrCast(self.vtable)).IsActive(@as(*const ISyncMgrHandlerInfo, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrHandlerInfo_IsEnabled(self: *const T) HRESULT {
                return @as(*const ISyncMgrHandlerInfo.VTable, @ptrCast(self.vtable)).IsEnabled(@as(*const ISyncMgrHandlerInfo, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrHandlerInfo_IsConnected(self: *const T) HRESULT {
                return @as(*const ISyncMgrHandlerInfo.VTable, @ptrCast(self.vtable)).IsConnected(@as(*const ISyncMgrHandlerInfo, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ISyncMgrSyncItemContainer_Value = Guid.initString("90701133-be32-4129-a65c-99e616cafff4");
pub const IID_ISyncMgrSyncItemContainer = &IID_ISyncMgrSyncItemContainer_Value;
pub const ISyncMgrSyncItemContainer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSyncItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrSyncItemContainer,
                pszItemID: ?[*:0]const u16,
                ppItem: ?*?*ISyncMgrSyncItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrSyncItemContainer,
                pszItemID: ?[*:0]const u16,
                ppItem: ?*?*ISyncMgrSyncItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSyncItemEnumerator: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrSyncItemContainer,
                ppenum: ?*?*IEnumSyncMgrSyncItems,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrSyncItemContainer,
                ppenum: ?*?*IEnumSyncMgrSyncItems,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSyncItemCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrSyncItemContainer,
                pcItems: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrSyncItemContainer,
                pcItems: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrSyncItemContainer_GetSyncItem(self: *const T, pszItemID: ?[*:0]const u16, ppItem: ?*?*ISyncMgrSyncItem) HRESULT {
                return @as(*const ISyncMgrSyncItemContainer.VTable, @ptrCast(self.vtable)).GetSyncItem(@as(*const ISyncMgrSyncItemContainer, @ptrCast(self)), pszItemID, ppItem);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrSyncItemContainer_GetSyncItemEnumerator(self: *const T, ppenum: ?*?*IEnumSyncMgrSyncItems) HRESULT {
                return @as(*const ISyncMgrSyncItemContainer.VTable, @ptrCast(self.vtable)).GetSyncItemEnumerator(@as(*const ISyncMgrSyncItemContainer, @ptrCast(self)), ppenum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrSyncItemContainer_GetSyncItemCount(self: *const T, pcItems: ?*u32) HRESULT {
                return @as(*const ISyncMgrSyncItemContainer.VTable, @ptrCast(self.vtable)).GetSyncItemCount(@as(*const ISyncMgrSyncItemContainer, @ptrCast(self)), pcItems);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SYNCMGR_ITEM_CAPABILITIES = enum(i32) {
    NONE = 0,
    PROVIDES_ICON = 1,
    EVENT_STORE = 2,
    CONFLICT_STORE = 4,
    CAN_DELETE = 16,
    CAN_BROWSE_CONTENT = 65536,
    QUERY_BEFORE_ENABLE = 1048576,
    QUERY_BEFORE_DISABLE = 2097152,
    QUERY_BEFORE_DELETE = 4194304,
    VALID_MASK = 7405591,
};
pub const SYNCMGR_ICM_NONE = SYNCMGR_ITEM_CAPABILITIES.NONE;
pub const SYNCMGR_ICM_PROVIDES_ICON = SYNCMGR_ITEM_CAPABILITIES.PROVIDES_ICON;
pub const SYNCMGR_ICM_EVENT_STORE = SYNCMGR_ITEM_CAPABILITIES.EVENT_STORE;
pub const SYNCMGR_ICM_CONFLICT_STORE = SYNCMGR_ITEM_CAPABILITIES.CONFLICT_STORE;
pub const SYNCMGR_ICM_CAN_DELETE = SYNCMGR_ITEM_CAPABILITIES.CAN_DELETE;
pub const SYNCMGR_ICM_CAN_BROWSE_CONTENT = SYNCMGR_ITEM_CAPABILITIES.CAN_BROWSE_CONTENT;
pub const SYNCMGR_ICM_QUERY_BEFORE_ENABLE = SYNCMGR_ITEM_CAPABILITIES.QUERY_BEFORE_ENABLE;
pub const SYNCMGR_ICM_QUERY_BEFORE_DISABLE = SYNCMGR_ITEM_CAPABILITIES.QUERY_BEFORE_DISABLE;
pub const SYNCMGR_ICM_QUERY_BEFORE_DELETE = SYNCMGR_ITEM_CAPABILITIES.QUERY_BEFORE_DELETE;
pub const SYNCMGR_ICM_VALID_MASK = SYNCMGR_ITEM_CAPABILITIES.VALID_MASK;

pub const SYNCMGR_ITEM_POLICIES = enum(i32) {
    NONE = 0,
    PREVENT_ENABLE = 1,
    PREVENT_DISABLE = 2,
    PREVENT_START_SYNC = 4,
    PREVENT_STOP_SYNC = 8,
    DISABLE_ENABLE = 16,
    DISABLE_DISABLE = 32,
    DISABLE_START_SYNC = 64,
    DISABLE_STOP_SYNC = 128,
    DISABLE_BROWSE = 256,
    DISABLE_DELETE = 512,
    HIDDEN_BY_DEFAULT = 65536,
    VALID_MASK = 66303,
};
pub const SYNCMGR_IPM_NONE = SYNCMGR_ITEM_POLICIES.NONE;
pub const SYNCMGR_IPM_PREVENT_ENABLE = SYNCMGR_ITEM_POLICIES.PREVENT_ENABLE;
pub const SYNCMGR_IPM_PREVENT_DISABLE = SYNCMGR_ITEM_POLICIES.PREVENT_DISABLE;
pub const SYNCMGR_IPM_PREVENT_START_SYNC = SYNCMGR_ITEM_POLICIES.PREVENT_START_SYNC;
pub const SYNCMGR_IPM_PREVENT_STOP_SYNC = SYNCMGR_ITEM_POLICIES.PREVENT_STOP_SYNC;
pub const SYNCMGR_IPM_DISABLE_ENABLE = SYNCMGR_ITEM_POLICIES.DISABLE_ENABLE;
pub const SYNCMGR_IPM_DISABLE_DISABLE = SYNCMGR_ITEM_POLICIES.DISABLE_DISABLE;
pub const SYNCMGR_IPM_DISABLE_START_SYNC = SYNCMGR_ITEM_POLICIES.DISABLE_START_SYNC;
pub const SYNCMGR_IPM_DISABLE_STOP_SYNC = SYNCMGR_ITEM_POLICIES.DISABLE_STOP_SYNC;
pub const SYNCMGR_IPM_DISABLE_BROWSE = SYNCMGR_ITEM_POLICIES.DISABLE_BROWSE;
pub const SYNCMGR_IPM_DISABLE_DELETE = SYNCMGR_ITEM_POLICIES.DISABLE_DELETE;
pub const SYNCMGR_IPM_HIDDEN_BY_DEFAULT = SYNCMGR_ITEM_POLICIES.HIDDEN_BY_DEFAULT;
pub const SYNCMGR_IPM_VALID_MASK = SYNCMGR_ITEM_POLICIES.VALID_MASK;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ISyncMgrSyncItem_Value = Guid.initString("b20b24ce-2593-4f04-bd8b-7ad6c45051cd");
pub const IID_ISyncMgrSyncItem = &IID_ISyncMgrSyncItem_Value;
pub const ISyncMgrSyncItem = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetItemID: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrSyncItem,
                ppszItemID: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrSyncItem,
                ppszItemID: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrSyncItem,
                ppszName: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrSyncItem,
                ppszName: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetItemInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrSyncItem,
                ppItemInfo: ?*?*ISyncMgrSyncItemInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrSyncItem,
                ppItemInfo: ?*?*ISyncMgrSyncItemInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrSyncItem,
                rguidObjectID: ?*const Guid,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrSyncItem,
                rguidObjectID: ?*const Guid,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCapabilities: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrSyncItem,
                pmCapabilities: ?*SYNCMGR_ITEM_CAPABILITIES,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrSyncItem,
                pmCapabilities: ?*SYNCMGR_ITEM_CAPABILITIES,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPolicies: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrSyncItem,
                pmPolicies: ?*SYNCMGR_ITEM_POLICIES,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrSyncItem,
                pmPolicies: ?*SYNCMGR_ITEM_POLICIES,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Enable: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrSyncItem,
                fEnable: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrSyncItem,
                fEnable: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Delete: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrSyncItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrSyncItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrSyncItem_GetItemID(self: *const T, ppszItemID: ?*?PWSTR) HRESULT {
                return @as(*const ISyncMgrSyncItem.VTable, @ptrCast(self.vtable)).GetItemID(@as(*const ISyncMgrSyncItem, @ptrCast(self)), ppszItemID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrSyncItem_GetName(self: *const T, ppszName: ?*?PWSTR) HRESULT {
                return @as(*const ISyncMgrSyncItem.VTable, @ptrCast(self.vtable)).GetName(@as(*const ISyncMgrSyncItem, @ptrCast(self)), ppszName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrSyncItem_GetItemInfo(self: *const T, ppItemInfo: ?*?*ISyncMgrSyncItemInfo) HRESULT {
                return @as(*const ISyncMgrSyncItem.VTable, @ptrCast(self.vtable)).GetItemInfo(@as(*const ISyncMgrSyncItem, @ptrCast(self)), ppItemInfo);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrSyncItem_GetObject(self: *const T, rguidObjectID: ?*const Guid, riid: ?*const Guid, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const ISyncMgrSyncItem.VTable, @ptrCast(self.vtable)).GetObject(@as(*const ISyncMgrSyncItem, @ptrCast(self)), rguidObjectID, riid, ppv);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrSyncItem_GetCapabilities(self: *const T, pmCapabilities: ?*SYNCMGR_ITEM_CAPABILITIES) HRESULT {
                return @as(*const ISyncMgrSyncItem.VTable, @ptrCast(self.vtable)).GetCapabilities(@as(*const ISyncMgrSyncItem, @ptrCast(self)), pmCapabilities);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrSyncItem_GetPolicies(self: *const T, pmPolicies: ?*SYNCMGR_ITEM_POLICIES) HRESULT {
                return @as(*const ISyncMgrSyncItem.VTable, @ptrCast(self.vtable)).GetPolicies(@as(*const ISyncMgrSyncItem, @ptrCast(self)), pmPolicies);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrSyncItem_Enable(self: *const T, fEnable: BOOL) HRESULT {
                return @as(*const ISyncMgrSyncItem.VTable, @ptrCast(self.vtable)).Enable(@as(*const ISyncMgrSyncItem, @ptrCast(self)), fEnable);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrSyncItem_Delete(self: *const T) HRESULT {
                return @as(*const ISyncMgrSyncItem.VTable, @ptrCast(self.vtable)).Delete(@as(*const ISyncMgrSyncItem, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ISyncMgrSyncItemInfo_Value = Guid.initString("e7fd9502-be0c-4464-90a1-2b5277031232");
pub const IID_ISyncMgrSyncItemInfo = &IID_ISyncMgrSyncItemInfo_Value;
pub const ISyncMgrSyncItemInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTypeLabel: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrSyncItemInfo,
                ppszTypeLabel: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrSyncItemInfo,
                ppszTypeLabel: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetComment: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrSyncItemInfo,
                ppszComment: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrSyncItemInfo,
                ppszComment: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLastSyncTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrSyncItemInfo,
                pftLastSync: ?*FILETIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrSyncItemInfo,
                pftLastSync: ?*FILETIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsEnabled: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrSyncItemInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrSyncItemInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsConnected: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrSyncItemInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrSyncItemInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrSyncItemInfo_GetTypeLabel(self: *const T, ppszTypeLabel: ?*?PWSTR) HRESULT {
                return @as(*const ISyncMgrSyncItemInfo.VTable, @ptrCast(self.vtable)).GetTypeLabel(@as(*const ISyncMgrSyncItemInfo, @ptrCast(self)), ppszTypeLabel);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrSyncItemInfo_GetComment(self: *const T, ppszComment: ?*?PWSTR) HRESULT {
                return @as(*const ISyncMgrSyncItemInfo.VTable, @ptrCast(self.vtable)).GetComment(@as(*const ISyncMgrSyncItemInfo, @ptrCast(self)), ppszComment);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrSyncItemInfo_GetLastSyncTime(self: *const T, pftLastSync: ?*FILETIME) HRESULT {
                return @as(*const ISyncMgrSyncItemInfo.VTable, @ptrCast(self.vtable)).GetLastSyncTime(@as(*const ISyncMgrSyncItemInfo, @ptrCast(self)), pftLastSync);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrSyncItemInfo_IsEnabled(self: *const T) HRESULT {
                return @as(*const ISyncMgrSyncItemInfo.VTable, @ptrCast(self.vtable)).IsEnabled(@as(*const ISyncMgrSyncItemInfo, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrSyncItemInfo_IsConnected(self: *const T) HRESULT {
                return @as(*const ISyncMgrSyncItemInfo.VTable, @ptrCast(self.vtable)).IsConnected(@as(*const ISyncMgrSyncItemInfo, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IEnumSyncMgrSyncItems_Value = Guid.initString("54b3abf3-f085-4181-b546-e29c403c726b");
pub const IID_IEnumSyncMgrSyncItems = &IID_IEnumSyncMgrSyncItems_Value;
pub const IEnumSyncMgrSyncItems = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumSyncMgrSyncItems,
                celt: u32,
                rgelt: [*]?*ISyncMgrSyncItem,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumSyncMgrSyncItems,
                celt: u32,
                rgelt: [*]?*ISyncMgrSyncItem,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumSyncMgrSyncItems,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumSyncMgrSyncItems,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumSyncMgrSyncItems,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumSyncMgrSyncItems,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumSyncMgrSyncItems,
                ppenum: ?*?*IEnumSyncMgrSyncItems,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumSyncMgrSyncItems,
                ppenum: ?*?*IEnumSyncMgrSyncItems,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumSyncMgrSyncItems_Next(self: *const T, celt: u32, rgelt: [*]?*ISyncMgrSyncItem, pceltFetched: ?*u32) HRESULT {
                return @as(*const IEnumSyncMgrSyncItems.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumSyncMgrSyncItems, @ptrCast(self)), celt, rgelt, pceltFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumSyncMgrSyncItems_Skip(self: *const T, celt: u32) HRESULT {
                return @as(*const IEnumSyncMgrSyncItems.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumSyncMgrSyncItems, @ptrCast(self)), celt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumSyncMgrSyncItems_Reset(self: *const T) HRESULT {
                return @as(*const IEnumSyncMgrSyncItems.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumSyncMgrSyncItems, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumSyncMgrSyncItems_Clone(self: *const T, ppenum: ?*?*IEnumSyncMgrSyncItems) HRESULT {
                return @as(*const IEnumSyncMgrSyncItems.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumSyncMgrSyncItems, @ptrCast(self)), ppenum);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SYNCMGR_PROGRESS_STATUS = enum(i32) {
    UPDATING = 1,
    UPDATING_INDETERMINATE = 2,
    SUCCEEDED = 3,
    FAILED = 4,
    CANCELED = 5,
    DISCONNECTED = 6,
    // MAX = 6, this enum value conflicts with DISCONNECTED
};
pub const SYNCMGR_PS_UPDATING = SYNCMGR_PROGRESS_STATUS.UPDATING;
pub const SYNCMGR_PS_UPDATING_INDETERMINATE = SYNCMGR_PROGRESS_STATUS.UPDATING_INDETERMINATE;
pub const SYNCMGR_PS_SUCCEEDED = SYNCMGR_PROGRESS_STATUS.SUCCEEDED;
pub const SYNCMGR_PS_FAILED = SYNCMGR_PROGRESS_STATUS.FAILED;
pub const SYNCMGR_PS_CANCELED = SYNCMGR_PROGRESS_STATUS.CANCELED;
pub const SYNCMGR_PS_DISCONNECTED = SYNCMGR_PROGRESS_STATUS.DISCONNECTED;
pub const SYNCMGR_PS_MAX = SYNCMGR_PROGRESS_STATUS.DISCONNECTED;

pub const SYNCMGR_CANCEL_REQUEST = enum(i32) {
    NONE = 0,
    CANCEL_ITEM = 1,
    CANCEL_ALL = 2,
    // MAX = 2, this enum value conflicts with CANCEL_ALL
};
pub const SYNCMGR_CR_NONE = SYNCMGR_CANCEL_REQUEST.NONE;
pub const SYNCMGR_CR_CANCEL_ITEM = SYNCMGR_CANCEL_REQUEST.CANCEL_ITEM;
pub const SYNCMGR_CR_CANCEL_ALL = SYNCMGR_CANCEL_REQUEST.CANCEL_ALL;
pub const SYNCMGR_CR_MAX = SYNCMGR_CANCEL_REQUEST.CANCEL_ALL;

pub const SYNCMGR_EVENT_LEVEL = enum(i32) {
    INFORMATION = 1,
    WARNING = 2,
    ERROR = 3,
    // MAX = 3, this enum value conflicts with ERROR
};
pub const SYNCMGR_EL_INFORMATION = SYNCMGR_EVENT_LEVEL.INFORMATION;
pub const SYNCMGR_EL_WARNING = SYNCMGR_EVENT_LEVEL.WARNING;
pub const SYNCMGR_EL_ERROR = SYNCMGR_EVENT_LEVEL.ERROR;
pub const SYNCMGR_EL_MAX = SYNCMGR_EVENT_LEVEL.ERROR;

pub const SYNCMGR_EVENT_FLAGS = enum(i32) {
    NONE = 0,
    // VALID = 0, this enum value conflicts with NONE
};
pub const SYNCMGR_EF_NONE = SYNCMGR_EVENT_FLAGS.NONE;
pub const SYNCMGR_EF_VALID = SYNCMGR_EVENT_FLAGS.NONE;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ISyncMgrSessionCreator_Value = Guid.initString("17f48517-f305-4321-a08d-b25a834918fd");
pub const IID_ISyncMgrSessionCreator = &IID_ISyncMgrSessionCreator_Value;
pub const ISyncMgrSessionCreator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateSession: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrSessionCreator,
                pszHandlerID: ?[*:0]const u16,
                ppszItemIDs: [*]?PWSTR,
                cItems: u32,
                ppCallback: ?*?*ISyncMgrSyncCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrSessionCreator,
                pszHandlerID: ?[*:0]const u16,
                ppszItemIDs: [*]?PWSTR,
                cItems: u32,
                ppCallback: ?*?*ISyncMgrSyncCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrSessionCreator_CreateSession(self: *const T, pszHandlerID: ?[*:0]const u16, ppszItemIDs: [*]?PWSTR, cItems: u32, ppCallback: ?*?*ISyncMgrSyncCallback) HRESULT {
                return @as(*const ISyncMgrSessionCreator.VTable, @ptrCast(self.vtable)).CreateSession(@as(*const ISyncMgrSessionCreator, @ptrCast(self)), pszHandlerID, ppszItemIDs, cItems, ppCallback);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ISyncMgrSyncCallback_Value = Guid.initString("884ccd87-b139-4937-a4ba-4f8e19513fbe");
pub const IID_ISyncMgrSyncCallback = &IID_ISyncMgrSyncCallback_Value;
pub const ISyncMgrSyncCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ReportProgress: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrSyncCallback,
                pszItemID: ?[*:0]const u16,
                pszProgressText: ?[*:0]const u16,
                nStatus: SYNCMGR_PROGRESS_STATUS,
                uCurrentStep: u32,
                uMaxStep: u32,
                pnCancelRequest: ?*SYNCMGR_CANCEL_REQUEST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrSyncCallback,
                pszItemID: ?[*:0]const u16,
                pszProgressText: ?[*:0]const u16,
                nStatus: SYNCMGR_PROGRESS_STATUS,
                uCurrentStep: u32,
                uMaxStep: u32,
                pnCancelRequest: ?*SYNCMGR_CANCEL_REQUEST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetHandlerProgressText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrSyncCallback,
                pszProgressText: ?[*:0]const u16,
                pnCancelRequest: ?*SYNCMGR_CANCEL_REQUEST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrSyncCallback,
                pszProgressText: ?[*:0]const u16,
                pnCancelRequest: ?*SYNCMGR_CANCEL_REQUEST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReportEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrSyncCallback,
                pszItemID: ?[*:0]const u16,
                nLevel: SYNCMGR_EVENT_LEVEL,
                nFlags: SYNCMGR_EVENT_FLAGS,
                pszName: ?[*:0]const u16,
                pszDescription: ?[*:0]const u16,
                pszLinkText: ?[*:0]const u16,
                pszLinkReference: ?[*:0]const u16,
                pszContext: ?[*:0]const u16,
                pguidEventID: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrSyncCallback,
                pszItemID: ?[*:0]const u16,
                nLevel: SYNCMGR_EVENT_LEVEL,
                nFlags: SYNCMGR_EVENT_FLAGS,
                pszName: ?[*:0]const u16,
                pszDescription: ?[*:0]const u16,
                pszLinkText: ?[*:0]const u16,
                pszLinkReference: ?[*:0]const u16,
                pszContext: ?[*:0]const u16,
                pguidEventID: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CanContinue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrSyncCallback,
                pszItemID: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrSyncCallback,
                pszItemID: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryForAdditionalItems: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrSyncCallback,
                ppenumItemIDs: ?*?*IEnumString,
                ppenumPunks: ?*?*IEnumUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrSyncCallback,
                ppenumItemIDs: ?*?*IEnumString,
                ppenumPunks: ?*?*IEnumUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddItemToSession: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrSyncCallback,
                pszItemID: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrSyncCallback,
                pszItemID: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddIUnknownToSession: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrSyncCallback,
                punk: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrSyncCallback,
                punk: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ProposeItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrSyncCallback,
                pNewItem: ?*ISyncMgrSyncItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrSyncCallback,
                pNewItem: ?*ISyncMgrSyncItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CommitItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrSyncCallback,
                pszItemID: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrSyncCallback,
                pszItemID: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReportManualSync: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrSyncCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrSyncCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrSyncCallback_ReportProgress(self: *const T, pszItemID: ?[*:0]const u16, pszProgressText: ?[*:0]const u16, nStatus: SYNCMGR_PROGRESS_STATUS, uCurrentStep: u32, uMaxStep: u32, pnCancelRequest: ?*SYNCMGR_CANCEL_REQUEST) HRESULT {
                return @as(*const ISyncMgrSyncCallback.VTable, @ptrCast(self.vtable)).ReportProgress(@as(*const ISyncMgrSyncCallback, @ptrCast(self)), pszItemID, pszProgressText, nStatus, uCurrentStep, uMaxStep, pnCancelRequest);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrSyncCallback_SetHandlerProgressText(self: *const T, pszProgressText: ?[*:0]const u16, pnCancelRequest: ?*SYNCMGR_CANCEL_REQUEST) HRESULT {
                return @as(*const ISyncMgrSyncCallback.VTable, @ptrCast(self.vtable)).SetHandlerProgressText(@as(*const ISyncMgrSyncCallback, @ptrCast(self)), pszProgressText, pnCancelRequest);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrSyncCallback_ReportEvent(self: *const T, pszItemID: ?[*:0]const u16, nLevel: SYNCMGR_EVENT_LEVEL, nFlags: SYNCMGR_EVENT_FLAGS, pszName: ?[*:0]const u16, pszDescription: ?[*:0]const u16, pszLinkText: ?[*:0]const u16, pszLinkReference: ?[*:0]const u16, pszContext: ?[*:0]const u16, pguidEventID: ?*Guid) HRESULT {
                return @as(*const ISyncMgrSyncCallback.VTable, @ptrCast(self.vtable)).ReportEvent(@as(*const ISyncMgrSyncCallback, @ptrCast(self)), pszItemID, nLevel, nFlags, pszName, pszDescription, pszLinkText, pszLinkReference, pszContext, pguidEventID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrSyncCallback_CanContinue(self: *const T, pszItemID: ?[*:0]const u16) HRESULT {
                return @as(*const ISyncMgrSyncCallback.VTable, @ptrCast(self.vtable)).CanContinue(@as(*const ISyncMgrSyncCallback, @ptrCast(self)), pszItemID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrSyncCallback_QueryForAdditionalItems(self: *const T, ppenumItemIDs: ?*?*IEnumString, ppenumPunks: ?*?*IEnumUnknown) HRESULT {
                return @as(*const ISyncMgrSyncCallback.VTable, @ptrCast(self.vtable)).QueryForAdditionalItems(@as(*const ISyncMgrSyncCallback, @ptrCast(self)), ppenumItemIDs, ppenumPunks);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrSyncCallback_AddItemToSession(self: *const T, pszItemID: ?[*:0]const u16) HRESULT {
                return @as(*const ISyncMgrSyncCallback.VTable, @ptrCast(self.vtable)).AddItemToSession(@as(*const ISyncMgrSyncCallback, @ptrCast(self)), pszItemID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrSyncCallback_AddIUnknownToSession(self: *const T, punk: ?*IUnknown) HRESULT {
                return @as(*const ISyncMgrSyncCallback.VTable, @ptrCast(self.vtable)).AddIUnknownToSession(@as(*const ISyncMgrSyncCallback, @ptrCast(self)), punk);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrSyncCallback_ProposeItem(self: *const T, pNewItem: ?*ISyncMgrSyncItem) HRESULT {
                return @as(*const ISyncMgrSyncCallback.VTable, @ptrCast(self.vtable)).ProposeItem(@as(*const ISyncMgrSyncCallback, @ptrCast(self)), pNewItem);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrSyncCallback_CommitItem(self: *const T, pszItemID: ?[*:0]const u16) HRESULT {
                return @as(*const ISyncMgrSyncCallback.VTable, @ptrCast(self.vtable)).CommitItem(@as(*const ISyncMgrSyncCallback, @ptrCast(self)), pszItemID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrSyncCallback_ReportManualSync(self: *const T) HRESULT {
                return @as(*const ISyncMgrSyncCallback.VTable, @ptrCast(self.vtable)).ReportManualSync(@as(*const ISyncMgrSyncCallback, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ISyncMgrUIOperation_Value = Guid.initString("fc7cfa47-dfe1-45b5-a049-8cfd82bec271");
pub const IID_ISyncMgrUIOperation = &IID_ISyncMgrUIOperation_Value;
pub const ISyncMgrUIOperation = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Run: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrUIOperation,
                hwndOwner: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrUIOperation,
                hwndOwner: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrUIOperation_Run(self: *const T, hwndOwner: ?HWND) HRESULT {
                return @as(*const ISyncMgrUIOperation.VTable, @ptrCast(self.vtable)).Run(@as(*const ISyncMgrUIOperation, @ptrCast(self)), hwndOwner);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ISyncMgrEventLinkUIOperation_Value = Guid.initString("64522e52-848b-4015-89ce-5a36f00b94ff");
pub const IID_ISyncMgrEventLinkUIOperation = &IID_ISyncMgrEventLinkUIOperation_Value;
pub const ISyncMgrEventLinkUIOperation = extern struct {
    pub const VTable = extern struct {
        base: ISyncMgrUIOperation.VTable,
        Init: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrEventLinkUIOperation,
                rguidEventID: ?*const Guid,
                pEvent: ?*ISyncMgrEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrEventLinkUIOperation,
                rguidEventID: ?*const Guid,
                pEvent: ?*ISyncMgrEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ISyncMgrUIOperation.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrEventLinkUIOperation_Init(self: *const T, rguidEventID: ?*const Guid, pEvent: ?*ISyncMgrEvent) HRESULT {
                return @as(*const ISyncMgrEventLinkUIOperation.VTable, @ptrCast(self.vtable)).Init(@as(*const ISyncMgrEventLinkUIOperation, @ptrCast(self)), rguidEventID, pEvent);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ISyncMgrScheduleWizardUIOperation_Value = Guid.initString("459a6c84-21d2-4ddc-8a53-f023a46066f2");
pub const IID_ISyncMgrScheduleWizardUIOperation = &IID_ISyncMgrScheduleWizardUIOperation_Value;
pub const ISyncMgrScheduleWizardUIOperation = extern struct {
    pub const VTable = extern struct {
        base: ISyncMgrUIOperation.VTable,
        InitWizard: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrScheduleWizardUIOperation,
                pszHandlerID: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrScheduleWizardUIOperation,
                pszHandlerID: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ISyncMgrUIOperation.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrScheduleWizardUIOperation_InitWizard(self: *const T, pszHandlerID: ?[*:0]const u16) HRESULT {
                return @as(*const ISyncMgrScheduleWizardUIOperation.VTable, @ptrCast(self.vtable)).InitWizard(@as(*const ISyncMgrScheduleWizardUIOperation, @ptrCast(self)), pszHandlerID);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ISyncMgrSyncResult_Value = Guid.initString("2b90f17e-5a3e-4b33-bb7f-1bc48056b94d");
pub const IID_ISyncMgrSyncResult = &IID_ISyncMgrSyncResult_Value;
pub const ISyncMgrSyncResult = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Result: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrSyncResult,
                nStatus: SYNCMGR_PROGRESS_STATUS,
                cError: u32,
                cConflicts: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrSyncResult,
                nStatus: SYNCMGR_PROGRESS_STATUS,
                cError: u32,
                cConflicts: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrSyncResult_Result(self: *const T, nStatus: SYNCMGR_PROGRESS_STATUS, cError: u32, cConflicts: u32) HRESULT {
                return @as(*const ISyncMgrSyncResult.VTable, @ptrCast(self.vtable)).Result(@as(*const ISyncMgrSyncResult, @ptrCast(self)), nStatus, cError, cConflicts);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SYNCMGR_CONTROL_FLAGS = enum(i32) {
    NONE = 0,
    // NOWAIT = 0, this enum value conflicts with NONE
    WAIT = 1,
    NOUI = 2,
    VALID = 3,
};
pub const SYNCMGR_CF_NONE = SYNCMGR_CONTROL_FLAGS.NONE;
pub const SYNCMGR_CF_NOWAIT = SYNCMGR_CONTROL_FLAGS.NONE;
pub const SYNCMGR_CF_WAIT = SYNCMGR_CONTROL_FLAGS.WAIT;
pub const SYNCMGR_CF_NOUI = SYNCMGR_CONTROL_FLAGS.NOUI;
pub const SYNCMGR_CF_VALID = SYNCMGR_CONTROL_FLAGS.VALID;

pub const SYNCMGR_SYNC_CONTROL_FLAGS = enum(i32) {
    NONE = 0,
    IGNORE_IF_ALREADY_SYNCING = 1,
    // VALID = 1, this enum value conflicts with IGNORE_IF_ALREADY_SYNCING
};
pub const SYNCMGR_SCF_NONE = SYNCMGR_SYNC_CONTROL_FLAGS.NONE;
pub const SYNCMGR_SCF_IGNORE_IF_ALREADY_SYNCING = SYNCMGR_SYNC_CONTROL_FLAGS.IGNORE_IF_ALREADY_SYNCING;
pub const SYNCMGR_SCF_VALID = SYNCMGR_SYNC_CONTROL_FLAGS.IGNORE_IF_ALREADY_SYNCING;

pub const SYNCMGR_UPDATE_REASON = enum(i32) {
    ADDED = 0,
    CHANGED = 1,
    REMOVED = 2,
    // MAX = 2, this enum value conflicts with REMOVED
};
pub const SYNCMGR_UR_ADDED = SYNCMGR_UPDATE_REASON.ADDED;
pub const SYNCMGR_UR_CHANGED = SYNCMGR_UPDATE_REASON.CHANGED;
pub const SYNCMGR_UR_REMOVED = SYNCMGR_UPDATE_REASON.REMOVED;
pub const SYNCMGR_UR_MAX = SYNCMGR_UPDATE_REASON.REMOVED;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ISyncMgrControl_Value = Guid.initString("9b63616c-36b2-46bc-959f-c1593952d19b");
pub const IID_ISyncMgrControl = &IID_ISyncMgrControl_Value;
pub const ISyncMgrControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        StartHandlerSync: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrControl,
                pszHandlerID: ?[*:0]const u16,
                hwndOwner: ?HWND,
                punk: ?*IUnknown,
                nSyncControlFlags: SYNCMGR_SYNC_CONTROL_FLAGS,
                pResult: ?*ISyncMgrSyncResult,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrControl,
                pszHandlerID: ?[*:0]const u16,
                hwndOwner: ?HWND,
                punk: ?*IUnknown,
                nSyncControlFlags: SYNCMGR_SYNC_CONTROL_FLAGS,
                pResult: ?*ISyncMgrSyncResult,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartItemSync: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrControl,
                pszHandlerID: ?[*:0]const u16,
                ppszItemIDs: [*]?PWSTR,
                cItems: u32,
                hwndOwner: ?HWND,
                punk: ?*IUnknown,
                nSyncControlFlags: SYNCMGR_SYNC_CONTROL_FLAGS,
                pResult: ?*ISyncMgrSyncResult,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrControl,
                pszHandlerID: ?[*:0]const u16,
                ppszItemIDs: [*]?PWSTR,
                cItems: u32,
                hwndOwner: ?HWND,
                punk: ?*IUnknown,
                nSyncControlFlags: SYNCMGR_SYNC_CONTROL_FLAGS,
                pResult: ?*ISyncMgrSyncResult,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartSyncAll: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrControl,
                hwndOwner: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrControl,
                hwndOwner: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StopHandlerSync: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrControl,
                pszHandlerID: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrControl,
                pszHandlerID: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StopItemSync: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrControl,
                pszHandlerID: ?[*:0]const u16,
                ppszItemIDs: [*]?PWSTR,
                cItems: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrControl,
                pszHandlerID: ?[*:0]const u16,
                ppszItemIDs: [*]?PWSTR,
                cItems: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StopSyncAll: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UpdateHandlerCollection: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrControl,
                rclsidCollectionID: ?*const Guid,
                nControlFlags: SYNCMGR_CONTROL_FLAGS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrControl,
                rclsidCollectionID: ?*const Guid,
                nControlFlags: SYNCMGR_CONTROL_FLAGS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UpdateHandler: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrControl,
                pszHandlerID: ?[*:0]const u16,
                nControlFlags: SYNCMGR_CONTROL_FLAGS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrControl,
                pszHandlerID: ?[*:0]const u16,
                nControlFlags: SYNCMGR_CONTROL_FLAGS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UpdateItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrControl,
                pszHandlerID: ?[*:0]const u16,
                pszItemID: ?[*:0]const u16,
                nControlFlags: SYNCMGR_CONTROL_FLAGS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrControl,
                pszHandlerID: ?[*:0]const u16,
                pszItemID: ?[*:0]const u16,
                nControlFlags: SYNCMGR_CONTROL_FLAGS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UpdateEvents: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrControl,
                pszHandlerID: ?[*:0]const u16,
                pszItemID: ?[*:0]const u16,
                nControlFlags: SYNCMGR_CONTROL_FLAGS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrControl,
                pszHandlerID: ?[*:0]const u16,
                pszItemID: ?[*:0]const u16,
                nControlFlags: SYNCMGR_CONTROL_FLAGS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UpdateConflict: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrControl,
                pszHandlerID: ?[*:0]const u16,
                pszItemID: ?[*:0]const u16,
                pConflict: ?*ISyncMgrConflict,
                nReason: SYNCMGR_UPDATE_REASON,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrControl,
                pszHandlerID: ?[*:0]const u16,
                pszItemID: ?[*:0]const u16,
                pConflict: ?*ISyncMgrConflict,
                nReason: SYNCMGR_UPDATE_REASON,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UpdateConflicts: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrControl,
                pszHandlerID: ?[*:0]const u16,
                pszItemID: ?[*:0]const u16,
                nControlFlags: SYNCMGR_CONTROL_FLAGS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrControl,
                pszHandlerID: ?[*:0]const u16,
                pszItemID: ?[*:0]const u16,
                nControlFlags: SYNCMGR_CONTROL_FLAGS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ActivateHandler: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrControl,
                fActivate: BOOL,
                pszHandlerID: ?[*:0]const u16,
                hwndOwner: ?HWND,
                nControlFlags: SYNCMGR_CONTROL_FLAGS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrControl,
                fActivate: BOOL,
                pszHandlerID: ?[*:0]const u16,
                hwndOwner: ?HWND,
                nControlFlags: SYNCMGR_CONTROL_FLAGS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnableHandler: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrControl,
                fEnable: BOOL,
                pszHandlerID: ?[*:0]const u16,
                hwndOwner: ?HWND,
                nControlFlags: SYNCMGR_CONTROL_FLAGS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrControl,
                fEnable: BOOL,
                pszHandlerID: ?[*:0]const u16,
                hwndOwner: ?HWND,
                nControlFlags: SYNCMGR_CONTROL_FLAGS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnableItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrControl,
                fEnable: BOOL,
                pszHandlerID: ?[*:0]const u16,
                pszItemID: ?[*:0]const u16,
                hwndOwner: ?HWND,
                nControlFlags: SYNCMGR_CONTROL_FLAGS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrControl,
                fEnable: BOOL,
                pszHandlerID: ?[*:0]const u16,
                pszItemID: ?[*:0]const u16,
                hwndOwner: ?HWND,
                nControlFlags: SYNCMGR_CONTROL_FLAGS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrControl_StartHandlerSync(self: *const T, pszHandlerID: ?[*:0]const u16, hwndOwner: ?HWND, punk: ?*IUnknown, nSyncControlFlags: SYNCMGR_SYNC_CONTROL_FLAGS, pResult: ?*ISyncMgrSyncResult) HRESULT {
                return @as(*const ISyncMgrControl.VTable, @ptrCast(self.vtable)).StartHandlerSync(@as(*const ISyncMgrControl, @ptrCast(self)), pszHandlerID, hwndOwner, punk, nSyncControlFlags, pResult);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrControl_StartItemSync(self: *const T, pszHandlerID: ?[*:0]const u16, ppszItemIDs: [*]?PWSTR, cItems: u32, hwndOwner: ?HWND, punk: ?*IUnknown, nSyncControlFlags: SYNCMGR_SYNC_CONTROL_FLAGS, pResult: ?*ISyncMgrSyncResult) HRESULT {
                return @as(*const ISyncMgrControl.VTable, @ptrCast(self.vtable)).StartItemSync(@as(*const ISyncMgrControl, @ptrCast(self)), pszHandlerID, ppszItemIDs, cItems, hwndOwner, punk, nSyncControlFlags, pResult);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrControl_StartSyncAll(self: *const T, hwndOwner: ?HWND) HRESULT {
                return @as(*const ISyncMgrControl.VTable, @ptrCast(self.vtable)).StartSyncAll(@as(*const ISyncMgrControl, @ptrCast(self)), hwndOwner);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrControl_StopHandlerSync(self: *const T, pszHandlerID: ?[*:0]const u16) HRESULT {
                return @as(*const ISyncMgrControl.VTable, @ptrCast(self.vtable)).StopHandlerSync(@as(*const ISyncMgrControl, @ptrCast(self)), pszHandlerID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrControl_StopItemSync(self: *const T, pszHandlerID: ?[*:0]const u16, ppszItemIDs: [*]?PWSTR, cItems: u32) HRESULT {
                return @as(*const ISyncMgrControl.VTable, @ptrCast(self.vtable)).StopItemSync(@as(*const ISyncMgrControl, @ptrCast(self)), pszHandlerID, ppszItemIDs, cItems);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrControl_StopSyncAll(self: *const T) HRESULT {
                return @as(*const ISyncMgrControl.VTable, @ptrCast(self.vtable)).StopSyncAll(@as(*const ISyncMgrControl, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrControl_UpdateHandlerCollection(self: *const T, rclsidCollectionID: ?*const Guid, nControlFlags: SYNCMGR_CONTROL_FLAGS) HRESULT {
                return @as(*const ISyncMgrControl.VTable, @ptrCast(self.vtable)).UpdateHandlerCollection(@as(*const ISyncMgrControl, @ptrCast(self)), rclsidCollectionID, nControlFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrControl_UpdateHandler(self: *const T, pszHandlerID: ?[*:0]const u16, nControlFlags: SYNCMGR_CONTROL_FLAGS) HRESULT {
                return @as(*const ISyncMgrControl.VTable, @ptrCast(self.vtable)).UpdateHandler(@as(*const ISyncMgrControl, @ptrCast(self)), pszHandlerID, nControlFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrControl_UpdateItem(self: *const T, pszHandlerID: ?[*:0]const u16, pszItemID: ?[*:0]const u16, nControlFlags: SYNCMGR_CONTROL_FLAGS) HRESULT {
                return @as(*const ISyncMgrControl.VTable, @ptrCast(self.vtable)).UpdateItem(@as(*const ISyncMgrControl, @ptrCast(self)), pszHandlerID, pszItemID, nControlFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrControl_UpdateEvents(self: *const T, pszHandlerID: ?[*:0]const u16, pszItemID: ?[*:0]const u16, nControlFlags: SYNCMGR_CONTROL_FLAGS) HRESULT {
                return @as(*const ISyncMgrControl.VTable, @ptrCast(self.vtable)).UpdateEvents(@as(*const ISyncMgrControl, @ptrCast(self)), pszHandlerID, pszItemID, nControlFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrControl_UpdateConflict(self: *const T, pszHandlerID: ?[*:0]const u16, pszItemID: ?[*:0]const u16, pConflict: ?*ISyncMgrConflict, nReason: SYNCMGR_UPDATE_REASON) HRESULT {
                return @as(*const ISyncMgrControl.VTable, @ptrCast(self.vtable)).UpdateConflict(@as(*const ISyncMgrControl, @ptrCast(self)), pszHandlerID, pszItemID, pConflict, nReason);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrControl_UpdateConflicts(self: *const T, pszHandlerID: ?[*:0]const u16, pszItemID: ?[*:0]const u16, nControlFlags: SYNCMGR_CONTROL_FLAGS) HRESULT {
                return @as(*const ISyncMgrControl.VTable, @ptrCast(self.vtable)).UpdateConflicts(@as(*const ISyncMgrControl, @ptrCast(self)), pszHandlerID, pszItemID, nControlFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrControl_ActivateHandler(self: *const T, fActivate: BOOL, pszHandlerID: ?[*:0]const u16, hwndOwner: ?HWND, nControlFlags: SYNCMGR_CONTROL_FLAGS) HRESULT {
                return @as(*const ISyncMgrControl.VTable, @ptrCast(self.vtable)).ActivateHandler(@as(*const ISyncMgrControl, @ptrCast(self)), fActivate, pszHandlerID, hwndOwner, nControlFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrControl_EnableHandler(self: *const T, fEnable: BOOL, pszHandlerID: ?[*:0]const u16, hwndOwner: ?HWND, nControlFlags: SYNCMGR_CONTROL_FLAGS) HRESULT {
                return @as(*const ISyncMgrControl.VTable, @ptrCast(self.vtable)).EnableHandler(@as(*const ISyncMgrControl, @ptrCast(self)), fEnable, pszHandlerID, hwndOwner, nControlFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrControl_EnableItem(self: *const T, fEnable: BOOL, pszHandlerID: ?[*:0]const u16, pszItemID: ?[*:0]const u16, hwndOwner: ?HWND, nControlFlags: SYNCMGR_CONTROL_FLAGS) HRESULT {
                return @as(*const ISyncMgrControl.VTable, @ptrCast(self.vtable)).EnableItem(@as(*const ISyncMgrControl, @ptrCast(self)), fEnable, pszHandlerID, pszItemID, hwndOwner, nControlFlags);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ISyncMgrEventStore_Value = Guid.initString("37e412f9-016e-44c2-81ff-db3add774266");
pub const IID_ISyncMgrEventStore = &IID_ISyncMgrEventStore_Value;
pub const ISyncMgrEventStore = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetEventEnumerator: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrEventStore,
                ppenum: ?*?*IEnumSyncMgrEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrEventStore,
                ppenum: ?*?*IEnumSyncMgrEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrEventStore,
                pcEvents: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrEventStore,
                pcEvents: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrEventStore,
                rguidEventID: ?*const Guid,
                ppEvent: ?*?*ISyncMgrEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrEventStore,
                rguidEventID: ?*const Guid,
                ppEvent: ?*?*ISyncMgrEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrEventStore,
                pguidEventIDs: [*]Guid,
                cEvents: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrEventStore,
                pguidEventIDs: [*]Guid,
                cEvents: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrEventStore_GetEventEnumerator(self: *const T, ppenum: ?*?*IEnumSyncMgrEvents) HRESULT {
                return @as(*const ISyncMgrEventStore.VTable, @ptrCast(self.vtable)).GetEventEnumerator(@as(*const ISyncMgrEventStore, @ptrCast(self)), ppenum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrEventStore_GetEventCount(self: *const T, pcEvents: ?*u32) HRESULT {
                return @as(*const ISyncMgrEventStore.VTable, @ptrCast(self.vtable)).GetEventCount(@as(*const ISyncMgrEventStore, @ptrCast(self)), pcEvents);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrEventStore_GetEvent(self: *const T, rguidEventID: ?*const Guid, ppEvent: ?*?*ISyncMgrEvent) HRESULT {
                return @as(*const ISyncMgrEventStore.VTable, @ptrCast(self.vtable)).GetEvent(@as(*const ISyncMgrEventStore, @ptrCast(self)), rguidEventID, ppEvent);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrEventStore_RemoveEvent(self: *const T, pguidEventIDs: [*]Guid, cEvents: u32) HRESULT {
                return @as(*const ISyncMgrEventStore.VTable, @ptrCast(self.vtable)).RemoveEvent(@as(*const ISyncMgrEventStore, @ptrCast(self)), pguidEventIDs, cEvents);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ISyncMgrEvent_Value = Guid.initString("fee0ef8b-46bd-4db4-b7e6-ff2c687313bc");
pub const IID_ISyncMgrEvent = &IID_ISyncMgrEvent_Value;
pub const ISyncMgrEvent = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetEventID: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrEvent,
                pguidEventID: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrEvent,
                pguidEventID: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetHandlerID: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrEvent,
                ppszHandlerID: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrEvent,
                ppszHandlerID: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetItemID: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrEvent,
                ppszItemID: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrEvent,
                ppszItemID: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLevel: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrEvent,
                pnLevel: ?*SYNCMGR_EVENT_LEVEL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrEvent,
                pnLevel: ?*SYNCMGR_EVENT_LEVEL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrEvent,
                pnFlags: ?*SYNCMGR_EVENT_FLAGS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrEvent,
                pnFlags: ?*SYNCMGR_EVENT_FLAGS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrEvent,
                pfCreationTime: ?*FILETIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrEvent,
                pfCreationTime: ?*FILETIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrEvent,
                ppszName: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrEvent,
                ppszName: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrEvent,
                ppszDescription: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrEvent,
                ppszDescription: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLinkText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrEvent,
                ppszLinkText: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrEvent,
                ppszLinkText: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLinkReference: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrEvent,
                ppszLinkReference: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrEvent,
                ppszLinkReference: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrEvent,
                ppszContext: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrEvent,
                ppszContext: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrEvent_GetEventID(self: *const T, pguidEventID: ?*Guid) HRESULT {
                return @as(*const ISyncMgrEvent.VTable, @ptrCast(self.vtable)).GetEventID(@as(*const ISyncMgrEvent, @ptrCast(self)), pguidEventID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrEvent_GetHandlerID(self: *const T, ppszHandlerID: ?*?PWSTR) HRESULT {
                return @as(*const ISyncMgrEvent.VTable, @ptrCast(self.vtable)).GetHandlerID(@as(*const ISyncMgrEvent, @ptrCast(self)), ppszHandlerID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrEvent_GetItemID(self: *const T, ppszItemID: ?*?PWSTR) HRESULT {
                return @as(*const ISyncMgrEvent.VTable, @ptrCast(self.vtable)).GetItemID(@as(*const ISyncMgrEvent, @ptrCast(self)), ppszItemID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrEvent_GetLevel(self: *const T, pnLevel: ?*SYNCMGR_EVENT_LEVEL) HRESULT {
                return @as(*const ISyncMgrEvent.VTable, @ptrCast(self.vtable)).GetLevel(@as(*const ISyncMgrEvent, @ptrCast(self)), pnLevel);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrEvent_GetFlags(self: *const T, pnFlags: ?*SYNCMGR_EVENT_FLAGS) HRESULT {
                return @as(*const ISyncMgrEvent.VTable, @ptrCast(self.vtable)).GetFlags(@as(*const ISyncMgrEvent, @ptrCast(self)), pnFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrEvent_GetTime(self: *const T, pfCreationTime: ?*FILETIME) HRESULT {
                return @as(*const ISyncMgrEvent.VTable, @ptrCast(self.vtable)).GetTime(@as(*const ISyncMgrEvent, @ptrCast(self)), pfCreationTime);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrEvent_GetName(self: *const T, ppszName: ?*?PWSTR) HRESULT {
                return @as(*const ISyncMgrEvent.VTable, @ptrCast(self.vtable)).GetName(@as(*const ISyncMgrEvent, @ptrCast(self)), ppszName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrEvent_GetDescription(self: *const T, ppszDescription: ?*?PWSTR) HRESULT {
                return @as(*const ISyncMgrEvent.VTable, @ptrCast(self.vtable)).GetDescription(@as(*const ISyncMgrEvent, @ptrCast(self)), ppszDescription);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrEvent_GetLinkText(self: *const T, ppszLinkText: ?*?PWSTR) HRESULT {
                return @as(*const ISyncMgrEvent.VTable, @ptrCast(self.vtable)).GetLinkText(@as(*const ISyncMgrEvent, @ptrCast(self)), ppszLinkText);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrEvent_GetLinkReference(self: *const T, ppszLinkReference: ?*?PWSTR) HRESULT {
                return @as(*const ISyncMgrEvent.VTable, @ptrCast(self.vtable)).GetLinkReference(@as(*const ISyncMgrEvent, @ptrCast(self)), ppszLinkReference);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrEvent_GetContext(self: *const T, ppszContext: ?*?PWSTR) HRESULT {
                return @as(*const ISyncMgrEvent.VTable, @ptrCast(self.vtable)).GetContext(@as(*const ISyncMgrEvent, @ptrCast(self)), ppszContext);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IEnumSyncMgrEvents_Value = Guid.initString("c81a1d4e-8cf7-4683-80e0-bcae88d677b6");
pub const IID_IEnumSyncMgrEvents = &IID_IEnumSyncMgrEvents_Value;
pub const IEnumSyncMgrEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumSyncMgrEvents,
                celt: u32,
                rgelt: [*]?*ISyncMgrEvent,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumSyncMgrEvents,
                celt: u32,
                rgelt: [*]?*ISyncMgrEvent,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumSyncMgrEvents,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumSyncMgrEvents,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumSyncMgrEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumSyncMgrEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumSyncMgrEvents,
                ppenum: ?*?*IEnumSyncMgrEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumSyncMgrEvents,
                ppenum: ?*?*IEnumSyncMgrEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumSyncMgrEvents_Next(self: *const T, celt: u32, rgelt: [*]?*ISyncMgrEvent, pceltFetched: ?*u32) HRESULT {
                return @as(*const IEnumSyncMgrEvents.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumSyncMgrEvents, @ptrCast(self)), celt, rgelt, pceltFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumSyncMgrEvents_Skip(self: *const T, celt: u32) HRESULT {
                return @as(*const IEnumSyncMgrEvents.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumSyncMgrEvents, @ptrCast(self)), celt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumSyncMgrEvents_Reset(self: *const T) HRESULT {
                return @as(*const IEnumSyncMgrEvents.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumSyncMgrEvents, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumSyncMgrEvents_Clone(self: *const T, ppenum: ?*?*IEnumSyncMgrEvents) HRESULT {
                return @as(*const IEnumSyncMgrEvents.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumSyncMgrEvents, @ptrCast(self)), ppenum);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SYNCMGR_CONFLICT_ID_INFO = extern struct {
    pblobID: ?*BYTE_BLOB,
    pblobExtra: ?*BYTE_BLOB,
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ISyncMgrConflictStore_Value = Guid.initString("cf8fc579-c396-4774-85f1-d908a831156e");
pub const IID_ISyncMgrConflictStore = &IID_ISyncMgrConflictStore_Value;
pub const ISyncMgrConflictStore = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EnumConflicts: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrConflictStore,
                pszHandlerID: ?[*:0]const u16,
                pszItemID: ?[*:0]const u16,
                ppEnum: ?*?*IEnumSyncMgrConflict,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrConflictStore,
                pszHandlerID: ?[*:0]const u16,
                pszItemID: ?[*:0]const u16,
                ppEnum: ?*?*IEnumSyncMgrConflict,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BindToConflict: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrConflictStore,
                pConflictIdInfo: ?*const SYNCMGR_CONFLICT_ID_INFO,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrConflictStore,
                pConflictIdInfo: ?*const SYNCMGR_CONFLICT_ID_INFO,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveConflicts: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrConflictStore,
                rgConflictIdInfo: [*]const SYNCMGR_CONFLICT_ID_INFO,
                cConflicts: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrConflictStore,
                rgConflictIdInfo: [*]const SYNCMGR_CONFLICT_ID_INFO,
                cConflicts: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrConflictStore,
                pszHandlerID: ?[*:0]const u16,
                pszItemID: ?[*:0]const u16,
                pnConflicts: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrConflictStore,
                pszHandlerID: ?[*:0]const u16,
                pszItemID: ?[*:0]const u16,
                pnConflicts: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrConflictStore_EnumConflicts(self: *const T, pszHandlerID: ?[*:0]const u16, pszItemID: ?[*:0]const u16, ppEnum: ?*?*IEnumSyncMgrConflict) HRESULT {
                return @as(*const ISyncMgrConflictStore.VTable, @ptrCast(self.vtable)).EnumConflicts(@as(*const ISyncMgrConflictStore, @ptrCast(self)), pszHandlerID, pszItemID, ppEnum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrConflictStore_BindToConflict(self: *const T, pConflictIdInfo: ?*const SYNCMGR_CONFLICT_ID_INFO, riid: ?*const Guid, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const ISyncMgrConflictStore.VTable, @ptrCast(self.vtable)).BindToConflict(@as(*const ISyncMgrConflictStore, @ptrCast(self)), pConflictIdInfo, riid, ppv);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrConflictStore_RemoveConflicts(self: *const T, rgConflictIdInfo: [*]const SYNCMGR_CONFLICT_ID_INFO, cConflicts: u32) HRESULT {
                return @as(*const ISyncMgrConflictStore.VTable, @ptrCast(self.vtable)).RemoveConflicts(@as(*const ISyncMgrConflictStore, @ptrCast(self)), rgConflictIdInfo, cConflicts);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrConflictStore_GetCount(self: *const T, pszHandlerID: ?[*:0]const u16, pszItemID: ?[*:0]const u16, pnConflicts: ?*u32) HRESULT {
                return @as(*const ISyncMgrConflictStore.VTable, @ptrCast(self.vtable)).GetCount(@as(*const ISyncMgrConflictStore, @ptrCast(self)), pszHandlerID, pszItemID, pnConflicts);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IEnumSyncMgrConflict_Value = Guid.initString("82705914-dda3-4893-ba99-49de6c8c8036");
pub const IID_IEnumSyncMgrConflict = &IID_IEnumSyncMgrConflict_Value;
pub const IEnumSyncMgrConflict = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumSyncMgrConflict,
                celt: u32,
                rgelt: [*]?*ISyncMgrConflict,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumSyncMgrConflict,
                celt: u32,
                rgelt: [*]?*ISyncMgrConflict,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumSyncMgrConflict,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumSyncMgrConflict,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumSyncMgrConflict,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumSyncMgrConflict,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumSyncMgrConflict,
                ppenum: ?*?*IEnumSyncMgrConflict,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumSyncMgrConflict,
                ppenum: ?*?*IEnumSyncMgrConflict,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumSyncMgrConflict_Next(self: *const T, celt: u32, rgelt: [*]?*ISyncMgrConflict, pceltFetched: ?*u32) HRESULT {
                return @as(*const IEnumSyncMgrConflict.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumSyncMgrConflict, @ptrCast(self)), celt, rgelt, pceltFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumSyncMgrConflict_Skip(self: *const T, celt: u32) HRESULT {
                return @as(*const IEnumSyncMgrConflict.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumSyncMgrConflict, @ptrCast(self)), celt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumSyncMgrConflict_Reset(self: *const T) HRESULT {
                return @as(*const IEnumSyncMgrConflict.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumSyncMgrConflict, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumSyncMgrConflict_Clone(self: *const T, ppenum: ?*?*IEnumSyncMgrConflict) HRESULT {
                return @as(*const IEnumSyncMgrConflict.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumSyncMgrConflict, @ptrCast(self)), ppenum);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SYNCMGR_CONFLICT_ITEM_TYPE = enum(i32) {
    UPDATED = 1,
    DELETED = 2,
};
pub const SYNCMGR_CIT_UPDATED = SYNCMGR_CONFLICT_ITEM_TYPE.UPDATED;
pub const SYNCMGR_CIT_DELETED = SYNCMGR_CONFLICT_ITEM_TYPE.DELETED;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ISyncMgrConflict_Value = Guid.initString("9c204249-c443-4ba4-85ed-c972681db137");
pub const IID_ISyncMgrConflict = &IID_ISyncMgrConflict_Value;
pub const ISyncMgrConflict = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrConflict,
                propkey: ?*const PROPERTYKEY,
                ppropvar: ?*PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrConflict,
                propkey: ?*const PROPERTYKEY,
                ppropvar: ?*PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetConflictIdInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrConflict,
                pConflictIdInfo: ?*SYNCMGR_CONFLICT_ID_INFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrConflict,
                pConflictIdInfo: ?*SYNCMGR_CONFLICT_ID_INFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetItemsArray: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrConflict,
                ppArray: ?*?*ISyncMgrConflictItems,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrConflict,
                ppArray: ?*?*ISyncMgrConflictItems,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Resolve: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrConflict,
                pResolveInfo: ?*ISyncMgrConflictResolveInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrConflict,
                pResolveInfo: ?*ISyncMgrConflictResolveInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetResolutionHandler: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrConflict,
                riid: ?*const Guid,
                ppvResolutionHandler: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrConflict,
                riid: ?*const Guid,
                ppvResolutionHandler: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrConflict_GetProperty(self: *const T, propkey: ?*const PROPERTYKEY, ppropvar: ?*PROPVARIANT) HRESULT {
                return @as(*const ISyncMgrConflict.VTable, @ptrCast(self.vtable)).GetProperty(@as(*const ISyncMgrConflict, @ptrCast(self)), propkey, ppropvar);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrConflict_GetConflictIdInfo(self: *const T, pConflictIdInfo: ?*SYNCMGR_CONFLICT_ID_INFO) HRESULT {
                return @as(*const ISyncMgrConflict.VTable, @ptrCast(self.vtable)).GetConflictIdInfo(@as(*const ISyncMgrConflict, @ptrCast(self)), pConflictIdInfo);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrConflict_GetItemsArray(self: *const T, ppArray: ?*?*ISyncMgrConflictItems) HRESULT {
                return @as(*const ISyncMgrConflict.VTable, @ptrCast(self.vtable)).GetItemsArray(@as(*const ISyncMgrConflict, @ptrCast(self)), ppArray);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrConflict_Resolve(self: *const T, pResolveInfo: ?*ISyncMgrConflictResolveInfo) HRESULT {
                return @as(*const ISyncMgrConflict.VTable, @ptrCast(self.vtable)).Resolve(@as(*const ISyncMgrConflict, @ptrCast(self)), pResolveInfo);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrConflict_GetResolutionHandler(self: *const T, riid: ?*const Guid, ppvResolutionHandler: ?*?*anyopaque) HRESULT {
                return @as(*const ISyncMgrConflict.VTable, @ptrCast(self.vtable)).GetResolutionHandler(@as(*const ISyncMgrConflict, @ptrCast(self)), riid, ppvResolutionHandler);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SYNCMGR_RESOLUTION_ABILITIES = enum(i32) {
    KEEPOTHER = 1,
    KEEPRECENT = 2,
    REMOVEFROMSYNCSET = 4,
    KEEP_SINGLE = 8,
    KEEP_MULTIPLE = 16,
    VALID = 31,
};
pub const SYNCMGR_RA_KEEPOTHER = SYNCMGR_RESOLUTION_ABILITIES.KEEPOTHER;
pub const SYNCMGR_RA_KEEPRECENT = SYNCMGR_RESOLUTION_ABILITIES.KEEPRECENT;
pub const SYNCMGR_RA_REMOVEFROMSYNCSET = SYNCMGR_RESOLUTION_ABILITIES.REMOVEFROMSYNCSET;
pub const SYNCMGR_RA_KEEP_SINGLE = SYNCMGR_RESOLUTION_ABILITIES.KEEP_SINGLE;
pub const SYNCMGR_RA_KEEP_MULTIPLE = SYNCMGR_RESOLUTION_ABILITIES.KEEP_MULTIPLE;
pub const SYNCMGR_RA_VALID = SYNCMGR_RESOLUTION_ABILITIES.VALID;

pub const SYNCMGR_RESOLUTION_FEEDBACK = enum(i32) {
    CONTINUE = 0,
    REFRESH = 1,
    CANCEL = 2,
};
pub const SYNCMGR_RF_CONTINUE = SYNCMGR_RESOLUTION_FEEDBACK.CONTINUE;
pub const SYNCMGR_RF_REFRESH = SYNCMGR_RESOLUTION_FEEDBACK.REFRESH;
pub const SYNCMGR_RF_CANCEL = SYNCMGR_RESOLUTION_FEEDBACK.CANCEL;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ISyncMgrResolutionHandler_Value = Guid.initString("40a3d052-8bff-4c4b-a338-d4a395700de9");
pub const IID_ISyncMgrResolutionHandler = &IID_ISyncMgrResolutionHandler_Value;
pub const ISyncMgrResolutionHandler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryAbilities: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrResolutionHandler,
                pdwAbilities: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrResolutionHandler,
                pdwAbilities: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        KeepOther: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrResolutionHandler,
                psiOther: ?*IShellItem,
                pFeedback: ?*SYNCMGR_RESOLUTION_FEEDBACK,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrResolutionHandler,
                psiOther: ?*IShellItem,
                pFeedback: ?*SYNCMGR_RESOLUTION_FEEDBACK,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        KeepRecent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrResolutionHandler,
                pFeedback: ?*SYNCMGR_RESOLUTION_FEEDBACK,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrResolutionHandler,
                pFeedback: ?*SYNCMGR_RESOLUTION_FEEDBACK,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveFromSyncSet: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrResolutionHandler,
                pFeedback: ?*SYNCMGR_RESOLUTION_FEEDBACK,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrResolutionHandler,
                pFeedback: ?*SYNCMGR_RESOLUTION_FEEDBACK,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        KeepItems: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrResolutionHandler,
                pArray: ?*ISyncMgrConflictResolutionItems,
                pFeedback: ?*SYNCMGR_RESOLUTION_FEEDBACK,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrResolutionHandler,
                pArray: ?*ISyncMgrConflictResolutionItems,
                pFeedback: ?*SYNCMGR_RESOLUTION_FEEDBACK,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrResolutionHandler_QueryAbilities(self: *const T, pdwAbilities: ?*u32) HRESULT {
                return @as(*const ISyncMgrResolutionHandler.VTable, @ptrCast(self.vtable)).QueryAbilities(@as(*const ISyncMgrResolutionHandler, @ptrCast(self)), pdwAbilities);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrResolutionHandler_KeepOther(self: *const T, psiOther: ?*IShellItem, pFeedback: ?*SYNCMGR_RESOLUTION_FEEDBACK) HRESULT {
                return @as(*const ISyncMgrResolutionHandler.VTable, @ptrCast(self.vtable)).KeepOther(@as(*const ISyncMgrResolutionHandler, @ptrCast(self)), psiOther, pFeedback);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrResolutionHandler_KeepRecent(self: *const T, pFeedback: ?*SYNCMGR_RESOLUTION_FEEDBACK) HRESULT {
                return @as(*const ISyncMgrResolutionHandler.VTable, @ptrCast(self.vtable)).KeepRecent(@as(*const ISyncMgrResolutionHandler, @ptrCast(self)), pFeedback);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrResolutionHandler_RemoveFromSyncSet(self: *const T, pFeedback: ?*SYNCMGR_RESOLUTION_FEEDBACK) HRESULT {
                return @as(*const ISyncMgrResolutionHandler.VTable, @ptrCast(self.vtable)).RemoveFromSyncSet(@as(*const ISyncMgrResolutionHandler, @ptrCast(self)), pFeedback);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrResolutionHandler_KeepItems(self: *const T, pArray: ?*ISyncMgrConflictResolutionItems, pFeedback: ?*SYNCMGR_RESOLUTION_FEEDBACK) HRESULT {
                return @as(*const ISyncMgrResolutionHandler.VTable, @ptrCast(self.vtable)).KeepItems(@as(*const ISyncMgrResolutionHandler, @ptrCast(self)), pArray, pFeedback);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ISyncMgrConflictPresenter_Value = Guid.initString("0b4f5353-fd2b-42cd-8763-4779f2d508a3");
pub const IID_ISyncMgrConflictPresenter = &IID_ISyncMgrConflictPresenter_Value;
pub const ISyncMgrConflictPresenter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        PresentConflict: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrConflictPresenter,
                pConflict: ?*ISyncMgrConflict,
                pResolveInfo: ?*ISyncMgrConflictResolveInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrConflictPresenter,
                pConflict: ?*ISyncMgrConflict,
                pResolveInfo: ?*ISyncMgrConflictResolveInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrConflictPresenter_PresentConflict(self: *const T, pConflict: ?*ISyncMgrConflict, pResolveInfo: ?*ISyncMgrConflictResolveInfo) HRESULT {
                return @as(*const ISyncMgrConflictPresenter.VTable, @ptrCast(self.vtable)).PresentConflict(@as(*const ISyncMgrConflictPresenter, @ptrCast(self)), pConflict, pResolveInfo);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SYNCMGR_PRESENTER_NEXT_STEP = enum(i32) {
    CONTINUE = 0,
    DEFAULT = 1,
    CANCEL = 2,
};
pub const SYNCMGR_PNS_CONTINUE = SYNCMGR_PRESENTER_NEXT_STEP.CONTINUE;
pub const SYNCMGR_PNS_DEFAULT = SYNCMGR_PRESENTER_NEXT_STEP.DEFAULT;
pub const SYNCMGR_PNS_CANCEL = SYNCMGR_PRESENTER_NEXT_STEP.CANCEL;

pub const SYNCMGR_PRESENTER_CHOICE = enum(i32) {
    NO_CHOICE = 0,
    KEEP_ONE = 1,
    KEEP_MULTIPLE = 2,
    KEEP_RECENT = 3,
    REMOVE_FROM_SYNC_SET = 4,
    SKIP = 5,
};
pub const SYNCMGR_PC_NO_CHOICE = SYNCMGR_PRESENTER_CHOICE.NO_CHOICE;
pub const SYNCMGR_PC_KEEP_ONE = SYNCMGR_PRESENTER_CHOICE.KEEP_ONE;
pub const SYNCMGR_PC_KEEP_MULTIPLE = SYNCMGR_PRESENTER_CHOICE.KEEP_MULTIPLE;
pub const SYNCMGR_PC_KEEP_RECENT = SYNCMGR_PRESENTER_CHOICE.KEEP_RECENT;
pub const SYNCMGR_PC_REMOVE_FROM_SYNC_SET = SYNCMGR_PRESENTER_CHOICE.REMOVE_FROM_SYNC_SET;
pub const SYNCMGR_PC_SKIP = SYNCMGR_PRESENTER_CHOICE.SKIP;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ISyncMgrConflictResolveInfo_Value = Guid.initString("c405a219-25a2-442e-8743-b845a2cee93f");
pub const IID_ISyncMgrConflictResolveInfo = &IID_ISyncMgrConflictResolveInfo_Value;
pub const ISyncMgrConflictResolveInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetIterationInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrConflictResolveInfo,
                pnCurrentConflict: ?*u32,
                pcConflicts: ?*u32,
                pcRemainingForApplyToAll: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrConflictResolveInfo,
                pnCurrentConflict: ?*u32,
                pcConflicts: ?*u32,
                pcRemainingForApplyToAll: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPresenterNextStep: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrConflictResolveInfo,
                pnPresenterNextStep: ?*SYNCMGR_PRESENTER_NEXT_STEP,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrConflictResolveInfo,
                pnPresenterNextStep: ?*SYNCMGR_PRESENTER_NEXT_STEP,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPresenterChoice: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrConflictResolveInfo,
                pnPresenterChoice: ?*SYNCMGR_PRESENTER_CHOICE,
                pfApplyToAll: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrConflictResolveInfo,
                pnPresenterChoice: ?*SYNCMGR_PRESENTER_CHOICE,
                pfApplyToAll: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetItemChoiceCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrConflictResolveInfo,
                pcChoices: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrConflictResolveInfo,
                pcChoices: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetItemChoice: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrConflictResolveInfo,
                iChoice: u32,
                piChoiceIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrConflictResolveInfo,
                iChoice: u32,
                piChoiceIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPresenterNextStep: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrConflictResolveInfo,
                nPresenterNextStep: SYNCMGR_PRESENTER_NEXT_STEP,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrConflictResolveInfo,
                nPresenterNextStep: SYNCMGR_PRESENTER_NEXT_STEP,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPresenterChoice: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrConflictResolveInfo,
                nPresenterChoice: SYNCMGR_PRESENTER_CHOICE,
                fApplyToAll: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrConflictResolveInfo,
                nPresenterChoice: SYNCMGR_PRESENTER_CHOICE,
                fApplyToAll: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetItemChoices: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrConflictResolveInfo,
                prgiConflictItemIndexes: ?*u32,
                cChoices: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrConflictResolveInfo,
                prgiConflictItemIndexes: ?*u32,
                cChoices: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrConflictResolveInfo_GetIterationInfo(self: *const T, pnCurrentConflict: ?*u32, pcConflicts: ?*u32, pcRemainingForApplyToAll: ?*u32) HRESULT {
                return @as(*const ISyncMgrConflictResolveInfo.VTable, @ptrCast(self.vtable)).GetIterationInfo(@as(*const ISyncMgrConflictResolveInfo, @ptrCast(self)), pnCurrentConflict, pcConflicts, pcRemainingForApplyToAll);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrConflictResolveInfo_GetPresenterNextStep(self: *const T, pnPresenterNextStep: ?*SYNCMGR_PRESENTER_NEXT_STEP) HRESULT {
                return @as(*const ISyncMgrConflictResolveInfo.VTable, @ptrCast(self.vtable)).GetPresenterNextStep(@as(*const ISyncMgrConflictResolveInfo, @ptrCast(self)), pnPresenterNextStep);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrConflictResolveInfo_GetPresenterChoice(self: *const T, pnPresenterChoice: ?*SYNCMGR_PRESENTER_CHOICE, pfApplyToAll: ?*BOOL) HRESULT {
                return @as(*const ISyncMgrConflictResolveInfo.VTable, @ptrCast(self.vtable)).GetPresenterChoice(@as(*const ISyncMgrConflictResolveInfo, @ptrCast(self)), pnPresenterChoice, pfApplyToAll);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrConflictResolveInfo_GetItemChoiceCount(self: *const T, pcChoices: ?*u32) HRESULT {
                return @as(*const ISyncMgrConflictResolveInfo.VTable, @ptrCast(self.vtable)).GetItemChoiceCount(@as(*const ISyncMgrConflictResolveInfo, @ptrCast(self)), pcChoices);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrConflictResolveInfo_GetItemChoice(self: *const T, iChoice: u32, piChoiceIndex: ?*u32) HRESULT {
                return @as(*const ISyncMgrConflictResolveInfo.VTable, @ptrCast(self.vtable)).GetItemChoice(@as(*const ISyncMgrConflictResolveInfo, @ptrCast(self)), iChoice, piChoiceIndex);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrConflictResolveInfo_SetPresenterNextStep(self: *const T, nPresenterNextStep: SYNCMGR_PRESENTER_NEXT_STEP) HRESULT {
                return @as(*const ISyncMgrConflictResolveInfo.VTable, @ptrCast(self.vtable)).SetPresenterNextStep(@as(*const ISyncMgrConflictResolveInfo, @ptrCast(self)), nPresenterNextStep);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrConflictResolveInfo_SetPresenterChoice(self: *const T, nPresenterChoice: SYNCMGR_PRESENTER_CHOICE, fApplyToAll: BOOL) HRESULT {
                return @as(*const ISyncMgrConflictResolveInfo.VTable, @ptrCast(self.vtable)).SetPresenterChoice(@as(*const ISyncMgrConflictResolveInfo, @ptrCast(self)), nPresenterChoice, fApplyToAll);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrConflictResolveInfo_SetItemChoices(self: *const T, prgiConflictItemIndexes: ?*u32, cChoices: u32) HRESULT {
                return @as(*const ISyncMgrConflictResolveInfo.VTable, @ptrCast(self.vtable)).SetItemChoices(@as(*const ISyncMgrConflictResolveInfo, @ptrCast(self)), prgiConflictItemIndexes, cChoices);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ISyncMgrConflictFolder_Value = Guid.initString("59287f5e-bc81-4fca-a7f1-e5a8ecdb1d69");
pub const IID_ISyncMgrConflictFolder = &IID_ISyncMgrConflictFolder_Value;
pub const ISyncMgrConflictFolder = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetConflictIDList: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrConflictFolder,
                pConflict: ?*ISyncMgrConflict,
                ppidlConflict: ?*?*ITEMIDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrConflictFolder,
                pConflict: ?*ISyncMgrConflict,
                ppidlConflict: ?*?*ITEMIDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrConflictFolder_GetConflictIDList(self: *const T, pConflict: ?*ISyncMgrConflict, ppidlConflict: ?*?*ITEMIDLIST) HRESULT {
                return @as(*const ISyncMgrConflictFolder.VTable, @ptrCast(self.vtable)).GetConflictIDList(@as(*const ISyncMgrConflictFolder, @ptrCast(self)), pConflict, ppidlConflict);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const CONFIRM_CONFLICT_ITEM = extern struct {
    pShellItem: ?*IShellItem2,
    pszOriginalName: ?PWSTR,
    pszAlternateName: ?PWSTR,
    pszLocationShort: ?PWSTR,
    pszLocationFull: ?PWSTR,
    nType: SYNCMGR_CONFLICT_ITEM_TYPE,
};

pub const CONFIRM_CONFLICT_RESULT_INFO = extern struct {
    pszNewName: ?PWSTR,
    iItemIndex: u32,
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ISyncMgrConflictItems_Value = Guid.initString("9c7ead52-8023-4936-a4db-d2a9a99e436a");
pub const IID_ISyncMgrConflictItems = &IID_ISyncMgrConflictItems_Value;
pub const ISyncMgrConflictItems = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrConflictItems,
                pCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrConflictItems,
                pCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrConflictItems,
                iIndex: u32,
                pItemInfo: ?*CONFIRM_CONFLICT_ITEM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrConflictItems,
                iIndex: u32,
                pItemInfo: ?*CONFIRM_CONFLICT_ITEM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrConflictItems_GetCount(self: *const T, pCount: ?*u32) HRESULT {
                return @as(*const ISyncMgrConflictItems.VTable, @ptrCast(self.vtable)).GetCount(@as(*const ISyncMgrConflictItems, @ptrCast(self)), pCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrConflictItems_GetItem(self: *const T, iIndex: u32, pItemInfo: ?*CONFIRM_CONFLICT_ITEM) HRESULT {
                return @as(*const ISyncMgrConflictItems.VTable, @ptrCast(self.vtable)).GetItem(@as(*const ISyncMgrConflictItems, @ptrCast(self)), iIndex, pItemInfo);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ISyncMgrConflictResolutionItems_Value = Guid.initString("458725b9-129d-4135-a998-9ceafec27007");
pub const IID_ISyncMgrConflictResolutionItems = &IID_ISyncMgrConflictResolutionItems_Value;
pub const ISyncMgrConflictResolutionItems = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrConflictResolutionItems,
                pCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrConflictResolutionItems,
                pCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrConflictResolutionItems,
                iIndex: u32,
                pItemInfo: ?*CONFIRM_CONFLICT_RESULT_INFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrConflictResolutionItems,
                iIndex: u32,
                pItemInfo: ?*CONFIRM_CONFLICT_RESULT_INFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrConflictResolutionItems_GetCount(self: *const T, pCount: ?*u32) HRESULT {
                return @as(*const ISyncMgrConflictResolutionItems.VTable, @ptrCast(self.vtable)).GetCount(@as(*const ISyncMgrConflictResolutionItems, @ptrCast(self)), pCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrConflictResolutionItems_GetItem(self: *const T, iIndex: u32, pItemInfo: ?*CONFIRM_CONFLICT_RESULT_INFO) HRESULT {
                return @as(*const ISyncMgrConflictResolutionItems.VTable, @ptrCast(self.vtable)).GetItem(@as(*const ISyncMgrConflictResolutionItems, @ptrCast(self)), iIndex, pItemInfo);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const CLSID_InputPanelConfiguration_Value = Guid.initString("2853add3-f096-4c63-a78f-7fa3ea837fb7");
pub const CLSID_InputPanelConfiguration = &CLSID_InputPanelConfiguration_Value;

// TODO: this type is limited to platform 'windows8.0'
const IID_IInputPanelConfiguration_Value = Guid.initString("41c81592-514c-48bd-a22e-e6af638521a6");
pub const IID_IInputPanelConfiguration = &IID_IInputPanelConfiguration_Value;
pub const IInputPanelConfiguration = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EnableFocusTracking: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInputPanelConfiguration,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInputPanelConfiguration,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInputPanelConfiguration_EnableFocusTracking(self: *const T) HRESULT {
                return @as(*const IInputPanelConfiguration.VTable, @ptrCast(self.vtable)).EnableFocusTracking(@as(*const IInputPanelConfiguration, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IInputPanelInvocationConfiguration_Value = Guid.initString("a213f136-3b45-4362-a332-efb6547cd432");
pub const IID_IInputPanelInvocationConfiguration = &IID_IInputPanelInvocationConfiguration_Value;
pub const IInputPanelInvocationConfiguration = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RequireTouchInEditControl: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInputPanelInvocationConfiguration,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInputPanelInvocationConfiguration,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInputPanelInvocationConfiguration_RequireTouchInEditControl(self: *const T) HRESULT {
                return @as(*const IInputPanelInvocationConfiguration.VTable, @ptrCast(self.vtable)).RequireTouchInEditControl(@as(*const IInputPanelInvocationConfiguration, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const CLSID_LocalThumbnailCache_Value = Guid.initString("50ef4544-ac9f-4a8e-b21b-8a26180db13f");
pub const CLSID_LocalThumbnailCache = &CLSID_LocalThumbnailCache_Value;

const CLSID_SharedBitmap_Value = Guid.initString("4db26476-6787-4046-b836-e8412a9e8a27");
pub const CLSID_SharedBitmap = &CLSID_SharedBitmap_Value;

pub const WTS_FLAGS = enum(i32) {
    NONE = 0,
    // EXTRACT = 0, this enum value conflicts with NONE
    INCACHEONLY = 1,
    FASTEXTRACT = 2,
    FORCEEXTRACTION = 4,
    SLOWRECLAIM = 8,
    EXTRACTDONOTCACHE = 32,
    SCALETOREQUESTEDSIZE = 64,
    SKIPFASTEXTRACT = 128,
    EXTRACTINPROC = 256,
    CROPTOSQUARE = 512,
    INSTANCESURROGATE = 1024,
    REQUIRESURROGATE = 2048,
    APPSTYLE = 8192,
    WIDETHUMBNAILS = 16384,
    IDEALCACHESIZEONLY = 32768,
    SCALEUP = 65536,
};
pub const WTS_NONE = WTS_FLAGS.NONE;
pub const WTS_EXTRACT = WTS_FLAGS.NONE;
pub const WTS_INCACHEONLY = WTS_FLAGS.INCACHEONLY;
pub const WTS_FASTEXTRACT = WTS_FLAGS.FASTEXTRACT;
pub const WTS_FORCEEXTRACTION = WTS_FLAGS.FORCEEXTRACTION;
pub const WTS_SLOWRECLAIM = WTS_FLAGS.SLOWRECLAIM;
pub const WTS_EXTRACTDONOTCACHE = WTS_FLAGS.EXTRACTDONOTCACHE;
pub const WTS_SCALETOREQUESTEDSIZE = WTS_FLAGS.SCALETOREQUESTEDSIZE;
pub const WTS_SKIPFASTEXTRACT = WTS_FLAGS.SKIPFASTEXTRACT;
pub const WTS_EXTRACTINPROC = WTS_FLAGS.EXTRACTINPROC;
pub const WTS_CROPTOSQUARE = WTS_FLAGS.CROPTOSQUARE;
pub const WTS_INSTANCESURROGATE = WTS_FLAGS.INSTANCESURROGATE;
pub const WTS_REQUIRESURROGATE = WTS_FLAGS.REQUIRESURROGATE;
pub const WTS_APPSTYLE = WTS_FLAGS.APPSTYLE;
pub const WTS_WIDETHUMBNAILS = WTS_FLAGS.WIDETHUMBNAILS;
pub const WTS_IDEALCACHESIZEONLY = WTS_FLAGS.IDEALCACHESIZEONLY;
pub const WTS_SCALEUP = WTS_FLAGS.SCALEUP;

pub const WTS_CACHEFLAGS = enum(i32) {
    DEFAULT = 0,
    LOWQUALITY = 1,
    CACHED = 2,
};
pub const WTS_DEFAULT = WTS_CACHEFLAGS.DEFAULT;
pub const WTS_LOWQUALITY = WTS_CACHEFLAGS.LOWQUALITY;
pub const WTS_CACHED = WTS_CACHEFLAGS.CACHED;

pub const WTS_CONTEXTFLAGS = enum(i32) {
    DEFAULT = 0,
    APPSTYLE = 1,
    SQUARE = 2,
    WIDE = 4,
    FAST = 8,
};
pub const WTSCF_DEFAULT = WTS_CONTEXTFLAGS.DEFAULT;
pub const WTSCF_APPSTYLE = WTS_CONTEXTFLAGS.APPSTYLE;
pub const WTSCF_SQUARE = WTS_CONTEXTFLAGS.SQUARE;
pub const WTSCF_WIDE = WTS_CONTEXTFLAGS.WIDE;
pub const WTSCF_FAST = WTS_CONTEXTFLAGS.FAST;

pub const WTS_ALPHATYPE = enum(i32) {
    UNKNOWN = 0,
    RGB = 1,
    ARGB = 2,
};
pub const WTSAT_UNKNOWN = WTS_ALPHATYPE.UNKNOWN;
pub const WTSAT_RGB = WTS_ALPHATYPE.RGB;
pub const WTSAT_ARGB = WTS_ALPHATYPE.ARGB;

pub const WTS_THUMBNAILID = extern struct {
    rgbKey: [16]u8,
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ISharedBitmap_Value = Guid.initString("091162a4-bc96-411f-aae8-c5122cd03363");
pub const IID_ISharedBitmap = &IID_ISharedBitmap_Value;
pub const ISharedBitmap = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSharedBitmap: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISharedBitmap,
                phbm: ?*?HBITMAP,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISharedBitmap,
                phbm: ?*?HBITMAP,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISharedBitmap,
                pSize: ?*SIZE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISharedBitmap,
                pSize: ?*SIZE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFormat: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISharedBitmap,
                pat: ?*WTS_ALPHATYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISharedBitmap,
                pat: ?*WTS_ALPHATYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InitializeBitmap: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISharedBitmap,
                hbm: ?HBITMAP,
                wtsAT: WTS_ALPHATYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISharedBitmap,
                hbm: ?HBITMAP,
                wtsAT: WTS_ALPHATYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Detach: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISharedBitmap,
                phbm: ?*?HBITMAP,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISharedBitmap,
                phbm: ?*?HBITMAP,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISharedBitmap_GetSharedBitmap(self: *const T, phbm: ?*?HBITMAP) HRESULT {
                return @as(*const ISharedBitmap.VTable, @ptrCast(self.vtable)).GetSharedBitmap(@as(*const ISharedBitmap, @ptrCast(self)), phbm);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISharedBitmap_GetSize(self: *const T, pSize: ?*SIZE) HRESULT {
                return @as(*const ISharedBitmap.VTable, @ptrCast(self.vtable)).GetSize(@as(*const ISharedBitmap, @ptrCast(self)), pSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISharedBitmap_GetFormat(self: *const T, pat: ?*WTS_ALPHATYPE) HRESULT {
                return @as(*const ISharedBitmap.VTable, @ptrCast(self.vtable)).GetFormat(@as(*const ISharedBitmap, @ptrCast(self)), pat);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISharedBitmap_InitializeBitmap(self: *const T, hbm: ?HBITMAP, wtsAT: WTS_ALPHATYPE) HRESULT {
                return @as(*const ISharedBitmap.VTable, @ptrCast(self.vtable)).InitializeBitmap(@as(*const ISharedBitmap, @ptrCast(self)), hbm, wtsAT);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISharedBitmap_Detach(self: *const T, phbm: ?*?HBITMAP) HRESULT {
                return @as(*const ISharedBitmap.VTable, @ptrCast(self.vtable)).Detach(@as(*const ISharedBitmap, @ptrCast(self)), phbm);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IThumbnailCache_Value = Guid.initString("f676c15d-596a-4ce2-8234-33996f445db1");
pub const IID_IThumbnailCache = &IID_IThumbnailCache_Value;
pub const IThumbnailCache = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetThumbnail: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IThumbnailCache,
                pShellItem: ?*IShellItem,
                cxyRequestedThumbSize: u32,
                flags: WTS_FLAGS,
                ppvThumb: ?*?*ISharedBitmap,
                pOutFlags: ?*WTS_CACHEFLAGS,
                pThumbnailID: ?*WTS_THUMBNAILID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IThumbnailCache,
                pShellItem: ?*IShellItem,
                cxyRequestedThumbSize: u32,
                flags: WTS_FLAGS,
                ppvThumb: ?*?*ISharedBitmap,
                pOutFlags: ?*WTS_CACHEFLAGS,
                pThumbnailID: ?*WTS_THUMBNAILID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetThumbnailByID: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IThumbnailCache,
                thumbnailID: WTS_THUMBNAILID,
                cxyRequestedThumbSize: u32,
                ppvThumb: ?*?*ISharedBitmap,
                pOutFlags: ?*WTS_CACHEFLAGS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IThumbnailCache,
                thumbnailID: WTS_THUMBNAILID,
                cxyRequestedThumbSize: u32,
                ppvThumb: ?*?*ISharedBitmap,
                pOutFlags: ?*WTS_CACHEFLAGS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IThumbnailCache_GetThumbnail(self: *const T, pShellItem: ?*IShellItem, cxyRequestedThumbSize: u32, flags: WTS_FLAGS, ppvThumb: ?*?*ISharedBitmap, pOutFlags: ?*WTS_CACHEFLAGS, pThumbnailID: ?*WTS_THUMBNAILID) HRESULT {
                return @as(*const IThumbnailCache.VTable, @ptrCast(self.vtable)).GetThumbnail(@as(*const IThumbnailCache, @ptrCast(self)), pShellItem, cxyRequestedThumbSize, flags, ppvThumb, pOutFlags, pThumbnailID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IThumbnailCache_GetThumbnailByID(self: *const T, thumbnailID: WTS_THUMBNAILID, cxyRequestedThumbSize: u32, ppvThumb: ?*?*ISharedBitmap, pOutFlags: ?*WTS_CACHEFLAGS) HRESULT {
                return @as(*const IThumbnailCache.VTable, @ptrCast(self.vtable)).GetThumbnailByID(@as(*const IThumbnailCache, @ptrCast(self)), thumbnailID, cxyRequestedThumbSize, ppvThumb, pOutFlags);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IThumbnailProvider_Value = Guid.initString("e357fccd-a995-4576-b01f-234630154e96");
pub const IID_IThumbnailProvider = &IID_IThumbnailProvider_Value;
pub const IThumbnailProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetThumbnail: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IThumbnailProvider,
                cx: u32,
                phbmp: ?*?HBITMAP,
                pdwAlpha: ?*WTS_ALPHATYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IThumbnailProvider,
                cx: u32,
                phbmp: ?*?HBITMAP,
                pdwAlpha: ?*WTS_ALPHATYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IThumbnailProvider_GetThumbnail(self: *const T, cx: u32, phbmp: ?*?HBITMAP, pdwAlpha: ?*WTS_ALPHATYPE) HRESULT {
                return @as(*const IThumbnailProvider.VTable, @ptrCast(self.vtable)).GetThumbnail(@as(*const IThumbnailProvider, @ptrCast(self)), cx, phbmp, pdwAlpha);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IThumbnailSettings_Value = Guid.initString("f4376f00-bef5-4d45-80f3-1e023bbf1209");
pub const IID_IThumbnailSettings = &IID_IThumbnailSettings_Value;
pub const IThumbnailSettings = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IThumbnailSettings,
                dwContext: WTS_CONTEXTFLAGS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IThumbnailSettings,
                dwContext: WTS_CONTEXTFLAGS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IThumbnailSettings_SetContext(self: *const T, dwContext: WTS_CONTEXTFLAGS) HRESULT {
                return @as(*const IThumbnailSettings.VTable, @ptrCast(self.vtable)).SetContext(@as(*const IThumbnailSettings, @ptrCast(self)), dwContext);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IThumbnailCachePrimer_Value = Guid.initString("0f03f8fe-2b26-46f0-965a-212aa8d66b76");
pub const IID_IThumbnailCachePrimer = &IID_IThumbnailCachePrimer_Value;
pub const IThumbnailCachePrimer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        PageInThumbnail: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IThumbnailCachePrimer,
                psi: ?*IShellItem,
                wtsFlags: WTS_FLAGS,
                cxyRequestedThumbSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IThumbnailCachePrimer,
                psi: ?*IShellItem,
                wtsFlags: WTS_FLAGS,
                cxyRequestedThumbSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IThumbnailCachePrimer_PageInThumbnail(self: *const T, psi: ?*IShellItem, wtsFlags: WTS_FLAGS, cxyRequestedThumbSize: u32) HRESULT {
                return @as(*const IThumbnailCachePrimer.VTable, @ptrCast(self.vtable)).PageInThumbnail(@as(*const IThumbnailCachePrimer, @ptrCast(self)), psi, wtsFlags, cxyRequestedThumbSize);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const CLSID_ShellImageDataFactory_Value = Guid.initString("66e4e4fb-f385-4dd0-8d74-a2efd1bc6178");
pub const CLSID_ShellImageDataFactory = &CLSID_ShellImageDataFactory_Value;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IShellImageDataFactory_Value = Guid.initString("9be8ed5c-edab-4d75-90f3-bd5bdbb21c82");
pub const IID_IShellImageDataFactory = &IID_IShellImageDataFactory_Value;
pub const IShellImageDataFactory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateIShellImageData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellImageDataFactory,
                ppshimg: ?*?*IShellImageData,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellImageDataFactory,
                ppshimg: ?*?*IShellImageData,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateImageFromFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellImageDataFactory,
                pszPath: ?[*:0]const u16,
                ppshimg: ?*?*IShellImageData,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellImageDataFactory,
                pszPath: ?[*:0]const u16,
                ppshimg: ?*?*IShellImageData,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateImageFromStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellImageDataFactory,
                pStream: ?*IStream,
                ppshimg: ?*?*IShellImageData,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellImageDataFactory,
                pStream: ?*IStream,
                ppshimg: ?*?*IShellImageData,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDataFormatFromPath: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellImageDataFactory,
                pszPath: ?[*:0]const u16,
                pDataFormat: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellImageDataFactory,
                pszPath: ?[*:0]const u16,
                pDataFormat: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellImageDataFactory_CreateIShellImageData(self: *const T, ppshimg: ?*?*IShellImageData) HRESULT {
                return @as(*const IShellImageDataFactory.VTable, @ptrCast(self.vtable)).CreateIShellImageData(@as(*const IShellImageDataFactory, @ptrCast(self)), ppshimg);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellImageDataFactory_CreateImageFromFile(self: *const T, pszPath: ?[*:0]const u16, ppshimg: ?*?*IShellImageData) HRESULT {
                return @as(*const IShellImageDataFactory.VTable, @ptrCast(self.vtable)).CreateImageFromFile(@as(*const IShellImageDataFactory, @ptrCast(self)), pszPath, ppshimg);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellImageDataFactory_CreateImageFromStream(self: *const T, pStream: ?*IStream, ppshimg: ?*?*IShellImageData) HRESULT {
                return @as(*const IShellImageDataFactory.VTable, @ptrCast(self.vtable)).CreateImageFromStream(@as(*const IShellImageDataFactory, @ptrCast(self)), pStream, ppshimg);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellImageDataFactory_GetDataFormatFromPath(self: *const T, pszPath: ?[*:0]const u16, pDataFormat: ?*Guid) HRESULT {
                return @as(*const IShellImageDataFactory.VTable, @ptrCast(self.vtable)).GetDataFormatFromPath(@as(*const IShellImageDataFactory, @ptrCast(self)), pszPath, pDataFormat);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IShellImageData_Value = Guid.initString("bfdeec12-8040-4403-a5ea-9e07dafcf530");
pub const IID_IShellImageData = &IID_IShellImageData_Value;
pub const IShellImageData = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Decode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellImageData,
                dwFlags: u32,
                cxDesired: u32,
                cyDesired: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellImageData,
                dwFlags: u32,
                cxDesired: u32,
                cyDesired: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Draw: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellImageData,
                hdc: ?HDC,
                prcDest: ?*RECT,
                prcSrc: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellImageData,
                hdc: ?HDC,
                prcDest: ?*RECT,
                prcSrc: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NextFrame: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellImageData,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellImageData,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NextPage: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellImageData,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellImageData,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PrevPage: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellImageData,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellImageData,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsTransparent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellImageData,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellImageData,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsAnimated: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellImageData,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellImageData,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsVector: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellImageData,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellImageData,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsMultipage: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellImageData,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellImageData,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsEditable: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellImageData,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellImageData,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsPrintable: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellImageData,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellImageData,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsDecoded: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellImageData,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellImageData,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentPage: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellImageData,
                pnPage: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellImageData,
                pnPage: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPageCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellImageData,
                pcPages: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellImageData,
                pcPages: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SelectPage: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellImageData,
                iPage: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellImageData,
                iPage: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellImageData,
                pSize: ?*SIZE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellImageData,
                pSize: ?*SIZE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRawDataFormat: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellImageData,
                pDataFormat: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellImageData,
                pDataFormat: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPixelFormat: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellImageData,
                pFormat: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellImageData,
                pFormat: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDelay: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellImageData,
                pdwDelay: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellImageData,
                pdwDelay: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProperties: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellImageData,
                dwMode: u32,
                ppPropSet: ?*?*IPropertySetStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellImageData,
                dwMode: u32,
                ppPropSet: ?*?*IPropertySetStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Rotate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellImageData,
                dwAngle: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellImageData,
                dwAngle: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Scale: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellImageData,
                cx: u32,
                cy: u32,
                hints: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellImageData,
                cx: u32,
                cy: u32,
                hints: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DiscardEdit: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellImageData,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellImageData,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEncoderParams: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellImageData,
                pbagEnc: ?*IPropertyBag,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellImageData,
                pbagEnc: ?*IPropertyBag,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DisplayName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellImageData,
                wszName: ?PWSTR,
                cch: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellImageData,
                wszName: ?PWSTR,
                cch: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetResolution: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellImageData,
                puResolutionX: ?*u32,
                puResolutionY: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellImageData,
                puResolutionX: ?*u32,
                puResolutionY: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEncoderParams: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellImageData,
                pguidFmt: ?*Guid,
                ppEncParams: ?*?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellImageData,
                pguidFmt: ?*Guid,
                ppEncParams: ?*?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RegisterAbort: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellImageData,
                pAbort: ?*IShellImageDataAbort,
                ppAbortPrev: ?*?*IShellImageDataAbort,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellImageData,
                pAbort: ?*IShellImageDataAbort,
                ppAbortPrev: ?*?*IShellImageDataAbort,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CloneFrame: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellImageData,
                ppImg: ?*?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellImageData,
                ppImg: ?*?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReplaceFrame: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellImageData,
                pImg: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellImageData,
                pImg: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellImageData_Decode(self: *const T, dwFlags: u32, cxDesired: u32, cyDesired: u32) HRESULT {
                return @as(*const IShellImageData.VTable, @ptrCast(self.vtable)).Decode(@as(*const IShellImageData, @ptrCast(self)), dwFlags, cxDesired, cyDesired);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellImageData_Draw(self: *const T, hdc: ?HDC, prcDest: ?*RECT, prcSrc: ?*RECT) HRESULT {
                return @as(*const IShellImageData.VTable, @ptrCast(self.vtable)).Draw(@as(*const IShellImageData, @ptrCast(self)), hdc, prcDest, prcSrc);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellImageData_NextFrame(self: *const T) HRESULT {
                return @as(*const IShellImageData.VTable, @ptrCast(self.vtable)).NextFrame(@as(*const IShellImageData, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellImageData_NextPage(self: *const T) HRESULT {
                return @as(*const IShellImageData.VTable, @ptrCast(self.vtable)).NextPage(@as(*const IShellImageData, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellImageData_PrevPage(self: *const T) HRESULT {
                return @as(*const IShellImageData.VTable, @ptrCast(self.vtable)).PrevPage(@as(*const IShellImageData, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellImageData_IsTransparent(self: *const T) HRESULT {
                return @as(*const IShellImageData.VTable, @ptrCast(self.vtable)).IsTransparent(@as(*const IShellImageData, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellImageData_IsAnimated(self: *const T) HRESULT {
                return @as(*const IShellImageData.VTable, @ptrCast(self.vtable)).IsAnimated(@as(*const IShellImageData, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellImageData_IsVector(self: *const T) HRESULT {
                return @as(*const IShellImageData.VTable, @ptrCast(self.vtable)).IsVector(@as(*const IShellImageData, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellImageData_IsMultipage(self: *const T) HRESULT {
                return @as(*const IShellImageData.VTable, @ptrCast(self.vtable)).IsMultipage(@as(*const IShellImageData, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellImageData_IsEditable(self: *const T) HRESULT {
                return @as(*const IShellImageData.VTable, @ptrCast(self.vtable)).IsEditable(@as(*const IShellImageData, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellImageData_IsPrintable(self: *const T) HRESULT {
                return @as(*const IShellImageData.VTable, @ptrCast(self.vtable)).IsPrintable(@as(*const IShellImageData, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellImageData_IsDecoded(self: *const T) HRESULT {
                return @as(*const IShellImageData.VTable, @ptrCast(self.vtable)).IsDecoded(@as(*const IShellImageData, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellImageData_GetCurrentPage(self: *const T, pnPage: ?*u32) HRESULT {
                return @as(*const IShellImageData.VTable, @ptrCast(self.vtable)).GetCurrentPage(@as(*const IShellImageData, @ptrCast(self)), pnPage);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellImageData_GetPageCount(self: *const T, pcPages: ?*u32) HRESULT {
                return @as(*const IShellImageData.VTable, @ptrCast(self.vtable)).GetPageCount(@as(*const IShellImageData, @ptrCast(self)), pcPages);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellImageData_SelectPage(self: *const T, iPage: u32) HRESULT {
                return @as(*const IShellImageData.VTable, @ptrCast(self.vtable)).SelectPage(@as(*const IShellImageData, @ptrCast(self)), iPage);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellImageData_GetSize(self: *const T, pSize: ?*SIZE) HRESULT {
                return @as(*const IShellImageData.VTable, @ptrCast(self.vtable)).GetSize(@as(*const IShellImageData, @ptrCast(self)), pSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellImageData_GetRawDataFormat(self: *const T, pDataFormat: ?*Guid) HRESULT {
                return @as(*const IShellImageData.VTable, @ptrCast(self.vtable)).GetRawDataFormat(@as(*const IShellImageData, @ptrCast(self)), pDataFormat);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellImageData_GetPixelFormat(self: *const T, pFormat: ?*u32) HRESULT {
                return @as(*const IShellImageData.VTable, @ptrCast(self.vtable)).GetPixelFormat(@as(*const IShellImageData, @ptrCast(self)), pFormat);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellImageData_GetDelay(self: *const T, pdwDelay: ?*u32) HRESULT {
                return @as(*const IShellImageData.VTable, @ptrCast(self.vtable)).GetDelay(@as(*const IShellImageData, @ptrCast(self)), pdwDelay);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellImageData_GetProperties(self: *const T, dwMode: u32, ppPropSet: ?*?*IPropertySetStorage) HRESULT {
                return @as(*const IShellImageData.VTable, @ptrCast(self.vtable)).GetProperties(@as(*const IShellImageData, @ptrCast(self)), dwMode, ppPropSet);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellImageData_Rotate(self: *const T, dwAngle: u32) HRESULT {
                return @as(*const IShellImageData.VTable, @ptrCast(self.vtable)).Rotate(@as(*const IShellImageData, @ptrCast(self)), dwAngle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellImageData_Scale(self: *const T, cx: u32, cy: u32, hints: u32) HRESULT {
                return @as(*const IShellImageData.VTable, @ptrCast(self.vtable)).Scale(@as(*const IShellImageData, @ptrCast(self)), cx, cy, hints);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellImageData_DiscardEdit(self: *const T) HRESULT {
                return @as(*const IShellImageData.VTable, @ptrCast(self.vtable)).DiscardEdit(@as(*const IShellImageData, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellImageData_SetEncoderParams(self: *const T, pbagEnc: ?*IPropertyBag) HRESULT {
                return @as(*const IShellImageData.VTable, @ptrCast(self.vtable)).SetEncoderParams(@as(*const IShellImageData, @ptrCast(self)), pbagEnc);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellImageData_DisplayName(self: *const T, wszName: ?PWSTR, cch: u32) HRESULT {
                return @as(*const IShellImageData.VTable, @ptrCast(self.vtable)).DisplayName(@as(*const IShellImageData, @ptrCast(self)), wszName, cch);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellImageData_GetResolution(self: *const T, puResolutionX: ?*u32, puResolutionY: ?*u32) HRESULT {
                return @as(*const IShellImageData.VTable, @ptrCast(self.vtable)).GetResolution(@as(*const IShellImageData, @ptrCast(self)), puResolutionX, puResolutionY);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellImageData_GetEncoderParams(self: *const T, pguidFmt: ?*Guid, ppEncParams: ?*?*u8) HRESULT {
                return @as(*const IShellImageData.VTable, @ptrCast(self.vtable)).GetEncoderParams(@as(*const IShellImageData, @ptrCast(self)), pguidFmt, ppEncParams);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellImageData_RegisterAbort(self: *const T, pAbort: ?*IShellImageDataAbort, ppAbortPrev: ?*?*IShellImageDataAbort) HRESULT {
                return @as(*const IShellImageData.VTable, @ptrCast(self.vtable)).RegisterAbort(@as(*const IShellImageData, @ptrCast(self)), pAbort, ppAbortPrev);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellImageData_CloneFrame(self: *const T, ppImg: ?*?*u8) HRESULT {
                return @as(*const IShellImageData.VTable, @ptrCast(self.vtable)).CloneFrame(@as(*const IShellImageData, @ptrCast(self)), ppImg);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellImageData_ReplaceFrame(self: *const T, pImg: ?*u8) HRESULT {
                return @as(*const IShellImageData.VTable, @ptrCast(self.vtable)).ReplaceFrame(@as(*const IShellImageData, @ptrCast(self)), pImg);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IShellImageDataAbort_Value = Guid.initString("53fb8e58-50c0-4003-b4aa-0c8df28e7f3a");
pub const IID_IShellImageDataAbort = &IID_IShellImageDataAbort_Value;
pub const IShellImageDataAbort = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryAbort: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellImageDataAbort,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellImageDataAbort,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellImageDataAbort_QueryAbort(self: *const T) HRESULT {
                return @as(*const IShellImageDataAbort.VTable, @ptrCast(self.vtable)).QueryAbort(@as(*const IShellImageDataAbort, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IStorageProviderPropertyHandler_Value = Guid.initString("301dfbe5-524c-4b0f-8b2d-21c40b3a2988");
pub const IID_IStorageProviderPropertyHandler = &IID_IStorageProviderPropertyHandler_Value;
pub const IStorageProviderPropertyHandler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RetrieveProperties: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IStorageProviderPropertyHandler,
                propertiesToRetrieve: [*]const PROPERTYKEY,
                propertiesToRetrieveCount: u32,
                retrievedProperties: ?*?*IPropertyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IStorageProviderPropertyHandler,
                propertiesToRetrieve: [*]const PROPERTYKEY,
                propertiesToRetrieveCount: u32,
                retrievedProperties: ?*?*IPropertyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SaveProperties: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IStorageProviderPropertyHandler,
                propertiesToSave: ?*IPropertyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IStorageProviderPropertyHandler,
                propertiesToSave: ?*IPropertyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IStorageProviderPropertyHandler_RetrieveProperties(self: *const T, propertiesToRetrieve: [*]const PROPERTYKEY, propertiesToRetrieveCount: u32, retrievedProperties: ?*?*IPropertyStore) HRESULT {
                return @as(*const IStorageProviderPropertyHandler.VTable, @ptrCast(self.vtable)).RetrieveProperties(@as(*const IStorageProviderPropertyHandler, @ptrCast(self)), propertiesToRetrieve, propertiesToRetrieveCount, retrievedProperties);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IStorageProviderPropertyHandler_SaveProperties(self: *const T, propertiesToSave: ?*IPropertyStore) HRESULT {
                return @as(*const IStorageProviderPropertyHandler.VTable, @ptrCast(self.vtable)).SaveProperties(@as(*const IStorageProviderPropertyHandler, @ptrCast(self)), propertiesToSave);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IStorageProviderHandler_Value = Guid.initString("162c6fb5-44d3-435b-903d-e613fa093fb5");
pub const IID_IStorageProviderHandler = &IID_IStorageProviderHandler_Value;
pub const IStorageProviderHandler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPropertyHandlerFromPath: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IStorageProviderHandler,
                path: ?[*:0]const u16,
                propertyHandler: ?*?*IStorageProviderPropertyHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IStorageProviderHandler,
                path: ?[*:0]const u16,
                propertyHandler: ?*?*IStorageProviderPropertyHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPropertyHandlerFromUri: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IStorageProviderHandler,
                uri: ?[*:0]const u16,
                propertyHandler: ?*?*IStorageProviderPropertyHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IStorageProviderHandler,
                uri: ?[*:0]const u16,
                propertyHandler: ?*?*IStorageProviderPropertyHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPropertyHandlerFromFileId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IStorageProviderHandler,
                fileId: ?[*:0]const u16,
                propertyHandler: ?*?*IStorageProviderPropertyHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IStorageProviderHandler,
                fileId: ?[*:0]const u16,
                propertyHandler: ?*?*IStorageProviderPropertyHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IStorageProviderHandler_GetPropertyHandlerFromPath(self: *const T, path: ?[*:0]const u16, propertyHandler: ?*?*IStorageProviderPropertyHandler) HRESULT {
                return @as(*const IStorageProviderHandler.VTable, @ptrCast(self.vtable)).GetPropertyHandlerFromPath(@as(*const IStorageProviderHandler, @ptrCast(self)), path, propertyHandler);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IStorageProviderHandler_GetPropertyHandlerFromUri(self: *const T, uri: ?[*:0]const u16, propertyHandler: ?*?*IStorageProviderPropertyHandler) HRESULT {
                return @as(*const IStorageProviderHandler.VTable, @ptrCast(self.vtable)).GetPropertyHandlerFromUri(@as(*const IStorageProviderHandler, @ptrCast(self)), uri, propertyHandler);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IStorageProviderHandler_GetPropertyHandlerFromFileId(self: *const T, fileId: ?[*:0]const u16, propertyHandler: ?*?*IStorageProviderPropertyHandler) HRESULT {
                return @as(*const IStorageProviderHandler.VTable, @ptrCast(self.vtable)).GetPropertyHandlerFromFileId(@as(*const IStorageProviderHandler, @ptrCast(self)), fileId, propertyHandler);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const CLSID_SyncMgr_Value = Guid.initString("6295df27-35ee-11d1-8707-00c04fd93327");
pub const CLSID_SyncMgr = &CLSID_SyncMgr_Value;

pub const SYNCMGRSTATUS = enum(i32) {
    STOPPED = 0,
    SKIPPED = 1,
    PENDING = 2,
    UPDATING = 3,
    SUCCEEDED = 4,
    FAILED = 5,
    PAUSED = 6,
    RESUMING = 7,
    UPDATING_INDETERMINATE = 8,
    DELETED = 256,
};
pub const SYNCMGRSTATUS_STOPPED = SYNCMGRSTATUS.STOPPED;
pub const SYNCMGRSTATUS_SKIPPED = SYNCMGRSTATUS.SKIPPED;
pub const SYNCMGRSTATUS_PENDING = SYNCMGRSTATUS.PENDING;
pub const SYNCMGRSTATUS_UPDATING = SYNCMGRSTATUS.UPDATING;
pub const SYNCMGRSTATUS_SUCCEEDED = SYNCMGRSTATUS.SUCCEEDED;
pub const SYNCMGRSTATUS_FAILED = SYNCMGRSTATUS.FAILED;
pub const SYNCMGRSTATUS_PAUSED = SYNCMGRSTATUS.PAUSED;
pub const SYNCMGRSTATUS_RESUMING = SYNCMGRSTATUS.RESUMING;
pub const SYNCMGRSTATUS_UPDATING_INDETERMINATE = SYNCMGRSTATUS.UPDATING_INDETERMINATE;
pub const SYNCMGRSTATUS_DELETED = SYNCMGRSTATUS.DELETED;

pub const SYNCMGRPROGRESSITEM = extern struct {
    cbSize: u32,
    mask: u32,
    lpcStatusText: ?[*:0]const u16,
    dwStatusType: u32,
    iProgValue: i32,
    iMaxValue: i32,
};

pub const SYNCMGRLOGLEVEL = enum(i32) {
    INFORMATION = 1,
    WARNING = 2,
    ERROR = 3,
    // LOGLEVELMAX = 3, this enum value conflicts with ERROR
};
pub const SYNCMGRLOGLEVEL_INFORMATION = SYNCMGRLOGLEVEL.INFORMATION;
pub const SYNCMGRLOGLEVEL_WARNING = SYNCMGRLOGLEVEL.WARNING;
pub const SYNCMGRLOGLEVEL_ERROR = SYNCMGRLOGLEVEL.ERROR;
pub const SYNCMGRLOGLEVEL_LOGLEVELMAX = SYNCMGRLOGLEVEL.ERROR;

pub const SYNCMGRERRORFLAGS = enum(i32) {
    T = 1,
};
pub const SYNCMGRERRORFLAG_ENABLEJUMPTEXT = SYNCMGRERRORFLAGS.T;

pub const SYNCMGRLOGERRORINFO = extern struct {
    cbSize: u32,
    mask: u32,
    dwSyncMgrErrorFlags: u32,
    ErrorID: Guid,
    ItemID: Guid,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ISyncMgrSynchronizeCallback_Value = Guid.initString("6295df41-35ee-11d1-8707-00c04fd93327");
pub const IID_ISyncMgrSynchronizeCallback = &IID_ISyncMgrSynchronizeCallback_Value;
pub const ISyncMgrSynchronizeCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ShowPropertiesCompleted: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrSynchronizeCallback,
                hr: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrSynchronizeCallback,
                hr: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PrepareForSyncCompleted: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrSynchronizeCallback,
                hr: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrSynchronizeCallback,
                hr: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SynchronizeCompleted: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrSynchronizeCallback,
                hr: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrSynchronizeCallback,
                hr: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ShowErrorCompleted: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrSynchronizeCallback,
                hr: HRESULT,
                cItems: u32,
                pItemIDs: [*]const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrSynchronizeCallback,
                hr: HRESULT,
                cItems: u32,
                pItemIDs: [*]const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnableModeless: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrSynchronizeCallback,
                fEnable: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrSynchronizeCallback,
                fEnable: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Progress: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrSynchronizeCallback,
                ItemID: ?*const Guid,
                pSyncProgressItem: ?*const SYNCMGRPROGRESSITEM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrSynchronizeCallback,
                ItemID: ?*const Guid,
                pSyncProgressItem: ?*const SYNCMGRPROGRESSITEM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LogError: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrSynchronizeCallback,
                dwErrorLevel: u32,
                pszErrorText: ?[*:0]const u16,
                pSyncLogError: ?*const SYNCMGRLOGERRORINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrSynchronizeCallback,
                dwErrorLevel: u32,
                pszErrorText: ?[*:0]const u16,
                pSyncLogError: ?*const SYNCMGRLOGERRORINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeleteLogError: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrSynchronizeCallback,
                ErrorID: ?*const Guid,
                dwReserved: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrSynchronizeCallback,
                ErrorID: ?*const Guid,
                dwReserved: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EstablishConnection: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrSynchronizeCallback,
                pwszConnection: ?[*:0]const u16,
                dwReserved: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrSynchronizeCallback,
                pwszConnection: ?[*:0]const u16,
                dwReserved: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrSynchronizeCallback_ShowPropertiesCompleted(self: *const T, hr: HRESULT) HRESULT {
                return @as(*const ISyncMgrSynchronizeCallback.VTable, @ptrCast(self.vtable)).ShowPropertiesCompleted(@as(*const ISyncMgrSynchronizeCallback, @ptrCast(self)), hr);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrSynchronizeCallback_PrepareForSyncCompleted(self: *const T, hr: HRESULT) HRESULT {
                return @as(*const ISyncMgrSynchronizeCallback.VTable, @ptrCast(self.vtable)).PrepareForSyncCompleted(@as(*const ISyncMgrSynchronizeCallback, @ptrCast(self)), hr);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrSynchronizeCallback_SynchronizeCompleted(self: *const T, hr: HRESULT) HRESULT {
                return @as(*const ISyncMgrSynchronizeCallback.VTable, @ptrCast(self.vtable)).SynchronizeCompleted(@as(*const ISyncMgrSynchronizeCallback, @ptrCast(self)), hr);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrSynchronizeCallback_ShowErrorCompleted(self: *const T, hr: HRESULT, cItems: u32, pItemIDs: [*]const Guid) HRESULT {
                return @as(*const ISyncMgrSynchronizeCallback.VTable, @ptrCast(self.vtable)).ShowErrorCompleted(@as(*const ISyncMgrSynchronizeCallback, @ptrCast(self)), hr, cItems, pItemIDs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrSynchronizeCallback_EnableModeless(self: *const T, fEnable: BOOL) HRESULT {
                return @as(*const ISyncMgrSynchronizeCallback.VTable, @ptrCast(self.vtable)).EnableModeless(@as(*const ISyncMgrSynchronizeCallback, @ptrCast(self)), fEnable);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrSynchronizeCallback_Progress(self: *const T, ItemID: ?*const Guid, pSyncProgressItem: ?*const SYNCMGRPROGRESSITEM) HRESULT {
                return @as(*const ISyncMgrSynchronizeCallback.VTable, @ptrCast(self.vtable)).Progress(@as(*const ISyncMgrSynchronizeCallback, @ptrCast(self)), ItemID, pSyncProgressItem);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrSynchronizeCallback_LogError(self: *const T, dwErrorLevel: u32, pszErrorText: ?[*:0]const u16, pSyncLogError: ?*const SYNCMGRLOGERRORINFO) HRESULT {
                return @as(*const ISyncMgrSynchronizeCallback.VTable, @ptrCast(self.vtable)).LogError(@as(*const ISyncMgrSynchronizeCallback, @ptrCast(self)), dwErrorLevel, pszErrorText, pSyncLogError);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrSynchronizeCallback_DeleteLogError(self: *const T, ErrorID: ?*const Guid, dwReserved: u32) HRESULT {
                return @as(*const ISyncMgrSynchronizeCallback.VTable, @ptrCast(self.vtable)).DeleteLogError(@as(*const ISyncMgrSynchronizeCallback, @ptrCast(self)), ErrorID, dwReserved);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrSynchronizeCallback_EstablishConnection(self: *const T, pwszConnection: ?[*:0]const u16, dwReserved: u32) HRESULT {
                return @as(*const ISyncMgrSynchronizeCallback.VTable, @ptrCast(self.vtable)).EstablishConnection(@as(*const ISyncMgrSynchronizeCallback, @ptrCast(self)), pwszConnection, dwReserved);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SYNCMGRITEMFLAGS = enum(i32) {
    HASPROPERTIES = 1,
    TEMPORARY = 2,
    ROAMINGUSER = 4,
    LASTUPDATETIME = 8,
    MAYDELETEITEM = 16,
    HIDDEN = 32,
};
pub const SYNCMGRITEM_HASPROPERTIES = SYNCMGRITEMFLAGS.HASPROPERTIES;
pub const SYNCMGRITEM_TEMPORARY = SYNCMGRITEMFLAGS.TEMPORARY;
pub const SYNCMGRITEM_ROAMINGUSER = SYNCMGRITEMFLAGS.ROAMINGUSER;
pub const SYNCMGRITEM_LASTUPDATETIME = SYNCMGRITEMFLAGS.LASTUPDATETIME;
pub const SYNCMGRITEM_MAYDELETEITEM = SYNCMGRITEMFLAGS.MAYDELETEITEM;
pub const SYNCMGRITEM_HIDDEN = SYNCMGRITEMFLAGS.HIDDEN;

pub const SYNCMGRITEM = extern struct {
    cbSize: u32,
    dwFlags: u32,
    ItemID: Guid,
    dwItemState: u32,
    hIcon: ?HICON,
    wszItemName: [128]u16,
    ftLastUpdate: FILETIME,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ISyncMgrEnumItems_Value = Guid.initString("6295df2a-35ee-11d1-8707-00c04fd93327");
pub const IID_ISyncMgrEnumItems = &IID_ISyncMgrEnumItems_Value;
pub const ISyncMgrEnumItems = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrEnumItems,
                celt: u32,
                rgelt: [*]SYNCMGRITEM,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrEnumItems,
                celt: u32,
                rgelt: [*]SYNCMGRITEM,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrEnumItems,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrEnumItems,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrEnumItems,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrEnumItems,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrEnumItems,
                ppenum: ?*?*ISyncMgrEnumItems,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrEnumItems,
                ppenum: ?*?*ISyncMgrEnumItems,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrEnumItems_Next(self: *const T, celt: u32, rgelt: [*]SYNCMGRITEM, pceltFetched: ?*u32) HRESULT {
                return @as(*const ISyncMgrEnumItems.VTable, @ptrCast(self.vtable)).Next(@as(*const ISyncMgrEnumItems, @ptrCast(self)), celt, rgelt, pceltFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrEnumItems_Skip(self: *const T, celt: u32) HRESULT {
                return @as(*const ISyncMgrEnumItems.VTable, @ptrCast(self.vtable)).Skip(@as(*const ISyncMgrEnumItems, @ptrCast(self)), celt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrEnumItems_Reset(self: *const T) HRESULT {
                return @as(*const ISyncMgrEnumItems.VTable, @ptrCast(self.vtable)).Reset(@as(*const ISyncMgrEnumItems, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrEnumItems_Clone(self: *const T, ppenum: ?*?*ISyncMgrEnumItems) HRESULT {
                return @as(*const ISyncMgrEnumItems.VTable, @ptrCast(self.vtable)).Clone(@as(*const ISyncMgrEnumItems, @ptrCast(self)), ppenum);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SYNCMGRFLAG = enum(i32) {
    CONNECT = 1,
    PENDINGDISCONNECT = 2,
    MANUAL = 3,
    IDLE = 4,
    INVOKE = 5,
    SCHEDULED = 6,
    EVENTMASK = 255,
    SETTINGS = 256,
    MAYBOTHERUSER = 512,
};
pub const SYNCMGRFLAG_CONNECT = SYNCMGRFLAG.CONNECT;
pub const SYNCMGRFLAG_PENDINGDISCONNECT = SYNCMGRFLAG.PENDINGDISCONNECT;
pub const SYNCMGRFLAG_MANUAL = SYNCMGRFLAG.MANUAL;
pub const SYNCMGRFLAG_IDLE = SYNCMGRFLAG.IDLE;
pub const SYNCMGRFLAG_INVOKE = SYNCMGRFLAG.INVOKE;
pub const SYNCMGRFLAG_SCHEDULED = SYNCMGRFLAG.SCHEDULED;
pub const SYNCMGRFLAG_EVENTMASK = SYNCMGRFLAG.EVENTMASK;
pub const SYNCMGRFLAG_SETTINGS = SYNCMGRFLAG.SETTINGS;
pub const SYNCMGRFLAG_MAYBOTHERUSER = SYNCMGRFLAG.MAYBOTHERUSER;

pub const SYNCMGRHANDLERFLAGS = enum(i32) {
    HASPROPERTIES = 1,
    MAYESTABLISHCONNECTION = 2,
    ALWAYSLISTHANDLER = 4,
    HIDDEN = 8,
};
pub const SYNCMGRHANDLER_HASPROPERTIES = SYNCMGRHANDLERFLAGS.HASPROPERTIES;
pub const SYNCMGRHANDLER_MAYESTABLISHCONNECTION = SYNCMGRHANDLERFLAGS.MAYESTABLISHCONNECTION;
pub const SYNCMGRHANDLER_ALWAYSLISTHANDLER = SYNCMGRHANDLERFLAGS.ALWAYSLISTHANDLER;
pub const SYNCMGRHANDLER_HIDDEN = SYNCMGRHANDLERFLAGS.HIDDEN;

pub const SYNCMGRHANDLERINFO = extern struct {
    cbSize: u32,
    hIcon: ?HICON,
    SyncMgrHandlerFlags: u32,
    wszHandlerName: [32]u16,
};

pub const SYNCMGRITEMSTATE = enum(i32) {
    UNCHECKED = 0,
    CHECKED = 1,
};
pub const SYNCMGRITEMSTATE_UNCHECKED = SYNCMGRITEMSTATE.UNCHECKED;
pub const SYNCMGRITEMSTATE_CHECKED = SYNCMGRITEMSTATE.CHECKED;

// TODO: this type is limited to platform 'windows5.0'
const IID_ISyncMgrSynchronize_Value = Guid.initString("6295df40-35ee-11d1-8707-00c04fd93327");
pub const IID_ISyncMgrSynchronize = &IID_ISyncMgrSynchronize_Value;
pub const ISyncMgrSynchronize = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrSynchronize,
                dwReserved: u32,
                dwSyncMgrFlags: u32,
                cbCookie: u32,
                lpCookie: [*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrSynchronize,
                dwReserved: u32,
                dwSyncMgrFlags: u32,
                cbCookie: u32,
                lpCookie: [*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetHandlerInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrSynchronize,
                ppSyncMgrHandlerInfo: ?*?*SYNCMGRHANDLERINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrSynchronize,
                ppSyncMgrHandlerInfo: ?*?*SYNCMGRHANDLERINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumSyncMgrItems: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrSynchronize,
                ppSyncMgrEnumItems: ?*?*ISyncMgrEnumItems,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrSynchronize,
                ppSyncMgrEnumItems: ?*?*ISyncMgrEnumItems,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetItemObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrSynchronize,
                ItemID: ?*const Guid,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrSynchronize,
                ItemID: ?*const Guid,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ShowProperties: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrSynchronize,
                hWndParent: ?HWND,
                ItemID: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrSynchronize,
                hWndParent: ?HWND,
                ItemID: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetProgressCallback: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrSynchronize,
                lpCallBack: ?*ISyncMgrSynchronizeCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrSynchronize,
                lpCallBack: ?*ISyncMgrSynchronizeCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PrepareForSync: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrSynchronize,
                cbNumItems: u32,
                pItemIDs: [*]Guid,
                hWndParent: ?HWND,
                dwReserved: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrSynchronize,
                cbNumItems: u32,
                pItemIDs: [*]Guid,
                hWndParent: ?HWND,
                dwReserved: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Synchronize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrSynchronize,
                hWndParent: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrSynchronize,
                hWndParent: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetItemStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrSynchronize,
                pItemID: ?*const Guid,
                dwSyncMgrStatus: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrSynchronize,
                pItemID: ?*const Guid,
                dwSyncMgrStatus: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ShowError: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrSynchronize,
                hWndParent: ?HWND,
                ErrorID: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrSynchronize,
                hWndParent: ?HWND,
                ErrorID: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrSynchronize_Initialize(self: *const T, dwReserved: u32, dwSyncMgrFlags: u32, cbCookie: u32, lpCookie: [*:0]const u8) HRESULT {
                return @as(*const ISyncMgrSynchronize.VTable, @ptrCast(self.vtable)).Initialize(@as(*const ISyncMgrSynchronize, @ptrCast(self)), dwReserved, dwSyncMgrFlags, cbCookie, lpCookie);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrSynchronize_GetHandlerInfo(self: *const T, ppSyncMgrHandlerInfo: ?*?*SYNCMGRHANDLERINFO) HRESULT {
                return @as(*const ISyncMgrSynchronize.VTable, @ptrCast(self.vtable)).GetHandlerInfo(@as(*const ISyncMgrSynchronize, @ptrCast(self)), ppSyncMgrHandlerInfo);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrSynchronize_EnumSyncMgrItems(self: *const T, ppSyncMgrEnumItems: ?*?*ISyncMgrEnumItems) HRESULT {
                return @as(*const ISyncMgrSynchronize.VTable, @ptrCast(self.vtable)).EnumSyncMgrItems(@as(*const ISyncMgrSynchronize, @ptrCast(self)), ppSyncMgrEnumItems);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrSynchronize_GetItemObject(self: *const T, ItemID: ?*const Guid, riid: ?*const Guid, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const ISyncMgrSynchronize.VTable, @ptrCast(self.vtable)).GetItemObject(@as(*const ISyncMgrSynchronize, @ptrCast(self)), ItemID, riid, ppv);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrSynchronize_ShowProperties(self: *const T, hWndParent: ?HWND, ItemID: ?*const Guid) HRESULT {
                return @as(*const ISyncMgrSynchronize.VTable, @ptrCast(self.vtable)).ShowProperties(@as(*const ISyncMgrSynchronize, @ptrCast(self)), hWndParent, ItemID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrSynchronize_SetProgressCallback(self: *const T, lpCallBack: ?*ISyncMgrSynchronizeCallback) HRESULT {
                return @as(*const ISyncMgrSynchronize.VTable, @ptrCast(self.vtable)).SetProgressCallback(@as(*const ISyncMgrSynchronize, @ptrCast(self)), lpCallBack);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrSynchronize_PrepareForSync(self: *const T, cbNumItems: u32, pItemIDs: [*]Guid, hWndParent: ?HWND, dwReserved: u32) HRESULT {
                return @as(*const ISyncMgrSynchronize.VTable, @ptrCast(self.vtable)).PrepareForSync(@as(*const ISyncMgrSynchronize, @ptrCast(self)), cbNumItems, pItemIDs, hWndParent, dwReserved);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrSynchronize_Synchronize(self: *const T, hWndParent: ?HWND) HRESULT {
                return @as(*const ISyncMgrSynchronize.VTable, @ptrCast(self.vtable)).Synchronize(@as(*const ISyncMgrSynchronize, @ptrCast(self)), hWndParent);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrSynchronize_SetItemStatus(self: *const T, pItemID: ?*const Guid, dwSyncMgrStatus: u32) HRESULT {
                return @as(*const ISyncMgrSynchronize.VTable, @ptrCast(self.vtable)).SetItemStatus(@as(*const ISyncMgrSynchronize, @ptrCast(self)), pItemID, dwSyncMgrStatus);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrSynchronize_ShowError(self: *const T, hWndParent: ?HWND, ErrorID: ?*const Guid) HRESULT {
                return @as(*const ISyncMgrSynchronize.VTable, @ptrCast(self.vtable)).ShowError(@as(*const ISyncMgrSynchronize, @ptrCast(self)), hWndParent, ErrorID);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SYNCMGRINVOKEFLAGS = enum(i32) {
    STARTSYNC = 2,
    MINIMIZED = 4,
};
pub const SYNCMGRINVOKE_STARTSYNC = SYNCMGRINVOKEFLAGS.STARTSYNC;
pub const SYNCMGRINVOKE_MINIMIZED = SYNCMGRINVOKEFLAGS.MINIMIZED;

// TODO: this type is limited to platform 'windows5.0'
const IID_ISyncMgrSynchronizeInvoke_Value = Guid.initString("6295df2c-35ee-11d1-8707-00c04fd93327");
pub const IID_ISyncMgrSynchronizeInvoke = &IID_ISyncMgrSynchronizeInvoke_Value;
pub const ISyncMgrSynchronizeInvoke = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        UpdateItems: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrSynchronizeInvoke,
                dwInvokeFlags: u32,
                clsid: ?*const Guid,
                cbCookie: u32,
                pCookie: [*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrSynchronizeInvoke,
                dwInvokeFlags: u32,
                clsid: ?*const Guid,
                cbCookie: u32,
                pCookie: [*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UpdateAll: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrSynchronizeInvoke,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrSynchronizeInvoke,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrSynchronizeInvoke_UpdateItems(self: *const T, dwInvokeFlags: u32, clsid: ?*const Guid, cbCookie: u32, pCookie: [*:0]const u8) HRESULT {
                return @as(*const ISyncMgrSynchronizeInvoke.VTable, @ptrCast(self.vtable)).UpdateItems(@as(*const ISyncMgrSynchronizeInvoke, @ptrCast(self)), dwInvokeFlags, clsid, cbCookie, pCookie);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrSynchronizeInvoke_UpdateAll(self: *const T) HRESULT {
                return @as(*const ISyncMgrSynchronizeInvoke.VTable, @ptrCast(self.vtable)).UpdateAll(@as(*const ISyncMgrSynchronizeInvoke, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SYNCMGRREGISTERFLAGS = enum(i32) {
    CONNECT = 1,
    PENDINGDISCONNECT = 2,
    IDLE = 4,
};
pub const SYNCMGRREGISTERFLAG_CONNECT = SYNCMGRREGISTERFLAGS.CONNECT;
pub const SYNCMGRREGISTERFLAG_PENDINGDISCONNECT = SYNCMGRREGISTERFLAGS.PENDINGDISCONNECT;
pub const SYNCMGRREGISTERFLAG_IDLE = SYNCMGRREGISTERFLAGS.IDLE;

// TODO: this type is limited to platform 'windows5.0'
const IID_ISyncMgrRegister_Value = Guid.initString("6295df42-35ee-11d1-8707-00c04fd93327");
pub const IID_ISyncMgrRegister = &IID_ISyncMgrRegister_Value;
pub const ISyncMgrRegister = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RegisterSyncMgrHandler: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrRegister,
                clsidHandler: ?*const Guid,
                pwszDescription: ?[*:0]const u16,
                dwSyncMgrRegisterFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrRegister,
                clsidHandler: ?*const Guid,
                pwszDescription: ?[*:0]const u16,
                dwSyncMgrRegisterFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnregisterSyncMgrHandler: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrRegister,
                clsidHandler: ?*const Guid,
                dwReserved: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrRegister,
                clsidHandler: ?*const Guid,
                dwReserved: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetHandlerRegistrationInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISyncMgrRegister,
                clsidHandler: ?*const Guid,
                pdwSyncMgrRegisterFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISyncMgrRegister,
                clsidHandler: ?*const Guid,
                pdwSyncMgrRegisterFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrRegister_RegisterSyncMgrHandler(self: *const T, clsidHandler: ?*const Guid, pwszDescription: ?[*:0]const u16, dwSyncMgrRegisterFlags: u32) HRESULT {
                return @as(*const ISyncMgrRegister.VTable, @ptrCast(self.vtable)).RegisterSyncMgrHandler(@as(*const ISyncMgrRegister, @ptrCast(self)), clsidHandler, pwszDescription, dwSyncMgrRegisterFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrRegister_UnregisterSyncMgrHandler(self: *const T, clsidHandler: ?*const Guid, dwReserved: u32) HRESULT {
                return @as(*const ISyncMgrRegister.VTable, @ptrCast(self.vtable)).UnregisterSyncMgrHandler(@as(*const ISyncMgrRegister, @ptrCast(self)), clsidHandler, dwReserved);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISyncMgrRegister_GetHandlerRegistrationInfo(self: *const T, clsidHandler: ?*const Guid, pdwSyncMgrRegisterFlags: ?*u32) HRESULT {
                return @as(*const ISyncMgrRegister.VTable, @ptrCast(self.vtable)).GetHandlerRegistrationInfo(@as(*const ISyncMgrRegister, @ptrCast(self)), clsidHandler, pdwSyncMgrRegisterFlags);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const CLSID_ThumbnailStreamCache_Value = Guid.initString("cbe0fed3-4b91-4e90-8354-8a8c84ec6872");
pub const CLSID_ThumbnailStreamCache = &CLSID_ThumbnailStreamCache_Value;

pub const ThumbnailStreamCacheOptions = enum(i32) {
    ExtractIfNotCached = 0,
    ReturnOnlyIfCached = 1,
    ResizeThumbnail = 2,
    AllowSmallerSize = 4,
};
pub const ExtractIfNotCached = ThumbnailStreamCacheOptions.ExtractIfNotCached;
pub const ReturnOnlyIfCached = ThumbnailStreamCacheOptions.ReturnOnlyIfCached;
pub const ResizeThumbnail = ThumbnailStreamCacheOptions.ResizeThumbnail;
pub const AllowSmallerSize = ThumbnailStreamCacheOptions.AllowSmallerSize;

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IThumbnailStreamCache_Value = Guid.initString("90e11430-9569-41d8-ae75-6d4d2ae7cca0");
pub const IID_IThumbnailStreamCache = &IID_IThumbnailStreamCache_Value;
pub const IThumbnailStreamCache = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetThumbnailStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IThumbnailStreamCache,
                path: ?[*:0]const u16,
                cacheId: u64,
                options: ThumbnailStreamCacheOptions,
                requestedThumbnailSize: u32,
                thumbnailSize: ?*SIZE,
                thumbnailStream: ?*?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IThumbnailStreamCache,
                path: ?[*:0]const u16,
                cacheId: u64,
                options: ThumbnailStreamCacheOptions,
                requestedThumbnailSize: u32,
                thumbnailSize: ?*SIZE,
                thumbnailStream: ?*?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetThumbnailStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IThumbnailStreamCache,
                path: ?[*:0]const u16,
                cacheId: u64,
                thumbnailSize: SIZE,
                thumbnailStream: ?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IThumbnailStreamCache,
                path: ?[*:0]const u16,
                cacheId: u64,
                thumbnailSize: SIZE,
                thumbnailStream: ?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IThumbnailStreamCache_GetThumbnailStream(self: *const T, path: ?[*:0]const u16, cacheId: u64, options: ThumbnailStreamCacheOptions, requestedThumbnailSize: u32, thumbnailSize: ?*SIZE, thumbnailStream: ?*?*IStream) HRESULT {
                return @as(*const IThumbnailStreamCache.VTable, @ptrCast(self.vtable)).GetThumbnailStream(@as(*const IThumbnailStreamCache, @ptrCast(self)), path, cacheId, options, requestedThumbnailSize, thumbnailSize, thumbnailStream);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IThumbnailStreamCache_SetThumbnailStream(self: *const T, path: ?[*:0]const u16, cacheId: u64, thumbnailSize: SIZE, thumbnailStream: ?*IStream) HRESULT {
                return @as(*const IThumbnailStreamCache.VTable, @ptrCast(self.vtable)).SetThumbnailStream(@as(*const IThumbnailStreamCache, @ptrCast(self)), path, cacheId, thumbnailSize, thumbnailStream);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const CLSID_TrackShellMenu_Value = Guid.initString("8278f931-2a3e-11d2-838f-00c04fd918d0");
pub const CLSID_TrackShellMenu = &CLSID_TrackShellMenu_Value;

pub const WINDOWDATA = extern struct {
    dwWindowID: u32,
    uiCP: u32,
    pidl: ?*ITEMIDLIST,
    lpszUrl: ?PWSTR,
    lpszUrlLocation: ?PWSTR,
    lpszTitle: ?PWSTR,
};

const IID_ITravelLogEntry_Value = Guid.initString("7ebfdd87-ad18-11d3-a4c5-00c04f72d6b8");
pub const IID_ITravelLogEntry = &IID_ITravelLogEntry_Value;
pub const ITravelLogEntry = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTitle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITravelLogEntry,
                ppszTitle: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITravelLogEntry,
                ppszTitle: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetURL: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITravelLogEntry,
                ppszURL: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITravelLogEntry,
                ppszURL: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITravelLogEntry_GetTitle(self: *const T, ppszTitle: ?*?PWSTR) HRESULT {
                return @as(*const ITravelLogEntry.VTable, @ptrCast(self.vtable)).GetTitle(@as(*const ITravelLogEntry, @ptrCast(self)), ppszTitle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITravelLogEntry_GetURL(self: *const T, ppszURL: ?*?PWSTR) HRESULT {
                return @as(*const ITravelLogEntry.VTable, @ptrCast(self.vtable)).GetURL(@as(*const ITravelLogEntry, @ptrCast(self)), ppszURL);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITravelLogClient_Value = Guid.initString("241c033e-e659-43da-aa4d-4086dbc4758d");
pub const IID_ITravelLogClient = &IID_ITravelLogClient_Value;
pub const ITravelLogClient = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        FindWindowByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITravelLogClient,
                dwID: u32,
                ppunk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITravelLogClient,
                dwID: u32,
                ppunk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetWindowData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITravelLogClient,
                pStream: ?*IStream,
                pWinData: ?*WINDOWDATA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITravelLogClient,
                pStream: ?*IStream,
                pWinData: ?*WINDOWDATA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LoadHistoryPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITravelLogClient,
                pszUrlLocation: ?PWSTR,
                dwPosition: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITravelLogClient,
                pszUrlLocation: ?PWSTR,
                dwPosition: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITravelLogClient_FindWindowByIndex(self: *const T, dwID: u32, ppunk: ?*?*IUnknown) HRESULT {
                return @as(*const ITravelLogClient.VTable, @ptrCast(self.vtable)).FindWindowByIndex(@as(*const ITravelLogClient, @ptrCast(self)), dwID, ppunk);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITravelLogClient_GetWindowData(self: *const T, pStream: ?*IStream, pWinData: ?*WINDOWDATA) HRESULT {
                return @as(*const ITravelLogClient.VTable, @ptrCast(self.vtable)).GetWindowData(@as(*const ITravelLogClient, @ptrCast(self)), pStream, pWinData);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITravelLogClient_LoadHistoryPosition(self: *const T, pszUrlLocation: ?PWSTR, dwPosition: u32) HRESULT {
                return @as(*const ITravelLogClient.VTable, @ptrCast(self.vtable)).LoadHistoryPosition(@as(*const ITravelLogClient, @ptrCast(self)), pszUrlLocation, dwPosition);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumTravelLogEntry_Value = Guid.initString("7ebfdd85-ad18-11d3-a4c5-00c04f72d6b8");
pub const IID_IEnumTravelLogEntry = &IID_IEnumTravelLogEntry_Value;
pub const IEnumTravelLogEntry = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumTravelLogEntry,
                cElt: u32,
                rgElt: [*]?*ITravelLogEntry,
                pcEltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumTravelLogEntry,
                cElt: u32,
                rgElt: [*]?*ITravelLogEntry,
                pcEltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumTravelLogEntry,
                cElt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumTravelLogEntry,
                cElt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumTravelLogEntry,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumTravelLogEntry,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumTravelLogEntry,
                ppEnum: ?*?*IEnumTravelLogEntry,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumTravelLogEntry,
                ppEnum: ?*?*IEnumTravelLogEntry,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumTravelLogEntry_Next(self: *const T, cElt: u32, rgElt: [*]?*ITravelLogEntry, pcEltFetched: ?*u32) HRESULT {
                return @as(*const IEnumTravelLogEntry.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumTravelLogEntry, @ptrCast(self)), cElt, rgElt, pcEltFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumTravelLogEntry_Skip(self: *const T, cElt: u32) HRESULT {
                return @as(*const IEnumTravelLogEntry.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumTravelLogEntry, @ptrCast(self)), cElt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumTravelLogEntry_Reset(self: *const T) HRESULT {
                return @as(*const IEnumTravelLogEntry.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumTravelLogEntry, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumTravelLogEntry_Clone(self: *const T, ppEnum: ?*?*IEnumTravelLogEntry) HRESULT {
                return @as(*const IEnumTravelLogEntry.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumTravelLogEntry, @ptrCast(self)), ppEnum);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const TLENUMF = enum(i32) {
    RELATIVE_INCLUDE_CURRENT = 1,
    RELATIVE_BACK = 16,
    RELATIVE_FORE = 32,
    INCLUDE_UNINVOKEABLE = 64,
    ABSOLUTE = 49,
    EXCLUDE_SUBFRAME_ENTRIES = 128,
    EXCLUDE_ABOUT_PAGES = 256,
};
pub const TLEF_RELATIVE_INCLUDE_CURRENT = TLENUMF.RELATIVE_INCLUDE_CURRENT;
pub const TLEF_RELATIVE_BACK = TLENUMF.RELATIVE_BACK;
pub const TLEF_RELATIVE_FORE = TLENUMF.RELATIVE_FORE;
pub const TLEF_INCLUDE_UNINVOKEABLE = TLENUMF.INCLUDE_UNINVOKEABLE;
pub const TLEF_ABSOLUTE = TLENUMF.ABSOLUTE;
pub const TLEF_EXCLUDE_SUBFRAME_ENTRIES = TLENUMF.EXCLUDE_SUBFRAME_ENTRIES;
pub const TLEF_EXCLUDE_ABOUT_PAGES = TLENUMF.EXCLUDE_ABOUT_PAGES;

const IID_ITravelLogStg_Value = Guid.initString("7ebfdd80-ad18-11d3-a4c5-00c04f72d6b8");
pub const IID_ITravelLogStg = &IID_ITravelLogStg_Value;
pub const ITravelLogStg = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateEntry: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITravelLogStg,
                pszUrl: ?[*:0]const u16,
                pszTitle: ?[*:0]const u16,
                ptleRelativeTo: ?*ITravelLogEntry,
                fPrepend: BOOL,
                pptle: ?*?*ITravelLogEntry,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITravelLogStg,
                pszUrl: ?[*:0]const u16,
                pszTitle: ?[*:0]const u16,
                ptleRelativeTo: ?*ITravelLogEntry,
                fPrepend: BOOL,
                pptle: ?*?*ITravelLogEntry,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TravelTo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITravelLogStg,
                ptle: ?*ITravelLogEntry,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITravelLogStg,
                ptle: ?*ITravelLogEntry,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumEntries: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITravelLogStg,
                flags: TLENUMF,
                ppenum: ?*?*IEnumTravelLogEntry,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITravelLogStg,
                flags: TLENUMF,
                ppenum: ?*?*IEnumTravelLogEntry,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindEntries: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITravelLogStg,
                flags: TLENUMF,
                pszUrl: ?[*:0]const u16,
                ppenum: ?*?*IEnumTravelLogEntry,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITravelLogStg,
                flags: TLENUMF,
                pszUrl: ?[*:0]const u16,
                ppenum: ?*?*IEnumTravelLogEntry,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITravelLogStg,
                flags: TLENUMF,
                pcEntries: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITravelLogStg,
                flags: TLENUMF,
                pcEntries: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveEntry: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITravelLogStg,
                ptle: ?*ITravelLogEntry,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITravelLogStg,
                ptle: ?*ITravelLogEntry,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRelativeEntry: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITravelLogStg,
                iOffset: i32,
                ptle: ?*?*ITravelLogEntry,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITravelLogStg,
                iOffset: i32,
                ptle: ?*?*ITravelLogEntry,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITravelLogStg_CreateEntry(self: *const T, pszUrl: ?[*:0]const u16, pszTitle: ?[*:0]const u16, ptleRelativeTo: ?*ITravelLogEntry, fPrepend: BOOL, pptle: ?*?*ITravelLogEntry) HRESULT {
                return @as(*const ITravelLogStg.VTable, @ptrCast(self.vtable)).CreateEntry(@as(*const ITravelLogStg, @ptrCast(self)), pszUrl, pszTitle, ptleRelativeTo, fPrepend, pptle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITravelLogStg_TravelTo(self: *const T, ptle: ?*ITravelLogEntry) HRESULT {
                return @as(*const ITravelLogStg.VTable, @ptrCast(self.vtable)).TravelTo(@as(*const ITravelLogStg, @ptrCast(self)), ptle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITravelLogStg_EnumEntries(self: *const T, flags: TLENUMF, ppenum: ?*?*IEnumTravelLogEntry) HRESULT {
                return @as(*const ITravelLogStg.VTable, @ptrCast(self.vtable)).EnumEntries(@as(*const ITravelLogStg, @ptrCast(self)), flags, ppenum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITravelLogStg_FindEntries(self: *const T, flags: TLENUMF, pszUrl: ?[*:0]const u16, ppenum: ?*?*IEnumTravelLogEntry) HRESULT {
                return @as(*const ITravelLogStg.VTable, @ptrCast(self.vtable)).FindEntries(@as(*const ITravelLogStg, @ptrCast(self)), flags, pszUrl, ppenum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITravelLogStg_GetCount(self: *const T, flags: TLENUMF, pcEntries: ?*u32) HRESULT {
                return @as(*const ITravelLogStg.VTable, @ptrCast(self.vtable)).GetCount(@as(*const ITravelLogStg, @ptrCast(self)), flags, pcEntries);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITravelLogStg_RemoveEntry(self: *const T, ptle: ?*ITravelLogEntry) HRESULT {
                return @as(*const ITravelLogStg.VTable, @ptrCast(self.vtable)).RemoveEntry(@as(*const ITravelLogStg, @ptrCast(self)), ptle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITravelLogStg_GetRelativeEntry(self: *const T, iOffset: i32, ptle: ?*?*ITravelLogEntry) HRESULT {
                return @as(*const ITravelLogStg.VTable, @ptrCast(self.vtable)).GetRelativeEntry(@as(*const ITravelLogStg, @ptrCast(self)), iOffset, ptle);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const _HLSR_NOREDEF10 = enum(i32) {
    HOME = 0,
    SEARCHPAGE = 1,
    HISTORYFOLDER = 2,
};
pub const HLSR_HOME = _HLSR_NOREDEF10.HOME;
pub const HLSR_SEARCHPAGE = _HLSR_NOREDEF10.SEARCHPAGE;
pub const HLSR_HISTORYFOLDER = _HLSR_NOREDEF10.HISTORYFOLDER;

pub const _HLSHORTCUTF__NOREDEF10 = enum(i32) {
    DEFAULT = 0,
    DONTACTUALLYCREATE = 1,
    USEFILENAMEFROMFRIENDLYNAME = 2,
    USEUNIQUEFILENAME = 4,
    MAYUSEEXISTINGSHORTCUT = 8,
};
pub const HLSHORTCUTF_DEFAULT = _HLSHORTCUTF__NOREDEF10.DEFAULT;
pub const HLSHORTCUTF_DONTACTUALLYCREATE = _HLSHORTCUTF__NOREDEF10.DONTACTUALLYCREATE;
pub const HLSHORTCUTF_USEFILENAMEFROMFRIENDLYNAME = _HLSHORTCUTF__NOREDEF10.USEFILENAMEFROMFRIENDLYNAME;
pub const HLSHORTCUTF_USEUNIQUEFILENAME = _HLSHORTCUTF__NOREDEF10.USEUNIQUEFILENAME;
pub const HLSHORTCUTF_MAYUSEEXISTINGSHORTCUT = _HLSHORTCUTF__NOREDEF10.MAYUSEEXISTINGSHORTCUT;

pub const _HLTRANSLATEF_NOREDEF10 = enum(i32) {
    EFAULT = 0,
    ONTAPPLYDEFAULTPREFIX = 1,
};
pub const HLTRANSLATEF_DEFAULT = _HLTRANSLATEF_NOREDEF10.EFAULT;
pub const HLTRANSLATEF_DONTAPPLYDEFAULTPREFIX = _HLTRANSLATEF_NOREDEF10.ONTAPPLYDEFAULTPREFIX;

pub const HLNF = enum(u32) {
    INTERNALJUMP = 1,
    OPENINNEWWINDOW = 2,
    NAVIGATINGBACK = 4,
    NAVIGATINGFORWARD = 8,
    NAVIGATINGTOSTACKITEM = 16,
    CREATENOHISTORY = 32,
    _,
    pub fn initFlags(o: struct {
        INTERNALJUMP: u1 = 0,
        OPENINNEWWINDOW: u1 = 0,
        NAVIGATINGBACK: u1 = 0,
        NAVIGATINGFORWARD: u1 = 0,
        NAVIGATINGTOSTACKITEM: u1 = 0,
        CREATENOHISTORY: u1 = 0,
    }) HLNF {
        return @as(HLNF, @enumFromInt((if (o.INTERNALJUMP == 1) @intFromEnum(HLNF.INTERNALJUMP) else 0) | (if (o.OPENINNEWWINDOW == 1) @intFromEnum(HLNF.OPENINNEWWINDOW) else 0) | (if (o.NAVIGATINGBACK == 1) @intFromEnum(HLNF.NAVIGATINGBACK) else 0) | (if (o.NAVIGATINGFORWARD == 1) @intFromEnum(HLNF.NAVIGATINGFORWARD) else 0) | (if (o.NAVIGATINGTOSTACKITEM == 1) @intFromEnum(HLNF.NAVIGATINGTOSTACKITEM) else 0) | (if (o.CREATENOHISTORY == 1) @intFromEnum(HLNF.CREATENOHISTORY) else 0)));
    }
};
pub const HLNF_INTERNALJUMP = HLNF.INTERNALJUMP;
pub const HLNF_OPENINNEWWINDOW = HLNF.OPENINNEWWINDOW;
pub const HLNF_NAVIGATINGBACK = HLNF.NAVIGATINGBACK;
pub const HLNF_NAVIGATINGFORWARD = HLNF.NAVIGATINGFORWARD;
pub const HLNF_NAVIGATINGTOSTACKITEM = HLNF.NAVIGATINGTOSTACKITEM;
pub const HLNF_CREATENOHISTORY = HLNF.CREATENOHISTORY;

pub const HLINKGETREF = enum(i32) {
    DEFAULT = 0,
    ABSOLUTE = 1,
    RELATIVE = 2,
};
pub const HLINKGETREF_DEFAULT = HLINKGETREF.DEFAULT;
pub const HLINKGETREF_ABSOLUTE = HLINKGETREF.ABSOLUTE;
pub const HLINKGETREF_RELATIVE = HLINKGETREF.RELATIVE;

pub const HLFNAMEF = enum(u32) {
    DEFAULT = 0,
    TRYCACHE = 1,
    TRYPRETTYTARGET = 2,
    TRYFULLTARGET = 4,
    TRYWIN95SHORTCUT = 8,
    _,
    pub fn initFlags(o: struct {
        DEFAULT: u1 = 0,
        TRYCACHE: u1 = 0,
        TRYPRETTYTARGET: u1 = 0,
        TRYFULLTARGET: u1 = 0,
        TRYWIN95SHORTCUT: u1 = 0,
    }) HLFNAMEF {
        return @as(HLFNAMEF, @enumFromInt((if (o.DEFAULT == 1) @intFromEnum(HLFNAMEF.DEFAULT) else 0) | (if (o.TRYCACHE == 1) @intFromEnum(HLFNAMEF.TRYCACHE) else 0) | (if (o.TRYPRETTYTARGET == 1) @intFromEnum(HLFNAMEF.TRYPRETTYTARGET) else 0) | (if (o.TRYFULLTARGET == 1) @intFromEnum(HLFNAMEF.TRYFULLTARGET) else 0) | (if (o.TRYWIN95SHORTCUT == 1) @intFromEnum(HLFNAMEF.TRYWIN95SHORTCUT) else 0)));
    }
};
pub const HLFNAMEF_DEFAULT = HLFNAMEF.DEFAULT;
pub const HLFNAMEF_TRYCACHE = HLFNAMEF.TRYCACHE;
pub const HLFNAMEF_TRYPRETTYTARGET = HLFNAMEF.TRYPRETTYTARGET;
pub const HLFNAMEF_TRYFULLTARGET = HLFNAMEF.TRYFULLTARGET;
pub const HLFNAMEF_TRYWIN95SHORTCUT = HLFNAMEF.TRYWIN95SHORTCUT;

pub const HLINKMISC = enum(i32) {
    E = 1,
};
pub const HLINKMISC_RELATIVE = HLINKMISC.E;

pub const HLINKSETF = enum(i32) {
    TARGET = 1,
    LOCATION = 2,
};
pub const HLINKSETF_TARGET = HLINKSETF.TARGET;
pub const HLINKSETF_LOCATION = HLINKSETF.LOCATION;

const IID_IHlink_Value = Guid.initString("79eac9c3-baf9-11ce-8c82-00aa004ba90b");
pub const IID_IHlink = &IID_IHlink_Value;
pub const IHlink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetHlinkSite: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IHlink,
                pihlSite: ?*IHlinkSite,
                dwSiteData: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IHlink,
                pihlSite: ?*IHlinkSite,
                dwSiteData: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetHlinkSite: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IHlink,
                ppihlSite: ?*?*IHlinkSite,
                pdwSiteData: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IHlink,
                ppihlSite: ?*?*IHlinkSite,
                pdwSiteData: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetMonikerReference: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IHlink,
                grfHLSETF: u32,
                pimkTarget: ?*IMoniker,
                pwzLocation: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IHlink,
                grfHLSETF: u32,
                pimkTarget: ?*IMoniker,
                pwzLocation: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMonikerReference: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IHlink,
                dwWhichRef: u32,
                ppimkTarget: ?*?*IMoniker,
                ppwzLocation: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IHlink,
                dwWhichRef: u32,
                ppimkTarget: ?*?*IMoniker,
                ppwzLocation: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetStringReference: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IHlink,
                grfHLSETF: u32,
                pwzTarget: ?[*:0]const u16,
                pwzLocation: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IHlink,
                grfHLSETF: u32,
                pwzTarget: ?[*:0]const u16,
                pwzLocation: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStringReference: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IHlink,
                dwWhichRef: u32,
                ppwzTarget: ?*?PWSTR,
                ppwzLocation: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IHlink,
                dwWhichRef: u32,
                ppwzTarget: ?*?PWSTR,
                ppwzLocation: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFriendlyName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IHlink,
                pwzFriendlyName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IHlink,
                pwzFriendlyName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFriendlyName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IHlink,
                grfHLFNAMEF: u32,
                ppwzFriendlyName: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IHlink,
                grfHLFNAMEF: u32,
                ppwzFriendlyName: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTargetFrameName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IHlink,
                pwzTargetFrameName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IHlink,
                pwzTargetFrameName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTargetFrameName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IHlink,
                ppwzTargetFrameName: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IHlink,
                ppwzTargetFrameName: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMiscStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IHlink,
                pdwStatus: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IHlink,
                pdwStatus: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Navigate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IHlink,
                grfHLNF: u32,
                pibc: ?*IBindCtx,
                pibsc: ?*IBindStatusCallback,
                pihlbc: ?*IHlinkBrowseContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IHlink,
                grfHLNF: u32,
                pibc: ?*IBindCtx,
                pibsc: ?*IBindStatusCallback,
                pihlbc: ?*IHlinkBrowseContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetAdditionalParams: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IHlink,
                pwzAdditionalParams: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IHlink,
                pwzAdditionalParams: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAdditionalParams: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IHlink,
                ppwzAdditionalParams: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IHlink,
                ppwzAdditionalParams: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IHlink_SetHlinkSite(self: *const T, pihlSite: ?*IHlinkSite, dwSiteData: u32) HRESULT {
                return @as(*const IHlink.VTable, @ptrCast(self.vtable)).SetHlinkSite(@as(*const IHlink, @ptrCast(self)), pihlSite, dwSiteData);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IHlink_GetHlinkSite(self: *const T, ppihlSite: ?*?*IHlinkSite, pdwSiteData: ?*u32) HRESULT {
                return @as(*const IHlink.VTable, @ptrCast(self.vtable)).GetHlinkSite(@as(*const IHlink, @ptrCast(self)), ppihlSite, pdwSiteData);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IHlink_SetMonikerReference(self: *const T, grfHLSETF: u32, pimkTarget: ?*IMoniker, pwzLocation: ?[*:0]const u16) HRESULT {
                return @as(*const IHlink.VTable, @ptrCast(self.vtable)).SetMonikerReference(@as(*const IHlink, @ptrCast(self)), grfHLSETF, pimkTarget, pwzLocation);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IHlink_GetMonikerReference(self: *const T, dwWhichRef: u32, ppimkTarget: ?*?*IMoniker, ppwzLocation: ?*?PWSTR) HRESULT {
                return @as(*const IHlink.VTable, @ptrCast(self.vtable)).GetMonikerReference(@as(*const IHlink, @ptrCast(self)), dwWhichRef, ppimkTarget, ppwzLocation);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IHlink_SetStringReference(self: *const T, grfHLSETF: u32, pwzTarget: ?[*:0]const u16, pwzLocation: ?[*:0]const u16) HRESULT {
                return @as(*const IHlink.VTable, @ptrCast(self.vtable)).SetStringReference(@as(*const IHlink, @ptrCast(self)), grfHLSETF, pwzTarget, pwzLocation);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IHlink_GetStringReference(self: *const T, dwWhichRef: u32, ppwzTarget: ?*?PWSTR, ppwzLocation: ?*?PWSTR) HRESULT {
                return @as(*const IHlink.VTable, @ptrCast(self.vtable)).GetStringReference(@as(*const IHlink, @ptrCast(self)), dwWhichRef, ppwzTarget, ppwzLocation);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IHlink_SetFriendlyName(self: *const T, pwzFriendlyName: ?[*:0]const u16) HRESULT {
                return @as(*const IHlink.VTable, @ptrCast(self.vtable)).SetFriendlyName(@as(*const IHlink, @ptrCast(self)), pwzFriendlyName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IHlink_GetFriendlyName(self: *const T, grfHLFNAMEF: u32, ppwzFriendlyName: ?*?PWSTR) HRESULT {
                return @as(*const IHlink.VTable, @ptrCast(self.vtable)).GetFriendlyName(@as(*const IHlink, @ptrCast(self)), grfHLFNAMEF, ppwzFriendlyName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IHlink_SetTargetFrameName(self: *const T, pwzTargetFrameName: ?[*:0]const u16) HRESULT {
                return @as(*const IHlink.VTable, @ptrCast(self.vtable)).SetTargetFrameName(@as(*const IHlink, @ptrCast(self)), pwzTargetFrameName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IHlink_GetTargetFrameName(self: *const T, ppwzTargetFrameName: ?*?PWSTR) HRESULT {
                return @as(*const IHlink.VTable, @ptrCast(self.vtable)).GetTargetFrameName(@as(*const IHlink, @ptrCast(self)), ppwzTargetFrameName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IHlink_GetMiscStatus(self: *const T, pdwStatus: ?*u32) HRESULT {
                return @as(*const IHlink.VTable, @ptrCast(self.vtable)).GetMiscStatus(@as(*const IHlink, @ptrCast(self)), pdwStatus);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IHlink_Navigate(self: *const T, grfHLNF: u32, pibc: ?*IBindCtx, pibsc: ?*IBindStatusCallback, pihlbc: ?*IHlinkBrowseContext) HRESULT {
                return @as(*const IHlink.VTable, @ptrCast(self.vtable)).Navigate(@as(*const IHlink, @ptrCast(self)), grfHLNF, pibc, pibsc, pihlbc);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IHlink_SetAdditionalParams(self: *const T, pwzAdditionalParams: ?[*:0]const u16) HRESULT {
                return @as(*const IHlink.VTable, @ptrCast(self.vtable)).SetAdditionalParams(@as(*const IHlink, @ptrCast(self)), pwzAdditionalParams);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IHlink_GetAdditionalParams(self: *const T, ppwzAdditionalParams: ?*?PWSTR) HRESULT {
                return @as(*const IHlink.VTable, @ptrCast(self.vtable)).GetAdditionalParams(@as(*const IHlink, @ptrCast(self)), ppwzAdditionalParams);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const HLINKWHICHMK = enum(i32) {
    CONTAINER = 1,
    BASE = 2,
};
pub const HLINKWHICHMK_CONTAINER = HLINKWHICHMK.CONTAINER;
pub const HLINKWHICHMK_BASE = HLINKWHICHMK.BASE;

const IID_IHlinkSite_Value = Guid.initString("79eac9c2-baf9-11ce-8c82-00aa004ba90b");
pub const IID_IHlinkSite = &IID_IHlinkSite_Value;
pub const IHlinkSite = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryService: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IHlinkSite,
                dwSiteData: u32,
                guidService: ?*const Guid,
                riid: ?*const Guid,
                ppiunk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IHlinkSite,
                dwSiteData: u32,
                guidService: ?*const Guid,
                riid: ?*const Guid,
                ppiunk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMoniker: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IHlinkSite,
                dwSiteData: u32,
                dwAssign: u32,
                dwWhich: u32,
                ppimk: ?*?*IMoniker,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IHlinkSite,
                dwSiteData: u32,
                dwAssign: u32,
                dwWhich: u32,
                ppimk: ?*?*IMoniker,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadyToNavigate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IHlinkSite,
                dwSiteData: u32,
                dwReserved: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IHlinkSite,
                dwSiteData: u32,
                dwReserved: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnNavigationComplete: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IHlinkSite,
                dwSiteData: u32,
                dwreserved: u32,
                hrError: HRESULT,
                pwzError: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IHlinkSite,
                dwSiteData: u32,
                dwreserved: u32,
                hrError: HRESULT,
                pwzError: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IHlinkSite_QueryService(self: *const T, dwSiteData: u32, guidService: ?*const Guid, riid: ?*const Guid, ppiunk: ?*?*IUnknown) HRESULT {
                return @as(*const IHlinkSite.VTable, @ptrCast(self.vtable)).QueryService(@as(*const IHlinkSite, @ptrCast(self)), dwSiteData, guidService, riid, ppiunk);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IHlinkSite_GetMoniker(self: *const T, dwSiteData: u32, dwAssign: u32, dwWhich: u32, ppimk: ?*?*IMoniker) HRESULT {
                return @as(*const IHlinkSite.VTable, @ptrCast(self.vtable)).GetMoniker(@as(*const IHlinkSite, @ptrCast(self)), dwSiteData, dwAssign, dwWhich, ppimk);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IHlinkSite_ReadyToNavigate(self: *const T, dwSiteData: u32, dwReserved: u32) HRESULT {
                return @as(*const IHlinkSite.VTable, @ptrCast(self.vtable)).ReadyToNavigate(@as(*const IHlinkSite, @ptrCast(self)), dwSiteData, dwReserved);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IHlinkSite_OnNavigationComplete(self: *const T, dwSiteData: u32, dwreserved: u32, hrError: HRESULT, pwzError: ?[*:0]const u16) HRESULT {
                return @as(*const IHlinkSite.VTable, @ptrCast(self.vtable)).OnNavigationComplete(@as(*const IHlinkSite, @ptrCast(self)), dwSiteData, dwreserved, hrError, pwzError);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IHlinkTarget_Value = Guid.initString("79eac9c4-baf9-11ce-8c82-00aa004ba90b");
pub const IID_IHlinkTarget = &IID_IHlinkTarget_Value;
pub const IHlinkTarget = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetBrowseContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IHlinkTarget,
                pihlbc: ?*IHlinkBrowseContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IHlinkTarget,
                pihlbc: ?*IHlinkBrowseContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBrowseContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IHlinkTarget,
                ppihlbc: ?*?*IHlinkBrowseContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IHlinkTarget,
                ppihlbc: ?*?*IHlinkBrowseContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Navigate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IHlinkTarget,
                grfHLNF: u32,
                pwzJumpLocation: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IHlinkTarget,
                grfHLNF: u32,
                pwzJumpLocation: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMoniker: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IHlinkTarget,
                pwzLocation: ?[*:0]const u16,
                dwAssign: u32,
                ppimkLocation: ?*?*IMoniker,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IHlinkTarget,
                pwzLocation: ?[*:0]const u16,
                dwAssign: u32,
                ppimkLocation: ?*?*IMoniker,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFriendlyName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IHlinkTarget,
                pwzLocation: ?[*:0]const u16,
                ppwzFriendlyName: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IHlinkTarget,
                pwzLocation: ?[*:0]const u16,
                ppwzFriendlyName: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IHlinkTarget_SetBrowseContext(self: *const T, pihlbc: ?*IHlinkBrowseContext) HRESULT {
                return @as(*const IHlinkTarget.VTable, @ptrCast(self.vtable)).SetBrowseContext(@as(*const IHlinkTarget, @ptrCast(self)), pihlbc);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IHlinkTarget_GetBrowseContext(self: *const T, ppihlbc: ?*?*IHlinkBrowseContext) HRESULT {
                return @as(*const IHlinkTarget.VTable, @ptrCast(self.vtable)).GetBrowseContext(@as(*const IHlinkTarget, @ptrCast(self)), ppihlbc);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IHlinkTarget_Navigate(self: *const T, grfHLNF: u32, pwzJumpLocation: ?[*:0]const u16) HRESULT {
                return @as(*const IHlinkTarget.VTable, @ptrCast(self.vtable)).Navigate(@as(*const IHlinkTarget, @ptrCast(self)), grfHLNF, pwzJumpLocation);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IHlinkTarget_GetMoniker(self: *const T, pwzLocation: ?[*:0]const u16, dwAssign: u32, ppimkLocation: ?*?*IMoniker) HRESULT {
                return @as(*const IHlinkTarget.VTable, @ptrCast(self.vtable)).GetMoniker(@as(*const IHlinkTarget, @ptrCast(self)), pwzLocation, dwAssign, ppimkLocation);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IHlinkTarget_GetFriendlyName(self: *const T, pwzLocation: ?[*:0]const u16, ppwzFriendlyName: ?*?PWSTR) HRESULT {
                return @as(*const IHlinkTarget.VTable, @ptrCast(self.vtable)).GetFriendlyName(@as(*const IHlinkTarget, @ptrCast(self)), pwzLocation, ppwzFriendlyName);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IHlinkFrame_Value = Guid.initString("79eac9c5-baf9-11ce-8c82-00aa004ba90b");
pub const IID_IHlinkFrame = &IID_IHlinkFrame_Value;
pub const IHlinkFrame = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetBrowseContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IHlinkFrame,
                pihlbc: ?*IHlinkBrowseContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IHlinkFrame,
                pihlbc: ?*IHlinkBrowseContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBrowseContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IHlinkFrame,
                ppihlbc: ?*?*IHlinkBrowseContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IHlinkFrame,
                ppihlbc: ?*?*IHlinkBrowseContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Navigate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IHlinkFrame,
                grfHLNF: u32,
                pbc: ?*IBindCtx,
                pibsc: ?*IBindStatusCallback,
                pihlNavigate: ?*IHlink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IHlinkFrame,
                grfHLNF: u32,
                pbc: ?*IBindCtx,
                pibsc: ?*IBindStatusCallback,
                pihlNavigate: ?*IHlink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnNavigate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IHlinkFrame,
                grfHLNF: u32,
                pimkTarget: ?*IMoniker,
                pwzLocation: ?[*:0]const u16,
                pwzFriendlyName: ?[*:0]const u16,
                dwreserved: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IHlinkFrame,
                grfHLNF: u32,
                pimkTarget: ?*IMoniker,
                pwzLocation: ?[*:0]const u16,
                pwzFriendlyName: ?[*:0]const u16,
                dwreserved: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UpdateHlink: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IHlinkFrame,
                uHLID: u32,
                pimkTarget: ?*IMoniker,
                pwzLocation: ?[*:0]const u16,
                pwzFriendlyName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IHlinkFrame,
                uHLID: u32,
                pimkTarget: ?*IMoniker,
                pwzLocation: ?[*:0]const u16,
                pwzFriendlyName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IHlinkFrame_SetBrowseContext(self: *const T, pihlbc: ?*IHlinkBrowseContext) HRESULT {
                return @as(*const IHlinkFrame.VTable, @ptrCast(self.vtable)).SetBrowseContext(@as(*const IHlinkFrame, @ptrCast(self)), pihlbc);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IHlinkFrame_GetBrowseContext(self: *const T, ppihlbc: ?*?*IHlinkBrowseContext) HRESULT {
                return @as(*const IHlinkFrame.VTable, @ptrCast(self.vtable)).GetBrowseContext(@as(*const IHlinkFrame, @ptrCast(self)), ppihlbc);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IHlinkFrame_Navigate(self: *const T, grfHLNF: u32, pbc: ?*IBindCtx, pibsc: ?*IBindStatusCallback, pihlNavigate: ?*IHlink) HRESULT {
                return @as(*const IHlinkFrame.VTable, @ptrCast(self.vtable)).Navigate(@as(*const IHlinkFrame, @ptrCast(self)), grfHLNF, pbc, pibsc, pihlNavigate);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IHlinkFrame_OnNavigate(self: *const T, grfHLNF: u32, pimkTarget: ?*IMoniker, pwzLocation: ?[*:0]const u16, pwzFriendlyName: ?[*:0]const u16, dwreserved: u32) HRESULT {
                return @as(*const IHlinkFrame.VTable, @ptrCast(self.vtable)).OnNavigate(@as(*const IHlinkFrame, @ptrCast(self)), grfHLNF, pimkTarget, pwzLocation, pwzFriendlyName, dwreserved);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IHlinkFrame_UpdateHlink(self: *const T, uHLID: u32, pimkTarget: ?*IMoniker, pwzLocation: ?[*:0]const u16, pwzFriendlyName: ?[*:0]const u16) HRESULT {
                return @as(*const IHlinkFrame.VTable, @ptrCast(self.vtable)).UpdateHlink(@as(*const IHlinkFrame, @ptrCast(self)), uHLID, pimkTarget, pwzLocation, pwzFriendlyName);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const HLITEM = extern struct {
    uHLID: u32,
    pwzFriendlyName: ?PWSTR,
};

const IID_IEnumHLITEM_Value = Guid.initString("79eac9c6-baf9-11ce-8c82-00aa004ba90b");
pub const IID_IEnumHLITEM = &IID_IEnumHLITEM_Value;
pub const IEnumHLITEM = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumHLITEM,
                celt: u32,
                rgelt: ?*HLITEM,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumHLITEM,
                celt: u32,
                rgelt: ?*HLITEM,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumHLITEM,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumHLITEM,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumHLITEM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumHLITEM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumHLITEM,
                ppienumhlitem: ?*?*IEnumHLITEM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumHLITEM,
                ppienumhlitem: ?*?*IEnumHLITEM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumHLITEM_Next(self: *const T, celt: u32, rgelt: ?*HLITEM, pceltFetched: ?*u32) HRESULT {
                return @as(*const IEnumHLITEM.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumHLITEM, @ptrCast(self)), celt, rgelt, pceltFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumHLITEM_Skip(self: *const T, celt: u32) HRESULT {
                return @as(*const IEnumHLITEM.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumHLITEM, @ptrCast(self)), celt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumHLITEM_Reset(self: *const T) HRESULT {
                return @as(*const IEnumHLITEM.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumHLITEM, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumHLITEM_Clone(self: *const T, ppienumhlitem: ?*?*IEnumHLITEM) HRESULT {
                return @as(*const IEnumHLITEM.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumHLITEM, @ptrCast(self)), ppienumhlitem);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const HLTB_INFO = enum(i32) {
    DOCKEDLEFT = 0,
    DOCKEDTOP = 1,
    DOCKEDRIGHT = 2,
    DOCKEDBOTTOM = 3,
    FLOATING = 4,
};
pub const HLTB_DOCKEDLEFT = HLTB_INFO.DOCKEDLEFT;
pub const HLTB_DOCKEDTOP = HLTB_INFO.DOCKEDTOP;
pub const HLTB_DOCKEDRIGHT = HLTB_INFO.DOCKEDRIGHT;
pub const HLTB_DOCKEDBOTTOM = HLTB_INFO.DOCKEDBOTTOM;
pub const HLTB_FLOATING = HLTB_INFO.FLOATING;

pub const HLTBINFO = extern struct {
    uDockType: u32,
    rcTbPos: RECT,
};

pub const HLBWIF_FLAGS = enum(u32) {
    HASFRAMEWNDINFO = 1,
    HASDOCWNDINFO = 2,
    FRAMEWNDMAXIMIZED = 4,
    DOCWNDMAXIMIZED = 8,
    HASWEBTOOLBARINFO = 16,
    WEBTOOLBARHIDDEN = 32,
    _,
    pub fn initFlags(o: struct {
        HASFRAMEWNDINFO: u1 = 0,
        HASDOCWNDINFO: u1 = 0,
        FRAMEWNDMAXIMIZED: u1 = 0,
        DOCWNDMAXIMIZED: u1 = 0,
        HASWEBTOOLBARINFO: u1 = 0,
        WEBTOOLBARHIDDEN: u1 = 0,
    }) HLBWIF_FLAGS {
        return @as(HLBWIF_FLAGS, @enumFromInt((if (o.HASFRAMEWNDINFO == 1) @intFromEnum(HLBWIF_FLAGS.HASFRAMEWNDINFO) else 0) | (if (o.HASDOCWNDINFO == 1) @intFromEnum(HLBWIF_FLAGS.HASDOCWNDINFO) else 0) | (if (o.FRAMEWNDMAXIMIZED == 1) @intFromEnum(HLBWIF_FLAGS.FRAMEWNDMAXIMIZED) else 0) | (if (o.DOCWNDMAXIMIZED == 1) @intFromEnum(HLBWIF_FLAGS.DOCWNDMAXIMIZED) else 0) | (if (o.HASWEBTOOLBARINFO == 1) @intFromEnum(HLBWIF_FLAGS.HASWEBTOOLBARINFO) else 0) | (if (o.WEBTOOLBARHIDDEN == 1) @intFromEnum(HLBWIF_FLAGS.WEBTOOLBARHIDDEN) else 0)));
    }
};
pub const HLBWIF_HASFRAMEWNDINFO = HLBWIF_FLAGS.HASFRAMEWNDINFO;
pub const HLBWIF_HASDOCWNDINFO = HLBWIF_FLAGS.HASDOCWNDINFO;
pub const HLBWIF_FRAMEWNDMAXIMIZED = HLBWIF_FLAGS.FRAMEWNDMAXIMIZED;
pub const HLBWIF_DOCWNDMAXIMIZED = HLBWIF_FLAGS.DOCWNDMAXIMIZED;
pub const HLBWIF_HASWEBTOOLBARINFO = HLBWIF_FLAGS.HASWEBTOOLBARINFO;
pub const HLBWIF_WEBTOOLBARHIDDEN = HLBWIF_FLAGS.WEBTOOLBARHIDDEN;

pub const HLBWINFO = extern struct {
    cbSize: u32,
    grfHLBWIF: u32,
    rcFramePos: RECT,
    rcDocPos: RECT,
    hltbinfo: HLTBINFO,
};

pub const HLID_INFO = enum(u32) {
    INVALID = 0,
    PREVIOUS = 4294967295,
    NEXT = 4294967294,
    CURRENT = 4294967293,
    STACKBOTTOM = 4294967292,
    STACKTOP = 4294967291,
};
pub const HLID_INVALID = HLID_INFO.INVALID;
pub const HLID_PREVIOUS = HLID_INFO.PREVIOUS;
pub const HLID_NEXT = HLID_INFO.NEXT;
pub const HLID_CURRENT = HLID_INFO.CURRENT;
pub const HLID_STACKBOTTOM = HLID_INFO.STACKBOTTOM;
pub const HLID_STACKTOP = HLID_INFO.STACKTOP;

pub const HLQF_INFO = enum(i32) {
    VALID = 1,
    CURRENT = 2,
};
pub const HLQF_ISVALID = HLQF_INFO.VALID;
pub const HLQF_ISCURRENT = HLQF_INFO.CURRENT;

const IID_IHlinkBrowseContext_Value = Guid.initString("79eac9c7-baf9-11ce-8c82-00aa004ba90b");
pub const IID_IHlinkBrowseContext = &IID_IHlinkBrowseContext_Value;
pub const IHlinkBrowseContext = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Register: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IHlinkBrowseContext,
                reserved: u32,
                piunk: ?*IUnknown,
                pimk: ?*IMoniker,
                pdwRegister: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IHlinkBrowseContext,
                reserved: u32,
                piunk: ?*IUnknown,
                pimk: ?*IMoniker,
                pdwRegister: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IHlinkBrowseContext,
                pimk: ?*IMoniker,
                fBindIfRootRegistered: BOOL,
                ppiunk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IHlinkBrowseContext,
                pimk: ?*IMoniker,
                fBindIfRootRegistered: BOOL,
                ppiunk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Revoke: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IHlinkBrowseContext,
                dwRegister: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IHlinkBrowseContext,
                dwRegister: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetBrowseWindowInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IHlinkBrowseContext,
                phlbwi: ?*HLBWINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IHlinkBrowseContext,
                phlbwi: ?*HLBWINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBrowseWindowInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IHlinkBrowseContext,
                phlbwi: ?*HLBWINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IHlinkBrowseContext,
                phlbwi: ?*HLBWINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetInitialHlink: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IHlinkBrowseContext,
                pimkTarget: ?*IMoniker,
                pwzLocation: ?[*:0]const u16,
                pwzFriendlyName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IHlinkBrowseContext,
                pimkTarget: ?*IMoniker,
                pwzLocation: ?[*:0]const u16,
                pwzFriendlyName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnNavigateHlink: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IHlinkBrowseContext,
                grfHLNF: u32,
                pimkTarget: ?*IMoniker,
                pwzLocation: ?[*:0]const u16,
                pwzFriendlyName: ?[*:0]const u16,
                puHLID: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IHlinkBrowseContext,
                grfHLNF: u32,
                pimkTarget: ?*IMoniker,
                pwzLocation: ?[*:0]const u16,
                pwzFriendlyName: ?[*:0]const u16,
                puHLID: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UpdateHlink: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IHlinkBrowseContext,
                uHLID: u32,
                pimkTarget: ?*IMoniker,
                pwzLocation: ?[*:0]const u16,
                pwzFriendlyName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IHlinkBrowseContext,
                uHLID: u32,
                pimkTarget: ?*IMoniker,
                pwzLocation: ?[*:0]const u16,
                pwzFriendlyName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumNavigationStack: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IHlinkBrowseContext,
                dwReserved: u32,
                grfHLFNAMEF: u32,
                ppienumhlitem: ?*?*IEnumHLITEM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IHlinkBrowseContext,
                dwReserved: u32,
                grfHLFNAMEF: u32,
                ppienumhlitem: ?*?*IEnumHLITEM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryHlink: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IHlinkBrowseContext,
                grfHLQF: u32,
                uHLID: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IHlinkBrowseContext,
                grfHLQF: u32,
                uHLID: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetHlink: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IHlinkBrowseContext,
                uHLID: u32,
                ppihl: ?*?*IHlink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IHlinkBrowseContext,
                uHLID: u32,
                ppihl: ?*?*IHlink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCurrentHlink: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IHlinkBrowseContext,
                uHLID: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IHlinkBrowseContext,
                uHLID: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IHlinkBrowseContext,
                piunkOuter: ?*IUnknown,
                riid: ?*const Guid,
                ppiunkObj: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IHlinkBrowseContext,
                piunkOuter: ?*IUnknown,
                riid: ?*const Guid,
                ppiunkObj: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Close: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IHlinkBrowseContext,
                reserved: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IHlinkBrowseContext,
                reserved: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IHlinkBrowseContext_Register(self: *const T, reserved: u32, piunk: ?*IUnknown, pimk: ?*IMoniker, pdwRegister: ?*u32) HRESULT {
                return @as(*const IHlinkBrowseContext.VTable, @ptrCast(self.vtable)).Register(@as(*const IHlinkBrowseContext, @ptrCast(self)), reserved, piunk, pimk, pdwRegister);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IHlinkBrowseContext_GetObject(self: *const T, pimk: ?*IMoniker, fBindIfRootRegistered: BOOL, ppiunk: ?*?*IUnknown) HRESULT {
                return @as(*const IHlinkBrowseContext.VTable, @ptrCast(self.vtable)).GetObject(@as(*const IHlinkBrowseContext, @ptrCast(self)), pimk, fBindIfRootRegistered, ppiunk);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IHlinkBrowseContext_Revoke(self: *const T, dwRegister: u32) HRESULT {
                return @as(*const IHlinkBrowseContext.VTable, @ptrCast(self.vtable)).Revoke(@as(*const IHlinkBrowseContext, @ptrCast(self)), dwRegister);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IHlinkBrowseContext_SetBrowseWindowInfo(self: *const T, phlbwi: ?*HLBWINFO) HRESULT {
                return @as(*const IHlinkBrowseContext.VTable, @ptrCast(self.vtable)).SetBrowseWindowInfo(@as(*const IHlinkBrowseContext, @ptrCast(self)), phlbwi);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IHlinkBrowseContext_GetBrowseWindowInfo(self: *const T, phlbwi: ?*HLBWINFO) HRESULT {
                return @as(*const IHlinkBrowseContext.VTable, @ptrCast(self.vtable)).GetBrowseWindowInfo(@as(*const IHlinkBrowseContext, @ptrCast(self)), phlbwi);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IHlinkBrowseContext_SetInitialHlink(self: *const T, pimkTarget: ?*IMoniker, pwzLocation: ?[*:0]const u16, pwzFriendlyName: ?[*:0]const u16) HRESULT {
                return @as(*const IHlinkBrowseContext.VTable, @ptrCast(self.vtable)).SetInitialHlink(@as(*const IHlinkBrowseContext, @ptrCast(self)), pimkTarget, pwzLocation, pwzFriendlyName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IHlinkBrowseContext_OnNavigateHlink(self: *const T, grfHLNF: u32, pimkTarget: ?*IMoniker, pwzLocation: ?[*:0]const u16, pwzFriendlyName: ?[*:0]const u16, puHLID: ?*u32) HRESULT {
                return @as(*const IHlinkBrowseContext.VTable, @ptrCast(self.vtable)).OnNavigateHlink(@as(*const IHlinkBrowseContext, @ptrCast(self)), grfHLNF, pimkTarget, pwzLocation, pwzFriendlyName, puHLID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IHlinkBrowseContext_UpdateHlink(self: *const T, uHLID: u32, pimkTarget: ?*IMoniker, pwzLocation: ?[*:0]const u16, pwzFriendlyName: ?[*:0]const u16) HRESULT {
                return @as(*const IHlinkBrowseContext.VTable, @ptrCast(self.vtable)).UpdateHlink(@as(*const IHlinkBrowseContext, @ptrCast(self)), uHLID, pimkTarget, pwzLocation, pwzFriendlyName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IHlinkBrowseContext_EnumNavigationStack(self: *const T, dwReserved: u32, grfHLFNAMEF: u32, ppienumhlitem: ?*?*IEnumHLITEM) HRESULT {
                return @as(*const IHlinkBrowseContext.VTable, @ptrCast(self.vtable)).EnumNavigationStack(@as(*const IHlinkBrowseContext, @ptrCast(self)), dwReserved, grfHLFNAMEF, ppienumhlitem);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IHlinkBrowseContext_QueryHlink(self: *const T, grfHLQF: u32, uHLID: u32) HRESULT {
                return @as(*const IHlinkBrowseContext.VTable, @ptrCast(self.vtable)).QueryHlink(@as(*const IHlinkBrowseContext, @ptrCast(self)), grfHLQF, uHLID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IHlinkBrowseContext_GetHlink(self: *const T, uHLID: u32, ppihl: ?*?*IHlink) HRESULT {
                return @as(*const IHlinkBrowseContext.VTable, @ptrCast(self.vtable)).GetHlink(@as(*const IHlinkBrowseContext, @ptrCast(self)), uHLID, ppihl);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IHlinkBrowseContext_SetCurrentHlink(self: *const T, uHLID: u32) HRESULT {
                return @as(*const IHlinkBrowseContext.VTable, @ptrCast(self.vtable)).SetCurrentHlink(@as(*const IHlinkBrowseContext, @ptrCast(self)), uHLID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IHlinkBrowseContext_Clone(self: *const T, piunkOuter: ?*IUnknown, riid: ?*const Guid, ppiunkObj: ?*?*IUnknown) HRESULT {
                return @as(*const IHlinkBrowseContext.VTable, @ptrCast(self.vtable)).Clone(@as(*const IHlinkBrowseContext, @ptrCast(self)), piunkOuter, riid, ppiunkObj);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IHlinkBrowseContext_Close(self: *const T, reserved: u32) HRESULT {
                return @as(*const IHlinkBrowseContext.VTable, @ptrCast(self.vtable)).Close(@as(*const IHlinkBrowseContext, @ptrCast(self)), reserved);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IExtensionServices_Value = Guid.initString("79eac9cb-baf9-11ce-8c82-00aa004ba90b");
pub const IID_IExtensionServices = &IID_IExtensionServices_Value;
pub const IExtensionServices = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetAdditionalHeaders: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IExtensionServices,
                pwzAdditionalHeaders: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IExtensionServices,
                pwzAdditionalHeaders: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetAuthenticateData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IExtensionServices,
                phwnd: ?HWND,
                pwzUsername: ?[*:0]const u16,
                pwzPassword: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IExtensionServices,
                phwnd: ?HWND,
                pwzUsername: ?[*:0]const u16,
                pwzPassword: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IExtensionServices_SetAdditionalHeaders(self: *const T, pwzAdditionalHeaders: ?[*:0]const u16) HRESULT {
                return @as(*const IExtensionServices.VTable, @ptrCast(self.vtable)).SetAdditionalHeaders(@as(*const IExtensionServices, @ptrCast(self)), pwzAdditionalHeaders);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IExtensionServices_SetAuthenticateData(self: *const T, phwnd: ?HWND, pwzUsername: ?[*:0]const u16, pwzPassword: ?[*:0]const u16) HRESULT {
                return @as(*const IExtensionServices.VTable, @ptrCast(self.vtable)).SetAuthenticateData(@as(*const IExtensionServices, @ptrCast(self)), phwnd, pwzUsername, pwzPassword);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITravelEntry_Value = Guid.initString("f46edb3b-bc2f-11d0-9412-00aa00a3ebd3");
pub const IID_ITravelEntry = &IID_ITravelEntry_Value;
pub const ITravelEntry = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Invoke: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITravelEntry,
                punk: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITravelEntry,
                punk: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Update: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITravelEntry,
                punk: ?*IUnknown,
                fIsLocalAnchor: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITravelEntry,
                punk: ?*IUnknown,
                fIsLocalAnchor: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPidl: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITravelEntry,
                ppidl: ?*?*ITEMIDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITravelEntry,
                ppidl: ?*?*ITEMIDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITravelEntry_Invoke(self: *const T, punk: ?*IUnknown) HRESULT {
                return @as(*const ITravelEntry.VTable, @ptrCast(self.vtable)).Invoke(@as(*const ITravelEntry, @ptrCast(self)), punk);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITravelEntry_Update(self: *const T, punk: ?*IUnknown, fIsLocalAnchor: BOOL) HRESULT {
                return @as(*const ITravelEntry.VTable, @ptrCast(self.vtable)).Update(@as(*const ITravelEntry, @ptrCast(self)), punk, fIsLocalAnchor);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITravelEntry_GetPidl(self: *const T, ppidl: ?*?*ITEMIDLIST) HRESULT {
                return @as(*const ITravelEntry.VTable, @ptrCast(self.vtable)).GetPidl(@as(*const ITravelEntry, @ptrCast(self)), ppidl);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITravelLog_Value = Guid.initString("66a9cb08-4802-11d2-a561-00a0c92dbfe8");
pub const IID_ITravelLog = &IID_ITravelLog_Value;
pub const ITravelLog = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddEntry: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITravelLog,
                punk: ?*IUnknown,
                fIsLocalAnchor: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITravelLog,
                punk: ?*IUnknown,
                fIsLocalAnchor: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UpdateEntry: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITravelLog,
                punk: ?*IUnknown,
                fIsLocalAnchor: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITravelLog,
                punk: ?*IUnknown,
                fIsLocalAnchor: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UpdateExternal: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITravelLog,
                punk: ?*IUnknown,
                punkHLBrowseContext: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITravelLog,
                punk: ?*IUnknown,
                punkHLBrowseContext: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Travel: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITravelLog,
                punk: ?*IUnknown,
                iOffset: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITravelLog,
                punk: ?*IUnknown,
                iOffset: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTravelEntry: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITravelLog,
                punk: ?*IUnknown,
                iOffset: i32,
                ppte: ?*?*ITravelEntry,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITravelLog,
                punk: ?*IUnknown,
                iOffset: i32,
                ppte: ?*?*ITravelEntry,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindTravelEntry: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITravelLog,
                punk: ?*IUnknown,
                pidl: ?*ITEMIDLIST,
                ppte: ?*?*ITravelEntry,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITravelLog,
                punk: ?*IUnknown,
                pidl: ?*ITEMIDLIST,
                ppte: ?*?*ITravelEntry,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetToolTipText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITravelLog,
                punk: ?*IUnknown,
                iOffset: i32,
                idsTemplate: i32,
                pwzText: [*:0]u16,
                cchText: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITravelLog,
                punk: ?*IUnknown,
                iOffset: i32,
                idsTemplate: i32,
                pwzText: [*:0]u16,
                cchText: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InsertMenuEntries: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITravelLog,
                punk: ?*IUnknown,
                hmenu: ?HMENU,
                nPos: i32,
                idFirst: i32,
                idLast: i32,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITravelLog,
                punk: ?*IUnknown,
                hmenu: ?HMENU,
                nPos: i32,
                idFirst: i32,
                idLast: i32,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITravelLog,
                pptl: ?*?*ITravelLog,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITravelLog,
                pptl: ?*?*ITravelLog,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CountEntries: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITravelLog,
                punk: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn (
                self: *const ITravelLog,
                punk: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
        Revert: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITravelLog,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITravelLog,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITravelLog_AddEntry(self: *const T, punk: ?*IUnknown, fIsLocalAnchor: BOOL) HRESULT {
                return @as(*const ITravelLog.VTable, @ptrCast(self.vtable)).AddEntry(@as(*const ITravelLog, @ptrCast(self)), punk, fIsLocalAnchor);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITravelLog_UpdateEntry(self: *const T, punk: ?*IUnknown, fIsLocalAnchor: BOOL) HRESULT {
                return @as(*const ITravelLog.VTable, @ptrCast(self.vtable)).UpdateEntry(@as(*const ITravelLog, @ptrCast(self)), punk, fIsLocalAnchor);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITravelLog_UpdateExternal(self: *const T, punk: ?*IUnknown, punkHLBrowseContext: ?*IUnknown) HRESULT {
                return @as(*const ITravelLog.VTable, @ptrCast(self.vtable)).UpdateExternal(@as(*const ITravelLog, @ptrCast(self)), punk, punkHLBrowseContext);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITravelLog_Travel(self: *const T, punk: ?*IUnknown, iOffset: i32) HRESULT {
                return @as(*const ITravelLog.VTable, @ptrCast(self.vtable)).Travel(@as(*const ITravelLog, @ptrCast(self)), punk, iOffset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITravelLog_GetTravelEntry(self: *const T, punk: ?*IUnknown, iOffset: i32, ppte: ?*?*ITravelEntry) HRESULT {
                return @as(*const ITravelLog.VTable, @ptrCast(self.vtable)).GetTravelEntry(@as(*const ITravelLog, @ptrCast(self)), punk, iOffset, ppte);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITravelLog_FindTravelEntry(self: *const T, punk: ?*IUnknown, pidl: ?*ITEMIDLIST, ppte: ?*?*ITravelEntry) HRESULT {
                return @as(*const ITravelLog.VTable, @ptrCast(self.vtable)).FindTravelEntry(@as(*const ITravelLog, @ptrCast(self)), punk, pidl, ppte);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITravelLog_GetToolTipText(self: *const T, punk: ?*IUnknown, iOffset: i32, idsTemplate: i32, pwzText: [*:0]u16, cchText: u32) HRESULT {
                return @as(*const ITravelLog.VTable, @ptrCast(self.vtable)).GetToolTipText(@as(*const ITravelLog, @ptrCast(self)), punk, iOffset, idsTemplate, pwzText, cchText);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITravelLog_InsertMenuEntries(self: *const T, punk: ?*IUnknown, hmenu: ?HMENU, nPos: i32, idFirst: i32, idLast: i32, dwFlags: u32) HRESULT {
                return @as(*const ITravelLog.VTable, @ptrCast(self.vtable)).InsertMenuEntries(@as(*const ITravelLog, @ptrCast(self)), punk, hmenu, nPos, idFirst, idLast, dwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITravelLog_Clone(self: *const T, pptl: ?*?*ITravelLog) HRESULT {
                return @as(*const ITravelLog.VTable, @ptrCast(self.vtable)).Clone(@as(*const ITravelLog, @ptrCast(self)), pptl);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITravelLog_CountEntries(self: *const T, punk: ?*IUnknown) u32 {
                return @as(*const ITravelLog.VTable, @ptrCast(self.vtable)).CountEntries(@as(*const ITravelLog, @ptrCast(self)), punk);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITravelLog_Revert(self: *const T) HRESULT {
                return @as(*const ITravelLog.VTable, @ptrCast(self.vtable)).Revert(@as(*const ITravelLog, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const CIE4ConnectionPoint = extern struct {
    pub const VTable = extern struct {
        base: IConnectionPoint.VTable,
        DoInvokeIE4: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const CIE4ConnectionPoint,
                pf: ?*BOOL,
                ppv: ?*?*anyopaque,
                dispid: i32,
                pdispparams: ?*DISPPARAMS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const CIE4ConnectionPoint,
                pf: ?*BOOL,
                ppv: ?*?*anyopaque,
                dispid: i32,
                pdispparams: ?*DISPPARAMS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DoInvokePIDLIE4: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const CIE4ConnectionPoint,
                dispid: i32,
                pidl: ?*ITEMIDLIST,
                fCanCancel: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const CIE4ConnectionPoint,
                dispid: i32,
                pidl: ?*ITEMIDLIST,
                fCanCancel: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IConnectionPoint.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn CIE4ConnectionPoint_DoInvokeIE4(self: *const T, pf: ?*BOOL, ppv: ?*?*anyopaque, dispid: i32, pdispparams: ?*DISPPARAMS) HRESULT {
                return @as(*const CIE4ConnectionPoint.VTable, @ptrCast(self.vtable)).DoInvokeIE4(@as(*const CIE4ConnectionPoint, @ptrCast(self)), pf, ppv, dispid, pdispparams);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn CIE4ConnectionPoint_DoInvokePIDLIE4(self: *const T, dispid: i32, pidl: ?*ITEMIDLIST, fCanCancel: BOOL) HRESULT {
                return @as(*const CIE4ConnectionPoint.VTable, @ptrCast(self.vtable)).DoInvokePIDLIE4(@as(*const CIE4ConnectionPoint, @ptrCast(self)), dispid, pidl, fCanCancel);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IExpDispSupportXP_Value = Guid.initString("2f0dd58c-f789-4f14-99fb-9293b3c9c212");
pub const IID_IExpDispSupportXP = &IID_IExpDispSupportXP_Value;
pub const IExpDispSupportXP = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        FindCIE4ConnectionPoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IExpDispSupportXP,
                riid: ?*const Guid,
                ppccp: ?*?*CIE4ConnectionPoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IExpDispSupportXP,
                riid: ?*const Guid,
                ppccp: ?*?*CIE4ConnectionPoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnTranslateAccelerator: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IExpDispSupportXP,
                pMsg: ?*MSG,
                grfModifiers: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IExpDispSupportXP,
                pMsg: ?*MSG,
                grfModifiers: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnInvoke: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IExpDispSupportXP,
                dispidMember: i32,
                iid: ?*const Guid,
                lcid: u32,
                wFlags: u16,
                pdispparams: ?*DISPPARAMS,
                pVarResult: ?*VARIANT,
                pexcepinfo: ?*EXCEPINFO,
                puArgErr: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IExpDispSupportXP,
                dispidMember: i32,
                iid: ?*const Guid,
                lcid: u32,
                wFlags: u16,
                pdispparams: ?*DISPPARAMS,
                pVarResult: ?*VARIANT,
                pexcepinfo: ?*EXCEPINFO,
                puArgErr: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IExpDispSupportXP_FindCIE4ConnectionPoint(self: *const T, riid: ?*const Guid, ppccp: ?*?*CIE4ConnectionPoint) HRESULT {
                return @as(*const IExpDispSupportXP.VTable, @ptrCast(self.vtable)).FindCIE4ConnectionPoint(@as(*const IExpDispSupportXP, @ptrCast(self)), riid, ppccp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IExpDispSupportXP_OnTranslateAccelerator(self: *const T, pMsg: ?*MSG, grfModifiers: u32) HRESULT {
                return @as(*const IExpDispSupportXP.VTable, @ptrCast(self.vtable)).OnTranslateAccelerator(@as(*const IExpDispSupportXP, @ptrCast(self)), pMsg, grfModifiers);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IExpDispSupportXP_OnInvoke(self: *const T, dispidMember: i32, iid: ?*const Guid, lcid: u32, wFlags: u16, pdispparams: ?*DISPPARAMS, pVarResult: ?*VARIANT, pexcepinfo: ?*EXCEPINFO, puArgErr: ?*u32) HRESULT {
                return @as(*const IExpDispSupportXP.VTable, @ptrCast(self.vtable)).OnInvoke(@as(*const IExpDispSupportXP, @ptrCast(self)), dispidMember, iid, lcid, wFlags, pdispparams, pVarResult, pexcepinfo, puArgErr);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IExpDispSupport_Value = Guid.initString("0d7d1d00-6fc0-11d0-a974-00c04fd705a2");
pub const IID_IExpDispSupport = &IID_IExpDispSupport_Value;
pub const IExpDispSupport = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        FindConnectionPoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IExpDispSupport,
                riid: ?*const Guid,
                ppccp: ?*?*IConnectionPoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IExpDispSupport,
                riid: ?*const Guid,
                ppccp: ?*?*IConnectionPoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnTranslateAccelerator: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IExpDispSupport,
                pMsg: ?*MSG,
                grfModifiers: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IExpDispSupport,
                pMsg: ?*MSG,
                grfModifiers: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnInvoke: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IExpDispSupport,
                dispidMember: i32,
                iid: ?*const Guid,
                lcid: u32,
                wFlags: u16,
                pdispparams: ?*DISPPARAMS,
                pVarResult: ?*VARIANT,
                pexcepinfo: ?*EXCEPINFO,
                puArgErr: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IExpDispSupport,
                dispidMember: i32,
                iid: ?*const Guid,
                lcid: u32,
                wFlags: u16,
                pdispparams: ?*DISPPARAMS,
                pVarResult: ?*VARIANT,
                pexcepinfo: ?*EXCEPINFO,
                puArgErr: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IExpDispSupport_FindConnectionPoint(self: *const T, riid: ?*const Guid, ppccp: ?*?*IConnectionPoint) HRESULT {
                return @as(*const IExpDispSupport.VTable, @ptrCast(self.vtable)).FindConnectionPoint(@as(*const IExpDispSupport, @ptrCast(self)), riid, ppccp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IExpDispSupport_OnTranslateAccelerator(self: *const T, pMsg: ?*MSG, grfModifiers: u32) HRESULT {
                return @as(*const IExpDispSupport.VTable, @ptrCast(self.vtable)).OnTranslateAccelerator(@as(*const IExpDispSupport, @ptrCast(self)), pMsg, grfModifiers);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IExpDispSupport_OnInvoke(self: *const T, dispidMember: i32, iid: ?*const Guid, lcid: u32, wFlags: u16, pdispparams: ?*DISPPARAMS, pVarResult: ?*VARIANT, pexcepinfo: ?*EXCEPINFO, puArgErr: ?*u32) HRESULT {
                return @as(*const IExpDispSupport.VTable, @ptrCast(self.vtable)).OnInvoke(@as(*const IExpDispSupport, @ptrCast(self)), dispidMember, iid, lcid, wFlags, pdispparams, pVarResult, pexcepinfo, puArgErr);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const BNSTATE = enum(i32) {
    NORMAL = 0,
    BEGIN_NAVIGATE = 1,
    NAVIGATE = 2,
};
pub const BNS_NORMAL = BNSTATE.NORMAL;
pub const BNS_BEGIN_NAVIGATE = BNSTATE.BEGIN_NAVIGATE;
pub const BNS_NAVIGATE = BNSTATE.NAVIGATE;

pub const SHELLBROWSERSHOWCONTROL = enum(i32) {
    HIDE = 0,
    SHOW = 1,
    TOGGLE = 2,
    QUERY = 3,
};
pub const SBSC_HIDE = SHELLBROWSERSHOWCONTROL.HIDE;
pub const SBSC_SHOW = SHELLBROWSERSHOWCONTROL.SHOW;
pub const SBSC_TOGGLE = SHELLBROWSERSHOWCONTROL.TOGGLE;
pub const SBSC_QUERY = SHELLBROWSERSHOWCONTROL.QUERY;

const IID_IBrowserService_Value = Guid.initString("02ba3b52-0547-11d1-b833-00c04fc9b31f");
pub const IID_IBrowserService = &IID_IBrowserService_Value;
pub const IBrowserService = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetParentSite: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService,
                ppipsite: ?*?*IOleInPlaceSite,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBrowserService,
                ppipsite: ?*?*IOleInPlaceSite,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTitle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService,
                psv: ?*IShellView,
                pszName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBrowserService,
                psv: ?*IShellView,
                pszName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTitle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService,
                psv: ?*IShellView,
                pszName: [*:0]u16,
                cchName: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBrowserService,
                psv: ?*IShellView,
                pszName: [*:0]u16,
                cchName: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOleObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService,
                ppobjv: ?*?*IOleObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBrowserService,
                ppobjv: ?*?*IOleObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTravelLog: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService,
                pptl: ?*?*ITravelLog,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBrowserService,
                pptl: ?*?*ITravelLog,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ShowControlWindow: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService,
                id: u32,
                fShow: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBrowserService,
                id: u32,
                fShow: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsControlWindowShown: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService,
                id: u32,
                pfShown: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBrowserService,
                id: u32,
                pfShown: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IEGetDisplayName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService,
                pidl: ?*ITEMIDLIST,
                pwszName: ?PWSTR,
                uFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBrowserService,
                pidl: ?*ITEMIDLIST,
                pwszName: ?PWSTR,
                uFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IEParseDisplayName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService,
                uiCP: u32,
                pwszPath: ?[*:0]const u16,
                ppidlOut: ?*?*ITEMIDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBrowserService,
                uiCP: u32,
                pwszPath: ?[*:0]const u16,
                ppidlOut: ?*?*ITEMIDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DisplayParseError: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService,
                hres: HRESULT,
                pwszPath: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBrowserService,
                hres: HRESULT,
                pwszPath: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NavigateToPidl: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService,
                pidl: ?*ITEMIDLIST,
                grfHLNF: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBrowserService,
                pidl: ?*ITEMIDLIST,
                grfHLNF: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetNavigateState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService,
                bnstate: BNSTATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBrowserService,
                bnstate: BNSTATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNavigateState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService,
                pbnstate: ?*BNSTATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBrowserService,
                pbnstate: ?*BNSTATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NotifyRedirect: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService,
                psv: ?*IShellView,
                pidl: ?*ITEMIDLIST,
                pfDidBrowse: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBrowserService,
                psv: ?*IShellView,
                pidl: ?*ITEMIDLIST,
                pfDidBrowse: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UpdateWindowList: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBrowserService,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UpdateBackForwardState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBrowserService,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService,
                dwFlags: u32,
                dwFlagMask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBrowserService,
                dwFlags: u32,
                dwFlagMask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService,
                pdwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBrowserService,
                pdwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CanNavigateNow: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBrowserService,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPidl: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService,
                ppidl: ?*?*ITEMIDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBrowserService,
                ppidl: ?*?*ITEMIDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetReferrer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService,
                pidl: ?*ITEMIDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBrowserService,
                pidl: ?*ITEMIDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBrowserIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn (
                self: *const IBrowserService,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
        GetBrowserByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService,
                dwID: u32,
                ppunk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBrowserService,
                dwID: u32,
                ppunk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetHistoryObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService,
                ppole: ?*?*IOleObject,
                pstm: ?*?*IStream,
                ppbc: ?*?*IBindCtx,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBrowserService,
                ppole: ?*?*IOleObject,
                pstm: ?*?*IStream,
                ppbc: ?*?*IBindCtx,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetHistoryObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService,
                pole: ?*IOleObject,
                fIsLocalAnchor: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBrowserService,
                pole: ?*IOleObject,
                fIsLocalAnchor: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CacheOLEServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService,
                pole: ?*IOleObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBrowserService,
                pole: ?*IOleObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSetCodePage: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService,
                pvarIn: ?*VARIANT,
                pvarOut: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBrowserService,
                pvarIn: ?*VARIANT,
                pvarOut: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnHttpEquiv: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService,
                psv: ?*IShellView,
                fDone: BOOL,
                pvarargIn: ?*VARIANT,
                pvarargOut: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBrowserService,
                psv: ?*IShellView,
                fDone: BOOL,
                pvarargIn: ?*VARIANT,
                pvarargOut: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPalette: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService,
                hpal: ?*?HPALETTE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBrowserService,
                hpal: ?*?HPALETTE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RegisterWindow: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService,
                fForceRegister: BOOL,
                swc: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBrowserService,
                fForceRegister: BOOL,
                swc: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService_GetParentSite(self: *const T, ppipsite: ?*?*IOleInPlaceSite) HRESULT {
                return @as(*const IBrowserService.VTable, @ptrCast(self.vtable)).GetParentSite(@as(*const IBrowserService, @ptrCast(self)), ppipsite);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService_SetTitle(self: *const T, psv: ?*IShellView, pszName: ?[*:0]const u16) HRESULT {
                return @as(*const IBrowserService.VTable, @ptrCast(self.vtable)).SetTitle(@as(*const IBrowserService, @ptrCast(self)), psv, pszName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService_GetTitle(self: *const T, psv: ?*IShellView, pszName: [*:0]u16, cchName: u32) HRESULT {
                return @as(*const IBrowserService.VTable, @ptrCast(self.vtable)).GetTitle(@as(*const IBrowserService, @ptrCast(self)), psv, pszName, cchName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService_GetOleObject(self: *const T, ppobjv: ?*?*IOleObject) HRESULT {
                return @as(*const IBrowserService.VTable, @ptrCast(self.vtable)).GetOleObject(@as(*const IBrowserService, @ptrCast(self)), ppobjv);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService_GetTravelLog(self: *const T, pptl: ?*?*ITravelLog) HRESULT {
                return @as(*const IBrowserService.VTable, @ptrCast(self.vtable)).GetTravelLog(@as(*const IBrowserService, @ptrCast(self)), pptl);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService_ShowControlWindow(self: *const T, id: u32, fShow: BOOL) HRESULT {
                return @as(*const IBrowserService.VTable, @ptrCast(self.vtable)).ShowControlWindow(@as(*const IBrowserService, @ptrCast(self)), id, fShow);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService_IsControlWindowShown(self: *const T, id: u32, pfShown: ?*BOOL) HRESULT {
                return @as(*const IBrowserService.VTable, @ptrCast(self.vtable)).IsControlWindowShown(@as(*const IBrowserService, @ptrCast(self)), id, pfShown);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService_IEGetDisplayName(self: *const T, pidl: ?*ITEMIDLIST, pwszName: ?PWSTR, uFlags: u32) HRESULT {
                return @as(*const IBrowserService.VTable, @ptrCast(self.vtable)).IEGetDisplayName(@as(*const IBrowserService, @ptrCast(self)), pidl, pwszName, uFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService_IEParseDisplayName(self: *const T, uiCP: u32, pwszPath: ?[*:0]const u16, ppidlOut: ?*?*ITEMIDLIST) HRESULT {
                return @as(*const IBrowserService.VTable, @ptrCast(self.vtable)).IEParseDisplayName(@as(*const IBrowserService, @ptrCast(self)), uiCP, pwszPath, ppidlOut);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService_DisplayParseError(self: *const T, hres: HRESULT, pwszPath: ?[*:0]const u16) HRESULT {
                return @as(*const IBrowserService.VTable, @ptrCast(self.vtable)).DisplayParseError(@as(*const IBrowserService, @ptrCast(self)), hres, pwszPath);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService_NavigateToPidl(self: *const T, pidl: ?*ITEMIDLIST, grfHLNF: u32) HRESULT {
                return @as(*const IBrowserService.VTable, @ptrCast(self.vtable)).NavigateToPidl(@as(*const IBrowserService, @ptrCast(self)), pidl, grfHLNF);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService_SetNavigateState(self: *const T, bnstate: BNSTATE) HRESULT {
                return @as(*const IBrowserService.VTable, @ptrCast(self.vtable)).SetNavigateState(@as(*const IBrowserService, @ptrCast(self)), bnstate);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService_GetNavigateState(self: *const T, pbnstate: ?*BNSTATE) HRESULT {
                return @as(*const IBrowserService.VTable, @ptrCast(self.vtable)).GetNavigateState(@as(*const IBrowserService, @ptrCast(self)), pbnstate);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService_NotifyRedirect(self: *const T, psv: ?*IShellView, pidl: ?*ITEMIDLIST, pfDidBrowse: ?*BOOL) HRESULT {
                return @as(*const IBrowserService.VTable, @ptrCast(self.vtable)).NotifyRedirect(@as(*const IBrowserService, @ptrCast(self)), psv, pidl, pfDidBrowse);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService_UpdateWindowList(self: *const T) HRESULT {
                return @as(*const IBrowserService.VTable, @ptrCast(self.vtable)).UpdateWindowList(@as(*const IBrowserService, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService_UpdateBackForwardState(self: *const T) HRESULT {
                return @as(*const IBrowserService.VTable, @ptrCast(self.vtable)).UpdateBackForwardState(@as(*const IBrowserService, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService_SetFlags(self: *const T, dwFlags: u32, dwFlagMask: u32) HRESULT {
                return @as(*const IBrowserService.VTable, @ptrCast(self.vtable)).SetFlags(@as(*const IBrowserService, @ptrCast(self)), dwFlags, dwFlagMask);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService_GetFlags(self: *const T, pdwFlags: ?*u32) HRESULT {
                return @as(*const IBrowserService.VTable, @ptrCast(self.vtable)).GetFlags(@as(*const IBrowserService, @ptrCast(self)), pdwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService_CanNavigateNow(self: *const T) HRESULT {
                return @as(*const IBrowserService.VTable, @ptrCast(self.vtable)).CanNavigateNow(@as(*const IBrowserService, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService_GetPidl(self: *const T, ppidl: ?*?*ITEMIDLIST) HRESULT {
                return @as(*const IBrowserService.VTable, @ptrCast(self.vtable)).GetPidl(@as(*const IBrowserService, @ptrCast(self)), ppidl);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService_SetReferrer(self: *const T, pidl: ?*ITEMIDLIST) HRESULT {
                return @as(*const IBrowserService.VTable, @ptrCast(self.vtable)).SetReferrer(@as(*const IBrowserService, @ptrCast(self)), pidl);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService_GetBrowserIndex(self: *const T) u32 {
                return @as(*const IBrowserService.VTable, @ptrCast(self.vtable)).GetBrowserIndex(@as(*const IBrowserService, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService_GetBrowserByIndex(self: *const T, dwID: u32, ppunk: ?*?*IUnknown) HRESULT {
                return @as(*const IBrowserService.VTable, @ptrCast(self.vtable)).GetBrowserByIndex(@as(*const IBrowserService, @ptrCast(self)), dwID, ppunk);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService_GetHistoryObject(self: *const T, ppole: ?*?*IOleObject, pstm: ?*?*IStream, ppbc: ?*?*IBindCtx) HRESULT {
                return @as(*const IBrowserService.VTable, @ptrCast(self.vtable)).GetHistoryObject(@as(*const IBrowserService, @ptrCast(self)), ppole, pstm, ppbc);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService_SetHistoryObject(self: *const T, pole: ?*IOleObject, fIsLocalAnchor: BOOL) HRESULT {
                return @as(*const IBrowserService.VTable, @ptrCast(self.vtable)).SetHistoryObject(@as(*const IBrowserService, @ptrCast(self)), pole, fIsLocalAnchor);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService_CacheOLEServer(self: *const T, pole: ?*IOleObject) HRESULT {
                return @as(*const IBrowserService.VTable, @ptrCast(self.vtable)).CacheOLEServer(@as(*const IBrowserService, @ptrCast(self)), pole);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService_GetSetCodePage(self: *const T, pvarIn: ?*VARIANT, pvarOut: ?*VARIANT) HRESULT {
                return @as(*const IBrowserService.VTable, @ptrCast(self.vtable)).GetSetCodePage(@as(*const IBrowserService, @ptrCast(self)), pvarIn, pvarOut);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService_OnHttpEquiv(self: *const T, psv: ?*IShellView, fDone: BOOL, pvarargIn: ?*VARIANT, pvarargOut: ?*VARIANT) HRESULT {
                return @as(*const IBrowserService.VTable, @ptrCast(self.vtable)).OnHttpEquiv(@as(*const IBrowserService, @ptrCast(self)), psv, fDone, pvarargIn, pvarargOut);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService_GetPalette(self: *const T, hpal: ?*?HPALETTE) HRESULT {
                return @as(*const IBrowserService.VTable, @ptrCast(self.vtable)).GetPalette(@as(*const IBrowserService, @ptrCast(self)), hpal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService_RegisterWindow(self: *const T, fForceRegister: BOOL, swc: i32) HRESULT {
                return @as(*const IBrowserService.VTable, @ptrCast(self.vtable)).RegisterWindow(@as(*const IBrowserService, @ptrCast(self)), fForceRegister, swc);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IShellService_Value = Guid.initString("5836fb00-8187-11cf-a12b-00aa004ae837");
pub const IID_IShellService = &IID_IShellService_Value;
pub const IShellService = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetOwner: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IShellService,
                punkOwner: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IShellService,
                punkOwner: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IShellService_SetOwner(self: *const T, punkOwner: ?*IUnknown) HRESULT {
                return @as(*const IShellService.VTable, @ptrCast(self.vtable)).SetOwner(@as(*const IShellService, @ptrCast(self)), punkOwner);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SECURELOCKCODE = enum(i32) {
    NOCHANGE = -1,
    SET_UNSECURE = 0,
    SET_MIXED = 1,
    SET_SECUREUNKNOWNBIT = 2,
    SET_SECURE40BIT = 3,
    SET_SECURE56BIT = 4,
    SET_FORTEZZA = 5,
    SET_SECURE128BIT = 6,
    FIRSTSUGGEST = 7,
    // SUGGEST_UNSECURE = 7, this enum value conflicts with FIRSTSUGGEST
    SUGGEST_MIXED = 8,
    SUGGEST_SECUREUNKNOWNBIT = 9,
    SUGGEST_SECURE40BIT = 10,
    SUGGEST_SECURE56BIT = 11,
    SUGGEST_FORTEZZA = 12,
    SUGGEST_SECURE128BIT = 13,
};
pub const SECURELOCK_NOCHANGE = SECURELOCKCODE.NOCHANGE;
pub const SECURELOCK_SET_UNSECURE = SECURELOCKCODE.SET_UNSECURE;
pub const SECURELOCK_SET_MIXED = SECURELOCKCODE.SET_MIXED;
pub const SECURELOCK_SET_SECUREUNKNOWNBIT = SECURELOCKCODE.SET_SECUREUNKNOWNBIT;
pub const SECURELOCK_SET_SECURE40BIT = SECURELOCKCODE.SET_SECURE40BIT;
pub const SECURELOCK_SET_SECURE56BIT = SECURELOCKCODE.SET_SECURE56BIT;
pub const SECURELOCK_SET_FORTEZZA = SECURELOCKCODE.SET_FORTEZZA;
pub const SECURELOCK_SET_SECURE128BIT = SECURELOCKCODE.SET_SECURE128BIT;
pub const SECURELOCK_FIRSTSUGGEST = SECURELOCKCODE.FIRSTSUGGEST;
pub const SECURELOCK_SUGGEST_UNSECURE = SECURELOCKCODE.FIRSTSUGGEST;
pub const SECURELOCK_SUGGEST_MIXED = SECURELOCKCODE.SUGGEST_MIXED;
pub const SECURELOCK_SUGGEST_SECUREUNKNOWNBIT = SECURELOCKCODE.SUGGEST_SECUREUNKNOWNBIT;
pub const SECURELOCK_SUGGEST_SECURE40BIT = SECURELOCKCODE.SUGGEST_SECURE40BIT;
pub const SECURELOCK_SUGGEST_SECURE56BIT = SECURELOCKCODE.SUGGEST_SECURE56BIT;
pub const SECURELOCK_SUGGEST_FORTEZZA = SECURELOCKCODE.SUGGEST_FORTEZZA;
pub const SECURELOCK_SUGGEST_SECURE128BIT = SECURELOCKCODE.SUGGEST_SECURE128BIT;

pub const BASEBROWSERDATAXP = extern struct {
    _hwnd: ?HWND,
    _ptl: ?*ITravelLog,
    _phlf: ?*IHlinkFrame,
    _pautoWB2: ?*IWebBrowser2,
    _pautoEDS: ?*IExpDispSupportXP,
    _pautoSS: ?*IShellService,
    _eSecureLockIcon: i32,
    _bitfield: u32,
    _uActivateState: u32,
    _pidlViewState: ?*ITEMIDLIST,
    _pctView: ?*IOleCommandTarget,
    _pidlCur: ?*ITEMIDLIST,
    _psv: ?*IShellView,
    _psf: ?*IShellFolder,
    _hwndView: ?HWND,
    _pszTitleCur: ?PWSTR,
    _pidlPending: ?*ITEMIDLIST,
    _psvPending: ?*IShellView,
    _psfPending: ?*IShellFolder,
    _hwndViewPending: ?HWND,
    _pszTitlePending: ?PWSTR,
    _fIsViewMSHTML: BOOL,
    _fPrivacyImpacted: BOOL,
    _clsidView: Guid,
    _clsidViewPending: Guid,
    _hwndFrame: ?HWND,
};

pub const BASEBROWSERDATALH = extern struct {
    _hwnd: ?HWND,
    _ptl: ?*ITravelLog,
    _phlf: ?*IHlinkFrame,
    _pautoWB2: ?*IWebBrowser2,
    _pautoEDS: ?*IExpDispSupport,
    _pautoSS: ?*IShellService,
    _eSecureLockIcon: i32,
    _bitfield: u32,
    _uActivateState: u32,
    _pidlViewState: ?*ITEMIDLIST,
    _pctView: ?*IOleCommandTarget,
    _pidlCur: ?*ITEMIDLIST,
    _psv: ?*IShellView,
    _psf: ?*IShellFolder,
    _hwndView: ?HWND,
    _pszTitleCur: ?PWSTR,
    _pidlPending: ?*ITEMIDLIST,
    _psvPending: ?*IShellView,
    _psfPending: ?*IShellFolder,
    _hwndViewPending: ?HWND,
    _pszTitlePending: ?PWSTR,
    _fIsViewMSHTML: BOOL,
    _fPrivacyImpacted: BOOL,
    _clsidView: Guid,
    _clsidViewPending: Guid,
    _hwndFrame: ?HWND,
    _lPhishingFilterStatus: i32,
};

pub const FOLDERSETDATA = extern struct {
    _fs: FOLDERSETTINGS,
    _vidRestore: Guid,
    _dwViewPriority: u32,
};

pub const TOOLBARITEM = extern struct {
    ptbar: ?*IDockingWindow,
    rcBorderTool: RECT,
    pwszItem: ?PWSTR,
    fShow: BOOL,
    hMon: ?HMONITOR,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IBrowserService2_Value = Guid.initString("68bd21cc-438b-11d2-a560-00a0c92dbfe8");
pub const IID_IBrowserService2 = &IID_IBrowserService2_Value;
pub const IBrowserService2 = extern struct {
    pub const VTable = extern struct {
        base: IBrowserService.VTable,
        WndProcBS: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService2,
                hwnd: ?HWND,
                uMsg: u32,
                wParam: WPARAM,
                lParam: LPARAM,
            ) callconv(@import("std").os.windows.WINAPI) LRESULT,
            else => *const fn (
                self: *const IBrowserService2,
                hwnd: ?HWND,
                uMsg: u32,
                wParam: WPARAM,
                lParam: LPARAM,
            ) callconv(@import("std").os.windows.WINAPI) LRESULT,
        },
        SetAsDefFolderSettings: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBrowserService2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetViewRect: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService2,
                prc: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBrowserService2,
                prc: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService2,
                wParam: WPARAM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBrowserService2,
                wParam: WPARAM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnCreate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService2,
                pcs: ?*CREATESTRUCTW,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBrowserService2,
                pcs: ?*CREATESTRUCTW,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService2,
                wParam: WPARAM,
                lParam: LPARAM,
            ) callconv(@import("std").os.windows.WINAPI) LRESULT,
            else => *const fn (
                self: *const IBrowserService2,
                wParam: WPARAM,
                lParam: LPARAM,
            ) callconv(@import("std").os.windows.WINAPI) LRESULT,
        },
        OnDestroy: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBrowserService2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnNotify: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService2,
                pnm: ?*NMHDR,
            ) callconv(@import("std").os.windows.WINAPI) LRESULT,
            else => *const fn (
                self: *const IBrowserService2,
                pnm: ?*NMHDR,
            ) callconv(@import("std").os.windows.WINAPI) LRESULT,
        },
        OnSetFocus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBrowserService2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnFrameWindowActivateBS: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService2,
                fActive: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBrowserService2,
                fActive: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReleaseShellView: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBrowserService2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ActivatePendingView: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBrowserService2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateViewWindow: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService2,
                psvNew: ?*IShellView,
                psvOld: ?*IShellView,
                prcView: ?*RECT,
                phwnd: ?*?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBrowserService2,
                psvNew: ?*IShellView,
                psvOld: ?*IShellView,
                prcView: ?*RECT,
                phwnd: ?*?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateBrowserPropSheetExt: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService2,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBrowserService2,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetViewWindow: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService2,
                phwndView: ?*?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBrowserService2,
                phwndView: ?*?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBaseBrowserData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService2,
                pbbd: ?*?*BASEBROWSERDATALH,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBrowserService2,
                pbbd: ?*?*BASEBROWSERDATALH,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PutBaseBrowserData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService2,
            ) callconv(@import("std").os.windows.WINAPI) ?*BASEBROWSERDATALH,
            else => *const fn (
                self: *const IBrowserService2,
            ) callconv(@import("std").os.windows.WINAPI) ?*BASEBROWSERDATALH,
        },
        InitializeTravelLog: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService2,
                ptl: ?*ITravelLog,
                dw: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBrowserService2,
                ptl: ?*ITravelLog,
                dw: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTopBrowser: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBrowserService2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Offline: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService2,
                iCmd: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBrowserService2,
                iCmd: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AllowViewResize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService2,
                f: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBrowserService2,
                f: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetActivateState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService2,
                u: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBrowserService2,
                u: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UpdateSecureLockIcon: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService2,
                eSecureLock: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBrowserService2,
                eSecureLock: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InitializeDownloadManager: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBrowserService2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InitializeTransitionSite: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBrowserService2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        _Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService2,
                hwnd: ?HWND,
                pauto: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBrowserService2,
                hwnd: ?HWND,
                pauto: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        _CancelPendingNavigationAsync: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBrowserService2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        _CancelPendingView: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBrowserService2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        _MaySaveChanges: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBrowserService2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        _PauseOrResumeView: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService2,
                fPaused: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBrowserService2,
                fPaused: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        _DisableModeless: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBrowserService2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        _NavigateToPidl2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService2,
                pidl: ?*ITEMIDLIST,
                grfHLNF: u32,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBrowserService2,
                pidl: ?*ITEMIDLIST,
                grfHLNF: u32,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        _TryShell2Rename: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService2,
                psv: ?*IShellView,
                pidlNew: ?*ITEMIDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBrowserService2,
                psv: ?*IShellView,
                pidlNew: ?*ITEMIDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        _SwitchActivationNow: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBrowserService2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        _ExecChildren: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService2,
                punkBar: ?*IUnknown,
                fBroadcast: BOOL,
                pguidCmdGroup: ?*const Guid,
                nCmdID: u32,
                nCmdexecopt: u32,
                pvarargIn: ?*VARIANT,
                pvarargOut: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBrowserService2,
                punkBar: ?*IUnknown,
                fBroadcast: BOOL,
                pguidCmdGroup: ?*const Guid,
                nCmdID: u32,
                nCmdexecopt: u32,
                pvarargIn: ?*VARIANT,
                pvarargOut: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        _SendChildren: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService2,
                hwndBar: ?HWND,
                fBroadcast: BOOL,
                uMsg: u32,
                wParam: WPARAM,
                lParam: LPARAM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBrowserService2,
                hwndBar: ?HWND,
                fBroadcast: BOOL,
                uMsg: u32,
                wParam: WPARAM,
                lParam: LPARAM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFolderSetData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService2,
                pfsd: ?*FOLDERSETDATA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBrowserService2,
                pfsd: ?*FOLDERSETDATA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        _OnFocusChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService2,
                itb: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBrowserService2,
                itb: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        v_ShowHideChildWindows: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService2,
                fChildOnly: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBrowserService2,
                fChildOnly: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        _get_itbLastFocus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService2,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn (
                self: *const IBrowserService2,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
        _put_itbLastFocus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService2,
                itbLastFocus: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBrowserService2,
                itbLastFocus: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        _UIActivateView: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService2,
                uState: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBrowserService2,
                uState: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        _GetViewBorderRect: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService2,
                prc: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBrowserService2,
                prc: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        _UpdateViewRectSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBrowserService2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        _ResizeNextBorder: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService2,
                itb: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBrowserService2,
                itb: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        _ResizeView: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBrowserService2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        _GetEffectiveClientArea: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService2,
                lprectBorder: ?*RECT,
                hmon: ?HMONITOR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBrowserService2,
                lprectBorder: ?*RECT,
                hmon: ?HMONITOR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        v_GetViewStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService2,
                pidl: ?*ITEMIDLIST,
                grfMode: u32,
                pwszName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) ?*IStream,
            else => *const fn (
                self: *const IBrowserService2,
                pidl: ?*ITEMIDLIST,
                grfMode: u32,
                pwszName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) ?*IStream,
        },
        ForwardViewMsg: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService2,
                uMsg: u32,
                wParam: WPARAM,
                lParam: LPARAM,
            ) callconv(@import("std").os.windows.WINAPI) LRESULT,
            else => *const fn (
                self: *const IBrowserService2,
                uMsg: u32,
                wParam: WPARAM,
                lParam: LPARAM,
            ) callconv(@import("std").os.windows.WINAPI) LRESULT,
        },
        SetAcceleratorMenu: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService2,
                hacc: ?HACCEL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBrowserService2,
                hacc: ?HACCEL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        _GetToolbarCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService2,
            ) callconv(@import("std").os.windows.WINAPI) i32,
            else => *const fn (
                self: *const IBrowserService2,
            ) callconv(@import("std").os.windows.WINAPI) i32,
        },
        _GetToolbarItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService2,
                itb: i32,
            ) callconv(@import("std").os.windows.WINAPI) ?*TOOLBARITEM,
            else => *const fn (
                self: *const IBrowserService2,
                itb: i32,
            ) callconv(@import("std").os.windows.WINAPI) ?*TOOLBARITEM,
        },
        _SaveToolbars: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService2,
                pstm: ?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBrowserService2,
                pstm: ?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        _LoadToolbars: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService2,
                pstm: ?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBrowserService2,
                pstm: ?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        _CloseAndReleaseToolbars: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService2,
                fClose: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBrowserService2,
                fClose: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        v_MayGetNextToolbarFocus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService2,
                lpMsg: ?*MSG,
                itbNext: u32,
                citb: i32,
                pptbi: ?*?*TOOLBARITEM,
                phwnd: ?*?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBrowserService2,
                lpMsg: ?*MSG,
                itbNext: u32,
                citb: i32,
                pptbi: ?*?*TOOLBARITEM,
                phwnd: ?*?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        _ResizeNextBorderHelper: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService2,
                itb: u32,
                bUseHmonitor: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBrowserService2,
                itb: u32,
                bUseHmonitor: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        _FindTBar: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService2,
                punkSrc: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn (
                self: *const IBrowserService2,
                punkSrc: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
        _SetFocus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService2,
                ptbi: ?*TOOLBARITEM,
                hwnd: ?HWND,
                lpMsg: ?*MSG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBrowserService2,
                ptbi: ?*TOOLBARITEM,
                hwnd: ?HWND,
                lpMsg: ?*MSG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        v_MayTranslateAccelerator: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService2,
                pmsg: ?*MSG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBrowserService2,
                pmsg: ?*MSG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        _GetBorderDWHelper: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService2,
                punkSrc: ?*IUnknown,
                lprectBorder: ?*RECT,
                bUseHmonitor: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBrowserService2,
                punkSrc: ?*IUnknown,
                lprectBorder: ?*RECT,
                bUseHmonitor: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        v_CheckZoneCrossing: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService2,
                pidl: ?*ITEMIDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBrowserService2,
                pidl: ?*ITEMIDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IBrowserService.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService2_WndProcBS(self: *const T, hwnd: ?HWND, uMsg: u32, wParam: WPARAM, lParam: LPARAM) LRESULT {
                return @as(*const IBrowserService2.VTable, @ptrCast(self.vtable)).WndProcBS(@as(*const IBrowserService2, @ptrCast(self)), hwnd, uMsg, wParam, lParam);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService2_SetAsDefFolderSettings(self: *const T) HRESULT {
                return @as(*const IBrowserService2.VTable, @ptrCast(self.vtable)).SetAsDefFolderSettings(@as(*const IBrowserService2, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService2_GetViewRect(self: *const T, prc: ?*RECT) HRESULT {
                return @as(*const IBrowserService2.VTable, @ptrCast(self.vtable)).GetViewRect(@as(*const IBrowserService2, @ptrCast(self)), prc);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService2_OnSize(self: *const T, wParam: WPARAM) HRESULT {
                return @as(*const IBrowserService2.VTable, @ptrCast(self.vtable)).OnSize(@as(*const IBrowserService2, @ptrCast(self)), wParam);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService2_OnCreate(self: *const T, pcs: ?*CREATESTRUCTW) HRESULT {
                return @as(*const IBrowserService2.VTable, @ptrCast(self.vtable)).OnCreate(@as(*const IBrowserService2, @ptrCast(self)), pcs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService2_OnCommand(self: *const T, wParam: WPARAM, lParam: LPARAM) LRESULT {
                return @as(*const IBrowserService2.VTable, @ptrCast(self.vtable)).OnCommand(@as(*const IBrowserService2, @ptrCast(self)), wParam, lParam);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService2_OnDestroy(self: *const T) HRESULT {
                return @as(*const IBrowserService2.VTable, @ptrCast(self.vtable)).OnDestroy(@as(*const IBrowserService2, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService2_OnNotify(self: *const T, pnm: ?*NMHDR) LRESULT {
                return @as(*const IBrowserService2.VTable, @ptrCast(self.vtable)).OnNotify(@as(*const IBrowserService2, @ptrCast(self)), pnm);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService2_OnSetFocus(self: *const T) HRESULT {
                return @as(*const IBrowserService2.VTable, @ptrCast(self.vtable)).OnSetFocus(@as(*const IBrowserService2, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService2_OnFrameWindowActivateBS(self: *const T, fActive: BOOL) HRESULT {
                return @as(*const IBrowserService2.VTable, @ptrCast(self.vtable)).OnFrameWindowActivateBS(@as(*const IBrowserService2, @ptrCast(self)), fActive);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService2_ReleaseShellView(self: *const T) HRESULT {
                return @as(*const IBrowserService2.VTable, @ptrCast(self.vtable)).ReleaseShellView(@as(*const IBrowserService2, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService2_ActivatePendingView(self: *const T) HRESULT {
                return @as(*const IBrowserService2.VTable, @ptrCast(self.vtable)).ActivatePendingView(@as(*const IBrowserService2, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService2_CreateViewWindow(self: *const T, psvNew: ?*IShellView, psvOld: ?*IShellView, prcView: ?*RECT, phwnd: ?*?HWND) HRESULT {
                return @as(*const IBrowserService2.VTable, @ptrCast(self.vtable)).CreateViewWindow(@as(*const IBrowserService2, @ptrCast(self)), psvNew, psvOld, prcView, phwnd);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService2_CreateBrowserPropSheetExt(self: *const T, riid: ?*const Guid, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const IBrowserService2.VTable, @ptrCast(self.vtable)).CreateBrowserPropSheetExt(@as(*const IBrowserService2, @ptrCast(self)), riid, ppv);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService2_GetViewWindow(self: *const T, phwndView: ?*?HWND) HRESULT {
                return @as(*const IBrowserService2.VTable, @ptrCast(self.vtable)).GetViewWindow(@as(*const IBrowserService2, @ptrCast(self)), phwndView);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService2_GetBaseBrowserData(self: *const T, pbbd: ?*?*BASEBROWSERDATALH) HRESULT {
                return @as(*const IBrowserService2.VTable, @ptrCast(self.vtable)).GetBaseBrowserData(@as(*const IBrowserService2, @ptrCast(self)), pbbd);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService2_PutBaseBrowserData(self: *const T) ?*BASEBROWSERDATALH {
                return @as(*const IBrowserService2.VTable, @ptrCast(self.vtable)).PutBaseBrowserData(@as(*const IBrowserService2, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService2_InitializeTravelLog(self: *const T, ptl: ?*ITravelLog, dw: u32) HRESULT {
                return @as(*const IBrowserService2.VTable, @ptrCast(self.vtable)).InitializeTravelLog(@as(*const IBrowserService2, @ptrCast(self)), ptl, dw);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService2_SetTopBrowser(self: *const T) HRESULT {
                return @as(*const IBrowserService2.VTable, @ptrCast(self.vtable)).SetTopBrowser(@as(*const IBrowserService2, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService2_Offline(self: *const T, iCmd: i32) HRESULT {
                return @as(*const IBrowserService2.VTable, @ptrCast(self.vtable)).Offline(@as(*const IBrowserService2, @ptrCast(self)), iCmd);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService2_AllowViewResize(self: *const T, f: BOOL) HRESULT {
                return @as(*const IBrowserService2.VTable, @ptrCast(self.vtable)).AllowViewResize(@as(*const IBrowserService2, @ptrCast(self)), f);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService2_SetActivateState(self: *const T, u: u32) HRESULT {
                return @as(*const IBrowserService2.VTable, @ptrCast(self.vtable)).SetActivateState(@as(*const IBrowserService2, @ptrCast(self)), u);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService2_UpdateSecureLockIcon(self: *const T, eSecureLock: i32) HRESULT {
                return @as(*const IBrowserService2.VTable, @ptrCast(self.vtable)).UpdateSecureLockIcon(@as(*const IBrowserService2, @ptrCast(self)), eSecureLock);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService2_InitializeDownloadManager(self: *const T) HRESULT {
                return @as(*const IBrowserService2.VTable, @ptrCast(self.vtable)).InitializeDownloadManager(@as(*const IBrowserService2, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService2_InitializeTransitionSite(self: *const T) HRESULT {
                return @as(*const IBrowserService2.VTable, @ptrCast(self.vtable)).InitializeTransitionSite(@as(*const IBrowserService2, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService2__Initialize(self: *const T, hwnd: ?HWND, pauto: ?*IUnknown) HRESULT {
                return @as(*const IBrowserService2.VTable, @ptrCast(self.vtable))._Initialize(@as(*const IBrowserService2, @ptrCast(self)), hwnd, pauto);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService2__CancelPendingNavigationAsync(self: *const T) HRESULT {
                return @as(*const IBrowserService2.VTable, @ptrCast(self.vtable))._CancelPendingNavigationAsync(@as(*const IBrowserService2, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService2__CancelPendingView(self: *const T) HRESULT {
                return @as(*const IBrowserService2.VTable, @ptrCast(self.vtable))._CancelPendingView(@as(*const IBrowserService2, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService2__MaySaveChanges(self: *const T) HRESULT {
                return @as(*const IBrowserService2.VTable, @ptrCast(self.vtable))._MaySaveChanges(@as(*const IBrowserService2, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService2__PauseOrResumeView(self: *const T, fPaused: BOOL) HRESULT {
                return @as(*const IBrowserService2.VTable, @ptrCast(self.vtable))._PauseOrResumeView(@as(*const IBrowserService2, @ptrCast(self)), fPaused);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService2__DisableModeless(self: *const T) HRESULT {
                return @as(*const IBrowserService2.VTable, @ptrCast(self.vtable))._DisableModeless(@as(*const IBrowserService2, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService2__NavigateToPidl2(self: *const T, pidl: ?*ITEMIDLIST, grfHLNF: u32, dwFlags: u32) HRESULT {
                return @as(*const IBrowserService2.VTable, @ptrCast(self.vtable))._NavigateToPidl2(@as(*const IBrowserService2, @ptrCast(self)), pidl, grfHLNF, dwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService2__TryShell2Rename(self: *const T, psv: ?*IShellView, pidlNew: ?*ITEMIDLIST) HRESULT {
                return @as(*const IBrowserService2.VTable, @ptrCast(self.vtable))._TryShell2Rename(@as(*const IBrowserService2, @ptrCast(self)), psv, pidlNew);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService2__SwitchActivationNow(self: *const T) HRESULT {
                return @as(*const IBrowserService2.VTable, @ptrCast(self.vtable))._SwitchActivationNow(@as(*const IBrowserService2, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService2__ExecChildren(self: *const T, punkBar: ?*IUnknown, fBroadcast: BOOL, pguidCmdGroup: ?*const Guid, nCmdID: u32, nCmdexecopt: u32, pvarargIn: ?*VARIANT, pvarargOut: ?*VARIANT) HRESULT {
                return @as(*const IBrowserService2.VTable, @ptrCast(self.vtable))._ExecChildren(@as(*const IBrowserService2, @ptrCast(self)), punkBar, fBroadcast, pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService2__SendChildren(self: *const T, hwndBar: ?HWND, fBroadcast: BOOL, uMsg: u32, wParam: WPARAM, lParam: LPARAM) HRESULT {
                return @as(*const IBrowserService2.VTable, @ptrCast(self.vtable))._SendChildren(@as(*const IBrowserService2, @ptrCast(self)), hwndBar, fBroadcast, uMsg, wParam, lParam);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService2_GetFolderSetData(self: *const T, pfsd: ?*FOLDERSETDATA) HRESULT {
                return @as(*const IBrowserService2.VTable, @ptrCast(self.vtable)).GetFolderSetData(@as(*const IBrowserService2, @ptrCast(self)), pfsd);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService2__OnFocusChange(self: *const T, itb: u32) HRESULT {
                return @as(*const IBrowserService2.VTable, @ptrCast(self.vtable))._OnFocusChange(@as(*const IBrowserService2, @ptrCast(self)), itb);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService2_v_ShowHideChildWindows(self: *const T, fChildOnly: BOOL) HRESULT {
                return @as(*const IBrowserService2.VTable, @ptrCast(self.vtable)).v_ShowHideChildWindows(@as(*const IBrowserService2, @ptrCast(self)), fChildOnly);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService2__get_itbLastFocus(self: *const T) u32 {
                return @as(*const IBrowserService2.VTable, @ptrCast(self.vtable))._get_itbLastFocus(@as(*const IBrowserService2, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService2__put_itbLastFocus(self: *const T, itbLastFocus: u32) HRESULT {
                return @as(*const IBrowserService2.VTable, @ptrCast(self.vtable))._put_itbLastFocus(@as(*const IBrowserService2, @ptrCast(self)), itbLastFocus);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService2__UIActivateView(self: *const T, uState: u32) HRESULT {
                return @as(*const IBrowserService2.VTable, @ptrCast(self.vtable))._UIActivateView(@as(*const IBrowserService2, @ptrCast(self)), uState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService2__GetViewBorderRect(self: *const T, prc: ?*RECT) HRESULT {
                return @as(*const IBrowserService2.VTable, @ptrCast(self.vtable))._GetViewBorderRect(@as(*const IBrowserService2, @ptrCast(self)), prc);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService2__UpdateViewRectSize(self: *const T) HRESULT {
                return @as(*const IBrowserService2.VTable, @ptrCast(self.vtable))._UpdateViewRectSize(@as(*const IBrowserService2, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService2__ResizeNextBorder(self: *const T, itb: u32) HRESULT {
                return @as(*const IBrowserService2.VTable, @ptrCast(self.vtable))._ResizeNextBorder(@as(*const IBrowserService2, @ptrCast(self)), itb);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService2__ResizeView(self: *const T) HRESULT {
                return @as(*const IBrowserService2.VTable, @ptrCast(self.vtable))._ResizeView(@as(*const IBrowserService2, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService2__GetEffectiveClientArea(self: *const T, lprectBorder: ?*RECT, hmon: ?HMONITOR) HRESULT {
                return @as(*const IBrowserService2.VTable, @ptrCast(self.vtable))._GetEffectiveClientArea(@as(*const IBrowserService2, @ptrCast(self)), lprectBorder, hmon);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService2_v_GetViewStream(self: *const T, pidl: ?*ITEMIDLIST, grfMode: u32, pwszName: ?[*:0]const u16) ?*IStream {
                return @as(*const IBrowserService2.VTable, @ptrCast(self.vtable)).v_GetViewStream(@as(*const IBrowserService2, @ptrCast(self)), pidl, grfMode, pwszName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService2_ForwardViewMsg(self: *const T, uMsg: u32, wParam: WPARAM, lParam: LPARAM) LRESULT {
                return @as(*const IBrowserService2.VTable, @ptrCast(self.vtable)).ForwardViewMsg(@as(*const IBrowserService2, @ptrCast(self)), uMsg, wParam, lParam);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService2_SetAcceleratorMenu(self: *const T, hacc: ?HACCEL) HRESULT {
                return @as(*const IBrowserService2.VTable, @ptrCast(self.vtable)).SetAcceleratorMenu(@as(*const IBrowserService2, @ptrCast(self)), hacc);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService2__GetToolbarCount(self: *const T) i32 {
                return @as(*const IBrowserService2.VTable, @ptrCast(self.vtable))._GetToolbarCount(@as(*const IBrowserService2, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService2__GetToolbarItem(self: *const T, itb: i32) ?*TOOLBARITEM {
                return @as(*const IBrowserService2.VTable, @ptrCast(self.vtable))._GetToolbarItem(@as(*const IBrowserService2, @ptrCast(self)), itb);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService2__SaveToolbars(self: *const T, pstm: ?*IStream) HRESULT {
                return @as(*const IBrowserService2.VTable, @ptrCast(self.vtable))._SaveToolbars(@as(*const IBrowserService2, @ptrCast(self)), pstm);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService2__LoadToolbars(self: *const T, pstm: ?*IStream) HRESULT {
                return @as(*const IBrowserService2.VTable, @ptrCast(self.vtable))._LoadToolbars(@as(*const IBrowserService2, @ptrCast(self)), pstm);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService2__CloseAndReleaseToolbars(self: *const T, fClose: BOOL) HRESULT {
                return @as(*const IBrowserService2.VTable, @ptrCast(self.vtable))._CloseAndReleaseToolbars(@as(*const IBrowserService2, @ptrCast(self)), fClose);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService2_v_MayGetNextToolbarFocus(self: *const T, lpMsg: ?*MSG, itbNext: u32, citb: i32, pptbi: ?*?*TOOLBARITEM, phwnd: ?*?HWND) HRESULT {
                return @as(*const IBrowserService2.VTable, @ptrCast(self.vtable)).v_MayGetNextToolbarFocus(@as(*const IBrowserService2, @ptrCast(self)), lpMsg, itbNext, citb, pptbi, phwnd);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService2__ResizeNextBorderHelper(self: *const T, itb: u32, bUseHmonitor: BOOL) HRESULT {
                return @as(*const IBrowserService2.VTable, @ptrCast(self.vtable))._ResizeNextBorderHelper(@as(*const IBrowserService2, @ptrCast(self)), itb, bUseHmonitor);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService2__FindTBar(self: *const T, punkSrc: ?*IUnknown) u32 {
                return @as(*const IBrowserService2.VTable, @ptrCast(self.vtable))._FindTBar(@as(*const IBrowserService2, @ptrCast(self)), punkSrc);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService2__SetFocus(self: *const T, ptbi: ?*TOOLBARITEM, hwnd: ?HWND, lpMsg: ?*MSG) HRESULT {
                return @as(*const IBrowserService2.VTable, @ptrCast(self.vtable))._SetFocus(@as(*const IBrowserService2, @ptrCast(self)), ptbi, hwnd, lpMsg);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService2_v_MayTranslateAccelerator(self: *const T, pmsg: ?*MSG) HRESULT {
                return @as(*const IBrowserService2.VTable, @ptrCast(self.vtable)).v_MayTranslateAccelerator(@as(*const IBrowserService2, @ptrCast(self)), pmsg);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService2__GetBorderDWHelper(self: *const T, punkSrc: ?*IUnknown, lprectBorder: ?*RECT, bUseHmonitor: BOOL) HRESULT {
                return @as(*const IBrowserService2.VTable, @ptrCast(self.vtable))._GetBorderDWHelper(@as(*const IBrowserService2, @ptrCast(self)), punkSrc, lprectBorder, bUseHmonitor);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService2_v_CheckZoneCrossing(self: *const T, pidl: ?*ITEMIDLIST) HRESULT {
                return @as(*const IBrowserService2.VTable, @ptrCast(self.vtable)).v_CheckZoneCrossing(@as(*const IBrowserService2, @ptrCast(self)), pidl);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const IEPDNFLAGS = enum(i32) {
    I = 1,
};
pub const IEPDN_BINDINGUI = IEPDNFLAGS.I;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IBrowserService3_Value = Guid.initString("27d7ce21-762d-48f3-86f3-40e2fd3749c4");
pub const IID_IBrowserService3 = &IID_IBrowserService3_Value;
pub const IBrowserService3 = extern struct {
    pub const VTable = extern struct {
        base: IBrowserService2.VTable,
        _PositionViewWindow: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService3,
                hwnd: ?HWND,
                prc: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBrowserService3,
                hwnd: ?HWND,
                prc: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IEParseDisplayNameEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService3,
                uiCP: u32,
                pwszPath: ?[*:0]const u16,
                dwFlags: u32,
                ppidlOut: ?*?*ITEMIDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBrowserService3,
                uiCP: u32,
                pwszPath: ?[*:0]const u16,
                dwFlags: u32,
                ppidlOut: ?*?*ITEMIDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IBrowserService2.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService3__PositionViewWindow(self: *const T, hwnd: ?HWND, prc: ?*RECT) HRESULT {
                return @as(*const IBrowserService3.VTable, @ptrCast(self.vtable))._PositionViewWindow(@as(*const IBrowserService3, @ptrCast(self)), hwnd, prc);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService3_IEParseDisplayNameEx(self: *const T, uiCP: u32, pwszPath: ?[*:0]const u16, dwFlags: u32, ppidlOut: ?*?*ITEMIDLIST) HRESULT {
                return @as(*const IBrowserService3.VTable, @ptrCast(self.vtable)).IEParseDisplayNameEx(@as(*const IBrowserService3, @ptrCast(self)), uiCP, pwszPath, dwFlags, ppidlOut);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IBrowserService4_Value = Guid.initString("639f1bff-e135-4096-abd8-e0f504d649a4");
pub const IID_IBrowserService4 = &IID_IBrowserService4_Value;
pub const IBrowserService4 = extern struct {
    pub const VTable = extern struct {
        base: IBrowserService3.VTable,
        ActivateView: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService4,
                fPendingView: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBrowserService4,
                fPendingView: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SaveViewState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService4,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBrowserService4,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        _ResizeAllBorders: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBrowserService4,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBrowserService4,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IBrowserService3.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService4_ActivateView(self: *const T, fPendingView: BOOL) HRESULT {
                return @as(*const IBrowserService4.VTable, @ptrCast(self.vtable)).ActivateView(@as(*const IBrowserService4, @ptrCast(self)), fPendingView);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService4_SaveViewState(self: *const T) HRESULT {
                return @as(*const IBrowserService4.VTable, @ptrCast(self.vtable)).SaveViewState(@as(*const IBrowserService4, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBrowserService4__ResizeAllBorders(self: *const T) HRESULT {
                return @as(*const IBrowserService4.VTable, @ptrCast(self.vtable))._ResizeAllBorders(@as(*const IBrowserService4, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ITrackShellMenu_Value = Guid.initString("8278f932-2a3e-11d2-838f-00c04fd918d0");
pub const IID_ITrackShellMenu = &IID_ITrackShellMenu_Value;
pub const ITrackShellMenu = extern struct {
    pub const VTable = extern struct {
        base: IShellMenu.VTable,
        SetObscured: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITrackShellMenu,
                hwndTB: ?HWND,
                punkBand: ?*IUnknown,
                dwSMSetFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITrackShellMenu,
                hwndTB: ?HWND,
                punkBand: ?*IUnknown,
                dwSMSetFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Popup: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITrackShellMenu,
                hwnd: ?HWND,
                ppt: ?*POINTL,
                prcExclude: ?*RECTL,
                dwFlags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITrackShellMenu,
                hwnd: ?HWND,
                ppt: ?*POINTL,
                prcExclude: ?*RECTL,
                dwFlags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IShellMenu.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITrackShellMenu_SetObscured(self: *const T, hwndTB: ?HWND, punkBand: ?*IUnknown, dwSMSetFlags: u32) HRESULT {
                return @as(*const ITrackShellMenu.VTable, @ptrCast(self.vtable)).SetObscured(@as(*const ITrackShellMenu, @ptrCast(self)), hwndTB, punkBand, dwSMSetFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITrackShellMenu_Popup(self: *const T, hwnd: ?HWND, ppt: ?*POINTL, prcExclude: ?*RECTL, dwFlags: i32) HRESULT {
                return @as(*const ITrackShellMenu.VTable, @ptrCast(self.vtable)).Popup(@as(*const ITrackShellMenu, @ptrCast(self)), hwnd, ppt, prcExclude, dwFlags);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const CLSID_ImageTranscode_Value = Guid.initString("17b75166-928f-417d-9685-64aa135565c1");
pub const CLSID_ImageTranscode = &CLSID_ImageTranscode_Value;

pub const TI_FLAGS = enum(i32) {
    BITMAP = 1,
    JPEG = 2,
};
pub const TI_BITMAP = TI_FLAGS.BITMAP;
pub const TI_JPEG = TI_FLAGS.JPEG;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ITranscodeImage_Value = Guid.initString("bae86ddd-dc11-421c-b7ab-cc55d1d65c44");
pub const IID_ITranscodeImage = &IID_ITranscodeImage_Value;
pub const ITranscodeImage = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        TranscodeImage: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITranscodeImage,
                pShellItem: ?*IShellItem,
                uiMaxWidth: u32,
                uiMaxHeight: u32,
                flags: u32,
                pvImage: ?*IStream,
                puiWidth: ?*u32,
                puiHeight: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITranscodeImage,
                pShellItem: ?*IShellItem,
                uiMaxWidth: u32,
                uiMaxHeight: u32,
                flags: u32,
                pvImage: ?*IStream,
                puiWidth: ?*u32,
                puiHeight: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITranscodeImage_TranscodeImage(self: *const T, pShellItem: ?*IShellItem, uiMaxWidth: u32, uiMaxHeight: u32, flags: u32, pvImage: ?*IStream, puiWidth: ?*u32, puiHeight: ?*u32) HRESULT {
                return @as(*const ITranscodeImage.VTable, @ptrCast(self.vtable)).TranscodeImage(@as(*const ITranscodeImage, @ptrCast(self)), pShellItem, uiMaxWidth, uiMaxHeight, flags, pvImage, puiWidth, puiHeight);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const PATHCCH_OPTIONS = enum(i32) {
    NONE = 0,
    ALLOW_LONG_PATHS = 1,
    FORCE_ENABLE_LONG_NAME_PROCESS = 2,
    FORCE_DISABLE_LONG_NAME_PROCESS = 4,
    DO_NOT_NORMALIZE_SEGMENTS = 8,
    ENSURE_IS_EXTENDED_LENGTH_PATH = 16,
    ENSURE_TRAILING_SLASH = 32,
    CANONICALIZE_SLASHES = 64,
};
pub const PATHCCH_NONE = PATHCCH_OPTIONS.NONE;
pub const PATHCCH_ALLOW_LONG_PATHS = PATHCCH_OPTIONS.ALLOW_LONG_PATHS;
pub const PATHCCH_FORCE_ENABLE_LONG_NAME_PROCESS = PATHCCH_OPTIONS.FORCE_ENABLE_LONG_NAME_PROCESS;
pub const PATHCCH_FORCE_DISABLE_LONG_NAME_PROCESS = PATHCCH_OPTIONS.FORCE_DISABLE_LONG_NAME_PROCESS;
pub const PATHCCH_DO_NOT_NORMALIZE_SEGMENTS = PATHCCH_OPTIONS.DO_NOT_NORMALIZE_SEGMENTS;
pub const PATHCCH_ENSURE_IS_EXTENDED_LENGTH_PATH = PATHCCH_OPTIONS.ENSURE_IS_EXTENDED_LENGTH_PATH;
pub const PATHCCH_ENSURE_TRAILING_SLASH = PATHCCH_OPTIONS.ENSURE_TRAILING_SLASH;
pub const PATHCCH_CANONICALIZE_SLASHES = PATHCCH_OPTIONS.CANONICALIZE_SLASHES;

pub const APPLET_PROC = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        hwndCpl: ?HWND,
        msg: u32,
        lParam1: LPARAM,
        lParam2: LPARAM,
    ) callconv(@import("std").os.windows.WINAPI) i32,
    else => *const fn (
        hwndCpl: ?HWND,
        msg: u32,
        lParam1: LPARAM,
        lParam2: LPARAM,
    ) callconv(@import("std").os.windows.WINAPI) i32,
};

pub const CPLINFO = extern struct {
    idIcon: i32 align(1),
    idName: i32 align(1),
    idInfo: i32 align(1),
    lData: isize align(1),
};

pub const NEWCPLINFOA = extern struct {
    dwSize: u32 align(1),
    dwFlags: u32 align(1),
    dwHelpContext: u32 align(1),
    lData: isize align(1),
    hIcon: ?HICON align(1),
    szName: [32]CHAR align(1),
    szInfo: [64]CHAR align(1),
    szHelpFile: [128]CHAR align(1),
};

pub const NEWCPLINFOW = extern struct {
    dwSize: u32 align(1),
    dwFlags: u32 align(1),
    dwHelpContext: u32 align(1),
    lData: isize align(1),
    hIcon: ?HICON align(1),
    szName: [32]u16 align(1),
    szInfo: [64]u16 align(1),
    szHelpFile: [128]u16 align(1),
};

pub const PROFILEINFOA = extern struct {
    dwSize: u32,
    dwFlags: u32,
    lpUserName: ?PSTR,
    lpProfilePath: ?PSTR,
    lpDefaultPath: ?PSTR,
    lpServerName: ?PSTR,
    lpPolicyPath: ?PSTR,
    hProfile: ?HANDLE,
};

pub const PROFILEINFOW = extern struct {
    dwSize: u32,
    dwFlags: u32,
    lpUserName: ?PWSTR,
    lpProfilePath: ?PWSTR,
    lpDefaultPath: ?PWSTR,
    lpServerName: ?PWSTR,
    lpPolicyPath: ?PWSTR,
    hProfile: ?HANDLE,
};

pub const iurl_seturl_flags = enum(i32) {
    GUESS_PROTOCOL = 1,
    USE_DEFAULT_PROTOCOL = 2,
};
pub const IURL_SETURL_FL_GUESS_PROTOCOL = iurl_seturl_flags.GUESS_PROTOCOL;
pub const IURL_SETURL_FL_USE_DEFAULT_PROTOCOL = iurl_seturl_flags.USE_DEFAULT_PROTOCOL;

pub const iurl_invokecommand_flags = enum(i32) {
    ALLOW_UI = 1,
    USE_DEFAULT_VERB = 2,
    DDEWAIT = 4,
    ASYNCOK = 8,
    LOG_USAGE = 16,
};
pub const IURL_INVOKECOMMAND_FL_ALLOW_UI = iurl_invokecommand_flags.ALLOW_UI;
pub const IURL_INVOKECOMMAND_FL_USE_DEFAULT_VERB = iurl_invokecommand_flags.USE_DEFAULT_VERB;
pub const IURL_INVOKECOMMAND_FL_DDEWAIT = iurl_invokecommand_flags.DDEWAIT;
pub const IURL_INVOKECOMMAND_FL_ASYNCOK = iurl_invokecommand_flags.ASYNCOK;
pub const IURL_INVOKECOMMAND_FL_LOG_USAGE = iurl_invokecommand_flags.LOG_USAGE;

pub const urlinvokecommandinfoA = extern struct {
    dwcbSize: u32,
    dwFlags: u32,
    hwndParent: ?HWND,
    pcszVerb: ?[*:0]const u8,
};

pub const urlinvokecommandinfoW = extern struct {
    dwcbSize: u32,
    dwFlags: u32,
    hwndParent: ?HWND,
    pcszVerb: ?[*:0]const u16,
};

const IID_IUniformResourceLocatorA_Value = Guid.initString("fbf23b80-e3f0-101b-8488-00aa003e56f8");
pub const IID_IUniformResourceLocatorA = &IID_IUniformResourceLocatorA_Value;
pub const IUniformResourceLocatorA = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetURL: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUniformResourceLocatorA,
                pcszURL: ?[*:0]const u8,
                dwInFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUniformResourceLocatorA,
                pcszURL: ?[*:0]const u8,
                dwInFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetURL: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUniformResourceLocatorA,
                ppszURL: ?*?PSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUniformResourceLocatorA,
                ppszURL: ?*?PSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InvokeCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUniformResourceLocatorA,
                purlici: ?*urlinvokecommandinfoA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUniformResourceLocatorA,
                purlici: ?*urlinvokecommandinfoA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUniformResourceLocatorA_SetURL(self: *const T, pcszURL: ?[*:0]const u8, dwInFlags: u32) HRESULT {
                return @as(*const IUniformResourceLocatorA.VTable, @ptrCast(self.vtable)).SetURL(@as(*const IUniformResourceLocatorA, @ptrCast(self)), pcszURL, dwInFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUniformResourceLocatorA_GetURL(self: *const T, ppszURL: ?*?PSTR) HRESULT {
                return @as(*const IUniformResourceLocatorA.VTable, @ptrCast(self.vtable)).GetURL(@as(*const IUniformResourceLocatorA, @ptrCast(self)), ppszURL);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUniformResourceLocatorA_InvokeCommand(self: *const T, purlici: ?*urlinvokecommandinfoA) HRESULT {
                return @as(*const IUniformResourceLocatorA.VTable, @ptrCast(self.vtable)).InvokeCommand(@as(*const IUniformResourceLocatorA, @ptrCast(self)), purlici);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IUniformResourceLocatorW_Value = Guid.initString("cabb0da0-da57-11cf-9974-0020afd79762");
pub const IID_IUniformResourceLocatorW = &IID_IUniformResourceLocatorW_Value;
pub const IUniformResourceLocatorW = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetURL: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUniformResourceLocatorW,
                pcszURL: ?[*:0]const u16,
                dwInFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUniformResourceLocatorW,
                pcszURL: ?[*:0]const u16,
                dwInFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetURL: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUniformResourceLocatorW,
                ppszURL: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUniformResourceLocatorW,
                ppszURL: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InvokeCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUniformResourceLocatorW,
                purlici: ?*urlinvokecommandinfoW,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUniformResourceLocatorW,
                purlici: ?*urlinvokecommandinfoW,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUniformResourceLocatorW_SetURL(self: *const T, pcszURL: ?[*:0]const u16, dwInFlags: u32) HRESULT {
                return @as(*const IUniformResourceLocatorW.VTable, @ptrCast(self.vtable)).SetURL(@as(*const IUniformResourceLocatorW, @ptrCast(self)), pcszURL, dwInFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUniformResourceLocatorW_GetURL(self: *const T, ppszURL: ?*?PWSTR) HRESULT {
                return @as(*const IUniformResourceLocatorW.VTable, @ptrCast(self.vtable)).GetURL(@as(*const IUniformResourceLocatorW, @ptrCast(self)), ppszURL);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUniformResourceLocatorW_InvokeCommand(self: *const T, purlici: ?*urlinvokecommandinfoW) HRESULT {
                return @as(*const IUniformResourceLocatorW.VTable, @ptrCast(self.vtable)).InvokeCommand(@as(*const IUniformResourceLocatorW, @ptrCast(self)), purlici);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const translateurl_in_flags = enum(i32) {
    GUESS_PROTOCOL = 1,
    USE_DEFAULT_PROTOCOL = 2,
};
pub const TRANSLATEURL_FL_GUESS_PROTOCOL = translateurl_in_flags.GUESS_PROTOCOL;
pub const TRANSLATEURL_FL_USE_DEFAULT_PROTOCOL = translateurl_in_flags.USE_DEFAULT_PROTOCOL;

pub const urlassociationdialog_in_flags = enum(i32) {
    USE_DEFAULT_NAME = 1,
    REGISTER_ASSOC = 2,
};
pub const URLASSOCDLG_FL_USE_DEFAULT_NAME = urlassociationdialog_in_flags.USE_DEFAULT_NAME;
pub const URLASSOCDLG_FL_REGISTER_ASSOC = urlassociationdialog_in_flags.REGISTER_ASSOC;

pub const mimeassociationdialog_in_flags = enum(i32) {
    C = 1,
};
pub const MIMEASSOCDLG_FL_REGISTER_ASSOC = mimeassociationdialog_in_flags.C;

pub const PAPPSTATE_CHANGE_ROUTINE = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        Quiesced: BOOLEAN,
        Context: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn (
        Quiesced: BOOLEAN,
        Context: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) void,
};

pub const PAPPCONSTRAIN_CHANGE_ROUTINE = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        Constrained: BOOLEAN,
        Context: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn (
        Constrained: BOOLEAN,
        Context: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) void,
};

const CLSID_ShowInputPaneAnimationCoordinator_Value = Guid.initString("1f046abf-3202-4dc1-8cb5-3c67617ce1fa");
pub const CLSID_ShowInputPaneAnimationCoordinator = &CLSID_ShowInputPaneAnimationCoordinator_Value;

const CLSID_HideInputPaneAnimationCoordinator_Value = Guid.initString("384742b1-2a77-4cb3-8cf8-1136f5e17e59");
pub const CLSID_HideInputPaneAnimationCoordinator = &CLSID_HideInputPaneAnimationCoordinator_Value;

const IID_IInputPaneAnimationCoordinator_Value = Guid.initString("2af16ba9-2de5-4b75-82d9-01372afbffb4");
pub const IID_IInputPaneAnimationCoordinator = &IID_IInputPaneAnimationCoordinator_Value;
pub const IInputPaneAnimationCoordinator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddAnimation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInputPaneAnimationCoordinator,
                device: ?*IUnknown,
                animation: ?*IDCompositionAnimation,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInputPaneAnimationCoordinator,
                device: ?*IUnknown,
                animation: ?*IDCompositionAnimation,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInputPaneAnimationCoordinator_AddAnimation(self: *const T, device: ?*IUnknown, animation: ?*IDCompositionAnimation) HRESULT {
                return @as(*const IInputPaneAnimationCoordinator.VTable, @ptrCast(self.vtable)).AddAnimation(@as(*const IInputPaneAnimationCoordinator, @ptrCast(self)), device, animation);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DRAGINFOA = switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        uSize: u32,
        pt: POINT,
        fNC: BOOL,
        lpFileList: ?[*]u8,
        grfKeyState: u32,
    },
    .X86 => extern struct {
        uSize: u32 align(1),
        pt: POINT align(1),
        fNC: BOOL align(1),
        lpFileList: ?[*]u8 align(1),
        grfKeyState: u32 align(1),
    },
};
pub const DRAGINFOW = switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        uSize: u32,
        pt: POINT,
        fNC: BOOL,
        lpFileList: ?[*]u16,
        grfKeyState: u32,
    },
    .X86 => extern struct {
        uSize: u32 align(1),
        pt: POINT align(1),
        fNC: BOOL align(1),
        lpFileList: ?[*]u16 align(1),
        grfKeyState: u32 align(1),
    },
};
pub const APPBARDATA = switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        cbSize: u32,
        hWnd: ?HWND,
        uCallbackMessage: u32,
        uEdge: u32,
        rc: RECT,
        lParam: LPARAM,
    },
    .X86 => extern struct {
        cbSize: u32 align(1),
        hWnd: ?HWND align(1),
        uCallbackMessage: u32 align(1),
        uEdge: u32 align(1),
        rc: RECT align(1),
        lParam: LPARAM align(1),
    },
};
pub const SHFILEOPSTRUCTA = switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        hwnd: ?HWND,
        wFunc: u32,
        pFrom: ?*i8,
        pTo: ?*i8,
        fFlags: u16,
        fAnyOperationsAborted: BOOL,
        hNameMappings: ?*anyopaque,
        lpszProgressTitle: ?[*:0]const u8,
    },
    .X86 => extern struct {
        hwnd: ?HWND align(1),
        wFunc: u32 align(1),
        pFrom: ?*i8 align(1),
        pTo: ?*i8 align(1),
        fFlags: u16 align(1),
        fAnyOperationsAborted: BOOL align(1),
        hNameMappings: ?*anyopaque align(1),
        lpszProgressTitle: ?[*:0]const u8 align(1),
    },
};
pub const SHFILEOPSTRUCTW = switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        hwnd: ?HWND,
        wFunc: u32,
        pFrom: ?[*]const u16,
        pTo: ?[*]const u16,
        fFlags: u16,
        fAnyOperationsAborted: BOOL,
        hNameMappings: ?*anyopaque,
        lpszProgressTitle: ?[*:0]const u16,
    },
    .X86 => extern struct {
        hwnd: ?HWND align(1),
        wFunc: u32 align(1),
        pFrom: ?[*]const u16 align(1),
        pTo: ?[*]const u16 align(1),
        fFlags: u16 align(1),
        fAnyOperationsAborted: BOOL align(1),
        hNameMappings: ?*anyopaque align(1),
        lpszProgressTitle: ?[*:0]const u16 align(1),
    },
};
pub const SHNAMEMAPPINGA = switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        pszOldPath: ?PSTR,
        pszNewPath: ?PSTR,
        cchOldPath: i32,
        cchNewPath: i32,
    },
    .X86 => extern struct {
        pszOldPath: ?PSTR align(1),
        pszNewPath: ?PSTR align(1),
        cchOldPath: i32 align(1),
        cchNewPath: i32 align(1),
    },
};
pub const SHNAMEMAPPINGW = switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        pszOldPath: ?PWSTR,
        pszNewPath: ?PWSTR,
        cchOldPath: i32,
        cchNewPath: i32,
    },
    .X86 => extern struct {
        pszOldPath: ?PWSTR align(1),
        pszNewPath: ?PWSTR align(1),
        cchOldPath: i32 align(1),
        cchNewPath: i32 align(1),
    },
};
pub const SHELLEXECUTEINFOA = switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        cbSize: u32,
        fMask: u32,
        hwnd: ?HWND,
        lpVerb: ?[*:0]const u8,
        lpFile: ?[*:0]const u8,
        lpParameters: ?[*:0]const u8,
        lpDirectory: ?[*:0]const u8,
        nShow: i32,
        hInstApp: ?HINSTANCE,
        lpIDList: ?*anyopaque,
        lpClass: ?[*:0]const u8,
        hkeyClass: ?HKEY,
        dwHotKey: u32,
        Anonymous: extern union {
            hIcon: ?HANDLE,
            hMonitor: ?HANDLE,
        },
        hProcess: ?HANDLE,
    },
    .X86 => extern struct {
        cbSize: u32 align(1),
        fMask: u32 align(1),
        hwnd: ?HWND align(1),
        lpVerb: ?[*:0]const u8 align(1),
        lpFile: ?[*:0]const u8 align(1),
        lpParameters: ?[*:0]const u8 align(1),
        lpDirectory: ?[*:0]const u8 align(1),
        nShow: i32 align(1),
        hInstApp: ?HINSTANCE align(1),
        lpIDList: ?*anyopaque align(1),
        lpClass: ?[*:0]const u8 align(1),
        hkeyClass: ?HKEY align(1),
        dwHotKey: u32 align(1),
        Anonymous: extern union {
            hIcon: ?HANDLE align(1),
            hMonitor: ?HANDLE align(1),
        } align(1),
        hProcess: ?HANDLE align(1),
    },
};
pub const SHELLEXECUTEINFOW = switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        cbSize: u32,
        fMask: u32,
        hwnd: ?HWND,
        lpVerb: ?[*:0]const u16,
        lpFile: ?[*:0]const u16,
        lpParameters: ?[*:0]const u16,
        lpDirectory: ?[*:0]const u16,
        nShow: i32,
        hInstApp: ?HINSTANCE,
        lpIDList: ?*anyopaque,
        lpClass: ?[*:0]const u16,
        hkeyClass: ?HKEY,
        dwHotKey: u32,
        Anonymous: extern union {
            hIcon: ?HANDLE,
            hMonitor: ?HANDLE,
        },
        hProcess: ?HANDLE,
    },
    .X86 => extern struct {
        cbSize: u32 align(1),
        fMask: u32 align(1),
        hwnd: ?HWND align(1),
        lpVerb: ?[*:0]const u16 align(1),
        lpFile: ?[*:0]const u16 align(1),
        lpParameters: ?[*:0]const u16 align(1),
        lpDirectory: ?[*:0]const u16 align(1),
        nShow: i32 align(1),
        hInstApp: ?HINSTANCE align(1),
        lpIDList: ?*anyopaque align(1),
        lpClass: ?[*:0]const u16 align(1),
        hkeyClass: ?HKEY align(1),
        dwHotKey: u32 align(1),
        Anonymous: extern union {
            hIcon: ?HANDLE align(1),
            hMonitor: ?HANDLE align(1),
        } align(1),
        hProcess: ?HANDLE align(1),
    },
};
pub const SHCREATEPROCESSINFOW = switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        cbSize: u32,
        fMask: u32,
        hwnd: ?HWND,
        pszFile: ?[*:0]const u16,
        pszParameters: ?[*:0]const u16,
        pszCurrentDirectory: ?[*:0]const u16,
        hUserToken: ?HANDLE,
        lpProcessAttributes: ?*SECURITY_ATTRIBUTES,
        lpThreadAttributes: ?*SECURITY_ATTRIBUTES,
        bInheritHandles: BOOL,
        dwCreationFlags: u32,
        lpStartupInfo: ?*STARTUPINFOW,
        lpProcessInformation: ?*PROCESS_INFORMATION,
    },
    .X86 => extern struct {
        cbSize: u32 align(1),
        fMask: u32 align(1),
        hwnd: ?HWND align(1),
        pszFile: ?[*:0]const u16 align(1),
        pszParameters: ?[*:0]const u16 align(1),
        pszCurrentDirectory: ?[*:0]const u16 align(1),
        hUserToken: ?HANDLE align(1),
        lpProcessAttributes: ?*SECURITY_ATTRIBUTES align(1),
        lpThreadAttributes: ?*SECURITY_ATTRIBUTES align(1),
        bInheritHandles: BOOL align(1),
        dwCreationFlags: u32 align(1),
        lpStartupInfo: ?*STARTUPINFOW align(1),
        lpProcessInformation: ?*PROCESS_INFORMATION align(1),
    },
};
pub const ASSOCIATIONELEMENT = switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        ac: ASSOCCLASS,
        hkClass: ?HKEY,
        pszClass: ?[*:0]const u16,
    },
    .X86 => extern struct {
        ac: ASSOCCLASS align(1),
        hkClass: ?HKEY align(1),
        pszClass: ?[*:0]const u16 align(1),
    },
};
pub const SHQUERYRBINFO = switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        cbSize: u32,
        i64Size: i64,
        i64NumItems: i64,
    },
    .X86 => extern struct {
        cbSize: u32 align(1),
        i64Size: i64 align(1),
        i64NumItems: i64 align(1),
    },
};
pub const NOTIFYICONDATAA = switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        cbSize: u32,
        hWnd: ?HWND,
        uID: u32,
        uFlags: NOTIFY_ICON_DATA_FLAGS,
        uCallbackMessage: u32,
        hIcon: ?HICON,
        szTip: [128]CHAR,
        dwState: u32,
        dwStateMask: u32,
        szInfo: [256]CHAR,
        Anonymous: extern union {
            uTimeout: u32,
            uVersion: u32,
        },
        szInfoTitle: [64]CHAR,
        dwInfoFlags: u32,
        guidItem: Guid,
        hBalloonIcon: ?HICON,
    },
    .X86 => extern struct {
        cbSize: u32 align(1),
        hWnd: ?HWND align(1),
        uID: u32 align(1),
        uFlags: NOTIFY_ICON_DATA_FLAGS align(1),
        uCallbackMessage: u32 align(1),
        hIcon: ?HICON align(1),
        szTip: [128]CHAR align(1),
        dwState: u32 align(1),
        dwStateMask: u32 align(1),
        szInfo: [256]CHAR align(1),
        Anonymous: extern union {
            uTimeout: u32 align(1),
            uVersion: u32 align(1),
        } align(1),
        szInfoTitle: [64]CHAR align(1),
        dwInfoFlags: u32 align(1),
        guidItem: Guid align(1),
        hBalloonIcon: ?HICON align(1),
    },
};
pub const NOTIFYICONDATAW = switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        cbSize: u32,
        hWnd: ?HWND,
        uID: u32,
        uFlags: NOTIFY_ICON_DATA_FLAGS,
        uCallbackMessage: u32,
        hIcon: ?HICON,
        szTip: [128]u16,
        dwState: u32,
        dwStateMask: u32,
        szInfo: [256]u16,
        Anonymous: extern union {
            uTimeout: u32,
            uVersion: u32,
        },
        szInfoTitle: [64]u16,
        dwInfoFlags: u32,
        guidItem: Guid,
        hBalloonIcon: ?HICON,
    },
    .X86 => extern struct {
        cbSize: u32 align(1),
        hWnd: ?HWND align(1),
        uID: u32 align(1),
        uFlags: NOTIFY_ICON_DATA_FLAGS align(1),
        uCallbackMessage: u32 align(1),
        hIcon: ?HICON align(1),
        szTip: [128]u16 align(1),
        dwState: u32 align(1),
        dwStateMask: u32 align(1),
        szInfo: [256]u16 align(1),
        Anonymous: extern union {
            uTimeout: u32 align(1),
            uVersion: u32 align(1),
        } align(1),
        szInfoTitle: [64]u16 align(1),
        dwInfoFlags: u32 align(1),
        guidItem: Guid align(1),
        hBalloonIcon: ?HICON align(1),
    },
};
pub const NOTIFYICONIDENTIFIER = switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        cbSize: u32,
        hWnd: ?HWND,
        uID: u32,
        guidItem: Guid,
    },
    .X86 => extern struct {
        cbSize: u32 align(1),
        hWnd: ?HWND align(1),
        uID: u32 align(1),
        guidItem: Guid align(1),
    },
};
pub const SHFILEINFOA = switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        hIcon: ?HICON,
        iIcon: i32,
        dwAttributes: u32,
        szDisplayName: [260]CHAR,
        szTypeName: [80]CHAR,
    },
    .X86 => extern struct {
        hIcon: ?HICON align(1),
        iIcon: i32 align(1),
        dwAttributes: u32 align(1),
        szDisplayName: [260]CHAR align(1),
        szTypeName: [80]CHAR align(1),
    },
};
pub const SHFILEINFOW = switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        hIcon: ?HICON,
        iIcon: i32,
        dwAttributes: u32,
        szDisplayName: [260]u16,
        szTypeName: [80]u16,
    },
    .X86 => extern struct {
        hIcon: ?HICON align(1),
        iIcon: i32 align(1),
        dwAttributes: u32 align(1),
        szDisplayName: [260]u16 align(1),
        szTypeName: [80]u16 align(1),
    },
};
pub const SHSTOCKICONINFO = switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        cbSize: u32,
        hIcon: ?HICON,
        iSysImageIndex: i32,
        iIcon: i32,
        szPath: [260]u16,
    },
    .X86 => extern struct {
        cbSize: u32 align(1),
        hIcon: ?HICON align(1),
        iSysImageIndex: i32 align(1),
        iIcon: i32 align(1),
        szPath: [260]u16 align(1),
    },
};
pub const OPEN_PRINTER_PROPS_INFOA = switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        dwSize: u32,
        pszSheetName: ?PSTR,
        uSheetIndex: u32,
        dwFlags: u32,
        bModal: BOOL,
    },
    .X86 => extern struct {
        dwSize: u32 align(1),
        pszSheetName: ?PSTR align(1),
        uSheetIndex: u32 align(1),
        dwFlags: u32 align(1),
        bModal: BOOL align(1),
    },
};
pub const OPEN_PRINTER_PROPS_INFOW = switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        dwSize: u32,
        pszSheetName: ?PWSTR,
        uSheetIndex: u32,
        dwFlags: u32,
        bModal: BOOL,
    },
    .X86 => extern struct {
        dwSize: u32 align(1),
        pszSheetName: ?PWSTR align(1),
        uSheetIndex: u32 align(1),
        dwFlags: u32 align(1),
        bModal: BOOL align(1),
    },
};

//--------------------------------------------------------------------------------
// Section: Functions (688)
//--------------------------------------------------------------------------------
// TODO: this type is limited to platform 'windows5.0'
pub extern "userenv" fn LoadUserProfileA(
    hToken: ?HANDLE,
    lpProfileInfo: ?*PROFILEINFOA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "userenv" fn LoadUserProfileW(
    hToken: ?HANDLE,
    lpProfileInfo: ?*PROFILEINFOW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "userenv" fn UnloadUserProfile(
    hToken: ?HANDLE,
    hProfile: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "userenv" fn GetProfilesDirectoryA(
    lpProfileDir: ?[*:0]u8,
    lpcchSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "userenv" fn GetProfilesDirectoryW(
    lpProfileDir: ?[*:0]u16,
    lpcchSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "userenv" fn GetProfileType(
    dwFlags: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "userenv" fn DeleteProfileA(
    lpSidString: ?[*:0]const u8,
    lpProfilePath: ?[*:0]const u8,
    lpComputerName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "userenv" fn DeleteProfileW(
    lpSidString: ?[*:0]const u16,
    lpProfilePath: ?[*:0]const u16,
    lpComputerName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "userenv" fn CreateProfile(
    pszUserSid: ?[*:0]const u16,
    pszUserName: ?[*:0]const u16,
    pszProfilePath: [*:0]u16,
    cchProfilePath: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "userenv" fn GetDefaultUserProfileDirectoryA(
    lpProfileDir: ?[*:0]u8,
    lpcchSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "userenv" fn GetDefaultUserProfileDirectoryW(
    lpProfileDir: ?[*:0]u16,
    lpcchSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "userenv" fn GetAllUsersProfileDirectoryA(
    lpProfileDir: ?[*:0]u8,
    lpcchSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "userenv" fn GetAllUsersProfileDirectoryW(
    lpProfileDir: ?[*:0]u16,
    lpcchSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "userenv" fn GetUserProfileDirectoryA(
    hToken: ?HANDLE,
    lpProfileDir: ?[*:0]u8,
    lpcchSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "userenv" fn GetUserProfileDirectoryW(
    hToken: ?HANDLE,
    lpProfileDir: ?[*:0]u16,
    lpcchSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "comctl32" fn SetWindowSubclass(
    hWnd: ?HWND,
    pfnSubclass: ?SUBCLASSPROC,
    uIdSubclass: usize,
    dwRefData: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "comctl32" fn GetWindowSubclass(
    hWnd: ?HWND,
    pfnSubclass: ?SUBCLASSPROC,
    uIdSubclass: usize,
    pdwRefData: ?*usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "comctl32" fn RemoveWindowSubclass(
    hWnd: ?HWND,
    pfnSubclass: ?SUBCLASSPROC,
    uIdSubclass: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "comctl32" fn DefSubclassProc(
    hWnd: ?HWND,
    uMsg: u32,
    wParam: WPARAM,
    lParam: LPARAM,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "user32" fn SetWindowContextHelpId(
    param0: ?HWND,
    param1: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "user32" fn GetWindowContextHelpId(
    param0: ?HWND,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "user32" fn SetMenuContextHelpId(
    param0: ?HMENU,
    param1: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "user32" fn GetMenuContextHelpId(
    param0: ?HMENU,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "user32" fn WinHelpA(
    hWndMain: ?HWND,
    lpszHelp: ?[*:0]const u8,
    uCommand: u32,
    dwData: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "user32" fn WinHelpW(
    hWndMain: ?HWND,
    lpszHelp: ?[*:0]const u16,
    uCommand: u32,
    dwData: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shell32" fn SHSimpleIDListFromPath(
    pszPath: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) ?*ITEMIDLIST;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "shell32" fn SHCreateItemFromIDList(
    pidl: ?*ITEMIDLIST,
    riid: ?*const Guid,
    ppv: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "shell32" fn SHCreateItemFromParsingName(
    pszPath: ?[*:0]const u16,
    pbc: ?*IBindCtx,
    riid: ?*const Guid,
    ppv: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "shell32" fn SHCreateItemWithParent(
    pidlParent: ?*ITEMIDLIST,
    psfParent: ?*IShellFolder,
    pidl: ?*ITEMIDLIST,
    riid: ?*const Guid,
    ppvItem: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "shell32" fn SHCreateItemFromRelativeName(
    psiParent: ?*IShellItem,
    pszName: ?[*:0]const u16,
    pbc: ?*IBindCtx,
    riid: ?*const Guid,
    ppv: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "shell32" fn SHCreateItemInKnownFolder(
    kfid: ?*const Guid,
    dwKFFlags: u32,
    pszItem: ?[*:0]const u16,
    riid: ?*const Guid,
    ppv: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "shell32" fn SHGetIDListFromObject(
    punk: ?*IUnknown,
    ppidl: ?*?*ITEMIDLIST,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "shell32" fn SHGetItemFromObject(
    punk: ?*IUnknown,
    riid: ?*const Guid,
    ppv: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "shell32" fn SHGetNameFromIDList(
    pidl: ?*ITEMIDLIST,
    sigdnName: SIGDN,
    ppszName: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "shell32" fn SHGetItemFromDataObject(
    pdtobj: ?*IDataObject,
    dwFlags: DATAOBJ_GET_ITEM_FLAGS,
    riid: ?*const Guid,
    ppv: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "shell32" fn SHCreateShellItemArray(
    pidlParent: ?*ITEMIDLIST,
    psf: ?*IShellFolder,
    cidl: u32,
    ppidl: ?[*]?*ITEMIDLIST,
    ppsiItemArray: ?*?*IShellItemArray,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "shell32" fn SHCreateShellItemArrayFromDataObject(
    pdo: ?*IDataObject,
    riid: ?*const Guid,
    ppv: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "shell32" fn SHCreateShellItemArrayFromIDLists(
    cidl: u32,
    rgpidl: [*]?*ITEMIDLIST,
    ppsiItemArray: ?*?*IShellItemArray,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "shell32" fn SHCreateShellItemArrayFromShellItem(
    psi: ?*IShellItem,
    riid: ?*const Guid,
    ppv: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "shell32" fn SHCreateAssociationRegistration(
    riid: ?*const Guid,
    ppv: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "shell32" fn SHCreateDefaultExtractIcon(
    riid: ?*const Guid,
    ppv: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "shell32" fn SetCurrentProcessExplicitAppUserModelID(
    AppID: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "shell32" fn GetCurrentProcessExplicitAppUserModelID(
    AppID: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "shell32" fn SHGetTemporaryPropertyForItem(
    psi: ?*IShellItem,
    propkey: ?*const PROPERTYKEY,
    ppropvar: ?*PROPVARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "shell32" fn SHSetTemporaryPropertyForItem(
    psi: ?*IShellItem,
    propkey: ?*const PROPERTYKEY,
    propvar: ?*const PROPVARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "shell32" fn SHShowManageLibraryUI(
    psiLibrary: ?*IShellItem,
    hwndOwner: ?HWND,
    pszTitle: ?[*:0]const u16,
    pszInstruction: ?[*:0]const u16,
    lmdOptions: LIBRARYMANAGEDIALOGOPTIONS,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "shell32" fn SHResolveLibrary(
    psiLibrary: ?*IShellItem,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "shell32" fn SHAssocEnumHandlers(
    pszExtra: ?[*:0]const u16,
    afFilter: ASSOC_FILTER,
    ppEnumHandler: ?*?*IEnumAssocHandlers,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "shell32" fn SHAssocEnumHandlersForProtocolByApplication(
    protocol: ?[*:0]const u16,
    riid: ?*const Guid,
    enumHandlers: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ole32" fn HMONITOR_UserSize(
    param0: ?*u32,
    param1: u32,
    param2: ?*?HMONITOR,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "ole32" fn HMONITOR_UserMarshal(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*?HMONITOR,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

pub extern "ole32" fn HMONITOR_UserUnmarshal(
    param0: ?*u32,
    param1: [*:0]u8,
    param2: ?*?HMONITOR,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

pub extern "ole32" fn HMONITOR_UserFree(
    param0: ?*u32,
    param1: ?*?HMONITOR,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "ole32" fn HMONITOR_UserSize64(
    param0: ?*u32,
    param1: u32,
    param2: ?*?HMONITOR,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "ole32" fn HMONITOR_UserMarshal64(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*?HMONITOR,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

pub extern "ole32" fn HMONITOR_UserUnmarshal64(
    param0: ?*u32,
    param1: [*:0]u8,
    param2: ?*?HMONITOR,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

pub extern "ole32" fn HMONITOR_UserFree64(
    param0: ?*u32,
    param1: ?*?HMONITOR,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "shell32" fn SHCreateDefaultPropertiesOp(
    psi: ?*IShellItem,
    ppFileOp: ?*?*IFileOperation,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "shell32" fn SHSetDefaultProperties(
    hwnd: ?HWND,
    psi: ?*IShellItem,
    dwFileOpFlags: u32,
    pfops: ?*IFileOperationProgressSink,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn SHGetMalloc(
    ppMalloc: ?*?*IMalloc,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shell32" fn SHAlloc(
    cb: usize,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shell32" fn SHFree(
    pv: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shell32" fn SHGetIconOverlayIndexA(
    pszIconPath: ?[*:0]const u8,
    iIconIndex: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shell32" fn SHGetIconOverlayIndexW(
    pszIconPath: ?[*:0]const u16,
    iIconIndex: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn ILClone(
    pidl: ?*ITEMIDLIST,
) callconv(@import("std").os.windows.WINAPI) ?*ITEMIDLIST;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn ILCloneFirst(
    pidl: ?*ITEMIDLIST,
) callconv(@import("std").os.windows.WINAPI) ?*ITEMIDLIST;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn ILCombine(
    pidl1: ?*ITEMIDLIST,
    pidl2: ?*ITEMIDLIST,
) callconv(@import("std").os.windows.WINAPI) ?*ITEMIDLIST;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn ILFree(
    pidl: ?*ITEMIDLIST,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn ILGetNext(
    pidl: ?*ITEMIDLIST,
) callconv(@import("std").os.windows.WINAPI) ?*ITEMIDLIST;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn ILGetSize(
    pidl: ?*ITEMIDLIST,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn ILFindChild(
    pidlParent: ?*ITEMIDLIST,
    pidlChild: ?*ITEMIDLIST,
) callconv(@import("std").os.windows.WINAPI) ?*ITEMIDLIST;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn ILFindLastID(
    pidl: ?*ITEMIDLIST,
) callconv(@import("std").os.windows.WINAPI) ?*ITEMIDLIST;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn ILRemoveLastID(
    pidl: ?*ITEMIDLIST,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn ILIsEqual(
    pidl1: ?*ITEMIDLIST,
    pidl2: ?*ITEMIDLIST,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn ILIsParent(
    pidl1: ?*ITEMIDLIST,
    pidl2: ?*ITEMIDLIST,
    fImmediate: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn ILSaveToStream(
    pstm: ?*IStream,
    pidl: ?*ITEMIDLIST,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "shell32" fn ILLoadFromStreamEx(
    pstm: ?*IStream,
    pidl: ?*?*ITEMIDLIST,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn ILCreateFromPathA(
    pszPath: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) ?*ITEMIDLIST;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn ILCreateFromPathW(
    pszPath: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) ?*ITEMIDLIST;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn SHILCreateFromPath(
    pszPath: ?[*:0]const u16,
    ppidl: ?*?*ITEMIDLIST,
    rgfInOut: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn ILAppendID(
    pidl: ?*ITEMIDLIST,
    pmkid: ?*SHITEMID,
    fAppend: BOOL,
) callconv(@import("std").os.windows.WINAPI) ?*ITEMIDLIST;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "shell32" fn SHGetPathFromIDListEx(
    pidl: ?*ITEMIDLIST,
    pszPath: [*:0]u16,
    cchPath: u32,
    uOpts: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn SHGetPathFromIDListA(
    pidl: ?*ITEMIDLIST,
    pszPath: *[260]u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn SHGetPathFromIDListW(
    pidl: ?*ITEMIDLIST,
    pszPath: *[260]u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn SHCreateDirectory(
    hwnd: ?HWND,
    pszPath: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shell32" fn SHCreateDirectoryExA(
    hwnd: ?HWND,
    pszPath: ?[*:0]const u8,
    psa: ?*const SECURITY_ATTRIBUTES,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shell32" fn SHCreateDirectoryExW(
    hwnd: ?HWND,
    pszPath: ?[*:0]const u16,
    psa: ?*const SECURITY_ATTRIBUTES,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn SHOpenFolderAndSelectItems(
    pidlFolder: ?*ITEMIDLIST,
    cidl: u32,
    apidl: ?[*]?*ITEMIDLIST,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn SHCreateShellItem(
    pidlParent: ?*ITEMIDLIST,
    psfParent: ?*IShellFolder,
    pidl: ?*ITEMIDLIST,
    ppsi: ?*?*IShellItem,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shell32" fn SHGetSpecialFolderLocation(
    hwnd: ?HWND,
    csidl: i32,
    ppidl: ?*?*ITEMIDLIST,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn SHCloneSpecialIDList(
    hwnd: ?HWND,
    csidl: i32,
    fCreate: BOOL,
) callconv(@import("std").os.windows.WINAPI) ?*ITEMIDLIST;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shell32" fn SHGetSpecialFolderPathA(
    hwnd: ?HWND,
    pszPath: *[260]u8,
    csidl: i32,
    fCreate: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shell32" fn SHGetSpecialFolderPathW(
    hwnd: ?HWND,
    pszPath: *[260]u16,
    csidl: i32,
    fCreate: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn SHFlushSFCache() callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shell32" fn SHGetFolderPathA(
    hwnd: ?HWND,
    csidl: i32,
    hToken: ?HANDLE,
    dwFlags: u32,
    pszPath: *[260]u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shell32" fn SHGetFolderPathW(
    hwnd: ?HWND,
    csidl: i32,
    hToken: ?HANDLE,
    dwFlags: u32,
    pszPath: *[260]u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shell32" fn SHGetFolderLocation(
    hwnd: ?HWND,
    csidl: i32,
    hToken: ?HANDLE,
    dwFlags: u32,
    ppidl: ?*?*ITEMIDLIST,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn SHSetFolderPathA(
    csidl: i32,
    hToken: ?HANDLE,
    dwFlags: u32,
    pszPath: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn SHSetFolderPathW(
    csidl: i32,
    hToken: ?HANDLE,
    dwFlags: u32,
    pszPath: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn SHGetFolderPathAndSubDirA(
    hwnd: ?HWND,
    csidl: i32,
    hToken: ?HANDLE,
    dwFlags: u32,
    pszSubDir: ?[*:0]const u8,
    pszPath: *[260]u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn SHGetFolderPathAndSubDirW(
    hwnd: ?HWND,
    csidl: i32,
    hToken: ?HANDLE,
    dwFlags: u32,
    pszSubDir: ?[*:0]const u16,
    pszPath: *[260]u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "shell32" fn SHGetKnownFolderIDList(
    rfid: ?*const Guid,
    dwFlags: u32,
    hToken: ?HANDLE,
    ppidl: ?*?*ITEMIDLIST,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "shell32" fn SHSetKnownFolderPath(
    rfid: ?*const Guid,
    dwFlags: u32,
    hToken: ?HANDLE,
    pszPath: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "shell32" fn SHGetKnownFolderPath(
    rfid: ?*const Guid,
    dwFlags: u32,
    hToken: ?HANDLE,
    ppszPath: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "shell32" fn SHGetKnownFolderItem(
    rfid: ?*const Guid,
    flags: KNOWN_FOLDER_FLAG,
    hToken: ?HANDLE,
    riid: ?*const Guid,
    ppv: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn SHGetSetFolderCustomSettings(
    pfcs: ?*SHFOLDERCUSTOMSETTINGS,
    pszPath: ?[*:0]const u16,
    dwReadWrite: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn SHBrowseForFolderA(
    lpbi: ?*BROWSEINFOA,
) callconv(@import("std").os.windows.WINAPI) ?*ITEMIDLIST;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn SHBrowseForFolderW(
    lpbi: ?*BROWSEINFOW,
) callconv(@import("std").os.windows.WINAPI) ?*ITEMIDLIST;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn SHLoadInProc(
    rclsid: ?*const Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn SHGetDesktopFolder(
    ppshf: ?*?*IShellFolder,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn SHChangeNotify(
    wEventId: SHCNE_ID,
    uFlags: SHCNF_FLAGS,
    dwItem1: ?*const anyopaque,
    dwItem2: ?*const anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn SHAddToRecentDocs(
    uFlags: u32,
    pv: ?*const anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn SHHandleUpdateImage(
    pidlExtra: ?*ITEMIDLIST,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shell32" fn SHUpdateImageA(
    pszHashItem: ?[*:0]const u8,
    iIndex: i32,
    uFlags: u32,
    iImageIndex: i32,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shell32" fn SHUpdateImageW(
    pszHashItem: ?[*:0]const u16,
    iIndex: i32,
    uFlags: u32,
    iImageIndex: i32,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shell32" fn SHChangeNotifyRegister(
    hwnd: ?HWND,
    fSources: SHCNRF_SOURCE,
    fEvents: i32,
    wMsg: u32,
    cEntries: i32,
    pshcne: ?*const SHChangeNotifyEntry,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn SHChangeNotifyDeregister(
    ulID: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shell32" fn SHChangeNotification_Lock(
    hChange: ?HANDLE,
    dwProcId: u32,
    pppidl: ?*?*?*ITEMIDLIST,
    plEvent: ?*i32,
) callconv(@import("std").os.windows.WINAPI) ShFindChangeNotificationHandle;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shell32" fn SHChangeNotification_Unlock(
    hLock: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn SHGetRealIDL(
    psf: ?*IShellFolder,
    pidlSimple: ?*ITEMIDLIST,
    ppidlReal: ?*?*ITEMIDLIST,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn SHGetInstanceExplorer(
    ppunk: ?*?*IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn SHGetDataFromIDListA(
    psf: ?*IShellFolder,
    pidl: ?*ITEMIDLIST,
    nFormat: SHGDFIL_FORMAT,
    // TODO: what to do with BytesParamIndex 4?
    pv: ?*anyopaque,
    cb: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn SHGetDataFromIDListW(
    psf: ?*IShellFolder,
    pidl: ?*ITEMIDLIST,
    nFormat: SHGDFIL_FORMAT,
    // TODO: what to do with BytesParamIndex 4?
    pv: ?*anyopaque,
    cb: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shell32" fn RestartDialog(
    hwnd: ?HWND,
    pszPrompt: ?[*:0]const u16,
    dwReturn: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shell32" fn RestartDialogEx(
    hwnd: ?HWND,
    pszPrompt: ?[*:0]const u16,
    dwReturn: u32,
    dwReasonCode: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn SHCoCreateInstance(
    pszCLSID: ?[*:0]const u16,
    pclsid: ?*const Guid,
    pUnkOuter: ?*IUnknown,
    riid: ?*const Guid,
    ppv: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "shell32" fn SHCreateDataObject(
    pidlFolder: ?*ITEMIDLIST,
    cidl: u32,
    apidl: ?[*]?*ITEMIDLIST,
    pdtInner: ?*IDataObject,
    riid: ?*const Guid,
    ppv: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shell32" fn CIDLData_CreateFromIDArray(
    pidlFolder: ?*ITEMIDLIST,
    cidl: u32,
    apidl: ?[*]?*ITEMIDLIST,
    ppdtobj: ?*?*IDataObject,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn SHCreateStdEnumFmtEtc(
    cfmt: u32,
    afmt: [*]const FORMATETC,
    ppenumFormatEtc: ?*?*IEnumFORMATETC,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn SHDoDragDrop(
    hwnd: ?HWND,
    pdata: ?*IDataObject,
    pdsrc: ?*IDropSource,
    dwEffect: u32,
    pdwEffect: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shell32" fn DAD_SetDragImage(
    him: ?HIMAGELIST,
    pptOffset: ?*POINT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shell32" fn DAD_DragEnterEx(
    hwndTarget: ?HWND,
    ptStart: POINT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shell32" fn DAD_DragEnterEx2(
    hwndTarget: ?HWND,
    ptStart: POINT,
    pdtObject: ?*IDataObject,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shell32" fn DAD_ShowDragImage(
    fShow: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shell32" fn DAD_DragMove(
    pt: POINT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shell32" fn DAD_DragLeave() callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shell32" fn DAD_AutoScroll(
    hwnd: ?HWND,
    pad: ?*AUTO_SCROLL_DATA,
    pptNow: ?*const POINT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn ReadCabinetState(
    // TODO: what to do with BytesParamIndex 1?
    pcs: ?*CABINETSTATE,
    cLength: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn WriteCabinetState(
    pcs: ?*CABINETSTATE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shell32" fn PathMakeUniqueName(
    pszUniqueName: [*:0]u16,
    cchMax: u32,
    pszTemplate: ?[*:0]const u16,
    pszLongPlate: ?[*:0]const u16,
    pszDir: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn PathIsExe(
    pszPath: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn PathCleanupSpec(
    pszDir: ?[*:0]const u16,
    pszSpec: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) PCS_RET;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn PathResolve(
    pszPath: *[260]u16,
    dirs: ?*?*u16,
    fFlags: PRF_FLAGS,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shell32" fn GetFileNameFromBrowse(
    hwnd: ?HWND,
    pszFilePath: [*:0]u16,
    cchFilePath: u32,
    pszWorkingDir: ?[*:0]const u16,
    pszDefExt: ?[*:0]const u16,
    pszFilters: ?[*:0]const u16,
    pszTitle: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn DriveType(
    iDrive: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn RealDriveType(
    iDrive: i32,
    fOKToHitNet: BOOL,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shell32" fn IsNetDrive(
    iDrive: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn Shell_MergeMenus(
    hmDst: ?HMENU,
    hmSrc: ?HMENU,
    uInsert: u32,
    uIDAdjust: u32,
    uIDAdjustMax: u32,
    uFlags: MM_FLAGS,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn SHObjectProperties(
    hwnd: ?HWND,
    shopObjectType: SHOP_TYPE,
    pszObjectName: ?[*:0]const u16,
    pszPropertyPage: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn SHFormatDrive(
    hwnd: ?HWND,
    drive: u32,
    fmtID: SHFMT_ID,
    options: SHFMT_OPT,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn SHDestroyPropSheetExtArray(
    hpsxa: ?HPSXA,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shell32" fn SHAddFromPropSheetExtArray(
    hpsxa: ?HPSXA,
    lpfnAddPage: ?LPFNSVADDPROPSHEETPAGE,
    lParam: LPARAM,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn SHReplaceFromPropSheetExtArray(
    hpsxa: ?HPSXA,
    uPageID: u32,
    lpfnReplaceWith: ?LPFNSVADDPROPSHEETPAGE,
    lParam: LPARAM,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn OpenRegStream(
    hkey: ?HKEY,
    pszSubkey: ?[*:0]const u16,
    pszValue: ?[*:0]const u16,
    grfMode: u32,
) callconv(@import("std").os.windows.WINAPI) ?*IStream;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn SHFindFiles(
    pidlFolder: ?*ITEMIDLIST,
    pidlSaveFile: ?*ITEMIDLIST,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn PathGetShortPath(
    pszLongPath: *[260]u16,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shell32" fn PathYetAnotherMakeUniqueName(
    pszUniqueName: *[260]u16,
    pszPath: ?[*:0]const u16,
    pszShort: ?[*:0]const u16,
    pszFileSpec: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn Win32DeleteFile(
    pszPath: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn SHRestricted(
    rest: RESTRICTIONS,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn SignalFileOpen(
    pidl: ?*ITEMIDLIST,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "shell32" fn AssocGetDetailsOfPropKey(
    psf: ?*IShellFolder,
    pidl: ?*ITEMIDLIST,
    pkey: ?*const PROPERTYKEY,
    pv: ?*VARIANT,
    pfFoundPropKey: ?*BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn SHStartNetConnectionDialogW(
    hwnd: ?HWND,
    pszRemoteName: ?[*:0]const u16,
    dwType: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn SHDefExtractIconA(
    pszIconFile: ?[*:0]const u8,
    iIndex: i32,
    uFlags: u32,
    phiconLarge: ?*?HICON,
    phiconSmall: ?*?HICON,
    nIconSize: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn SHDefExtractIconW(
    pszIconFile: ?[*:0]const u16,
    iIndex: i32,
    uFlags: u32,
    phiconLarge: ?*?HICON,
    phiconSmall: ?*?HICON,
    nIconSize: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "shell32" fn SHOpenWithDialog(
    hwndParent: ?HWND,
    poainfo: ?*const OPENASINFO,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn Shell_GetImageLists(
    phiml: ?*?HIMAGELIST,
    phimlSmall: ?*?HIMAGELIST,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn Shell_GetCachedImageIndex(
    pwszIconPath: ?[*:0]const u16,
    iIconIndex: i32,
    uIconFlags: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn Shell_GetCachedImageIndexA(
    pszIconPath: ?[*:0]const u8,
    iIconIndex: i32,
    uIconFlags: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn Shell_GetCachedImageIndexW(
    pszIconPath: ?[*:0]const u16,
    iIconIndex: i32,
    uIconFlags: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn SHValidateUNC(
    hwndOwner: ?HWND,
    pszFile: ?PWSTR,
    fConnect: VALIDATEUNC_OPTION,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn SHSetInstanceExplorer(
    punk: ?*IUnknown,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn IsUserAnAdmin() callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn SHShellFolderView_Message(
    hwndMain: ?HWND,
    uMsg: u32,
    lParam: LPARAM,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shell32" fn SHCreateShellFolderView(
    pcsfv: ?*const SFV_CREATE,
    ppsv: ?*?*IShellView,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shell32" fn CDefFolderMenu_Create2(
    pidlFolder: ?*ITEMIDLIST,
    hwnd: ?HWND,
    cidl: u32,
    apidl: ?[*]?*ITEMIDLIST,
    psf: ?*IShellFolder,
    pfn: ?LPFNDFMCALLBACK,
    nKeys: u32,
    ahkeys: ?[*]const ?HKEY,
    ppcm: ?*?*IContextMenu,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "shell32" fn SHCreateDefaultContextMenu(
    pdcm: ?*const DEFCONTEXTMENU,
    riid: ?*const Guid,
    ppv: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn SHFind_InitMenuPopup(
    hmenu: ?HMENU,
    hwndOwner: ?HWND,
    idCmdFirst: u32,
    idCmdLast: u32,
) callconv(@import("std").os.windows.WINAPI) ?*IContextMenu;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shell32" fn SHCreateShellFolderViewEx(
    pcsfv: ?*CSFV,
    ppsv: ?*?*IShellView,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn SHGetSetSettings(
    lpss: ?*SHELLSTATEA,
    dwMask: SSF_MASK,
    bSet: BOOL,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shell32" fn SHGetSettings(
    psfs: ?*SHELLFLAGSTATE,
    dwMask: u32,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shell32" fn SHBindToParent(
    pidl: ?*ITEMIDLIST,
    riid: ?*const Guid,
    ppv: ?*?*anyopaque,
    ppidlLast: ?*?*ITEMIDLIST,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "shell32" fn SHBindToFolderIDListParent(
    psfRoot: ?*IShellFolder,
    pidl: ?*ITEMIDLIST,
    riid: ?*const Guid,
    ppv: ?*?*anyopaque,
    ppidlLast: ?*?*ITEMIDLIST,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "shell32" fn SHBindToFolderIDListParentEx(
    psfRoot: ?*IShellFolder,
    pidl: ?*ITEMIDLIST,
    ppbc: ?*IBindCtx,
    riid: ?*const Guid,
    ppv: ?*?*anyopaque,
    ppidlLast: ?*?*ITEMIDLIST,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "shell32" fn SHBindToObject(
    psf: ?*IShellFolder,
    pidl: ?*ITEMIDLIST,
    pbc: ?*IBindCtx,
    riid: ?*const Guid,
    ppv: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn SHParseDisplayName(
    pszName: ?[*:0]const u16,
    pbc: ?*IBindCtx,
    ppidl: ?*?*ITEMIDLIST,
    sfgaoIn: u32,
    psfgaoOut: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shell32" fn SHPathPrepareForWriteA(
    hwnd: ?HWND,
    punkEnableModless: ?*IUnknown,
    pszPath: ?[*:0]const u8,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shell32" fn SHPathPrepareForWriteW(
    hwnd: ?HWND,
    punkEnableModless: ?*IUnknown,
    pszPath: ?[*:0]const u16,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn SHCreateFileExtractIconW(
    pszFile: ?[*:0]const u16,
    dwFileAttributes: u32,
    riid: ?*const Guid,
    ppv: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shell32" fn SHLimitInputEdit(
    hwndEdit: ?HWND,
    psf: ?*IShellFolder,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn SHGetAttributesFromDataObject(
    pdo: ?*IDataObject,
    dwAttributeMask: u32,
    pdwAttributes: ?*u32,
    pcItems: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn SHMapPIDLToSystemImageListIndex(
    pshf: ?*IShellFolder,
    pidl: ?*ITEMIDLIST,
    piIndexSel: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shell32" fn SHCLSIDFromString(
    psz: ?[*:0]const u16,
    pclsid: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn PickIconDlg(
    hwnd: ?HWND,
    pszIconPath: [*:0]u16,
    cchIconPath: u32,
    piIconIndex: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "shell32" fn StgMakeUniqueName(
    pstgParent: ?*IStorage,
    pszFileSpec: ?[*:0]const u16,
    grfMode: u32,
    riid: ?*const Guid,
    ppv: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "shell32" fn SHChangeNotifyRegisterThread(
    status: SCNRT_STATUS,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "shell32" fn PathQualify(
    psz: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn PathIsSlowA(
    pszFile: ?[*:0]const u8,
    dwAttr: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn PathIsSlowW(
    pszFile: ?[*:0]const u16,
    dwAttr: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn SHCreatePropSheetExtArray(
    hKey: ?HKEY,
    pszSubKey: ?[*:0]const u16,
    max_iface: u32,
) callconv(@import("std").os.windows.WINAPI) ?HPSXA;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn SHOpenPropSheetW(
    pszCaption: ?[*:0]const u16,
    ahkeys: ?[*]?HKEY,
    ckeys: u32,
    pclsidDefault: ?*const Guid,
    pdtobj: ?*IDataObject,
    psb: ?*IShellBrowser,
    pStartPage: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shdocvw" fn SoftwareUpdateMessageBox(
    hWnd: ?HWND,
    pszDistUnit: ?[*:0]const u16,
    dwFlags: u32,
    psdi: ?*SOFTDISTINFO,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shell32" fn SHMultiFileProperties(
    pdtobj: ?*IDataObject,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn SHCreateQueryCancelAutoPlayMoniker(
    ppmoniker: ?*?*IMoniker,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "shdocvw" fn ImportPrivacySettings(
    pszFilename: ?[*:0]const u16,
    pfParsePrivacyPreferences: ?*BOOL,
    pfParsePerSiteRules: ?*BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-shcore-scaling-l1-1-0" fn GetScaleFactorForDevice(
    deviceType: DISPLAY_DEVICE_TYPE,
) callconv(@import("std").os.windows.WINAPI) DEVICE_SCALE_FACTOR;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-shcore-scaling-l1-1-0" fn RegisterScaleChangeNotifications(
    displayDevice: DISPLAY_DEVICE_TYPE,
    hwndNotify: ?HWND,
    uMsgNotify: u32,
    pdwCookie: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-shcore-scaling-l1-1-0" fn RevokeScaleChangeNotifications(
    displayDevice: DISPLAY_DEVICE_TYPE,
    dwCookie: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.1'
pub extern "api-ms-win-shcore-scaling-l1-1-1" fn GetScaleFactorForMonitor(
    hMon: ?HMONITOR,
    pScale: ?*DEVICE_SCALE_FACTOR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.1'
pub extern "api-ms-win-shcore-scaling-l1-1-1" fn RegisterScaleChangeEvent(
    hEvent: ?HANDLE,
    pdwCookie: ?*usize,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.1'
pub extern "api-ms-win-shcore-scaling-l1-1-1" fn UnregisterScaleChangeEvent(
    dwCookie: usize,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.1'
pub extern "api-ms-win-shcore-scaling-l1-1-2" fn GetDpiForShellUIComponent(
    param0: SHELL_UI_COMPONENT,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shell32" fn CommandLineToArgvW(
    lpCmdLine: ?[*:0]const u16,
    pNumArgs: ?*i32,
) callconv(@import("std").os.windows.WINAPI) ?*?PWSTR;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn DragQueryFileA(
    hDrop: ?HDROP,
    iFile: u32,
    lpszFile: ?[*:0]u8,
    cch: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn DragQueryFileW(
    hDrop: ?HDROP,
    iFile: u32,
    lpszFile: ?[*:0]u16,
    cch: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn DragQueryPoint(
    hDrop: ?HDROP,
    ppt: ?*POINT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn DragFinish(
    hDrop: ?HDROP,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn DragAcceptFiles(
    hWnd: ?HWND,
    fAccept: BOOL,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn ShellExecuteA(
    hwnd: ?HWND,
    lpOperation: ?[*:0]const u8,
    lpFile: ?[*:0]const u8,
    lpParameters: ?[*:0]const u8,
    lpDirectory: ?[*:0]const u8,
    nShowCmd: i32,
) callconv(@import("std").os.windows.WINAPI) ?HINSTANCE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn ShellExecuteW(
    hwnd: ?HWND,
    lpOperation: ?[*:0]const u16,
    lpFile: ?[*:0]const u16,
    lpParameters: ?[*:0]const u16,
    lpDirectory: ?[*:0]const u16,
    nShowCmd: i32,
) callconv(@import("std").os.windows.WINAPI) ?HINSTANCE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn FindExecutableA(
    lpFile: ?[*:0]const u8,
    lpDirectory: ?[*:0]const u8,
    lpResult: *[260]u8,
) callconv(@import("std").os.windows.WINAPI) ?HINSTANCE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn FindExecutableW(
    lpFile: ?[*:0]const u16,
    lpDirectory: ?[*:0]const u16,
    lpResult: *[260]u16,
) callconv(@import("std").os.windows.WINAPI) ?HINSTANCE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn ShellAboutA(
    hWnd: ?HWND,
    szApp: ?[*:0]const u8,
    szOtherStuff: ?[*:0]const u8,
    hIcon: ?HICON,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn ShellAboutW(
    hWnd: ?HWND,
    szApp: ?[*:0]const u16,
    szOtherStuff: ?[*:0]const u16,
    hIcon: ?HICON,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn DuplicateIcon(
    hInst: ?HINSTANCE,
    hIcon: ?HICON,
) callconv(@import("std").os.windows.WINAPI) ?HICON;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn ExtractAssociatedIconA(
    hInst: ?HINSTANCE,
    pszIconPath: *[128]u8,
    piIcon: ?*u16,
) callconv(@import("std").os.windows.WINAPI) ?HICON;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn ExtractAssociatedIconW(
    hInst: ?HINSTANCE,
    pszIconPath: *[128]u16,
    piIcon: ?*u16,
) callconv(@import("std").os.windows.WINAPI) ?HICON;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn ExtractAssociatedIconExA(
    hInst: ?HINSTANCE,
    pszIconPath: *[128]u8,
    piIconIndex: ?*u16,
    piIconId: ?*u16,
) callconv(@import("std").os.windows.WINAPI) ?HICON;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn ExtractAssociatedIconExW(
    hInst: ?HINSTANCE,
    pszIconPath: *[128]u16,
    piIconIndex: ?*u16,
    piIconId: ?*u16,
) callconv(@import("std").os.windows.WINAPI) ?HICON;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn ExtractIconA(
    hInst: ?HINSTANCE,
    pszExeFileName: ?[*:0]const u8,
    nIconIndex: u32,
) callconv(@import("std").os.windows.WINAPI) ?HICON;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn ExtractIconW(
    hInst: ?HINSTANCE,
    pszExeFileName: ?[*:0]const u16,
    nIconIndex: u32,
) callconv(@import("std").os.windows.WINAPI) ?HICON;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn SHAppBarMessage(
    dwMessage: u32,
    pData: ?*APPBARDATA,
) callconv(@import("std").os.windows.WINAPI) usize;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn DoEnvironmentSubstA(
    pszSrc: [*:0]u8,
    cchSrc: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn DoEnvironmentSubstW(
    pszSrc: [*:0]u16,
    cchSrc: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn ExtractIconExA(
    lpszFile: ?[*:0]const u8,
    nIconIndex: i32,
    phiconLarge: ?[*]?HICON,
    phiconSmall: ?[*]?HICON,
    nIcons: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn ExtractIconExW(
    lpszFile: ?[*:0]const u16,
    nIconIndex: i32,
    phiconLarge: ?[*]?HICON,
    phiconSmall: ?[*]?HICON,
    nIcons: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn SHFileOperationA(
    lpFileOp: ?*SHFILEOPSTRUCTA,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn SHFileOperationW(
    lpFileOp: ?*SHFILEOPSTRUCTW,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn SHFreeNameMappings(
    hNameMappings: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn ShellExecuteExA(
    pExecInfo: ?*SHELLEXECUTEINFOA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn ShellExecuteExW(
    pExecInfo: ?*SHELLEXECUTEINFOW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shell32" fn SHCreateProcessAsUserW(
    pscpi: ?*SHCREATEPROCESSINFOW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "shell32" fn SHEvaluateSystemCommandTemplate(
    pszCmdTemplate: ?[*:0]const u16,
    ppszApplication: ?*?PWSTR,
    ppszCommandLine: ?*?PWSTR,
    ppszParameters: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "shell32" fn AssocCreateForClasses(
    rgClasses: [*]const ASSOCIATIONELEMENT,
    cClasses: u32,
    riid: ?*const Guid,
    ppv: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shell32" fn SHQueryRecycleBinA(
    pszRootPath: ?[*:0]const u8,
    pSHQueryRBInfo: ?*SHQUERYRBINFO,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shell32" fn SHQueryRecycleBinW(
    pszRootPath: ?[*:0]const u16,
    pSHQueryRBInfo: ?*SHQUERYRBINFO,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shell32" fn SHEmptyRecycleBinA(
    hwnd: ?HWND,
    pszRootPath: ?[*:0]const u8,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shell32" fn SHEmptyRecycleBinW(
    hwnd: ?HWND,
    pszRootPath: ?[*:0]const u16,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "shell32" fn SHQueryUserNotificationState(
    pquns: ?*QUERY_USER_NOTIFICATION_STATE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn Shell_NotifyIconA(
    dwMessage: NOTIFY_ICON_MESSAGE,
    lpData: ?*NOTIFYICONDATAA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn Shell_NotifyIconW(
    dwMessage: NOTIFY_ICON_MESSAGE,
    lpData: ?*NOTIFYICONDATAW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "shell32" fn Shell_NotifyIconGetRect(
    identifier: ?*const NOTIFYICONIDENTIFIER,
    iconLocation: ?*RECT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn SHGetFileInfoA(
    pszPath: ?[*:0]const u8,
    dwFileAttributes: FILE_FLAGS_AND_ATTRIBUTES,
    // TODO: what to do with BytesParamIndex 3?
    psfi: ?*SHFILEINFOA,
    cbFileInfo: u32,
    uFlags: SHGFI_FLAGS,
) callconv(@import("std").os.windows.WINAPI) usize;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn SHGetFileInfoW(
    pszPath: ?[*:0]const u16,
    dwFileAttributes: FILE_FLAGS_AND_ATTRIBUTES,
    // TODO: what to do with BytesParamIndex 3?
    psfi: ?*SHFILEINFOW,
    cbFileInfo: u32,
    uFlags: SHGFI_FLAGS,
) callconv(@import("std").os.windows.WINAPI) usize;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "shell32" fn SHGetStockIconInfo(
    siid: SHSTOCKICONID,
    uFlags: u32,
    psii: ?*SHSTOCKICONINFO,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shell32" fn SHGetDiskFreeSpaceExA(
    pszDirectoryName: ?[*:0]const u8,
    pulFreeBytesAvailableToCaller: ?*ULARGE_INTEGER,
    pulTotalNumberOfBytes: ?*ULARGE_INTEGER,
    pulTotalNumberOfFreeBytes: ?*ULARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shell32" fn SHGetDiskFreeSpaceExW(
    pszDirectoryName: ?[*:0]const u16,
    pulFreeBytesAvailableToCaller: ?*ULARGE_INTEGER,
    pulTotalNumberOfBytes: ?*ULARGE_INTEGER,
    pulTotalNumberOfFreeBytes: ?*ULARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shell32" fn SHGetNewLinkInfoA(
    pszLinkTo: ?[*:0]const u8,
    pszDir: ?[*:0]const u8,
    pszName: *[260]u8,
    pfMustCopy: ?*BOOL,
    uFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shell32" fn SHGetNewLinkInfoW(
    pszLinkTo: ?[*:0]const u16,
    pszDir: ?[*:0]const u16,
    pszName: *[260]u16,
    pfMustCopy: ?*BOOL,
    uFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shell32" fn SHInvokePrinterCommandA(
    hwnd: ?HWND,
    uAction: u32,
    lpBuf1: ?[*:0]const u8,
    lpBuf2: ?[*:0]const u8,
    fModal: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shell32" fn SHInvokePrinterCommandW(
    hwnd: ?HWND,
    uAction: u32,
    lpBuf1: ?[*:0]const u16,
    lpBuf2: ?[*:0]const u16,
    fModal: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shell32" fn SHLoadNonloadedIconOverlayIdentifiers() callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shell32" fn SHIsFileAvailableOffline(
    pwszPath: ?[*:0]const u16,
    pdwStatus: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn SHSetLocalizedName(
    pszPath: ?[*:0]const u16,
    pszResModule: ?[*:0]const u16,
    idsRes: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "shell32" fn SHRemoveLocalizedName(
    pszPath: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "shell32" fn SHGetLocalizedName(
    pszPath: ?[*:0]const u16,
    pszResModule: [*:0]u16,
    cch: u32,
    pidsRes: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shlwapi" fn ShellMessageBoxA(
    hAppInst: ?HINSTANCE,
    hWnd: ?HWND,
    lpcText: ?[*:0]const u8,
    lpcTitle: ?[*:0]const u8,
    fuStyle: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shlwapi" fn ShellMessageBoxW(
    hAppInst: ?HINSTANCE,
    hWnd: ?HWND,
    lpcText: ?[*:0]const u16,
    lpcTitle: ?[*:0]const u16,
    fuStyle: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "shell32" fn IsLFNDriveA(
    pszPath: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "shell32" fn IsLFNDriveW(
    pszPath: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn SHEnumerateUnreadMailAccountsW(
    hKeyUser: ?HKEY,
    dwIndex: u32,
    pszMailAddress: [*:0]u16,
    cchMailAddress: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn SHGetUnreadMailCountW(
    hKeyUser: ?HKEY,
    pszMailAddress: ?[*:0]const u16,
    pdwCount: ?*u32,
    pFileTime: ?*FILETIME,
    pszShellExecuteCommand: ?[*:0]u16,
    cchShellExecuteCommand: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn SHSetUnreadMailCountW(
    pszMailAddress: ?[*:0]const u16,
    dwCount: u32,
    pszShellExecuteCommand: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn SHTestTokenMembership(
    hToken: ?HANDLE,
    ulRID: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shell32" fn SHGetImageList(
    iImageList: i32,
    riid: ?*const Guid,
    ppvObj: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "shell32" fn InitNetworkAddressControl() callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "shell32" fn SHGetDriveMedia(
    pszDrive: ?[*:0]const u16,
    pdwMediaContent: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn StrChrA(
    pszStart: ?[*:0]const u8,
    wMatch: u16,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn StrChrW(
    pszStart: ?[*:0]const u16,
    wMatch: u16,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn StrChrIA(
    pszStart: ?[*:0]const u8,
    wMatch: u16,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn StrChrIW(
    pszStart: ?[*:0]const u16,
    wMatch: u16,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shlwapi" fn StrChrNW(
    pszStart: ?[*:0]const u16,
    wMatch: u16,
    cchMax: u32,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "shlwapi" fn StrChrNIW(
    pszStart: ?[*:0]const u16,
    wMatch: u16,
    cchMax: u32,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn StrCmpNA(
    psz1: ?[*:0]const u8,
    psz2: ?[*:0]const u8,
    nChar: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn StrCmpNW(
    psz1: ?[*:0]const u16,
    psz2: ?[*:0]const u16,
    nChar: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn StrCmpNIA(
    psz1: ?[*:0]const u8,
    psz2: ?[*:0]const u8,
    nChar: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn StrCmpNIW(
    psz1: ?[*:0]const u16,
    psz2: ?[*:0]const u16,
    nChar: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn StrCSpnA(
    pszStr: ?[*:0]const u8,
    pszSet: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn StrCSpnW(
    pszStr: ?[*:0]const u16,
    pszSet: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn StrCSpnIA(
    pszStr: ?[*:0]const u8,
    pszSet: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn StrCSpnIW(
    pszStr: ?[*:0]const u16,
    pszSet: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn StrDupA(
    pszSrch: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn StrDupW(
    pszSrch: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "shlwapi" fn StrFormatByteSizeEx(
    ull: u64,
    flags: SFBS_FLAGS,
    pszBuf: [*:0]u16,
    cchBuf: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn StrFormatByteSizeA(
    dw: u32,
    pszBuf: [*:0]u8,
    cchBuf: u32,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn StrFormatByteSize64A(
    qdw: i64,
    pszBuf: [*:0]u8,
    cchBuf: u32,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn StrFormatByteSizeW(
    qdw: i64,
    pszBuf: [*:0]u16,
    cchBuf: u32,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn StrFormatKBSizeW(
    qdw: i64,
    pszBuf: [*:0]u16,
    cchBuf: u32,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn StrFormatKBSizeA(
    qdw: i64,
    pszBuf: [*:0]u8,
    cchBuf: u32,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn StrFromTimeIntervalA(
    pszOut: [*:0]u8,
    cchMax: u32,
    dwTimeMS: u32,
    digits: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn StrFromTimeIntervalW(
    pszOut: [*:0]u16,
    cchMax: u32,
    dwTimeMS: u32,
    digits: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn StrIsIntlEqualA(
    fCaseSens: BOOL,
    pszString1: ?[*:0]const u8,
    pszString2: ?[*:0]const u8,
    nChar: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn StrIsIntlEqualW(
    fCaseSens: BOOL,
    pszString1: ?[*:0]const u16,
    pszString2: ?[*:0]const u16,
    nChar: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn StrNCatA(
    psz1: [*:0]u8,
    psz2: ?[*:0]const u8,
    cchMax: i32,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn StrNCatW(
    psz1: [*:0]u16,
    psz2: ?[*:0]const u16,
    cchMax: i32,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn StrPBrkA(
    psz: ?[*:0]const u8,
    pszSet: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn StrPBrkW(
    psz: ?[*:0]const u16,
    pszSet: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn StrRChrA(
    pszStart: ?[*:0]const u8,
    pszEnd: ?[*:0]const u8,
    wMatch: u16,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn StrRChrW(
    pszStart: ?[*:0]const u16,
    pszEnd: ?[*:0]const u16,
    wMatch: u16,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn StrRChrIA(
    pszStart: ?[*:0]const u8,
    pszEnd: ?[*:0]const u8,
    wMatch: u16,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn StrRChrIW(
    pszStart: ?[*:0]const u16,
    pszEnd: ?[*:0]const u16,
    wMatch: u16,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn StrRStrIA(
    pszSource: ?[*:0]const u8,
    pszLast: ?[*:0]const u8,
    pszSrch: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn StrRStrIW(
    pszSource: ?[*:0]const u16,
    pszLast: ?[*:0]const u16,
    pszSrch: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn StrSpnA(
    psz: ?[*:0]const u8,
    pszSet: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn StrSpnW(
    psz: ?[*:0]const u16,
    pszSet: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn StrStrA(
    pszFirst: ?[*:0]const u8,
    pszSrch: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn StrStrW(
    pszFirst: ?[*:0]const u16,
    pszSrch: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn StrStrIA(
    pszFirst: ?[*:0]const u8,
    pszSrch: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn StrStrIW(
    pszFirst: ?[*:0]const u16,
    pszSrch: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "shlwapi" fn StrStrNW(
    pszFirst: ?[*:0]const u16,
    pszSrch: ?[*:0]const u16,
    cchMax: u32,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "shlwapi" fn StrStrNIW(
    pszFirst: ?[*:0]const u16,
    pszSrch: ?[*:0]const u16,
    cchMax: u32,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn StrToIntA(
    pszSrc: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn StrToIntW(
    pszSrc: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn StrToIntExA(
    pszString: ?[*:0]const u8,
    dwFlags: i32,
    piRet: ?*i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn StrToIntExW(
    pszString: ?[*:0]const u16,
    dwFlags: i32,
    piRet: ?*i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn StrToInt64ExA(
    pszString: ?[*:0]const u8,
    dwFlags: i32,
    pllRet: ?*i64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn StrToInt64ExW(
    pszString: ?[*:0]const u16,
    dwFlags: i32,
    pllRet: ?*i64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn StrTrimA(
    psz: ?PSTR,
    pszTrimChars: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn StrTrimW(
    psz: ?PWSTR,
    pszTrimChars: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn StrCatW(
    psz1: ?PWSTR,
    psz2: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn StrCmpW(
    psz1: ?[*:0]const u16,
    psz2: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn StrCmpIW(
    psz1: ?[*:0]const u16,
    psz2: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn StrCpyW(
    psz1: ?PWSTR,
    psz2: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn StrCpyNW(
    pszDst: [*:0]u16,
    pszSrc: ?[*:0]const u16,
    cchMax: i32,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn StrCatBuffW(
    pszDest: [*:0]u16,
    pszSrc: ?[*:0]const u16,
    cchDestBuffSize: i32,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn StrCatBuffA(
    pszDest: [*:0]u8,
    pszSrc: ?[*:0]const u8,
    cchDestBuffSize: i32,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn ChrCmpIA(
    w1: u16,
    w2: u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn ChrCmpIW(
    w1: u16,
    w2: u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn wvnsprintfA(
    pszDest: [*:0]u8,
    cchDest: i32,
    pszFmt: ?[*:0]const u8,
    arglist: ?*i8,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn wvnsprintfW(
    pszDest: [*:0]u16,
    cchDest: i32,
    pszFmt: ?[*:0]const u16,
    arglist: ?*i8,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn wnsprintfA(
    pszDest: [*:0]u8,
    cchDest: i32,
    pszFmt: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn wnsprintfW(
    pszDest: [*:0]u16,
    cchDest: i32,
    pszFmt: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn StrRetToStrA(
    pstr: ?*STRRET,
    pidl: ?*ITEMIDLIST,
    ppsz: ?*?PSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn StrRetToStrW(
    pstr: ?*STRRET,
    pidl: ?*ITEMIDLIST,
    ppsz: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn StrRetToBufA(
    pstr: ?*STRRET,
    pidl: ?*ITEMIDLIST,
    pszBuf: [*:0]u8,
    cchBuf: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn StrRetToBufW(
    pstr: ?*STRRET,
    pidl: ?*ITEMIDLIST,
    pszBuf: [*:0]u16,
    cchBuf: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn SHStrDupA(
    psz: ?[*:0]const u8,
    ppwsz: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn SHStrDupW(
    psz: ?[*:0]const u16,
    ppwsz: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shlwapi" fn StrCmpLogicalW(
    psz1: ?[*:0]const u16,
    psz2: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shlwapi" fn StrCatChainW(
    pszDst: [*:0]u16,
    cchDst: u32,
    ichAt: u32,
    pszSrc: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shlwapi" fn StrRetToBSTR(
    pstr: ?*STRRET,
    pidl: ?*ITEMIDLIST,
    pbstr: ?*?BSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shlwapi" fn SHLoadIndirectString(
    pszSource: ?[*:0]const u16,
    pszOutBuf: [*:0]u16,
    cchOutBuf: u32,
    ppvReserved: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn IsCharSpaceA(
    wch: CHAR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn IsCharSpaceW(
    wch: u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn StrCmpCA(
    pszStr1: ?[*:0]const u8,
    pszStr2: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn StrCmpCW(
    pszStr1: ?[*:0]const u16,
    pszStr2: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn StrCmpICA(
    pszStr1: ?[*:0]const u8,
    pszStr2: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn StrCmpICW(
    pszStr1: ?[*:0]const u16,
    pszStr2: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn StrCmpNCA(
    pszStr1: ?[*:0]const u8,
    pszStr2: ?[*:0]const u8,
    nChar: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn StrCmpNCW(
    pszStr1: ?[*:0]const u16,
    pszStr2: ?[*:0]const u16,
    nChar: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn StrCmpNICA(
    pszStr1: ?[*:0]const u8,
    pszStr2: ?[*:0]const u8,
    nChar: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn StrCmpNICW(
    pszStr1: ?[*:0]const u16,
    pszStr2: ?[*:0]const u16,
    nChar: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn IntlStrEqWorkerA(
    fCaseSens: BOOL,
    lpString1: [*:0]const u8,
    lpString2: [*:0]const u8,
    nChar: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn IntlStrEqWorkerW(
    fCaseSens: BOOL,
    lpString1: [*:0]const u16,
    lpString2: [*:0]const u16,
    nChar: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathAddBackslashA(
    pszPath: *[260]u8,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathAddBackslashW(
    pszPath: *[260]u16,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathAddExtensionA(
    pszPath: *[260]u8,
    pszExt: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathAddExtensionW(
    pszPath: *[260]u16,
    pszExt: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathAppendA(
    pszPath: *[260]u8,
    pszMore: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathAppendW(
    pszPath: *[260]u16,
    pszMore: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathBuildRootA(
    pszRoot: *[4]u8,
    iDrive: i32,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathBuildRootW(
    pszRoot: *[4]u16,
    iDrive: i32,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathCanonicalizeA(
    pszBuf: *[260]u8,
    pszPath: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathCanonicalizeW(
    pszBuf: *[260]u16,
    pszPath: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathCombineA(
    pszDest: *[260]u8,
    pszDir: ?[*:0]const u8,
    pszFile: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathCombineW(
    pszDest: *[260]u16,
    pszDir: ?[*:0]const u16,
    pszFile: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathCompactPathA(
    hDC: ?HDC,
    pszPath: *[260]u8,
    dx: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathCompactPathW(
    hDC: ?HDC,
    pszPath: *[260]u16,
    dx: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathCompactPathExA(
    pszOut: [*:0]u8,
    pszSrc: ?[*:0]const u8,
    cchMax: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathCompactPathExW(
    pszOut: [*:0]u16,
    pszSrc: ?[*:0]const u16,
    cchMax: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathCommonPrefixA(
    pszFile1: ?[*:0]const u8,
    pszFile2: ?[*:0]const u8,
    achPath: ?*[260]u8,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathCommonPrefixW(
    pszFile1: ?[*:0]const u16,
    pszFile2: ?[*:0]const u16,
    achPath: ?*[260]u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathFileExistsA(
    pszPath: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathFileExistsW(
    pszPath: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathFindExtensionA(
    pszPath: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathFindExtensionW(
    pszPath: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathFindFileNameA(
    pszPath: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathFindFileNameW(
    pszPath: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathFindNextComponentA(
    pszPath: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathFindNextComponentW(
    pszPath: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathFindOnPathA(
    pszPath: *[260]u8,
    ppszOtherDirs: ?*?*i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathFindOnPathW(
    pszPath: *[260]u16,
    ppszOtherDirs: ?*?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathFindSuffixArrayA(
    pszPath: ?[*:0]const u8,
    apszSuffix: [*]const ?[*:0]const u8,
    iArraySize: i32,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathFindSuffixArrayW(
    pszPath: ?[*:0]const u16,
    apszSuffix: [*]const ?[*:0]const u16,
    iArraySize: i32,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathGetArgsA(
    pszPath: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathGetArgsW(
    pszPath: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathIsLFNFileSpecA(
    pszName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathIsLFNFileSpecW(
    pszName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathGetCharTypeA(
    ch: u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathGetCharTypeW(
    ch: u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathGetDriveNumberA(
    pszPath: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathGetDriveNumberW(
    pszPath: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathIsDirectoryA(
    pszPath: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathIsDirectoryW(
    pszPath: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathIsDirectoryEmptyA(
    pszPath: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathIsDirectoryEmptyW(
    pszPath: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathIsFileSpecA(
    pszPath: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathIsFileSpecW(
    pszPath: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathIsPrefixA(
    pszPrefix: ?[*:0]const u8,
    pszPath: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathIsPrefixW(
    pszPrefix: ?[*:0]const u16,
    pszPath: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathIsRelativeA(
    pszPath: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathIsRelativeW(
    pszPath: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathIsRootA(
    pszPath: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathIsRootW(
    pszPath: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathIsSameRootA(
    pszPath1: ?[*:0]const u8,
    pszPath2: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathIsSameRootW(
    pszPath1: ?[*:0]const u16,
    pszPath2: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathIsUNCA(
    pszPath: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathIsUNCW(
    pszPath: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathIsNetworkPathA(
    pszPath: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathIsNetworkPathW(
    pszPath: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathIsUNCServerA(
    pszPath: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathIsUNCServerW(
    pszPath: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathIsUNCServerShareA(
    pszPath: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathIsUNCServerShareW(
    pszPath: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathIsContentTypeA(
    pszPath: ?[*:0]const u8,
    pszContentType: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathIsContentTypeW(
    pszPath: ?[*:0]const u16,
    pszContentType: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathIsURLA(
    pszPath: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathIsURLW(
    pszPath: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathMakePrettyA(
    pszPath: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathMakePrettyW(
    pszPath: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathMatchSpecA(
    pszFile: ?[*:0]const u8,
    pszSpec: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathMatchSpecW(
    pszFile: ?[*:0]const u16,
    pszSpec: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "shlwapi" fn PathMatchSpecExA(
    pszFile: ?[*:0]const u8,
    pszSpec: ?[*:0]const u8,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "shlwapi" fn PathMatchSpecExW(
    pszFile: ?[*:0]const u16,
    pszSpec: ?[*:0]const u16,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathParseIconLocationA(
    pszIconFile: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathParseIconLocationW(
    pszIconFile: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathQuoteSpacesA(
    lpsz: *[260]u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathQuoteSpacesW(
    lpsz: *[260]u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathRelativePathToA(
    pszPath: *[260]u8,
    pszFrom: ?[*:0]const u8,
    dwAttrFrom: u32,
    pszTo: ?[*:0]const u8,
    dwAttrTo: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathRelativePathToW(
    pszPath: *[260]u16,
    pszFrom: ?[*:0]const u16,
    dwAttrFrom: u32,
    pszTo: ?[*:0]const u16,
    dwAttrTo: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathRemoveArgsA(
    pszPath: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathRemoveArgsW(
    pszPath: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathRemoveBackslashA(
    pszPath: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathRemoveBackslashW(
    pszPath: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathRemoveBlanksA(
    pszPath: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathRemoveBlanksW(
    pszPath: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathRemoveExtensionA(
    pszPath: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathRemoveExtensionW(
    pszPath: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathRemoveFileSpecA(
    pszPath: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathRemoveFileSpecW(
    pszPath: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathRenameExtensionA(
    pszPath: *[260]u8,
    pszExt: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathRenameExtensionW(
    pszPath: *[260]u16,
    pszExt: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathSearchAndQualifyA(
    pszPath: ?[*:0]const u8,
    pszBuf: [*:0]u8,
    cchBuf: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathSearchAndQualifyW(
    pszPath: ?[*:0]const u16,
    pszBuf: [*:0]u16,
    cchBuf: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathSetDlgItemPathA(
    hDlg: ?HWND,
    id: i32,
    pszPath: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathSetDlgItemPathW(
    hDlg: ?HWND,
    id: i32,
    pszPath: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathSkipRootA(
    pszPath: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathSkipRootW(
    pszPath: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathStripPathA(
    pszPath: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathStripPathW(
    pszPath: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathStripToRootA(
    pszPath: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathStripToRootW(
    pszPath: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathUnquoteSpacesA(
    lpsz: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathUnquoteSpacesW(
    lpsz: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathMakeSystemFolderA(
    pszPath: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathMakeSystemFolderW(
    pszPath: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathUnmakeSystemFolderA(
    pszPath: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathUnmakeSystemFolderW(
    pszPath: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathIsSystemFolderA(
    pszPath: ?[*:0]const u8,
    dwAttrb: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathIsSystemFolderW(
    pszPath: ?[*:0]const u16,
    dwAttrb: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathUndecorateA(
    pszPath: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathUndecorateW(
    pszPath: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathUnExpandEnvStringsA(
    pszPath: ?[*:0]const u8,
    pszBuf: [*:0]u8,
    cchBuf: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathUnExpandEnvStringsW(
    pszPath: ?[*:0]const u16,
    pszBuf: [*:0]u16,
    cchBuf: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn UrlCompareA(
    psz1: ?[*:0]const u8,
    psz2: ?[*:0]const u8,
    fIgnoreSlash: BOOL,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn UrlCompareW(
    psz1: ?[*:0]const u16,
    psz2: ?[*:0]const u16,
    fIgnoreSlash: BOOL,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn UrlCombineA(
    pszBase: ?[*:0]const u8,
    pszRelative: ?[*:0]const u8,
    pszCombined: ?[*:0]u8,
    pcchCombined: ?*u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn UrlCombineW(
    pszBase: ?[*:0]const u16,
    pszRelative: ?[*:0]const u16,
    pszCombined: ?[*:0]u16,
    pcchCombined: ?*u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn UrlCanonicalizeA(
    pszUrl: ?[*:0]const u8,
    pszCanonicalized: [*:0]u8,
    pcchCanonicalized: ?*u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn UrlCanonicalizeW(
    pszUrl: ?[*:0]const u16,
    pszCanonicalized: [*:0]u16,
    pcchCanonicalized: ?*u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn UrlIsOpaqueA(
    pszURL: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn UrlIsOpaqueW(
    pszURL: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn UrlIsNoHistoryA(
    pszURL: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn UrlIsNoHistoryW(
    pszURL: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn UrlIsA(
    pszUrl: ?[*:0]const u8,
    UrlIs: URLIS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn UrlIsW(
    pszUrl: ?[*:0]const u16,
    UrlIs: URLIS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn UrlGetLocationA(
    pszURL: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn UrlGetLocationW(
    pszURL: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn UrlUnescapeA(
    pszUrl: ?PSTR,
    pszUnescaped: ?[*:0]u8,
    pcchUnescaped: ?*u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn UrlUnescapeW(
    pszUrl: ?PWSTR,
    pszUnescaped: ?[*:0]u16,
    pcchUnescaped: ?*u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn UrlEscapeA(
    pszUrl: ?[*:0]const u8,
    pszEscaped: [*:0]u8,
    pcchEscaped: ?*u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn UrlEscapeW(
    pszUrl: ?[*:0]const u16,
    pszEscaped: [*:0]u16,
    pcchEscaped: ?*u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn UrlCreateFromPathA(
    pszPath: ?[*:0]const u8,
    pszUrl: [*:0]u8,
    pcchUrl: ?*u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn UrlCreateFromPathW(
    pszPath: ?[*:0]const u16,
    pszUrl: [*:0]u16,
    pcchUrl: ?*u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathCreateFromUrlA(
    pszUrl: ?[*:0]const u8,
    pszPath: [*:0]u8,
    pcchPath: ?*u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn PathCreateFromUrlW(
    pszUrl: ?[*:0]const u16,
    pszPath: [*:0]u16,
    pcchPath: ?*u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "shlwapi" fn PathCreateFromUrlAlloc(
    pszIn: ?[*:0]const u16,
    ppszOut: ?*?PWSTR,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn UrlHashA(
    pszUrl: ?[*:0]const u8,
    // TODO: what to do with BytesParamIndex 2?
    pbHash: ?*u8,
    cbHash: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn UrlHashW(
    pszUrl: ?[*:0]const u16,
    // TODO: what to do with BytesParamIndex 2?
    pbHash: ?*u8,
    cbHash: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn UrlGetPartW(
    pszIn: ?[*:0]const u16,
    pszOut: [*:0]u16,
    pcchOut: ?*u32,
    dwPart: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn UrlGetPartA(
    pszIn: ?[*:0]const u8,
    pszOut: [*:0]u8,
    pcchOut: ?*u32,
    dwPart: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn UrlApplySchemeA(
    pszIn: ?[*:0]const u8,
    pszOut: [*:0]u8,
    pcchOut: ?*u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn UrlApplySchemeW(
    pszIn: ?[*:0]const u16,
    pszOut: [*:0]u16,
    pcchOut: ?*u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn HashData(
    // TODO: what to do with BytesParamIndex 1?
    pbData: ?*u8,
    cbData: u32,
    // TODO: what to do with BytesParamIndex 3?
    pbHash: ?*u8,
    cbHash: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shlwapi" fn UrlFixupW(
    pcszUrl: ?[*:0]const u16,
    pszTranslatedUrl: [*:0]u16,
    cchMax: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "shlwapi" fn ParseURLA(
    pcszURL: ?[*:0]const u8,
    ppu: ?*PARSEDURLA,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "shlwapi" fn ParseURLW(
    pcszURL: ?[*:0]const u16,
    ppu: ?*PARSEDURLW,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn SHDeleteEmptyKeyA(
    hkey: ?HKEY,
    pszSubKey: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn SHDeleteEmptyKeyW(
    hkey: ?HKEY,
    pszSubKey: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn SHDeleteKeyA(
    hkey: ?HKEY,
    pszSubKey: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn SHDeleteKeyW(
    hkey: ?HKEY,
    pszSubKey: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn SHRegDuplicateHKey(
    hkey: ?HKEY,
) callconv(@import("std").os.windows.WINAPI) ?HKEY;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn SHDeleteValueA(
    hkey: ?HKEY,
    pszSubKey: ?[*:0]const u8,
    pszValue: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn SHDeleteValueW(
    hkey: ?HKEY,
    pszSubKey: ?[*:0]const u16,
    pszValue: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn SHGetValueA(
    hkey: ?HKEY,
    pszSubKey: ?[*:0]const u8,
    pszValue: ?[*:0]const u8,
    pdwType: ?*u32,
    // TODO: what to do with BytesParamIndex 5?
    pvData: ?*anyopaque,
    pcbData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn SHGetValueW(
    hkey: ?HKEY,
    pszSubKey: ?[*:0]const u16,
    pszValue: ?[*:0]const u16,
    pdwType: ?*u32,
    // TODO: what to do with BytesParamIndex 5?
    pvData: ?*anyopaque,
    pcbData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn SHSetValueA(
    hkey: ?HKEY,
    pszSubKey: ?[*:0]const u8,
    pszValue: ?[*:0]const u8,
    dwType: u32,
    // TODO: what to do with BytesParamIndex 5?
    pvData: ?*const anyopaque,
    cbData: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn SHSetValueW(
    hkey: ?HKEY,
    pszSubKey: ?[*:0]const u16,
    pszValue: ?[*:0]const u16,
    dwType: u32,
    // TODO: what to do with BytesParamIndex 5?
    pvData: ?*const anyopaque,
    cbData: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shlwapi" fn SHRegGetValueA(
    hkey: ?HKEY,
    pszSubKey: ?[*:0]const u8,
    pszValue: ?[*:0]const u8,
    srrfFlags: i32,
    pdwType: ?*u32,
    // TODO: what to do with BytesParamIndex 6?
    pvData: ?*anyopaque,
    pcbData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shlwapi" fn SHRegGetValueW(
    hkey: ?HKEY,
    pszSubKey: ?[*:0]const u16,
    pszValue: ?[*:0]const u16,
    srrfFlags: i32,
    pdwType: ?*u32,
    // TODO: what to do with BytesParamIndex 6?
    pvData: ?*anyopaque,
    pcbData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "shlwapi" fn SHRegGetValueFromHKCUHKLM(
    pwszKey: ?[*:0]const u16,
    pwszValue: ?[*:0]const u16,
    srrfFlags: i32,
    pdwType: ?*u32,
    // TODO: what to do with BytesParamIndex 5?
    pvData: ?*anyopaque,
    pcbData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn SHQueryValueExA(
    hkey: ?HKEY,
    pszValue: ?[*:0]const u8,
    pdwReserved: ?*u32,
    pdwType: ?*u32,
    // TODO: what to do with BytesParamIndex 5?
    pvData: ?*anyopaque,
    pcbData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn SHQueryValueExW(
    hkey: ?HKEY,
    pszValue: ?[*:0]const u16,
    pdwReserved: ?*u32,
    pdwType: ?*u32,
    // TODO: what to do with BytesParamIndex 5?
    pvData: ?*anyopaque,
    pcbData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn SHEnumKeyExA(
    hkey: ?HKEY,
    dwIndex: u32,
    pszName: [*:0]u8,
    pcchName: ?*u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn SHEnumKeyExW(
    hkey: ?HKEY,
    dwIndex: u32,
    pszName: [*:0]u16,
    pcchName: ?*u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn SHEnumValueA(
    hkey: ?HKEY,
    dwIndex: u32,
    pszValueName: ?[*:0]u8,
    pcchValueName: ?*u32,
    pdwType: ?*u32,
    // TODO: what to do with BytesParamIndex 6?
    pvData: ?*anyopaque,
    pcbData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn SHEnumValueW(
    hkey: ?HKEY,
    dwIndex: u32,
    pszValueName: ?[*:0]u16,
    pcchValueName: ?*u32,
    pdwType: ?*u32,
    // TODO: what to do with BytesParamIndex 6?
    pvData: ?*anyopaque,
    pcbData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn SHQueryInfoKeyA(
    hkey: ?HKEY,
    pcSubKeys: ?*u32,
    pcchMaxSubKeyLen: ?*u32,
    pcValues: ?*u32,
    pcchMaxValueNameLen: ?*u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn SHQueryInfoKeyW(
    hkey: ?HKEY,
    pcSubKeys: ?*u32,
    pcchMaxSubKeyLen: ?*u32,
    pcValues: ?*u32,
    pcchMaxValueNameLen: ?*u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn SHCopyKeyA(
    hkeySrc: ?HKEY,
    pszSrcSubKey: ?[*:0]const u8,
    hkeyDest: ?HKEY,
    fReserved: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn SHCopyKeyW(
    hkeySrc: ?HKEY,
    pszSrcSubKey: ?[*:0]const u16,
    hkeyDest: ?HKEY,
    fReserved: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn SHRegGetPathA(
    hKey: ?HKEY,
    pcszSubKey: ?[*:0]const u8,
    pcszValue: ?[*:0]const u8,
    pszPath: *[260]u8,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn SHRegGetPathW(
    hKey: ?HKEY,
    pcszSubKey: ?[*:0]const u16,
    pcszValue: ?[*:0]const u16,
    pszPath: *[260]u16,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn SHRegSetPathA(
    hKey: ?HKEY,
    pcszSubKey: ?[*:0]const u8,
    pcszValue: ?[*:0]const u8,
    pcszPath: ?[*:0]const u8,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn SHRegSetPathW(
    hKey: ?HKEY,
    pcszSubKey: ?[*:0]const u16,
    pcszValue: ?[*:0]const u16,
    pcszPath: ?[*:0]const u16,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn SHRegCreateUSKeyA(
    pszPath: ?[*:0]const u8,
    samDesired: u32,
    hRelativeUSKey: isize,
    phNewUSKey: ?*isize,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn SHRegCreateUSKeyW(
    pwzPath: ?[*:0]const u16,
    samDesired: u32,
    hRelativeUSKey: isize,
    phNewUSKey: ?*isize,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn SHRegOpenUSKeyA(
    pszPath: ?[*:0]const u8,
    samDesired: u32,
    hRelativeUSKey: isize,
    phNewUSKey: ?*isize,
    fIgnoreHKCU: BOOL,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn SHRegOpenUSKeyW(
    pwzPath: ?[*:0]const u16,
    samDesired: u32,
    hRelativeUSKey: isize,
    phNewUSKey: ?*isize,
    fIgnoreHKCU: BOOL,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn SHRegQueryUSValueA(
    hUSKey: isize,
    pszValue: ?[*:0]const u8,
    pdwType: ?*u32,
    // TODO: what to do with BytesParamIndex 4?
    pvData: ?*anyopaque,
    pcbData: ?*u32,
    fIgnoreHKCU: BOOL,
    // TODO: what to do with BytesParamIndex 7?
    pvDefaultData: ?*anyopaque,
    dwDefaultDataSize: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn SHRegQueryUSValueW(
    hUSKey: isize,
    pszValue: ?[*:0]const u16,
    pdwType: ?*u32,
    // TODO: what to do with BytesParamIndex 4?
    pvData: ?*anyopaque,
    pcbData: ?*u32,
    fIgnoreHKCU: BOOL,
    // TODO: what to do with BytesParamIndex 7?
    pvDefaultData: ?*anyopaque,
    dwDefaultDataSize: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn SHRegWriteUSValueA(
    hUSKey: isize,
    pszValue: ?[*:0]const u8,
    dwType: u32,
    // TODO: what to do with BytesParamIndex 4?
    pvData: ?*const anyopaque,
    cbData: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn SHRegWriteUSValueW(
    hUSKey: isize,
    pwzValue: ?[*:0]const u16,
    dwType: u32,
    // TODO: what to do with BytesParamIndex 4?
    pvData: ?*const anyopaque,
    cbData: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn SHRegDeleteUSValueA(
    hUSKey: isize,
    pszValue: ?[*:0]const u8,
    delRegFlags: SHREGDEL_FLAGS,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn SHRegDeleteUSValueW(
    hUSKey: isize,
    pwzValue: ?[*:0]const u16,
    delRegFlags: SHREGDEL_FLAGS,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn SHRegDeleteEmptyUSKeyW(
    hUSKey: isize,
    pwzSubKey: ?[*:0]const u16,
    delRegFlags: SHREGDEL_FLAGS,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn SHRegDeleteEmptyUSKeyA(
    hUSKey: isize,
    pszSubKey: ?[*:0]const u8,
    delRegFlags: SHREGDEL_FLAGS,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn SHRegEnumUSKeyA(
    hUSKey: isize,
    dwIndex: u32,
    pszName: [*:0]u8,
    pcchName: ?*u32,
    enumRegFlags: SHREGENUM_FLAGS,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn SHRegEnumUSKeyW(
    hUSKey: isize,
    dwIndex: u32,
    pwzName: [*:0]u16,
    pcchName: ?*u32,
    enumRegFlags: SHREGENUM_FLAGS,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn SHRegEnumUSValueA(
    hUSkey: isize,
    dwIndex: u32,
    pszValueName: [*:0]u8,
    pcchValueName: ?*u32,
    pdwType: ?*u32,
    // TODO: what to do with BytesParamIndex 6?
    pvData: ?*anyopaque,
    pcbData: ?*u32,
    enumRegFlags: SHREGENUM_FLAGS,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn SHRegEnumUSValueW(
    hUSkey: isize,
    dwIndex: u32,
    pszValueName: [*:0]u16,
    pcchValueName: ?*u32,
    pdwType: ?*u32,
    // TODO: what to do with BytesParamIndex 6?
    pvData: ?*anyopaque,
    pcbData: ?*u32,
    enumRegFlags: SHREGENUM_FLAGS,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn SHRegQueryInfoUSKeyA(
    hUSKey: isize,
    pcSubKeys: ?*u32,
    pcchMaxSubKeyLen: ?*u32,
    pcValues: ?*u32,
    pcchMaxValueNameLen: ?*u32,
    enumRegFlags: SHREGENUM_FLAGS,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn SHRegQueryInfoUSKeyW(
    hUSKey: isize,
    pcSubKeys: ?*u32,
    pcchMaxSubKeyLen: ?*u32,
    pcValues: ?*u32,
    pcchMaxValueNameLen: ?*u32,
    enumRegFlags: SHREGENUM_FLAGS,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn SHRegCloseUSKey(
    hUSKey: isize,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn SHRegGetUSValueA(
    pszSubKey: ?[*:0]const u8,
    pszValue: ?[*:0]const u8,
    pdwType: ?*u32,
    // TODO: what to do with BytesParamIndex 4?
    pvData: ?*anyopaque,
    pcbData: ?*u32,
    fIgnoreHKCU: BOOL,
    // TODO: what to do with BytesParamIndex 7?
    pvDefaultData: ?*anyopaque,
    dwDefaultDataSize: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn SHRegGetUSValueW(
    pszSubKey: ?[*:0]const u16,
    pszValue: ?[*:0]const u16,
    pdwType: ?*u32,
    // TODO: what to do with BytesParamIndex 4?
    pvData: ?*anyopaque,
    pcbData: ?*u32,
    fIgnoreHKCU: BOOL,
    // TODO: what to do with BytesParamIndex 7?
    pvDefaultData: ?*anyopaque,
    dwDefaultDataSize: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn SHRegSetUSValueA(
    pszSubKey: ?[*:0]const u8,
    pszValue: ?[*:0]const u8,
    dwType: u32,
    // TODO: what to do with BytesParamIndex 4?
    pvData: ?*const anyopaque,
    cbData: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn SHRegSetUSValueW(
    pwzSubKey: ?[*:0]const u16,
    pwzValue: ?[*:0]const u16,
    dwType: u32,
    // TODO: what to do with BytesParamIndex 4?
    pvData: ?*const anyopaque,
    cbData: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn SHRegGetIntW(
    hk: ?HKEY,
    pwzKey: ?[*:0]const u16,
    iDefault: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn SHRegGetBoolUSValueA(
    pszSubKey: ?[*:0]const u8,
    pszValue: ?[*:0]const u8,
    fIgnoreHKCU: BOOL,
    fDefault: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn SHRegGetBoolUSValueW(
    pszSubKey: ?[*:0]const u16,
    pszValue: ?[*:0]const u16,
    fIgnoreHKCU: BOOL,
    fDefault: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn AssocCreate(
    clsid: Guid,
    riid: ?*const Guid,
    ppv: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn AssocQueryStringA(
    flags: u32,
    str: ASSOCSTR,
    pszAssoc: ?[*:0]const u8,
    pszExtra: ?[*:0]const u8,
    pszOut: ?[*:0]u8,
    pcchOut: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn AssocQueryStringW(
    flags: u32,
    str: ASSOCSTR,
    pszAssoc: ?[*:0]const u16,
    pszExtra: ?[*:0]const u16,
    pszOut: ?[*:0]u16,
    pcchOut: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn AssocQueryStringByKeyA(
    flags: u32,
    str: ASSOCSTR,
    hkAssoc: ?HKEY,
    pszExtra: ?[*:0]const u8,
    pszOut: ?[*:0]u8,
    pcchOut: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn AssocQueryStringByKeyW(
    flags: u32,
    str: ASSOCSTR,
    hkAssoc: ?HKEY,
    pszExtra: ?[*:0]const u16,
    pszOut: ?[*:0]u16,
    pcchOut: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn AssocQueryKeyA(
    flags: u32,
    key: ASSOCKEY,
    pszAssoc: ?[*:0]const u8,
    pszExtra: ?[*:0]const u8,
    phkeyOut: ?*?HKEY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn AssocQueryKeyW(
    flags: u32,
    key: ASSOCKEY,
    pszAssoc: ?[*:0]const u16,
    pszExtra: ?[*:0]const u16,
    phkeyOut: ?*?HKEY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shlwapi" fn AssocIsDangerous(
    pszAssoc: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shlwapi" fn AssocGetPerceivedType(
    pszExt: ?[*:0]const u16,
    ptype: ?*PERCEIVED,
    pflag: ?*u32,
    ppszType: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn SHOpenRegStreamA(
    hkey: ?HKEY,
    pszSubkey: ?[*:0]const u8,
    pszValue: ?[*:0]const u8,
    grfMode: u32,
) callconv(@import("std").os.windows.WINAPI) ?*IStream;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn SHOpenRegStreamW(
    hkey: ?HKEY,
    pszSubkey: ?[*:0]const u16,
    pszValue: ?[*:0]const u16,
    grfMode: u32,
) callconv(@import("std").os.windows.WINAPI) ?*IStream;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn SHOpenRegStream2A(
    hkey: ?HKEY,
    pszSubkey: ?[*:0]const u8,
    pszValue: ?[*:0]const u8,
    grfMode: u32,
) callconv(@import("std").os.windows.WINAPI) ?*IStream;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn SHOpenRegStream2W(
    hkey: ?HKEY,
    pszSubkey: ?[*:0]const u16,
    pszValue: ?[*:0]const u16,
    grfMode: u32,
) callconv(@import("std").os.windows.WINAPI) ?*IStream;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shlwapi" fn SHCreateStreamOnFileA(
    pszFile: ?[*:0]const u8,
    grfMode: u32,
    ppstm: ?*?*IStream,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shlwapi" fn SHCreateStreamOnFileW(
    pszFile: ?[*:0]const u16,
    grfMode: u32,
    ppstm: ?*?*IStream,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shlwapi" fn SHCreateStreamOnFileEx(
    pszFile: ?[*:0]const u16,
    grfMode: u32,
    dwAttributes: u32,
    fCreate: BOOL,
    pstmTemplate: ?*IStream,
    ppstm: ?*?*IStream,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn SHCreateMemStream(
    // TODO: what to do with BytesParamIndex 1?
    pInit: ?*const u8,
    cbInit: u32,
) callconv(@import("std").os.windows.WINAPI) ?*IStream;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn GetAcceptLanguagesA(
    pszLanguages: [*:0]u8,
    pcchLanguages: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn GetAcceptLanguagesW(
    pszLanguages: [*:0]u16,
    pcchLanguages: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn IUnknown_Set(
    ppunk: ?*?*IUnknown,
    punk: ?*IUnknown,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn IUnknown_AtomicRelease(
    ppunk: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn IUnknown_GetWindow(
    punk: ?*IUnknown,
    phwnd: ?*?HWND,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn IUnknown_SetSite(
    punk: ?*IUnknown,
    punkSite: ?*IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn IUnknown_GetSite(
    punk: ?*IUnknown,
    riid: ?*const Guid,
    ppv: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn IUnknown_QueryService(
    punk: ?*IUnknown,
    guidService: ?*const Guid,
    riid: ?*const Guid,
    ppvOut: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn IStream_Read(
    pstm: ?*IStream,
    pv: ?*anyopaque,
    cb: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "shlwapi" fn IStream_Write(
    pstm: ?*IStream,
    // TODO: what to do with BytesParamIndex 2?
    pv: ?*const anyopaque,
    cb: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn IStream_Reset(
    pstm: ?*IStream,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn IStream_Size(
    pstm: ?*IStream,
    pui: ?*ULARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn ConnectToConnectionPoint(
    punk: ?*IUnknown,
    riidEvent: ?*const Guid,
    fConnect: BOOL,
    punkTarget: ?*IUnknown,
    pdwCookie: ?*u32,
    ppcpOut: ?*?*IConnectionPoint,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "shlwapi" fn IStream_ReadPidl(
    pstm: ?*IStream,
    ppidlOut: ?*?*ITEMIDLIST,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "shlwapi" fn IStream_WritePidl(
    pstm: ?*IStream,
    pidlWrite: ?*ITEMIDLIST,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "shlwapi" fn IStream_ReadStr(
    pstm: ?*IStream,
    ppsz: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "shlwapi" fn IStream_WriteStr(
    pstm: ?*IStream,
    psz: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "shlwapi" fn IStream_Copy(
    pstmFrom: ?*IStream,
    pstmTo: ?*IStream,
    cb: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shlwapi" fn SHGetViewStatePropertyBag(
    pidl: ?*ITEMIDLIST,
    pszBagName: ?[*:0]const u16,
    dwFlags: u32,
    riid: ?*const Guid,
    ppv: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shlwapi" fn SHFormatDateTimeA(
    pft: ?*const FILETIME,
    pdwFlags: ?*u32,
    pszBuf: [*:0]u8,
    cchBuf: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shlwapi" fn SHFormatDateTimeW(
    pft: ?*const FILETIME,
    pdwFlags: ?*u32,
    pszBuf: [*:0]u16,
    cchBuf: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn SHAnsiToUnicode(
    pszSrc: ?[*:0]const u8,
    pwszDst: [*:0]u16,
    cwchBuf: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn SHAnsiToAnsi(
    pszSrc: ?[*:0]const u8,
    pszDst: [*:0]u8,
    cchBuf: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn SHUnicodeToAnsi(
    pwszSrc: ?[*:0]const u16,
    pszDst: [*:0]u8,
    cchBuf: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn SHUnicodeToUnicode(
    pwzSrc: ?[*:0]const u16,
    pwzDst: [*:0]u16,
    cwchBuf: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shlwapi" fn SHMessageBoxCheckA(
    hwnd: ?HWND,
    pszText: ?[*:0]const u8,
    pszCaption: ?[*:0]const u8,
    uType: u32,
    iDefault: i32,
    pszRegVal: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shlwapi" fn SHMessageBoxCheckW(
    hwnd: ?HWND,
    pszText: ?[*:0]const u16,
    pszCaption: ?[*:0]const u16,
    uType: u32,
    iDefault: i32,
    pszRegVal: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shlwapi" fn SHSendMessageBroadcastA(
    uMsg: u32,
    wParam: WPARAM,
    lParam: LPARAM,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shlwapi" fn SHSendMessageBroadcastW(
    uMsg: u32,
    wParam: WPARAM,
    lParam: LPARAM,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn SHStripMneumonicA(
    pszMenu: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) CHAR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn SHStripMneumonicW(
    pszMenu: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) u16;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn IsOS(
    dwOS: OS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "shlwapi" fn SHGlobalCounterGetValue(
    id: SHGLOBALCOUNTER,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "shlwapi" fn SHGlobalCounterIncrement(
    id: SHGLOBALCOUNTER,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "shlwapi" fn SHGlobalCounterDecrement(
    id: SHGLOBALCOUNTER,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shlwapi" fn SHAllocShared(
    // TODO: what to do with BytesParamIndex 1?
    pvData: ?*const anyopaque,
    dwSize: u32,
    dwProcessId: u32,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shlwapi" fn SHFreeShared(
    hData: ?HANDLE,
    dwProcessId: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shlwapi" fn SHLockShared(
    hData: ?HANDLE,
    dwProcessId: u32,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shlwapi" fn SHUnlockShared(
    pvData: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shlwapi" fn WhichPlatform() callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn QISearch(
    that: ?*anyopaque,
    pqit: ?*QITAB,
    riid: ?*const Guid,
    ppv: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shlwapi" fn SHIsLowMemoryMachine(
    dwType: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shlwapi" fn GetMenuPosFromID(
    hmenu: ?HMENU,
    id: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn SHGetInverseCMAP(
    // TODO: what to do with BytesParamIndex 1?
    pbMap: ?*u8,
    cbMap: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn SHAutoComplete(
    hwndEdit: ?HWND,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shlwapi" fn SHCreateThreadRef(
    pcRef: ?*i32,
    ppunk: ?*?*IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn SHSetThreadRef(
    punk: ?*IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn SHGetThreadRef(
    ppunk: ?*?*IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn SHSkipJunction(
    pbc: ?*IBindCtx,
    pclsid: ?*const Guid,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn SHCreateThread(
    pfnThreadProc: ?LPTHREAD_START_ROUTINE,
    pData: ?*anyopaque,
    flags: u32,
    pfnCallback: ?LPTHREAD_START_ROUTINE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "shlwapi" fn SHCreateThreadWithHandle(
    pfnThreadProc: ?LPTHREAD_START_ROUTINE,
    pData: ?*anyopaque,
    flags: u32,
    pfnCallback: ?LPTHREAD_START_ROUTINE,
    pHandle: ?*?HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shlwapi" fn SHReleaseThreadRef() callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn SHCreateShellPalette(
    hdc: ?HDC,
) callconv(@import("std").os.windows.WINAPI) ?HPALETTE;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn ColorRGBToHLS(
    clrRGB: u32,
    pwHue: ?*u16,
    pwLuminance: ?*u16,
    pwSaturation: ?*u16,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn ColorHLSToRGB(
    wHue: u16,
    wLuminance: u16,
    wSaturation: u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "shlwapi" fn ColorAdjustLuma(
    clrRGB: u32,
    n: i32,
    fScale: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "shlwapi" fn IsInternetESCEnabled() callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "hlink" fn HlinkCreateFromMoniker(
    pimkTrgt: ?*IMoniker,
    pwzLocation: ?[*:0]const u16,
    pwzFriendlyName: ?[*:0]const u16,
    pihlsite: ?*IHlinkSite,
    dwSiteData: u32,
    piunkOuter: ?*IUnknown,
    riid: ?*const Guid,
    ppvObj: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "hlink" fn HlinkCreateFromString(
    pwzTarget: ?[*:0]const u16,
    pwzLocation: ?[*:0]const u16,
    pwzFriendlyName: ?[*:0]const u16,
    pihlsite: ?*IHlinkSite,
    dwSiteData: u32,
    piunkOuter: ?*IUnknown,
    riid: ?*const Guid,
    ppvObj: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "hlink" fn HlinkCreateFromData(
    piDataObj: ?*IDataObject,
    pihlsite: ?*IHlinkSite,
    dwSiteData: u32,
    piunkOuter: ?*IUnknown,
    riid: ?*const Guid,
    ppvObj: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "hlink" fn HlinkQueryCreateFromData(
    piDataObj: ?*IDataObject,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "hlink" fn HlinkClone(
    pihl: ?*IHlink,
    riid: ?*const Guid,
    pihlsiteForClone: ?*IHlinkSite,
    dwSiteData: u32,
    ppvObj: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "hlink" fn HlinkCreateBrowseContext(
    piunkOuter: ?*IUnknown,
    riid: ?*const Guid,
    ppvObj: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "hlink" fn HlinkNavigateToStringReference(
    pwzTarget: ?[*:0]const u16,
    pwzLocation: ?[*:0]const u16,
    pihlsite: ?*IHlinkSite,
    dwSiteData: u32,
    pihlframe: ?*IHlinkFrame,
    grfHLNF: u32,
    pibc: ?*IBindCtx,
    pibsc: ?*IBindStatusCallback,
    pihlbc: ?*IHlinkBrowseContext,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "hlink" fn HlinkNavigate(
    pihl: ?*IHlink,
    pihlframe: ?*IHlinkFrame,
    grfHLNF: u32,
    pbc: ?*IBindCtx,
    pibsc: ?*IBindStatusCallback,
    pihlbc: ?*IHlinkBrowseContext,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "hlink" fn HlinkOnNavigate(
    pihlframe: ?*IHlinkFrame,
    pihlbc: ?*IHlinkBrowseContext,
    grfHLNF: u32,
    pimkTarget: ?*IMoniker,
    pwzLocation: ?[*:0]const u16,
    pwzFriendlyName: ?[*:0]const u16,
    puHLID: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "hlink" fn HlinkUpdateStackItem(
    pihlframe: ?*IHlinkFrame,
    pihlbc: ?*IHlinkBrowseContext,
    uHLID: u32,
    pimkTrgt: ?*IMoniker,
    pwzLocation: ?[*:0]const u16,
    pwzFriendlyName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "hlink" fn HlinkOnRenameDocument(
    dwReserved: u32,
    pihlbc: ?*IHlinkBrowseContext,
    pimkOld: ?*IMoniker,
    pimkNew: ?*IMoniker,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "hlink" fn HlinkResolveMonikerForData(
    pimkReference: ?*IMoniker,
    reserved: u32,
    pibc: ?*IBindCtx,
    cFmtetc: u32,
    rgFmtetc: ?*FORMATETC,
    pibsc: ?*IBindStatusCallback,
    pimkBase: ?*IMoniker,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "hlink" fn HlinkResolveStringForData(
    pwzReference: ?[*:0]const u16,
    reserved: u32,
    pibc: ?*IBindCtx,
    cFmtetc: u32,
    rgFmtetc: ?*FORMATETC,
    pibsc: ?*IBindStatusCallback,
    pimkBase: ?*IMoniker,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "hlink" fn HlinkParseDisplayName(
    pibc: ?*IBindCtx,
    pwzDisplayName: ?[*:0]const u16,
    fNoForceAbs: BOOL,
    pcchEaten: ?*u32,
    ppimk: ?*?*IMoniker,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "hlink" fn HlinkCreateExtensionServices(
    pwzAdditionalHeaders: ?[*:0]const u16,
    phwnd: ?HWND,
    pszUsername: ?[*:0]const u16,
    pszPassword: ?[*:0]const u16,
    piunkOuter: ?*IUnknown,
    riid: ?*const Guid,
    ppvObj: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "hlink" fn HlinkPreprocessMoniker(
    pibc: ?*IBindCtx,
    pimkIn: ?*IMoniker,
    ppimkOut: ?*?*IMoniker,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "hlink" fn OleSaveToStreamEx(
    piunk: ?*IUnknown,
    pistm: ?*IStream,
    fClearDirty: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "hlink" fn HlinkSetSpecialReference(
    uReference: u32,
    pwzReference: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "hlink" fn HlinkGetSpecialReference(
    uReference: u32,
    ppwzReference: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "hlink" fn HlinkCreateShortcut(
    grfHLSHORTCUTF: u32,
    pihl: ?*IHlink,
    pwzDir: ?[*:0]const u16,
    pwzFileName: ?[*:0]const u16,
    ppwzShortcutFile: ?*?PWSTR,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "hlink" fn HlinkCreateShortcutFromMoniker(
    grfHLSHORTCUTF: u32,
    pimkTarget: ?*IMoniker,
    pwzLocation: ?[*:0]const u16,
    pwzDir: ?[*:0]const u16,
    pwzFileName: ?[*:0]const u16,
    ppwzShortcutFile: ?*?PWSTR,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "hlink" fn HlinkCreateShortcutFromString(
    grfHLSHORTCUTF: u32,
    pwzTarget: ?[*:0]const u16,
    pwzLocation: ?[*:0]const u16,
    pwzDir: ?[*:0]const u16,
    pwzFileName: ?[*:0]const u16,
    ppwzShortcutFile: ?*?PWSTR,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "hlink" fn HlinkResolveShortcut(
    pwzShortcutFileName: ?[*:0]const u16,
    pihlsite: ?*IHlinkSite,
    dwSiteData: u32,
    piunkOuter: ?*IUnknown,
    riid: ?*const Guid,
    ppvObj: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "hlink" fn HlinkResolveShortcutToMoniker(
    pwzShortcutFileName: ?[*:0]const u16,
    ppimkTarget: ?*?*IMoniker,
    ppwzLocation: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "hlink" fn HlinkResolveShortcutToString(
    pwzShortcutFileName: ?[*:0]const u16,
    ppwzTarget: ?*?PWSTR,
    ppwzLocation: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "hlink" fn HlinkIsShortcut(
    pwzFileName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "hlink" fn HlinkGetValueFromParams(
    pwzParams: ?[*:0]const u16,
    pwzName: ?[*:0]const u16,
    ppwzValue: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "hlink" fn HlinkTranslateURL(
    pwzURL: ?[*:0]const u16,
    grfFlags: u32,
    ppwzTranslatedURL: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-path-l1-1-0" fn PathIsUNCEx(
    pszPath: ?[*:0]const u16,
    ppszServer: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-path-l1-1-0" fn PathCchIsRoot(
    pszPath: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-path-l1-1-0" fn PathCchAddBackslashEx(
    pszPath: [*:0]u16,
    cchPath: usize,
    ppszEnd: ?*?PWSTR,
    pcchRemaining: ?*usize,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-path-l1-1-0" fn PathCchAddBackslash(
    pszPath: [*:0]u16,
    cchPath: usize,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-path-l1-1-0" fn PathCchRemoveBackslashEx(
    pszPath: ?PWSTR,
    cchPath: usize,
    ppszEnd: ?*?PWSTR,
    pcchRemaining: ?*usize,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-path-l1-1-0" fn PathCchRemoveBackslash(
    pszPath: [*:0]u16,
    cchPath: usize,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-path-l1-1-0" fn PathCchSkipRoot(
    pszPath: ?[*:0]const u16,
    ppszRootEnd: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-path-l1-1-0" fn PathCchStripToRoot(
    pszPath: ?PWSTR,
    cchPath: usize,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-path-l1-1-0" fn PathCchRemoveFileSpec(
    pszPath: ?PWSTR,
    cchPath: usize,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-path-l1-1-0" fn PathCchFindExtension(
    pszPath: ?[*:0]const u16,
    cchPath: usize,
    ppszExt: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-path-l1-1-0" fn PathCchAddExtension(
    pszPath: [*:0]u16,
    cchPath: usize,
    pszExt: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-path-l1-1-0" fn PathCchRenameExtension(
    pszPath: [*:0]u16,
    cchPath: usize,
    pszExt: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-path-l1-1-0" fn PathCchRemoveExtension(
    pszPath: ?PWSTR,
    cchPath: usize,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-path-l1-1-0" fn PathCchCanonicalizeEx(
    pszPathOut: [*:0]u16,
    cchPathOut: usize,
    pszPathIn: ?[*:0]const u16,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-path-l1-1-0" fn PathCchCanonicalize(
    pszPathOut: [*:0]u16,
    cchPathOut: usize,
    pszPathIn: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-path-l1-1-0" fn PathCchCombineEx(
    pszPathOut: [*:0]u16,
    cchPathOut: usize,
    pszPathIn: ?[*:0]const u16,
    pszMore: ?[*:0]const u16,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-path-l1-1-0" fn PathCchCombine(
    pszPathOut: [*:0]u16,
    cchPathOut: usize,
    pszPathIn: ?[*:0]const u16,
    pszMore: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-path-l1-1-0" fn PathCchAppendEx(
    pszPath: [*:0]u16,
    cchPath: usize,
    pszMore: ?[*:0]const u16,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-path-l1-1-0" fn PathCchAppend(
    pszPath: [*:0]u16,
    cchPath: usize,
    pszMore: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-path-l1-1-0" fn PathCchStripPrefix(
    pszPath: [*:0]u16,
    cchPath: usize,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-path-l1-1-0" fn PathAllocCombine(
    pszPathIn: ?[*:0]const u16,
    pszMore: ?[*:0]const u16,
    dwFlags: u32,
    ppszPathOut: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-path-l1-1-0" fn PathAllocCanonicalize(
    pszPathIn: ?[*:0]const u16,
    dwFlags: u32,
    ppszPathOut: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "api-ms-win-core-psm-appnotify-l1-1-0" fn RegisterAppStateChangeNotification(
    Routine: ?PAPPSTATE_CHANGE_ROUTINE,
    Context: ?*anyopaque,
    Registration: ?*?*_APPSTATE_REGISTRATION,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "api-ms-win-core-psm-appnotify-l1-1-0" fn UnregisterAppStateChangeNotification(
    Registration: ?*_APPSTATE_REGISTRATION,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "api-ms-win-core-psm-appnotify-l1-1-1" fn RegisterAppConstrainedChangeNotification(
    Routine: ?PAPPCONSTRAIN_CHANGE_ROUTINE,
    Context: ?*anyopaque,
    Registration: ?*?*_APPCONSTRAIN_REGISTRATION,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "api-ms-win-core-psm-appnotify-l1-1-1" fn UnregisterAppConstrainedChangeNotification(
    Registration: ?*_APPCONSTRAIN_REGISTRATION,
) callconv(@import("std").os.windows.WINAPI) void;

//--------------------------------------------------------------------------------
// Section: Unicode Aliases (205)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
        pub const MULTIKEYHELP = thismodule.MULTIKEYHELPA;
        pub const HELPWININFO = thismodule.HELPWININFOA;
        pub const IShellLink = thismodule.IShellLinkA;
        pub const IExtractIcon = thismodule.IExtractIconA;
        pub const BROWSEINFO = thismodule.BROWSEINFOA;
        pub const FILEDESCRIPTOR = thismodule.FILEDESCRIPTORA;
        pub const FILEGROUPDESCRIPTOR = thismodule.FILEGROUPDESCRIPTORA;
        pub const SHELLSTATE = thismodule.SHELLSTATEA;
        pub const INewShortcutHook = thismodule.INewShortcutHookA;
        pub const ICopyHook = thismodule.ICopyHookA;
        pub const DRAGINFO = thismodule.DRAGINFOA;
        pub const SHFILEOPSTRUCT = thismodule.SHFILEOPSTRUCTA;
        pub const SHNAMEMAPPING = thismodule.SHNAMEMAPPINGA;
        pub const SHELLEXECUTEINFO = thismodule.SHELLEXECUTEINFOA;
        pub const NOTIFYICONDATA = thismodule.NOTIFYICONDATAA;
        pub const SHFILEINFO = thismodule.SHFILEINFOA;
        pub const OPEN_PRINTER_PROPS_INFO = thismodule.OPEN_PRINTER_PROPS_INFOA;
        pub const PARSEDURL = thismodule.PARSEDURLA;
        pub const NEWCPLINFO = thismodule.NEWCPLINFOA;
        pub const PROFILEINFO = thismodule.PROFILEINFOA;
        pub const urlinvokecommandinfo = thismodule.urlinvokecommandinfoA;
        pub const IUniformResourceLocator = thismodule.IUniformResourceLocatorA;
        pub const LoadUserProfile = thismodule.LoadUserProfileA;
        pub const GetProfilesDirectory = thismodule.GetProfilesDirectoryA;
        pub const DeleteProfile = thismodule.DeleteProfileA;
        pub const GetDefaultUserProfileDirectory = thismodule.GetDefaultUserProfileDirectoryA;
        pub const GetAllUsersProfileDirectory = thismodule.GetAllUsersProfileDirectoryA;
        pub const GetUserProfileDirectory = thismodule.GetUserProfileDirectoryA;
        pub const WinHelp = thismodule.WinHelpA;
        pub const SHGetIconOverlayIndex = thismodule.SHGetIconOverlayIndexA;
        pub const ILCreateFromPath = thismodule.ILCreateFromPathA;
        pub const SHGetPathFromIDList = thismodule.SHGetPathFromIDListA;
        pub const SHCreateDirectoryEx = thismodule.SHCreateDirectoryExA;
        pub const SHGetSpecialFolderPath = thismodule.SHGetSpecialFolderPathA;
        pub const SHGetFolderPath = thismodule.SHGetFolderPathA;
        pub const SHSetFolderPath = thismodule.SHSetFolderPathA;
        pub const SHGetFolderPathAndSubDir = thismodule.SHGetFolderPathAndSubDirA;
        pub const SHBrowseForFolder = thismodule.SHBrowseForFolderA;
        pub const SHUpdateImage = thismodule.SHUpdateImageA;
        pub const SHGetDataFromIDList = thismodule.SHGetDataFromIDListA;
        pub const SHDefExtractIcon = thismodule.SHDefExtractIconA;
        pub const SHPathPrepareForWrite = thismodule.SHPathPrepareForWriteA;
        pub const PathIsSlow = thismodule.PathIsSlowA;
        pub const DragQueryFile = thismodule.DragQueryFileA;
        pub const ShellExecute = thismodule.ShellExecuteA;
        pub const FindExecutable = thismodule.FindExecutableA;
        pub const ShellAbout = thismodule.ShellAboutA;
        pub const ExtractAssociatedIcon = thismodule.ExtractAssociatedIconA;
        pub const ExtractAssociatedIconEx = thismodule.ExtractAssociatedIconExA;
        pub const ExtractIcon = thismodule.ExtractIconA;
        pub const DoEnvironmentSubst = thismodule.DoEnvironmentSubstA;
        pub const ExtractIconEx = thismodule.ExtractIconExA;
        pub const SHFileOperation = thismodule.SHFileOperationA;
        pub const ShellExecuteEx = thismodule.ShellExecuteExA;
        pub const SHQueryRecycleBin = thismodule.SHQueryRecycleBinA;
        pub const SHEmptyRecycleBin = thismodule.SHEmptyRecycleBinA;
        pub const Shell_NotifyIcon = thismodule.Shell_NotifyIconA;
        pub const SHGetFileInfo = thismodule.SHGetFileInfoA;
        pub const SHGetDiskFreeSpaceEx = thismodule.SHGetDiskFreeSpaceExA;
        pub const SHGetNewLinkInfo = thismodule.SHGetNewLinkInfoA;
        pub const SHInvokePrinterCommand = thismodule.SHInvokePrinterCommandA;
        pub const ShellMessageBox = thismodule.ShellMessageBoxA;
        pub const IsLFNDrive = thismodule.IsLFNDriveA;
        pub const StrChr = thismodule.StrChrA;
        pub const StrChrI = thismodule.StrChrIA;
        pub const StrCmpN = thismodule.StrCmpNA;
        pub const StrCmpNI = thismodule.StrCmpNIA;
        pub const StrCSpn = thismodule.StrCSpnA;
        pub const StrCSpnI = thismodule.StrCSpnIA;
        pub const StrDup = thismodule.StrDupA;
        pub const StrFormatByteSize = thismodule.StrFormatByteSizeA;
        pub const StrFormatKBSize = thismodule.StrFormatKBSizeA;
        pub const StrFromTimeInterval = thismodule.StrFromTimeIntervalA;
        pub const StrIsIntlEqual = thismodule.StrIsIntlEqualA;
        pub const StrNCat = thismodule.StrNCatA;
        pub const StrPBrk = thismodule.StrPBrkA;
        pub const StrRChr = thismodule.StrRChrA;
        pub const StrRChrI = thismodule.StrRChrIA;
        pub const StrRStrI = thismodule.StrRStrIA;
        pub const StrSpn = thismodule.StrSpnA;
        pub const StrStr = thismodule.StrStrA;
        pub const StrStrI = thismodule.StrStrIA;
        pub const StrToInt = thismodule.StrToIntA;
        pub const StrToIntEx = thismodule.StrToIntExA;
        pub const StrToInt64Ex = thismodule.StrToInt64ExA;
        pub const StrTrim = thismodule.StrTrimA;
        pub const StrCatBuff = thismodule.StrCatBuffA;
        pub const ChrCmpI = thismodule.ChrCmpIA;
        pub const wvnsprintf = thismodule.wvnsprintfA;
        pub const wnsprintf = thismodule.wnsprintfA;
        pub const StrRetToStr = thismodule.StrRetToStrA;
        pub const StrRetToBuf = thismodule.StrRetToBufA;
        pub const SHStrDup = thismodule.SHStrDupA;
        pub const IsCharSpace = thismodule.IsCharSpaceA;
        pub const StrCmpC = thismodule.StrCmpCA;
        pub const StrCmpIC = thismodule.StrCmpICA;
        pub const StrCmpNC = thismodule.StrCmpNCA;
        pub const StrCmpNIC = thismodule.StrCmpNICA;
        pub const IntlStrEqWorker = thismodule.IntlStrEqWorkerA;
        pub const PathAddBackslash = thismodule.PathAddBackslashA;
        pub const PathAddExtension = thismodule.PathAddExtensionA;
        pub const PathAppend = thismodule.PathAppendA;
        pub const PathBuildRoot = thismodule.PathBuildRootA;
        pub const PathCanonicalize = thismodule.PathCanonicalizeA;
        pub const PathCombine = thismodule.PathCombineA;
        pub const PathCompactPath = thismodule.PathCompactPathA;
        pub const PathCompactPathEx = thismodule.PathCompactPathExA;
        pub const PathCommonPrefix = thismodule.PathCommonPrefixA;
        pub const PathFileExists = thismodule.PathFileExistsA;
        pub const PathFindExtension = thismodule.PathFindExtensionA;
        pub const PathFindFileName = thismodule.PathFindFileNameA;
        pub const PathFindNextComponent = thismodule.PathFindNextComponentA;
        pub const PathFindOnPath = thismodule.PathFindOnPathA;
        pub const PathFindSuffixArray = thismodule.PathFindSuffixArrayA;
        pub const PathGetArgs = thismodule.PathGetArgsA;
        pub const PathIsLFNFileSpec = thismodule.PathIsLFNFileSpecA;
        pub const PathGetCharType = thismodule.PathGetCharTypeA;
        pub const PathGetDriveNumber = thismodule.PathGetDriveNumberA;
        pub const PathIsDirectory = thismodule.PathIsDirectoryA;
        pub const PathIsDirectoryEmpty = thismodule.PathIsDirectoryEmptyA;
        pub const PathIsFileSpec = thismodule.PathIsFileSpecA;
        pub const PathIsPrefix = thismodule.PathIsPrefixA;
        pub const PathIsRelative = thismodule.PathIsRelativeA;
        pub const PathIsRoot = thismodule.PathIsRootA;
        pub const PathIsSameRoot = thismodule.PathIsSameRootA;
        pub const PathIsUNC = thismodule.PathIsUNCA;
        pub const PathIsNetworkPath = thismodule.PathIsNetworkPathA;
        pub const PathIsUNCServer = thismodule.PathIsUNCServerA;
        pub const PathIsUNCServerShare = thismodule.PathIsUNCServerShareA;
        pub const PathIsContentType = thismodule.PathIsContentTypeA;
        pub const PathIsURL = thismodule.PathIsURLA;
        pub const PathMakePretty = thismodule.PathMakePrettyA;
        pub const PathMatchSpec = thismodule.PathMatchSpecA;
        pub const PathMatchSpecEx = thismodule.PathMatchSpecExA;
        pub const PathParseIconLocation = thismodule.PathParseIconLocationA;
        pub const PathQuoteSpaces = thismodule.PathQuoteSpacesA;
        pub const PathRelativePathTo = thismodule.PathRelativePathToA;
        pub const PathRemoveArgs = thismodule.PathRemoveArgsA;
        pub const PathRemoveBackslash = thismodule.PathRemoveBackslashA;
        pub const PathRemoveBlanks = thismodule.PathRemoveBlanksA;
        pub const PathRemoveExtension = thismodule.PathRemoveExtensionA;
        pub const PathRemoveFileSpec = thismodule.PathRemoveFileSpecA;
        pub const PathRenameExtension = thismodule.PathRenameExtensionA;
        pub const PathSearchAndQualify = thismodule.PathSearchAndQualifyA;
        pub const PathSetDlgItemPath = thismodule.PathSetDlgItemPathA;
        pub const PathSkipRoot = thismodule.PathSkipRootA;
        pub const PathStripPath = thismodule.PathStripPathA;
        pub const PathStripToRoot = thismodule.PathStripToRootA;
        pub const PathUnquoteSpaces = thismodule.PathUnquoteSpacesA;
        pub const PathMakeSystemFolder = thismodule.PathMakeSystemFolderA;
        pub const PathUnmakeSystemFolder = thismodule.PathUnmakeSystemFolderA;
        pub const PathIsSystemFolder = thismodule.PathIsSystemFolderA;
        pub const PathUndecorate = thismodule.PathUndecorateA;
        pub const PathUnExpandEnvStrings = thismodule.PathUnExpandEnvStringsA;
        pub const UrlCompare = thismodule.UrlCompareA;
        pub const UrlCombine = thismodule.UrlCombineA;
        pub const UrlCanonicalize = thismodule.UrlCanonicalizeA;
        pub const UrlIsOpaque = thismodule.UrlIsOpaqueA;
        pub const UrlIsNoHistory = thismodule.UrlIsNoHistoryA;
        pub const UrlIs = thismodule.UrlIsA;
        pub const UrlGetLocation = thismodule.UrlGetLocationA;
        pub const UrlUnescape = thismodule.UrlUnescapeA;
        pub const UrlEscape = thismodule.UrlEscapeA;
        pub const UrlCreateFromPath = thismodule.UrlCreateFromPathA;
        pub const PathCreateFromUrl = thismodule.PathCreateFromUrlA;
        pub const UrlHash = thismodule.UrlHashA;
        pub const UrlGetPart = thismodule.UrlGetPartA;
        pub const UrlApplyScheme = thismodule.UrlApplySchemeA;
        pub const ParseURL = thismodule.ParseURLA;
        pub const SHDeleteEmptyKey = thismodule.SHDeleteEmptyKeyA;
        pub const SHDeleteKey = thismodule.SHDeleteKeyA;
        pub const SHDeleteValue = thismodule.SHDeleteValueA;
        pub const SHGetValue = thismodule.SHGetValueA;
        pub const SHSetValue = thismodule.SHSetValueA;
        pub const SHRegGetValue = thismodule.SHRegGetValueA;
        pub const SHQueryValueEx = thismodule.SHQueryValueExA;
        pub const SHEnumKeyEx = thismodule.SHEnumKeyExA;
        pub const SHEnumValue = thismodule.SHEnumValueA;
        pub const SHQueryInfoKey = thismodule.SHQueryInfoKeyA;
        pub const SHCopyKey = thismodule.SHCopyKeyA;
        pub const SHRegGetPath = thismodule.SHRegGetPathA;
        pub const SHRegSetPath = thismodule.SHRegSetPathA;
        pub const SHRegCreateUSKey = thismodule.SHRegCreateUSKeyA;
        pub const SHRegOpenUSKey = thismodule.SHRegOpenUSKeyA;
        pub const SHRegQueryUSValue = thismodule.SHRegQueryUSValueA;
        pub const SHRegWriteUSValue = thismodule.SHRegWriteUSValueA;
        pub const SHRegDeleteUSValue = thismodule.SHRegDeleteUSValueA;
        pub const SHRegDeleteEmptyUSKey = thismodule.SHRegDeleteEmptyUSKeyA;
        pub const SHRegEnumUSKey = thismodule.SHRegEnumUSKeyA;
        pub const SHRegEnumUSValue = thismodule.SHRegEnumUSValueA;
        pub const SHRegQueryInfoUSKey = thismodule.SHRegQueryInfoUSKeyA;
        pub const SHRegGetUSValue = thismodule.SHRegGetUSValueA;
        pub const SHRegSetUSValue = thismodule.SHRegSetUSValueA;
        pub const SHRegGetBoolUSValue = thismodule.SHRegGetBoolUSValueA;
        pub const AssocQueryString = thismodule.AssocQueryStringA;
        pub const AssocQueryStringByKey = thismodule.AssocQueryStringByKeyA;
        pub const AssocQueryKey = thismodule.AssocQueryKeyA;
        pub const SHOpenRegStream = thismodule.SHOpenRegStreamA;
        pub const SHOpenRegStream2 = thismodule.SHOpenRegStream2A;
        pub const SHCreateStreamOnFile = thismodule.SHCreateStreamOnFileA;
        pub const GetAcceptLanguages = thismodule.GetAcceptLanguagesA;
        pub const SHFormatDateTime = thismodule.SHFormatDateTimeA;
        pub const SHMessageBoxCheck = thismodule.SHMessageBoxCheckA;
        pub const SHSendMessageBroadcast = thismodule.SHSendMessageBroadcastA;
        pub const SHStripMneumonic = thismodule.SHStripMneumonicA;
    },
    .wide => struct {
        pub const MULTIKEYHELP = thismodule.MULTIKEYHELPW;
        pub const HELPWININFO = thismodule.HELPWININFOW;
        pub const IShellLink = thismodule.IShellLinkW;
        pub const IExtractIcon = thismodule.IExtractIconW;
        pub const BROWSEINFO = thismodule.BROWSEINFOW;
        pub const FILEDESCRIPTOR = thismodule.FILEDESCRIPTORW;
        pub const FILEGROUPDESCRIPTOR = thismodule.FILEGROUPDESCRIPTORW;
        pub const SHELLSTATE = thismodule.SHELLSTATEW;
        pub const INewShortcutHook = thismodule.INewShortcutHookW;
        pub const ICopyHook = thismodule.ICopyHookW;
        pub const DRAGINFO = thismodule.DRAGINFOW;
        pub const SHFILEOPSTRUCT = thismodule.SHFILEOPSTRUCTW;
        pub const SHNAMEMAPPING = thismodule.SHNAMEMAPPINGW;
        pub const SHELLEXECUTEINFO = thismodule.SHELLEXECUTEINFOW;
        pub const NOTIFYICONDATA = thismodule.NOTIFYICONDATAW;
        pub const SHFILEINFO = thismodule.SHFILEINFOW;
        pub const OPEN_PRINTER_PROPS_INFO = thismodule.OPEN_PRINTER_PROPS_INFOW;
        pub const PARSEDURL = thismodule.PARSEDURLW;
        pub const NEWCPLINFO = thismodule.NEWCPLINFOW;
        pub const PROFILEINFO = thismodule.PROFILEINFOW;
        pub const urlinvokecommandinfo = thismodule.urlinvokecommandinfoW;
        pub const IUniformResourceLocator = thismodule.IUniformResourceLocatorW;
        pub const LoadUserProfile = thismodule.LoadUserProfileW;
        pub const GetProfilesDirectory = thismodule.GetProfilesDirectoryW;
        pub const DeleteProfile = thismodule.DeleteProfileW;
        pub const GetDefaultUserProfileDirectory = thismodule.GetDefaultUserProfileDirectoryW;
        pub const GetAllUsersProfileDirectory = thismodule.GetAllUsersProfileDirectoryW;
        pub const GetUserProfileDirectory = thismodule.GetUserProfileDirectoryW;
        pub const WinHelp = thismodule.WinHelpW;
        pub const SHGetIconOverlayIndex = thismodule.SHGetIconOverlayIndexW;
        pub const ILCreateFromPath = thismodule.ILCreateFromPathW;
        pub const SHGetPathFromIDList = thismodule.SHGetPathFromIDListW;
        pub const SHCreateDirectoryEx = thismodule.SHCreateDirectoryExW;
        pub const SHGetSpecialFolderPath = thismodule.SHGetSpecialFolderPathW;
        pub const SHGetFolderPath = thismodule.SHGetFolderPathW;
        pub const SHSetFolderPath = thismodule.SHSetFolderPathW;
        pub const SHGetFolderPathAndSubDir = thismodule.SHGetFolderPathAndSubDirW;
        pub const SHBrowseForFolder = thismodule.SHBrowseForFolderW;
        pub const SHUpdateImage = thismodule.SHUpdateImageW;
        pub const SHGetDataFromIDList = thismodule.SHGetDataFromIDListW;
        pub const SHDefExtractIcon = thismodule.SHDefExtractIconW;
        pub const SHPathPrepareForWrite = thismodule.SHPathPrepareForWriteW;
        pub const PathIsSlow = thismodule.PathIsSlowW;
        pub const DragQueryFile = thismodule.DragQueryFileW;
        pub const ShellExecute = thismodule.ShellExecuteW;
        pub const FindExecutable = thismodule.FindExecutableW;
        pub const ShellAbout = thismodule.ShellAboutW;
        pub const ExtractAssociatedIcon = thismodule.ExtractAssociatedIconW;
        pub const ExtractAssociatedIconEx = thismodule.ExtractAssociatedIconExW;
        pub const ExtractIcon = thismodule.ExtractIconW;
        pub const DoEnvironmentSubst = thismodule.DoEnvironmentSubstW;
        pub const ExtractIconEx = thismodule.ExtractIconExW;
        pub const SHFileOperation = thismodule.SHFileOperationW;
        pub const ShellExecuteEx = thismodule.ShellExecuteExW;
        pub const SHQueryRecycleBin = thismodule.SHQueryRecycleBinW;
        pub const SHEmptyRecycleBin = thismodule.SHEmptyRecycleBinW;
        pub const Shell_NotifyIcon = thismodule.Shell_NotifyIconW;
        pub const SHGetFileInfo = thismodule.SHGetFileInfoW;
        pub const SHGetDiskFreeSpaceEx = thismodule.SHGetDiskFreeSpaceExW;
        pub const SHGetNewLinkInfo = thismodule.SHGetNewLinkInfoW;
        pub const SHInvokePrinterCommand = thismodule.SHInvokePrinterCommandW;
        pub const ShellMessageBox = thismodule.ShellMessageBoxW;
        pub const IsLFNDrive = thismodule.IsLFNDriveW;
        pub const StrChr = thismodule.StrChrW;
        pub const StrChrI = thismodule.StrChrIW;
        pub const StrCmpN = thismodule.StrCmpNW;
        pub const StrCmpNI = thismodule.StrCmpNIW;
        pub const StrCSpn = thismodule.StrCSpnW;
        pub const StrCSpnI = thismodule.StrCSpnIW;
        pub const StrDup = thismodule.StrDupW;
        pub const StrFormatByteSize = thismodule.StrFormatByteSizeW;
        pub const StrFormatKBSize = thismodule.StrFormatKBSizeW;
        pub const StrFromTimeInterval = thismodule.StrFromTimeIntervalW;
        pub const StrIsIntlEqual = thismodule.StrIsIntlEqualW;
        pub const StrNCat = thismodule.StrNCatW;
        pub const StrPBrk = thismodule.StrPBrkW;
        pub const StrRChr = thismodule.StrRChrW;
        pub const StrRChrI = thismodule.StrRChrIW;
        pub const StrRStrI = thismodule.StrRStrIW;
        pub const StrSpn = thismodule.StrSpnW;
        pub const StrStr = thismodule.StrStrW;
        pub const StrStrI = thismodule.StrStrIW;
        pub const StrToInt = thismodule.StrToIntW;
        pub const StrToIntEx = thismodule.StrToIntExW;
        pub const StrToInt64Ex = thismodule.StrToInt64ExW;
        pub const StrTrim = thismodule.StrTrimW;
        pub const StrCatBuff = thismodule.StrCatBuffW;
        pub const ChrCmpI = thismodule.ChrCmpIW;
        pub const wvnsprintf = thismodule.wvnsprintfW;
        pub const wnsprintf = thismodule.wnsprintfW;
        pub const StrRetToStr = thismodule.StrRetToStrW;
        pub const StrRetToBuf = thismodule.StrRetToBufW;
        pub const SHStrDup = thismodule.SHStrDupW;
        pub const IsCharSpace = thismodule.IsCharSpaceW;
        pub const StrCmpC = thismodule.StrCmpCW;
        pub const StrCmpIC = thismodule.StrCmpICW;
        pub const StrCmpNC = thismodule.StrCmpNCW;
        pub const StrCmpNIC = thismodule.StrCmpNICW;
        pub const IntlStrEqWorker = thismodule.IntlStrEqWorkerW;
        pub const PathAddBackslash = thismodule.PathAddBackslashW;
        pub const PathAddExtension = thismodule.PathAddExtensionW;
        pub const PathAppend = thismodule.PathAppendW;
        pub const PathBuildRoot = thismodule.PathBuildRootW;
        pub const PathCanonicalize = thismodule.PathCanonicalizeW;
        pub const PathCombine = thismodule.PathCombineW;
        pub const PathCompactPath = thismodule.PathCompactPathW;
        pub const PathCompactPathEx = thismodule.PathCompactPathExW;
        pub const PathCommonPrefix = thismodule.PathCommonPrefixW;
        pub const PathFileExists = thismodule.PathFileExistsW;
        pub const PathFindExtension = thismodule.PathFindExtensionW;
        pub const PathFindFileName = thismodule.PathFindFileNameW;
        pub const PathFindNextComponent = thismodule.PathFindNextComponentW;
        pub const PathFindOnPath = thismodule.PathFindOnPathW;
        pub const PathFindSuffixArray = thismodule.PathFindSuffixArrayW;
        pub const PathGetArgs = thismodule.PathGetArgsW;
        pub const PathIsLFNFileSpec = thismodule.PathIsLFNFileSpecW;
        pub const PathGetCharType = thismodule.PathGetCharTypeW;
        pub const PathGetDriveNumber = thismodule.PathGetDriveNumberW;
        pub const PathIsDirectory = thismodule.PathIsDirectoryW;
        pub const PathIsDirectoryEmpty = thismodule.PathIsDirectoryEmptyW;
        pub const PathIsFileSpec = thismodule.PathIsFileSpecW;
        pub const PathIsPrefix = thismodule.PathIsPrefixW;
        pub const PathIsRelative = thismodule.PathIsRelativeW;
        pub const PathIsRoot = thismodule.PathIsRootW;
        pub const PathIsSameRoot = thismodule.PathIsSameRootW;
        pub const PathIsUNC = thismodule.PathIsUNCW;
        pub const PathIsNetworkPath = thismodule.PathIsNetworkPathW;
        pub const PathIsUNCServer = thismodule.PathIsUNCServerW;
        pub const PathIsUNCServerShare = thismodule.PathIsUNCServerShareW;
        pub const PathIsContentType = thismodule.PathIsContentTypeW;
        pub const PathIsURL = thismodule.PathIsURLW;
        pub const PathMakePretty = thismodule.PathMakePrettyW;
        pub const PathMatchSpec = thismodule.PathMatchSpecW;
        pub const PathMatchSpecEx = thismodule.PathMatchSpecExW;
        pub const PathParseIconLocation = thismodule.PathParseIconLocationW;
        pub const PathQuoteSpaces = thismodule.PathQuoteSpacesW;
        pub const PathRelativePathTo = thismodule.PathRelativePathToW;
        pub const PathRemoveArgs = thismodule.PathRemoveArgsW;
        pub const PathRemoveBackslash = thismodule.PathRemoveBackslashW;
        pub const PathRemoveBlanks = thismodule.PathRemoveBlanksW;
        pub const PathRemoveExtension = thismodule.PathRemoveExtensionW;
        pub const PathRemoveFileSpec = thismodule.PathRemoveFileSpecW;
        pub const PathRenameExtension = thismodule.PathRenameExtensionW;
        pub const PathSearchAndQualify = thismodule.PathSearchAndQualifyW;
        pub const PathSetDlgItemPath = thismodule.PathSetDlgItemPathW;
        pub const PathSkipRoot = thismodule.PathSkipRootW;
        pub const PathStripPath = thismodule.PathStripPathW;
        pub const PathStripToRoot = thismodule.PathStripToRootW;
        pub const PathUnquoteSpaces = thismodule.PathUnquoteSpacesW;
        pub const PathMakeSystemFolder = thismodule.PathMakeSystemFolderW;
        pub const PathUnmakeSystemFolder = thismodule.PathUnmakeSystemFolderW;
        pub const PathIsSystemFolder = thismodule.PathIsSystemFolderW;
        pub const PathUndecorate = thismodule.PathUndecorateW;
        pub const PathUnExpandEnvStrings = thismodule.PathUnExpandEnvStringsW;
        pub const UrlCompare = thismodule.UrlCompareW;
        pub const UrlCombine = thismodule.UrlCombineW;
        pub const UrlCanonicalize = thismodule.UrlCanonicalizeW;
        pub const UrlIsOpaque = thismodule.UrlIsOpaqueW;
        pub const UrlIsNoHistory = thismodule.UrlIsNoHistoryW;
        pub const UrlIs = thismodule.UrlIsW;
        pub const UrlGetLocation = thismodule.UrlGetLocationW;
        pub const UrlUnescape = thismodule.UrlUnescapeW;
        pub const UrlEscape = thismodule.UrlEscapeW;
        pub const UrlCreateFromPath = thismodule.UrlCreateFromPathW;
        pub const PathCreateFromUrl = thismodule.PathCreateFromUrlW;
        pub const UrlHash = thismodule.UrlHashW;
        pub const UrlGetPart = thismodule.UrlGetPartW;
        pub const UrlApplyScheme = thismodule.UrlApplySchemeW;
        pub const ParseURL = thismodule.ParseURLW;
        pub const SHDeleteEmptyKey = thismodule.SHDeleteEmptyKeyW;
        pub const SHDeleteKey = thismodule.SHDeleteKeyW;
        pub const SHDeleteValue = thismodule.SHDeleteValueW;
        pub const SHGetValue = thismodule.SHGetValueW;
        pub const SHSetValue = thismodule.SHSetValueW;
        pub const SHRegGetValue = thismodule.SHRegGetValueW;
        pub const SHQueryValueEx = thismodule.SHQueryValueExW;
        pub const SHEnumKeyEx = thismodule.SHEnumKeyExW;
        pub const SHEnumValue = thismodule.SHEnumValueW;
        pub const SHQueryInfoKey = thismodule.SHQueryInfoKeyW;
        pub const SHCopyKey = thismodule.SHCopyKeyW;
        pub const SHRegGetPath = thismodule.SHRegGetPathW;
        pub const SHRegSetPath = thismodule.SHRegSetPathW;
        pub const SHRegCreateUSKey = thismodule.SHRegCreateUSKeyW;
        pub const SHRegOpenUSKey = thismodule.SHRegOpenUSKeyW;
        pub const SHRegQueryUSValue = thismodule.SHRegQueryUSValueW;
        pub const SHRegWriteUSValue = thismodule.SHRegWriteUSValueW;
        pub const SHRegDeleteUSValue = thismodule.SHRegDeleteUSValueW;
        pub const SHRegDeleteEmptyUSKey = thismodule.SHRegDeleteEmptyUSKeyW;
        pub const SHRegEnumUSKey = thismodule.SHRegEnumUSKeyW;
        pub const SHRegEnumUSValue = thismodule.SHRegEnumUSValueW;
        pub const SHRegQueryInfoUSKey = thismodule.SHRegQueryInfoUSKeyW;
        pub const SHRegGetUSValue = thismodule.SHRegGetUSValueW;
        pub const SHRegSetUSValue = thismodule.SHRegSetUSValueW;
        pub const SHRegGetBoolUSValue = thismodule.SHRegGetBoolUSValueW;
        pub const AssocQueryString = thismodule.AssocQueryStringW;
        pub const AssocQueryStringByKey = thismodule.AssocQueryStringByKeyW;
        pub const AssocQueryKey = thismodule.AssocQueryKeyW;
        pub const SHOpenRegStream = thismodule.SHOpenRegStreamW;
        pub const SHOpenRegStream2 = thismodule.SHOpenRegStream2W;
        pub const SHCreateStreamOnFile = thismodule.SHCreateStreamOnFileW;
        pub const GetAcceptLanguages = thismodule.GetAcceptLanguagesW;
        pub const SHFormatDateTime = thismodule.SHFormatDateTimeW;
        pub const SHMessageBoxCheck = thismodule.SHMessageBoxCheckW;
        pub const SHSendMessageBroadcast = thismodule.SHSendMessageBroadcastW;
        pub const SHStripMneumonic = thismodule.SHStripMneumonicW;
    },
    .unspecified => if (@import("builtin").is_test) struct {
        pub const MULTIKEYHELP = *opaque {};
        pub const HELPWININFO = *opaque {};
        pub const IShellLink = *opaque {};
        pub const IExtractIcon = *opaque {};
        pub const BROWSEINFO = *opaque {};
        pub const FILEDESCRIPTOR = *opaque {};
        pub const FILEGROUPDESCRIPTOR = *opaque {};
        pub const SHELLSTATE = *opaque {};
        pub const INewShortcutHook = *opaque {};
        pub const ICopyHook = *opaque {};
        pub const DRAGINFO = *opaque {};
        pub const SHFILEOPSTRUCT = *opaque {};
        pub const SHNAMEMAPPING = *opaque {};
        pub const SHELLEXECUTEINFO = *opaque {};
        pub const NOTIFYICONDATA = *opaque {};
        pub const SHFILEINFO = *opaque {};
        pub const OPEN_PRINTER_PROPS_INFO = *opaque {};
        pub const PARSEDURL = *opaque {};
        pub const NEWCPLINFO = *opaque {};
        pub const PROFILEINFO = *opaque {};
        pub const urlinvokecommandinfo = *opaque {};
        pub const IUniformResourceLocator = *opaque {};
        pub const LoadUserProfile = *opaque {};
        pub const GetProfilesDirectory = *opaque {};
        pub const DeleteProfile = *opaque {};
        pub const GetDefaultUserProfileDirectory = *opaque {};
        pub const GetAllUsersProfileDirectory = *opaque {};
        pub const GetUserProfileDirectory = *opaque {};
        pub const WinHelp = *opaque {};
        pub const SHGetIconOverlayIndex = *opaque {};
        pub const ILCreateFromPath = *opaque {};
        pub const SHGetPathFromIDList = *opaque {};
        pub const SHCreateDirectoryEx = *opaque {};
        pub const SHGetSpecialFolderPath = *opaque {};
        pub const SHGetFolderPath = *opaque {};
        pub const SHSetFolderPath = *opaque {};
        pub const SHGetFolderPathAndSubDir = *opaque {};
        pub const SHBrowseForFolder = *opaque {};
        pub const SHUpdateImage = *opaque {};
        pub const SHGetDataFromIDList = *opaque {};
        pub const SHDefExtractIcon = *opaque {};
        pub const SHPathPrepareForWrite = *opaque {};
        pub const PathIsSlow = *opaque {};
        pub const DragQueryFile = *opaque {};
        pub const ShellExecute = *opaque {};
        pub const FindExecutable = *opaque {};
        pub const ShellAbout = *opaque {};
        pub const ExtractAssociatedIcon = *opaque {};
        pub const ExtractAssociatedIconEx = *opaque {};
        pub const ExtractIcon = *opaque {};
        pub const DoEnvironmentSubst = *opaque {};
        pub const ExtractIconEx = *opaque {};
        pub const SHFileOperation = *opaque {};
        pub const ShellExecuteEx = *opaque {};
        pub const SHQueryRecycleBin = *opaque {};
        pub const SHEmptyRecycleBin = *opaque {};
        pub const Shell_NotifyIcon = *opaque {};
        pub const SHGetFileInfo = *opaque {};
        pub const SHGetDiskFreeSpaceEx = *opaque {};
        pub const SHGetNewLinkInfo = *opaque {};
        pub const SHInvokePrinterCommand = *opaque {};
        pub const ShellMessageBox = *opaque {};
        pub const IsLFNDrive = *opaque {};
        pub const StrChr = *opaque {};
        pub const StrChrI = *opaque {};
        pub const StrCmpN = *opaque {};
        pub const StrCmpNI = *opaque {};
        pub const StrCSpn = *opaque {};
        pub const StrCSpnI = *opaque {};
        pub const StrDup = *opaque {};
        pub const StrFormatByteSize = *opaque {};
        pub const StrFormatKBSize = *opaque {};
        pub const StrFromTimeInterval = *opaque {};
        pub const StrIsIntlEqual = *opaque {};
        pub const StrNCat = *opaque {};
        pub const StrPBrk = *opaque {};
        pub const StrRChr = *opaque {};
        pub const StrRChrI = *opaque {};
        pub const StrRStrI = *opaque {};
        pub const StrSpn = *opaque {};
        pub const StrStr = *opaque {};
        pub const StrStrI = *opaque {};
        pub const StrToInt = *opaque {};
        pub const StrToIntEx = *opaque {};
        pub const StrToInt64Ex = *opaque {};
        pub const StrTrim = *opaque {};
        pub const StrCatBuff = *opaque {};
        pub const ChrCmpI = *opaque {};
        pub const wvnsprintf = *opaque {};
        pub const wnsprintf = *opaque {};
        pub const StrRetToStr = *opaque {};
        pub const StrRetToBuf = *opaque {};
        pub const SHStrDup = *opaque {};
        pub const IsCharSpace = *opaque {};
        pub const StrCmpC = *opaque {};
        pub const StrCmpIC = *opaque {};
        pub const StrCmpNC = *opaque {};
        pub const StrCmpNIC = *opaque {};
        pub const IntlStrEqWorker = *opaque {};
        pub const PathAddBackslash = *opaque {};
        pub const PathAddExtension = *opaque {};
        pub const PathAppend = *opaque {};
        pub const PathBuildRoot = *opaque {};
        pub const PathCanonicalize = *opaque {};
        pub const PathCombine = *opaque {};
        pub const PathCompactPath = *opaque {};
        pub const PathCompactPathEx = *opaque {};
        pub const PathCommonPrefix = *opaque {};
        pub const PathFileExists = *opaque {};
        pub const PathFindExtension = *opaque {};
        pub const PathFindFileName = *opaque {};
        pub const PathFindNextComponent = *opaque {};
        pub const PathFindOnPath = *opaque {};
        pub const PathFindSuffixArray = *opaque {};
        pub const PathGetArgs = *opaque {};
        pub const PathIsLFNFileSpec = *opaque {};
        pub const PathGetCharType = *opaque {};
        pub const PathGetDriveNumber = *opaque {};
        pub const PathIsDirectory = *opaque {};
        pub const PathIsDirectoryEmpty = *opaque {};
        pub const PathIsFileSpec = *opaque {};
        pub const PathIsPrefix = *opaque {};
        pub const PathIsRelative = *opaque {};
        pub const PathIsRoot = *opaque {};
        pub const PathIsSameRoot = *opaque {};
        pub const PathIsUNC = *opaque {};
        pub const PathIsNetworkPath = *opaque {};
        pub const PathIsUNCServer = *opaque {};
        pub const PathIsUNCServerShare = *opaque {};
        pub const PathIsContentType = *opaque {};
        pub const PathIsURL = *opaque {};
        pub const PathMakePretty = *opaque {};
        pub const PathMatchSpec = *opaque {};
        pub const PathMatchSpecEx = *opaque {};
        pub const PathParseIconLocation = *opaque {};
        pub const PathQuoteSpaces = *opaque {};
        pub const PathRelativePathTo = *opaque {};
        pub const PathRemoveArgs = *opaque {};
        pub const PathRemoveBackslash = *opaque {};
        pub const PathRemoveBlanks = *opaque {};
        pub const PathRemoveExtension = *opaque {};
        pub const PathRemoveFileSpec = *opaque {};
        pub const PathRenameExtension = *opaque {};
        pub const PathSearchAndQualify = *opaque {};
        pub const PathSetDlgItemPath = *opaque {};
        pub const PathSkipRoot = *opaque {};
        pub const PathStripPath = *opaque {};
        pub const PathStripToRoot = *opaque {};
        pub const PathUnquoteSpaces = *opaque {};
        pub const PathMakeSystemFolder = *opaque {};
        pub const PathUnmakeSystemFolder = *opaque {};
        pub const PathIsSystemFolder = *opaque {};
        pub const PathUndecorate = *opaque {};
        pub const PathUnExpandEnvStrings = *opaque {};
        pub const UrlCompare = *opaque {};
        pub const UrlCombine = *opaque {};
        pub const UrlCanonicalize = *opaque {};
        pub const UrlIsOpaque = *opaque {};
        pub const UrlIsNoHistory = *opaque {};
        pub const UrlIs = *opaque {};
        pub const UrlGetLocation = *opaque {};
        pub const UrlUnescape = *opaque {};
        pub const UrlEscape = *opaque {};
        pub const UrlCreateFromPath = *opaque {};
        pub const PathCreateFromUrl = *opaque {};
        pub const UrlHash = *opaque {};
        pub const UrlGetPart = *opaque {};
        pub const UrlApplyScheme = *opaque {};
        pub const ParseURL = *opaque {};
        pub const SHDeleteEmptyKey = *opaque {};
        pub const SHDeleteKey = *opaque {};
        pub const SHDeleteValue = *opaque {};
        pub const SHGetValue = *opaque {};
        pub const SHSetValue = *opaque {};
        pub const SHRegGetValue = *opaque {};
        pub const SHQueryValueEx = *opaque {};
        pub const SHEnumKeyEx = *opaque {};
        pub const SHEnumValue = *opaque {};
        pub const SHQueryInfoKey = *opaque {};
        pub const SHCopyKey = *opaque {};
        pub const SHRegGetPath = *opaque {};
        pub const SHRegSetPath = *opaque {};
        pub const SHRegCreateUSKey = *opaque {};
        pub const SHRegOpenUSKey = *opaque {};
        pub const SHRegQueryUSValue = *opaque {};
        pub const SHRegWriteUSValue = *opaque {};
        pub const SHRegDeleteUSValue = *opaque {};
        pub const SHRegDeleteEmptyUSKey = *opaque {};
        pub const SHRegEnumUSKey = *opaque {};
        pub const SHRegEnumUSValue = *opaque {};
        pub const SHRegQueryInfoUSKey = *opaque {};
        pub const SHRegGetUSValue = *opaque {};
        pub const SHRegSetUSValue = *opaque {};
        pub const SHRegGetBoolUSValue = *opaque {};
        pub const AssocQueryString = *opaque {};
        pub const AssocQueryStringByKey = *opaque {};
        pub const AssocQueryKey = *opaque {};
        pub const SHOpenRegStream = *opaque {};
        pub const SHOpenRegStream2 = *opaque {};
        pub const SHCreateStreamOnFile = *opaque {};
        pub const GetAcceptLanguages = *opaque {};
        pub const SHFormatDateTime = *opaque {};
        pub const SHMessageBoxCheck = *opaque {};
        pub const SHSendMessageBroadcast = *opaque {};
        pub const SHStripMneumonic = *opaque {};
    } else struct {
        pub const MULTIKEYHELP = @compileError("'MULTIKEYHELP' requires that UNICODE be set to true or false in the root module");
        pub const HELPWININFO = @compileError("'HELPWININFO' requires that UNICODE be set to true or false in the root module");
        pub const IShellLink = @compileError("'IShellLink' requires that UNICODE be set to true or false in the root module");
        pub const IExtractIcon = @compileError("'IExtractIcon' requires that UNICODE be set to true or false in the root module");
        pub const BROWSEINFO = @compileError("'BROWSEINFO' requires that UNICODE be set to true or false in the root module");
        pub const FILEDESCRIPTOR = @compileError("'FILEDESCRIPTOR' requires that UNICODE be set to true or false in the root module");
        pub const FILEGROUPDESCRIPTOR = @compileError("'FILEGROUPDESCRIPTOR' requires that UNICODE be set to true or false in the root module");
        pub const SHELLSTATE = @compileError("'SHELLSTATE' requires that UNICODE be set to true or false in the root module");
        pub const INewShortcutHook = @compileError("'INewShortcutHook' requires that UNICODE be set to true or false in the root module");
        pub const ICopyHook = @compileError("'ICopyHook' requires that UNICODE be set to true or false in the root module");
        pub const DRAGINFO = @compileError("'DRAGINFO' requires that UNICODE be set to true or false in the root module");
        pub const SHFILEOPSTRUCT = @compileError("'SHFILEOPSTRUCT' requires that UNICODE be set to true or false in the root module");
        pub const SHNAMEMAPPING = @compileError("'SHNAMEMAPPING' requires that UNICODE be set to true or false in the root module");
        pub const SHELLEXECUTEINFO = @compileError("'SHELLEXECUTEINFO' requires that UNICODE be set to true or false in the root module");
        pub const NOTIFYICONDATA = @compileError("'NOTIFYICONDATA' requires that UNICODE be set to true or false in the root module");
        pub const SHFILEINFO = @compileError("'SHFILEINFO' requires that UNICODE be set to true or false in the root module");
        pub const OPEN_PRINTER_PROPS_INFO = @compileError("'OPEN_PRINTER_PROPS_INFO' requires that UNICODE be set to true or false in the root module");
        pub const PARSEDURL = @compileError("'PARSEDURL' requires that UNICODE be set to true or false in the root module");
        pub const NEWCPLINFO = @compileError("'NEWCPLINFO' requires that UNICODE be set to true or false in the root module");
        pub const PROFILEINFO = @compileError("'PROFILEINFO' requires that UNICODE be set to true or false in the root module");
        pub const urlinvokecommandinfo = @compileError("'urlinvokecommandinfo' requires that UNICODE be set to true or false in the root module");
        pub const IUniformResourceLocator = @compileError("'IUniformResourceLocator' requires that UNICODE be set to true or false in the root module");
        pub const LoadUserProfile = @compileError("'LoadUserProfile' requires that UNICODE be set to true or false in the root module");
        pub const GetProfilesDirectory = @compileError("'GetProfilesDirectory' requires that UNICODE be set to true or false in the root module");
        pub const DeleteProfile = @compileError("'DeleteProfile' requires that UNICODE be set to true or false in the root module");
        pub const GetDefaultUserProfileDirectory = @compileError("'GetDefaultUserProfileDirectory' requires that UNICODE be set to true or false in the root module");
        pub const GetAllUsersProfileDirectory = @compileError("'GetAllUsersProfileDirectory' requires that UNICODE be set to true or false in the root module");
        pub const GetUserProfileDirectory = @compileError("'GetUserProfileDirectory' requires that UNICODE be set to true or false in the root module");
        pub const WinHelp = @compileError("'WinHelp' requires that UNICODE be set to true or false in the root module");
        pub const SHGetIconOverlayIndex = @compileError("'SHGetIconOverlayIndex' requires that UNICODE be set to true or false in the root module");
        pub const ILCreateFromPath = @compileError("'ILCreateFromPath' requires that UNICODE be set to true or false in the root module");
        pub const SHGetPathFromIDList = @compileError("'SHGetPathFromIDList' requires that UNICODE be set to true or false in the root module");
        pub const SHCreateDirectoryEx = @compileError("'SHCreateDirectoryEx' requires that UNICODE be set to true or false in the root module");
        pub const SHGetSpecialFolderPath = @compileError("'SHGetSpecialFolderPath' requires that UNICODE be set to true or false in the root module");
        pub const SHGetFolderPath = @compileError("'SHGetFolderPath' requires that UNICODE be set to true or false in the root module");
        pub const SHSetFolderPath = @compileError("'SHSetFolderPath' requires that UNICODE be set to true or false in the root module");
        pub const SHGetFolderPathAndSubDir = @compileError("'SHGetFolderPathAndSubDir' requires that UNICODE be set to true or false in the root module");
        pub const SHBrowseForFolder = @compileError("'SHBrowseForFolder' requires that UNICODE be set to true or false in the root module");
        pub const SHUpdateImage = @compileError("'SHUpdateImage' requires that UNICODE be set to true or false in the root module");
        pub const SHGetDataFromIDList = @compileError("'SHGetDataFromIDList' requires that UNICODE be set to true or false in the root module");
        pub const SHDefExtractIcon = @compileError("'SHDefExtractIcon' requires that UNICODE be set to true or false in the root module");
        pub const SHPathPrepareForWrite = @compileError("'SHPathPrepareForWrite' requires that UNICODE be set to true or false in the root module");
        pub const PathIsSlow = @compileError("'PathIsSlow' requires that UNICODE be set to true or false in the root module");
        pub const DragQueryFile = @compileError("'DragQueryFile' requires that UNICODE be set to true or false in the root module");
        pub const ShellExecute = @compileError("'ShellExecute' requires that UNICODE be set to true or false in the root module");
        pub const FindExecutable = @compileError("'FindExecutable' requires that UNICODE be set to true or false in the root module");
        pub const ShellAbout = @compileError("'ShellAbout' requires that UNICODE be set to true or false in the root module");
        pub const ExtractAssociatedIcon = @compileError("'ExtractAssociatedIcon' requires that UNICODE be set to true or false in the root module");
        pub const ExtractAssociatedIconEx = @compileError("'ExtractAssociatedIconEx' requires that UNICODE be set to true or false in the root module");
        pub const ExtractIcon = @compileError("'ExtractIcon' requires that UNICODE be set to true or false in the root module");
        pub const DoEnvironmentSubst = @compileError("'DoEnvironmentSubst' requires that UNICODE be set to true or false in the root module");
        pub const ExtractIconEx = @compileError("'ExtractIconEx' requires that UNICODE be set to true or false in the root module");
        pub const SHFileOperation = @compileError("'SHFileOperation' requires that UNICODE be set to true or false in the root module");
        pub const ShellExecuteEx = @compileError("'ShellExecuteEx' requires that UNICODE be set to true or false in the root module");
        pub const SHQueryRecycleBin = @compileError("'SHQueryRecycleBin' requires that UNICODE be set to true or false in the root module");
        pub const SHEmptyRecycleBin = @compileError("'SHEmptyRecycleBin' requires that UNICODE be set to true or false in the root module");
        pub const Shell_NotifyIcon = @compileError("'Shell_NotifyIcon' requires that UNICODE be set to true or false in the root module");
        pub const SHGetFileInfo = @compileError("'SHGetFileInfo' requires that UNICODE be set to true or false in the root module");
        pub const SHGetDiskFreeSpaceEx = @compileError("'SHGetDiskFreeSpaceEx' requires that UNICODE be set to true or false in the root module");
        pub const SHGetNewLinkInfo = @compileError("'SHGetNewLinkInfo' requires that UNICODE be set to true or false in the root module");
        pub const SHInvokePrinterCommand = @compileError("'SHInvokePrinterCommand' requires that UNICODE be set to true or false in the root module");
        pub const ShellMessageBox = @compileError("'ShellMessageBox' requires that UNICODE be set to true or false in the root module");
        pub const IsLFNDrive = @compileError("'IsLFNDrive' requires that UNICODE be set to true or false in the root module");
        pub const StrChr = @compileError("'StrChr' requires that UNICODE be set to true or false in the root module");
        pub const StrChrI = @compileError("'StrChrI' requires that UNICODE be set to true or false in the root module");
        pub const StrCmpN = @compileError("'StrCmpN' requires that UNICODE be set to true or false in the root module");
        pub const StrCmpNI = @compileError("'StrCmpNI' requires that UNICODE be set to true or false in the root module");
        pub const StrCSpn = @compileError("'StrCSpn' requires that UNICODE be set to true or false in the root module");
        pub const StrCSpnI = @compileError("'StrCSpnI' requires that UNICODE be set to true or false in the root module");
        pub const StrDup = @compileError("'StrDup' requires that UNICODE be set to true or false in the root module");
        pub const StrFormatByteSize = @compileError("'StrFormatByteSize' requires that UNICODE be set to true or false in the root module");
        pub const StrFormatKBSize = @compileError("'StrFormatKBSize' requires that UNICODE be set to true or false in the root module");
        pub const StrFromTimeInterval = @compileError("'StrFromTimeInterval' requires that UNICODE be set to true or false in the root module");
        pub const StrIsIntlEqual = @compileError("'StrIsIntlEqual' requires that UNICODE be set to true or false in the root module");
        pub const StrNCat = @compileError("'StrNCat' requires that UNICODE be set to true or false in the root module");
        pub const StrPBrk = @compileError("'StrPBrk' requires that UNICODE be set to true or false in the root module");
        pub const StrRChr = @compileError("'StrRChr' requires that UNICODE be set to true or false in the root module");
        pub const StrRChrI = @compileError("'StrRChrI' requires that UNICODE be set to true or false in the root module");
        pub const StrRStrI = @compileError("'StrRStrI' requires that UNICODE be set to true or false in the root module");
        pub const StrSpn = @compileError("'StrSpn' requires that UNICODE be set to true or false in the root module");
        pub const StrStr = @compileError("'StrStr' requires that UNICODE be set to true or false in the root module");
        pub const StrStrI = @compileError("'StrStrI' requires that UNICODE be set to true or false in the root module");
        pub const StrToInt = @compileError("'StrToInt' requires that UNICODE be set to true or false in the root module");
        pub const StrToIntEx = @compileError("'StrToIntEx' requires that UNICODE be set to true or false in the root module");
        pub const StrToInt64Ex = @compileError("'StrToInt64Ex' requires that UNICODE be set to true or false in the root module");
        pub const StrTrim = @compileError("'StrTrim' requires that UNICODE be set to true or false in the root module");
        pub const StrCatBuff = @compileError("'StrCatBuff' requires that UNICODE be set to true or false in the root module");
        pub const ChrCmpI = @compileError("'ChrCmpI' requires that UNICODE be set to true or false in the root module");
        pub const wvnsprintf = @compileError("'wvnsprintf' requires that UNICODE be set to true or false in the root module");
        pub const wnsprintf = @compileError("'wnsprintf' requires that UNICODE be set to true or false in the root module");
        pub const StrRetToStr = @compileError("'StrRetToStr' requires that UNICODE be set to true or false in the root module");
        pub const StrRetToBuf = @compileError("'StrRetToBuf' requires that UNICODE be set to true or false in the root module");
        pub const SHStrDup = @compileError("'SHStrDup' requires that UNICODE be set to true or false in the root module");
        pub const IsCharSpace = @compileError("'IsCharSpace' requires that UNICODE be set to true or false in the root module");
        pub const StrCmpC = @compileError("'StrCmpC' requires that UNICODE be set to true or false in the root module");
        pub const StrCmpIC = @compileError("'StrCmpIC' requires that UNICODE be set to true or false in the root module");
        pub const StrCmpNC = @compileError("'StrCmpNC' requires that UNICODE be set to true or false in the root module");
        pub const StrCmpNIC = @compileError("'StrCmpNIC' requires that UNICODE be set to true or false in the root module");
        pub const IntlStrEqWorker = @compileError("'IntlStrEqWorker' requires that UNICODE be set to true or false in the root module");
        pub const PathAddBackslash = @compileError("'PathAddBackslash' requires that UNICODE be set to true or false in the root module");
        pub const PathAddExtension = @compileError("'PathAddExtension' requires that UNICODE be set to true or false in the root module");
        pub const PathAppend = @compileError("'PathAppend' requires that UNICODE be set to true or false in the root module");
        pub const PathBuildRoot = @compileError("'PathBuildRoot' requires that UNICODE be set to true or false in the root module");
        pub const PathCanonicalize = @compileError("'PathCanonicalize' requires that UNICODE be set to true or false in the root module");
        pub const PathCombine = @compileError("'PathCombine' requires that UNICODE be set to true or false in the root module");
        pub const PathCompactPath = @compileError("'PathCompactPath' requires that UNICODE be set to true or false in the root module");
        pub const PathCompactPathEx = @compileError("'PathCompactPathEx' requires that UNICODE be set to true or false in the root module");
        pub const PathCommonPrefix = @compileError("'PathCommonPrefix' requires that UNICODE be set to true or false in the root module");
        pub const PathFileExists = @compileError("'PathFileExists' requires that UNICODE be set to true or false in the root module");
        pub const PathFindExtension = @compileError("'PathFindExtension' requires that UNICODE be set to true or false in the root module");
        pub const PathFindFileName = @compileError("'PathFindFileName' requires that UNICODE be set to true or false in the root module");
        pub const PathFindNextComponent = @compileError("'PathFindNextComponent' requires that UNICODE be set to true or false in the root module");
        pub const PathFindOnPath = @compileError("'PathFindOnPath' requires that UNICODE be set to true or false in the root module");
        pub const PathFindSuffixArray = @compileError("'PathFindSuffixArray' requires that UNICODE be set to true or false in the root module");
        pub const PathGetArgs = @compileError("'PathGetArgs' requires that UNICODE be set to true or false in the root module");
        pub const PathIsLFNFileSpec = @compileError("'PathIsLFNFileSpec' requires that UNICODE be set to true or false in the root module");
        pub const PathGetCharType = @compileError("'PathGetCharType' requires that UNICODE be set to true or false in the root module");
        pub const PathGetDriveNumber = @compileError("'PathGetDriveNumber' requires that UNICODE be set to true or false in the root module");
        pub const PathIsDirectory = @compileError("'PathIsDirectory' requires that UNICODE be set to true or false in the root module");
        pub const PathIsDirectoryEmpty = @compileError("'PathIsDirectoryEmpty' requires that UNICODE be set to true or false in the root module");
        pub const PathIsFileSpec = @compileError("'PathIsFileSpec' requires that UNICODE be set to true or false in the root module");
        pub const PathIsPrefix = @compileError("'PathIsPrefix' requires that UNICODE be set to true or false in the root module");
        pub const PathIsRelative = @compileError("'PathIsRelative' requires that UNICODE be set to true or false in the root module");
        pub const PathIsRoot = @compileError("'PathIsRoot' requires that UNICODE be set to true or false in the root module");
        pub const PathIsSameRoot = @compileError("'PathIsSameRoot' requires that UNICODE be set to true or false in the root module");
        pub const PathIsUNC = @compileError("'PathIsUNC' requires that UNICODE be set to true or false in the root module");
        pub const PathIsNetworkPath = @compileError("'PathIsNetworkPath' requires that UNICODE be set to true or false in the root module");
        pub const PathIsUNCServer = @compileError("'PathIsUNCServer' requires that UNICODE be set to true or false in the root module");
        pub const PathIsUNCServerShare = @compileError("'PathIsUNCServerShare' requires that UNICODE be set to true or false in the root module");
        pub const PathIsContentType = @compileError("'PathIsContentType' requires that UNICODE be set to true or false in the root module");
        pub const PathIsURL = @compileError("'PathIsURL' requires that UNICODE be set to true or false in the root module");
        pub const PathMakePretty = @compileError("'PathMakePretty' requires that UNICODE be set to true or false in the root module");
        pub const PathMatchSpec = @compileError("'PathMatchSpec' requires that UNICODE be set to true or false in the root module");
        pub const PathMatchSpecEx = @compileError("'PathMatchSpecEx' requires that UNICODE be set to true or false in the root module");
        pub const PathParseIconLocation = @compileError("'PathParseIconLocation' requires that UNICODE be set to true or false in the root module");
        pub const PathQuoteSpaces = @compileError("'PathQuoteSpaces' requires that UNICODE be set to true or false in the root module");
        pub const PathRelativePathTo = @compileError("'PathRelativePathTo' requires that UNICODE be set to true or false in the root module");
        pub const PathRemoveArgs = @compileError("'PathRemoveArgs' requires that UNICODE be set to true or false in the root module");
        pub const PathRemoveBackslash = @compileError("'PathRemoveBackslash' requires that UNICODE be set to true or false in the root module");
        pub const PathRemoveBlanks = @compileError("'PathRemoveBlanks' requires that UNICODE be set to true or false in the root module");
        pub const PathRemoveExtension = @compileError("'PathRemoveExtension' requires that UNICODE be set to true or false in the root module");
        pub const PathRemoveFileSpec = @compileError("'PathRemoveFileSpec' requires that UNICODE be set to true or false in the root module");
        pub const PathRenameExtension = @compileError("'PathRenameExtension' requires that UNICODE be set to true or false in the root module");
        pub const PathSearchAndQualify = @compileError("'PathSearchAndQualify' requires that UNICODE be set to true or false in the root module");
        pub const PathSetDlgItemPath = @compileError("'PathSetDlgItemPath' requires that UNICODE be set to true or false in the root module");
        pub const PathSkipRoot = @compileError("'PathSkipRoot' requires that UNICODE be set to true or false in the root module");
        pub const PathStripPath = @compileError("'PathStripPath' requires that UNICODE be set to true or false in the root module");
        pub const PathStripToRoot = @compileError("'PathStripToRoot' requires that UNICODE be set to true or false in the root module");
        pub const PathUnquoteSpaces = @compileError("'PathUnquoteSpaces' requires that UNICODE be set to true or false in the root module");
        pub const PathMakeSystemFolder = @compileError("'PathMakeSystemFolder' requires that UNICODE be set to true or false in the root module");
        pub const PathUnmakeSystemFolder = @compileError("'PathUnmakeSystemFolder' requires that UNICODE be set to true or false in the root module");
        pub const PathIsSystemFolder = @compileError("'PathIsSystemFolder' requires that UNICODE be set to true or false in the root module");
        pub const PathUndecorate = @compileError("'PathUndecorate' requires that UNICODE be set to true or false in the root module");
        pub const PathUnExpandEnvStrings = @compileError("'PathUnExpandEnvStrings' requires that UNICODE be set to true or false in the root module");
        pub const UrlCompare = @compileError("'UrlCompare' requires that UNICODE be set to true or false in the root module");
        pub const UrlCombine = @compileError("'UrlCombine' requires that UNICODE be set to true or false in the root module");
        pub const UrlCanonicalize = @compileError("'UrlCanonicalize' requires that UNICODE be set to true or false in the root module");
        pub const UrlIsOpaque = @compileError("'UrlIsOpaque' requires that UNICODE be set to true or false in the root module");
        pub const UrlIsNoHistory = @compileError("'UrlIsNoHistory' requires that UNICODE be set to true or false in the root module");
        pub const UrlIs = @compileError("'UrlIs' requires that UNICODE be set to true or false in the root module");
        pub const UrlGetLocation = @compileError("'UrlGetLocation' requires that UNICODE be set to true or false in the root module");
        pub const UrlUnescape = @compileError("'UrlUnescape' requires that UNICODE be set to true or false in the root module");
        pub const UrlEscape = @compileError("'UrlEscape' requires that UNICODE be set to true or false in the root module");
        pub const UrlCreateFromPath = @compileError("'UrlCreateFromPath' requires that UNICODE be set to true or false in the root module");
        pub const PathCreateFromUrl = @compileError("'PathCreateFromUrl' requires that UNICODE be set to true or false in the root module");
        pub const UrlHash = @compileError("'UrlHash' requires that UNICODE be set to true or false in the root module");
        pub const UrlGetPart = @compileError("'UrlGetPart' requires that UNICODE be set to true or false in the root module");
        pub const UrlApplyScheme = @compileError("'UrlApplyScheme' requires that UNICODE be set to true or false in the root module");
        pub const ParseURL = @compileError("'ParseURL' requires that UNICODE be set to true or false in the root module");
        pub const SHDeleteEmptyKey = @compileError("'SHDeleteEmptyKey' requires that UNICODE be set to true or false in the root module");
        pub const SHDeleteKey = @compileError("'SHDeleteKey' requires that UNICODE be set to true or false in the root module");
        pub const SHDeleteValue = @compileError("'SHDeleteValue' requires that UNICODE be set to true or false in the root module");
        pub const SHGetValue = @compileError("'SHGetValue' requires that UNICODE be set to true or false in the root module");
        pub const SHSetValue = @compileError("'SHSetValue' requires that UNICODE be set to true or false in the root module");
        pub const SHRegGetValue = @compileError("'SHRegGetValue' requires that UNICODE be set to true or false in the root module");
        pub const SHQueryValueEx = @compileError("'SHQueryValueEx' requires that UNICODE be set to true or false in the root module");
        pub const SHEnumKeyEx = @compileError("'SHEnumKeyEx' requires that UNICODE be set to true or false in the root module");
        pub const SHEnumValue = @compileError("'SHEnumValue' requires that UNICODE be set to true or false in the root module");
        pub const SHQueryInfoKey = @compileError("'SHQueryInfoKey' requires that UNICODE be set to true or false in the root module");
        pub const SHCopyKey = @compileError("'SHCopyKey' requires that UNICODE be set to true or false in the root module");
        pub const SHRegGetPath = @compileError("'SHRegGetPath' requires that UNICODE be set to true or false in the root module");
        pub const SHRegSetPath = @compileError("'SHRegSetPath' requires that UNICODE be set to true or false in the root module");
        pub const SHRegCreateUSKey = @compileError("'SHRegCreateUSKey' requires that UNICODE be set to true or false in the root module");
        pub const SHRegOpenUSKey = @compileError("'SHRegOpenUSKey' requires that UNICODE be set to true or false in the root module");
        pub const SHRegQueryUSValue = @compileError("'SHRegQueryUSValue' requires that UNICODE be set to true or false in the root module");
        pub const SHRegWriteUSValue = @compileError("'SHRegWriteUSValue' requires that UNICODE be set to true or false in the root module");
        pub const SHRegDeleteUSValue = @compileError("'SHRegDeleteUSValue' requires that UNICODE be set to true or false in the root module");
        pub const SHRegDeleteEmptyUSKey = @compileError("'SHRegDeleteEmptyUSKey' requires that UNICODE be set to true or false in the root module");
        pub const SHRegEnumUSKey = @compileError("'SHRegEnumUSKey' requires that UNICODE be set to true or false in the root module");
        pub const SHRegEnumUSValue = @compileError("'SHRegEnumUSValue' requires that UNICODE be set to true or false in the root module");
        pub const SHRegQueryInfoUSKey = @compileError("'SHRegQueryInfoUSKey' requires that UNICODE be set to true or false in the root module");
        pub const SHRegGetUSValue = @compileError("'SHRegGetUSValue' requires that UNICODE be set to true or false in the root module");
        pub const SHRegSetUSValue = @compileError("'SHRegSetUSValue' requires that UNICODE be set to true or false in the root module");
        pub const SHRegGetBoolUSValue = @compileError("'SHRegGetBoolUSValue' requires that UNICODE be set to true or false in the root module");
        pub const AssocQueryString = @compileError("'AssocQueryString' requires that UNICODE be set to true or false in the root module");
        pub const AssocQueryStringByKey = @compileError("'AssocQueryStringByKey' requires that UNICODE be set to true or false in the root module");
        pub const AssocQueryKey = @compileError("'AssocQueryKey' requires that UNICODE be set to true or false in the root module");
        pub const SHOpenRegStream = @compileError("'SHOpenRegStream' requires that UNICODE be set to true or false in the root module");
        pub const SHOpenRegStream2 = @compileError("'SHOpenRegStream2' requires that UNICODE be set to true or false in the root module");
        pub const SHCreateStreamOnFile = @compileError("'SHCreateStreamOnFile' requires that UNICODE be set to true or false in the root module");
        pub const GetAcceptLanguages = @compileError("'GetAcceptLanguages' requires that UNICODE be set to true or false in the root module");
        pub const SHFormatDateTime = @compileError("'SHFormatDateTime' requires that UNICODE be set to true or false in the root module");
        pub const SHMessageBoxCheck = @compileError("'SHMessageBoxCheck' requires that UNICODE be set to true or false in the root module");
        pub const SHSendMessageBroadcast = @compileError("'SHSendMessageBroadcast' requires that UNICODE be set to true or false in the root module");
        pub const SHStripMneumonic = @compileError("'SHStripMneumonic' requires that UNICODE be set to true or false in the root module");
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (105)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const BOOL = @import("../foundation.zig").BOOL;
const BOOLEAN = @import("../foundation.zig").BOOLEAN;
const BSTR = @import("../foundation.zig").BSTR;
const BYTE_BLOB = @import("../system/com.zig").BYTE_BLOB;
const CHAR = @import("../foundation.zig").CHAR;
const COMDLG_FILTERSPEC = @import("../ui/shell/common.zig").COMDLG_FILTERSPEC;
const COORD = @import("../system/console.zig").COORD;
const CREATESTRUCTW = @import("../ui/windows_and_messaging.zig").CREATESTRUCTW;
const DEVICE_SCALE_FACTOR = @import("../ui/shell/common.zig").DEVICE_SCALE_FACTOR;
const DISPPARAMS = @import("../system/com.zig").DISPPARAMS;
const EXCEPINFO = @import("../system/com.zig").EXCEPINFO;
const FILE_FLAGS_AND_ATTRIBUTES = @import("../storage/file_system.zig").FILE_FLAGS_AND_ATTRIBUTES;
const FILETIME = @import("../foundation.zig").FILETIME;
const FORMATETC = @import("../system/com.zig").FORMATETC;
const GETPROPERTYSTOREFLAGS = @import("../ui/shell/properties_system.zig").GETPROPERTYSTOREFLAGS;
const HACCEL = @import("../ui/windows_and_messaging.zig").HACCEL;
const HANDLE = @import("../foundation.zig").HANDLE;
const HBITMAP = @import("../graphics/gdi.zig").HBITMAP;
const HDC = @import("../graphics/gdi.zig").HDC;
const HICON = @import("../ui/windows_and_messaging.zig").HICON;
const HIMAGELIST = @import("../ui/controls.zig").HIMAGELIST;
const HINSTANCE = @import("../foundation.zig").HINSTANCE;
const HKEY = @import("../system/registry.zig").HKEY;
const HMENU = @import("../ui/windows_and_messaging.zig").HMENU;
const HMONITOR = @import("../graphics/gdi.zig").HMONITOR;
const HPALETTE = @import("../graphics/gdi.zig").HPALETTE;
const HPROPSHEETPAGE = @import("../ui/controls.zig").HPROPSHEETPAGE;
const HRESULT = @import("../foundation.zig").HRESULT;
const HWND = @import("../foundation.zig").HWND;
const IBindCtx = @import("../system/com.zig").IBindCtx;
const IBindStatusCallback = @import("../system/com.zig").IBindStatusCallback;
const ICondition = @import("../system/search.zig").ICondition;
const IConnectionPoint = @import("../system/com.zig").IConnectionPoint;
const IDataObject = @import("../system/com.zig").IDataObject;
const IDCompositionAnimation = @import("../graphics/direct_composition.zig").IDCompositionAnimation;
const IDispatch = @import("../system/com.zig").IDispatch;
const IDropSource = @import("../system/ole.zig").IDropSource;
const IDropTarget = @import("../system/ole.zig").IDropTarget;
const IEnumFORMATETC = @import("../system/com.zig").IEnumFORMATETC;
const IEnumGUID = @import("../system/com.zig").IEnumGUID;
const IEnumString = @import("../system/com.zig").IEnumString;
const IEnumUnknown = @import("../system/com.zig").IEnumUnknown;
const IMalloc = @import("../system/com.zig").IMalloc;
const IMoniker = @import("../system/com.zig").IMoniker;
const IObjectArray = @import("../ui/shell/common.zig").IObjectArray;
const IOleCommandTarget = @import("../system/ole.zig").IOleCommandTarget;
const IOleInPlaceSite = @import("../system/ole.zig").IOleInPlaceSite;
const IOleObject = @import("../system/ole.zig").IOleObject;
const IOleWindow = @import("../system/ole.zig").IOleWindow;
const IPersist = @import("../system/com.zig").IPersist;
const IPropertyBag = @import("../system/com/structured_storage.zig").IPropertyBag;
const IPropertyChangeArray = @import("../ui/shell/properties_system.zig").IPropertyChangeArray;
const IPropertyDescriptionList = @import("../ui/shell/properties_system.zig").IPropertyDescriptionList;
const IPropertySetStorage = @import("../system/com/structured_storage.zig").IPropertySetStorage;
const IPropertyStore = @import("../ui/shell/properties_system.zig").IPropertyStore;
const IServiceProvider = @import("../system/com.zig").IServiceProvider;
const IStorage = @import("../system/com/structured_storage.zig").IStorage;
const IStream = @import("../system/com.zig").IStream;
const ITEMIDLIST = @import("../ui/shell/common.zig").ITEMIDLIST;
const IUnknown = @import("../system/com.zig").IUnknown;
const IXMLDOMDocument = @import("../data/xml/ms_xml.zig").IXMLDOMDocument;
const LARGE_INTEGER = @import("../foundation.zig").LARGE_INTEGER;
const LOGFONTW = @import("../graphics/gdi.zig").LOGFONTW;
const LPARAM = @import("../foundation.zig").LPARAM;
const LPFNSVADDPROPSHEETPAGE = @import("../ui/controls.zig").LPFNSVADDPROPSHEETPAGE;
const LPTHREAD_START_ROUTINE = @import("../system/threading.zig").LPTHREAD_START_ROUTINE;
const LRESULT = @import("../foundation.zig").LRESULT;
const LSTATUS = @import("../foundation.zig").LSTATUS;
const MSG = @import("../ui/windows_and_messaging.zig").MSG;
const NETRESOURCEA = @import("../network_management/wnet.zig").NETRESOURCEA;
const NMHDR = @import("../ui/controls.zig").NMHDR;
const NTSTATUS = @import("../foundation.zig").NTSTATUS;
const OLECMDEXECOPT = @import("../system/ole.zig").OLECMDEXECOPT;
const OLECMDF = @import("../system/ole.zig").OLECMDF;
const OLECMDID = @import("../system/ole.zig").OLECMDID;
const OleMenuGroupWidths = @import("../system/ole.zig").OleMenuGroupWidths;
const OVERLAPPED = @import("../system/io.zig").OVERLAPPED;
const PDOPSTATUS = @import("../ui/shell/properties_system.zig").PDOPSTATUS;
const PERCEIVED = @import("../ui/shell/common.zig").PERCEIVED;
const POINT = @import("../foundation.zig").POINT;
const POINTL = @import("../foundation.zig").POINTL;
const PROCESS_INFORMATION = @import("../system/threading.zig").PROCESS_INFORMATION;
const PROPERTYKEY = @import("../ui/shell/properties_system.zig").PROPERTYKEY;
const PROPVARIANT = @import("../system/com/structured_storage.zig").PROPVARIANT;
const PSTR = @import("../foundation.zig").PSTR;
const PWSTR = @import("../foundation.zig").PWSTR;
const READYSTATE = @import("../system/ole.zig").READYSTATE;
const RECT = @import("../foundation.zig").RECT;
const RECTL = @import("../foundation.zig").RECTL;
const SECURITY_ATTRIBUTES = @import("../security.zig").SECURITY_ATTRIBUTES;
const SHANDLE_PTR = @import("../foundation.zig").SHANDLE_PTR;
const SHELLDETAILS = @import("../ui/shell/common.zig").SHELLDETAILS;
const SHITEMID = @import("../ui/shell/common.zig").SHITEMID;
const SIZE = @import("../foundation.zig").SIZE;
const SOFTDISTINFO = @import("../system/com/urlmon.zig").SOFTDISTINFO;
const STARTUPINFOW = @import("../system/threading.zig").STARTUPINFOW;
const STRRET = @import("../ui/shell/common.zig").STRRET;
const SYSTEMTIME = @import("../foundation.zig").SYSTEMTIME;
const TBBUTTON = @import("../ui/controls.zig").TBBUTTON;
const ULARGE_INTEGER = @import("../foundation.zig").ULARGE_INTEGER;
const VARIANT = @import("../system/com.zig").VARIANT;
const WIN32_FIND_DATAA = @import("../storage/file_system.zig").WIN32_FIND_DATAA;
const WIN32_FIND_DATAW = @import("../storage/file_system.zig").WIN32_FIND_DATAW;
const WPARAM = @import("../foundation.zig").WPARAM;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "SUBCLASSPROC")) {
        _ = SUBCLASSPROC;
    }
    if (@hasDecl(@This(), "BFFCALLBACK")) {
        _ = BFFCALLBACK;
    }
    if (@hasDecl(@This(), "LPFNDFMCALLBACK")) {
        _ = LPFNDFMCALLBACK;
    }
    if (@hasDecl(@This(), "LPFNVIEWCALLBACK")) {
        _ = LPFNVIEWCALLBACK;
    }
    if (@hasDecl(@This(), "PFNCANSHAREFOLDERW")) {
        _ = PFNCANSHAREFOLDERW;
    }
    if (@hasDecl(@This(), "PFNSHOWSHAREFOLDERUIW")) {
        _ = PFNSHOWSHAREFOLDERUIW;
    }
    if (@hasDecl(@This(), "DLLGETVERSIONPROC")) {
        _ = DLLGETVERSIONPROC;
    }
    if (@hasDecl(@This(), "APPLET_PROC")) {
        _ = APPLET_PROC;
    }
    if (@hasDecl(@This(), "PAPPSTATE_CHANGE_ROUTINE")) {
        _ = PAPPSTATE_CHANGE_ROUTINE;
    }
    if (@hasDecl(@This(), "PAPPCONSTRAIN_CHANGE_ROUTINE")) {
        _ = PAPPCONSTRAIN_CHANGE_ROUTINE;
    }

    @setEvalBranchQuota(comptime @import("std").meta.declarations(@This()).len * 3);

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        if (decl.is_pub) {
            _ = @field(@This(), decl.name);
        }
    }
}
//--------------------------------------------------------------------------------
// Section: SubModules (2)
//--------------------------------------------------------------------------------
pub const common = @import("shell/common.zig");
pub const properties_system = @import("shell/properties_system.zig");
