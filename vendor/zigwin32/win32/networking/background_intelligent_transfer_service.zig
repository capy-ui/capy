//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (209)
//--------------------------------------------------------------------------------
pub const BG_NOTIFY_JOB_TRANSFERRED = @as(u32, 1);
pub const BG_NOTIFY_JOB_ERROR = @as(u32, 2);
pub const BG_NOTIFY_DISABLE = @as(u32, 4);
pub const BG_NOTIFY_JOB_MODIFICATION = @as(u32, 8);
pub const BG_NOTIFY_FILE_TRANSFERRED = @as(u32, 16);
pub const BG_NOTIFY_FILE_RANGES_TRANSFERRED = @as(u32, 32);
pub const BG_JOB_ENUM_ALL_USERS = @as(u32, 1);
pub const BG_COPY_FILE_OWNER = @as(u32, 1);
pub const BG_COPY_FILE_GROUP = @as(u32, 2);
pub const BG_COPY_FILE_DACL = @as(u32, 4);
pub const BG_COPY_FILE_SACL = @as(u32, 8);
pub const BG_COPY_FILE_ALL = @as(u32, 15);
pub const BG_SSL_ENABLE_CRL_CHECK = @as(u32, 1);
pub const BG_SSL_IGNORE_CERT_CN_INVALID = @as(u32, 2);
pub const BG_SSL_IGNORE_CERT_DATE_INVALID = @as(u32, 4);
pub const BG_SSL_IGNORE_UNKNOWN_CA = @as(u32, 8);
pub const BG_SSL_IGNORE_CERT_WRONG_USAGE = @as(u32, 16);
pub const BG_HTTP_REDIRECT_POLICY_MASK = @as(u32, 1792);
pub const BG_HTTP_REDIRECT_POLICY_ALLOW_SILENT = @as(u32, 0);
pub const BG_HTTP_REDIRECT_POLICY_ALLOW_REPORT = @as(u32, 256);
pub const BG_HTTP_REDIRECT_POLICY_DISALLOW = @as(u32, 512);
pub const BG_HTTP_REDIRECT_POLICY_ALLOW_HTTPS_TO_HTTP = @as(u32, 2048);
pub const BG_ENABLE_PEERCACHING_CLIENT = @as(u32, 1);
pub const BG_ENABLE_PEERCACHING_SERVER = @as(u32, 2);
pub const BG_DISABLE_BRANCH_CACHE = @as(u32, 4);
pub const BG_JOB_ENABLE_PEERCACHING_CLIENT = @as(u32, 1);
pub const BG_JOB_ENABLE_PEERCACHING_SERVER = @as(u32, 2);
pub const BG_JOB_DISABLE_BRANCH_CACHE = @as(u32, 4);
pub const BITS_COST_STATE_UNRESTRICTED = @as(u32, 1);
pub const BITS_COST_STATE_CAPPED_USAGE_UNKNOWN = @as(u32, 2);
pub const BITS_COST_STATE_BELOW_CAP = @as(u32, 4);
pub const BITS_COST_STATE_NEAR_CAP = @as(u32, 8);
pub const BITS_COST_STATE_OVERCAP_CHARGED = @as(u32, 16);
pub const BITS_COST_STATE_OVERCAP_THROTTLED = @as(u32, 32);
pub const BITS_COST_STATE_USAGE_BASED = @as(u32, 64);
pub const BITS_COST_STATE_ROAMING = @as(u32, 128);
pub const BITS_COST_OPTION_IGNORE_CONGESTION = @as(u32, 2147483648);
pub const BITS_COST_STATE_RESERVED = @as(u32, 1073741824);
pub const QM_NOTIFY_FILE_DONE = @as(u32, 1);
pub const QM_NOTIFY_JOB_DONE = @as(u32, 2);
pub const QM_NOTIFY_GROUP_DONE = @as(u32, 4);
pub const QM_NOTIFY_DISABLE_NOTIFY = @as(u32, 64);
pub const QM_NOTIFY_USE_PROGRESSEX = @as(u32, 128);
pub const QM_STATUS_FILE_COMPLETE = @as(u32, 1);
pub const QM_STATUS_FILE_INCOMPLETE = @as(u32, 2);
pub const QM_STATUS_JOB_COMPLETE = @as(u32, 4);
pub const QM_STATUS_JOB_INCOMPLETE = @as(u32, 8);
pub const QM_STATUS_JOB_ERROR = @as(u32, 16);
pub const QM_STATUS_JOB_FOREGROUND = @as(u32, 32);
pub const QM_STATUS_GROUP_COMPLETE = @as(u32, 64);
pub const QM_STATUS_GROUP_INCOMPLETE = @as(u32, 128);
pub const QM_STATUS_GROUP_SUSPENDED = @as(u32, 256);
pub const QM_STATUS_GROUP_ERROR = @as(u32, 512);
pub const QM_STATUS_GROUP_FOREGROUND = @as(u32, 1024);
pub const QM_PROTOCOL_HTTP = @as(u32, 1);
pub const QM_PROTOCOL_FTP = @as(u32, 2);
pub const QM_PROTOCOL_SMB = @as(u32, 3);
pub const QM_PROTOCOL_CUSTOM = @as(u32, 4);
pub const QM_PROGRESS_PERCENT_DONE = @as(u32, 1);
pub const QM_PROGRESS_TIME_DONE = @as(u32, 2);
pub const QM_PROGRESS_SIZE_DONE = @as(u32, 3);
pub const QM_E_INVALID_STATE = @as(u32, 2164264961);
pub const QM_E_SERVICE_UNAVAILABLE = @as(u32, 2164264962);
pub const QM_E_DOWNLOADER_UNAVAILABLE = @as(u32, 2164264963);
pub const QM_E_ITEM_NOT_FOUND = @as(u32, 2164264964);
pub const BG_E_NOT_FOUND = @as(i32, -2145386495);
pub const BG_E_INVALID_STATE = @as(i32, -2145386494);
pub const BG_E_EMPTY = @as(i32, -2145386493);
pub const BG_E_FILE_NOT_AVAILABLE = @as(i32, -2145386492);
pub const BG_E_PROTOCOL_NOT_AVAILABLE = @as(i32, -2145386491);
pub const BG_S_ERROR_CONTEXT_NONE = @as(i32, 2097158);
pub const BG_E_ERROR_CONTEXT_UNKNOWN = @as(i32, -2145386489);
pub const BG_E_ERROR_CONTEXT_GENERAL_QUEUE_MANAGER = @as(i32, -2145386488);
pub const BG_E_ERROR_CONTEXT_LOCAL_FILE = @as(i32, -2145386487);
pub const BG_E_ERROR_CONTEXT_REMOTE_FILE = @as(i32, -2145386486);
pub const BG_E_ERROR_CONTEXT_GENERAL_TRANSPORT = @as(i32, -2145386485);
pub const BG_E_ERROR_CONTEXT_QUEUE_MANAGER_NOTIFICATION = @as(i32, -2145386484);
pub const BG_E_DESTINATION_LOCKED = @as(i32, -2145386483);
pub const BG_E_VOLUME_CHANGED = @as(i32, -2145386482);
pub const BG_E_ERROR_INFORMATION_UNAVAILABLE = @as(i32, -2145386481);
pub const BG_E_NETWORK_DISCONNECTED = @as(i32, -2145386480);
pub const BG_E_MISSING_FILE_SIZE = @as(i32, -2145386479);
pub const BG_E_INSUFFICIENT_HTTP_SUPPORT = @as(i32, -2145386478);
pub const BG_E_INSUFFICIENT_RANGE_SUPPORT = @as(i32, -2145386477);
pub const BG_E_REMOTE_NOT_SUPPORTED = @as(i32, -2145386476);
pub const BG_E_NEW_OWNER_DIFF_MAPPING = @as(i32, -2145386475);
pub const BG_E_NEW_OWNER_NO_FILE_ACCESS = @as(i32, -2145386474);
pub const BG_S_PARTIAL_COMPLETE = @as(i32, 2097175);
pub const BG_E_PROXY_LIST_TOO_LARGE = @as(i32, -2145386472);
pub const BG_E_PROXY_BYPASS_LIST_TOO_LARGE = @as(i32, -2145386471);
pub const BG_S_UNABLE_TO_DELETE_FILES = @as(i32, 2097178);
pub const BG_E_INVALID_SERVER_RESPONSE = @as(i32, -2145386469);
pub const BG_E_TOO_MANY_FILES = @as(i32, -2145386468);
pub const BG_E_LOCAL_FILE_CHANGED = @as(i32, -2145386467);
pub const BG_E_ERROR_CONTEXT_REMOTE_APPLICATION = @as(i32, -2145386466);
pub const BG_E_SESSION_NOT_FOUND = @as(i32, -2145386465);
pub const BG_E_TOO_LARGE = @as(i32, -2145386464);
pub const BG_E_STRING_TOO_LONG = @as(i32, -2145386463);
pub const BG_E_CLIENT_SERVER_PROTOCOL_MISMATCH = @as(i32, -2145386462);
pub const BG_E_SERVER_EXECUTE_ENABLE = @as(i32, -2145386461);
pub const BG_E_NO_PROGRESS = @as(i32, -2145386460);
pub const BG_E_USERNAME_TOO_LARGE = @as(i32, -2145386459);
pub const BG_E_PASSWORD_TOO_LARGE = @as(i32, -2145386458);
pub const BG_E_INVALID_AUTH_TARGET = @as(i32, -2145386457);
pub const BG_E_INVALID_AUTH_SCHEME = @as(i32, -2145386456);
pub const BG_E_FILE_NOT_FOUND = @as(i32, -2145386455);
pub const BG_S_PROXY_CHANGED = @as(i32, 2097194);
pub const BG_E_INVALID_RANGE = @as(i32, -2145386453);
pub const BG_E_OVERLAPPING_RANGES = @as(i32, -2145386452);
pub const BG_E_CONNECT_FAILURE = @as(i32, -2145386451);
pub const BG_E_CONNECTION_CLOSED = @as(i32, -2145386450);
pub const BG_E_BLOCKED_BY_POLICY = @as(i32, -2145386434);
pub const BG_E_INVALID_PROXY_INFO = @as(i32, -2145386433);
pub const BG_E_INVALID_CREDENTIALS = @as(i32, -2145386432);
pub const BG_E_INVALID_HASH_ALGORITHM = @as(i32, -2145386431);
pub const BG_E_RECORD_DELETED = @as(i32, -2145386430);
pub const BG_E_COMMIT_IN_PROGRESS = @as(i32, -2145386429);
pub const BG_E_DISCOVERY_IN_PROGRESS = @as(i32, -2145386428);
pub const BG_E_UPNP_ERROR = @as(i32, -2145386427);
pub const BG_E_TEST_OPTION_BLOCKED_DOWNLOAD = @as(i32, -2145386426);
pub const BG_E_PEERCACHING_DISABLED = @as(i32, -2145386425);
pub const BG_E_BUSYCACHERECORD = @as(i32, -2145386424);
pub const BG_E_TOO_MANY_JOBS_PER_USER = @as(i32, -2145386423);
pub const BG_E_TOO_MANY_JOBS_PER_MACHINE = @as(i32, -2145386416);
pub const BG_E_TOO_MANY_FILES_IN_JOB = @as(i32, -2145386415);
pub const BG_E_TOO_MANY_RANGES_IN_FILE = @as(i32, -2145386414);
pub const BG_E_VALIDATION_FAILED = @as(i32, -2145386413);
pub const BG_E_MAXDOWNLOAD_TIMEOUT = @as(i32, -2145386412);
pub const BG_S_OVERRIDDEN_BY_POLICY = @as(i32, 2097237);
pub const BG_E_TOKEN_REQUIRED = @as(i32, -2145386410);
pub const BG_E_UNKNOWN_PROPERTY_ID = @as(i32, -2145386409);
pub const BG_E_READ_ONLY_PROPERTY = @as(i32, -2145386408);
pub const BG_E_BLOCKED_BY_COST_TRANSFER_POLICY = @as(i32, -2145386407);
pub const BG_E_PROPERTY_SUPPORTED_FOR_DOWNLOAD_JOBS_ONLY = @as(i32, -2145386400);
pub const BG_E_READ_ONLY_PROPERTY_AFTER_ADDFILE = @as(i32, -2145386399);
pub const BG_E_READ_ONLY_PROPERTY_AFTER_RESUME = @as(i32, -2145386398);
pub const BG_E_MAX_DOWNLOAD_SIZE_INVALID_VALUE = @as(i32, -2145386397);
pub const BG_E_MAX_DOWNLOAD_SIZE_LIMIT_REACHED = @as(i32, -2145386396);
pub const BG_E_STANDBY_MODE = @as(i32, -2145386395);
pub const BG_E_USE_STORED_CREDENTIALS_NOT_SUPPORTED = @as(i32, -2145386394);
pub const BG_E_BLOCKED_BY_BATTERY_POLICY = @as(i32, -2145386393);
pub const BG_E_BLOCKED_BY_BATTERY_SAVER = @as(i32, -2145386392);
pub const BG_E_WATCHDOG_TIMEOUT = @as(i32, -2145386391);
pub const BG_E_APP_PACKAGE_NOT_FOUND = @as(i32, -2145386390);
pub const BG_E_APP_PACKAGE_SCENARIO_NOT_SUPPORTED = @as(i32, -2145386389);
pub const BG_E_DATABASE_CORRUPT = @as(i32, -2145386388);
pub const BG_E_RANDOM_ACCESS_NOT_SUPPORTED = @as(i32, -2145386387);
pub const BG_E_BLOCKED_BY_BACKGROUND_ACCESS_POLICY = @as(i32, -2145386386);
pub const BG_E_BLOCKED_BY_GAME_MODE = @as(i32, -2145386385);
pub const BG_E_BLOCKED_BY_SYSTEM_POLICY = @as(i32, -2145386384);
pub const BG_E_NOT_SUPPORTED_WITH_CUSTOM_HTTP_METHOD = @as(i32, -2145386383);
pub const BG_E_UNSUPPORTED_JOB_CONFIGURATION = @as(i32, -2145386382);
pub const BG_E_REMOTE_FILE_CHANGED = @as(i32, -2145386381);
pub const BG_E_SERVER_CERT_VALIDATION_INTERFACE_REQUIRED = @as(i32, -2145386380);
pub const BG_E_READ_ONLY_WHEN_JOB_ACTIVE = @as(i32, -2145386379);
pub const BG_E_ERROR_CONTEXT_SERVER_CERTIFICATE_CALLBACK = @as(i32, -2145386378);
pub const BG_E_HTTP_ERROR_100 = @as(i32, -2145845148);
pub const BG_E_HTTP_ERROR_101 = @as(i32, -2145845147);
pub const BG_E_HTTP_ERROR_200 = @as(i32, -2145845048);
pub const BG_E_HTTP_ERROR_201 = @as(i32, -2145845047);
pub const BG_E_HTTP_ERROR_202 = @as(i32, -2145845046);
pub const BG_E_HTTP_ERROR_203 = @as(i32, -2145845045);
pub const BG_E_HTTP_ERROR_204 = @as(i32, -2145845044);
pub const BG_E_HTTP_ERROR_205 = @as(i32, -2145845043);
pub const BG_E_HTTP_ERROR_206 = @as(i32, -2145845042);
pub const BG_E_HTTP_ERROR_300 = @as(i32, -2145844948);
pub const BG_E_HTTP_ERROR_301 = @as(i32, -2145844947);
pub const BG_E_HTTP_ERROR_302 = @as(i32, -2145844946);
pub const BG_E_HTTP_ERROR_303 = @as(i32, -2145844945);
pub const BG_E_HTTP_ERROR_304 = @as(i32, -2145844944);
pub const BG_E_HTTP_ERROR_305 = @as(i32, -2145844943);
pub const BG_E_HTTP_ERROR_307 = @as(i32, -2145844941);
pub const BG_E_HTTP_ERROR_400 = @as(i32, -2145844848);
pub const BG_E_HTTP_ERROR_401 = @as(i32, -2145844847);
pub const BG_E_HTTP_ERROR_402 = @as(i32, -2145844846);
pub const BG_E_HTTP_ERROR_403 = @as(i32, -2145844845);
pub const BG_E_HTTP_ERROR_404 = @as(i32, -2145844844);
pub const BG_E_HTTP_ERROR_405 = @as(i32, -2145844843);
pub const BG_E_HTTP_ERROR_406 = @as(i32, -2145844842);
pub const BG_E_HTTP_ERROR_407 = @as(i32, -2145844841);
pub const BG_E_HTTP_ERROR_408 = @as(i32, -2145844840);
pub const BG_E_HTTP_ERROR_409 = @as(i32, -2145844839);
pub const BG_E_HTTP_ERROR_410 = @as(i32, -2145844838);
pub const BG_E_HTTP_ERROR_411 = @as(i32, -2145844837);
pub const BG_E_HTTP_ERROR_412 = @as(i32, -2145844836);
pub const BG_E_HTTP_ERROR_413 = @as(i32, -2145844835);
pub const BG_E_HTTP_ERROR_414 = @as(i32, -2145844834);
pub const BG_E_HTTP_ERROR_415 = @as(i32, -2145844833);
pub const BG_E_HTTP_ERROR_416 = @as(i32, -2145844832);
pub const BG_E_HTTP_ERROR_417 = @as(i32, -2145844831);
pub const BG_E_HTTP_ERROR_449 = @as(i32, -2145844799);
pub const BG_E_HTTP_ERROR_500 = @as(i32, -2145844748);
pub const BG_E_HTTP_ERROR_501 = @as(i32, -2145844747);
pub const BG_E_HTTP_ERROR_502 = @as(i32, -2145844746);
pub const BG_E_HTTP_ERROR_503 = @as(i32, -2145844745);
pub const BG_E_HTTP_ERROR_504 = @as(i32, -2145844744);
pub const BG_E_HTTP_ERROR_505 = @as(i32, -2145844743);
pub const BITS_MC_JOB_CANCELLED = @as(i32, -2145828864);
pub const BITS_MC_FILE_DELETION_FAILED = @as(i32, -2145828863);
pub const BITS_MC_FILE_DELETION_FAILED_MORE = @as(i32, -2145828862);
pub const BITS_MC_JOB_PROPERTY_CHANGE = @as(i32, -2145828861);
pub const BITS_MC_JOB_TAKE_OWNERSHIP = @as(i32, -2145828860);
pub const BITS_MC_JOB_SCAVENGED = @as(i32, -2145828859);
pub const BITS_MC_JOB_NOTIFICATION_FAILURE = @as(i32, -2145828858);
pub const BITS_MC_STATE_FILE_CORRUPT = @as(i32, -2145828857);
pub const BITS_MC_FAILED_TO_START = @as(i32, -2145828856);
pub const BITS_MC_FATAL_IGD_ERROR = @as(i32, -2145828855);
pub const BITS_MC_PEERCACHING_PORT = @as(i32, -2145828854);
pub const BITS_MC_WSD_PORT = @as(i32, -2145828853);

//--------------------------------------------------------------------------------
// Section: Types (74)
//--------------------------------------------------------------------------------
pub const BG_TOKEN = enum(u32) {
    LOCAL_FILE = 1,
    NETWORK = 2,
};
pub const BG_TOKEN_LOCAL_FILE = BG_TOKEN.LOCAL_FILE;
pub const BG_TOKEN_NETWORK = BG_TOKEN.NETWORK;

const CLSID_BackgroundCopyManager_Value = Guid.initString("4991d34b-80a1-4291-83b6-3328366b9097");
pub const CLSID_BackgroundCopyManager = &CLSID_BackgroundCopyManager_Value;

pub const BG_FILE_PROGRESS = extern struct {
    BytesTotal: u64,
    BytesTransferred: u64,
    Completed: BOOL,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IBackgroundCopyFile_Value = Guid.initString("01b7bd23-fb88-4a77-8490-5891d3e4653a");
pub const IID_IBackgroundCopyFile = &IID_IBackgroundCopyFile_Value;
pub const IBackgroundCopyFile = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetRemoteName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyFile,
                pVal: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyFile,
                pVal: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLocalName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyFile,
                pVal: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyFile,
                pVal: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProgress: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyFile,
                pVal: ?*BG_FILE_PROGRESS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyFile,
                pVal: ?*BG_FILE_PROGRESS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyFile_GetRemoteName(self: *const T, pVal: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyFile.VTable, self.vtable).GetRemoteName(@ptrCast(*const IBackgroundCopyFile, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyFile_GetLocalName(self: *const T, pVal: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyFile.VTable, self.vtable).GetLocalName(@ptrCast(*const IBackgroundCopyFile, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyFile_GetProgress(self: *const T, pVal: ?*BG_FILE_PROGRESS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyFile.VTable, self.vtable).GetProgress(@ptrCast(*const IBackgroundCopyFile, self), pVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IEnumBackgroundCopyFiles_Value = Guid.initString("ca51e165-c365-424c-8d41-24aaa4ff3c40");
pub const IID_IEnumBackgroundCopyFiles = &IID_IEnumBackgroundCopyFiles_Value;
pub const IEnumBackgroundCopyFiles = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumBackgroundCopyFiles,
                celt: u32,
                rgelt: ?*?*IBackgroundCopyFile,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumBackgroundCopyFiles,
                celt: u32,
                rgelt: ?*?*IBackgroundCopyFile,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumBackgroundCopyFiles,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumBackgroundCopyFiles,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumBackgroundCopyFiles,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumBackgroundCopyFiles,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumBackgroundCopyFiles,
                ppenum: ?*?*IEnumBackgroundCopyFiles,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumBackgroundCopyFiles,
                ppenum: ?*?*IEnumBackgroundCopyFiles,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumBackgroundCopyFiles,
                puCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumBackgroundCopyFiles,
                puCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumBackgroundCopyFiles_Next(self: *const T, celt: u32, rgelt: ?*?*IBackgroundCopyFile, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumBackgroundCopyFiles.VTable, self.vtable).Next(@ptrCast(*const IEnumBackgroundCopyFiles, self), celt, rgelt, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumBackgroundCopyFiles_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumBackgroundCopyFiles.VTable, self.vtable).Skip(@ptrCast(*const IEnumBackgroundCopyFiles, self), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumBackgroundCopyFiles_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumBackgroundCopyFiles.VTable, self.vtable).Reset(@ptrCast(*const IEnumBackgroundCopyFiles, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumBackgroundCopyFiles_Clone(self: *const T, ppenum: ?*?*IEnumBackgroundCopyFiles) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumBackgroundCopyFiles.VTable, self.vtable).Clone(@ptrCast(*const IEnumBackgroundCopyFiles, self), ppenum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumBackgroundCopyFiles_GetCount(self: *const T, puCount: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumBackgroundCopyFiles.VTable, self.vtable).GetCount(@ptrCast(*const IEnumBackgroundCopyFiles, self), puCount);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const BG_ERROR_CONTEXT = enum(i32) {
    NONE = 0,
    UNKNOWN = 1,
    GENERAL_QUEUE_MANAGER = 2,
    QUEUE_MANAGER_NOTIFICATION = 3,
    LOCAL_FILE = 4,
    REMOTE_FILE = 5,
    GENERAL_TRANSPORT = 6,
    REMOTE_APPLICATION = 7,
    SERVER_CERTIFICATE_CALLBACK = 8,
};
pub const BG_ERROR_CONTEXT_NONE = BG_ERROR_CONTEXT.NONE;
pub const BG_ERROR_CONTEXT_UNKNOWN = BG_ERROR_CONTEXT.UNKNOWN;
pub const BG_ERROR_CONTEXT_GENERAL_QUEUE_MANAGER = BG_ERROR_CONTEXT.GENERAL_QUEUE_MANAGER;
pub const BG_ERROR_CONTEXT_QUEUE_MANAGER_NOTIFICATION = BG_ERROR_CONTEXT.QUEUE_MANAGER_NOTIFICATION;
pub const BG_ERROR_CONTEXT_LOCAL_FILE = BG_ERROR_CONTEXT.LOCAL_FILE;
pub const BG_ERROR_CONTEXT_REMOTE_FILE = BG_ERROR_CONTEXT.REMOTE_FILE;
pub const BG_ERROR_CONTEXT_GENERAL_TRANSPORT = BG_ERROR_CONTEXT.GENERAL_TRANSPORT;
pub const BG_ERROR_CONTEXT_REMOTE_APPLICATION = BG_ERROR_CONTEXT.REMOTE_APPLICATION;
pub const BG_ERROR_CONTEXT_SERVER_CERTIFICATE_CALLBACK = BG_ERROR_CONTEXT.SERVER_CERTIFICATE_CALLBACK;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IBackgroundCopyError_Value = Guid.initString("19c613a0-fcb8-4f28-81ae-897c3d078f81");
pub const IID_IBackgroundCopyError = &IID_IBackgroundCopyError_Value;
pub const IBackgroundCopyError = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetError: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyError,
                pContext: ?*BG_ERROR_CONTEXT,
                pCode: ?*HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyError,
                pContext: ?*BG_ERROR_CONTEXT,
                pCode: ?*HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyError,
                pVal: ?*?*IBackgroundCopyFile,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyError,
                pVal: ?*?*IBackgroundCopyFile,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetErrorDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyError,
                LanguageId: u32,
                pErrorDescription: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyError,
                LanguageId: u32,
                pErrorDescription: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetErrorContextDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyError,
                LanguageId: u32,
                pContextDescription: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyError,
                LanguageId: u32,
                pContextDescription: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProtocol: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyError,
                pProtocol: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyError,
                pProtocol: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyError_GetError(self: *const T, pContext: ?*BG_ERROR_CONTEXT, pCode: ?*HRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyError.VTable, self.vtable).GetError(@ptrCast(*const IBackgroundCopyError, self), pContext, pCode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyError_GetFile(self: *const T, pVal: ?*?*IBackgroundCopyFile) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyError.VTable, self.vtable).GetFile(@ptrCast(*const IBackgroundCopyError, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyError_GetErrorDescription(self: *const T, LanguageId: u32, pErrorDescription: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyError.VTable, self.vtable).GetErrorDescription(@ptrCast(*const IBackgroundCopyError, self), LanguageId, pErrorDescription);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyError_GetErrorContextDescription(self: *const T, LanguageId: u32, pContextDescription: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyError.VTable, self.vtable).GetErrorContextDescription(@ptrCast(*const IBackgroundCopyError, self), LanguageId, pContextDescription);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyError_GetProtocol(self: *const T, pProtocol: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyError.VTable, self.vtable).GetProtocol(@ptrCast(*const IBackgroundCopyError, self), pProtocol);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const BG_FILE_INFO = extern struct {
    RemoteName: ?PWSTR,
    LocalName: ?PWSTR,
};

pub const BG_JOB_PROGRESS = extern struct {
    BytesTotal: u64,
    BytesTransferred: u64,
    FilesTotal: u32,
    FilesTransferred: u32,
};

pub const BG_JOB_TIMES = extern struct {
    CreationTime: FILETIME,
    ModificationTime: FILETIME,
    TransferCompletionTime: FILETIME,
};

pub const BG_JOB_PRIORITY = enum(i32) {
    FOREGROUND = 0,
    HIGH = 1,
    NORMAL = 2,
    LOW = 3,
};
pub const BG_JOB_PRIORITY_FOREGROUND = BG_JOB_PRIORITY.FOREGROUND;
pub const BG_JOB_PRIORITY_HIGH = BG_JOB_PRIORITY.HIGH;
pub const BG_JOB_PRIORITY_NORMAL = BG_JOB_PRIORITY.NORMAL;
pub const BG_JOB_PRIORITY_LOW = BG_JOB_PRIORITY.LOW;

pub const BG_JOB_STATE = enum(i32) {
    QUEUED = 0,
    CONNECTING = 1,
    TRANSFERRING = 2,
    SUSPENDED = 3,
    ERROR = 4,
    TRANSIENT_ERROR = 5,
    TRANSFERRED = 6,
    ACKNOWLEDGED = 7,
    CANCELLED = 8,
};
pub const BG_JOB_STATE_QUEUED = BG_JOB_STATE.QUEUED;
pub const BG_JOB_STATE_CONNECTING = BG_JOB_STATE.CONNECTING;
pub const BG_JOB_STATE_TRANSFERRING = BG_JOB_STATE.TRANSFERRING;
pub const BG_JOB_STATE_SUSPENDED = BG_JOB_STATE.SUSPENDED;
pub const BG_JOB_STATE_ERROR = BG_JOB_STATE.ERROR;
pub const BG_JOB_STATE_TRANSIENT_ERROR = BG_JOB_STATE.TRANSIENT_ERROR;
pub const BG_JOB_STATE_TRANSFERRED = BG_JOB_STATE.TRANSFERRED;
pub const BG_JOB_STATE_ACKNOWLEDGED = BG_JOB_STATE.ACKNOWLEDGED;
pub const BG_JOB_STATE_CANCELLED = BG_JOB_STATE.CANCELLED;

pub const BG_JOB_TYPE = enum(i32) {
    DOWNLOAD = 0,
    UPLOAD = 1,
    UPLOAD_REPLY = 2,
};
pub const BG_JOB_TYPE_DOWNLOAD = BG_JOB_TYPE.DOWNLOAD;
pub const BG_JOB_TYPE_UPLOAD = BG_JOB_TYPE.UPLOAD;
pub const BG_JOB_TYPE_UPLOAD_REPLY = BG_JOB_TYPE.UPLOAD_REPLY;

pub const BG_JOB_PROXY_USAGE = enum(i32) {
    PRECONFIG = 0,
    NO_PROXY = 1,
    OVERRIDE = 2,
    AUTODETECT = 3,
};
pub const BG_JOB_PROXY_USAGE_PRECONFIG = BG_JOB_PROXY_USAGE.PRECONFIG;
pub const BG_JOB_PROXY_USAGE_NO_PROXY = BG_JOB_PROXY_USAGE.NO_PROXY;
pub const BG_JOB_PROXY_USAGE_OVERRIDE = BG_JOB_PROXY_USAGE.OVERRIDE;
pub const BG_JOB_PROXY_USAGE_AUTODETECT = BG_JOB_PROXY_USAGE.AUTODETECT;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IBackgroundCopyJob_Value = Guid.initString("37668d37-507e-4160-9316-26306d150b12");
pub const IID_IBackgroundCopyJob = &IID_IBackgroundCopyJob_Value;
pub const IBackgroundCopyJob = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddFileSet: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyJob,
                cFileCount: u32,
                pFileSet: [*]BG_FILE_INFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyJob,
                cFileCount: u32,
                pFileSet: [*]BG_FILE_INFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyJob,
                RemoteUrl: ?[*:0]const u16,
                LocalName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyJob,
                RemoteUrl: ?[*:0]const u16,
                LocalName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumFiles: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyJob,
                pEnum: ?*?*IEnumBackgroundCopyFiles,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyJob,
                pEnum: ?*?*IEnumBackgroundCopyFiles,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Suspend: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyJob,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyJob,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Resume: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyJob,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyJob,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Cancel: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyJob,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyJob,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Complete: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyJob,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyJob,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyJob,
                pVal: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyJob,
                pVal: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyJob,
                pVal: ?*BG_JOB_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyJob,
                pVal: ?*BG_JOB_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProgress: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyJob,
                pVal: ?*BG_JOB_PROGRESS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyJob,
                pVal: ?*BG_JOB_PROGRESS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTimes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyJob,
                pVal: ?*BG_JOB_TIMES,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyJob,
                pVal: ?*BG_JOB_TIMES,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyJob,
                pVal: ?*BG_JOB_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyJob,
                pVal: ?*BG_JOB_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetError: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyJob,
                ppError: ?*?*IBackgroundCopyError,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyJob,
                ppError: ?*?*IBackgroundCopyError,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOwner: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyJob,
                pVal: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyJob,
                pVal: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDisplayName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyJob,
                Val: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyJob,
                Val: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDisplayName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyJob,
                pVal: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyJob,
                pVal: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyJob,
                Val: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyJob,
                Val: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyJob,
                pVal: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyJob,
                pVal: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPriority: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyJob,
                Val: BG_JOB_PRIORITY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyJob,
                Val: BG_JOB_PRIORITY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPriority: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyJob,
                pVal: ?*BG_JOB_PRIORITY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyJob,
                pVal: ?*BG_JOB_PRIORITY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetNotifyFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyJob,
                Val: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyJob,
                Val: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNotifyFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyJob,
                pVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyJob,
                pVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetNotifyInterface: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyJob,
                Val: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyJob,
                Val: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNotifyInterface: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyJob,
                pVal: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyJob,
                pVal: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetMinimumRetryDelay: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyJob,
                Seconds: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyJob,
                Seconds: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMinimumRetryDelay: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyJob,
                Seconds: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyJob,
                Seconds: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetNoProgressTimeout: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyJob,
                Seconds: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyJob,
                Seconds: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNoProgressTimeout: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyJob,
                Seconds: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyJob,
                Seconds: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetErrorCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyJob,
                Errors: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyJob,
                Errors: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetProxySettings: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyJob,
                ProxyUsage: BG_JOB_PROXY_USAGE,
                ProxyList: ?[*:0]const u16,
                ProxyBypassList: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyJob,
                ProxyUsage: BG_JOB_PROXY_USAGE,
                ProxyList: ?[*:0]const u16,
                ProxyBypassList: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProxySettings: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyJob,
                pProxyUsage: ?*BG_JOB_PROXY_USAGE,
                pProxyList: ?*?PWSTR,
                pProxyBypassList: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyJob,
                pProxyUsage: ?*BG_JOB_PROXY_USAGE,
                pProxyList: ?*?PWSTR,
                pProxyBypassList: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TakeOwnership: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyJob,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyJob,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyJob_AddFileSet(self: *const T, cFileCount: u32, pFileSet: [*]BG_FILE_INFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyJob.VTable, self.vtable).AddFileSet(@ptrCast(*const IBackgroundCopyJob, self), cFileCount, pFileSet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyJob_AddFile(self: *const T, RemoteUrl: ?[*:0]const u16, LocalName: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyJob.VTable, self.vtable).AddFile(@ptrCast(*const IBackgroundCopyJob, self), RemoteUrl, LocalName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyJob_EnumFiles(self: *const T, pEnum: ?*?*IEnumBackgroundCopyFiles) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyJob.VTable, self.vtable).EnumFiles(@ptrCast(*const IBackgroundCopyJob, self), pEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyJob_Suspend(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyJob.VTable, self.vtable).Suspend(@ptrCast(*const IBackgroundCopyJob, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyJob_Resume(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyJob.VTable, self.vtable).Resume(@ptrCast(*const IBackgroundCopyJob, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyJob_Cancel(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyJob.VTable, self.vtable).Cancel(@ptrCast(*const IBackgroundCopyJob, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyJob_Complete(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyJob.VTable, self.vtable).Complete(@ptrCast(*const IBackgroundCopyJob, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyJob_GetId(self: *const T, pVal: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyJob.VTable, self.vtable).GetId(@ptrCast(*const IBackgroundCopyJob, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyJob_GetType(self: *const T, pVal: ?*BG_JOB_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyJob.VTable, self.vtable).GetType(@ptrCast(*const IBackgroundCopyJob, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyJob_GetProgress(self: *const T, pVal: ?*BG_JOB_PROGRESS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyJob.VTable, self.vtable).GetProgress(@ptrCast(*const IBackgroundCopyJob, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyJob_GetTimes(self: *const T, pVal: ?*BG_JOB_TIMES) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyJob.VTable, self.vtable).GetTimes(@ptrCast(*const IBackgroundCopyJob, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyJob_GetState(self: *const T, pVal: ?*BG_JOB_STATE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyJob.VTable, self.vtable).GetState(@ptrCast(*const IBackgroundCopyJob, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyJob_GetError(self: *const T, ppError: ?*?*IBackgroundCopyError) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyJob.VTable, self.vtable).GetError(@ptrCast(*const IBackgroundCopyJob, self), ppError);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyJob_GetOwner(self: *const T, pVal: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyJob.VTable, self.vtable).GetOwner(@ptrCast(*const IBackgroundCopyJob, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyJob_SetDisplayName(self: *const T, Val: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyJob.VTable, self.vtable).SetDisplayName(@ptrCast(*const IBackgroundCopyJob, self), Val);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyJob_GetDisplayName(self: *const T, pVal: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyJob.VTable, self.vtable).GetDisplayName(@ptrCast(*const IBackgroundCopyJob, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyJob_SetDescription(self: *const T, Val: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyJob.VTable, self.vtable).SetDescription(@ptrCast(*const IBackgroundCopyJob, self), Val);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyJob_GetDescription(self: *const T, pVal: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyJob.VTable, self.vtable).GetDescription(@ptrCast(*const IBackgroundCopyJob, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyJob_SetPriority(self: *const T, Val: BG_JOB_PRIORITY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyJob.VTable, self.vtable).SetPriority(@ptrCast(*const IBackgroundCopyJob, self), Val);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyJob_GetPriority(self: *const T, pVal: ?*BG_JOB_PRIORITY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyJob.VTable, self.vtable).GetPriority(@ptrCast(*const IBackgroundCopyJob, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyJob_SetNotifyFlags(self: *const T, Val: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyJob.VTable, self.vtable).SetNotifyFlags(@ptrCast(*const IBackgroundCopyJob, self), Val);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyJob_GetNotifyFlags(self: *const T, pVal: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyJob.VTable, self.vtable).GetNotifyFlags(@ptrCast(*const IBackgroundCopyJob, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyJob_SetNotifyInterface(self: *const T, Val: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyJob.VTable, self.vtable).SetNotifyInterface(@ptrCast(*const IBackgroundCopyJob, self), Val);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyJob_GetNotifyInterface(self: *const T, pVal: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyJob.VTable, self.vtable).GetNotifyInterface(@ptrCast(*const IBackgroundCopyJob, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyJob_SetMinimumRetryDelay(self: *const T, Seconds: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyJob.VTable, self.vtable).SetMinimumRetryDelay(@ptrCast(*const IBackgroundCopyJob, self), Seconds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyJob_GetMinimumRetryDelay(self: *const T, Seconds: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyJob.VTable, self.vtable).GetMinimumRetryDelay(@ptrCast(*const IBackgroundCopyJob, self), Seconds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyJob_SetNoProgressTimeout(self: *const T, Seconds: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyJob.VTable, self.vtable).SetNoProgressTimeout(@ptrCast(*const IBackgroundCopyJob, self), Seconds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyJob_GetNoProgressTimeout(self: *const T, Seconds: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyJob.VTable, self.vtable).GetNoProgressTimeout(@ptrCast(*const IBackgroundCopyJob, self), Seconds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyJob_GetErrorCount(self: *const T, Errors: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyJob.VTable, self.vtable).GetErrorCount(@ptrCast(*const IBackgroundCopyJob, self), Errors);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyJob_SetProxySettings(self: *const T, ProxyUsage: BG_JOB_PROXY_USAGE, ProxyList: ?[*:0]const u16, ProxyBypassList: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyJob.VTable, self.vtable).SetProxySettings(@ptrCast(*const IBackgroundCopyJob, self), ProxyUsage, ProxyList, ProxyBypassList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyJob_GetProxySettings(self: *const T, pProxyUsage: ?*BG_JOB_PROXY_USAGE, pProxyList: ?*?PWSTR, pProxyBypassList: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyJob.VTable, self.vtable).GetProxySettings(@ptrCast(*const IBackgroundCopyJob, self), pProxyUsage, pProxyList, pProxyBypassList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyJob_TakeOwnership(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyJob.VTable, self.vtable).TakeOwnership(@ptrCast(*const IBackgroundCopyJob, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IEnumBackgroundCopyJobs_Value = Guid.initString("1af4f612-3b71-466f-8f58-7b6f73ac57ad");
pub const IID_IEnumBackgroundCopyJobs = &IID_IEnumBackgroundCopyJobs_Value;
pub const IEnumBackgroundCopyJobs = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumBackgroundCopyJobs,
                celt: u32,
                rgelt: ?*?*IBackgroundCopyJob,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumBackgroundCopyJobs,
                celt: u32,
                rgelt: ?*?*IBackgroundCopyJob,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumBackgroundCopyJobs,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumBackgroundCopyJobs,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumBackgroundCopyJobs,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumBackgroundCopyJobs,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumBackgroundCopyJobs,
                ppenum: ?*?*IEnumBackgroundCopyJobs,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumBackgroundCopyJobs,
                ppenum: ?*?*IEnumBackgroundCopyJobs,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumBackgroundCopyJobs,
                puCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumBackgroundCopyJobs,
                puCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumBackgroundCopyJobs_Next(self: *const T, celt: u32, rgelt: ?*?*IBackgroundCopyJob, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumBackgroundCopyJobs.VTable, self.vtable).Next(@ptrCast(*const IEnumBackgroundCopyJobs, self), celt, rgelt, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumBackgroundCopyJobs_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumBackgroundCopyJobs.VTable, self.vtable).Skip(@ptrCast(*const IEnumBackgroundCopyJobs, self), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumBackgroundCopyJobs_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumBackgroundCopyJobs.VTable, self.vtable).Reset(@ptrCast(*const IEnumBackgroundCopyJobs, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumBackgroundCopyJobs_Clone(self: *const T, ppenum: ?*?*IEnumBackgroundCopyJobs) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumBackgroundCopyJobs.VTable, self.vtable).Clone(@ptrCast(*const IEnumBackgroundCopyJobs, self), ppenum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumBackgroundCopyJobs_GetCount(self: *const T, puCount: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumBackgroundCopyJobs.VTable, self.vtable).GetCount(@ptrCast(*const IEnumBackgroundCopyJobs, self), puCount);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IBackgroundCopyCallback_Value = Guid.initString("97ea99c7-0186-4ad4-8df9-c5b4e0ed6b22");
pub const IID_IBackgroundCopyCallback = &IID_IBackgroundCopyCallback_Value;
pub const IBackgroundCopyCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        JobTransferred: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyCallback,
                pJob: ?*IBackgroundCopyJob,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyCallback,
                pJob: ?*IBackgroundCopyJob,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        JobError: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyCallback,
                pJob: ?*IBackgroundCopyJob,
                pError: ?*IBackgroundCopyError,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyCallback,
                pJob: ?*IBackgroundCopyJob,
                pError: ?*IBackgroundCopyError,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        JobModification: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyCallback,
                pJob: ?*IBackgroundCopyJob,
                dwReserved: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyCallback,
                pJob: ?*IBackgroundCopyJob,
                dwReserved: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyCallback_JobTransferred(self: *const T, pJob: ?*IBackgroundCopyJob) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyCallback.VTable, self.vtable).JobTransferred(@ptrCast(*const IBackgroundCopyCallback, self), pJob);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyCallback_JobError(self: *const T, pJob: ?*IBackgroundCopyJob, pError: ?*IBackgroundCopyError) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyCallback.VTable, self.vtable).JobError(@ptrCast(*const IBackgroundCopyCallback, self), pJob, pError);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyCallback_JobModification(self: *const T, pJob: ?*IBackgroundCopyJob, dwReserved: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyCallback.VTable, self.vtable).JobModification(@ptrCast(*const IBackgroundCopyCallback, self), pJob, dwReserved);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_AsyncIBackgroundCopyCallback_Value = Guid.initString("ca29d251-b4bb-4679-a3d9-ae8006119d54");
pub const IID_AsyncIBackgroundCopyCallback = &IID_AsyncIBackgroundCopyCallback_Value;
pub const AsyncIBackgroundCopyCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Begin_JobTransferred: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const AsyncIBackgroundCopyCallback,
                pJob: ?*IBackgroundCopyJob,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const AsyncIBackgroundCopyCallback,
                pJob: ?*IBackgroundCopyJob,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Finish_JobTransferred: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const AsyncIBackgroundCopyCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const AsyncIBackgroundCopyCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Begin_JobError: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const AsyncIBackgroundCopyCallback,
                pJob: ?*IBackgroundCopyJob,
                pError: ?*IBackgroundCopyError,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const AsyncIBackgroundCopyCallback,
                pJob: ?*IBackgroundCopyJob,
                pError: ?*IBackgroundCopyError,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Finish_JobError: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const AsyncIBackgroundCopyCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const AsyncIBackgroundCopyCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Begin_JobModification: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const AsyncIBackgroundCopyCallback,
                pJob: ?*IBackgroundCopyJob,
                dwReserved: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const AsyncIBackgroundCopyCallback,
                pJob: ?*IBackgroundCopyJob,
                dwReserved: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Finish_JobModification: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const AsyncIBackgroundCopyCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const AsyncIBackgroundCopyCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIBackgroundCopyCallback_Begin_JobTransferred(self: *const T, pJob: ?*IBackgroundCopyJob) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIBackgroundCopyCallback.VTable, self.vtable).Begin_JobTransferred(@ptrCast(*const AsyncIBackgroundCopyCallback, self), pJob);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIBackgroundCopyCallback_Finish_JobTransferred(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIBackgroundCopyCallback.VTable, self.vtable).Finish_JobTransferred(@ptrCast(*const AsyncIBackgroundCopyCallback, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIBackgroundCopyCallback_Begin_JobError(self: *const T, pJob: ?*IBackgroundCopyJob, pError: ?*IBackgroundCopyError) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIBackgroundCopyCallback.VTable, self.vtable).Begin_JobError(@ptrCast(*const AsyncIBackgroundCopyCallback, self), pJob, pError);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIBackgroundCopyCallback_Finish_JobError(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIBackgroundCopyCallback.VTable, self.vtable).Finish_JobError(@ptrCast(*const AsyncIBackgroundCopyCallback, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIBackgroundCopyCallback_Begin_JobModification(self: *const T, pJob: ?*IBackgroundCopyJob, dwReserved: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIBackgroundCopyCallback.VTable, self.vtable).Begin_JobModification(@ptrCast(*const AsyncIBackgroundCopyCallback, self), pJob, dwReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIBackgroundCopyCallback_Finish_JobModification(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIBackgroundCopyCallback.VTable, self.vtable).Finish_JobModification(@ptrCast(*const AsyncIBackgroundCopyCallback, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IBackgroundCopyManager_Value = Guid.initString("5ce34c0d-0dc9-4c1f-897c-daa1b78cee7c");
pub const IID_IBackgroundCopyManager = &IID_IBackgroundCopyManager_Value;
pub const IBackgroundCopyManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateJob: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyManager,
                DisplayName: ?[*:0]const u16,
                Type: BG_JOB_TYPE,
                pJobId: ?*Guid,
                ppJob: ?*?*IBackgroundCopyJob,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyManager,
                DisplayName: ?[*:0]const u16,
                Type: BG_JOB_TYPE,
                pJobId: ?*Guid,
                ppJob: ?*?*IBackgroundCopyJob,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetJob: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyManager,
                jobID: ?*const Guid,
                ppJob: ?*?*IBackgroundCopyJob,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyManager,
                jobID: ?*const Guid,
                ppJob: ?*?*IBackgroundCopyJob,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumJobs: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyManager,
                dwFlags: u32,
                ppEnum: ?*?*IEnumBackgroundCopyJobs,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyManager,
                dwFlags: u32,
                ppEnum: ?*?*IEnumBackgroundCopyJobs,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetErrorDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyManager,
                hResult: HRESULT,
                LanguageId: u32,
                pErrorDescription: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyManager,
                hResult: HRESULT,
                LanguageId: u32,
                pErrorDescription: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyManager_CreateJob(self: *const T, DisplayName: ?[*:0]const u16, Type: BG_JOB_TYPE, pJobId: ?*Guid, ppJob: ?*?*IBackgroundCopyJob) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyManager.VTable, self.vtable).CreateJob(@ptrCast(*const IBackgroundCopyManager, self), DisplayName, Type, pJobId, ppJob);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyManager_GetJob(self: *const T, jobID: ?*const Guid, ppJob: ?*?*IBackgroundCopyJob) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyManager.VTable, self.vtable).GetJob(@ptrCast(*const IBackgroundCopyManager, self), jobID, ppJob);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyManager_EnumJobs(self: *const T, dwFlags: u32, ppEnum: ?*?*IEnumBackgroundCopyJobs) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyManager.VTable, self.vtable).EnumJobs(@ptrCast(*const IBackgroundCopyManager, self), dwFlags, ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyManager_GetErrorDescription(self: *const T, hResult: HRESULT, LanguageId: u32, pErrorDescription: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyManager.VTable, self.vtable).GetErrorDescription(@ptrCast(*const IBackgroundCopyManager, self), hResult, LanguageId, pErrorDescription);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const CLSID_BackgroundCopyManager1_5_Value = Guid.initString("f087771f-d74f-4c1a-bb8a-e16aca9124ea");
pub const CLSID_BackgroundCopyManager1_5 = &CLSID_BackgroundCopyManager1_5_Value;

pub const BG_JOB_REPLY_PROGRESS = extern struct {
    BytesTotal: u64,
    BytesTransferred: u64,
};

pub const BG_AUTH_TARGET = enum(i32) {
    SERVER = 1,
    PROXY = 2,
};
pub const BG_AUTH_TARGET_SERVER = BG_AUTH_TARGET.SERVER;
pub const BG_AUTH_TARGET_PROXY = BG_AUTH_TARGET.PROXY;

pub const BG_AUTH_SCHEME = enum(i32) {
    BASIC = 1,
    DIGEST = 2,
    NTLM = 3,
    NEGOTIATE = 4,
    PASSPORT = 5,
};
pub const BG_AUTH_SCHEME_BASIC = BG_AUTH_SCHEME.BASIC;
pub const BG_AUTH_SCHEME_DIGEST = BG_AUTH_SCHEME.DIGEST;
pub const BG_AUTH_SCHEME_NTLM = BG_AUTH_SCHEME.NTLM;
pub const BG_AUTH_SCHEME_NEGOTIATE = BG_AUTH_SCHEME.NEGOTIATE;
pub const BG_AUTH_SCHEME_PASSPORT = BG_AUTH_SCHEME.PASSPORT;

pub const BG_BASIC_CREDENTIALS = extern struct {
    UserName: ?PWSTR,
    Password: ?PWSTR,
};

pub const BG_AUTH_CREDENTIALS_UNION = extern union {
    Basic: BG_BASIC_CREDENTIALS,
};

pub const BG_AUTH_CREDENTIALS = extern struct {
    Target: BG_AUTH_TARGET,
    Scheme: BG_AUTH_SCHEME,
    Credentials: BG_AUTH_CREDENTIALS_UNION,
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IBackgroundCopyJob2_Value = Guid.initString("54b50739-686f-45eb-9dff-d6a9a0faa9af");
pub const IID_IBackgroundCopyJob2 = &IID_IBackgroundCopyJob2_Value;
pub const IBackgroundCopyJob2 = extern struct {
    pub const VTable = extern struct {
        base: IBackgroundCopyJob.VTable,
        SetNotifyCmdLine: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyJob2,
                Program: ?[*:0]const u16,
                Parameters: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyJob2,
                Program: ?[*:0]const u16,
                Parameters: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNotifyCmdLine: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyJob2,
                pProgram: ?*?PWSTR,
                pParameters: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyJob2,
                pProgram: ?*?PWSTR,
                pParameters: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetReplyProgress: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyJob2,
                pProgress: ?*BG_JOB_REPLY_PROGRESS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyJob2,
                pProgress: ?*BG_JOB_REPLY_PROGRESS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetReplyData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyJob2,
                ppBuffer: ?*?*u8,
                pLength: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyJob2,
                ppBuffer: ?*?*u8,
                pLength: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetReplyFileName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyJob2,
                ReplyFileName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyJob2,
                ReplyFileName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetReplyFileName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyJob2,
                pReplyFileName: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyJob2,
                pReplyFileName: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCredentials: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyJob2,
                credentials: ?*BG_AUTH_CREDENTIALS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyJob2,
                credentials: ?*BG_AUTH_CREDENTIALS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveCredentials: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyJob2,
                Target: BG_AUTH_TARGET,
                Scheme: BG_AUTH_SCHEME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyJob2,
                Target: BG_AUTH_TARGET,
                Scheme: BG_AUTH_SCHEME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IBackgroundCopyJob.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyJob2_SetNotifyCmdLine(self: *const T, Program: ?[*:0]const u16, Parameters: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyJob2.VTable, self.vtable).SetNotifyCmdLine(@ptrCast(*const IBackgroundCopyJob2, self), Program, Parameters);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyJob2_GetNotifyCmdLine(self: *const T, pProgram: ?*?PWSTR, pParameters: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyJob2.VTable, self.vtable).GetNotifyCmdLine(@ptrCast(*const IBackgroundCopyJob2, self), pProgram, pParameters);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyJob2_GetReplyProgress(self: *const T, pProgress: ?*BG_JOB_REPLY_PROGRESS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyJob2.VTable, self.vtable).GetReplyProgress(@ptrCast(*const IBackgroundCopyJob2, self), pProgress);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyJob2_GetReplyData(self: *const T, ppBuffer: ?*?*u8, pLength: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyJob2.VTable, self.vtable).GetReplyData(@ptrCast(*const IBackgroundCopyJob2, self), ppBuffer, pLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyJob2_SetReplyFileName(self: *const T, ReplyFileName: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyJob2.VTable, self.vtable).SetReplyFileName(@ptrCast(*const IBackgroundCopyJob2, self), ReplyFileName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyJob2_GetReplyFileName(self: *const T, pReplyFileName: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyJob2.VTable, self.vtable).GetReplyFileName(@ptrCast(*const IBackgroundCopyJob2, self), pReplyFileName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyJob2_SetCredentials(self: *const T, credentials: ?*BG_AUTH_CREDENTIALS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyJob2.VTable, self.vtable).SetCredentials(@ptrCast(*const IBackgroundCopyJob2, self), credentials);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyJob2_RemoveCredentials(self: *const T, Target: BG_AUTH_TARGET, Scheme: BG_AUTH_SCHEME) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyJob2.VTable, self.vtable).RemoveCredentials(@ptrCast(*const IBackgroundCopyJob2, self), Target, Scheme);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const CLSID_BackgroundCopyManager2_0_Value = Guid.initString("6d18ad12-bde3-4393-b311-099c346e6df9");
pub const CLSID_BackgroundCopyManager2_0 = &CLSID_BackgroundCopyManager2_0_Value;

pub const BG_FILE_RANGE = extern struct {
    InitialOffset: u64,
    Length: u64,
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IBackgroundCopyJob3_Value = Guid.initString("443c8934-90ff-48ed-bcde-26f5c7450042");
pub const IID_IBackgroundCopyJob3 = &IID_IBackgroundCopyJob3_Value;
pub const IBackgroundCopyJob3 = extern struct {
    pub const VTable = extern struct {
        base: IBackgroundCopyJob2.VTable,
        ReplaceRemotePrefix: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyJob3,
                OldPrefix: ?[*:0]const u16,
                NewPrefix: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyJob3,
                OldPrefix: ?[*:0]const u16,
                NewPrefix: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddFileWithRanges: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyJob3,
                RemoteUrl: ?[*:0]const u16,
                LocalName: ?[*:0]const u16,
                RangeCount: u32,
                Ranges: [*]BG_FILE_RANGE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyJob3,
                RemoteUrl: ?[*:0]const u16,
                LocalName: ?[*:0]const u16,
                RangeCount: u32,
                Ranges: [*]BG_FILE_RANGE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFileACLFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyJob3,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyJob3,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFileACLFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyJob3,
                Flags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyJob3,
                Flags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IBackgroundCopyJob2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyJob3_ReplaceRemotePrefix(self: *const T, OldPrefix: ?[*:0]const u16, NewPrefix: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyJob3.VTable, self.vtable).ReplaceRemotePrefix(@ptrCast(*const IBackgroundCopyJob3, self), OldPrefix, NewPrefix);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyJob3_AddFileWithRanges(self: *const T, RemoteUrl: ?[*:0]const u16, LocalName: ?[*:0]const u16, RangeCount: u32, Ranges: [*]BG_FILE_RANGE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyJob3.VTable, self.vtable).AddFileWithRanges(@ptrCast(*const IBackgroundCopyJob3, self), RemoteUrl, LocalName, RangeCount, Ranges);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyJob3_SetFileACLFlags(self: *const T, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyJob3.VTable, self.vtable).SetFileACLFlags(@ptrCast(*const IBackgroundCopyJob3, self), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyJob3_GetFileACLFlags(self: *const T, Flags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyJob3.VTable, self.vtable).GetFileACLFlags(@ptrCast(*const IBackgroundCopyJob3, self), Flags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IBackgroundCopyFile2_Value = Guid.initString("83e81b93-0873-474d-8a8c-f2018b1a939c");
pub const IID_IBackgroundCopyFile2 = &IID_IBackgroundCopyFile2_Value;
pub const IBackgroundCopyFile2 = extern struct {
    pub const VTable = extern struct {
        base: IBackgroundCopyFile.VTable,
        GetFileRanges: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyFile2,
                RangeCount: ?*u32,
                Ranges: [*]?*BG_FILE_RANGE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyFile2,
                RangeCount: ?*u32,
                Ranges: [*]?*BG_FILE_RANGE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetRemoteName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyFile2,
                Val: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyFile2,
                Val: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IBackgroundCopyFile.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyFile2_GetFileRanges(self: *const T, RangeCount: ?*u32, Ranges: [*]?*BG_FILE_RANGE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyFile2.VTable, self.vtable).GetFileRanges(@ptrCast(*const IBackgroundCopyFile2, self), RangeCount, Ranges);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyFile2_SetRemoteName(self: *const T, Val: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyFile2.VTable, self.vtable).SetRemoteName(@ptrCast(*const IBackgroundCopyFile2, self), Val);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const CLSID_BackgroundCopyManager2_5_Value = Guid.initString("03ca98d6-ff5d-49b8-abc6-03dd84127020");
pub const CLSID_BackgroundCopyManager2_5 = &CLSID_BackgroundCopyManager2_5_Value;

pub const BG_CERT_STORE_LOCATION = enum(i32) {
    CURRENT_USER = 0,
    LOCAL_MACHINE = 1,
    CURRENT_SERVICE = 2,
    SERVICES = 3,
    USERS = 4,
    CURRENT_USER_GROUP_POLICY = 5,
    LOCAL_MACHINE_GROUP_POLICY = 6,
    LOCAL_MACHINE_ENTERPRISE = 7,
};
pub const BG_CERT_STORE_LOCATION_CURRENT_USER = BG_CERT_STORE_LOCATION.CURRENT_USER;
pub const BG_CERT_STORE_LOCATION_LOCAL_MACHINE = BG_CERT_STORE_LOCATION.LOCAL_MACHINE;
pub const BG_CERT_STORE_LOCATION_CURRENT_SERVICE = BG_CERT_STORE_LOCATION.CURRENT_SERVICE;
pub const BG_CERT_STORE_LOCATION_SERVICES = BG_CERT_STORE_LOCATION.SERVICES;
pub const BG_CERT_STORE_LOCATION_USERS = BG_CERT_STORE_LOCATION.USERS;
pub const BG_CERT_STORE_LOCATION_CURRENT_USER_GROUP_POLICY = BG_CERT_STORE_LOCATION.CURRENT_USER_GROUP_POLICY;
pub const BG_CERT_STORE_LOCATION_LOCAL_MACHINE_GROUP_POLICY = BG_CERT_STORE_LOCATION.LOCAL_MACHINE_GROUP_POLICY;
pub const BG_CERT_STORE_LOCATION_LOCAL_MACHINE_ENTERPRISE = BG_CERT_STORE_LOCATION.LOCAL_MACHINE_ENTERPRISE;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IBackgroundCopyJobHttpOptions_Value = Guid.initString("f1bd1079-9f01-4bdc-8036-f09b70095066");
pub const IID_IBackgroundCopyJobHttpOptions = &IID_IBackgroundCopyJobHttpOptions_Value;
pub const IBackgroundCopyJobHttpOptions = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetClientCertificateByID: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyJobHttpOptions,
                StoreLocation: BG_CERT_STORE_LOCATION,
                StoreName: ?[*:0]const u16,
                pCertHashBlob: *[20]u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyJobHttpOptions,
                StoreLocation: BG_CERT_STORE_LOCATION,
                StoreName: ?[*:0]const u16,
                pCertHashBlob: *[20]u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetClientCertificateByName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyJobHttpOptions,
                StoreLocation: BG_CERT_STORE_LOCATION,
                StoreName: ?[*:0]const u16,
                SubjectName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyJobHttpOptions,
                StoreLocation: BG_CERT_STORE_LOCATION,
                StoreName: ?[*:0]const u16,
                SubjectName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveClientCertificate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyJobHttpOptions,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyJobHttpOptions,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetClientCertificate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyJobHttpOptions,
                pStoreLocation: ?*BG_CERT_STORE_LOCATION,
                pStoreName: ?*?PWSTR,
                ppCertHashBlob: ?*[20]?*u8,
                pSubjectName: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyJobHttpOptions,
                pStoreLocation: ?*BG_CERT_STORE_LOCATION,
                pStoreName: ?*?PWSTR,
                ppCertHashBlob: ?*[20]?*u8,
                pSubjectName: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCustomHeaders: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyJobHttpOptions,
                RequestHeaders: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyJobHttpOptions,
                RequestHeaders: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCustomHeaders: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyJobHttpOptions,
                pRequestHeaders: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyJobHttpOptions,
                pRequestHeaders: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSecurityFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyJobHttpOptions,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyJobHttpOptions,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSecurityFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyJobHttpOptions,
                pFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyJobHttpOptions,
                pFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyJobHttpOptions_SetClientCertificateByID(self: *const T, StoreLocation: BG_CERT_STORE_LOCATION, StoreName: ?[*:0]const u16, pCertHashBlob: *[20]u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyJobHttpOptions.VTable, self.vtable).SetClientCertificateByID(@ptrCast(*const IBackgroundCopyJobHttpOptions, self), StoreLocation, StoreName, pCertHashBlob);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyJobHttpOptions_SetClientCertificateByName(self: *const T, StoreLocation: BG_CERT_STORE_LOCATION, StoreName: ?[*:0]const u16, SubjectName: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyJobHttpOptions.VTable, self.vtable).SetClientCertificateByName(@ptrCast(*const IBackgroundCopyJobHttpOptions, self), StoreLocation, StoreName, SubjectName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyJobHttpOptions_RemoveClientCertificate(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyJobHttpOptions.VTable, self.vtable).RemoveClientCertificate(@ptrCast(*const IBackgroundCopyJobHttpOptions, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyJobHttpOptions_GetClientCertificate(self: *const T, pStoreLocation: ?*BG_CERT_STORE_LOCATION, pStoreName: ?*?PWSTR, ppCertHashBlob: ?*[20]?*u8, pSubjectName: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyJobHttpOptions.VTable, self.vtable).GetClientCertificate(@ptrCast(*const IBackgroundCopyJobHttpOptions, self), pStoreLocation, pStoreName, ppCertHashBlob, pSubjectName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyJobHttpOptions_SetCustomHeaders(self: *const T, RequestHeaders: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyJobHttpOptions.VTable, self.vtable).SetCustomHeaders(@ptrCast(*const IBackgroundCopyJobHttpOptions, self), RequestHeaders);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyJobHttpOptions_GetCustomHeaders(self: *const T, pRequestHeaders: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyJobHttpOptions.VTable, self.vtable).GetCustomHeaders(@ptrCast(*const IBackgroundCopyJobHttpOptions, self), pRequestHeaders);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyJobHttpOptions_SetSecurityFlags(self: *const T, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyJobHttpOptions.VTable, self.vtable).SetSecurityFlags(@ptrCast(*const IBackgroundCopyJobHttpOptions, self), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyJobHttpOptions_GetSecurityFlags(self: *const T, pFlags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyJobHttpOptions.VTable, self.vtable).GetSecurityFlags(@ptrCast(*const IBackgroundCopyJobHttpOptions, self), pFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const CLSID_BackgroundCopyManager3_0_Value = Guid.initString("659cdea7-489e-11d9-a9cd-000d56965251");
pub const CLSID_BackgroundCopyManager3_0 = &CLSID_BackgroundCopyManager3_0_Value;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IBitsPeerCacheRecord_Value = Guid.initString("659cdeaf-489e-11d9-a9cd-000d56965251");
pub const IID_IBitsPeerCacheRecord = &IID_IBitsPeerCacheRecord_Value;
pub const IBitsPeerCacheRecord = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBitsPeerCacheRecord,
                pVal: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBitsPeerCacheRecord,
                pVal: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOriginUrl: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBitsPeerCacheRecord,
                pVal: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBitsPeerCacheRecord,
                pVal: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFileSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBitsPeerCacheRecord,
                pVal: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBitsPeerCacheRecord,
                pVal: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFileModificationTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBitsPeerCacheRecord,
                pVal: ?*FILETIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBitsPeerCacheRecord,
                pVal: ?*FILETIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLastAccessTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBitsPeerCacheRecord,
                pVal: ?*FILETIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBitsPeerCacheRecord,
                pVal: ?*FILETIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsFileValidated: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBitsPeerCacheRecord,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBitsPeerCacheRecord,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFileRanges: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBitsPeerCacheRecord,
                pRangeCount: ?*u32,
                ppRanges: [*]?*BG_FILE_RANGE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBitsPeerCacheRecord,
                pRangeCount: ?*u32,
                ppRanges: [*]?*BG_FILE_RANGE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBitsPeerCacheRecord_GetId(self: *const T, pVal: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBitsPeerCacheRecord.VTable, self.vtable).GetId(@ptrCast(*const IBitsPeerCacheRecord, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBitsPeerCacheRecord_GetOriginUrl(self: *const T, pVal: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBitsPeerCacheRecord.VTable, self.vtable).GetOriginUrl(@ptrCast(*const IBitsPeerCacheRecord, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBitsPeerCacheRecord_GetFileSize(self: *const T, pVal: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBitsPeerCacheRecord.VTable, self.vtable).GetFileSize(@ptrCast(*const IBitsPeerCacheRecord, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBitsPeerCacheRecord_GetFileModificationTime(self: *const T, pVal: ?*FILETIME) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBitsPeerCacheRecord.VTable, self.vtable).GetFileModificationTime(@ptrCast(*const IBitsPeerCacheRecord, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBitsPeerCacheRecord_GetLastAccessTime(self: *const T, pVal: ?*FILETIME) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBitsPeerCacheRecord.VTable, self.vtable).GetLastAccessTime(@ptrCast(*const IBitsPeerCacheRecord, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBitsPeerCacheRecord_IsFileValidated(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBitsPeerCacheRecord.VTable, self.vtable).IsFileValidated(@ptrCast(*const IBitsPeerCacheRecord, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBitsPeerCacheRecord_GetFileRanges(self: *const T, pRangeCount: ?*u32, ppRanges: [*]?*BG_FILE_RANGE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBitsPeerCacheRecord.VTable, self.vtable).GetFileRanges(@ptrCast(*const IBitsPeerCacheRecord, self), pRangeCount, ppRanges);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IEnumBitsPeerCacheRecords_Value = Guid.initString("659cdea4-489e-11d9-a9cd-000d56965251");
pub const IID_IEnumBitsPeerCacheRecords = &IID_IEnumBitsPeerCacheRecords_Value;
pub const IEnumBitsPeerCacheRecords = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumBitsPeerCacheRecords,
                celt: u32,
                rgelt: ?*?*IBitsPeerCacheRecord,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumBitsPeerCacheRecords,
                celt: u32,
                rgelt: ?*?*IBitsPeerCacheRecord,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumBitsPeerCacheRecords,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumBitsPeerCacheRecords,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumBitsPeerCacheRecords,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumBitsPeerCacheRecords,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumBitsPeerCacheRecords,
                ppenum: ?*?*IEnumBitsPeerCacheRecords,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumBitsPeerCacheRecords,
                ppenum: ?*?*IEnumBitsPeerCacheRecords,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumBitsPeerCacheRecords,
                puCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumBitsPeerCacheRecords,
                puCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumBitsPeerCacheRecords_Next(self: *const T, celt: u32, rgelt: ?*?*IBitsPeerCacheRecord, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumBitsPeerCacheRecords.VTable, self.vtable).Next(@ptrCast(*const IEnumBitsPeerCacheRecords, self), celt, rgelt, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumBitsPeerCacheRecords_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumBitsPeerCacheRecords.VTable, self.vtable).Skip(@ptrCast(*const IEnumBitsPeerCacheRecords, self), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumBitsPeerCacheRecords_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumBitsPeerCacheRecords.VTable, self.vtable).Reset(@ptrCast(*const IEnumBitsPeerCacheRecords, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumBitsPeerCacheRecords_Clone(self: *const T, ppenum: ?*?*IEnumBitsPeerCacheRecords) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumBitsPeerCacheRecords.VTable, self.vtable).Clone(@ptrCast(*const IEnumBitsPeerCacheRecords, self), ppenum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumBitsPeerCacheRecords_GetCount(self: *const T, puCount: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumBitsPeerCacheRecords.VTable, self.vtable).GetCount(@ptrCast(*const IEnumBitsPeerCacheRecords, self), puCount);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IBitsPeer_Value = Guid.initString("659cdea2-489e-11d9-a9cd-000d56965251");
pub const IID_IBitsPeer = &IID_IBitsPeer_Value;
pub const IBitsPeer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPeerName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBitsPeer,
                pName: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBitsPeer,
                pName: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsAuthenticated: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBitsPeer,
                pAuth: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBitsPeer,
                pAuth: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsAvailable: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBitsPeer,
                pOnline: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBitsPeer,
                pOnline: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBitsPeer_GetPeerName(self: *const T, pName: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBitsPeer.VTable, self.vtable).GetPeerName(@ptrCast(*const IBitsPeer, self), pName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBitsPeer_IsAuthenticated(self: *const T, pAuth: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBitsPeer.VTable, self.vtable).IsAuthenticated(@ptrCast(*const IBitsPeer, self), pAuth);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBitsPeer_IsAvailable(self: *const T, pOnline: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBitsPeer.VTable, self.vtable).IsAvailable(@ptrCast(*const IBitsPeer, self), pOnline);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IEnumBitsPeers_Value = Guid.initString("659cdea5-489e-11d9-a9cd-000d56965251");
pub const IID_IEnumBitsPeers = &IID_IEnumBitsPeers_Value;
pub const IEnumBitsPeers = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumBitsPeers,
                celt: u32,
                rgelt: ?*?*IBitsPeer,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumBitsPeers,
                celt: u32,
                rgelt: ?*?*IBitsPeer,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumBitsPeers,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumBitsPeers,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumBitsPeers,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumBitsPeers,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumBitsPeers,
                ppenum: ?*?*IEnumBitsPeers,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumBitsPeers,
                ppenum: ?*?*IEnumBitsPeers,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumBitsPeers,
                puCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumBitsPeers,
                puCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumBitsPeers_Next(self: *const T, celt: u32, rgelt: ?*?*IBitsPeer, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumBitsPeers.VTable, self.vtable).Next(@ptrCast(*const IEnumBitsPeers, self), celt, rgelt, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumBitsPeers_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumBitsPeers.VTable, self.vtable).Skip(@ptrCast(*const IEnumBitsPeers, self), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumBitsPeers_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumBitsPeers.VTable, self.vtable).Reset(@ptrCast(*const IEnumBitsPeers, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumBitsPeers_Clone(self: *const T, ppenum: ?*?*IEnumBitsPeers) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumBitsPeers.VTable, self.vtable).Clone(@ptrCast(*const IEnumBitsPeers, self), ppenum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumBitsPeers_GetCount(self: *const T, puCount: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumBitsPeers.VTable, self.vtable).GetCount(@ptrCast(*const IEnumBitsPeers, self), puCount);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IBitsPeerCacheAdministration_Value = Guid.initString("659cdead-489e-11d9-a9cd-000d56965251");
pub const IID_IBitsPeerCacheAdministration = &IID_IBitsPeerCacheAdministration_Value;
pub const IBitsPeerCacheAdministration = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetMaximumCacheSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBitsPeerCacheAdministration,
                pBytes: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBitsPeerCacheAdministration,
                pBytes: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetMaximumCacheSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBitsPeerCacheAdministration,
                Bytes: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBitsPeerCacheAdministration,
                Bytes: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMaximumContentAge: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBitsPeerCacheAdministration,
                pSeconds: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBitsPeerCacheAdministration,
                pSeconds: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetMaximumContentAge: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBitsPeerCacheAdministration,
                Seconds: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBitsPeerCacheAdministration,
                Seconds: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetConfigurationFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBitsPeerCacheAdministration,
                pFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBitsPeerCacheAdministration,
                pFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetConfigurationFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBitsPeerCacheAdministration,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBitsPeerCacheAdministration,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumRecords: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBitsPeerCacheAdministration,
                ppEnum: ?*?*IEnumBitsPeerCacheRecords,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBitsPeerCacheAdministration,
                ppEnum: ?*?*IEnumBitsPeerCacheRecords,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecord: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBitsPeerCacheAdministration,
                id: ?*const Guid,
                ppRecord: ?*?*IBitsPeerCacheRecord,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBitsPeerCacheAdministration,
                id: ?*const Guid,
                ppRecord: ?*?*IBitsPeerCacheRecord,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ClearRecords: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBitsPeerCacheAdministration,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBitsPeerCacheAdministration,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeleteRecord: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBitsPeerCacheAdministration,
                id: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBitsPeerCacheAdministration,
                id: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeleteUrl: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBitsPeerCacheAdministration,
                url: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBitsPeerCacheAdministration,
                url: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumPeers: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBitsPeerCacheAdministration,
                ppEnum: ?*?*IEnumBitsPeers,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBitsPeerCacheAdministration,
                ppEnum: ?*?*IEnumBitsPeers,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ClearPeers: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBitsPeerCacheAdministration,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBitsPeerCacheAdministration,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DiscoverPeers: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBitsPeerCacheAdministration,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBitsPeerCacheAdministration,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBitsPeerCacheAdministration_GetMaximumCacheSize(self: *const T, pBytes: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBitsPeerCacheAdministration.VTable, self.vtable).GetMaximumCacheSize(@ptrCast(*const IBitsPeerCacheAdministration, self), pBytes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBitsPeerCacheAdministration_SetMaximumCacheSize(self: *const T, Bytes: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBitsPeerCacheAdministration.VTable, self.vtable).SetMaximumCacheSize(@ptrCast(*const IBitsPeerCacheAdministration, self), Bytes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBitsPeerCacheAdministration_GetMaximumContentAge(self: *const T, pSeconds: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBitsPeerCacheAdministration.VTable, self.vtable).GetMaximumContentAge(@ptrCast(*const IBitsPeerCacheAdministration, self), pSeconds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBitsPeerCacheAdministration_SetMaximumContentAge(self: *const T, Seconds: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBitsPeerCacheAdministration.VTable, self.vtable).SetMaximumContentAge(@ptrCast(*const IBitsPeerCacheAdministration, self), Seconds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBitsPeerCacheAdministration_GetConfigurationFlags(self: *const T, pFlags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBitsPeerCacheAdministration.VTable, self.vtable).GetConfigurationFlags(@ptrCast(*const IBitsPeerCacheAdministration, self), pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBitsPeerCacheAdministration_SetConfigurationFlags(self: *const T, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBitsPeerCacheAdministration.VTable, self.vtable).SetConfigurationFlags(@ptrCast(*const IBitsPeerCacheAdministration, self), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBitsPeerCacheAdministration_EnumRecords(self: *const T, ppEnum: ?*?*IEnumBitsPeerCacheRecords) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBitsPeerCacheAdministration.VTable, self.vtable).EnumRecords(@ptrCast(*const IBitsPeerCacheAdministration, self), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBitsPeerCacheAdministration_GetRecord(self: *const T, id: ?*const Guid, ppRecord: ?*?*IBitsPeerCacheRecord) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBitsPeerCacheAdministration.VTable, self.vtable).GetRecord(@ptrCast(*const IBitsPeerCacheAdministration, self), id, ppRecord);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBitsPeerCacheAdministration_ClearRecords(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBitsPeerCacheAdministration.VTable, self.vtable).ClearRecords(@ptrCast(*const IBitsPeerCacheAdministration, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBitsPeerCacheAdministration_DeleteRecord(self: *const T, id: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBitsPeerCacheAdministration.VTable, self.vtable).DeleteRecord(@ptrCast(*const IBitsPeerCacheAdministration, self), id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBitsPeerCacheAdministration_DeleteUrl(self: *const T, url: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBitsPeerCacheAdministration.VTable, self.vtable).DeleteUrl(@ptrCast(*const IBitsPeerCacheAdministration, self), url);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBitsPeerCacheAdministration_EnumPeers(self: *const T, ppEnum: ?*?*IEnumBitsPeers) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBitsPeerCacheAdministration.VTable, self.vtable).EnumPeers(@ptrCast(*const IBitsPeerCacheAdministration, self), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBitsPeerCacheAdministration_ClearPeers(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBitsPeerCacheAdministration.VTable, self.vtable).ClearPeers(@ptrCast(*const IBitsPeerCacheAdministration, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBitsPeerCacheAdministration_DiscoverPeers(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBitsPeerCacheAdministration.VTable, self.vtable).DiscoverPeers(@ptrCast(*const IBitsPeerCacheAdministration, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IBackgroundCopyJob4_Value = Guid.initString("659cdeae-489e-11d9-a9cd-000d56965251");
pub const IID_IBackgroundCopyJob4 = &IID_IBackgroundCopyJob4_Value;
pub const IBackgroundCopyJob4 = extern struct {
    pub const VTable = extern struct {
        base: IBackgroundCopyJob3.VTable,
        SetPeerCachingFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyJob4,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyJob4,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPeerCachingFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyJob4,
                pFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyJob4,
                pFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOwnerIntegrityLevel: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyJob4,
                pLevel: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyJob4,
                pLevel: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOwnerElevationState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyJob4,
                pElevated: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyJob4,
                pElevated: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetMaximumDownloadTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyJob4,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyJob4,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMaximumDownloadTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyJob4,
                pTimeout: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyJob4,
                pTimeout: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IBackgroundCopyJob3.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyJob4_SetPeerCachingFlags(self: *const T, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyJob4.VTable, self.vtable).SetPeerCachingFlags(@ptrCast(*const IBackgroundCopyJob4, self), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyJob4_GetPeerCachingFlags(self: *const T, pFlags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyJob4.VTable, self.vtable).GetPeerCachingFlags(@ptrCast(*const IBackgroundCopyJob4, self), pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyJob4_GetOwnerIntegrityLevel(self: *const T, pLevel: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyJob4.VTable, self.vtable).GetOwnerIntegrityLevel(@ptrCast(*const IBackgroundCopyJob4, self), pLevel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyJob4_GetOwnerElevationState(self: *const T, pElevated: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyJob4.VTable, self.vtable).GetOwnerElevationState(@ptrCast(*const IBackgroundCopyJob4, self), pElevated);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyJob4_SetMaximumDownloadTime(self: *const T, Timeout: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyJob4.VTable, self.vtable).SetMaximumDownloadTime(@ptrCast(*const IBackgroundCopyJob4, self), Timeout);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyJob4_GetMaximumDownloadTime(self: *const T, pTimeout: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyJob4.VTable, self.vtable).GetMaximumDownloadTime(@ptrCast(*const IBackgroundCopyJob4, self), pTimeout);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IBackgroundCopyFile3_Value = Guid.initString("659cdeaa-489e-11d9-a9cd-000d56965251");
pub const IID_IBackgroundCopyFile3 = &IID_IBackgroundCopyFile3_Value;
pub const IBackgroundCopyFile3 = extern struct {
    pub const VTable = extern struct {
        base: IBackgroundCopyFile2.VTable,
        GetTemporaryName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyFile3,
                pFilename: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyFile3,
                pFilename: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetValidationState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyFile3,
                state: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyFile3,
                state: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetValidationState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyFile3,
                pState: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyFile3,
                pState: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsDownloadedFromPeer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyFile3,
                pVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyFile3,
                pVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IBackgroundCopyFile2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyFile3_GetTemporaryName(self: *const T, pFilename: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyFile3.VTable, self.vtable).GetTemporaryName(@ptrCast(*const IBackgroundCopyFile3, self), pFilename);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyFile3_SetValidationState(self: *const T, state: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyFile3.VTable, self.vtable).SetValidationState(@ptrCast(*const IBackgroundCopyFile3, self), state);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyFile3_GetValidationState(self: *const T, pState: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyFile3.VTable, self.vtable).GetValidationState(@ptrCast(*const IBackgroundCopyFile3, self), pState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyFile3_IsDownloadedFromPeer(self: *const T, pVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyFile3.VTable, self.vtable).IsDownloadedFromPeer(@ptrCast(*const IBackgroundCopyFile3, self), pVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IBackgroundCopyCallback2_Value = Guid.initString("659cdeac-489e-11d9-a9cd-000d56965251");
pub const IID_IBackgroundCopyCallback2 = &IID_IBackgroundCopyCallback2_Value;
pub const IBackgroundCopyCallback2 = extern struct {
    pub const VTable = extern struct {
        base: IBackgroundCopyCallback.VTable,
        FileTransferred: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyCallback2,
                pJob: ?*IBackgroundCopyJob,
                pFile: ?*IBackgroundCopyFile,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyCallback2,
                pJob: ?*IBackgroundCopyJob,
                pFile: ?*IBackgroundCopyFile,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IBackgroundCopyCallback.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyCallback2_FileTransferred(self: *const T, pJob: ?*IBackgroundCopyJob, pFile: ?*IBackgroundCopyFile) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyCallback2.VTable, self.vtable).FileTransferred(@ptrCast(*const IBackgroundCopyCallback2, self), pJob, pFile);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const CLSID_BackgroundCopyManager4_0_Value = Guid.initString("bb6df56b-cace-11dc-9992-0019b93a3a84");
pub const CLSID_BackgroundCopyManager4_0 = &CLSID_BackgroundCopyManager4_0_Value;

// TODO: this type is limited to platform 'windows6.1'
const IID_IBitsTokenOptions_Value = Guid.initString("9a2584c3-f7d2-457a-9a5e-22b67bffc7d2");
pub const IID_IBitsTokenOptions = &IID_IBitsTokenOptions_Value;
pub const IBitsTokenOptions = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetHelperTokenFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBitsTokenOptions,
                UsageFlags: BG_TOKEN,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBitsTokenOptions,
                UsageFlags: BG_TOKEN,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetHelperTokenFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBitsTokenOptions,
                pFlags: ?*BG_TOKEN,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBitsTokenOptions,
                pFlags: ?*BG_TOKEN,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetHelperToken: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBitsTokenOptions,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBitsTokenOptions,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ClearHelperToken: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBitsTokenOptions,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBitsTokenOptions,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetHelperTokenSid: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBitsTokenOptions,
                pSid: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBitsTokenOptions,
                pSid: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBitsTokenOptions_SetHelperTokenFlags(self: *const T, UsageFlags: BG_TOKEN) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBitsTokenOptions.VTable, self.vtable).SetHelperTokenFlags(@ptrCast(*const IBitsTokenOptions, self), UsageFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBitsTokenOptions_GetHelperTokenFlags(self: *const T, pFlags: ?*BG_TOKEN) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBitsTokenOptions.VTable, self.vtable).GetHelperTokenFlags(@ptrCast(*const IBitsTokenOptions, self), pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBitsTokenOptions_SetHelperToken(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBitsTokenOptions.VTable, self.vtable).SetHelperToken(@ptrCast(*const IBitsTokenOptions, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBitsTokenOptions_ClearHelperToken(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBitsTokenOptions.VTable, self.vtable).ClearHelperToken(@ptrCast(*const IBitsTokenOptions, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBitsTokenOptions_GetHelperTokenSid(self: *const T, pSid: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBitsTokenOptions.VTable, self.vtable).GetHelperTokenSid(@ptrCast(*const IBitsTokenOptions, self), pSid);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IBackgroundCopyFile4_Value = Guid.initString("ef7e0655-7888-4960-b0e5-730846e03492");
pub const IID_IBackgroundCopyFile4 = &IID_IBackgroundCopyFile4_Value;
pub const IBackgroundCopyFile4 = extern struct {
    pub const VTable = extern struct {
        base: IBackgroundCopyFile3.VTable,
        GetPeerDownloadStats: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyFile4,
                pFromOrigin: ?*u64,
                pFromPeers: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyFile4,
                pFromOrigin: ?*u64,
                pFromPeers: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IBackgroundCopyFile3.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyFile4_GetPeerDownloadStats(self: *const T, pFromOrigin: ?*u64, pFromPeers: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyFile4.VTable, self.vtable).GetPeerDownloadStats(@ptrCast(*const IBackgroundCopyFile4, self), pFromOrigin, pFromPeers);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const CLSID_BackgroundCopyManager5_0_Value = Guid.initString("1ecca34c-e88a-44e3-8d6a-8921bde9e452");
pub const CLSID_BackgroundCopyManager5_0 = &CLSID_BackgroundCopyManager5_0_Value;

pub const BITS_JOB_TRANSFER_POLICY = enum(i32) {
    ALWAYS = -2147483393,
    NOT_ROAMING = -2147483521,
    NO_SURCHARGE = -2147483537,
    STANDARD = -2147483545,
    UNRESTRICTED = -2147483615,
};
pub const BITS_JOB_TRANSFER_POLICY_ALWAYS = BITS_JOB_TRANSFER_POLICY.ALWAYS;
pub const BITS_JOB_TRANSFER_POLICY_NOT_ROAMING = BITS_JOB_TRANSFER_POLICY.NOT_ROAMING;
pub const BITS_JOB_TRANSFER_POLICY_NO_SURCHARGE = BITS_JOB_TRANSFER_POLICY.NO_SURCHARGE;
pub const BITS_JOB_TRANSFER_POLICY_STANDARD = BITS_JOB_TRANSFER_POLICY.STANDARD;
pub const BITS_JOB_TRANSFER_POLICY_UNRESTRICTED = BITS_JOB_TRANSFER_POLICY.UNRESTRICTED;

pub const BITS_JOB_PROPERTY_ID = enum(i32) {
    ID_COST_FLAGS = 1,
    NOTIFICATION_CLSID = 2,
    DYNAMIC_CONTENT = 3,
    HIGH_PERFORMANCE = 4,
    MAX_DOWNLOAD_SIZE = 5,
    USE_STORED_CREDENTIALS = 7,
    MINIMUM_NOTIFICATION_INTERVAL_MS = 9,
    ON_DEMAND_MODE = 10,
};
pub const BITS_JOB_PROPERTY_ID_COST_FLAGS = BITS_JOB_PROPERTY_ID.ID_COST_FLAGS;
pub const BITS_JOB_PROPERTY_NOTIFICATION_CLSID = BITS_JOB_PROPERTY_ID.NOTIFICATION_CLSID;
pub const BITS_JOB_PROPERTY_DYNAMIC_CONTENT = BITS_JOB_PROPERTY_ID.DYNAMIC_CONTENT;
pub const BITS_JOB_PROPERTY_HIGH_PERFORMANCE = BITS_JOB_PROPERTY_ID.HIGH_PERFORMANCE;
pub const BITS_JOB_PROPERTY_MAX_DOWNLOAD_SIZE = BITS_JOB_PROPERTY_ID.MAX_DOWNLOAD_SIZE;
pub const BITS_JOB_PROPERTY_USE_STORED_CREDENTIALS = BITS_JOB_PROPERTY_ID.USE_STORED_CREDENTIALS;
pub const BITS_JOB_PROPERTY_MINIMUM_NOTIFICATION_INTERVAL_MS = BITS_JOB_PROPERTY_ID.MINIMUM_NOTIFICATION_INTERVAL_MS;
pub const BITS_JOB_PROPERTY_ON_DEMAND_MODE = BITS_JOB_PROPERTY_ID.ON_DEMAND_MODE;

pub const BITS_JOB_PROPERTY_VALUE = extern union {
    Dword: u32,
    ClsID: Guid,
    Enable: BOOL,
    Uint64: u64,
    Target: BG_AUTH_TARGET,
};

pub const BITS_FILE_PROPERTY_ID = enum(i32) {
    S = 1,
};
pub const BITS_FILE_PROPERTY_ID_HTTP_RESPONSE_HEADERS = BITS_FILE_PROPERTY_ID.S;

pub const BITS_FILE_PROPERTY_VALUE = extern union {
    String: ?PWSTR,
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IBackgroundCopyJob5_Value = Guid.initString("e847030c-bbba-4657-af6d-484aa42bf1fe");
pub const IID_IBackgroundCopyJob5 = &IID_IBackgroundCopyJob5_Value;
pub const IBackgroundCopyJob5 = extern struct {
    pub const VTable = extern struct {
        base: IBackgroundCopyJob4.VTable,
        SetProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyJob5,
                PropertyId: BITS_JOB_PROPERTY_ID,
                PropertyValue: BITS_JOB_PROPERTY_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyJob5,
                PropertyId: BITS_JOB_PROPERTY_ID,
                PropertyValue: BITS_JOB_PROPERTY_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyJob5,
                PropertyId: BITS_JOB_PROPERTY_ID,
                PropertyValue: ?*BITS_JOB_PROPERTY_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyJob5,
                PropertyId: BITS_JOB_PROPERTY_ID,
                PropertyValue: ?*BITS_JOB_PROPERTY_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IBackgroundCopyJob4.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyJob5_SetProperty(self: *const T, PropertyId: BITS_JOB_PROPERTY_ID, PropertyValue: BITS_JOB_PROPERTY_VALUE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyJob5.VTable, self.vtable).SetProperty(@ptrCast(*const IBackgroundCopyJob5, self), PropertyId, PropertyValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyJob5_GetProperty(self: *const T, PropertyId: BITS_JOB_PROPERTY_ID, PropertyValue: ?*BITS_JOB_PROPERTY_VALUE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyJob5.VTable, self.vtable).GetProperty(@ptrCast(*const IBackgroundCopyJob5, self), PropertyId, PropertyValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IBackgroundCopyFile5_Value = Guid.initString("85c1657f-dafc-40e8-8834-df18ea25717e");
pub const IID_IBackgroundCopyFile5 = &IID_IBackgroundCopyFile5_Value;
pub const IBackgroundCopyFile5 = extern struct {
    pub const VTable = extern struct {
        base: IBackgroundCopyFile4.VTable,
        SetProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyFile5,
                PropertyId: BITS_FILE_PROPERTY_ID,
                PropertyValue: BITS_FILE_PROPERTY_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyFile5,
                PropertyId: BITS_FILE_PROPERTY_ID,
                PropertyValue: BITS_FILE_PROPERTY_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyFile5,
                PropertyId: BITS_FILE_PROPERTY_ID,
                PropertyValue: ?*BITS_FILE_PROPERTY_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyFile5,
                PropertyId: BITS_FILE_PROPERTY_ID,
                PropertyValue: ?*BITS_FILE_PROPERTY_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IBackgroundCopyFile4.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyFile5_SetProperty(self: *const T, PropertyId: BITS_FILE_PROPERTY_ID, PropertyValue: BITS_FILE_PROPERTY_VALUE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyFile5.VTable, self.vtable).SetProperty(@ptrCast(*const IBackgroundCopyFile5, self), PropertyId, PropertyValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyFile5_GetProperty(self: *const T, PropertyId: BITS_FILE_PROPERTY_ID, PropertyValue: ?*BITS_FILE_PROPERTY_VALUE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyFile5.VTable, self.vtable).GetProperty(@ptrCast(*const IBackgroundCopyFile5, self), PropertyId, PropertyValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const CLSID_BackgroundCopyManager10_1_Value = Guid.initString("4bd3e4e1-7bd4-4a2b-9964-496400de5193");
pub const CLSID_BackgroundCopyManager10_1 = &CLSID_BackgroundCopyManager10_1_Value;

// TODO: this type is limited to platform 'windows10.0.15063'
const IID_IBackgroundCopyCallback3_Value = Guid.initString("98c97bd2-e32b-4ad8-a528-95fd8b16bd42");
pub const IID_IBackgroundCopyCallback3 = &IID_IBackgroundCopyCallback3_Value;
pub const IBackgroundCopyCallback3 = extern struct {
    pub const VTable = extern struct {
        base: IBackgroundCopyCallback2.VTable,
        FileRangesTransferred: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyCallback3,
                job: ?*IBackgroundCopyJob,
                file: ?*IBackgroundCopyFile,
                rangeCount: u32,
                ranges: [*]const BG_FILE_RANGE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyCallback3,
                job: ?*IBackgroundCopyJob,
                file: ?*IBackgroundCopyFile,
                rangeCount: u32,
                ranges: [*]const BG_FILE_RANGE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IBackgroundCopyCallback2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyCallback3_FileRangesTransferred(self: *const T, job: ?*IBackgroundCopyJob, file: ?*IBackgroundCopyFile, rangeCount: u32, ranges: [*]const BG_FILE_RANGE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyCallback3.VTable, self.vtable).FileRangesTransferred(@ptrCast(*const IBackgroundCopyCallback3, self), job, file, rangeCount, ranges);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.15063'
const IID_IBackgroundCopyFile6_Value = Guid.initString("cf6784f7-d677-49fd-9368-cb47aee9d1ad");
pub const IID_IBackgroundCopyFile6 = &IID_IBackgroundCopyFile6_Value;
pub const IBackgroundCopyFile6 = extern struct {
    pub const VTable = extern struct {
        base: IBackgroundCopyFile5.VTable,
        UpdateDownloadPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyFile6,
                offset: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyFile6,
                offset: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RequestFileRanges: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyFile6,
                rangeCount: u32,
                ranges: [*]const BG_FILE_RANGE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyFile6,
                rangeCount: u32,
                ranges: [*]const BG_FILE_RANGE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFilledFileRanges: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyFile6,
                rangeCount: ?*u32,
                ranges: [*]?*BG_FILE_RANGE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyFile6,
                rangeCount: ?*u32,
                ranges: [*]?*BG_FILE_RANGE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IBackgroundCopyFile5.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyFile6_UpdateDownloadPosition(self: *const T, offset: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyFile6.VTable, self.vtable).UpdateDownloadPosition(@ptrCast(*const IBackgroundCopyFile6, self), offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyFile6_RequestFileRanges(self: *const T, rangeCount: u32, ranges: [*]const BG_FILE_RANGE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyFile6.VTable, self.vtable).RequestFileRanges(@ptrCast(*const IBackgroundCopyFile6, self), rangeCount, ranges);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyFile6_GetFilledFileRanges(self: *const T, rangeCount: ?*u32, ranges: [*]?*BG_FILE_RANGE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyFile6.VTable, self.vtable).GetFilledFileRanges(@ptrCast(*const IBackgroundCopyFile6, self), rangeCount, ranges);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const CLSID_BackgroundCopyManager10_2_Value = Guid.initString("4575438f-a6c8-4976-b0fe-2f26b80d959e");
pub const CLSID_BackgroundCopyManager10_2 = &CLSID_BackgroundCopyManager10_2_Value;

// TODO: this type is limited to platform 'windows10.0.17763'
const IID_IBackgroundCopyJobHttpOptions2_Value = Guid.initString("b591a192-a405-4fc3-8323-4c5c542578fc");
pub const IID_IBackgroundCopyJobHttpOptions2 = &IID_IBackgroundCopyJobHttpOptions2_Value;
pub const IBackgroundCopyJobHttpOptions2 = extern struct {
    pub const VTable = extern struct {
        base: IBackgroundCopyJobHttpOptions.VTable,
        SetHttpMethod: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyJobHttpOptions2,
                method: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyJobHttpOptions2,
                method: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetHttpMethod: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyJobHttpOptions2,
                method: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyJobHttpOptions2,
                method: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IBackgroundCopyJobHttpOptions.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyJobHttpOptions2_SetHttpMethod(self: *const T, method: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyJobHttpOptions2.VTable, self.vtable).SetHttpMethod(@ptrCast(*const IBackgroundCopyJobHttpOptions2, self), method);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyJobHttpOptions2_GetHttpMethod(self: *const T, method: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyJobHttpOptions2.VTable, self.vtable).GetHttpMethod(@ptrCast(*const IBackgroundCopyJobHttpOptions2, self), method);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const CLSID_BackgroundCopyManager10_3_Value = Guid.initString("5fd42ad5-c04e-4d36-adc7-e08ff15737ad");
pub const CLSID_BackgroundCopyManager10_3 = &CLSID_BackgroundCopyManager10_3_Value;

const IID_IBackgroundCopyServerCertificateValidationCallback_Value = Guid.initString("4cec0d02-def7-4158-813a-c32a46945ff7");
pub const IID_IBackgroundCopyServerCertificateValidationCallback = &IID_IBackgroundCopyServerCertificateValidationCallback_Value;
pub const IBackgroundCopyServerCertificateValidationCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ValidateServerCertificate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyServerCertificateValidationCallback,
                job: ?*IBackgroundCopyJob,
                file: ?*IBackgroundCopyFile,
                certLength: u32,
                certData: [*:0]const u8,
                certEncodingType: u32,
                certStoreLength: u32,
                certStoreData: [*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyServerCertificateValidationCallback,
                job: ?*IBackgroundCopyJob,
                file: ?*IBackgroundCopyFile,
                certLength: u32,
                certData: [*:0]const u8,
                certEncodingType: u32,
                certStoreLength: u32,
                certStoreData: [*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyServerCertificateValidationCallback_ValidateServerCertificate(self: *const T, job: ?*IBackgroundCopyJob, file: ?*IBackgroundCopyFile, certLength: u32, certData: [*:0]const u8, certEncodingType: u32, certStoreLength: u32, certStoreData: [*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyServerCertificateValidationCallback.VTable, self.vtable).ValidateServerCertificate(@ptrCast(*const IBackgroundCopyServerCertificateValidationCallback, self), job, file, certLength, certData, certEncodingType, certStoreLength, certStoreData);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IBackgroundCopyJobHttpOptions3_Value = Guid.initString("8a9263d3-fd4c-4eda-9b28-30132a4d4e3c");
pub const IID_IBackgroundCopyJobHttpOptions3 = &IID_IBackgroundCopyJobHttpOptions3_Value;
pub const IBackgroundCopyJobHttpOptions3 = extern struct {
    pub const VTable = extern struct {
        base: IBackgroundCopyJobHttpOptions2.VTable,
        SetServerCertificateValidationInterface: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyJobHttpOptions3,
                certValidationCallback: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyJobHttpOptions3,
                certValidationCallback: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        MakeCustomHeadersWriteOnly: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyJobHttpOptions3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyJobHttpOptions3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IBackgroundCopyJobHttpOptions2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyJobHttpOptions3_SetServerCertificateValidationInterface(self: *const T, certValidationCallback: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyJobHttpOptions3.VTable, self.vtable).SetServerCertificateValidationInterface(@ptrCast(*const IBackgroundCopyJobHttpOptions3, self), certValidationCallback);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyJobHttpOptions3_MakeCustomHeadersWriteOnly(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyJobHttpOptions3.VTable, self.vtable).MakeCustomHeadersWriteOnly(@ptrCast(*const IBackgroundCopyJobHttpOptions3, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const CLSID_BITSExtensionSetupFactory_Value = Guid.initString("efbbab68-7286-4783-94bf-9461d8b7e7e9");
pub const CLSID_BITSExtensionSetupFactory = &CLSID_BITSExtensionSetupFactory_Value;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IBITSExtensionSetup_Value = Guid.initString("29cfbbf7-09e4-4b97-b0bc-f2287e3d8eb3");
pub const IID_IBITSExtensionSetup = &IID_IBITSExtensionSetup_Value;
pub const IBITSExtensionSetup = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        EnableBITSUploads: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBITSExtensionSetup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBITSExtensionSetup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DisableBITSUploads: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBITSExtensionSetup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBITSExtensionSetup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCleanupTaskName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBITSExtensionSetup,
                pTaskName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBITSExtensionSetup,
                pTaskName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCleanupTask: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBITSExtensionSetup,
                riid: ?*const Guid,
                ppUnk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBITSExtensionSetup,
                riid: ?*const Guid,
                ppUnk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBITSExtensionSetup_EnableBITSUploads(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBITSExtensionSetup.VTable, self.vtable).EnableBITSUploads(@ptrCast(*const IBITSExtensionSetup, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBITSExtensionSetup_DisableBITSUploads(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBITSExtensionSetup.VTable, self.vtable).DisableBITSUploads(@ptrCast(*const IBITSExtensionSetup, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBITSExtensionSetup_GetCleanupTaskName(self: *const T, pTaskName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBITSExtensionSetup.VTable, self.vtable).GetCleanupTaskName(@ptrCast(*const IBITSExtensionSetup, self), pTaskName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBITSExtensionSetup_GetCleanupTask(self: *const T, riid: ?*const Guid, ppUnk: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBITSExtensionSetup.VTable, self.vtable).GetCleanupTask(@ptrCast(*const IBITSExtensionSetup, self), riid, ppUnk);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IBITSExtensionSetupFactory_Value = Guid.initString("d5d2d542-5503-4e64-8b48-72ef91a32ee1");
pub const IID_IBITSExtensionSetupFactory = &IID_IBITSExtensionSetupFactory_Value;
pub const IBITSExtensionSetupFactory = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        GetObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBITSExtensionSetupFactory,
                Path: ?BSTR,
                ppExtensionSetup: ?*?*IBITSExtensionSetup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBITSExtensionSetupFactory,
                Path: ?BSTR,
                ppExtensionSetup: ?*?*IBITSExtensionSetup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBITSExtensionSetupFactory_GetObject(self: *const T, Path: ?BSTR, ppExtensionSetup: ?*?*IBITSExtensionSetup) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBITSExtensionSetupFactory.VTable, self.vtable).GetObject(@ptrCast(*const IBITSExtensionSetupFactory, self), Path, ppExtensionSetup);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const CLSID_BackgroundCopyQMgr_Value = Guid.initString("69ad4aee-51be-439b-a92c-86ae490e8b30");
pub const CLSID_BackgroundCopyQMgr = &CLSID_BackgroundCopyQMgr_Value;

pub const FILESETINFO = extern struct {
    bstrRemoteFile: ?BSTR,
    bstrLocalFile: ?BSTR,
    dwSizeHint: u32,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IBackgroundCopyJob1_Value = Guid.initString("59f5553c-2031-4629-bb18-2645a6970947");
pub const IID_IBackgroundCopyJob1 = &IID_IBackgroundCopyJob1_Value;
pub const IBackgroundCopyJob1 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CancelJob: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyJob1,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyJob1,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProgress: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyJob1,
                dwFlags: u32,
                pdwProgress: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyJob1,
                dwFlags: u32,
                pdwProgress: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyJob1,
                pdwStatus: ?*u32,
                pdwWin32Result: ?*u32,
                pdwTransportResult: ?*u32,
                pdwNumOfRetries: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyJob1,
                pdwStatus: ?*u32,
                pdwWin32Result: ?*u32,
                pdwTransportResult: ?*u32,
                pdwNumOfRetries: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddFiles: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyJob1,
                cFileCount: u32,
                ppFileSet: [*]?*FILESETINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyJob1,
                cFileCount: u32,
                ppFileSet: [*]?*FILESETINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyJob1,
                cFileIndex: u32,
                pFileInfo: ?*FILESETINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyJob1,
                cFileIndex: u32,
                pFileInfo: ?*FILESETINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFileCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyJob1,
                pdwFileCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyJob1,
                pdwFileCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SwitchToForeground: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyJob1,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyJob1,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_JobID: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBackgroundCopyJob1,
                pguidJobID: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBackgroundCopyJob1,
                pguidJobID: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyJob1_CancelJob(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyJob1.VTable, self.vtable).CancelJob(@ptrCast(*const IBackgroundCopyJob1, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyJob1_GetProgress(self: *const T, dwFlags: u32, pdwProgress: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyJob1.VTable, self.vtable).GetProgress(@ptrCast(*const IBackgroundCopyJob1, self), dwFlags, pdwProgress);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyJob1_GetStatus(self: *const T, pdwStatus: ?*u32, pdwWin32Result: ?*u32, pdwTransportResult: ?*u32, pdwNumOfRetries: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyJob1.VTable, self.vtable).GetStatus(@ptrCast(*const IBackgroundCopyJob1, self), pdwStatus, pdwWin32Result, pdwTransportResult, pdwNumOfRetries);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyJob1_AddFiles(self: *const T, cFileCount: u32, ppFileSet: [*]?*FILESETINFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyJob1.VTable, self.vtable).AddFiles(@ptrCast(*const IBackgroundCopyJob1, self), cFileCount, ppFileSet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyJob1_GetFile(self: *const T, cFileIndex: u32, pFileInfo: ?*FILESETINFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyJob1.VTable, self.vtable).GetFile(@ptrCast(*const IBackgroundCopyJob1, self), cFileIndex, pFileInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyJob1_GetFileCount(self: *const T, pdwFileCount: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyJob1.VTable, self.vtable).GetFileCount(@ptrCast(*const IBackgroundCopyJob1, self), pdwFileCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyJob1_SwitchToForeground(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyJob1.VTable, self.vtable).SwitchToForeground(@ptrCast(*const IBackgroundCopyJob1, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyJob1_get_JobID(self: *const T, pguidJobID: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyJob1.VTable, self.vtable).get_JobID(@ptrCast(*const IBackgroundCopyJob1, self), pguidJobID);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IEnumBackgroundCopyJobs1_Value = Guid.initString("8baeba9d-8f1c-42c4-b82c-09ae79980d25");
pub const IID_IEnumBackgroundCopyJobs1 = &IID_IEnumBackgroundCopyJobs1_Value;
pub const IEnumBackgroundCopyJobs1 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumBackgroundCopyJobs1,
                celt: u32,
                rgelt: [*]Guid,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumBackgroundCopyJobs1,
                celt: u32,
                rgelt: [*]Guid,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumBackgroundCopyJobs1,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumBackgroundCopyJobs1,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumBackgroundCopyJobs1,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumBackgroundCopyJobs1,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumBackgroundCopyJobs1,
                ppenum: ?*?*IEnumBackgroundCopyJobs1,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumBackgroundCopyJobs1,
                ppenum: ?*?*IEnumBackgroundCopyJobs1,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumBackgroundCopyJobs1,
                puCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumBackgroundCopyJobs1,
                puCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumBackgroundCopyJobs1_Next(self: *const T, celt: u32, rgelt: [*]Guid, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumBackgroundCopyJobs1.VTable, self.vtable).Next(@ptrCast(*const IEnumBackgroundCopyJobs1, self), celt, rgelt, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumBackgroundCopyJobs1_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumBackgroundCopyJobs1.VTable, self.vtable).Skip(@ptrCast(*const IEnumBackgroundCopyJobs1, self), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumBackgroundCopyJobs1_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumBackgroundCopyJobs1.VTable, self.vtable).Reset(@ptrCast(*const IEnumBackgroundCopyJobs1, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumBackgroundCopyJobs1_Clone(self: *const T, ppenum: ?*?*IEnumBackgroundCopyJobs1) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumBackgroundCopyJobs1.VTable, self.vtable).Clone(@ptrCast(*const IEnumBackgroundCopyJobs1, self), ppenum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumBackgroundCopyJobs1_GetCount(self: *const T, puCount: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumBackgroundCopyJobs1.VTable, self.vtable).GetCount(@ptrCast(*const IEnumBackgroundCopyJobs1, self), puCount);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const GROUPPROP = enum(i32) {
    PRIORITY = 0,
    REMOTEUSERID = 1,
    REMOTEUSERPWD = 2,
    LOCALUSERID = 3,
    LOCALUSERPWD = 4,
    PROTOCOLFLAGS = 5,
    NOTIFYFLAGS = 6,
    NOTIFYCLSID = 7,
    PROGRESSSIZE = 8,
    PROGRESSPERCENT = 9,
    PROGRESSTIME = 10,
    DISPLAYNAME = 11,
    DESCRIPTION = 12,
};
pub const GROUPPROP_PRIORITY = GROUPPROP.PRIORITY;
pub const GROUPPROP_REMOTEUSERID = GROUPPROP.REMOTEUSERID;
pub const GROUPPROP_REMOTEUSERPWD = GROUPPROP.REMOTEUSERPWD;
pub const GROUPPROP_LOCALUSERID = GROUPPROP.LOCALUSERID;
pub const GROUPPROP_LOCALUSERPWD = GROUPPROP.LOCALUSERPWD;
pub const GROUPPROP_PROTOCOLFLAGS = GROUPPROP.PROTOCOLFLAGS;
pub const GROUPPROP_NOTIFYFLAGS = GROUPPROP.NOTIFYFLAGS;
pub const GROUPPROP_NOTIFYCLSID = GROUPPROP.NOTIFYCLSID;
pub const GROUPPROP_PROGRESSSIZE = GROUPPROP.PROGRESSSIZE;
pub const GROUPPROP_PROGRESSPERCENT = GROUPPROP.PROGRESSPERCENT;
pub const GROUPPROP_PROGRESSTIME = GROUPPROP.PROGRESSTIME;
pub const GROUPPROP_DISPLAYNAME = GROUPPROP.DISPLAYNAME;
pub const GROUPPROP_DESCRIPTION = GROUPPROP.DESCRIPTION;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IBackgroundCopyGroup_Value = Guid.initString("1ded80a7-53ea-424f-8a04-17fea9adc4f5");
pub const IID_IBackgroundCopyGroup = &IID_IBackgroundCopyGroup_Value;
pub const IBackgroundCopyGroup = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetProp: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyGroup,
                propID: GROUPPROP,
                pvarVal: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyGroup,
                propID: GROUPPROP,
                pvarVal: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetProp: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyGroup,
                propID: GROUPPROP,
                pvarVal: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyGroup,
                propID: GROUPPROP,
                pvarVal: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProgress: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyGroup,
                dwFlags: u32,
                pdwProgress: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyGroup,
                dwFlags: u32,
                pdwProgress: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyGroup,
                pdwStatus: ?*u32,
                pdwJobIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyGroup,
                pdwStatus: ?*u32,
                pdwJobIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetJob: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyGroup,
                jobID: Guid,
                ppJob: ?*?*IBackgroundCopyJob1,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyGroup,
                jobID: Guid,
                ppJob: ?*?*IBackgroundCopyJob1,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SuspendGroup: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyGroup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyGroup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ResumeGroup: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyGroup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyGroup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CancelGroup: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyGroup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyGroup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Size: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBackgroundCopyGroup,
                pdwSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBackgroundCopyGroup,
                pdwSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_GroupID: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBackgroundCopyGroup,
                pguidGroupID: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBackgroundCopyGroup,
                pguidGroupID: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateJob: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyGroup,
                guidJobID: Guid,
                ppJob: ?*?*IBackgroundCopyJob1,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyGroup,
                guidJobID: Guid,
                ppJob: ?*?*IBackgroundCopyJob1,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumJobs: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyGroup,
                dwFlags: u32,
                ppEnumJobs: ?*?*IEnumBackgroundCopyJobs1,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyGroup,
                dwFlags: u32,
                ppEnumJobs: ?*?*IEnumBackgroundCopyJobs1,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SwitchToForeground: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyGroup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyGroup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryNewJobInterface: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyGroup,
                iid: ?*const Guid,
                pUnk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyGroup,
                iid: ?*const Guid,
                pUnk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetNotificationPointer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyGroup,
                iid: ?*const Guid,
                pUnk: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyGroup,
                iid: ?*const Guid,
                pUnk: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyGroup_GetProp(self: *const T, propID: GROUPPROP, pvarVal: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyGroup.VTable, self.vtable).GetProp(@ptrCast(*const IBackgroundCopyGroup, self), propID, pvarVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyGroup_SetProp(self: *const T, propID: GROUPPROP, pvarVal: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyGroup.VTable, self.vtable).SetProp(@ptrCast(*const IBackgroundCopyGroup, self), propID, pvarVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyGroup_GetProgress(self: *const T, dwFlags: u32, pdwProgress: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyGroup.VTable, self.vtable).GetProgress(@ptrCast(*const IBackgroundCopyGroup, self), dwFlags, pdwProgress);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyGroup_GetStatus(self: *const T, pdwStatus: ?*u32, pdwJobIndex: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyGroup.VTable, self.vtable).GetStatus(@ptrCast(*const IBackgroundCopyGroup, self), pdwStatus, pdwJobIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyGroup_GetJob(self: *const T, jobID: Guid, ppJob: ?*?*IBackgroundCopyJob1) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyGroup.VTable, self.vtable).GetJob(@ptrCast(*const IBackgroundCopyGroup, self), jobID, ppJob);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyGroup_SuspendGroup(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyGroup.VTable, self.vtable).SuspendGroup(@ptrCast(*const IBackgroundCopyGroup, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyGroup_ResumeGroup(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyGroup.VTable, self.vtable).ResumeGroup(@ptrCast(*const IBackgroundCopyGroup, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyGroup_CancelGroup(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyGroup.VTable, self.vtable).CancelGroup(@ptrCast(*const IBackgroundCopyGroup, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyGroup_get_Size(self: *const T, pdwSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyGroup.VTable, self.vtable).get_Size(@ptrCast(*const IBackgroundCopyGroup, self), pdwSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyGroup_get_GroupID(self: *const T, pguidGroupID: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyGroup.VTable, self.vtable).get_GroupID(@ptrCast(*const IBackgroundCopyGroup, self), pguidGroupID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyGroup_CreateJob(self: *const T, guidJobID: Guid, ppJob: ?*?*IBackgroundCopyJob1) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyGroup.VTable, self.vtable).CreateJob(@ptrCast(*const IBackgroundCopyGroup, self), guidJobID, ppJob);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyGroup_EnumJobs(self: *const T, dwFlags: u32, ppEnumJobs: ?*?*IEnumBackgroundCopyJobs1) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyGroup.VTable, self.vtable).EnumJobs(@ptrCast(*const IBackgroundCopyGroup, self), dwFlags, ppEnumJobs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyGroup_SwitchToForeground(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyGroup.VTable, self.vtable).SwitchToForeground(@ptrCast(*const IBackgroundCopyGroup, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyGroup_QueryNewJobInterface(self: *const T, iid: ?*const Guid, pUnk: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyGroup.VTable, self.vtable).QueryNewJobInterface(@ptrCast(*const IBackgroundCopyGroup, self), iid, pUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyGroup_SetNotificationPointer(self: *const T, iid: ?*const Guid, pUnk: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyGroup.VTable, self.vtable).SetNotificationPointer(@ptrCast(*const IBackgroundCopyGroup, self), iid, pUnk);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IEnumBackgroundCopyGroups_Value = Guid.initString("d993e603-4aa4-47c5-8665-c20d39c2ba4f");
pub const IID_IEnumBackgroundCopyGroups = &IID_IEnumBackgroundCopyGroups_Value;
pub const IEnumBackgroundCopyGroups = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumBackgroundCopyGroups,
                celt: u32,
                rgelt: [*]Guid,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumBackgroundCopyGroups,
                celt: u32,
                rgelt: [*]Guid,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumBackgroundCopyGroups,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumBackgroundCopyGroups,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumBackgroundCopyGroups,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumBackgroundCopyGroups,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumBackgroundCopyGroups,
                ppenum: ?*?*IEnumBackgroundCopyGroups,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumBackgroundCopyGroups,
                ppenum: ?*?*IEnumBackgroundCopyGroups,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumBackgroundCopyGroups,
                puCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumBackgroundCopyGroups,
                puCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumBackgroundCopyGroups_Next(self: *const T, celt: u32, rgelt: [*]Guid, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumBackgroundCopyGroups.VTable, self.vtable).Next(@ptrCast(*const IEnumBackgroundCopyGroups, self), celt, rgelt, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumBackgroundCopyGroups_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumBackgroundCopyGroups.VTable, self.vtable).Skip(@ptrCast(*const IEnumBackgroundCopyGroups, self), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumBackgroundCopyGroups_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumBackgroundCopyGroups.VTable, self.vtable).Reset(@ptrCast(*const IEnumBackgroundCopyGroups, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumBackgroundCopyGroups_Clone(self: *const T, ppenum: ?*?*IEnumBackgroundCopyGroups) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumBackgroundCopyGroups.VTable, self.vtable).Clone(@ptrCast(*const IEnumBackgroundCopyGroups, self), ppenum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumBackgroundCopyGroups_GetCount(self: *const T, puCount: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumBackgroundCopyGroups.VTable, self.vtable).GetCount(@ptrCast(*const IEnumBackgroundCopyGroups, self), puCount);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IBackgroundCopyCallback1_Value = Guid.initString("084f6593-3800-4e08-9b59-99fa59addf82");
pub const IID_IBackgroundCopyCallback1 = &IID_IBackgroundCopyCallback1_Value;
pub const IBackgroundCopyCallback1 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyCallback1,
                pGroup: ?*IBackgroundCopyGroup,
                pJob: ?*IBackgroundCopyJob1,
                dwFileIndex: u32,
                dwStatus: u32,
                dwNumOfRetries: u32,
                dwWin32Result: u32,
                dwTransportResult: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyCallback1,
                pGroup: ?*IBackgroundCopyGroup,
                pJob: ?*IBackgroundCopyJob1,
                dwFileIndex: u32,
                dwStatus: u32,
                dwNumOfRetries: u32,
                dwWin32Result: u32,
                dwTransportResult: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnProgress: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyCallback1,
                ProgressType: u32,
                pGroup: ?*IBackgroundCopyGroup,
                pJob: ?*IBackgroundCopyJob1,
                dwFileIndex: u32,
                dwProgressValue: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyCallback1,
                ProgressType: u32,
                pGroup: ?*IBackgroundCopyGroup,
                pJob: ?*IBackgroundCopyJob1,
                dwFileIndex: u32,
                dwProgressValue: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnProgressEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyCallback1,
                ProgressType: u32,
                pGroup: ?*IBackgroundCopyGroup,
                pJob: ?*IBackgroundCopyJob1,
                dwFileIndex: u32,
                dwProgressValue: u32,
                dwByteArraySize: u32,
                pByte: [*:0]u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyCallback1,
                ProgressType: u32,
                pGroup: ?*IBackgroundCopyGroup,
                pJob: ?*IBackgroundCopyJob1,
                dwFileIndex: u32,
                dwProgressValue: u32,
                dwByteArraySize: u32,
                pByte: [*:0]u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyCallback1_OnStatus(self: *const T, pGroup: ?*IBackgroundCopyGroup, pJob: ?*IBackgroundCopyJob1, dwFileIndex: u32, dwStatus: u32, dwNumOfRetries: u32, dwWin32Result: u32, dwTransportResult: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyCallback1.VTable, self.vtable).OnStatus(@ptrCast(*const IBackgroundCopyCallback1, self), pGroup, pJob, dwFileIndex, dwStatus, dwNumOfRetries, dwWin32Result, dwTransportResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyCallback1_OnProgress(self: *const T, ProgressType: u32, pGroup: ?*IBackgroundCopyGroup, pJob: ?*IBackgroundCopyJob1, dwFileIndex: u32, dwProgressValue: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyCallback1.VTable, self.vtable).OnProgress(@ptrCast(*const IBackgroundCopyCallback1, self), ProgressType, pGroup, pJob, dwFileIndex, dwProgressValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyCallback1_OnProgressEx(self: *const T, ProgressType: u32, pGroup: ?*IBackgroundCopyGroup, pJob: ?*IBackgroundCopyJob1, dwFileIndex: u32, dwProgressValue: u32, dwByteArraySize: u32, pByte: [*:0]u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyCallback1.VTable, self.vtable).OnProgressEx(@ptrCast(*const IBackgroundCopyCallback1, self), ProgressType, pGroup, pJob, dwFileIndex, dwProgressValue, dwByteArraySize, pByte);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IBackgroundCopyQMgr_Value = Guid.initString("16f41c69-09f5-41d2-8cd8-3c08c47bc8a8");
pub const IID_IBackgroundCopyQMgr = &IID_IBackgroundCopyQMgr_Value;
pub const IBackgroundCopyQMgr = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateGroup: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyQMgr,
                guidGroupID: Guid,
                ppGroup: ?*?*IBackgroundCopyGroup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyQMgr,
                guidGroupID: Guid,
                ppGroup: ?*?*IBackgroundCopyGroup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetGroup: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyQMgr,
                groupID: Guid,
                ppGroup: ?*?*IBackgroundCopyGroup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyQMgr,
                groupID: Guid,
                ppGroup: ?*?*IBackgroundCopyGroup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumGroups: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBackgroundCopyQMgr,
                dwFlags: u32,
                ppEnumGroups: ?*?*IEnumBackgroundCopyGroups,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBackgroundCopyQMgr,
                dwFlags: u32,
                ppEnumGroups: ?*?*IEnumBackgroundCopyGroups,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyQMgr_CreateGroup(self: *const T, guidGroupID: Guid, ppGroup: ?*?*IBackgroundCopyGroup) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyQMgr.VTable, self.vtable).CreateGroup(@ptrCast(*const IBackgroundCopyQMgr, self), guidGroupID, ppGroup);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyQMgr_GetGroup(self: *const T, groupID: Guid, ppGroup: ?*?*IBackgroundCopyGroup) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyQMgr.VTable, self.vtable).GetGroup(@ptrCast(*const IBackgroundCopyQMgr, self), groupID, ppGroup);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBackgroundCopyQMgr_EnumGroups(self: *const T, dwFlags: u32, ppEnumGroups: ?*?*IEnumBackgroundCopyGroups) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBackgroundCopyQMgr.VTable, self.vtable).EnumGroups(@ptrCast(*const IBackgroundCopyQMgr, self), dwFlags, ppEnumGroups);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};


//--------------------------------------------------------------------------------
// Section: Functions (0)
//--------------------------------------------------------------------------------

//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
    },
    .wide => struct {
    },
    .unspecified => if (@import("builtin").is_test) struct {
    } else struct {
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (9)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const BOOL = @import("../foundation.zig").BOOL;
const BSTR = @import("../foundation.zig").BSTR;
const FILETIME = @import("../foundation.zig").FILETIME;
const HRESULT = @import("../foundation.zig").HRESULT;
const IDispatch = @import("../system/com.zig").IDispatch;
const IUnknown = @import("../system/com.zig").IUnknown;
const PWSTR = @import("../foundation.zig").PWSTR;
const VARIANT = @import("../system/com.zig").VARIANT;

test {
    @setEvalBranchQuota(
        comptime @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        if (decl.is_pub) {
            _ = @field(@This(), decl.name);
        }
    }
}
