//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (919)
//--------------------------------------------------------------------------------
pub const DIALPROP_USERNAME = "UserName";
pub const DIALPROP_PASSWORD = "Password";
pub const DIALPROP_DOMAIN = "Domain";
pub const DIALPROP_SAVEPASSWORD = "SavePassword";
pub const DIALPROP_REDIALCOUNT = "RedialCount";
pub const DIALPROP_REDIALINTERVAL = "RedialInterval";
pub const DIALPROP_PHONENUMBER = "PhoneNumber";
pub const DIALPROP_LASTERROR = "LastError";
pub const DIALPROP_RESOLVEDPHONE = "ResolvedPhone";
pub const DIALENG_OperationComplete = @as(u32, 65536);
pub const DIALENG_RedialAttempt = @as(u32, 65537);
pub const DIALENG_RedialWait = @as(u32, 65538);
pub const INTERNET_INVALID_PORT_NUMBER = @as(u32, 0);
pub const INTERNET_DEFAULT_FTP_PORT = @as(u32, 21);
pub const INTERNET_DEFAULT_GOPHER_PORT = @as(u32, 70);
pub const INTERNET_DEFAULT_SOCKS_PORT = @as(u32, 1080);
pub const INTERNET_MAX_HOST_NAME_LENGTH = @as(u32, 256);
pub const INTERNET_MAX_USER_NAME_LENGTH = @as(u32, 128);
pub const INTERNET_MAX_PASSWORD_LENGTH = @as(u32, 128);
pub const INTERNET_MAX_PORT_NUMBER_LENGTH = @as(u32, 5);
pub const INTERNET_MAX_PORT_NUMBER_VALUE = @as(u32, 65535);
pub const INTERNET_KEEP_ALIVE_UNKNOWN = @as(u32, 4294967295);
pub const INTERNET_KEEP_ALIVE_ENABLED = @as(u32, 1);
pub const INTERNET_KEEP_ALIVE_DISABLED = @as(u32, 0);
pub const INTERNET_REQFLAG_FROM_CACHE = @as(u32, 1);
pub const INTERNET_REQFLAG_ASYNC = @as(u32, 2);
pub const INTERNET_REQFLAG_VIA_PROXY = @as(u32, 4);
pub const INTERNET_REQFLAG_NO_HEADERS = @as(u32, 8);
pub const INTERNET_REQFLAG_PASSIVE = @as(u32, 16);
pub const INTERNET_REQFLAG_CACHE_WRITE_DISABLED = @as(u32, 64);
pub const INTERNET_REQFLAG_NET_TIMEOUT = @as(u32, 128);
pub const INTERNET_FLAG_IDN_DIRECT = @as(u32, 1);
pub const INTERNET_FLAG_IDN_PROXY = @as(u32, 2);
pub const INTERNET_FLAG_RELOAD = @as(u32, 2147483648);
pub const INTERNET_FLAG_RAW_DATA = @as(u32, 1073741824);
pub const INTERNET_FLAG_EXISTING_CONNECT = @as(u32, 536870912);
pub const INTERNET_FLAG_ASYNC = @as(u32, 268435456);
pub const INTERNET_FLAG_PASSIVE = @as(u32, 134217728);
pub const INTERNET_FLAG_NO_CACHE_WRITE = @as(u32, 67108864);
pub const INTERNET_FLAG_DONT_CACHE = @as(u32, 67108864);
pub const INTERNET_FLAG_MAKE_PERSISTENT = @as(u32, 33554432);
pub const INTERNET_FLAG_FROM_CACHE = @as(u32, 16777216);
pub const INTERNET_FLAG_OFFLINE = @as(u32, 16777216);
pub const INTERNET_FLAG_SECURE = @as(u32, 8388608);
pub const INTERNET_FLAG_KEEP_CONNECTION = @as(u32, 4194304);
pub const INTERNET_FLAG_NO_AUTO_REDIRECT = @as(u32, 2097152);
pub const INTERNET_FLAG_READ_PREFETCH = @as(u32, 1048576);
pub const INTERNET_FLAG_NO_COOKIES = @as(u32, 524288);
pub const INTERNET_FLAG_NO_AUTH = @as(u32, 262144);
pub const INTERNET_FLAG_CACHE_IF_NET_FAIL = @as(u32, 65536);
pub const INTERNET_FLAG_IGNORE_REDIRECT_TO_HTTP = @as(u32, 32768);
pub const INTERNET_FLAG_IGNORE_REDIRECT_TO_HTTPS = @as(u32, 16384);
pub const INTERNET_FLAG_IGNORE_CERT_DATE_INVALID = @as(u32, 8192);
pub const INTERNET_FLAG_IGNORE_CERT_CN_INVALID = @as(u32, 4096);
pub const INTERNET_FLAG_RESYNCHRONIZE = @as(u32, 2048);
pub const INTERNET_FLAG_HYPERLINK = @as(u32, 1024);
pub const INTERNET_FLAG_NO_UI = @as(u32, 512);
pub const INTERNET_FLAG_PRAGMA_NOCACHE = @as(u32, 256);
pub const INTERNET_FLAG_CACHE_ASYNC = @as(u32, 128);
pub const INTERNET_FLAG_FORMS_SUBMIT = @as(u32, 64);
pub const INTERNET_FLAG_FWD_BACK = @as(u32, 32);
pub const INTERNET_FLAG_NEED_FILE = @as(u32, 16);
pub const INTERNET_FLAG_MUST_CACHE_REQUEST = @as(u32, 16);
pub const INTERNET_ERROR_MASK_INSERT_CDROM = @as(u32, 1);
pub const INTERNET_ERROR_MASK_COMBINED_SEC_CERT = @as(u32, 2);
pub const INTERNET_ERROR_MASK_NEED_MSN_SSPI_PKG = @as(u32, 4);
pub const INTERNET_ERROR_MASK_LOGIN_FAILURE_DISPLAY_ENTITY_BODY = @as(u32, 8);
pub const WININET_API_FLAG_ASYNC = @as(u32, 1);
pub const WININET_API_FLAG_SYNC = @as(u32, 4);
pub const WININET_API_FLAG_USE_CONTEXT = @as(u32, 8);
pub const INTERNET_NO_CALLBACK = @as(u32, 0);
pub const IDSI_FLAG_KEEP_ALIVE = @as(u32, 1);
pub const IDSI_FLAG_SECURE = @as(u32, 2);
pub const IDSI_FLAG_PROXY = @as(u32, 4);
pub const IDSI_FLAG_TUNNEL = @as(u32, 8);
pub const INTERNET_PER_CONN_FLAGS_UI = @as(u32, 10);
pub const PROXY_TYPE_DIRECT = @as(u32, 1);
pub const PROXY_TYPE_PROXY = @as(u32, 2);
pub const PROXY_TYPE_AUTO_PROXY_URL = @as(u32, 4);
pub const PROXY_TYPE_AUTO_DETECT = @as(u32, 8);
pub const AUTO_PROXY_FLAG_USER_SET = @as(u32, 1);
pub const AUTO_PROXY_FLAG_ALWAYS_DETECT = @as(u32, 2);
pub const AUTO_PROXY_FLAG_DETECTION_RUN = @as(u32, 4);
pub const AUTO_PROXY_FLAG_MIGRATED = @as(u32, 8);
pub const AUTO_PROXY_FLAG_DONT_CACHE_PROXY_RESULT = @as(u32, 16);
pub const AUTO_PROXY_FLAG_CACHE_INIT_RUN = @as(u32, 32);
pub const AUTO_PROXY_FLAG_DETECTION_SUSPECT = @as(u32, 64);
pub const ISO_FORCE_DISCONNECTED = @as(u32, 1);
pub const INTERNET_RFC1123_FORMAT = @as(u32, 0);
pub const INTERNET_RFC1123_BUFSIZE = @as(u32, 30);
pub const ICU_USERNAME = @as(u32, 1073741824);
pub const INTERNET_OPEN_TYPE_PRECONFIG_WITH_NO_AUTOPROXY = @as(u32, 4);
pub const INTERNET_SERVICE_FTP = @as(u32, 1);
pub const INTERNET_SERVICE_GOPHER = @as(u32, 2);
pub const INTERNET_SERVICE_HTTP = @as(u32, 3);
pub const IRF_ASYNC = @as(u32, 1);
pub const IRF_SYNC = @as(u32, 4);
pub const IRF_USE_CONTEXT = @as(u32, 8);
pub const IRF_NO_WAIT = @as(u32, 8);
pub const ISO_GLOBAL = @as(u32, 1);
pub const ISO_REGISTRY = @as(u32, 2);
pub const INTERNET_OPTION_CALLBACK = @as(u32, 1);
pub const INTERNET_OPTION_CONNECT_TIMEOUT = @as(u32, 2);
pub const INTERNET_OPTION_CONNECT_RETRIES = @as(u32, 3);
pub const INTERNET_OPTION_CONNECT_BACKOFF = @as(u32, 4);
pub const INTERNET_OPTION_SEND_TIMEOUT = @as(u32, 5);
pub const INTERNET_OPTION_CONTROL_SEND_TIMEOUT = @as(u32, 5);
pub const INTERNET_OPTION_RECEIVE_TIMEOUT = @as(u32, 6);
pub const INTERNET_OPTION_CONTROL_RECEIVE_TIMEOUT = @as(u32, 6);
pub const INTERNET_OPTION_DATA_SEND_TIMEOUT = @as(u32, 7);
pub const INTERNET_OPTION_DATA_RECEIVE_TIMEOUT = @as(u32, 8);
pub const INTERNET_OPTION_HANDLE_TYPE = @as(u32, 9);
pub const INTERNET_OPTION_LISTEN_TIMEOUT = @as(u32, 11);
pub const INTERNET_OPTION_READ_BUFFER_SIZE = @as(u32, 12);
pub const INTERNET_OPTION_WRITE_BUFFER_SIZE = @as(u32, 13);
pub const INTERNET_OPTION_ASYNC_ID = @as(u32, 15);
pub const INTERNET_OPTION_ASYNC_PRIORITY = @as(u32, 16);
pub const INTERNET_OPTION_PARENT_HANDLE = @as(u32, 21);
pub const INTERNET_OPTION_KEEP_CONNECTION = @as(u32, 22);
pub const INTERNET_OPTION_REQUEST_FLAGS = @as(u32, 23);
pub const INTERNET_OPTION_EXTENDED_ERROR = @as(u32, 24);
pub const INTERNET_OPTION_OFFLINE_MODE = @as(u32, 26);
pub const INTERNET_OPTION_CACHE_STREAM_HANDLE = @as(u32, 27);
pub const INTERNET_OPTION_USERNAME = @as(u32, 28);
pub const INTERNET_OPTION_PASSWORD = @as(u32, 29);
pub const INTERNET_OPTION_ASYNC = @as(u32, 30);
pub const INTERNET_OPTION_SECURITY_FLAGS = @as(u32, 31);
pub const INTERNET_OPTION_SECURITY_CERTIFICATE_STRUCT = @as(u32, 32);
pub const INTERNET_OPTION_DATAFILE_NAME = @as(u32, 33);
pub const INTERNET_OPTION_URL = @as(u32, 34);
pub const INTERNET_OPTION_SECURITY_CERTIFICATE = @as(u32, 35);
pub const INTERNET_OPTION_SECURITY_KEY_BITNESS = @as(u32, 36);
pub const INTERNET_OPTION_REFRESH = @as(u32, 37);
pub const INTERNET_OPTION_PROXY = @as(u32, 38);
pub const INTERNET_OPTION_SETTINGS_CHANGED = @as(u32, 39);
pub const INTERNET_OPTION_VERSION = @as(u32, 40);
pub const INTERNET_OPTION_USER_AGENT = @as(u32, 41);
pub const INTERNET_OPTION_END_BROWSER_SESSION = @as(u32, 42);
pub const INTERNET_OPTION_PROXY_USERNAME = @as(u32, 43);
pub const INTERNET_OPTION_PROXY_PASSWORD = @as(u32, 44);
pub const INTERNET_OPTION_CONTEXT_VALUE = @as(u32, 45);
pub const INTERNET_OPTION_CONNECT_LIMIT = @as(u32, 46);
pub const INTERNET_OPTION_SECURITY_SELECT_CLIENT_CERT = @as(u32, 47);
pub const INTERNET_OPTION_POLICY = @as(u32, 48);
pub const INTERNET_OPTION_DISCONNECTED_TIMEOUT = @as(u32, 49);
pub const INTERNET_OPTION_CONNECTED_STATE = @as(u32, 50);
pub const INTERNET_OPTION_IDLE_STATE = @as(u32, 51);
pub const INTERNET_OPTION_OFFLINE_SEMANTICS = @as(u32, 52);
pub const INTERNET_OPTION_SECONDARY_CACHE_KEY = @as(u32, 53);
pub const INTERNET_OPTION_CALLBACK_FILTER = @as(u32, 54);
pub const INTERNET_OPTION_CONNECT_TIME = @as(u32, 55);
pub const INTERNET_OPTION_SEND_THROUGHPUT = @as(u32, 56);
pub const INTERNET_OPTION_RECEIVE_THROUGHPUT = @as(u32, 57);
pub const INTERNET_OPTION_REQUEST_PRIORITY = @as(u32, 58);
pub const INTERNET_OPTION_HTTP_VERSION = @as(u32, 59);
pub const INTERNET_OPTION_RESET_URLCACHE_SESSION = @as(u32, 60);
pub const INTERNET_OPTION_ERROR_MASK = @as(u32, 62);
pub const INTERNET_OPTION_FROM_CACHE_TIMEOUT = @as(u32, 63);
pub const INTERNET_OPTION_BYPASS_EDITED_ENTRY = @as(u32, 64);
pub const INTERNET_OPTION_HTTP_DECODING = @as(u32, 65);
pub const INTERNET_OPTION_DIAGNOSTIC_SOCKET_INFO = @as(u32, 67);
pub const INTERNET_OPTION_CODEPAGE = @as(u32, 68);
pub const INTERNET_OPTION_CACHE_TIMESTAMPS = @as(u32, 69);
pub const INTERNET_OPTION_DISABLE_AUTODIAL = @as(u32, 70);
pub const INTERNET_OPTION_MAX_CONNS_PER_SERVER = @as(u32, 73);
pub const INTERNET_OPTION_MAX_CONNS_PER_1_0_SERVER = @as(u32, 74);
pub const INTERNET_OPTION_PER_CONNECTION_OPTION = @as(u32, 75);
pub const INTERNET_OPTION_DIGEST_AUTH_UNLOAD = @as(u32, 76);
pub const INTERNET_OPTION_IGNORE_OFFLINE = @as(u32, 77);
pub const INTERNET_OPTION_IDENTITY = @as(u32, 78);
pub const INTERNET_OPTION_REMOVE_IDENTITY = @as(u32, 79);
pub const INTERNET_OPTION_ALTER_IDENTITY = @as(u32, 80);
pub const INTERNET_OPTION_SUPPRESS_BEHAVIOR = @as(u32, 81);
pub const INTERNET_OPTION_AUTODIAL_MODE = @as(u32, 82);
pub const INTERNET_OPTION_AUTODIAL_CONNECTION = @as(u32, 83);
pub const INTERNET_OPTION_CLIENT_CERT_CONTEXT = @as(u32, 84);
pub const INTERNET_OPTION_AUTH_FLAGS = @as(u32, 85);
pub const INTERNET_OPTION_COOKIES_3RD_PARTY = @as(u32, 86);
pub const INTERNET_OPTION_DISABLE_PASSPORT_AUTH = @as(u32, 87);
pub const INTERNET_OPTION_SEND_UTF8_SERVERNAME_TO_PROXY = @as(u32, 88);
pub const INTERNET_OPTION_EXEMPT_CONNECTION_LIMIT = @as(u32, 89);
pub const INTERNET_OPTION_ENABLE_PASSPORT_AUTH = @as(u32, 90);
pub const INTERNET_OPTION_HIBERNATE_INACTIVE_WORKER_THREADS = @as(u32, 91);
pub const INTERNET_OPTION_ACTIVATE_WORKER_THREADS = @as(u32, 92);
pub const INTERNET_OPTION_RESTORE_WORKER_THREAD_DEFAULTS = @as(u32, 93);
pub const INTERNET_OPTION_SOCKET_SEND_BUFFER_LENGTH = @as(u32, 94);
pub const INTERNET_OPTION_PROXY_SETTINGS_CHANGED = @as(u32, 95);
pub const INTERNET_OPTION_DATAFILE_EXT = @as(u32, 96);
pub const INTERNET_OPTION_CODEPAGE_PATH = @as(u32, 100);
pub const INTERNET_OPTION_CODEPAGE_EXTRA = @as(u32, 101);
pub const INTERNET_OPTION_IDN = @as(u32, 102);
pub const INTERNET_OPTION_MAX_CONNS_PER_PROXY = @as(u32, 103);
pub const INTERNET_OPTION_SUPPRESS_SERVER_AUTH = @as(u32, 104);
pub const INTERNET_OPTION_SERVER_CERT_CHAIN_CONTEXT = @as(u32, 105);
pub const INTERNET_OPTION_ENABLE_REDIRECT_CACHE_READ = @as(u32, 122);
pub const INTERNET_OPTION_COMPRESSED_CONTENT_LENGTH = @as(u32, 147);
pub const INTERNET_OPTION_ENABLE_HTTP_PROTOCOL = @as(u32, 148);
pub const INTERNET_OPTION_HTTP_PROTOCOL_USED = @as(u32, 149);
pub const INTERNET_OPTION_ENCODE_EXTRA = @as(u32, 155);
pub const INTERNET_OPTION_HSTS = @as(u32, 157);
pub const INTERNET_OPTION_ENTERPRISE_CONTEXT = @as(u32, 159);
pub const INTERNET_OPTION_CONNECTION_FILTER = @as(u32, 162);
pub const INTERNET_OPTION_REFERER_TOKEN_BINDING_HOSTNAME = @as(u32, 163);
pub const INTERNET_OPTION_TOKEN_BINDING_PUBLIC_KEY = @as(u32, 181);
pub const INTERNET_OPTION_COOKIES_SAME_SITE_LEVEL = @as(u32, 187);
pub const INTERNET_FIRST_OPTION = @as(u32, 1);
pub const INTERNET_LAST_OPTION = @as(u32, 187);
pub const INTERNET_PRIORITY_FOREGROUND = @as(u32, 1000);
pub const HTTP_COOKIES_SAME_SITE_LEVEL_UNKNOWN = @as(u32, 0);
pub const HTTP_COOKIES_SAME_SITE_LEVEL_SAME_SITE = @as(u32, 1);
pub const HTTP_COOKIES_SAME_SITE_LEVEL_CROSS_SITE_LAX = @as(u32, 2);
pub const HTTP_COOKIES_SAME_SITE_LEVEL_CROSS_SITE = @as(u32, 3);
pub const HTTP_COOKIES_SAME_SITE_LEVEL_MAX = @as(u32, 3);
pub const HTTP_PROTOCOL_FLAG_HTTP2 = @as(u32, 2);
pub const HTTP_PROTOCOL_MASK = @as(u32, 2);
pub const INTERNET_HANDLE_TYPE_INTERNET = @as(u32, 1);
pub const INTERNET_HANDLE_TYPE_CONNECT_FTP = @as(u32, 2);
pub const INTERNET_HANDLE_TYPE_CONNECT_GOPHER = @as(u32, 3);
pub const INTERNET_HANDLE_TYPE_CONNECT_HTTP = @as(u32, 4);
pub const INTERNET_HANDLE_TYPE_FTP_FIND = @as(u32, 5);
pub const INTERNET_HANDLE_TYPE_FTP_FIND_HTML = @as(u32, 6);
pub const INTERNET_HANDLE_TYPE_FTP_FILE = @as(u32, 7);
pub const INTERNET_HANDLE_TYPE_FTP_FILE_HTML = @as(u32, 8);
pub const INTERNET_HANDLE_TYPE_GOPHER_FIND = @as(u32, 9);
pub const INTERNET_HANDLE_TYPE_GOPHER_FIND_HTML = @as(u32, 10);
pub const INTERNET_HANDLE_TYPE_GOPHER_FILE = @as(u32, 11);
pub const INTERNET_HANDLE_TYPE_GOPHER_FILE_HTML = @as(u32, 12);
pub const INTERNET_HANDLE_TYPE_HTTP_REQUEST = @as(u32, 13);
pub const INTERNET_HANDLE_TYPE_FILE_REQUEST = @as(u32, 14);
pub const AUTH_FLAG_DISABLE_NEGOTIATE = @as(u32, 1);
pub const AUTH_FLAG_ENABLE_NEGOTIATE = @as(u32, 2);
pub const AUTH_FLAG_DISABLE_BASIC_CLEARCHANNEL = @as(u32, 4);
pub const AUTH_FLAG_DISABLE_SERVER_AUTH = @as(u32, 8);
pub const SECURITY_FLAG_UNKNOWNBIT = @as(u32, 2147483648);
pub const SECURITY_FLAG_FORTEZZA = @as(u32, 134217728);
pub const SECURITY_FLAG_NORMALBITNESS = @as(u32, 268435456);
pub const SECURITY_FLAG_SSL = @as(u32, 2);
pub const SECURITY_FLAG_SSL3 = @as(u32, 4);
pub const SECURITY_FLAG_PCT = @as(u32, 8);
pub const SECURITY_FLAG_PCT4 = @as(u32, 16);
pub const SECURITY_FLAG_IETFSSL4 = @as(u32, 32);
pub const SECURITY_FLAG_40BIT = @as(u32, 268435456);
pub const SECURITY_FLAG_128BIT = @as(u32, 536870912);
pub const SECURITY_FLAG_56BIT = @as(u32, 1073741824);
pub const SECURITY_FLAG_IGNORE_REVOCATION = @as(u32, 128);
pub const SECURITY_FLAG_IGNORE_WRONG_USAGE = @as(u32, 512);
pub const SECURITY_FLAG_IGNORE_WEAK_SIGNATURE = @as(u32, 65536);
pub const SECURITY_FLAG_IGNORE_REDIRECT_TO_HTTPS = @as(u32, 16384);
pub const SECURITY_FLAG_IGNORE_REDIRECT_TO_HTTP = @as(u32, 32768);
pub const SECURITY_FLAG_OPT_IN_WEAK_SIGNATURE = @as(u32, 131072);
pub const AUTODIAL_MODE_NEVER = @as(u32, 1);
pub const AUTODIAL_MODE_ALWAYS = @as(u32, 2);
pub const AUTODIAL_MODE_NO_NETWORK_PRESENT = @as(u32, 4);
pub const INTERNET_STATUS_RESOLVING_NAME = @as(u32, 10);
pub const INTERNET_STATUS_NAME_RESOLVED = @as(u32, 11);
pub const INTERNET_STATUS_CONNECTING_TO_SERVER = @as(u32, 20);
pub const INTERNET_STATUS_CONNECTED_TO_SERVER = @as(u32, 21);
pub const INTERNET_STATUS_SENDING_REQUEST = @as(u32, 30);
pub const INTERNET_STATUS_REQUEST_SENT = @as(u32, 31);
pub const INTERNET_STATUS_RECEIVING_RESPONSE = @as(u32, 40);
pub const INTERNET_STATUS_RESPONSE_RECEIVED = @as(u32, 41);
pub const INTERNET_STATUS_CTL_RESPONSE_RECEIVED = @as(u32, 42);
pub const INTERNET_STATUS_PREFETCH = @as(u32, 43);
pub const INTERNET_STATUS_CLOSING_CONNECTION = @as(u32, 50);
pub const INTERNET_STATUS_CONNECTION_CLOSED = @as(u32, 51);
pub const INTERNET_STATUS_HANDLE_CREATED = @as(u32, 60);
pub const INTERNET_STATUS_HANDLE_CLOSING = @as(u32, 70);
pub const INTERNET_STATUS_DETECTING_PROXY = @as(u32, 80);
pub const INTERNET_STATUS_REQUEST_COMPLETE = @as(u32, 100);
pub const INTERNET_STATUS_REDIRECT = @as(u32, 110);
pub const INTERNET_STATUS_INTERMEDIATE_RESPONSE = @as(u32, 120);
pub const INTERNET_STATUS_USER_INPUT_REQUIRED = @as(u32, 140);
pub const INTERNET_STATUS_STATE_CHANGE = @as(u32, 200);
pub const INTERNET_STATUS_COOKIE_SENT = @as(u32, 320);
pub const INTERNET_STATUS_COOKIE_RECEIVED = @as(u32, 321);
pub const INTERNET_STATUS_PRIVACY_IMPACTED = @as(u32, 324);
pub const INTERNET_STATUS_P3P_HEADER = @as(u32, 325);
pub const INTERNET_STATUS_P3P_POLICYREF = @as(u32, 326);
pub const INTERNET_STATUS_COOKIE_HISTORY = @as(u32, 327);
pub const MAX_GOPHER_DISPLAY_TEXT = @as(u32, 128);
pub const MAX_GOPHER_SELECTOR_TEXT = @as(u32, 256);
pub const MAX_GOPHER_HOST_NAME = @as(u32, 256);
pub const MAX_GOPHER_CATEGORY_NAME = @as(u32, 128);
pub const MAX_GOPHER_ATTRIBUTE_NAME = @as(u32, 128);
pub const MIN_GOPHER_ATTRIBUTE_LENGTH = @as(u32, 256);
pub const GOPHER_INFO_CATEGORY = "+INFO";
pub const GOPHER_ADMIN_CATEGORY = "+ADMIN";
pub const GOPHER_VIEWS_CATEGORY = "+VIEWS";
pub const GOPHER_ABSTRACT_CATEGORY = "+ABSTRACT";
pub const GOPHER_VERONICA_CATEGORY = "+VERONICA";
pub const GOPHER_ADMIN_ATTRIBUTE = "Admin";
pub const GOPHER_MOD_DATE_ATTRIBUTE = "Mod-Date";
pub const GOPHER_TTL_ATTRIBUTE = "TTL";
pub const GOPHER_SCORE_ATTRIBUTE = "Score";
pub const GOPHER_RANGE_ATTRIBUTE = "Score-range";
pub const GOPHER_SITE_ATTRIBUTE = "Site";
pub const GOPHER_ORG_ATTRIBUTE = "Org";
pub const GOPHER_LOCATION_ATTRIBUTE = "Loc";
pub const GOPHER_GEOG_ATTRIBUTE = "Geog";
pub const GOPHER_TIMEZONE_ATTRIBUTE = "TZ";
pub const GOPHER_PROVIDER_ATTRIBUTE = "Provider";
pub const GOPHER_VERSION_ATTRIBUTE = "Version";
pub const GOPHER_ABSTRACT_ATTRIBUTE = "Abstract";
pub const GOPHER_VIEW_ATTRIBUTE = "View";
pub const GOPHER_TREEWALK_ATTRIBUTE = "treewalk";
pub const GOPHER_ATTRIBUTE_ID_BASE = @as(u32, 2882325504);
pub const GOPHER_CATEGORY_ID_ALL = @as(u32, 2882325505);
pub const GOPHER_CATEGORY_ID_INFO = @as(u32, 2882325506);
pub const GOPHER_CATEGORY_ID_ADMIN = @as(u32, 2882325507);
pub const GOPHER_CATEGORY_ID_VIEWS = @as(u32, 2882325508);
pub const GOPHER_CATEGORY_ID_ABSTRACT = @as(u32, 2882325509);
pub const GOPHER_CATEGORY_ID_VERONICA = @as(u32, 2882325510);
pub const GOPHER_CATEGORY_ID_ASK = @as(u32, 2882325511);
pub const GOPHER_CATEGORY_ID_UNKNOWN = @as(u32, 2882325512);
pub const GOPHER_ATTRIBUTE_ID_ALL = @as(u32, 2882325513);
pub const GOPHER_ATTRIBUTE_ID_ADMIN = @as(u32, 2882325514);
pub const GOPHER_ATTRIBUTE_ID_MOD_DATE = @as(u32, 2882325515);
pub const GOPHER_ATTRIBUTE_ID_TTL = @as(u32, 2882325516);
pub const GOPHER_ATTRIBUTE_ID_SCORE = @as(u32, 2882325517);
pub const GOPHER_ATTRIBUTE_ID_RANGE = @as(u32, 2882325518);
pub const GOPHER_ATTRIBUTE_ID_SITE = @as(u32, 2882325519);
pub const GOPHER_ATTRIBUTE_ID_ORG = @as(u32, 2882325520);
pub const GOPHER_ATTRIBUTE_ID_LOCATION = @as(u32, 2882325521);
pub const GOPHER_ATTRIBUTE_ID_GEOG = @as(u32, 2882325522);
pub const GOPHER_ATTRIBUTE_ID_TIMEZONE = @as(u32, 2882325523);
pub const GOPHER_ATTRIBUTE_ID_PROVIDER = @as(u32, 2882325524);
pub const GOPHER_ATTRIBUTE_ID_VERSION = @as(u32, 2882325525);
pub const GOPHER_ATTRIBUTE_ID_ABSTRACT = @as(u32, 2882325526);
pub const GOPHER_ATTRIBUTE_ID_VIEW = @as(u32, 2882325527);
pub const GOPHER_ATTRIBUTE_ID_TREEWALK = @as(u32, 2882325528);
pub const GOPHER_ATTRIBUTE_ID_UNKNOWN = @as(u32, 2882325529);
pub const HTTP_MAJOR_VERSION = @as(u32, 1);
pub const HTTP_MINOR_VERSION = @as(u32, 0);
pub const HTTP_VERSIONA = "HTTP/1.0";
pub const HTTP_VERSIONW = "HTTP/1.0";
pub const HTTP_QUERY_MIME_VERSION = @as(u32, 0);
pub const HTTP_QUERY_CONTENT_TYPE = @as(u32, 1);
pub const HTTP_QUERY_CONTENT_TRANSFER_ENCODING = @as(u32, 2);
pub const HTTP_QUERY_CONTENT_ID = @as(u32, 3);
pub const HTTP_QUERY_CONTENT_DESCRIPTION = @as(u32, 4);
pub const HTTP_QUERY_CONTENT_LENGTH = @as(u32, 5);
pub const HTTP_QUERY_CONTENT_LANGUAGE = @as(u32, 6);
pub const HTTP_QUERY_ALLOW = @as(u32, 7);
pub const HTTP_QUERY_PUBLIC = @as(u32, 8);
pub const HTTP_QUERY_DATE = @as(u32, 9);
pub const HTTP_QUERY_EXPIRES = @as(u32, 10);
pub const HTTP_QUERY_LAST_MODIFIED = @as(u32, 11);
pub const HTTP_QUERY_MESSAGE_ID = @as(u32, 12);
pub const HTTP_QUERY_URI = @as(u32, 13);
pub const HTTP_QUERY_DERIVED_FROM = @as(u32, 14);
pub const HTTP_QUERY_COST = @as(u32, 15);
pub const HTTP_QUERY_LINK = @as(u32, 16);
pub const HTTP_QUERY_PRAGMA = @as(u32, 17);
pub const HTTP_QUERY_VERSION = @as(u32, 18);
pub const HTTP_QUERY_STATUS_CODE = @as(u32, 19);
pub const HTTP_QUERY_STATUS_TEXT = @as(u32, 20);
pub const HTTP_QUERY_RAW_HEADERS = @as(u32, 21);
pub const HTTP_QUERY_RAW_HEADERS_CRLF = @as(u32, 22);
pub const HTTP_QUERY_CONNECTION = @as(u32, 23);
pub const HTTP_QUERY_ACCEPT = @as(u32, 24);
pub const HTTP_QUERY_ACCEPT_CHARSET = @as(u32, 25);
pub const HTTP_QUERY_ACCEPT_ENCODING = @as(u32, 26);
pub const HTTP_QUERY_ACCEPT_LANGUAGE = @as(u32, 27);
pub const HTTP_QUERY_AUTHORIZATION = @as(u32, 28);
pub const HTTP_QUERY_CONTENT_ENCODING = @as(u32, 29);
pub const HTTP_QUERY_FORWARDED = @as(u32, 30);
pub const HTTP_QUERY_FROM = @as(u32, 31);
pub const HTTP_QUERY_IF_MODIFIED_SINCE = @as(u32, 32);
pub const HTTP_QUERY_LOCATION = @as(u32, 33);
pub const HTTP_QUERY_ORIG_URI = @as(u32, 34);
pub const HTTP_QUERY_REFERER = @as(u32, 35);
pub const HTTP_QUERY_RETRY_AFTER = @as(u32, 36);
pub const HTTP_QUERY_SERVER = @as(u32, 37);
pub const HTTP_QUERY_TITLE = @as(u32, 38);
pub const HTTP_QUERY_USER_AGENT = @as(u32, 39);
pub const HTTP_QUERY_WWW_AUTHENTICATE = @as(u32, 40);
pub const HTTP_QUERY_PROXY_AUTHENTICATE = @as(u32, 41);
pub const HTTP_QUERY_ACCEPT_RANGES = @as(u32, 42);
pub const HTTP_QUERY_SET_COOKIE = @as(u32, 43);
pub const HTTP_QUERY_COOKIE = @as(u32, 44);
pub const HTTP_QUERY_REQUEST_METHOD = @as(u32, 45);
pub const HTTP_QUERY_REFRESH = @as(u32, 46);
pub const HTTP_QUERY_CONTENT_DISPOSITION = @as(u32, 47);
pub const HTTP_QUERY_AGE = @as(u32, 48);
pub const HTTP_QUERY_CACHE_CONTROL = @as(u32, 49);
pub const HTTP_QUERY_CONTENT_BASE = @as(u32, 50);
pub const HTTP_QUERY_CONTENT_LOCATION = @as(u32, 51);
pub const HTTP_QUERY_CONTENT_MD5 = @as(u32, 52);
pub const HTTP_QUERY_CONTENT_RANGE = @as(u32, 53);
pub const HTTP_QUERY_ETAG = @as(u32, 54);
pub const HTTP_QUERY_HOST = @as(u32, 55);
pub const HTTP_QUERY_IF_MATCH = @as(u32, 56);
pub const HTTP_QUERY_IF_NONE_MATCH = @as(u32, 57);
pub const HTTP_QUERY_IF_RANGE = @as(u32, 58);
pub const HTTP_QUERY_IF_UNMODIFIED_SINCE = @as(u32, 59);
pub const HTTP_QUERY_MAX_FORWARDS = @as(u32, 60);
pub const HTTP_QUERY_PROXY_AUTHORIZATION = @as(u32, 61);
pub const HTTP_QUERY_RANGE = @as(u32, 62);
pub const HTTP_QUERY_TRANSFER_ENCODING = @as(u32, 63);
pub const HTTP_QUERY_UPGRADE = @as(u32, 64);
pub const HTTP_QUERY_VARY = @as(u32, 65);
pub const HTTP_QUERY_VIA = @as(u32, 66);
pub const HTTP_QUERY_WARNING = @as(u32, 67);
pub const HTTP_QUERY_EXPECT = @as(u32, 68);
pub const HTTP_QUERY_PROXY_CONNECTION = @as(u32, 69);
pub const HTTP_QUERY_UNLESS_MODIFIED_SINCE = @as(u32, 70);
pub const HTTP_QUERY_ECHO_REQUEST = @as(u32, 71);
pub const HTTP_QUERY_ECHO_REPLY = @as(u32, 72);
pub const HTTP_QUERY_ECHO_HEADERS = @as(u32, 73);
pub const HTTP_QUERY_ECHO_HEADERS_CRLF = @as(u32, 74);
pub const HTTP_QUERY_PROXY_SUPPORT = @as(u32, 75);
pub const HTTP_QUERY_AUTHENTICATION_INFO = @as(u32, 76);
pub const HTTP_QUERY_PASSPORT_URLS = @as(u32, 77);
pub const HTTP_QUERY_PASSPORT_CONFIG = @as(u32, 78);
pub const HTTP_QUERY_X_CONTENT_TYPE_OPTIONS = @as(u32, 79);
pub const HTTP_QUERY_P3P = @as(u32, 80);
pub const HTTP_QUERY_X_P2P_PEERDIST = @as(u32, 81);
pub const HTTP_QUERY_TRANSLATE = @as(u32, 82);
pub const HTTP_QUERY_X_UA_COMPATIBLE = @as(u32, 83);
pub const HTTP_QUERY_DEFAULT_STYLE = @as(u32, 84);
pub const HTTP_QUERY_X_FRAME_OPTIONS = @as(u32, 85);
pub const HTTP_QUERY_X_XSS_PROTECTION = @as(u32, 86);
pub const HTTP_QUERY_SET_COOKIE2 = @as(u32, 87);
pub const HTTP_QUERY_DO_NOT_TRACK = @as(u32, 88);
pub const HTTP_QUERY_KEEP_ALIVE = @as(u32, 89);
pub const HTTP_QUERY_HTTP2_SETTINGS = @as(u32, 90);
pub const HTTP_QUERY_STRICT_TRANSPORT_SECURITY = @as(u32, 91);
pub const HTTP_QUERY_TOKEN_BINDING = @as(u32, 92);
pub const HTTP_QUERY_INCLUDE_REFERRED_TOKEN_BINDING_ID = @as(u32, 93);
pub const HTTP_QUERY_INCLUDE_REFERER_TOKEN_BINDING_ID = @as(u32, 93);
pub const HTTP_QUERY_PUBLIC_KEY_PINS = @as(u32, 94);
pub const HTTP_QUERY_PUBLIC_KEY_PINS_REPORT_ONLY = @as(u32, 95);
pub const HTTP_QUERY_MAX = @as(u32, 95);
pub const HTTP_QUERY_CUSTOM = @as(u32, 65535);
pub const HTTP_QUERY_FLAG_REQUEST_HEADERS = @as(u32, 2147483648);
pub const HTTP_QUERY_FLAG_SYSTEMTIME = @as(u32, 1073741824);
pub const HTTP_QUERY_FLAG_NUMBER = @as(u32, 536870912);
pub const HTTP_QUERY_FLAG_COALESCE = @as(u32, 268435456);
pub const HTTP_QUERY_FLAG_NUMBER64 = @as(u32, 134217728);
pub const HTTP_QUERY_FLAG_COALESCE_WITH_COMMA = @as(u32, 67108864);
pub const HTTP_STATUS_MISDIRECTED_REQUEST = @as(u32, 421);
pub const HTTP_ADDREQ_INDEX_MASK = @as(u32, 65535);
pub const HTTP_ADDREQ_FLAGS_MASK = @as(u32, 4294901760);
pub const HSR_ASYNC = @as(u32, 1);
pub const HSR_SYNC = @as(u32, 4);
pub const HSR_USE_CONTEXT = @as(u32, 8);
pub const HSR_INITIATE = @as(u32, 8);
pub const HSR_DOWNLOAD = @as(u32, 16);
pub const HSR_CHUNKED = @as(u32, 32);
pub const INTERNET_COOKIE_IS_SECURE = @as(u32, 1);
pub const INTERNET_COOKIE_IS_SESSION = @as(u32, 2);
pub const INTERNET_COOKIE_PROMPT_REQUIRED = @as(u32, 32);
pub const INTERNET_COOKIE_EVALUATE_P3P = @as(u32, 64);
pub const INTERNET_COOKIE_APPLY_P3P = @as(u32, 128);
pub const INTERNET_COOKIE_P3P_ENABLED = @as(u32, 256);
pub const INTERNET_COOKIE_IS_RESTRICTED = @as(u32, 512);
pub const INTERNET_COOKIE_IE6 = @as(u32, 1024);
pub const INTERNET_COOKIE_IS_LEGACY = @as(u32, 2048);
pub const INTERNET_COOKIE_NON_SCRIPT = @as(u32, 4096);
pub const INTERNET_COOKIE_HOST_ONLY = @as(u32, 16384);
pub const INTERNET_COOKIE_APPLY_HOST_ONLY = @as(u32, 32768);
pub const INTERNET_COOKIE_HOST_ONLY_APPLIED = @as(u32, 524288);
pub const INTERNET_COOKIE_SAME_SITE_STRICT = @as(u32, 1048576);
pub const INTERNET_COOKIE_SAME_SITE_LAX = @as(u32, 2097152);
pub const INTERNET_COOKIE_SAME_SITE_LEVEL_CROSS_SITE = @as(u32, 4194304);
pub const FLAG_ICC_FORCE_CONNECTION = @as(u32, 1);
pub const FLAGS_ERROR_UI_FILTER_FOR_ERRORS = @as(u32, 1);
pub const FLAGS_ERROR_UI_FLAGS_CHANGE_OPTIONS = @as(u32, 2);
pub const FLAGS_ERROR_UI_FLAGS_GENERATE_DATA = @as(u32, 4);
pub const FLAGS_ERROR_UI_FLAGS_NO_UI = @as(u32, 8);
pub const FLAGS_ERROR_UI_SERIALIZE_DIALOGS = @as(u32, 16);
pub const INTERNET_ERROR_BASE = @as(u32, 12000);
pub const ERROR_INTERNET_OUT_OF_HANDLES = @as(u32, 12001);
pub const ERROR_INTERNET_TIMEOUT = @as(u32, 12002);
pub const ERROR_INTERNET_EXTENDED_ERROR = @as(u32, 12003);
pub const ERROR_INTERNET_INTERNAL_ERROR = @as(u32, 12004);
pub const ERROR_INTERNET_INVALID_URL = @as(u32, 12005);
pub const ERROR_INTERNET_UNRECOGNIZED_SCHEME = @as(u32, 12006);
pub const ERROR_INTERNET_NAME_NOT_RESOLVED = @as(u32, 12007);
pub const ERROR_INTERNET_PROTOCOL_NOT_FOUND = @as(u32, 12008);
pub const ERROR_INTERNET_INVALID_OPTION = @as(u32, 12009);
pub const ERROR_INTERNET_BAD_OPTION_LENGTH = @as(u32, 12010);
pub const ERROR_INTERNET_OPTION_NOT_SETTABLE = @as(u32, 12011);
pub const ERROR_INTERNET_SHUTDOWN = @as(u32, 12012);
pub const ERROR_INTERNET_INCORRECT_USER_NAME = @as(u32, 12013);
pub const ERROR_INTERNET_INCORRECT_PASSWORD = @as(u32, 12014);
pub const ERROR_INTERNET_LOGIN_FAILURE = @as(u32, 12015);
pub const ERROR_INTERNET_INVALID_OPERATION = @as(u32, 12016);
pub const ERROR_INTERNET_OPERATION_CANCELLED = @as(u32, 12017);
pub const ERROR_INTERNET_INCORRECT_HANDLE_TYPE = @as(u32, 12018);
pub const ERROR_INTERNET_INCORRECT_HANDLE_STATE = @as(u32, 12019);
pub const ERROR_INTERNET_NOT_PROXY_REQUEST = @as(u32, 12020);
pub const ERROR_INTERNET_REGISTRY_VALUE_NOT_FOUND = @as(u32, 12021);
pub const ERROR_INTERNET_BAD_REGISTRY_PARAMETER = @as(u32, 12022);
pub const ERROR_INTERNET_NO_DIRECT_ACCESS = @as(u32, 12023);
pub const ERROR_INTERNET_NO_CONTEXT = @as(u32, 12024);
pub const ERROR_INTERNET_NO_CALLBACK = @as(u32, 12025);
pub const ERROR_INTERNET_REQUEST_PENDING = @as(u32, 12026);
pub const ERROR_INTERNET_INCORRECT_FORMAT = @as(u32, 12027);
pub const ERROR_INTERNET_ITEM_NOT_FOUND = @as(u32, 12028);
pub const ERROR_INTERNET_CANNOT_CONNECT = @as(u32, 12029);
pub const ERROR_INTERNET_CONNECTION_ABORTED = @as(u32, 12030);
pub const ERROR_INTERNET_CONNECTION_RESET = @as(u32, 12031);
pub const ERROR_INTERNET_FORCE_RETRY = @as(u32, 12032);
pub const ERROR_INTERNET_INVALID_PROXY_REQUEST = @as(u32, 12033);
pub const ERROR_INTERNET_NEED_UI = @as(u32, 12034);
pub const ERROR_INTERNET_HANDLE_EXISTS = @as(u32, 12036);
pub const ERROR_INTERNET_SEC_CERT_DATE_INVALID = @as(u32, 12037);
pub const ERROR_INTERNET_SEC_CERT_CN_INVALID = @as(u32, 12038);
pub const ERROR_INTERNET_HTTP_TO_HTTPS_ON_REDIR = @as(u32, 12039);
pub const ERROR_INTERNET_HTTPS_TO_HTTP_ON_REDIR = @as(u32, 12040);
pub const ERROR_INTERNET_MIXED_SECURITY = @as(u32, 12041);
pub const ERROR_INTERNET_CHG_POST_IS_NON_SECURE = @as(u32, 12042);
pub const ERROR_INTERNET_POST_IS_NON_SECURE = @as(u32, 12043);
pub const ERROR_INTERNET_CLIENT_AUTH_CERT_NEEDED = @as(u32, 12044);
pub const ERROR_INTERNET_INVALID_CA = @as(u32, 12045);
pub const ERROR_INTERNET_CLIENT_AUTH_NOT_SETUP = @as(u32, 12046);
pub const ERROR_INTERNET_ASYNC_THREAD_FAILED = @as(u32, 12047);
pub const ERROR_INTERNET_REDIRECT_SCHEME_CHANGE = @as(u32, 12048);
pub const ERROR_INTERNET_DIALOG_PENDING = @as(u32, 12049);
pub const ERROR_INTERNET_RETRY_DIALOG = @as(u32, 12050);
pub const ERROR_INTERNET_HTTPS_HTTP_SUBMIT_REDIR = @as(u32, 12052);
pub const ERROR_INTERNET_INSERT_CDROM = @as(u32, 12053);
pub const ERROR_INTERNET_FORTEZZA_LOGIN_NEEDED = @as(u32, 12054);
pub const ERROR_INTERNET_SEC_CERT_ERRORS = @as(u32, 12055);
pub const ERROR_INTERNET_SEC_CERT_NO_REV = @as(u32, 12056);
pub const ERROR_INTERNET_SEC_CERT_REV_FAILED = @as(u32, 12057);
pub const ERROR_HTTP_HSTS_REDIRECT_REQUIRED = @as(u32, 12060);
pub const ERROR_INTERNET_SEC_CERT_WEAK_SIGNATURE = @as(u32, 12062);
pub const ERROR_FTP_TRANSFER_IN_PROGRESS = @as(u32, 12110);
pub const ERROR_FTP_DROPPED = @as(u32, 12111);
pub const ERROR_FTP_NO_PASSIVE_MODE = @as(u32, 12112);
pub const ERROR_GOPHER_PROTOCOL_ERROR = @as(u32, 12130);
pub const ERROR_GOPHER_NOT_FILE = @as(u32, 12131);
pub const ERROR_GOPHER_DATA_ERROR = @as(u32, 12132);
pub const ERROR_GOPHER_END_OF_DATA = @as(u32, 12133);
pub const ERROR_GOPHER_INVALID_LOCATOR = @as(u32, 12134);
pub const ERROR_GOPHER_INCORRECT_LOCATOR_TYPE = @as(u32, 12135);
pub const ERROR_GOPHER_NOT_GOPHER_PLUS = @as(u32, 12136);
pub const ERROR_GOPHER_ATTRIBUTE_NOT_FOUND = @as(u32, 12137);
pub const ERROR_GOPHER_UNKNOWN_LOCATOR = @as(u32, 12138);
pub const ERROR_HTTP_HEADER_NOT_FOUND = @as(u32, 12150);
pub const ERROR_HTTP_DOWNLEVEL_SERVER = @as(u32, 12151);
pub const ERROR_HTTP_INVALID_SERVER_RESPONSE = @as(u32, 12152);
pub const ERROR_HTTP_INVALID_HEADER = @as(u32, 12153);
pub const ERROR_HTTP_INVALID_QUERY_REQUEST = @as(u32, 12154);
pub const ERROR_HTTP_HEADER_ALREADY_EXISTS = @as(u32, 12155);
pub const ERROR_HTTP_REDIRECT_FAILED = @as(u32, 12156);
pub const ERROR_HTTP_NOT_REDIRECTED = @as(u32, 12160);
pub const ERROR_HTTP_COOKIE_NEEDS_CONFIRMATION = @as(u32, 12161);
pub const ERROR_HTTP_COOKIE_DECLINED = @as(u32, 12162);
pub const ERROR_HTTP_REDIRECT_NEEDS_CONFIRMATION = @as(u32, 12168);
pub const ERROR_INTERNET_SECURITY_CHANNEL_ERROR = @as(u32, 12157);
pub const ERROR_INTERNET_UNABLE_TO_CACHE_FILE = @as(u32, 12158);
pub const ERROR_INTERNET_TCPIP_NOT_INSTALLED = @as(u32, 12159);
pub const ERROR_INTERNET_DISCONNECTED = @as(u32, 12163);
pub const ERROR_INTERNET_SERVER_UNREACHABLE = @as(u32, 12164);
pub const ERROR_INTERNET_PROXY_SERVER_UNREACHABLE = @as(u32, 12165);
pub const ERROR_INTERNET_BAD_AUTO_PROXY_SCRIPT = @as(u32, 12166);
pub const ERROR_INTERNET_UNABLE_TO_DOWNLOAD_SCRIPT = @as(u32, 12167);
pub const ERROR_INTERNET_SEC_INVALID_CERT = @as(u32, 12169);
pub const ERROR_INTERNET_SEC_CERT_REVOKED = @as(u32, 12170);
pub const ERROR_INTERNET_FAILED_DUETOSECURITYCHECK = @as(u32, 12171);
pub const ERROR_INTERNET_NOT_INITIALIZED = @as(u32, 12172);
pub const ERROR_INTERNET_NEED_MSN_SSPI_PKG = @as(u32, 12173);
pub const ERROR_INTERNET_LOGIN_FAILURE_DISPLAY_ENTITY_BODY = @as(u32, 12174);
pub const ERROR_INTERNET_DECODING_FAILED = @as(u32, 12175);
pub const ERROR_INTERNET_CLIENT_AUTH_CERT_NEEDED_PROXY = @as(u32, 12187);
pub const ERROR_INTERNET_SECURE_FAILURE_PROXY = @as(u32, 12188);
pub const ERROR_INTERNET_HTTP_PROTOCOL_MISMATCH = @as(u32, 12190);
pub const ERROR_INTERNET_GLOBAL_CALLBACK_FAILED = @as(u32, 12191);
pub const ERROR_INTERNET_FEATURE_DISABLED = @as(u32, 12192);
pub const INTERNET_ERROR_LAST = @as(u32, 12192);
pub const NORMAL_CACHE_ENTRY = @as(u32, 1);
pub const STICKY_CACHE_ENTRY = @as(u32, 4);
pub const EDITED_CACHE_ENTRY = @as(u32, 8);
pub const TRACK_OFFLINE_CACHE_ENTRY = @as(u32, 16);
pub const TRACK_ONLINE_CACHE_ENTRY = @as(u32, 32);
pub const SPARSE_CACHE_ENTRY = @as(u32, 65536);
pub const COOKIE_CACHE_ENTRY = @as(u32, 1048576);
pub const URLHISTORY_CACHE_ENTRY = @as(u32, 2097152);
pub const CACHEGROUP_ATTRIBUTE_GET_ALL = @as(u32, 4294967295);
pub const CACHEGROUP_ATTRIBUTE_BASIC = @as(u32, 1);
pub const CACHEGROUP_ATTRIBUTE_FLAG = @as(u32, 2);
pub const CACHEGROUP_ATTRIBUTE_TYPE = @as(u32, 4);
pub const CACHEGROUP_ATTRIBUTE_QUOTA = @as(u32, 8);
pub const CACHEGROUP_ATTRIBUTE_GROUPNAME = @as(u32, 16);
pub const CACHEGROUP_ATTRIBUTE_STORAGE = @as(u32, 32);
pub const CACHEGROUP_FLAG_NONPURGEABLE = @as(u32, 1);
pub const CACHEGROUP_FLAG_GIDONLY = @as(u32, 4);
pub const CACHEGROUP_FLAG_FLUSHURL_ONDELETE = @as(u32, 2);
pub const CACHEGROUP_SEARCH_ALL = @as(u32, 0);
pub const CACHEGROUP_SEARCH_BYURL = @as(u32, 1);
pub const CACHEGROUP_TYPE_INVALID = @as(u32, 1);
pub const GROUPNAME_MAX_LENGTH = @as(u32, 120);
pub const GROUP_OWNER_STORAGE_SIZE = @as(u32, 4);
pub const CACHE_ENTRY_ATTRIBUTE_FC = @as(u32, 4);
pub const CACHE_ENTRY_HITRATE_FC = @as(u32, 16);
pub const CACHE_ENTRY_MODTIME_FC = @as(u32, 64);
pub const CACHE_ENTRY_EXPTIME_FC = @as(u32, 128);
pub const CACHE_ENTRY_ACCTIME_FC = @as(u32, 256);
pub const CACHE_ENTRY_SYNCTIME_FC = @as(u32, 512);
pub const CACHE_ENTRY_HEADERINFO_FC = @as(u32, 1024);
pub const CACHE_ENTRY_EXEMPT_DELTA_FC = @as(u32, 2048);
pub const INTERNET_CACHE_GROUP_ADD = @as(u32, 0);
pub const INTERNET_CACHE_GROUP_REMOVE = @as(u32, 1);
pub const INTERNET_DIAL_FORCE_PROMPT = @as(u32, 8192);
pub const INTERNET_DIAL_SHOW_OFFLINE = @as(u32, 16384);
pub const INTERNET_DIAL_UNATTENDED = @as(u32, 32768);
pub const INTERENT_GOONLINE_REFRESH = @as(u32, 1);
pub const INTERENT_GOONLINE_NOPROMPT = @as(u32, 2);
pub const INTERENT_GOONLINE_MASK = @as(u32, 3);
pub const INTERNET_CUSTOMDIAL_CONNECT = @as(u32, 0);
pub const INTERNET_CUSTOMDIAL_UNATTENDED = @as(u32, 1);
pub const INTERNET_CUSTOMDIAL_DISCONNECT = @as(u32, 2);
pub const INTERNET_CUSTOMDIAL_SHOWOFFLINE = @as(u32, 4);
pub const INTERNET_CUSTOMDIAL_SAFE_FOR_UNATTENDED = @as(u32, 1);
pub const INTERNET_CUSTOMDIAL_WILL_SUPPLY_STATE = @as(u32, 2);
pub const INTERNET_CUSTOMDIAL_CAN_HANGUP = @as(u32, 4);
pub const INTERNET_DIALSTATE_DISCONNECTED = @as(u32, 1);
pub const INTERNET_IDENTITY_FLAG_PRIVATE_CACHE = @as(u32, 1);
pub const INTERNET_IDENTITY_FLAG_SHARED_CACHE = @as(u32, 2);
pub const INTERNET_IDENTITY_FLAG_CLEAR_DATA = @as(u32, 4);
pub const INTERNET_IDENTITY_FLAG_CLEAR_COOKIES = @as(u32, 8);
pub const INTERNET_IDENTITY_FLAG_CLEAR_HISTORY = @as(u32, 16);
pub const INTERNET_IDENTITY_FLAG_CLEAR_CONTENT = @as(u32, 32);
pub const INTERNET_SUPPRESS_RESET_ALL = @as(u32, 0);
pub const INTERNET_SUPPRESS_COOKIE_POLICY = @as(u32, 1);
pub const INTERNET_SUPPRESS_COOKIE_POLICY_RESET = @as(u32, 2);
pub const PRIVACY_TEMPLATE_NO_COOKIES = @as(u32, 0);
pub const PRIVACY_TEMPLATE_HIGH = @as(u32, 1);
pub const PRIVACY_TEMPLATE_MEDIUM_HIGH = @as(u32, 2);
pub const PRIVACY_TEMPLATE_MEDIUM = @as(u32, 3);
pub const PRIVACY_TEMPLATE_MEDIUM_LOW = @as(u32, 4);
pub const PRIVACY_TEMPLATE_LOW = @as(u32, 5);
pub const PRIVACY_TEMPLATE_CUSTOM = @as(u32, 100);
pub const PRIVACY_TEMPLATE_ADVANCED = @as(u32, 101);
pub const PRIVACY_TEMPLATE_MAX = @as(u32, 5);
pub const PRIVACY_TYPE_FIRST_PARTY = @as(u32, 0);
pub const PRIVACY_TYPE_THIRD_PARTY = @as(u32, 1);
pub const MAX_CACHE_ENTRY_INFO_SIZE = @as(u32, 4096);
pub const INTERNET_REQFLAG_FROM_APP_CACHE = @as(u32, 256);
pub const INTERNET_FLAG_BGUPDATE = @as(u32, 8);
pub const INTERNET_FLAG_FTP_FOLDER_VIEW = @as(u32, 4);
pub const INTERNET_PREFETCH_PROGRESS = @as(u32, 0);
pub const INTERNET_PREFETCH_COMPLETE = @as(u32, 1);
pub const INTERNET_PREFETCH_ABORTED = @as(u32, 2);
pub const ISO_FORCE_OFFLINE = @as(u32, 1);
pub const DLG_FLAGS_INVALID_CA = @as(u32, 16777216);
pub const DLG_FLAGS_SEC_CERT_CN_INVALID = @as(u32, 33554432);
pub const DLG_FLAGS_SEC_CERT_DATE_INVALID = @as(u32, 67108864);
pub const DLG_FLAGS_WEAK_SIGNATURE = @as(u32, 2097152);
pub const DLG_FLAGS_INSECURE_FALLBACK = @as(u32, 4194304);
pub const DLG_FLAGS_SEC_CERT_REV_FAILED = @as(u32, 8388608);
pub const INTERNET_SERVICE_URL = @as(u32, 0);
pub const INTERNET_OPTION_CONTEXT_VALUE_OLD = @as(u32, 10);
pub const INTERNET_OPTION_NET_SPEED = @as(u32, 61);
pub const INTERNET_OPTION_SECURITY_CONNECTION_INFO = @as(u32, 66);
pub const INTERNET_OPTION_DETECT_POST_SEND = @as(u32, 71);
pub const INTERNET_OPTION_DISABLE_NTLM_PREAUTH = @as(u32, 72);
pub const INTERNET_OPTION_ORIGINAL_CONNECT_FLAGS = @as(u32, 97);
pub const INTERNET_OPTION_CERT_ERROR_FLAGS = @as(u32, 98);
pub const INTERNET_OPTION_IGNORE_CERT_ERROR_FLAGS = @as(u32, 99);
pub const INTERNET_OPTION_SESSION_START_TIME = @as(u32, 106);
pub const INTERNET_OPTION_PROXY_CREDENTIALS = @as(u32, 107);
pub const INTERNET_OPTION_EXTENDED_CALLBACKS = @as(u32, 108);
pub const INTERNET_OPTION_PROXY_FROM_REQUEST = @as(u32, 109);
pub const INTERNET_OPTION_ALLOW_FAILED_CONNECT_CONTENT = @as(u32, 110);
pub const INTERNET_OPTION_CACHE_PARTITION = @as(u32, 111);
pub const INTERNET_OPTION_AUTODIAL_HWND = @as(u32, 112);
pub const INTERNET_OPTION_SERVER_CREDENTIALS = @as(u32, 113);
pub const INTERNET_OPTION_WPAD_SLEEP = @as(u32, 114);
pub const INTERNET_OPTION_FAIL_ON_CACHE_WRITE_ERROR = @as(u32, 115);
pub const INTERNET_OPTION_DOWNLOAD_MODE = @as(u32, 116);
pub const INTERNET_OPTION_RESPONSE_RESUMABLE = @as(u32, 117);
pub const INTERNET_OPTION_CM_HANDLE_COPY_REF = @as(u32, 118);
pub const INTERNET_OPTION_CONNECTION_INFO = @as(u32, 120);
pub const INTERNET_OPTION_BACKGROUND_CONNECTIONS = @as(u32, 121);
pub const INTERNET_OPTION_DO_NOT_TRACK = @as(u32, 123);
pub const INTERNET_OPTION_USE_MODIFIED_HEADER_FILTER = @as(u32, 124);
pub const INTERNET_OPTION_WWA_MODE = @as(u32, 125);
pub const INTERNET_OPTION_UPGRADE_TO_WEB_SOCKET = @as(u32, 126);
pub const INTERNET_OPTION_WEB_SOCKET_KEEPALIVE_INTERVAL = @as(u32, 127);
pub const INTERNET_OPTION_UNLOAD_NOTIFY_EVENT = @as(u32, 128);
pub const INTERNET_OPTION_SOCKET_NODELAY = @as(u32, 129);
pub const INTERNET_OPTION_APP_CACHE = @as(u32, 130);
pub const INTERNET_OPTION_DEPENDENCY_HANDLE = @as(u32, 131);
pub const INTERNET_OPTION_USE_FIRST_AVAILABLE_CONNECTION = @as(u32, 132);
pub const INTERNET_OPTION_TIMED_CONNECTION_LIMIT_BYPASS = @as(u32, 133);
pub const INTERNET_OPTION_WEB_SOCKET_CLOSE_TIMEOUT = @as(u32, 134);
pub const INTERNET_OPTION_FLUSH_STATE = @as(u32, 135);
pub const INTERNET_OPTION_DISALLOW_PREMATURE_EOF = @as(u32, 137);
pub const INTERNET_OPTION_SOCKET_NOTIFICATION_IOCTL = @as(u32, 138);
pub const INTERNET_OPTION_CACHE_ENTRY_EXTRA_DATA = @as(u32, 139);
pub const INTERNET_OPTION_MAX_QUERY_BUFFER_SIZE = @as(u32, 140);
pub const INTERNET_OPTION_FALSE_START = @as(u32, 141);
pub const INTERNET_OPTION_USER_PASS_SERVER_ONLY = @as(u32, 142);
pub const INTERNET_OPTION_SERVER_AUTH_SCHEME = @as(u32, 143);
pub const INTERNET_OPTION_PROXY_AUTH_SCHEME = @as(u32, 144);
pub const INTERNET_OPTION_TUNNEL_ONLY = @as(u32, 145);
pub const INTERNET_OPTION_SOURCE_PORT = @as(u32, 146);
pub const INTERNET_OPTION_ENABLE_DUO = @as(u32, 148);
pub const INTERNET_OPTION_DUO_USED = @as(u32, 149);
pub const INTERNET_OPTION_CHUNK_ENCODE_REQUEST = @as(u32, 150);
pub const INTERNET_OPTION_SECURE_FAILURE = @as(u32, 151);
pub const INTERNET_OPTION_NOTIFY_SENDING_COOKIE = @as(u32, 152);
pub const INTERNET_OPTION_CLIENT_CERT_ISSUER_LIST = @as(u32, 153);
pub const INTERNET_OPTION_RESET = @as(u32, 154);
pub const INTERNET_OPTION_SERVER_ADDRESS_INFO = @as(u32, 156);
pub const INTERNET_OPTION_ENABLE_WBOEXT = @as(u32, 158);
pub const INTERNET_OPTION_DISABLE_INSECURE_FALLBACK = @as(u32, 160);
pub const INTERNET_OPTION_ALLOW_INSECURE_FALLBACK = @as(u32, 161);
pub const INTERNET_OPTION_SET_IN_PRIVATE = @as(u32, 164);
pub const INTERNET_OPTION_DOWNLOAD_MODE_HANDLE = @as(u32, 165);
pub const INTERNET_OPTION_EDGE_COOKIES = @as(u32, 166);
pub const INTERNET_OPTION_NO_HTTP_SERVER_AUTH = @as(u32, 167);
pub const INTERNET_OPTION_ENABLE_HEADER_CALLBACKS = @as(u32, 168);
pub const INTERNET_OPTION_PRESERVE_REQUEST_SERVER_CREDENTIALS_ON_REDIRECT = @as(u32, 169);
pub const INTERNET_OPTION_PRESERVE_REFERER_ON_HTTPS_TO_HTTP_REDIRECT = @as(u32, 170);
pub const INTERNET_OPTION_TCP_FAST_OPEN = @as(u32, 171);
pub const INTERNET_OPTION_SYNC_MODE_AUTOMATIC_SESSION_DISABLED = @as(u32, 172);
pub const INTERNET_OPTION_ENABLE_ZLIB_DEFLATE = @as(u32, 173);
pub const INTERNET_OPTION_ENCODE_FALLBACK_FOR_REDIRECT_URI = @as(u32, 174);
pub const INTERNET_OPTION_EDGE_COOKIES_TEMP = @as(u32, 175);
pub const INTERNET_OPTION_OPT_IN_WEAK_SIGNATURE = @as(u32, 176);
pub const INTERNET_OPTION_PARSE_LINE_FOLDING = @as(u32, 177);
pub const INTERNET_OPTION_FORCE_DECODE = @as(u32, 178);
pub const INTERNET_OPTION_COOKIES_APPLY_HOST_ONLY = @as(u32, 179);
pub const INTERNET_OPTION_EDGE_MODE = @as(u32, 180);
pub const INTERNET_OPTION_CANCEL_CACHE_WRITE = @as(u32, 182);
pub const INTERNET_OPTION_AUTH_SCHEME_SELECTED = @as(u32, 183);
pub const INTERNET_OPTION_NOCACHE_WRITE_IN_PRIVATE = @as(u32, 184);
pub const INTERNET_OPTION_ACTIVITY_ID = @as(u32, 185);
pub const INTERNET_OPTION_REQUEST_TIMES = @as(u32, 186);
pub const INTERNET_OPTION_GLOBAL_CALLBACK = @as(u32, 188);
pub const INTERNET_OPTION_ENABLE_TEST_SIGNING = @as(u32, 189);
pub const INTERNET_OPTION_DISABLE_PROXY_LINK_LOCAL_NAME_RESOLUTION = @as(u32, 190);
pub const INTERNET_OPTION_HTTP_09 = @as(u32, 191);
pub const INTERNET_LAST_OPTION_INTERNAL = @as(u32, 191);
pub const INTERNET_OPTION_OFFLINE_TIMEOUT = @as(u32, 49);
pub const INTERNET_OPTION_LINE_STATE = @as(u32, 50);
pub const DUO_PROTOCOL_FLAG_SPDY3 = @as(u32, 1);
pub const DUO_PROTOCOL_MASK = @as(u32, 1);
pub const AUTH_FLAG_RESET = @as(u32, 0);
pub const INTERNET_AUTH_SCHEME_BASIC = @as(u32, 0);
pub const INTERNET_AUTH_SCHEME_DIGEST = @as(u32, 1);
pub const INTERNET_AUTH_SCHEME_NTLM = @as(u32, 2);
pub const INTERNET_AUTH_SCHEME_KERBEROS = @as(u32, 3);
pub const INTERNET_AUTH_SCHEME_NEGOTIATE = @as(u32, 4);
pub const INTERNET_AUTH_SCHEME_PASSPORT = @as(u32, 5);
pub const INTERNET_AUTH_SCHEME_UNKNOWN = @as(u32, 6);
pub const INTERNET_STATUS_SENDING_COOKIE = @as(u32, 328);
pub const INTERNET_STATUS_REQUEST_HEADERS_SET = @as(u32, 329);
pub const INTERNET_STATUS_RESPONSE_HEADERS_SET = @as(u32, 330);
pub const INTERNET_STATUS_PROXY_CREDENTIALS = @as(u32, 400);
pub const INTERNET_STATUS_SERVER_CREDENTIALS = @as(u32, 401);
pub const INTERNET_STATUS_SERVER_CONNECTION_STATE = @as(u32, 410);
pub const INTERNET_STATUS_END_BROWSER_SESSION = @as(u32, 420);
pub const INTERNET_STATUS_COOKIE = @as(u32, 430);
pub const COOKIE_STATE_LB = @as(u32, 0);
pub const COOKIE_STATE_UB = @as(u32, 5);
pub const MaxPrivacySettings = @as(u32, 16384);
pub const INTERNET_STATUS_FILTER_RESOLVING = @as(u32, 1);
pub const INTERNET_STATUS_FILTER_RESOLVED = @as(u32, 2);
pub const INTERNET_STATUS_FILTER_CONNECTING = @as(u32, 4);
pub const INTERNET_STATUS_FILTER_CONNECTED = @as(u32, 8);
pub const INTERNET_STATUS_FILTER_SENDING = @as(u32, 16);
pub const INTERNET_STATUS_FILTER_SENT = @as(u32, 32);
pub const INTERNET_STATUS_FILTER_RECEIVING = @as(u32, 64);
pub const INTERNET_STATUS_FILTER_RECEIVED = @as(u32, 128);
pub const INTERNET_STATUS_FILTER_CLOSING = @as(u32, 256);
pub const INTERNET_STATUS_FILTER_CLOSED = @as(u32, 512);
pub const INTERNET_STATUS_FILTER_HANDLE_CREATED = @as(u32, 1024);
pub const INTERNET_STATUS_FILTER_HANDLE_CLOSING = @as(u32, 2048);
pub const INTERNET_STATUS_FILTER_PREFETCH = @as(u32, 4096);
pub const INTERNET_STATUS_FILTER_REDIRECT = @as(u32, 8192);
pub const INTERNET_STATUS_FILTER_STATE_CHANGE = @as(u32, 16384);
pub const HTTP_ADDREQ_FLAG_RESPONSE_HEADERS = @as(u32, 33554432);
pub const HTTP_ADDREQ_FLAG_ALLOW_EMPTY_VALUES = @as(u32, 67108864);
pub const COOKIE_DONT_ALLOW = @as(u32, 1);
pub const COOKIE_ALLOW = @as(u32, 2);
pub const COOKIE_ALLOW_ALL = @as(u32, 4);
pub const COOKIE_DONT_ALLOW_ALL = @as(u32, 8);
pub const COOKIE_OP_SET = @as(u32, 1);
pub const COOKIE_OP_MODIFY = @as(u32, 2);
pub const COOKIE_OP_GET = @as(u32, 4);
pub const COOKIE_OP_SESSION = @as(u32, 8);
pub const COOKIE_OP_PERSISTENT = @as(u32, 16);
pub const COOKIE_OP_3RD_PARTY = @as(u32, 32);
pub const INTERNET_COOKIE_PERSISTENT_HOST_ONLY = @as(u32, 65536);
pub const INTERNET_COOKIE_RESTRICTED_ZONE = @as(u32, 131072);
pub const INTERNET_COOKIE_EDGE_COOKIES = @as(u32, 262144);
pub const INTERNET_COOKIE_ALL_COOKIES = @as(u32, 536870912);
pub const INTERNET_COOKIE_NO_CALLBACK = @as(u32, 1073741824);
pub const INTERNET_COOKIE_ECTX_3RDPARTY = @as(u32, 2147483648);
pub const FLAGS_ERROR_UI_SHOW_IDN_HOSTNAME = @as(u32, 32);
pub const ERROR_INTERNET_NO_NEW_CONTAINERS = @as(u32, 12051);
pub const ERROR_INTERNET_SOURCE_PORT_IN_USE = @as(u32, 12058);
pub const ERROR_INTERNET_INSECURE_FALLBACK_REQUIRED = @as(u32, 12059);
pub const ERROR_INTERNET_PROXY_ALERT = @as(u32, 12061);
pub const ERROR_INTERNET_NO_CM_CONNECTION = @as(u32, 12080);
pub const ERROR_HTTP_PUSH_STATUS_CODE_NOT_SUPPORTED = @as(u32, 12147);
pub const ERROR_HTTP_PUSH_RETRY_NOT_SUPPORTED = @as(u32, 12148);
pub const ERROR_HTTP_PUSH_ENABLE_FAILED = @as(u32, 12149);
pub const ERROR_INTERNET_DISALLOW_INPRIVATE = @as(u32, 12189);
pub const ERROR_INTERNET_OFFLINE = @as(u32, 12163);
pub const INTERNET_INTERNAL_ERROR_BASE = @as(u32, 12900);
pub const ERROR_INTERNET_INTERNAL_SOCKET_ERROR = @as(u32, 12901);
pub const ERROR_INTERNET_CONNECTION_AVAILABLE = @as(u32, 12902);
pub const ERROR_INTERNET_NO_KNOWN_SERVERS = @as(u32, 12903);
pub const ERROR_INTERNET_PING_FAILED = @as(u32, 12904);
pub const ERROR_INTERNET_NO_PING_SUPPORT = @as(u32, 12905);
pub const ERROR_INTERNET_CACHE_SUCCESS = @as(u32, 12906);
pub const ERROR_HTTP_COOKIE_NEEDS_CONFIRMATION_EX = @as(u32, 12907);
pub const HTTP_1_1_CACHE_ENTRY = @as(u32, 64);
pub const STATIC_CACHE_ENTRY = @as(u32, 128);
pub const MUST_REVALIDATE_CACHE_ENTRY = @as(u32, 256);
pub const SHORTPATH_CACHE_ENTRY = @as(u32, 512);
pub const DOWNLOAD_CACHE_ENTRY = @as(u32, 1024);
pub const REDIRECT_CACHE_ENTRY = @as(u32, 2048);
pub const COOKIE_ACCEPTED_CACHE_ENTRY = @as(u32, 4096);
pub const COOKIE_LEASHED_CACHE_ENTRY = @as(u32, 8192);
pub const COOKIE_DOWNGRADED_CACHE_ENTRY = @as(u32, 16384);
pub const COOKIE_REJECTED_CACHE_ENTRY = @as(u32, 32768);
pub const PRIVACY_MODE_CACHE_ENTRY = @as(u32, 131072);
pub const XDR_CACHE_ENTRY = @as(u32, 262144);
pub const IMMUTABLE_CACHE_ENTRY = @as(u32, 524288);
pub const PENDING_DELETE_CACHE_ENTRY = @as(u32, 4194304);
pub const OTHER_USER_CACHE_ENTRY = @as(u32, 8388608);
pub const PRIVACY_IMPACTED_CACHE_ENTRY = @as(u32, 33554432);
pub const POST_RESPONSE_CACHE_ENTRY = @as(u32, 67108864);
pub const INSTALLED_CACHE_ENTRY = @as(u32, 268435456);
pub const POST_CHECK_CACHE_ENTRY = @as(u32, 536870912);
pub const IDENTITY_CACHE_ENTRY = @as(u32, 2147483648);
pub const ANY_CACHE_ENTRY = @as(u32, 4294967295);
pub const CACHEGROUP_FLAG_VALID = @as(u32, 7);
pub const CACHEGROUP_ID_BUILTIN_STICKY = @as(u64, 1152921504606846983);
pub const INTERNET_CACHE_FLAG_ALLOW_COLLISIONS = @as(u32, 256);
pub const INTERNET_CACHE_FLAG_INSTALLED_ENTRY = @as(u32, 512);
pub const INTERNET_CACHE_FLAG_ENTRY_OR_MAPPING = @as(u32, 1024);
pub const INTERNET_CACHE_FLAG_ADD_FILENAME_ONLY = @as(u32, 2048);
pub const INTERNET_CACHE_FLAG_GET_STRUCT_ONLY = @as(u32, 4096);
pub const CACHE_ENTRY_TYPE_FC = @as(u32, 4096);
pub const CACHE_ENTRY_MODIFY_DATA_FC = @as(u32, 2147483648);
pub const INTERNET_CACHE_CONTAINER_NOSUBDIRS = @as(u32, 1);
pub const INTERNET_CACHE_CONTAINER_AUTODELETE = @as(u32, 2);
pub const INTERNET_CACHE_CONTAINER_RESERVED1 = @as(u32, 4);
pub const INTERNET_CACHE_CONTAINER_NODESKTOPINIT = @as(u32, 8);
pub const INTERNET_CACHE_CONTAINER_MAP_ENABLED = @as(u32, 16);
pub const INTERNET_CACHE_CONTAINER_BLOOM_FILTER = @as(u32, 32);
pub const INTERNET_CACHE_CONTAINER_SHARE_READ = @as(u32, 256);
pub const INTERNET_CACHE_CONTAINER_SHARE_READ_WRITE = @as(u32, 768);
pub const CACHE_FIND_CONTAINER_RETURN_NOCHANGE = @as(u32, 1);
pub const CACHE_HEADER_DATA_CURRENT_SETTINGS_VERSION = @as(u32, 0);
pub const CACHE_HEADER_DATA_CONLIST_CHANGE_COUNT = @as(u32, 1);
pub const CACHE_HEADER_DATA_COOKIE_CHANGE_COUNT = @as(u32, 2);
pub const CACHE_HEADER_DATA_NOTIFICATION_HWND = @as(u32, 3);
pub const CACHE_HEADER_DATA_NOTIFICATION_MESG = @as(u32, 4);
pub const CACHE_HEADER_DATA_ROOTGROUP_OFFSET = @as(u32, 5);
pub const CACHE_HEADER_DATA_GID_LOW = @as(u32, 6);
pub const CACHE_HEADER_DATA_GID_HIGH = @as(u32, 7);
pub const CACHE_HEADER_DATA_LAST_SCAVENGE_TIMESTAMP = @as(u32, 8);
pub const CACHE_HEADER_DATA_CACHE_READ_COUNT_SINCE_LAST_SCAVENGE = @as(u32, 9);
pub const CACHE_HEADER_DATA_CACHE_WRITE_COUNT_SINCE_LAST_SCAVENGE = @as(u32, 10);
pub const CACHE_HEADER_DATA_HSTS_CHANGE_COUNT = @as(u32, 11);
pub const CACHE_HEADER_DATA_CACHE_RESERVED_12 = @as(u32, 12);
pub const CACHE_HEADER_DATA_CACHE_RESERVED_13 = @as(u32, 13);
pub const CACHE_HEADER_DATA_SSL_STATE_COUNT = @as(u32, 14);
pub const CACHE_HEADER_DATA_DOWNLOAD_PARTIAL = @as(u32, 14);
pub const CACHE_HEADER_DATA_CACHE_RESERVED_15 = @as(u32, 15);
pub const CACHE_HEADER_DATA_CACHE_RESERVED_16 = @as(u32, 16);
pub const CACHE_HEADER_DATA_CACHE_RESERVED_17 = @as(u32, 17);
pub const CACHE_HEADER_DATA_CACHE_RESERVED_18 = @as(u32, 18);
pub const CACHE_HEADER_DATA_CACHE_RESERVED_19 = @as(u32, 19);
pub const CACHE_HEADER_DATA_CACHE_RESERVED_20 = @as(u32, 20);
pub const CACHE_HEADER_DATA_NOTIFICATION_FILTER = @as(u32, 21);
pub const CACHE_HEADER_DATA_ROOT_LEAK_OFFSET = @as(u32, 22);
pub const CACHE_HEADER_DATA_CACHE_RESERVED_23 = @as(u32, 23);
pub const CACHE_HEADER_DATA_CACHE_RESERVED_24 = @as(u32, 24);
pub const CACHE_HEADER_DATA_CACHE_RESERVED_25 = @as(u32, 25);
pub const CACHE_HEADER_DATA_CACHE_RESERVED_26 = @as(u32, 26);
pub const CACHE_HEADER_DATA_ROOT_GROUPLIST_OFFSET = @as(u32, 27);
pub const CACHE_HEADER_DATA_CACHE_RESERVED_28 = @as(u32, 28);
pub const CACHE_HEADER_DATA_CACHE_RESERVED_29 = @as(u32, 29);
pub const CACHE_HEADER_DATA_CACHE_RESERVED_30 = @as(u32, 30);
pub const CACHE_HEADER_DATA_CACHE_RESERVED_31 = @as(u32, 31);
pub const CACHE_HEADER_DATA_LAST = @as(u32, 31);
pub const CACHE_NOTIFY_ADD_URL = @as(u32, 1);
pub const CACHE_NOTIFY_DELETE_URL = @as(u32, 2);
pub const CACHE_NOTIFY_UPDATE_URL = @as(u32, 4);
pub const CACHE_NOTIFY_DELETE_ALL = @as(u32, 8);
pub const CACHE_NOTIFY_URL_SET_STICKY = @as(u32, 16);
pub const CACHE_NOTIFY_URL_UNSET_STICKY = @as(u32, 32);
pub const CACHE_NOTIFY_SET_ONLINE = @as(u32, 256);
pub const CACHE_NOTIFY_SET_OFFLINE = @as(u32, 512);
pub const CACHE_NOTIFY_FILTER_CHANGED = @as(u32, 268435456);
pub const APP_CACHE_LOOKUP_NO_MASTER_ONLY = @as(u32, 1);
pub const APP_CACHE_ENTRY_TYPE_MASTER = @as(u32, 1);
pub const APP_CACHE_ENTRY_TYPE_EXPLICIT = @as(u32, 2);
pub const APP_CACHE_ENTRY_TYPE_FALLBACK = @as(u32, 4);
pub const APP_CACHE_ENTRY_TYPE_FOREIGN = @as(u32, 8);
pub const APP_CACHE_ENTRY_TYPE_MANIFEST = @as(u32, 16);
pub const CACHE_CONFIG_CONTENT_QUOTA_FC = @as(u32, 32768);
pub const CACHE_CONFIG_TOTAL_CONTENT_QUOTA_FC = @as(u32, 65536);
pub const CACHE_CONFIG_APPCONTAINER_CONTENT_QUOTA_FC = @as(u32, 131072);
pub const CACHE_CONFIG_APPCONTAINER_TOTAL_CONTENT_QUOTA_FC = @as(u32, 262144);
pub const INTERNET_AUTOPROXY_INIT_DEFAULT = @as(u32, 1);
pub const INTERNET_AUTOPROXY_INIT_DOWNLOADSYNC = @as(u32, 2);
pub const INTERNET_AUTOPROXY_INIT_QUERYSTATE = @as(u32, 4);
pub const INTERNET_AUTOPROXY_INIT_ONLYQUERY = @as(u32, 8);
pub const REGSTR_DIAL_AUTOCONNECT = "AutoConnect";
pub const REGSTR_LEASH_LEGACY_COOKIES = "LeashLegacyCookies";
pub const LOCAL_NAMESPACE_PREFIX = "Local\\";
pub const LOCAL_NAMESPACE_PREFIX_W = "Local\\";
pub const INTERNET_SUPPRESS_COOKIE_PERSIST = @as(u32, 3);
pub const INTERNET_SUPPRESS_COOKIE_PERSIST_RESET = @as(u32, 4);
pub const HTTP_WEB_SOCKET_MAX_CLOSE_REASON_LENGTH = @as(u32, 123);
pub const HTTP_WEB_SOCKET_MIN_KEEPALIVE_VALUE = @as(u32, 10000);
pub const INTERNET_GLOBAL_CALLBACK_SENDING_HTTP_HEADERS = @as(u32, 1);

//--------------------------------------------------------------------------------
// Section: Types (120)
//--------------------------------------------------------------------------------
pub const CACHE_CONFIG = enum(u32) {
    FORCE_CLEANUP_FC = 32,
    DISK_CACHE_PATHS_FC = 64,
    SYNC_MODE_FC = 128,
    CONTENT_PATHS_FC = 256,
    HISTORY_PATHS_FC = 1024,
    COOKIES_PATHS_FC = 512,
    QUOTA_FC = 2048,
    USER_MODE_FC = 4096,
    CONTENT_USAGE_FC = 8192,
    STICKY_CONTENT_USAGE_FC = 16384,
};
pub const CACHE_CONFIG_FORCE_CLEANUP_FC = CACHE_CONFIG.FORCE_CLEANUP_FC;
pub const CACHE_CONFIG_DISK_CACHE_PATHS_FC = CACHE_CONFIG.DISK_CACHE_PATHS_FC;
pub const CACHE_CONFIG_SYNC_MODE_FC = CACHE_CONFIG.SYNC_MODE_FC;
pub const CACHE_CONFIG_CONTENT_PATHS_FC = CACHE_CONFIG.CONTENT_PATHS_FC;
pub const CACHE_CONFIG_HISTORY_PATHS_FC = CACHE_CONFIG.HISTORY_PATHS_FC;
pub const CACHE_CONFIG_COOKIES_PATHS_FC = CACHE_CONFIG.COOKIES_PATHS_FC;
pub const CACHE_CONFIG_QUOTA_FC = CACHE_CONFIG.QUOTA_FC;
pub const CACHE_CONFIG_USER_MODE_FC = CACHE_CONFIG.USER_MODE_FC;
pub const CACHE_CONFIG_CONTENT_USAGE_FC = CACHE_CONFIG.CONTENT_USAGE_FC;
pub const CACHE_CONFIG_STICKY_CONTENT_USAGE_FC = CACHE_CONFIG.STICKY_CONTENT_USAGE_FC;

pub const FTP_FLAGS = enum(u32) {
    FTP_TRANSFER_TYPE_ASCII = 1,
    FTP_TRANSFER_TYPE_BINARY = 2,
    FTP_TRANSFER_TYPE_UNKNOWN = 0,
    pub const INTERNET_FLAG_TRANSFER_ASCII = .FTP_TRANSFER_TYPE_ASCII;
    pub const INTERNET_FLAG_TRANSFER_BINARY = .FTP_TRANSFER_TYPE_BINARY;
};
pub const FTP_TRANSFER_TYPE_ASCII = FTP_FLAGS.FTP_TRANSFER_TYPE_ASCII;
pub const FTP_TRANSFER_TYPE_BINARY = FTP_FLAGS.FTP_TRANSFER_TYPE_BINARY;
pub const FTP_TRANSFER_TYPE_UNKNOWN = FTP_FLAGS.FTP_TRANSFER_TYPE_UNKNOWN;
pub const INTERNET_FLAG_TRANSFER_ASCII = FTP_FLAGS.FTP_TRANSFER_TYPE_ASCII;
pub const INTERNET_FLAG_TRANSFER_BINARY = FTP_FLAGS.FTP_TRANSFER_TYPE_BINARY;

pub const INTERNET_CONNECTION = packed struct(u32) {
    CONNECTION_MODEM: u1 = 0,
    CONNECTION_LAN: u1 = 0,
    CONNECTION_PROXY: u1 = 0,
    CONNECTION_MODEM_BUSY: u1 = 0,
    RAS_INSTALLED: u1 = 0,
    CONNECTION_OFFLINE: u1 = 0,
    CONNECTION_CONFIGURED: u1 = 0,
    _7: u1 = 0,
    _8: u1 = 0,
    _9: u1 = 0,
    _10: u1 = 0,
    _11: u1 = 0,
    _12: u1 = 0,
    _13: u1 = 0,
    _14: u1 = 0,
    _15: u1 = 0,
    _16: u1 = 0,
    _17: u1 = 0,
    _18: u1 = 0,
    _19: u1 = 0,
    _20: u1 = 0,
    _21: u1 = 0,
    _22: u1 = 0,
    _23: u1 = 0,
    _24: u1 = 0,
    _25: u1 = 0,
    _26: u1 = 0,
    _27: u1 = 0,
    _28: u1 = 0,
    _29: u1 = 0,
    _30: u1 = 0,
    _31: u1 = 0,
};
pub const INTERNET_CONNECTION_CONFIGURED = INTERNET_CONNECTION{ .CONNECTION_CONFIGURED = 1 };
pub const INTERNET_CONNECTION_LAN = INTERNET_CONNECTION{ .CONNECTION_LAN = 1 };
pub const INTERNET_CONNECTION_MODEM = INTERNET_CONNECTION{ .CONNECTION_MODEM = 1 };
pub const INTERNET_CONNECTION_MODEM_BUSY = INTERNET_CONNECTION{ .CONNECTION_MODEM_BUSY = 1 };
pub const INTERNET_CONNECTION_OFFLINE = INTERNET_CONNECTION{ .CONNECTION_OFFLINE = 1 };
pub const INTERNET_CONNECTION_PROXY = INTERNET_CONNECTION{ .CONNECTION_PROXY = 1 };
pub const INTERNET_RAS_INSTALLED = INTERNET_CONNECTION{ .RAS_INSTALLED = 1 };

pub const HTTP_ADDREQ_FLAG = packed struct(u32) {
    _0: u1 = 0,
    _1: u1 = 0,
    _2: u1 = 0,
    _3: u1 = 0,
    _4: u1 = 0,
    _5: u1 = 0,
    _6: u1 = 0,
    _7: u1 = 0,
    _8: u1 = 0,
    _9: u1 = 0,
    _10: u1 = 0,
    _11: u1 = 0,
    _12: u1 = 0,
    _13: u1 = 0,
    _14: u1 = 0,
    _15: u1 = 0,
    _16: u1 = 0,
    _17: u1 = 0,
    _18: u1 = 0,
    _19: u1 = 0,
    _20: u1 = 0,
    _21: u1 = 0,
    _22: u1 = 0,
    _23: u1 = 0,
    COALESCE_WITH_SEMICOLON: u1 = 0,
    _25: u1 = 0,
    _26: u1 = 0,
    _27: u1 = 0,
    ADD_IF_NEW: u1 = 0,
    ADD: u1 = 0,
    COALESCE: u1 = 0,
    REPLACE: u1 = 0,
    // COALESCE_WITH_COMMA (bit index 30) conflicts with COALESCE
};
pub const HTTP_ADDREQ_FLAG_ADD = HTTP_ADDREQ_FLAG{ .ADD = 1 };
pub const HTTP_ADDREQ_FLAG_ADD_IF_NEW = HTTP_ADDREQ_FLAG{ .ADD_IF_NEW = 1 };
pub const HTTP_ADDREQ_FLAG_COALESCE = HTTP_ADDREQ_FLAG{ .COALESCE = 1 };
pub const HTTP_ADDREQ_FLAG_COALESCE_WITH_COMMA = HTTP_ADDREQ_FLAG{ .COALESCE = 1 };
pub const HTTP_ADDREQ_FLAG_COALESCE_WITH_SEMICOLON = HTTP_ADDREQ_FLAG{ .COALESCE_WITH_SEMICOLON = 1 };
pub const HTTP_ADDREQ_FLAG_REPLACE = HTTP_ADDREQ_FLAG{ .REPLACE = 1 };

pub const INTERNET_COOKIE_FLAGS = enum(u32) {
    COOKIE_HTTPONLY = 8192,
    COOKIE_THIRD_PARTY = 16,
    FLAG_RESTRICTED_ZONE = 131072,
};
pub const INTERNET_COOKIE_HTTPONLY = INTERNET_COOKIE_FLAGS.COOKIE_HTTPONLY;
pub const INTERNET_COOKIE_THIRD_PARTY = INTERNET_COOKIE_FLAGS.COOKIE_THIRD_PARTY;
pub const INTERNET_FLAG_RESTRICTED_ZONE = INTERNET_COOKIE_FLAGS.FLAG_RESTRICTED_ZONE;

pub const PROXY_AUTO_DETECT_TYPE = packed struct(u32) {
    HCP: u1 = 0,
    NS_A: u1 = 0,
    _2: u1 = 0,
    _3: u1 = 0,
    _4: u1 = 0,
    _5: u1 = 0,
    _6: u1 = 0,
    _7: u1 = 0,
    _8: u1 = 0,
    _9: u1 = 0,
    _10: u1 = 0,
    _11: u1 = 0,
    _12: u1 = 0,
    _13: u1 = 0,
    _14: u1 = 0,
    _15: u1 = 0,
    _16: u1 = 0,
    _17: u1 = 0,
    _18: u1 = 0,
    _19: u1 = 0,
    _20: u1 = 0,
    _21: u1 = 0,
    _22: u1 = 0,
    _23: u1 = 0,
    _24: u1 = 0,
    _25: u1 = 0,
    _26: u1 = 0,
    _27: u1 = 0,
    _28: u1 = 0,
    _29: u1 = 0,
    _30: u1 = 0,
    _31: u1 = 0,
};
pub const PROXY_AUTO_DETECT_TYPE_DHCP = PROXY_AUTO_DETECT_TYPE{ .HCP = 1 };
pub const PROXY_AUTO_DETECT_TYPE_DNS_A = PROXY_AUTO_DETECT_TYPE{ .NS_A = 1 };

pub const INTERNET_AUTODIAL = enum(u32) {
    FAILIFSECURITYCHECK = 4,
    FORCE_ONLINE = 1,
    FORCE_UNATTENDED = 2,
    OVERRIDE_NET_PRESENT = 8,
};
pub const INTERNET_AUTODIAL_FAILIFSECURITYCHECK = INTERNET_AUTODIAL.FAILIFSECURITYCHECK;
pub const INTERNET_AUTODIAL_FORCE_ONLINE = INTERNET_AUTODIAL.FORCE_ONLINE;
pub const INTERNET_AUTODIAL_FORCE_UNATTENDED = INTERNET_AUTODIAL.FORCE_UNATTENDED;
pub const INTERNET_AUTODIAL_OVERRIDE_NET_PRESENT = INTERNET_AUTODIAL.OVERRIDE_NET_PRESENT;

pub const GOPHER_TYPE = enum(u32) {
    ASK = 1073741824,
    BINARY = 512,
    BITMAP = 16384,
    CALENDAR = 524288,
    CSO = 4,
    DIRECTORY = 2,
    DOS_ARCHIVE = 32,
    ERROR = 8,
    GIF = 4096,
    GOPHER_PLUS = 2147483648,
    HTML = 131072,
    IMAGE = 8192,
    INDEX_SERVER = 128,
    INLINE = 1048576,
    MAC_BINHEX = 16,
    MOVIE = 32768,
    PDF = 262144,
    REDUNDANT = 1024,
    SOUND = 65536,
    TELNET = 256,
    TEXT_FILE = 1,
    TN3270 = 2048,
    UNIX_UUENCODED = 64,
    UNKNOWN = 536870912,
};
pub const GOPHER_TYPE_ASK = GOPHER_TYPE.ASK;
pub const GOPHER_TYPE_BINARY = GOPHER_TYPE.BINARY;
pub const GOPHER_TYPE_BITMAP = GOPHER_TYPE.BITMAP;
pub const GOPHER_TYPE_CALENDAR = GOPHER_TYPE.CALENDAR;
pub const GOPHER_TYPE_CSO = GOPHER_TYPE.CSO;
pub const GOPHER_TYPE_DIRECTORY = GOPHER_TYPE.DIRECTORY;
pub const GOPHER_TYPE_DOS_ARCHIVE = GOPHER_TYPE.DOS_ARCHIVE;
pub const GOPHER_TYPE_ERROR = GOPHER_TYPE.ERROR;
pub const GOPHER_TYPE_GIF = GOPHER_TYPE.GIF;
pub const GOPHER_TYPE_GOPHER_PLUS = GOPHER_TYPE.GOPHER_PLUS;
pub const GOPHER_TYPE_HTML = GOPHER_TYPE.HTML;
pub const GOPHER_TYPE_IMAGE = GOPHER_TYPE.IMAGE;
pub const GOPHER_TYPE_INDEX_SERVER = GOPHER_TYPE.INDEX_SERVER;
pub const GOPHER_TYPE_INLINE = GOPHER_TYPE.INLINE;
pub const GOPHER_TYPE_MAC_BINHEX = GOPHER_TYPE.MAC_BINHEX;
pub const GOPHER_TYPE_MOVIE = GOPHER_TYPE.MOVIE;
pub const GOPHER_TYPE_PDF = GOPHER_TYPE.PDF;
pub const GOPHER_TYPE_REDUNDANT = GOPHER_TYPE.REDUNDANT;
pub const GOPHER_TYPE_SOUND = GOPHER_TYPE.SOUND;
pub const GOPHER_TYPE_TELNET = GOPHER_TYPE.TELNET;
pub const GOPHER_TYPE_TEXT_FILE = GOPHER_TYPE.TEXT_FILE;
pub const GOPHER_TYPE_TN3270 = GOPHER_TYPE.TN3270;
pub const GOPHER_TYPE_UNIX_UUENCODED = GOPHER_TYPE.UNIX_UUENCODED;
pub const GOPHER_TYPE_UNKNOWN = GOPHER_TYPE.UNKNOWN;

pub const INTERNET_PER_CONN = enum(u32) {
    AUTOCONFIG_URL = 4,
    AUTODISCOVERY_FLAGS = 5,
    FLAGS = 1,
    PROXY_BYPASS = 3,
    PROXY_SERVER = 2,
    AUTOCONFIG_SECONDARY_URL = 6,
    AUTOCONFIG_RELOAD_DELAY_MINS = 7,
    AUTOCONFIG_LAST_DETECT_TIME = 8,
    AUTOCONFIG_LAST_DETECT_URL = 9,
};
pub const INTERNET_PER_CONN_AUTOCONFIG_URL = INTERNET_PER_CONN.AUTOCONFIG_URL;
pub const INTERNET_PER_CONN_AUTODISCOVERY_FLAGS = INTERNET_PER_CONN.AUTODISCOVERY_FLAGS;
pub const INTERNET_PER_CONN_FLAGS = INTERNET_PER_CONN.FLAGS;
pub const INTERNET_PER_CONN_PROXY_BYPASS = INTERNET_PER_CONN.PROXY_BYPASS;
pub const INTERNET_PER_CONN_PROXY_SERVER = INTERNET_PER_CONN.PROXY_SERVER;
pub const INTERNET_PER_CONN_AUTOCONFIG_SECONDARY_URL = INTERNET_PER_CONN.AUTOCONFIG_SECONDARY_URL;
pub const INTERNET_PER_CONN_AUTOCONFIG_RELOAD_DELAY_MINS = INTERNET_PER_CONN.AUTOCONFIG_RELOAD_DELAY_MINS;
pub const INTERNET_PER_CONN_AUTOCONFIG_LAST_DETECT_TIME = INTERNET_PER_CONN.AUTOCONFIG_LAST_DETECT_TIME;
pub const INTERNET_PER_CONN_AUTOCONFIG_LAST_DETECT_URL = INTERNET_PER_CONN.AUTOCONFIG_LAST_DETECT_URL;

pub const INTERNET_ACCESS_TYPE = enum(u32) {
    DIRECT = 1,
    PRECONFIG = 0,
    PROXY = 3,
};
pub const INTERNET_OPEN_TYPE_DIRECT = INTERNET_ACCESS_TYPE.DIRECT;
pub const INTERNET_OPEN_TYPE_PRECONFIG = INTERNET_ACCESS_TYPE.PRECONFIG;
pub const INTERNET_OPEN_TYPE_PROXY = INTERNET_ACCESS_TYPE.PROXY;

pub const INTERNET_STATE = enum(u32) {
    CONNECTED = 1,
    DISCONNECTED = 2,
    DISCONNECTED_BY_USER = 16,
    IDLE = 256,
    BUSY = 512,
};
pub const INTERNET_STATE_CONNECTED = INTERNET_STATE.CONNECTED;
pub const INTERNET_STATE_DISCONNECTED = INTERNET_STATE.DISCONNECTED;
pub const INTERNET_STATE_DISCONNECTED_BY_USER = INTERNET_STATE.DISCONNECTED_BY_USER;
pub const INTERNET_STATE_IDLE = INTERNET_STATE.IDLE;
pub const INTERNET_STATE_BUSY = INTERNET_STATE.BUSY;

// TODO: this type has an InvalidHandleValue of '0', what can Zig do with this information?
pub const HTTP_PUSH_WAIT_HANDLE = isize;

pub const INTERNET_SCHEME = enum(i32) {
    PARTIAL = -2,
    UNKNOWN = -1,
    DEFAULT = 0,
    FTP = 1,
    GOPHER = 2,
    HTTP = 3,
    HTTPS = 4,
    FILE = 5,
    NEWS = 6,
    MAILTO = 7,
    SOCKS = 8,
    JAVASCRIPT = 9,
    VBSCRIPT = 10,
    RES = 11,
    pub const FIRST = .FTP;
    pub const LAST = .RES;
};
pub const INTERNET_SCHEME_PARTIAL = INTERNET_SCHEME.PARTIAL;
pub const INTERNET_SCHEME_UNKNOWN = INTERNET_SCHEME.UNKNOWN;
pub const INTERNET_SCHEME_DEFAULT = INTERNET_SCHEME.DEFAULT;
pub const INTERNET_SCHEME_FTP = INTERNET_SCHEME.FTP;
pub const INTERNET_SCHEME_GOPHER = INTERNET_SCHEME.GOPHER;
pub const INTERNET_SCHEME_HTTP = INTERNET_SCHEME.HTTP;
pub const INTERNET_SCHEME_HTTPS = INTERNET_SCHEME.HTTPS;
pub const INTERNET_SCHEME_FILE = INTERNET_SCHEME.FILE;
pub const INTERNET_SCHEME_NEWS = INTERNET_SCHEME.NEWS;
pub const INTERNET_SCHEME_MAILTO = INTERNET_SCHEME.MAILTO;
pub const INTERNET_SCHEME_SOCKS = INTERNET_SCHEME.SOCKS;
pub const INTERNET_SCHEME_JAVASCRIPT = INTERNET_SCHEME.JAVASCRIPT;
pub const INTERNET_SCHEME_VBSCRIPT = INTERNET_SCHEME.VBSCRIPT;
pub const INTERNET_SCHEME_RES = INTERNET_SCHEME.RES;
pub const INTERNET_SCHEME_FIRST = INTERNET_SCHEME.FTP;
pub const INTERNET_SCHEME_LAST = INTERNET_SCHEME.RES;

pub const INTERNET_ASYNC_RESULT = extern struct {
    dwResult: usize,
    dwError: u32,
};

pub const INTERNET_DIAGNOSTIC_SOCKET_INFO = extern struct {
    Socket: usize,
    SourcePort: u32,
    DestPort: u32,
    Flags: u32,
};

pub const INTERNET_PROXY_INFO = extern struct {
    dwAccessType: INTERNET_ACCESS_TYPE,
    lpszProxy: ?*i8,
    lpszProxyBypass: ?*i8,
};

pub const INTERNET_PER_CONN_OPTIONA = extern struct {
    dwOption: INTERNET_PER_CONN,
    Value: extern union {
        dwValue: u32,
        pszValue: ?PSTR,
        ftValue: FILETIME,
    },
};

pub const INTERNET_PER_CONN_OPTIONW = extern struct {
    dwOption: INTERNET_PER_CONN,
    Value: extern union {
        dwValue: u32,
        pszValue: ?PWSTR,
        ftValue: FILETIME,
    },
};

pub const INTERNET_PER_CONN_OPTION_LISTA = extern struct {
    dwSize: u32,
    pszConnection: ?PSTR,
    dwOptionCount: u32,
    dwOptionError: u32,
    pOptions: ?*INTERNET_PER_CONN_OPTIONA,
};

pub const INTERNET_PER_CONN_OPTION_LISTW = extern struct {
    dwSize: u32,
    pszConnection: ?PWSTR,
    dwOptionCount: u32,
    dwOptionError: u32,
    pOptions: ?*INTERNET_PER_CONN_OPTIONW,
};

pub const INTERNET_VERSION_INFO = extern struct {
    dwMajorVersion: u32,
    dwMinorVersion: u32,
};

pub const INTERNET_CONNECTED_INFO = extern struct {
    dwConnectedState: INTERNET_STATE,
    dwFlags: u32,
};

pub const URL_COMPONENTSA = extern struct {
    dwStructSize: u32,
    lpszScheme: ?PSTR,
    dwSchemeLength: u32,
    nScheme: INTERNET_SCHEME,
    lpszHostName: ?PSTR,
    dwHostNameLength: u32,
    nPort: u16,
    lpszUserName: ?PSTR,
    dwUserNameLength: u32,
    lpszPassword: ?PSTR,
    dwPasswordLength: u32,
    lpszUrlPath: ?PSTR,
    dwUrlPathLength: u32,
    lpszExtraInfo: ?PSTR,
    dwExtraInfoLength: u32,
};

pub const URL_COMPONENTSW = extern struct {
    dwStructSize: u32,
    lpszScheme: ?PWSTR,
    dwSchemeLength: u32,
    nScheme: INTERNET_SCHEME,
    lpszHostName: ?PWSTR,
    dwHostNameLength: u32,
    nPort: u16,
    lpszUserName: ?PWSTR,
    dwUserNameLength: u32,
    lpszPassword: ?PWSTR,
    dwPasswordLength: u32,
    lpszUrlPath: ?PWSTR,
    dwUrlPathLength: u32,
    lpszExtraInfo: ?PWSTR,
    dwExtraInfoLength: u32,
};

pub const INTERNET_CERTIFICATE_INFO = extern struct {
    ftExpiry: FILETIME,
    ftStart: FILETIME,
    lpszSubjectInfo: ?*i8,
    lpszIssuerInfo: ?*i8,
    lpszProtocolName: ?*i8,
    lpszSignatureAlgName: ?*i8,
    lpszEncryptionAlgName: ?*i8,
    dwKeySize: u32,
};

pub const INTERNET_BUFFERSA = extern struct {
    dwStructSize: u32,
    Next: ?*INTERNET_BUFFERSA,
    lpcszHeader: ?[*:0]const u8,
    dwHeadersLength: u32,
    dwHeadersTotal: u32,
    lpvBuffer: ?*anyopaque,
    dwBufferLength: u32,
    dwBufferTotal: u32,
    dwOffsetLow: u32,
    dwOffsetHigh: u32,
};

pub const INTERNET_BUFFERSW = extern struct {
    dwStructSize: u32,
    Next: ?*INTERNET_BUFFERSW,
    lpcszHeader: ?[*:0]const u16,
    dwHeadersLength: u32,
    dwHeadersTotal: u32,
    lpvBuffer: ?*anyopaque,
    dwBufferLength: u32,
    dwBufferTotal: u32,
    dwOffsetLow: u32,
    dwOffsetHigh: u32,
};

pub const LPINTERNET_STATUS_CALLBACK = *const fn(
    hInternet: ?*anyopaque,
    dwContext: usize,
    dwInternetStatus: u32,
    lpvStatusInformation: ?*anyopaque,
    dwStatusInformationLength: u32,
) callconv(@import("std").os.windows.WINAPI) void;

pub const InternetCookieState = enum(i32) {
    UNKNOWN = 0,
    ACCEPT = 1,
    PROMPT = 2,
    LEASH = 3,
    DOWNGRADE = 4,
    REJECT = 5,
    pub const MAX = .REJECT;
};
pub const COOKIE_STATE_UNKNOWN = InternetCookieState.UNKNOWN;
pub const COOKIE_STATE_ACCEPT = InternetCookieState.ACCEPT;
pub const COOKIE_STATE_PROMPT = InternetCookieState.PROMPT;
pub const COOKIE_STATE_LEASH = InternetCookieState.LEASH;
pub const COOKIE_STATE_DOWNGRADE = InternetCookieState.DOWNGRADE;
pub const COOKIE_STATE_REJECT = InternetCookieState.REJECT;
pub const COOKIE_STATE_MAX = InternetCookieState.REJECT;

pub const IncomingCookieState = extern struct {
    cSession: i32,
    cPersistent: i32,
    cAccepted: i32,
    cLeashed: i32,
    cDowngraded: i32,
    cBlocked: i32,
    pszLocation: ?[*:0]const u8,
};

pub const OutgoingCookieState = extern struct {
    cSent: i32,
    cSuppressed: i32,
    pszLocation: ?[*:0]const u8,
};

pub const InternetCookieHistory = extern struct {
    fAccepted: BOOL,
    fLeashed: BOOL,
    fDowngraded: BOOL,
    fRejected: BOOL,
};

pub const CookieDecision = extern struct {
    dwCookieState: u32,
    fAllowSession: BOOL,
};

pub const GOPHER_FIND_DATAA = extern struct {
    DisplayString: [129]CHAR,
    GopherType: GOPHER_TYPE,
    SizeLow: u32,
    SizeHigh: u32,
    LastModificationTime: FILETIME,
    Locator: [654]CHAR,
};

pub const GOPHER_FIND_DATAW = extern struct {
    DisplayString: [129]u16,
    GopherType: GOPHER_TYPE,
    SizeLow: u32,
    SizeHigh: u32,
    LastModificationTime: FILETIME,
    Locator: [654]u16,
};

pub const GOPHER_ADMIN_ATTRIBUTE_TYPE = extern struct {
    Comment: ?*i8,
    EmailAddress: ?*i8,
};

pub const GOPHER_MOD_DATE_ATTRIBUTE_TYPE = extern struct {
    DateAndTime: FILETIME,
};

pub const GOPHER_TTL_ATTRIBUTE_TYPE = extern struct {
    Ttl: u32,
};

pub const GOPHER_SCORE_ATTRIBUTE_TYPE = extern struct {
    Score: i32,
};

pub const GOPHER_SCORE_RANGE_ATTRIBUTE_TYPE = extern struct {
    LowerBound: i32,
    UpperBound: i32,
};

pub const GOPHER_SITE_ATTRIBUTE_TYPE = extern struct {
    Site: ?*i8,
};

pub const GOPHER_ORGANIZATION_ATTRIBUTE_TYPE = extern struct {
    Organization: ?*i8,
};

pub const GOPHER_LOCATION_ATTRIBUTE_TYPE = extern struct {
    Location: ?*i8,
};

pub const GOPHER_GEOGRAPHICAL_LOCATION_ATTRIBUTE_TYPE = extern struct {
    DegreesNorth: i32,
    MinutesNorth: i32,
    SecondsNorth: i32,
    DegreesEast: i32,
    MinutesEast: i32,
    SecondsEast: i32,
};

pub const GOPHER_TIMEZONE_ATTRIBUTE_TYPE = extern struct {
    Zone: i32,
};

pub const GOPHER_PROVIDER_ATTRIBUTE_TYPE = extern struct {
    Provider: ?*i8,
};

pub const GOPHER_VERSION_ATTRIBUTE_TYPE = extern struct {
    Version: ?*i8,
};

pub const GOPHER_ABSTRACT_ATTRIBUTE_TYPE = extern struct {
    ShortAbstract: ?*i8,
    AbstractFile: ?*i8,
};

pub const GOPHER_VIEW_ATTRIBUTE_TYPE = extern struct {
    ContentType: ?*i8,
    Language: ?*i8,
    Size: u32,
};

pub const GOPHER_VERONICA_ATTRIBUTE_TYPE = extern struct {
    TreeWalk: BOOL,
};

pub const GOPHER_ASK_ATTRIBUTE_TYPE = extern struct {
    QuestionType: ?*i8,
    QuestionText: ?*i8,
};

pub const GOPHER_UNKNOWN_ATTRIBUTE_TYPE = extern struct {
    Text: ?*i8,
};

pub const GOPHER_ATTRIBUTE_TYPE = extern struct {
    CategoryId: u32,
    AttributeId: u32,
    AttributeType: extern union {
        Admin: GOPHER_ADMIN_ATTRIBUTE_TYPE,
        ModDate: GOPHER_MOD_DATE_ATTRIBUTE_TYPE,
        Ttl: GOPHER_TTL_ATTRIBUTE_TYPE,
        Score: GOPHER_SCORE_ATTRIBUTE_TYPE,
        ScoreRange: GOPHER_SCORE_RANGE_ATTRIBUTE_TYPE,
        Site: GOPHER_SITE_ATTRIBUTE_TYPE,
        Organization: GOPHER_ORGANIZATION_ATTRIBUTE_TYPE,
        Location: GOPHER_LOCATION_ATTRIBUTE_TYPE,
        GeographicalLocation: GOPHER_GEOGRAPHICAL_LOCATION_ATTRIBUTE_TYPE,
        TimeZone: GOPHER_TIMEZONE_ATTRIBUTE_TYPE,
        Provider: GOPHER_PROVIDER_ATTRIBUTE_TYPE,
        Version: GOPHER_VERSION_ATTRIBUTE_TYPE,
        Abstract: GOPHER_ABSTRACT_ATTRIBUTE_TYPE,
        View: GOPHER_VIEW_ATTRIBUTE_TYPE,
        Veronica: GOPHER_VERONICA_ATTRIBUTE_TYPE,
        Ask: GOPHER_ASK_ATTRIBUTE_TYPE,
        Unknown: GOPHER_UNKNOWN_ATTRIBUTE_TYPE,
    },
};

pub const GOPHER_ATTRIBUTE_ENUMERATOR = *const fn(
    lpAttributeInfo: ?*GOPHER_ATTRIBUTE_TYPE,
    dwError: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const INTERNET_COOKIE2 = extern struct {
    pwszName: ?PWSTR,
    pwszValue: ?PWSTR,
    pwszDomain: ?PWSTR,
    pwszPath: ?PWSTR,
    dwFlags: u32,
    ftExpires: FILETIME,
    fExpiresSet: BOOL,
};

pub const PFN_AUTH_NOTIFY = *const fn(
    param0: usize,
    param1: u32,
    param2: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const INTERNET_AUTH_NOTIFY_DATA = extern struct {
    cbStruct: u32,
    dwOptions: u32,
    pfnNotify: ?PFN_AUTH_NOTIFY,
    dwContext: usize,
};

pub const INTERNET_CACHE_ENTRY_INFOA = extern struct {
    dwStructSize: u32,
    lpszSourceUrlName: ?PSTR,
    lpszLocalFileName: ?PSTR,
    CacheEntryType: u32,
    dwUseCount: u32,
    dwHitRate: u32,
    dwSizeLow: u32,
    dwSizeHigh: u32,
    LastModifiedTime: FILETIME,
    ExpireTime: FILETIME,
    LastAccessTime: FILETIME,
    LastSyncTime: FILETIME,
    lpHeaderInfo: ?PSTR,
    dwHeaderInfoSize: u32,
    lpszFileExtension: ?PSTR,
    Anonymous: extern union {
        dwReserved: u32,
        dwExemptDelta: u32,
    },
};

pub const INTERNET_CACHE_ENTRY_INFOW = extern struct {
    dwStructSize: u32,
    lpszSourceUrlName: ?PWSTR,
    lpszLocalFileName: ?PWSTR,
    CacheEntryType: u32,
    dwUseCount: u32,
    dwHitRate: u32,
    dwSizeLow: u32,
    dwSizeHigh: u32,
    LastModifiedTime: FILETIME,
    ExpireTime: FILETIME,
    LastAccessTime: FILETIME,
    LastSyncTime: FILETIME,
    lpHeaderInfo: ?PWSTR,
    dwHeaderInfoSize: u32,
    lpszFileExtension: ?PWSTR,
    Anonymous: extern union {
        dwReserved: u32,
        dwExemptDelta: u32,
    },
};

pub const INTERNET_CACHE_TIMESTAMPS = extern struct {
    ftExpires: FILETIME,
    ftLastModified: FILETIME,
};

pub const INTERNET_CACHE_GROUP_INFOA = extern struct {
    dwGroupSize: u32,
    dwGroupFlags: u32,
    dwGroupType: u32,
    dwDiskUsage: u32,
    dwDiskQuota: u32,
    dwOwnerStorage: [4]u32,
    szGroupName: [120]CHAR,
};

pub const INTERNET_CACHE_GROUP_INFOW = extern struct {
    dwGroupSize: u32,
    dwGroupFlags: u32,
    dwGroupType: u32,
    dwDiskUsage: u32,
    dwDiskQuota: u32,
    dwOwnerStorage: [4]u32,
    szGroupName: [120]u16,
};

pub const AutoProxyHelperVtbl = extern struct {
    IsResolvable: isize,
    GetIPAddress: isize,
    ResolveHostName: isize,
    IsInNet: isize,
    IsResolvableEx: isize,
    GetIPAddressEx: isize,
    ResolveHostNameEx: isize,
    IsInNetEx: isize,
    SortIpList: isize,
};

pub const AUTO_PROXY_SCRIPT_BUFFER = extern struct {
    dwStructSize: u32,
    lpszScriptBuffer: ?PSTR,
    dwScriptBufferSize: u32,
};

pub const AutoProxyHelperFunctions = extern struct {
    lpVtbl: ?*const AutoProxyHelperVtbl,
};

pub const pfnInternetInitializeAutoProxyDll = *const fn(
    dwVersion: u32,
    lpszDownloadedTempFile: ?PSTR,
    lpszMime: ?PSTR,
    lpAutoProxyCallbacks: ?*AutoProxyHelperFunctions,
    lpAutoProxyScriptBuffer: ?*AUTO_PROXY_SCRIPT_BUFFER,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const pfnInternetDeInitializeAutoProxyDll = *const fn(
    lpszMime: ?PSTR,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const pfnInternetGetProxyInfo = *const fn(
    lpszUrl: ?[*:0]const u8,
    dwUrlLength: u32,
    lpszUrlHostName: ?PSTR,
    dwUrlHostNameLength: u32,
    lplpszProxyHostName: ?*?PSTR,
    lpdwProxyHostNameLength: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const WPAD_CACHE_DELETE = enum(i32) {
    CURRENT = 0,
    ALL = 1,
};
pub const WPAD_CACHE_DELETE_CURRENT = WPAD_CACHE_DELETE.CURRENT;
pub const WPAD_CACHE_DELETE_ALL = WPAD_CACHE_DELETE.ALL;

pub const PFN_DIAL_HANDLER = *const fn(
    param0: ?HWND,
    param1: ?[*:0]const u8,
    param2: u32,
    param3: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

const IID_IDialEventSink_Value = Guid.initString("2d86f4ff-6e2d-4488-b2e9-6934afd41bea");
pub const IID_IDialEventSink = &IID_IDialEventSink_Value;
pub const IDialEventSink = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnEvent: *const fn(
            self: *const IDialEventSink,
            dwEvent: u32,
            dwStatus: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn OnEvent(self: *const IDialEventSink, dwEvent: u32, dwStatus: u32) callconv(.Inline) HRESULT {
        return self.vtable.OnEvent(self, dwEvent, dwStatus);
    }
};

const IID_IDialEngine_Value = Guid.initString("39fd782b-7905-40d5-9148-3c9b190423d5");
pub const IID_IDialEngine = &IID_IDialEngine_Value;
pub const IDialEngine = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: *const fn(
            self: *const IDialEngine,
            pwzConnectoid: ?[*:0]const u16,
            pIDES: ?*IDialEventSink,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperty: *const fn(
            self: *const IDialEngine,
            pwzProperty: ?[*:0]const u16,
            pwzValue: ?PWSTR,
            dwBufSize: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProperty: *const fn(
            self: *const IDialEngine,
            pwzProperty: ?[*:0]const u16,
            pwzValue: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Dial: *const fn(
            self: *const IDialEngine,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HangUp: *const fn(
            self: *const IDialEngine,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetConnectedState: *const fn(
            self: *const IDialEngine,
            pdwState: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetConnectHandle: *const fn(
            self: *const IDialEngine,
            pdwHandle: ?*usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn Initialize(self: *const IDialEngine, pwzConnectoid: ?[*:0]const u16, pIDES: ?*IDialEventSink) callconv(.Inline) HRESULT {
        return self.vtable.Initialize(self, pwzConnectoid, pIDES);
    }
    pub fn GetProperty(self: *const IDialEngine, pwzProperty: ?[*:0]const u16, pwzValue: ?PWSTR, dwBufSize: u32) callconv(.Inline) HRESULT {
        return self.vtable.GetProperty(self, pwzProperty, pwzValue, dwBufSize);
    }
    pub fn SetProperty(self: *const IDialEngine, pwzProperty: ?[*:0]const u16, pwzValue: ?[*:0]const u16) callconv(.Inline) HRESULT {
        return self.vtable.SetProperty(self, pwzProperty, pwzValue);
    }
    pub fn Dial(self: *const IDialEngine) callconv(.Inline) HRESULT {
        return self.vtable.Dial(self);
    }
    pub fn HangUp(self: *const IDialEngine) callconv(.Inline) HRESULT {
        return self.vtable.HangUp(self);
    }
    pub fn GetConnectedState(self: *const IDialEngine, pdwState: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.GetConnectedState(self, pdwState);
    }
    pub fn GetConnectHandle(self: *const IDialEngine, pdwHandle: ?*usize) callconv(.Inline) HRESULT {
        return self.vtable.GetConnectHandle(self, pdwHandle);
    }
};

const IID_IDialBranding_Value = Guid.initString("8aecafa9-4306-43cc-8c5a-765f2979cc16");
pub const IID_IDialBranding = &IID_IDialBranding_Value;
pub const IDialBranding = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: *const fn(
            self: *const IDialBranding,
            pwzConnectoid: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBitmap: *const fn(
            self: *const IDialBranding,
            dwIndex: u32,
            phBitmap: ?*?HBITMAP,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn Initialize(self: *const IDialBranding, pwzConnectoid: ?[*:0]const u16) callconv(.Inline) HRESULT {
        return self.vtable.Initialize(self, pwzConnectoid);
    }
    pub fn GetBitmap(self: *const IDialBranding, dwIndex: u32, phBitmap: ?*?HBITMAP) callconv(.Inline) HRESULT {
        return self.vtable.GetBitmap(self, dwIndex, phBitmap);
    }
};

pub const INTERNET_PREFETCH_STATUS = extern struct {
    dwStatus: u32,
    dwSize: u32,
};

pub const INTERNET_SECURITY_INFO = extern struct {
    dwSize: u32,
    pCertificate: ?*const CERT_CONTEXT,
    pcCertChain: ?*CERT_CHAIN_CONTEXT,
    connectionInfo: SecPkgContext_ConnectionInfo,
    cipherInfo: SecPkgContext_CipherInfo,
    pcUnverifiedCertChain: ?*CERT_CHAIN_CONTEXT,
    channelBindingToken: SecPkgContext_Bindings,
};

pub const INTERNET_SECURITY_CONNECTION_INFO = extern struct {
    dwSize: u32,
    fSecure: BOOL,
    connectionInfo: SecPkgContext_ConnectionInfo,
    cipherInfo: SecPkgContext_CipherInfo,
};

pub const FORTCMD = enum(i32) {
    LOGON = 1,
    LOGOFF = 2,
    CHG_PERSONALITY = 3,
};
pub const FORTCMD_LOGON = FORTCMD.LOGON;
pub const FORTCMD_LOGOFF = FORTCMD.LOGOFF;
pub const FORTCMD_CHG_PERSONALITY = FORTCMD.CHG_PERSONALITY;

pub const FORTSTAT = enum(i32) {
    INSTALLED = 1,
    LOGGEDON = 2,
};
pub const FORTSTAT_INSTALLED = FORTSTAT.INSTALLED;
pub const FORTSTAT_LOGGEDON = FORTSTAT.LOGGEDON;

pub const INTERNET_DOWNLOAD_MODE_HANDLE = extern struct {
    pcwszFileName: ?[*:0]const u16,
    phFile: ?*?HANDLE,
};

pub const REQUEST_TIMES = enum(i32) {
    NameResolutionStart = 0,
    NameResolutionEnd = 1,
    ConnectionEstablishmentStart = 2,
    ConnectionEstablishmentEnd = 3,
    TLSHandshakeStart = 4,
    TLSHandshakeEnd = 5,
    HttpRequestTimeMax = 32,
};
pub const NameResolutionStart = REQUEST_TIMES.NameResolutionStart;
pub const NameResolutionEnd = REQUEST_TIMES.NameResolutionEnd;
pub const ConnectionEstablishmentStart = REQUEST_TIMES.ConnectionEstablishmentStart;
pub const ConnectionEstablishmentEnd = REQUEST_TIMES.ConnectionEstablishmentEnd;
pub const TLSHandshakeStart = REQUEST_TIMES.TLSHandshakeStart;
pub const TLSHandshakeEnd = REQUEST_TIMES.TLSHandshakeEnd;
pub const HttpRequestTimeMax = REQUEST_TIMES.HttpRequestTimeMax;

pub const HTTP_REQUEST_TIMES = extern struct {
    cTimes: u32,
    rgTimes: [32]u64,
};

pub const INTERNET_SERVER_CONNECTION_STATE = extern struct {
    lpcwszHostName: ?[*:0]const u16,
    fProxy: BOOL,
    dwCounter: u32,
    dwConnectionLimit: u32,
    dwAvailableCreates: u32,
    dwAvailableKeepAlives: u32,
    dwActiveConnections: u32,
    dwWaiters: u32,
};

pub const INTERNET_END_BROWSER_SESSION_DATA = extern struct {
    lpBuffer: ?*anyopaque,
    dwBufferLength: u32,
};

pub const INTERNET_CALLBACK_COOKIE = extern struct {
    pcwszName: ?[*:0]const u16,
    pcwszValue: ?[*:0]const u16,
    pcwszDomain: ?[*:0]const u16,
    pcwszPath: ?[*:0]const u16,
    ftExpires: FILETIME,
    dwFlags: u32,
};

pub const INTERNET_CREDENTIALS = extern struct {
    lpcwszHostName: ?[*:0]const u16,
    dwPort: u32,
    dwScheme: u32,
    lpcwszUrl: ?[*:0]const u16,
    lpcwszRealm: ?[*:0]const u16,
    fAuthIdentity: BOOL,
    Anonymous: extern union {
        Anonymous: extern struct {
            lpcwszUserName: ?[*:0]const u16,
            lpcwszPassword: ?[*:0]const u16,
        },
        pAuthIdentityOpaque: ?*anyopaque,
    },
};

pub const HTTP_PUSH_TRANSPORT_SETTING = extern struct {
    TransportSettingId: Guid,
    BrokerEventId: Guid,
};

pub const HTTP_PUSH_NOTIFICATION_STATUS = extern struct {
    ChannelStatusValid: BOOL,
    ChannelStatus: u32,
};

pub const HTTP_PUSH_WAIT_TYPE = enum(i32) {
    EnableComplete = 0,
    ReceiveComplete = 1,
    SendComplete = 2,
};
pub const HttpPushWaitEnableComplete = HTTP_PUSH_WAIT_TYPE.EnableComplete;
pub const HttpPushWaitReceiveComplete = HTTP_PUSH_WAIT_TYPE.ReceiveComplete;
pub const HttpPushWaitSendComplete = HTTP_PUSH_WAIT_TYPE.SendComplete;

pub const INTERNET_COOKIE = extern struct {
    cbSize: u32,
    pszName: ?PSTR,
    pszData: ?PSTR,
    pszDomain: ?PSTR,
    pszPath: ?PSTR,
    pftExpires: ?*FILETIME,
    dwFlags: u32,
    pszUrl: ?PSTR,
    pszP3PPolicy: ?PSTR,
};

pub const COOKIE_DLG_INFO = extern struct {
    pszServer: ?PWSTR,
    pic: ?*INTERNET_COOKIE,
    dwStopWarning: u32,
    cx: i32,
    cy: i32,
    pszHeader: ?PWSTR,
    dwOperation: u32,
};

pub const INTERNET_CACHE_CONFIG_PATH_ENTRYA = extern struct {
    CachePath: [260]CHAR,
    dwCacheSize: u32,
};

pub const INTERNET_CACHE_CONFIG_PATH_ENTRYW = extern struct {
    CachePath: [260]u16,
    dwCacheSize: u32,
};

pub const INTERNET_CACHE_CONFIG_INFOA = extern struct {
    dwStructSize: u32,
    dwContainer: u32,
    dwQuota: u32,
    dwReserved4: u32,
    fPerUser: BOOL,
    dwSyncMode: u32,
    dwNumCachePaths: u32,
    Anonymous: extern union {
        Anonymous: extern struct {
            CachePath: [260]CHAR,
            dwCacheSize: u32,
        },
        CachePaths: [1]INTERNET_CACHE_CONFIG_PATH_ENTRYA,
    },
    dwNormalUsage: u32,
    dwExemptUsage: u32,
};

pub const INTERNET_CACHE_CONFIG_INFOW = extern struct {
    dwStructSize: u32,
    dwContainer: u32,
    dwQuota: u32,
    dwReserved4: u32,
    fPerUser: BOOL,
    dwSyncMode: u32,
    dwNumCachePaths: u32,
    Anonymous: extern union {
        Anonymous: extern struct {
            CachePath: [260]u16,
            dwCacheSize: u32,
        },
        CachePaths: [1]INTERNET_CACHE_CONFIG_PATH_ENTRYW,
    },
    dwNormalUsage: u32,
    dwExemptUsage: u32,
};

pub const INTERNET_CACHE_CONTAINER_INFOA = extern struct {
    dwCacheVersion: u32,
    lpszName: ?PSTR,
    lpszCachePrefix: ?PSTR,
    lpszVolumeLabel: ?PSTR,
    lpszVolumeTitle: ?PSTR,
};

pub const INTERNET_CACHE_CONTAINER_INFOW = extern struct {
    dwCacheVersion: u32,
    lpszName: ?PWSTR,
    lpszCachePrefix: ?PWSTR,
    lpszVolumeLabel: ?PWSTR,
    lpszVolumeTitle: ?PWSTR,
};

pub const WININET_SYNC_MODE = enum(i32) {
    NEVER = 0,
    ON_EXPIRY = 1,
    ONCE_PER_SESSION = 2,
    ALWAYS = 3,
    AUTOMATIC = 4,
    pub const DEFAULT = .AUTOMATIC;
};
pub const WININET_SYNC_MODE_NEVER = WININET_SYNC_MODE.NEVER;
pub const WININET_SYNC_MODE_ON_EXPIRY = WININET_SYNC_MODE.ON_EXPIRY;
pub const WININET_SYNC_MODE_ONCE_PER_SESSION = WININET_SYNC_MODE.ONCE_PER_SESSION;
pub const WININET_SYNC_MODE_ALWAYS = WININET_SYNC_MODE.ALWAYS;
pub const WININET_SYNC_MODE_AUTOMATIC = WININET_SYNC_MODE.AUTOMATIC;
pub const WININET_SYNC_MODE_DEFAULT = WININET_SYNC_MODE.AUTOMATIC;

pub const APP_CACHE_STATE = enum(i32) {
    NoUpdateNeeded = 0,
    UpdateNeeded = 1,
    UpdateNeededNew = 2,
    UpdateNeededMasterOnly = 3,
};
pub const AppCacheStateNoUpdateNeeded = APP_CACHE_STATE.NoUpdateNeeded;
pub const AppCacheStateUpdateNeeded = APP_CACHE_STATE.UpdateNeeded;
pub const AppCacheStateUpdateNeededNew = APP_CACHE_STATE.UpdateNeededNew;
pub const AppCacheStateUpdateNeededMasterOnly = APP_CACHE_STATE.UpdateNeededMasterOnly;

pub const APP_CACHE_DOWNLOAD_ENTRY = extern struct {
    pwszUrl: ?PWSTR,
    dwEntryType: u32,
};

pub const APP_CACHE_DOWNLOAD_LIST = extern struct {
    dwEntryCount: u32,
    pEntries: ?*APP_CACHE_DOWNLOAD_ENTRY,
};

pub const APP_CACHE_FINALIZE_STATE = enum(i32) {
    Incomplete = 0,
    ManifestChange = 1,
    Complete = 2,
};
pub const AppCacheFinalizeStateIncomplete = APP_CACHE_FINALIZE_STATE.Incomplete;
pub const AppCacheFinalizeStateManifestChange = APP_CACHE_FINALIZE_STATE.ManifestChange;
pub const AppCacheFinalizeStateComplete = APP_CACHE_FINALIZE_STATE.Complete;

pub const APP_CACHE_GROUP_INFO = extern struct {
    pwszManifestUrl: ?PWSTR,
    ftLastAccessTime: FILETIME,
    ullSize: u64,
};

pub const APP_CACHE_GROUP_LIST = extern struct {
    dwAppCacheGroupCount: u32,
    pAppCacheGroups: ?*APP_CACHE_GROUP_INFO,
};

pub const URLCACHE_ENTRY_INFO = extern struct {
    pwszSourceUrlName: ?PWSTR,
    pwszLocalFileName: ?PWSTR,
    dwCacheEntryType: u32,
    dwUseCount: u32,
    dwHitRate: u32,
    dwSizeLow: u32,
    dwSizeHigh: u32,
    ftLastModifiedTime: FILETIME,
    ftExpireTime: FILETIME,
    ftLastAccessTime: FILETIME,
    ftLastSyncTime: FILETIME,
    pbHeaderInfo: ?*u8,
    cbHeaderInfoSize: u32,
    pbExtraData: ?*u8,
    cbExtraDataSize: u32,
};

pub const URL_CACHE_LIMIT_TYPE = enum(i32) {
    IE = 0,
    IETotal = 1,
    AppContainer = 2,
    AppContainerTotal = 3,
    Num = 4,
};
pub const UrlCacheLimitTypeIE = URL_CACHE_LIMIT_TYPE.IE;
pub const UrlCacheLimitTypeIETotal = URL_CACHE_LIMIT_TYPE.IETotal;
pub const UrlCacheLimitTypeAppContainer = URL_CACHE_LIMIT_TYPE.AppContainer;
pub const UrlCacheLimitTypeAppContainerTotal = URL_CACHE_LIMIT_TYPE.AppContainerTotal;
pub const UrlCacheLimitTypeNum = URL_CACHE_LIMIT_TYPE.Num;

pub const WININET_PROXY_INFO = extern struct {
    fProxy: BOOL,
    fBypass: BOOL,
    ProxyScheme: INTERNET_SCHEME,
    pwszProxy: ?PWSTR,
    ProxyPort: u16,
};

pub const WININET_PROXY_INFO_LIST = extern struct {
    dwProxyInfoCount: u32,
    pProxyInfo: ?*WININET_PROXY_INFO,
};

pub const CACHE_OPERATOR = *const fn(
    pcei: ?*INTERNET_CACHE_ENTRY_INFOA,
    pcbcei: ?*u32,
    pOpData: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const HTTP_WEB_SOCKET_OPERATION = enum(i32) {
    SEND_OPERATION = 0,
    RECEIVE_OPERATION = 1,
    CLOSE_OPERATION = 2,
    SHUTDOWN_OPERATION = 3,
};
pub const HTTP_WEB_SOCKET_SEND_OPERATION = HTTP_WEB_SOCKET_OPERATION.SEND_OPERATION;
pub const HTTP_WEB_SOCKET_RECEIVE_OPERATION = HTTP_WEB_SOCKET_OPERATION.RECEIVE_OPERATION;
pub const HTTP_WEB_SOCKET_CLOSE_OPERATION = HTTP_WEB_SOCKET_OPERATION.CLOSE_OPERATION;
pub const HTTP_WEB_SOCKET_SHUTDOWN_OPERATION = HTTP_WEB_SOCKET_OPERATION.SHUTDOWN_OPERATION;

pub const HTTP_WEB_SOCKET_BUFFER_TYPE = enum(i32) {
    BINARY_MESSAGE_TYPE = 0,
    BINARY_FRAGMENT_TYPE = 1,
    UTF8_MESSAGE_TYPE = 2,
    UTF8_FRAGMENT_TYPE = 3,
    CLOSE_TYPE = 4,
    PING_TYPE = 5,
};
pub const HTTP_WEB_SOCKET_BINARY_MESSAGE_TYPE = HTTP_WEB_SOCKET_BUFFER_TYPE.BINARY_MESSAGE_TYPE;
pub const HTTP_WEB_SOCKET_BINARY_FRAGMENT_TYPE = HTTP_WEB_SOCKET_BUFFER_TYPE.BINARY_FRAGMENT_TYPE;
pub const HTTP_WEB_SOCKET_UTF8_MESSAGE_TYPE = HTTP_WEB_SOCKET_BUFFER_TYPE.UTF8_MESSAGE_TYPE;
pub const HTTP_WEB_SOCKET_UTF8_FRAGMENT_TYPE = HTTP_WEB_SOCKET_BUFFER_TYPE.UTF8_FRAGMENT_TYPE;
pub const HTTP_WEB_SOCKET_CLOSE_TYPE = HTTP_WEB_SOCKET_BUFFER_TYPE.CLOSE_TYPE;
pub const HTTP_WEB_SOCKET_PING_TYPE = HTTP_WEB_SOCKET_BUFFER_TYPE.PING_TYPE;

pub const HTTP_WEB_SOCKET_CLOSE_STATUS = enum(i32) {
    SUCCESS_CLOSE_STATUS = 1000,
    ENDPOINT_TERMINATED_CLOSE_STATUS = 1001,
    PROTOCOL_ERROR_CLOSE_STATUS = 1002,
    INVALID_DATA_TYPE_CLOSE_STATUS = 1003,
    EMPTY_CLOSE_STATUS = 1005,
    ABORTED_CLOSE_STATUS = 1006,
    INVALID_PAYLOAD_CLOSE_STATUS = 1007,
    POLICY_VIOLATION_CLOSE_STATUS = 1008,
    MESSAGE_TOO_BIG_CLOSE_STATUS = 1009,
    UNSUPPORTED_EXTENSIONS_CLOSE_STATUS = 1010,
    SERVER_ERROR_CLOSE_STATUS = 1011,
    SECURE_HANDSHAKE_ERROR_CLOSE_STATUS = 1015,
};
pub const HTTP_WEB_SOCKET_SUCCESS_CLOSE_STATUS = HTTP_WEB_SOCKET_CLOSE_STATUS.SUCCESS_CLOSE_STATUS;
pub const HTTP_WEB_SOCKET_ENDPOINT_TERMINATED_CLOSE_STATUS = HTTP_WEB_SOCKET_CLOSE_STATUS.ENDPOINT_TERMINATED_CLOSE_STATUS;
pub const HTTP_WEB_SOCKET_PROTOCOL_ERROR_CLOSE_STATUS = HTTP_WEB_SOCKET_CLOSE_STATUS.PROTOCOL_ERROR_CLOSE_STATUS;
pub const HTTP_WEB_SOCKET_INVALID_DATA_TYPE_CLOSE_STATUS = HTTP_WEB_SOCKET_CLOSE_STATUS.INVALID_DATA_TYPE_CLOSE_STATUS;
pub const HTTP_WEB_SOCKET_EMPTY_CLOSE_STATUS = HTTP_WEB_SOCKET_CLOSE_STATUS.EMPTY_CLOSE_STATUS;
pub const HTTP_WEB_SOCKET_ABORTED_CLOSE_STATUS = HTTP_WEB_SOCKET_CLOSE_STATUS.ABORTED_CLOSE_STATUS;
pub const HTTP_WEB_SOCKET_INVALID_PAYLOAD_CLOSE_STATUS = HTTP_WEB_SOCKET_CLOSE_STATUS.INVALID_PAYLOAD_CLOSE_STATUS;
pub const HTTP_WEB_SOCKET_POLICY_VIOLATION_CLOSE_STATUS = HTTP_WEB_SOCKET_CLOSE_STATUS.POLICY_VIOLATION_CLOSE_STATUS;
pub const HTTP_WEB_SOCKET_MESSAGE_TOO_BIG_CLOSE_STATUS = HTTP_WEB_SOCKET_CLOSE_STATUS.MESSAGE_TOO_BIG_CLOSE_STATUS;
pub const HTTP_WEB_SOCKET_UNSUPPORTED_EXTENSIONS_CLOSE_STATUS = HTTP_WEB_SOCKET_CLOSE_STATUS.UNSUPPORTED_EXTENSIONS_CLOSE_STATUS;
pub const HTTP_WEB_SOCKET_SERVER_ERROR_CLOSE_STATUS = HTTP_WEB_SOCKET_CLOSE_STATUS.SERVER_ERROR_CLOSE_STATUS;
pub const HTTP_WEB_SOCKET_SECURE_HANDSHAKE_ERROR_CLOSE_STATUS = HTTP_WEB_SOCKET_CLOSE_STATUS.SECURE_HANDSHAKE_ERROR_CLOSE_STATUS;

pub const HTTP_WEB_SOCKET_ASYNC_RESULT = extern struct {
    AsyncResult: INTERNET_ASYNC_RESULT,
    Operation: HTTP_WEB_SOCKET_OPERATION,
    BufferType: HTTP_WEB_SOCKET_BUFFER_TYPE,
    dwBytesTransferred: u32,
};

pub const HTTP_POLICY_EXTENSION_TYPE = enum(i32) {
    NONE = 0,
    WINHTTP = 1,
    WININET = 2,
};
pub const POLICY_EXTENSION_TYPE_NONE = HTTP_POLICY_EXTENSION_TYPE.NONE;
pub const POLICY_EXTENSION_TYPE_WINHTTP = HTTP_POLICY_EXTENSION_TYPE.WINHTTP;
pub const POLICY_EXTENSION_TYPE_WININET = HTTP_POLICY_EXTENSION_TYPE.WININET;

pub const HTTP_POLICY_EXTENSION_VERSION = enum(i32) {
    @"1" = 1,
};
pub const POLICY_EXTENSION_VERSION1 = HTTP_POLICY_EXTENSION_VERSION.@"1";

pub const HTTP_POLICY_EXTENSION_INIT = *const fn(
    Version: HTTP_POLICY_EXTENSION_VERSION,
    Type: HTTP_POLICY_EXTENSION_TYPE,
    pvData: ?*anyopaque,
    cbData: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const HTTP_POLICY_EXTENSION_SHUTDOWN = *const fn(
    Type: HTTP_POLICY_EXTENSION_TYPE,
) callconv(@import("std").os.windows.WINAPI) u32;

const CLSID_ProofOfPossessionCookieInfoManager_Value = Guid.initString("a9927f85-a304-4390-8b23-a75f1c668600");
pub const CLSID_ProofOfPossessionCookieInfoManager = &CLSID_ProofOfPossessionCookieInfoManager_Value;

pub const ProofOfPossessionCookieInfo = extern struct {
    name: ?PWSTR,
    data: ?PWSTR,
    flags: u32,
    p3pHeader: ?PWSTR,
};

const IID_IProofOfPossessionCookieInfoManager_Value = Guid.initString("cdaece56-4edf-43df-b113-88e4556fa1bb");
pub const IID_IProofOfPossessionCookieInfoManager = &IID_IProofOfPossessionCookieInfoManager_Value;
pub const IProofOfPossessionCookieInfoManager = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCookieInfoForUri: *const fn(
            self: *const IProofOfPossessionCookieInfoManager,
            uri: ?[*:0]const u16,
            cookieInfoCount: ?*u32,
            cookieInfo: [*]?*ProofOfPossessionCookieInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn GetCookieInfoForUri(self: *const IProofOfPossessionCookieInfoManager, uri: ?[*:0]const u16, cookieInfoCount: ?*u32, cookieInfo: [*]?*ProofOfPossessionCookieInfo) callconv(.Inline) HRESULT {
        return self.vtable.GetCookieInfoForUri(self, uri, cookieInfoCount, cookieInfo);
    }
};

const IID_IProofOfPossessionCookieInfoManager2_Value = Guid.initString("15e41407-b42f-4ae7-9966-34a087b2d713");
pub const IID_IProofOfPossessionCookieInfoManager2 = &IID_IProofOfPossessionCookieInfoManager2_Value;
pub const IProofOfPossessionCookieInfoManager2 = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCookieInfoWithUriForAccount: *const fn(
            self: *const IProofOfPossessionCookieInfoManager2,
            webAccount: ?*IInspectable,
            uri: ?[*:0]const u16,
            cookieInfoCount: ?*u32,
            cookieInfo: [*]?*ProofOfPossessionCookieInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn GetCookieInfoWithUriForAccount(self: *const IProofOfPossessionCookieInfoManager2, webAccount: ?*IInspectable, uri: ?[*:0]const u16, cookieInfoCount: ?*u32, cookieInfo: [*]?*ProofOfPossessionCookieInfo) callconv(.Inline) HRESULT {
        return self.vtable.GetCookieInfoWithUriForAccount(self, webAccount, uri, cookieInfoCount, cookieInfo);
    }
};


//--------------------------------------------------------------------------------
// Section: Functions (296)
//--------------------------------------------------------------------------------
// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn InternetTimeFromSystemTimeA(
    pst: ?*const SYSTEMTIME,
    dwRFC: u32,
    // TODO: what to do with BytesParamIndex 3?
    lpszTime: ?PSTR,
    cbTime: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn InternetTimeFromSystemTimeW(
    pst: ?*const SYSTEMTIME,
    dwRFC: u32,
    // TODO: what to do with BytesParamIndex 3?
    lpszTime: ?PWSTR,
    cbTime: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn InternetTimeFromSystemTime(
    pst: ?*const SYSTEMTIME,
    dwRFC: u32,
    // TODO: what to do with BytesParamIndex 3?
    lpszTime: ?PSTR,
    cbTime: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn InternetTimeToSystemTimeA(
    lpszTime: ?[*:0]const u8,
    pst: ?*SYSTEMTIME,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn InternetTimeToSystemTimeW(
    lpszTime: ?[*:0]const u16,
    pst: ?*SYSTEMTIME,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn InternetTimeToSystemTime(
    lpszTime: ?[*:0]const u8,
    pst: ?*SYSTEMTIME,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn InternetCrackUrlA(
    lpszUrl: [*:0]const u8,
    dwUrlLength: u32,
    dwFlags: WIN_HTTP_CREATE_URL_FLAGS,
    lpUrlComponents: ?*URL_COMPONENTSA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn InternetCrackUrlW(
    lpszUrl: [*:0]const u16,
    dwUrlLength: u32,
    dwFlags: WIN_HTTP_CREATE_URL_FLAGS,
    lpUrlComponents: ?*URL_COMPONENTSW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn InternetCreateUrlA(
    lpUrlComponents: ?*URL_COMPONENTSA,
    dwFlags: u32,
    lpszUrl: ?[*:0]u8,
    lpdwUrlLength: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn InternetCreateUrlW(
    lpUrlComponents: ?*URL_COMPONENTSW,
    dwFlags: u32,
    lpszUrl: ?[*:0]u16,
    lpdwUrlLength: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn InternetCanonicalizeUrlA(
    lpszUrl: ?[*:0]const u8,
    lpszBuffer: [*:0]u8,
    lpdwBufferLength: ?*u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn InternetCanonicalizeUrlW(
    lpszUrl: ?[*:0]const u16,
    lpszBuffer: [*:0]u16,
    lpdwBufferLength: ?*u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn InternetCombineUrlA(
    lpszBaseUrl: ?[*:0]const u8,
    lpszRelativeUrl: ?[*:0]const u8,
    lpszBuffer: [*:0]u8,
    lpdwBufferLength: ?*u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn InternetCombineUrlW(
    lpszBaseUrl: ?[*:0]const u16,
    lpszRelativeUrl: ?[*:0]const u16,
    lpszBuffer: [*:0]u16,
    lpdwBufferLength: ?*u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn InternetOpenA(
    lpszAgent: ?[*:0]const u8,
    dwAccessType: u32,
    lpszProxy: ?[*:0]const u8,
    lpszProxyBypass: ?[*:0]const u8,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn InternetOpenW(
    lpszAgent: ?[*:0]const u16,
    dwAccessType: u32,
    lpszProxy: ?[*:0]const u16,
    lpszProxyBypass: ?[*:0]const u16,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn InternetCloseHandle(
    hInternet: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn InternetConnectA(
    hInternet: ?*anyopaque,
    lpszServerName: ?[*:0]const u8,
    nServerPort: u16,
    lpszUserName: ?[*:0]const u8,
    lpszPassword: ?[*:0]const u8,
    dwService: u32,
    dwFlags: u32,
    dwContext: usize,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn InternetConnectW(
    hInternet: ?*anyopaque,
    lpszServerName: ?[*:0]const u16,
    nServerPort: u16,
    lpszUserName: ?[*:0]const u16,
    lpszPassword: ?[*:0]const u16,
    dwService: u32,
    dwFlags: u32,
    dwContext: usize,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn InternetOpenUrlA(
    hInternet: ?*anyopaque,
    lpszUrl: ?[*:0]const u8,
    lpszHeaders: ?[*:0]const u8,
    dwHeadersLength: u32,
    dwFlags: u32,
    dwContext: usize,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn InternetOpenUrlW(
    hInternet: ?*anyopaque,
    lpszUrl: ?[*:0]const u16,
    lpszHeaders: ?[*:0]const u16,
    dwHeadersLength: u32,
    dwFlags: u32,
    dwContext: usize,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn InternetReadFile(
    hFile: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 2?
    lpBuffer: ?*anyopaque,
    dwNumberOfBytesToRead: u32,
    lpdwNumberOfBytesRead: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn InternetReadFileExA(
    hFile: ?*anyopaque,
    lpBuffersOut: ?*INTERNET_BUFFERSA,
    dwFlags: u32,
    dwContext: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn InternetReadFileExW(
    hFile: ?*anyopaque,
    lpBuffersOut: ?*INTERNET_BUFFERSW,
    dwFlags: u32,
    dwContext: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn InternetSetFilePointer(
    hFile: ?*anyopaque,
    lDistanceToMove: i32,
    lpDistanceToMoveHigh: ?*i32,
    dwMoveMethod: u32,
    dwContext: usize,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn InternetWriteFile(
    hFile: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 2?
    lpBuffer: ?*const anyopaque,
    dwNumberOfBytesToWrite: u32,
    lpdwNumberOfBytesWritten: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn InternetQueryDataAvailable(
    hFile: ?*anyopaque,
    lpdwNumberOfBytesAvailable: ?*u32,
    dwFlags: u32,
    dwContext: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn InternetFindNextFileA(
    hFind: ?*anyopaque,
    lpvFindData: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn InternetFindNextFileW(
    hFind: ?*anyopaque,
    lpvFindData: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn InternetQueryOptionA(
    hInternet: ?*anyopaque,
    dwOption: u32,
    // TODO: what to do with BytesParamIndex 3?
    lpBuffer: ?*anyopaque,
    lpdwBufferLength: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn InternetQueryOptionW(
    hInternet: ?*anyopaque,
    dwOption: u32,
    // TODO: what to do with BytesParamIndex 3?
    lpBuffer: ?*anyopaque,
    lpdwBufferLength: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn InternetSetOptionA(
    hInternet: ?*anyopaque,
    dwOption: u32,
    lpBuffer: ?*anyopaque,
    dwBufferLength: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn InternetSetOptionW(
    hInternet: ?*anyopaque,
    dwOption: u32,
    lpBuffer: ?*anyopaque,
    dwBufferLength: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn InternetSetOptionExA(
    hInternet: ?*anyopaque,
    dwOption: u32,
    lpBuffer: ?*anyopaque,
    dwBufferLength: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn InternetSetOptionExW(
    hInternet: ?*anyopaque,
    dwOption: u32,
    lpBuffer: ?*anyopaque,
    dwBufferLength: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn InternetLockRequestFile(
    hInternet: ?*anyopaque,
    lphLockRequestInfo: ?*?HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn InternetUnlockRequestFile(
    hLockRequestInfo: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn InternetGetLastResponseInfoA(
    lpdwError: ?*u32,
    lpszBuffer: ?[*:0]u8,
    lpdwBufferLength: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn InternetGetLastResponseInfoW(
    lpdwError: ?*u32,
    lpszBuffer: ?[*:0]u16,
    lpdwBufferLength: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "wininet" fn InternetSetStatusCallbackA(
    hInternet: ?*anyopaque,
    lpfnInternetCallback: ?LPINTERNET_STATUS_CALLBACK,
) callconv(@import("std").os.windows.WINAPI) ?LPINTERNET_STATUS_CALLBACK;

pub extern "wininet" fn InternetSetStatusCallbackW(
    hInternet: ?*anyopaque,
    lpfnInternetCallback: ?LPINTERNET_STATUS_CALLBACK,
) callconv(@import("std").os.windows.WINAPI) ?LPINTERNET_STATUS_CALLBACK;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn InternetSetStatusCallback(
    hInternet: ?*anyopaque,
    lpfnInternetCallback: ?LPINTERNET_STATUS_CALLBACK,
) callconv(@import("std").os.windows.WINAPI) ?LPINTERNET_STATUS_CALLBACK;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn FtpFindFirstFileA(
    hConnect: ?*anyopaque,
    lpszSearchFile: ?[*:0]const u8,
    lpFindFileData: ?*WIN32_FIND_DATAA,
    dwFlags: u32,
    dwContext: usize,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn FtpFindFirstFileW(
    hConnect: ?*anyopaque,
    lpszSearchFile: ?[*:0]const u16,
    lpFindFileData: ?*WIN32_FIND_DATAW,
    dwFlags: u32,
    dwContext: usize,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn FtpGetFileA(
    hConnect: ?*anyopaque,
    lpszRemoteFile: ?[*:0]const u8,
    lpszNewFile: ?[*:0]const u8,
    fFailIfExists: BOOL,
    dwFlagsAndAttributes: u32,
    dwFlags: u32,
    dwContext: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn FtpGetFileW(
    hConnect: ?*anyopaque,
    lpszRemoteFile: ?[*:0]const u16,
    lpszNewFile: ?[*:0]const u16,
    fFailIfExists: BOOL,
    dwFlagsAndAttributes: u32,
    dwFlags: u32,
    dwContext: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn FtpPutFileA(
    hConnect: ?*anyopaque,
    lpszLocalFile: ?[*:0]const u8,
    lpszNewRemoteFile: ?[*:0]const u8,
    dwFlags: FTP_FLAGS,
    dwContext: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn FtpPutFileW(
    hConnect: ?*anyopaque,
    lpszLocalFile: ?[*:0]const u16,
    lpszNewRemoteFile: ?[*:0]const u16,
    dwFlags: FTP_FLAGS,
    dwContext: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "wininet" fn FtpGetFileEx(
    hFtpSession: ?*anyopaque,
    lpszRemoteFile: ?[*:0]const u8,
    lpszNewFile: ?[*:0]const u16,
    fFailIfExists: BOOL,
    dwFlagsAndAttributes: u32,
    dwFlags: u32,
    dwContext: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "wininet" fn FtpPutFileEx(
    hFtpSession: ?*anyopaque,
    lpszLocalFile: ?[*:0]const u16,
    lpszNewRemoteFile: ?[*:0]const u8,
    dwFlags: u32,
    dwContext: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn FtpDeleteFileA(
    hConnect: ?*anyopaque,
    lpszFileName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn FtpDeleteFileW(
    hConnect: ?*anyopaque,
    lpszFileName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn FtpRenameFileA(
    hConnect: ?*anyopaque,
    lpszExisting: ?[*:0]const u8,
    lpszNew: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn FtpRenameFileW(
    hConnect: ?*anyopaque,
    lpszExisting: ?[*:0]const u16,
    lpszNew: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn FtpOpenFileA(
    hConnect: ?*anyopaque,
    lpszFileName: ?[*:0]const u8,
    dwAccess: u32,
    dwFlags: FTP_FLAGS,
    dwContext: usize,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn FtpOpenFileW(
    hConnect: ?*anyopaque,
    lpszFileName: ?[*:0]const u16,
    dwAccess: u32,
    dwFlags: FTP_FLAGS,
    dwContext: usize,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn FtpCreateDirectoryA(
    hConnect: ?*anyopaque,
    lpszDirectory: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn FtpCreateDirectoryW(
    hConnect: ?*anyopaque,
    lpszDirectory: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn FtpRemoveDirectoryA(
    hConnect: ?*anyopaque,
    lpszDirectory: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn FtpRemoveDirectoryW(
    hConnect: ?*anyopaque,
    lpszDirectory: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn FtpSetCurrentDirectoryA(
    hConnect: ?*anyopaque,
    lpszDirectory: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn FtpSetCurrentDirectoryW(
    hConnect: ?*anyopaque,
    lpszDirectory: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn FtpGetCurrentDirectoryA(
    hConnect: ?*anyopaque,
    lpszCurrentDirectory: [*:0]u8,
    lpdwCurrentDirectory: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn FtpGetCurrentDirectoryW(
    hConnect: ?*anyopaque,
    lpszCurrentDirectory: [*:0]u16,
    lpdwCurrentDirectory: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn FtpCommandA(
    hConnect: ?*anyopaque,
    fExpectResponse: BOOL,
    dwFlags: FTP_FLAGS,
    lpszCommand: ?[*:0]const u8,
    dwContext: usize,
    phFtpCommand: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn FtpCommandW(
    hConnect: ?*anyopaque,
    fExpectResponse: BOOL,
    dwFlags: FTP_FLAGS,
    lpszCommand: ?[*:0]const u16,
    dwContext: usize,
    phFtpCommand: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn FtpGetFileSize(
    hFile: ?*anyopaque,
    lpdwFileSizeHigh: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn GopherCreateLocatorA(
    lpszHost: ?[*:0]const u8,
    nServerPort: u16,
    lpszDisplayString: ?[*:0]const u8,
    lpszSelectorString: ?[*:0]const u8,
    dwGopherType: u32,
    lpszLocator: ?[*:0]u8,
    lpdwBufferLength: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn GopherCreateLocatorW(
    lpszHost: ?[*:0]const u16,
    nServerPort: u16,
    lpszDisplayString: ?[*:0]const u16,
    lpszSelectorString: ?[*:0]const u16,
    dwGopherType: u32,
    lpszLocator: ?[*:0]u16,
    lpdwBufferLength: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn GopherGetLocatorTypeA(
    lpszLocator: ?[*:0]const u8,
    lpdwGopherType: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn GopherGetLocatorTypeW(
    lpszLocator: ?[*:0]const u16,
    lpdwGopherType: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn GopherFindFirstFileA(
    hConnect: ?*anyopaque,
    lpszLocator: ?[*:0]const u8,
    lpszSearchString: ?[*:0]const u8,
    lpFindData: ?*GOPHER_FIND_DATAA,
    dwFlags: u32,
    dwContext: usize,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn GopherFindFirstFileW(
    hConnect: ?*anyopaque,
    lpszLocator: ?[*:0]const u16,
    lpszSearchString: ?[*:0]const u16,
    lpFindData: ?*GOPHER_FIND_DATAW,
    dwFlags: u32,
    dwContext: usize,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn GopherOpenFileA(
    hConnect: ?*anyopaque,
    lpszLocator: ?[*:0]const u8,
    lpszView: ?[*:0]const u8,
    dwFlags: u32,
    dwContext: usize,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn GopherOpenFileW(
    hConnect: ?*anyopaque,
    lpszLocator: ?[*:0]const u16,
    lpszView: ?[*:0]const u16,
    dwFlags: u32,
    dwContext: usize,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn GopherGetAttributeA(
    hConnect: ?*anyopaque,
    lpszLocator: ?[*:0]const u8,
    lpszAttributeName: ?[*:0]const u8,
    lpBuffer: [*:0]u8,
    dwBufferLength: u32,
    lpdwCharactersReturned: ?*u32,
    lpfnEnumerator: ?GOPHER_ATTRIBUTE_ENUMERATOR,
    dwContext: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn GopherGetAttributeW(
    hConnect: ?*anyopaque,
    lpszLocator: ?[*:0]const u16,
    lpszAttributeName: ?[*:0]const u16,
    lpBuffer: [*:0]u8,
    dwBufferLength: u32,
    lpdwCharactersReturned: ?*u32,
    lpfnEnumerator: ?GOPHER_ATTRIBUTE_ENUMERATOR,
    dwContext: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn HttpOpenRequestA(
    hConnect: ?*anyopaque,
    lpszVerb: ?[*:0]const u8,
    lpszObjectName: ?[*:0]const u8,
    lpszVersion: ?[*:0]const u8,
    lpszReferrer: ?[*:0]const u8,
    lplpszAcceptTypes: ?*?PSTR,
    dwFlags: u32,
    dwContext: usize,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn HttpOpenRequestW(
    hConnect: ?*anyopaque,
    lpszVerb: ?[*:0]const u16,
    lpszObjectName: ?[*:0]const u16,
    lpszVersion: ?[*:0]const u16,
    lpszReferrer: ?[*:0]const u16,
    lplpszAcceptTypes: ?*?PWSTR,
    dwFlags: u32,
    dwContext: usize,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn HttpAddRequestHeadersA(
    hRequest: ?*anyopaque,
    lpszHeaders: [*:0]const u8,
    dwHeadersLength: u32,
    dwModifiers: HTTP_ADDREQ_FLAG,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn HttpAddRequestHeadersW(
    hRequest: ?*anyopaque,
    lpszHeaders: [*:0]const u16,
    dwHeadersLength: u32,
    dwModifiers: HTTP_ADDREQ_FLAG,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn HttpSendRequestA(
    hRequest: ?*anyopaque,
    lpszHeaders: ?[*:0]const u8,
    dwHeadersLength: u32,
    // TODO: what to do with BytesParamIndex 4?
    lpOptional: ?*anyopaque,
    dwOptionalLength: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn HttpSendRequestW(
    hRequest: ?*anyopaque,
    lpszHeaders: ?[*:0]const u16,
    dwHeadersLength: u32,
    // TODO: what to do with BytesParamIndex 4?
    lpOptional: ?*anyopaque,
    dwOptionalLength: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn HttpSendRequestExA(
    hRequest: ?*anyopaque,
    lpBuffersIn: ?*INTERNET_BUFFERSA,
    lpBuffersOut: ?*INTERNET_BUFFERSA,
    dwFlags: u32,
    dwContext: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn HttpSendRequestExW(
    hRequest: ?*anyopaque,
    lpBuffersIn: ?*INTERNET_BUFFERSW,
    lpBuffersOut: ?*INTERNET_BUFFERSW,
    dwFlags: u32,
    dwContext: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn HttpEndRequestA(
    hRequest: ?*anyopaque,
    lpBuffersOut: ?*INTERNET_BUFFERSA,
    dwFlags: u32,
    dwContext: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn HttpEndRequestW(
    hRequest: ?*anyopaque,
    lpBuffersOut: ?*INTERNET_BUFFERSW,
    dwFlags: u32,
    dwContext: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn HttpQueryInfoA(
    hRequest: ?*anyopaque,
    dwInfoLevel: u32,
    // TODO: what to do with BytesParamIndex 3?
    lpBuffer: ?*anyopaque,
    lpdwBufferLength: ?*u32,
    lpdwIndex: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn HttpQueryInfoW(
    hRequest: ?*anyopaque,
    dwInfoLevel: u32,
    // TODO: what to do with BytesParamIndex 3?
    lpBuffer: ?*anyopaque,
    lpdwBufferLength: ?*u32,
    lpdwIndex: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn InternetSetCookieA(
    lpszUrl: ?[*:0]const u8,
    lpszCookieName: ?[*:0]const u8,
    lpszCookieData: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn InternetSetCookieW(
    lpszUrl: ?[*:0]const u16,
    lpszCookieName: ?[*:0]const u16,
    lpszCookieData: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn InternetGetCookieA(
    lpszUrl: ?[*:0]const u8,
    lpszCookieName: ?[*:0]const u8,
    lpszCookieData: ?[*:0]u8,
    lpdwSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn InternetGetCookieW(
    lpszUrl: ?[*:0]const u16,
    lpszCookieName: ?[*:0]const u16,
    lpszCookieData: ?[*:0]u16,
    lpdwSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "wininet" fn InternetSetCookieExA(
    lpszUrl: ?[*:0]const u8,
    lpszCookieName: ?[*:0]const u8,
    lpszCookieData: ?[*:0]const u8,
    dwFlags: u32,
    dwReserved: usize,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "wininet" fn InternetSetCookieExW(
    lpszUrl: ?[*:0]const u16,
    lpszCookieName: ?[*:0]const u16,
    lpszCookieData: ?[*:0]const u16,
    dwFlags: u32,
    dwReserved: usize,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "wininet" fn InternetGetCookieExA(
    lpszUrl: ?[*:0]const u8,
    lpszCookieName: ?[*:0]const u8,
    lpszCookieData: ?[*:0]u8,
    lpdwSize: ?*u32,
    dwFlags: INTERNET_COOKIE_FLAGS,
    lpReserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "wininet" fn InternetGetCookieExW(
    lpszUrl: ?[*:0]const u16,
    lpszCookieName: ?[*:0]const u16,
    lpszCookieData: ?[*:0]u16,
    lpdwSize: ?*u32,
    dwFlags: INTERNET_COOKIE_FLAGS,
    lpReserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "wininet" fn InternetFreeCookies(
    pCookies: ?*INTERNET_COOKIE2,
    dwCookieCount: u32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "wininet" fn InternetGetCookieEx2(
    pcwszUrl: ?[*:0]const u16,
    pcwszCookieName: ?[*:0]const u16,
    dwFlags: u32,
    ppCookies: ?*?*INTERNET_COOKIE2,
    pdwCookieCount: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "wininet" fn InternetSetCookieEx2(
    pcwszUrl: ?[*:0]const u16,
    pCookie: ?*const INTERNET_COOKIE2,
    pcwszP3PPolicy: ?[*:0]const u16,
    dwFlags: u32,
    pdwCookieState: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn InternetAttemptConnect(
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn InternetCheckConnectionA(
    lpszUrl: ?[*:0]const u8,
    dwFlags: u32,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn InternetCheckConnectionW(
    lpszUrl: ?[*:0]const u16,
    dwFlags: u32,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn ResumeSuspendedDownload(
    hRequest: ?*anyopaque,
    dwResultCode: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn InternetErrorDlg(
    hWnd: ?HWND,
    hRequest: ?*anyopaque,
    dwError: u32,
    dwFlags: u32,
    lppvData: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn InternetConfirmZoneCrossingA(
    hWnd: ?HWND,
    szUrlPrev: ?PSTR,
    szUrlNew: ?PSTR,
    bPost: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn InternetConfirmZoneCrossingW(
    hWnd: ?HWND,
    szUrlPrev: ?PWSTR,
    szUrlNew: ?PWSTR,
    bPost: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn InternetConfirmZoneCrossing(
    hWnd: ?HWND,
    szUrlPrev: ?PSTR,
    szUrlNew: ?PSTR,
    bPost: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn CreateUrlCacheEntryA(
    lpszUrlName: ?[*:0]const u8,
    dwExpectedFileSize: u32,
    lpszFileExtension: ?[*:0]const u8,
    lpszFileName: *[260]u8,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn CreateUrlCacheEntryW(
    lpszUrlName: ?[*:0]const u16,
    dwExpectedFileSize: u32,
    lpszFileExtension: ?[*:0]const u16,
    lpszFileName: *[260]u16,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn CommitUrlCacheEntryA(
    lpszUrlName: ?[*:0]const u8,
    lpszLocalFileName: ?[*:0]const u8,
    ExpireTime: FILETIME,
    LastModifiedTime: FILETIME,
    CacheEntryType: u32,
    lpHeaderInfo: ?[*:0]u8,
    cchHeaderInfo: u32,
    lpszFileExtension: ?[*:0]const u8,
    lpszOriginalUrl: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn CommitUrlCacheEntryW(
    lpszUrlName: ?[*:0]const u16,
    lpszLocalFileName: ?[*:0]const u16,
    ExpireTime: FILETIME,
    LastModifiedTime: FILETIME,
    CacheEntryType: u32,
    lpszHeaderInfo: ?[*:0]u16,
    cchHeaderInfo: u32,
    lpszFileExtension: ?[*:0]const u16,
    lpszOriginalUrl: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn RetrieveUrlCacheEntryFileA(
    lpszUrlName: ?[*:0]const u8,
    // TODO: what to do with BytesParamIndex 2?
    lpCacheEntryInfo: ?*INTERNET_CACHE_ENTRY_INFOA,
    lpcbCacheEntryInfo: ?*u32,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn RetrieveUrlCacheEntryFileW(
    lpszUrlName: ?[*:0]const u16,
    // TODO: what to do with BytesParamIndex 2?
    lpCacheEntryInfo: ?*INTERNET_CACHE_ENTRY_INFOW,
    lpcbCacheEntryInfo: ?*u32,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn UnlockUrlCacheEntryFileA(
    lpszUrlName: ?[*:0]const u8,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn UnlockUrlCacheEntryFileW(
    lpszUrlName: ?[*:0]const u16,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn UnlockUrlCacheEntryFile(
    lpszUrlName: ?[*:0]const u8,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn RetrieveUrlCacheEntryStreamA(
    lpszUrlName: ?[*:0]const u8,
    // TODO: what to do with BytesParamIndex 2?
    lpCacheEntryInfo: ?*INTERNET_CACHE_ENTRY_INFOA,
    lpcbCacheEntryInfo: ?*u32,
    fRandomRead: BOOL,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn RetrieveUrlCacheEntryStreamW(
    lpszUrlName: ?[*:0]const u16,
    // TODO: what to do with BytesParamIndex 2?
    lpCacheEntryInfo: ?*INTERNET_CACHE_ENTRY_INFOW,
    lpcbCacheEntryInfo: ?*u32,
    fRandomRead: BOOL,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn ReadUrlCacheEntryStream(
    hUrlCacheStream: ?HANDLE,
    dwLocation: u32,
    // TODO: what to do with BytesParamIndex 3?
    lpBuffer: ?*anyopaque,
    lpdwLen: ?*u32,
    Reserved: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "wininet" fn ReadUrlCacheEntryStreamEx(
    hUrlCacheStream: ?HANDLE,
    qwLocation: u64,
    // TODO: what to do with BytesParamIndex 3?
    lpBuffer: ?*anyopaque,
    lpdwLen: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn UnlockUrlCacheEntryStream(
    hUrlCacheStream: ?HANDLE,
    Reserved: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn GetUrlCacheEntryInfoA(
    lpszUrlName: ?[*:0]const u8,
    // TODO: what to do with BytesParamIndex 2?
    lpCacheEntryInfo: ?*INTERNET_CACHE_ENTRY_INFOA,
    lpcbCacheEntryInfo: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn GetUrlCacheEntryInfoW(
    lpszUrlName: ?[*:0]const u16,
    // TODO: what to do with BytesParamIndex 2?
    lpCacheEntryInfo: ?*INTERNET_CACHE_ENTRY_INFOW,
    lpcbCacheEntryInfo: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn FindFirstUrlCacheGroup(
    dwFlags: u32,
    dwFilter: u32,
    lpSearchCondition: ?*anyopaque,
    dwSearchCondition: u32,
    lpGroupId: ?*i64,
    lpReserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn FindNextUrlCacheGroup(
    hFind: ?HANDLE,
    lpGroupId: ?*i64,
    lpReserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn GetUrlCacheGroupAttributeA(
    gid: i64,
    dwFlags: u32,
    dwAttributes: u32,
    // TODO: what to do with BytesParamIndex 4?
    lpGroupInfo: ?*INTERNET_CACHE_GROUP_INFOA,
    lpcbGroupInfo: ?*u32,
    lpReserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn GetUrlCacheGroupAttributeW(
    gid: i64,
    dwFlags: u32,
    dwAttributes: u32,
    // TODO: what to do with BytesParamIndex 4?
    lpGroupInfo: ?*INTERNET_CACHE_GROUP_INFOW,
    lpcbGroupInfo: ?*u32,
    lpReserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn SetUrlCacheGroupAttributeA(
    gid: i64,
    dwFlags: u32,
    dwAttributes: u32,
    lpGroupInfo: ?*INTERNET_CACHE_GROUP_INFOA,
    lpReserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn SetUrlCacheGroupAttributeW(
    gid: i64,
    dwFlags: u32,
    dwAttributes: u32,
    lpGroupInfo: ?*INTERNET_CACHE_GROUP_INFOW,
    lpReserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn GetUrlCacheEntryInfoExA(
    lpszUrl: ?[*:0]const u8,
    // TODO: what to do with BytesParamIndex 2?
    lpCacheEntryInfo: ?*INTERNET_CACHE_ENTRY_INFOA,
    lpcbCacheEntryInfo: ?*u32,
    lpszRedirectUrl: ?PSTR,
    lpcbRedirectUrl: ?*u32,
    lpReserved: ?*anyopaque,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn GetUrlCacheEntryInfoExW(
    lpszUrl: ?[*:0]const u16,
    // TODO: what to do with BytesParamIndex 2?
    lpCacheEntryInfo: ?*INTERNET_CACHE_ENTRY_INFOW,
    lpcbCacheEntryInfo: ?*u32,
    lpszRedirectUrl: ?PWSTR,
    lpcbRedirectUrl: ?*u32,
    lpReserved: ?*anyopaque,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn SetUrlCacheEntryInfoA(
    lpszUrlName: ?[*:0]const u8,
    lpCacheEntryInfo: ?*INTERNET_CACHE_ENTRY_INFOA,
    dwFieldControl: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn SetUrlCacheEntryInfoW(
    lpszUrlName: ?[*:0]const u16,
    lpCacheEntryInfo: ?*INTERNET_CACHE_ENTRY_INFOW,
    dwFieldControl: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn CreateUrlCacheGroup(
    dwFlags: u32,
    lpReserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i64;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn DeleteUrlCacheGroup(
    GroupId: i64,
    dwFlags: u32,
    lpReserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn SetUrlCacheEntryGroupA(
    lpszUrlName: ?[*:0]const u8,
    dwFlags: u32,
    GroupId: i64,
    pbGroupAttributes: ?*u8,
    cbGroupAttributes: u32,
    lpReserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn SetUrlCacheEntryGroupW(
    lpszUrlName: ?[*:0]const u16,
    dwFlags: u32,
    GroupId: i64,
    pbGroupAttributes: ?*u8,
    cbGroupAttributes: u32,
    lpReserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn SetUrlCacheEntryGroup(
    lpszUrlName: ?[*:0]const u8,
    dwFlags: u32,
    GroupId: i64,
    pbGroupAttributes: ?*u8,
    cbGroupAttributes: u32,
    lpReserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn FindFirstUrlCacheEntryExA(
    lpszUrlSearchPattern: ?[*:0]const u8,
    dwFlags: u32,
    dwFilter: u32,
    GroupId: i64,
    // TODO: what to do with BytesParamIndex 5?
    lpFirstCacheEntryInfo: ?*INTERNET_CACHE_ENTRY_INFOA,
    lpcbCacheEntryInfo: ?*u32,
    lpGroupAttributes: ?*anyopaque,
    lpcbGroupAttributes: ?*u32,
    lpReserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn FindFirstUrlCacheEntryExW(
    lpszUrlSearchPattern: ?[*:0]const u16,
    dwFlags: u32,
    dwFilter: u32,
    GroupId: i64,
    // TODO: what to do with BytesParamIndex 5?
    lpFirstCacheEntryInfo: ?*INTERNET_CACHE_ENTRY_INFOW,
    lpcbCacheEntryInfo: ?*u32,
    lpGroupAttributes: ?*anyopaque,
    lpcbGroupAttributes: ?*u32,
    lpReserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn FindNextUrlCacheEntryExA(
    hEnumHandle: ?HANDLE,
    // TODO: what to do with BytesParamIndex 2?
    lpNextCacheEntryInfo: ?*INTERNET_CACHE_ENTRY_INFOA,
    lpcbCacheEntryInfo: ?*u32,
    lpGroupAttributes: ?*anyopaque,
    lpcbGroupAttributes: ?*u32,
    lpReserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn FindNextUrlCacheEntryExW(
    hEnumHandle: ?HANDLE,
    // TODO: what to do with BytesParamIndex 2?
    lpNextCacheEntryInfo: ?*INTERNET_CACHE_ENTRY_INFOW,
    lpcbCacheEntryInfo: ?*u32,
    lpGroupAttributes: ?*anyopaque,
    lpcbGroupAttributes: ?*u32,
    lpReserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn FindFirstUrlCacheEntryA(
    lpszUrlSearchPattern: ?[*:0]const u8,
    // TODO: what to do with BytesParamIndex 2?
    lpFirstCacheEntryInfo: ?*INTERNET_CACHE_ENTRY_INFOA,
    lpcbCacheEntryInfo: ?*u32,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn FindFirstUrlCacheEntryW(
    lpszUrlSearchPattern: ?[*:0]const u16,
    // TODO: what to do with BytesParamIndex 2?
    lpFirstCacheEntryInfo: ?*INTERNET_CACHE_ENTRY_INFOW,
    lpcbCacheEntryInfo: ?*u32,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn FindNextUrlCacheEntryA(
    hEnumHandle: ?HANDLE,
    // TODO: what to do with BytesParamIndex 2?
    lpNextCacheEntryInfo: ?*INTERNET_CACHE_ENTRY_INFOA,
    lpcbCacheEntryInfo: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn FindNextUrlCacheEntryW(
    hEnumHandle: ?HANDLE,
    // TODO: what to do with BytesParamIndex 2?
    lpNextCacheEntryInfo: ?*INTERNET_CACHE_ENTRY_INFOW,
    lpcbCacheEntryInfo: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn FindCloseUrlCache(
    hEnumHandle: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn DeleteUrlCacheEntryA(
    lpszUrlName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn DeleteUrlCacheEntryW(
    lpszUrlName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn DeleteUrlCacheEntry(
    lpszUrlName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn InternetDialA(
    hwndParent: ?HWND,
    lpszConnectoid: ?PSTR,
    dwFlags: u32,
    lpdwConnection: ?*usize,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn InternetDialW(
    hwndParent: ?HWND,
    lpszConnectoid: ?PWSTR,
    dwFlags: u32,
    lpdwConnection: ?*usize,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn InternetDial(
    hwndParent: ?HWND,
    lpszConnectoid: ?PSTR,
    dwFlags: u32,
    lpdwConnection: ?*u32,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn InternetHangUp(
    dwConnection: usize,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn InternetGoOnlineA(
    lpszURL: ?[*:0]const u8,
    hwndParent: ?HWND,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn InternetGoOnlineW(
    lpszURL: ?[*:0]const u16,
    hwndParent: ?HWND,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn InternetGoOnline(
    lpszURL: ?PSTR,
    hwndParent: ?HWND,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn InternetAutodial(
    dwFlags: INTERNET_AUTODIAL,
    hwndParent: ?HWND,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn InternetAutodialHangup(
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn InternetGetConnectedState(
    lpdwFlags: ?*INTERNET_CONNECTION,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn InternetGetConnectedStateExA(
    lpdwFlags: ?*INTERNET_CONNECTION,
    lpszConnectionName: ?[*:0]u8,
    cchNameLen: u32,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn InternetGetConnectedStateExW(
    lpdwFlags: ?*INTERNET_CONNECTION,
    lpszConnectionName: ?[*:0]u16,
    cchNameLen: u32,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "wininet" fn DeleteWpadCacheForNetworks(
    param0: WPAD_CACHE_DELETE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn InternetInitializeAutoProxyDll(
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn DetectAutoProxyUrl(
    pszAutoProxyUrl: [*:0]u8,
    cchAutoProxyUrl: u32,
    dwDetectFlags: PROXY_AUTO_DETECT_TYPE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn CreateMD5SSOHash(
    pszChallengeInfo: ?PWSTR,
    pwszRealm: ?PWSTR,
    pwszTarget: ?PWSTR,
    pbHexHash: ?*u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn InternetGetConnectedStateEx(
    lpdwFlags: ?*INTERNET_CONNECTION,
    lpszConnectionName: ?[*:0]u8,
    dwNameLen: u32,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "wininet" fn InternetSetDialStateA(
    lpszConnectoid: ?[*:0]const u8,
    dwState: u32,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "wininet" fn InternetSetDialStateW(
    lpszConnectoid: ?[*:0]const u16,
    dwState: u32,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "wininet" fn InternetSetDialState(
    lpszConnectoid: ?[*:0]const u8,
    dwState: u32,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn InternetSetPerSiteCookieDecisionA(
    pchHostName: ?[*:0]const u8,
    dwDecision: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn InternetSetPerSiteCookieDecisionW(
    pchHostName: ?[*:0]const u16,
    dwDecision: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn InternetGetPerSiteCookieDecisionA(
    pchHostName: ?[*:0]const u8,
    pResult: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn InternetGetPerSiteCookieDecisionW(
    pchHostName: ?[*:0]const u16,
    pResult: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn InternetClearAllPerSiteCookieDecisions(
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn InternetEnumPerSiteCookieDecisionA(
    pszSiteName: [*:0]u8,
    pcSiteNameSize: ?*u32,
    pdwDecision: ?*u32,
    dwIndex: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn InternetEnumPerSiteCookieDecisionW(
    pszSiteName: [*:0]u16,
    pcSiteNameSize: ?*u32,
    pdwDecision: ?*u32,
    dwIndex: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn PrivacySetZonePreferenceW(
    dwZone: u32,
    dwType: u32,
    dwTemplate: u32,
    pszPreference: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn PrivacyGetZonePreferenceW(
    dwZone: u32,
    dwType: u32,
    pdwTemplate: ?*u32,
    pszBuffer: ?[*:0]u16,
    pdwBufferLength: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "wininet" fn HttpIsHostHstsEnabled(
    pcwszUrl: ?[*:0]const u16,
    pfIsHsts: ?*BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "wininet" fn InternetAlgIdToStringA(
    ai: u32,
    lpstr: [*:0]u8,
    lpdwstrLength: ?*u32,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "wininet" fn InternetAlgIdToStringW(
    ai: u32,
    lpstr: [*:0]u16,
    lpdwstrLength: ?*u32,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "wininet" fn InternetSecurityProtocolToStringA(
    dwProtocol: u32,
    lpstr: ?[*:0]u8,
    lpdwstrLength: ?*u32,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "wininet" fn InternetSecurityProtocolToStringW(
    dwProtocol: u32,
    lpstr: ?[*:0]u16,
    lpdwstrLength: ?*u32,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "wininet" fn InternetGetSecurityInfoByURLA(
    lpszURL: ?PSTR,
    ppCertChain: ?*?*CERT_CHAIN_CONTEXT,
    pdwSecureFlags: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "wininet" fn InternetGetSecurityInfoByURLW(
    lpszURL: ?[*:0]const u16,
    ppCertChain: ?*?*CERT_CHAIN_CONTEXT,
    pdwSecureFlags: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "wininet" fn InternetGetSecurityInfoByURL(
    lpszURL: ?PSTR,
    ppCertChain: ?*?*CERT_CHAIN_CONTEXT,
    pdwSecureFlags: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "wininet" fn ShowSecurityInfo(
    hWndParent: ?HWND,
    pSecurityInfo: ?*INTERNET_SECURITY_INFO,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "wininet" fn ShowX509EncodedCertificate(
    hWndParent: ?HWND,
    // TODO: what to do with BytesParamIndex 2?
    lpCert: ?*u8,
    cbCert: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "wininet" fn ShowClientAuthCerts(
    hWndParent: ?HWND,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "wininet" fn ParseX509EncodedCertificateForListBoxEntry(
    // TODO: what to do with BytesParamIndex 1?
    lpCert: ?*u8,
    cbCert: u32,
    lpszListBoxEntry: ?[*:0]u8,
    lpdwListBoxEntry: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "wininet" fn InternetShowSecurityInfoByURLA(
    lpszURL: ?PSTR,
    hwndParent: ?HWND,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "wininet" fn InternetShowSecurityInfoByURLW(
    lpszURL: ?[*:0]const u16,
    hwndParent: ?HWND,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "wininet" fn InternetShowSecurityInfoByURL(
    lpszURL: ?PSTR,
    hwndParent: ?HWND,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "wininet" fn InternetFortezzaCommand(
    dwCommand: u32,
    hwnd: ?HWND,
    dwReserved: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "wininet" fn InternetQueryFortezzaStatus(
    pdwStatus: ?*u32,
    dwReserved: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "wininet" fn InternetWriteFileExA(
    hFile: ?*anyopaque,
    lpBuffersIn: ?*INTERNET_BUFFERSA,
    dwFlags: u32,
    dwContext: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "wininet" fn InternetWriteFileExW(
    hFile: ?*anyopaque,
    lpBuffersIn: ?*INTERNET_BUFFERSW,
    dwFlags: u32,
    dwContext: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "wininet" fn FindP3PPolicySymbol(
    pszSymbol: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "wininet" fn HttpGetServerCredentials(
    pwszUrl: ?PWSTR,
    ppwszUserName: ?*?PWSTR,
    ppwszPassword: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "wininet" fn HttpPushEnable(
    hRequest: ?*anyopaque,
    pTransportSetting: ?*HTTP_PUSH_TRANSPORT_SETTING,
    phWait: ?*HTTP_PUSH_WAIT_HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "wininet" fn HttpPushWait(
    hWait: HTTP_PUSH_WAIT_HANDLE,
    eType: HTTP_PUSH_WAIT_TYPE,
    pNotificationStatus: ?*HTTP_PUSH_NOTIFICATION_STATUS,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "wininet" fn HttpPushClose(
    hWait: HTTP_PUSH_WAIT_HANDLE,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "wininet" fn HttpCheckDavComplianceA(
    lpszUrl: ?[*:0]const u8,
    lpszComplianceToken: ?[*:0]const u8,
    lpfFound: ?*i32,
    hWnd: ?HWND,
    lpvReserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "wininet" fn HttpCheckDavComplianceW(
    lpszUrl: ?[*:0]const u16,
    lpszComplianceToken: ?[*:0]const u16,
    lpfFound: ?*i32,
    hWnd: ?HWND,
    lpvReserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "wininet" fn IsUrlCacheEntryExpiredA(
    lpszUrlName: ?[*:0]const u8,
    dwFlags: u32,
    pftLastModified: ?*FILETIME,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "wininet" fn IsUrlCacheEntryExpiredW(
    lpszUrlName: ?[*:0]const u16,
    dwFlags: u32,
    pftLastModified: ?*FILETIME,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "wininet" fn CreateUrlCacheEntryExW(
    lpszUrlName: ?[*:0]const u16,
    dwExpectedFileSize: u32,
    lpszFileExtension: ?[*:0]const u16,
    lpszFileName: *[260]u16,
    dwReserved: u32,
    fPreserveIncomingFileName: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "wininet" fn GetUrlCacheEntryBinaryBlob(
    pwszUrlName: ?[*:0]const u16,
    dwType: ?*u32,
    pftExpireTime: ?*FILETIME,
    pftAccessTime: ?*FILETIME,
    pftModifiedTime: ?*FILETIME,
    ppbBlob: ?[*]?*u8,
    pcbBlob: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "wininet" fn CommitUrlCacheEntryBinaryBlob(
    pwszUrlName: ?[*:0]const u16,
    dwType: u32,
    ftExpireTime: FILETIME,
    ftModifiedTime: FILETIME,
    pbBlob: ?[*:0]const u8,
    cbBlob: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn CreateUrlCacheContainerA(
    Name: ?[*:0]const u8,
    lpCachePrefix: ?[*:0]const u8,
    lpszCachePath: ?[*:0]const u8,
    KBCacheLimit: u32,
    dwContainerType: u32,
    dwOptions: u32,
    pvBuffer: ?*anyopaque,
    cbBuffer: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn CreateUrlCacheContainerW(
    Name: ?[*:0]const u16,
    lpCachePrefix: ?[*:0]const u16,
    lpszCachePath: ?[*:0]const u16,
    KBCacheLimit: u32,
    dwContainerType: u32,
    dwOptions: u32,
    pvBuffer: ?*anyopaque,
    cbBuffer: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn DeleteUrlCacheContainerA(
    Name: ?[*:0]const u8,
    dwOptions: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn DeleteUrlCacheContainerW(
    Name: ?[*:0]const u16,
    dwOptions: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "wininet" fn FindFirstUrlCacheContainerA(
    pdwModified: ?*u32,
    // TODO: what to do with BytesParamIndex 2?
    lpContainerInfo: ?*INTERNET_CACHE_CONTAINER_INFOA,
    lpcbContainerInfo: ?*u32,
    dwOptions: u32,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

pub extern "wininet" fn FindFirstUrlCacheContainerW(
    pdwModified: ?*u32,
    // TODO: what to do with BytesParamIndex 2?
    lpContainerInfo: ?*INTERNET_CACHE_CONTAINER_INFOW,
    lpcbContainerInfo: ?*u32,
    dwOptions: u32,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

pub extern "wininet" fn FindNextUrlCacheContainerA(
    hEnumHandle: ?HANDLE,
    // TODO: what to do with BytesParamIndex 2?
    lpContainerInfo: ?*INTERNET_CACHE_CONTAINER_INFOA,
    lpcbContainerInfo: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "wininet" fn FindNextUrlCacheContainerW(
    hEnumHandle: ?HANDLE,
    // TODO: what to do with BytesParamIndex 2?
    lpContainerInfo: ?*INTERNET_CACHE_CONTAINER_INFOW,
    lpcbContainerInfo: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn FreeUrlCacheSpaceA(
    lpszCachePath: ?[*:0]const u8,
    dwSize: u32,
    dwFilter: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wininet" fn FreeUrlCacheSpaceW(
    lpszCachePath: ?[*:0]const u16,
    dwSize: u32,
    dwFilter: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "wininet" fn UrlCacheFreeGlobalSpace(
    ullTargetSize: u64,
    dwFilter: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "wininet" fn UrlCacheGetGlobalCacheSize(
    dwFilter: u32,
    pullSize: ?*u64,
    pullLimit: ?*u64,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "wininet" fn GetUrlCacheConfigInfoA(
    lpCacheConfigInfo: ?*INTERNET_CACHE_CONFIG_INFOA,
    lpcbCacheConfigInfo: ?*u32,
    dwFieldControl: CACHE_CONFIG,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "wininet" fn GetUrlCacheConfigInfoW(
    lpCacheConfigInfo: ?*INTERNET_CACHE_CONFIG_INFOW,
    lpcbCacheConfigInfo: ?*u32,
    dwFieldControl: CACHE_CONFIG,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "wininet" fn SetUrlCacheConfigInfoA(
    lpCacheConfigInfo: ?*INTERNET_CACHE_CONFIG_INFOA,
    dwFieldControl: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "wininet" fn SetUrlCacheConfigInfoW(
    lpCacheConfigInfo: ?*INTERNET_CACHE_CONFIG_INFOW,
    dwFieldControl: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "wininet" fn RunOnceUrlCache(
    hwnd: ?HWND,
    hinst: ?HINSTANCE,
    lpszCmd: ?PSTR,
    nCmdShow: i32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "wininet" fn DeleteIE3Cache(
    hwnd: ?HWND,
    hinst: ?HINSTANCE,
    lpszCmd: ?PSTR,
    nCmdShow: i32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "wininet" fn UpdateUrlCacheContentPath(
    szNewPath: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "wininet" fn RegisterUrlCacheNotification(
    hWnd: ?HWND,
    uMsg: u32,
    gid: i64,
    dwOpsFilter: u32,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "wininet" fn GetUrlCacheHeaderData(
    nIdx: u32,
    lpdwData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "wininet" fn SetUrlCacheHeaderData(
    nIdx: u32,
    dwData: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "wininet" fn IncrementUrlCacheHeaderData(
    nIdx: u32,
    lpdwData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "wininet" fn LoadUrlCacheContent(
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "wininet" fn AppCacheLookup(
    pwszUrl: ?[*:0]const u16,
    dwFlags: u32,
    phAppCache: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "wininet" fn AppCacheCheckManifest(
    pwszMasterUrl: ?[*:0]const u16,
    pwszManifestUrl: ?[*:0]const u16,
    // TODO: what to do with BytesParamIndex 3?
    pbManifestData: ?*const u8,
    dwManifestDataSize: u32,
    // TODO: what to do with BytesParamIndex 5?
    pbManifestResponseHeaders: ?*const u8,
    dwManifestResponseHeadersSize: u32,
    peState: ?*APP_CACHE_STATE,
    phNewAppCache: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "wininet" fn AppCacheGetDownloadList(
    hAppCache: ?*anyopaque,
    pDownloadList: ?*APP_CACHE_DOWNLOAD_LIST,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "wininet" fn AppCacheFreeDownloadList(
    pDownloadList: ?*APP_CACHE_DOWNLOAD_LIST,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "wininet" fn AppCacheFinalize(
    hAppCache: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 2?
    pbManifestData: ?*const u8,
    dwManifestDataSize: u32,
    peState: ?*APP_CACHE_FINALIZE_STATE,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "wininet" fn AppCacheGetFallbackUrl(
    hAppCache: ?*anyopaque,
    pwszUrl: ?[*:0]const u16,
    ppwszFallbackUrl: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "wininet" fn AppCacheGetManifestUrl(
    hAppCache: ?*anyopaque,
    ppwszManifestUrl: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "wininet" fn AppCacheDuplicateHandle(
    hAppCache: ?*anyopaque,
    phDuplicatedAppCache: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "wininet" fn AppCacheCloseHandle(
    hAppCache: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "wininet" fn AppCacheFreeGroupList(
    pAppCacheGroupList: ?*APP_CACHE_GROUP_LIST,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "wininet" fn AppCacheGetGroupList(
    pAppCacheGroupList: ?*APP_CACHE_GROUP_LIST,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "wininet" fn AppCacheGetInfo(
    hAppCache: ?*anyopaque,
    pAppCacheInfo: ?*APP_CACHE_GROUP_INFO,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "wininet" fn AppCacheDeleteGroup(
    pwszManifestUrl: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "wininet" fn AppCacheFreeSpace(
    ftCutOff: FILETIME,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "wininet" fn AppCacheGetIEGroupList(
    pAppCacheGroupList: ?*APP_CACHE_GROUP_LIST,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "wininet" fn AppCacheDeleteIEGroup(
    pwszManifestUrl: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "wininet" fn AppCacheFreeIESpace(
    ftCutOff: FILETIME,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "wininet" fn AppCacheCreateAndCommitFile(
    hAppCache: ?*anyopaque,
    pwszSourceFilePath: ?[*:0]const u16,
    pwszUrl: ?[*:0]const u16,
    // TODO: what to do with BytesParamIndex 4?
    pbResponseHeaders: ?*const u8,
    dwResponseHeadersSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "wininet" fn HttpOpenDependencyHandle(
    hRequestHandle: ?*anyopaque,
    fBackground: BOOL,
    phDependencyHandle: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "wininet" fn HttpCloseDependencyHandle(
    hDependencyHandle: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "wininet" fn HttpDuplicateDependencyHandle(
    hDependencyHandle: ?*anyopaque,
    phDuplicatedDependencyHandle: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "wininet" fn HttpIndicatePageLoadComplete(
    hDependencyHandle: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "wininet" fn UrlCacheFreeEntryInfo(
    pCacheEntryInfo: ?*URLCACHE_ENTRY_INFO,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "wininet" fn UrlCacheGetEntryInfo(
    hAppCache: ?*anyopaque,
    pcwszUrl: ?[*:0]const u16,
    pCacheEntryInfo: ?*URLCACHE_ENTRY_INFO,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "wininet" fn UrlCacheCloseEntryHandle(
    hEntryFile: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "wininet" fn UrlCacheRetrieveEntryFile(
    hAppCache: ?*anyopaque,
    pcwszUrl: ?[*:0]const u16,
    pCacheEntryInfo: ?*URLCACHE_ENTRY_INFO,
    phEntryFile: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "wininet" fn UrlCacheReadEntryStream(
    hUrlCacheStream: ?*anyopaque,
    ullLocation: u64,
    pBuffer: ?*anyopaque,
    dwBufferLen: u32,
    pdwBufferLen: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "wininet" fn UrlCacheRetrieveEntryStream(
    hAppCache: ?*anyopaque,
    pcwszUrl: ?[*:0]const u16,
    fRandomRead: BOOL,
    pCacheEntryInfo: ?*URLCACHE_ENTRY_INFO,
    phEntryStream: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "wininet" fn UrlCacheUpdateEntryExtraData(
    hAppCache: ?*anyopaque,
    pcwszUrl: ?[*:0]const u16,
    // TODO: what to do with BytesParamIndex 3?
    pbExtraData: ?*const u8,
    cbExtraData: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "wininet" fn UrlCacheCreateContainer(
    pwszName: ?[*:0]const u16,
    pwszPrefix: ?[*:0]const u16,
    pwszDirectory: ?[*:0]const u16,
    ullLimit: u64,
    dwOptions: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "wininet" fn UrlCacheCheckEntriesExist(
    rgpwszUrls: [*]?PWSTR,
    cEntries: u32,
    rgfExist: [*]BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "wininet" fn UrlCacheGetContentPaths(
    pppwszDirectories: ?*?*?PWSTR,
    pcDirectories: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "wininet" fn UrlCacheGetGlobalLimit(
    limitType: URL_CACHE_LIMIT_TYPE,
    pullLimit: ?*u64,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "wininet" fn UrlCacheSetGlobalLimit(
    limitType: URL_CACHE_LIMIT_TYPE,
    ullLimit: u64,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "wininet" fn UrlCacheReloadSettings(
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "wininet" fn UrlCacheContainerSetEntryMaximumAge(
    pwszPrefix: ?[*:0]const u16,
    dwEntryMaxAge: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "wininet" fn UrlCacheFindFirstEntry(
    pwszPrefix: ?[*:0]const u16,
    dwFlags: u32,
    dwFilter: u32,
    GroupId: i64,
    pCacheEntryInfo: ?*URLCACHE_ENTRY_INFO,
    phFind: ?*?HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "wininet" fn UrlCacheFindNextEntry(
    hFind: ?HANDLE,
    pCacheEntryInfo: ?*URLCACHE_ENTRY_INFO,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "wininet" fn UrlCacheServer(
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "wininet" fn ReadGuidsForConnectedNetworks(
    pcNetworks: ?*u32,
    pppwszNetworkGuids: ?*?*?PWSTR,
    pppbstrNetworkNames: ?*?*?BSTR,
    pppwszGWMacs: ?*?*?PWSTR,
    pcGatewayMacs: ?*u32,
    pdwFlags: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "wininet" fn IsHostInProxyBypassList(
    tScheme: INTERNET_SCHEME,
    lpszHost: [*:0]const u8,
    cchHost: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "wininet" fn InternetFreeProxyInfoList(
    pProxyInfoList: ?*WININET_PROXY_INFO_LIST,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "wininet" fn InternetGetProxyForUrl(
    hInternet: ?*anyopaque,
    pcwszUrl: ?[*:0]const u16,
    pProxyInfoList: ?*WININET_PROXY_INFO_LIST,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "wininet" fn DoConnectoidsExist(
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "wininet" fn GetDiskInfoA(
    pszPath: ?[*:0]const u8,
    pdwClusterSize: ?*u32,
    pdlAvail: ?*u64,
    pdlTotal: ?*u64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "wininet" fn PerformOperationOverUrlCacheA(
    pszUrlSearchPattern: ?[*:0]const u8,
    dwFlags: u32,
    dwFilter: u32,
    GroupId: i64,
    pReserved1: ?*anyopaque,
    pdwReserved2: ?*u32,
    pReserved3: ?*anyopaque,
    op: ?CACHE_OPERATOR,
    pOperatorData: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "wininet" fn IsProfilesEnabled(
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "wininet" fn InternalInternetGetCookie(
    lpszUrl: ?[*:0]const u8,
    lpszCookieData: [*:0]u8,
    lpdwDataSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "wininet" fn ImportCookieFileA(
    szFilename: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "wininet" fn ImportCookieFileW(
    szFilename: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "wininet" fn ExportCookieFileA(
    szFilename: ?[*:0]const u8,
    fAppend: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "wininet" fn ExportCookieFileW(
    szFilename: ?[*:0]const u16,
    fAppend: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "wininet" fn IsDomainLegalCookieDomainA(
    pchDomain: ?[*:0]const u8,
    pchFullDomain: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "wininet" fn IsDomainLegalCookieDomainW(
    pchDomain: ?[*:0]const u16,
    pchFullDomain: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "wininet" fn HttpWebSocketCompleteUpgrade(
    hRequest: ?*anyopaque,
    dwContext: usize,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

pub extern "wininet" fn HttpWebSocketSend(
    hWebSocket: ?*anyopaque,
    BufferType: HTTP_WEB_SOCKET_BUFFER_TYPE,
    // TODO: what to do with BytesParamIndex 3?
    pvBuffer: ?*anyopaque,
    dwBufferLength: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "wininet" fn HttpWebSocketReceive(
    hWebSocket: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 2?
    pvBuffer: ?*anyopaque,
    dwBufferLength: u32,
    pdwBytesRead: ?*u32,
    pBufferType: ?*HTTP_WEB_SOCKET_BUFFER_TYPE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "wininet" fn HttpWebSocketClose(
    hWebSocket: ?*anyopaque,
    usStatus: u16,
    // TODO: what to do with BytesParamIndex 3?
    pvReason: ?*anyopaque,
    dwReasonLength: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "wininet" fn HttpWebSocketShutdown(
    hWebSocket: ?*anyopaque,
    usStatus: u16,
    // TODO: what to do with BytesParamIndex 3?
    pvReason: ?*anyopaque,
    dwReasonLength: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "wininet" fn HttpWebSocketQueryCloseStatus(
    hWebSocket: ?*anyopaque,
    pusStatus: ?*u16,
    // TODO: what to do with BytesParamIndex 3?
    pvReason: ?*anyopaque,
    dwReasonLength: u32,
    pdwReasonLengthConsumed: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "wininet" fn InternetConvertUrlFromWireToWideChar(
    pcszUrl: [*:0]const u8,
    cchUrl: u32,
    pcwszBaseUrl: ?[*:0]const u16,
    dwCodePageHost: u32,
    dwCodePagePath: u32,
    fEncodePathExtra: BOOL,
    dwCodePageExtra: u32,
    ppwszConvertedUrl: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) u32;


//--------------------------------------------------------------------------------
// Section: Unicode Aliases (81)
//--------------------------------------------------------------------------------
pub const INTERNET_PER_CONN_OPTION = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().INTERNET_PER_CONN_OPTIONA,
    .wide => @This().INTERNET_PER_CONN_OPTIONW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'INTERNET_PER_CONN_OPTION' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const INTERNET_PER_CONN_OPTION_LIST = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().INTERNET_PER_CONN_OPTION_LISTA,
    .wide => @This().INTERNET_PER_CONN_OPTION_LISTW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'INTERNET_PER_CONN_OPTION_LIST' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const URL_COMPONENTS = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().URL_COMPONENTSA,
    .wide => @This().URL_COMPONENTSW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'URL_COMPONENTS' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const INTERNET_BUFFERS = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().INTERNET_BUFFERSA,
    .wide => @This().INTERNET_BUFFERSW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'INTERNET_BUFFERS' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const GOPHER_FIND_DATA = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().GOPHER_FIND_DATAA,
    .wide => @This().GOPHER_FIND_DATAW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'GOPHER_FIND_DATA' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const INTERNET_CACHE_ENTRY_INFO = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().INTERNET_CACHE_ENTRY_INFOA,
    .wide => @This().INTERNET_CACHE_ENTRY_INFOW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'INTERNET_CACHE_ENTRY_INFO' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const INTERNET_CACHE_GROUP_INFO = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().INTERNET_CACHE_GROUP_INFOA,
    .wide => @This().INTERNET_CACHE_GROUP_INFOW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'INTERNET_CACHE_GROUP_INFO' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const INTERNET_CACHE_CONFIG_PATH_ENTRY = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().INTERNET_CACHE_CONFIG_PATH_ENTRYA,
    .wide => @This().INTERNET_CACHE_CONFIG_PATH_ENTRYW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'INTERNET_CACHE_CONFIG_PATH_ENTRY' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const INTERNET_CACHE_CONFIG_INFO = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().INTERNET_CACHE_CONFIG_INFOA,
    .wide => @This().INTERNET_CACHE_CONFIG_INFOW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'INTERNET_CACHE_CONFIG_INFO' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const INTERNET_CACHE_CONTAINER_INFO = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().INTERNET_CACHE_CONTAINER_INFOA,
    .wide => @This().INTERNET_CACHE_CONTAINER_INFOW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'INTERNET_CACHE_CONTAINER_INFO' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const InternetCrackUrl = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().InternetCrackUrlA,
    .wide => @This().InternetCrackUrlW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'InternetCrackUrl' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const InternetCreateUrl = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().InternetCreateUrlA,
    .wide => @This().InternetCreateUrlW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'InternetCreateUrl' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const InternetCanonicalizeUrl = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().InternetCanonicalizeUrlA,
    .wide => @This().InternetCanonicalizeUrlW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'InternetCanonicalizeUrl' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const InternetCombineUrl = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().InternetCombineUrlA,
    .wide => @This().InternetCombineUrlW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'InternetCombineUrl' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const InternetOpen = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().InternetOpenA,
    .wide => @This().InternetOpenW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'InternetOpen' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const InternetConnect = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().InternetConnectA,
    .wide => @This().InternetConnectW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'InternetConnect' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const InternetOpenUrl = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().InternetOpenUrlA,
    .wide => @This().InternetOpenUrlW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'InternetOpenUrl' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const InternetReadFileEx = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().InternetReadFileExA,
    .wide => @This().InternetReadFileExW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'InternetReadFileEx' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const InternetFindNextFile = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().InternetFindNextFileA,
    .wide => @This().InternetFindNextFileW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'InternetFindNextFile' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const InternetQueryOption = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().InternetQueryOptionA,
    .wide => @This().InternetQueryOptionW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'InternetQueryOption' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const InternetSetOption = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().InternetSetOptionA,
    .wide => @This().InternetSetOptionW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'InternetSetOption' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const InternetSetOptionEx = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().InternetSetOptionExA,
    .wide => @This().InternetSetOptionExW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'InternetSetOptionEx' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const InternetGetLastResponseInfo = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().InternetGetLastResponseInfoA,
    .wide => @This().InternetGetLastResponseInfoW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'InternetGetLastResponseInfo' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const FtpFindFirstFile = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().FtpFindFirstFileA,
    .wide => @This().FtpFindFirstFileW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'FtpFindFirstFile' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const FtpGetFile = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().FtpGetFileA,
    .wide => @This().FtpGetFileW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'FtpGetFile' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const FtpPutFile = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().FtpPutFileA,
    .wide => @This().FtpPutFileW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'FtpPutFile' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const FtpDeleteFile = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().FtpDeleteFileA,
    .wide => @This().FtpDeleteFileW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'FtpDeleteFile' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const FtpRenameFile = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().FtpRenameFileA,
    .wide => @This().FtpRenameFileW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'FtpRenameFile' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const FtpOpenFile = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().FtpOpenFileA,
    .wide => @This().FtpOpenFileW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'FtpOpenFile' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const FtpCreateDirectory = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().FtpCreateDirectoryA,
    .wide => @This().FtpCreateDirectoryW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'FtpCreateDirectory' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const FtpRemoveDirectory = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().FtpRemoveDirectoryA,
    .wide => @This().FtpRemoveDirectoryW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'FtpRemoveDirectory' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const FtpSetCurrentDirectory = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().FtpSetCurrentDirectoryA,
    .wide => @This().FtpSetCurrentDirectoryW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'FtpSetCurrentDirectory' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const FtpGetCurrentDirectory = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().FtpGetCurrentDirectoryA,
    .wide => @This().FtpGetCurrentDirectoryW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'FtpGetCurrentDirectory' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const FtpCommand = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().FtpCommandA,
    .wide => @This().FtpCommandW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'FtpCommand' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const GopherCreateLocator = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().GopherCreateLocatorA,
    .wide => @This().GopherCreateLocatorW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'GopherCreateLocator' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const GopherGetLocatorType = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().GopherGetLocatorTypeA,
    .wide => @This().GopherGetLocatorTypeW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'GopherGetLocatorType' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const GopherFindFirstFile = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().GopherFindFirstFileA,
    .wide => @This().GopherFindFirstFileW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'GopherFindFirstFile' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const GopherOpenFile = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().GopherOpenFileA,
    .wide => @This().GopherOpenFileW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'GopherOpenFile' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const GopherGetAttribute = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().GopherGetAttributeA,
    .wide => @This().GopherGetAttributeW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'GopherGetAttribute' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const HttpOpenRequest = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().HttpOpenRequestA,
    .wide => @This().HttpOpenRequestW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'HttpOpenRequest' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const HttpAddRequestHeaders = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().HttpAddRequestHeadersA,
    .wide => @This().HttpAddRequestHeadersW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'HttpAddRequestHeaders' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const HttpSendRequest = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().HttpSendRequestA,
    .wide => @This().HttpSendRequestW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'HttpSendRequest' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const HttpSendRequestEx = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().HttpSendRequestExA,
    .wide => @This().HttpSendRequestExW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'HttpSendRequestEx' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const HttpEndRequest = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().HttpEndRequestA,
    .wide => @This().HttpEndRequestW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'HttpEndRequest' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const HttpQueryInfo = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().HttpQueryInfoA,
    .wide => @This().HttpQueryInfoW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'HttpQueryInfo' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const InternetSetCookie = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().InternetSetCookieA,
    .wide => @This().InternetSetCookieW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'InternetSetCookie' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const InternetGetCookie = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().InternetGetCookieA,
    .wide => @This().InternetGetCookieW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'InternetGetCookie' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const InternetSetCookieEx = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().InternetSetCookieExA,
    .wide => @This().InternetSetCookieExW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'InternetSetCookieEx' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const InternetGetCookieEx = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().InternetGetCookieExA,
    .wide => @This().InternetGetCookieExW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'InternetGetCookieEx' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const InternetCheckConnection = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().InternetCheckConnectionA,
    .wide => @This().InternetCheckConnectionW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'InternetCheckConnection' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const CreateUrlCacheEntry = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().CreateUrlCacheEntryA,
    .wide => @This().CreateUrlCacheEntryW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'CreateUrlCacheEntry' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const CommitUrlCacheEntry = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().CommitUrlCacheEntryA,
    .wide => @This().CommitUrlCacheEntryW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'CommitUrlCacheEntry' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const RetrieveUrlCacheEntryFile = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().RetrieveUrlCacheEntryFileA,
    .wide => @This().RetrieveUrlCacheEntryFileW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'RetrieveUrlCacheEntryFile' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const RetrieveUrlCacheEntryStream = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().RetrieveUrlCacheEntryStreamA,
    .wide => @This().RetrieveUrlCacheEntryStreamW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'RetrieveUrlCacheEntryStream' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const GetUrlCacheEntryInfo = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().GetUrlCacheEntryInfoA,
    .wide => @This().GetUrlCacheEntryInfoW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'GetUrlCacheEntryInfo' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const GetUrlCacheGroupAttribute = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().GetUrlCacheGroupAttributeA,
    .wide => @This().GetUrlCacheGroupAttributeW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'GetUrlCacheGroupAttribute' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const SetUrlCacheGroupAttribute = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().SetUrlCacheGroupAttributeA,
    .wide => @This().SetUrlCacheGroupAttributeW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'SetUrlCacheGroupAttribute' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const GetUrlCacheEntryInfoEx = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().GetUrlCacheEntryInfoExA,
    .wide => @This().GetUrlCacheEntryInfoExW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'GetUrlCacheEntryInfoEx' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const SetUrlCacheEntryInfo = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().SetUrlCacheEntryInfoA,
    .wide => @This().SetUrlCacheEntryInfoW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'SetUrlCacheEntryInfo' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const FindFirstUrlCacheEntryEx = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().FindFirstUrlCacheEntryExA,
    .wide => @This().FindFirstUrlCacheEntryExW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'FindFirstUrlCacheEntryEx' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const FindNextUrlCacheEntryEx = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().FindNextUrlCacheEntryExA,
    .wide => @This().FindNextUrlCacheEntryExW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'FindNextUrlCacheEntryEx' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const FindFirstUrlCacheEntry = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().FindFirstUrlCacheEntryA,
    .wide => @This().FindFirstUrlCacheEntryW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'FindFirstUrlCacheEntry' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const FindNextUrlCacheEntry = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().FindNextUrlCacheEntryA,
    .wide => @This().FindNextUrlCacheEntryW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'FindNextUrlCacheEntry' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const InternetSetPerSiteCookieDecision = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().InternetSetPerSiteCookieDecisionA,
    .wide => @This().InternetSetPerSiteCookieDecisionW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'InternetSetPerSiteCookieDecision' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const InternetGetPerSiteCookieDecision = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().InternetGetPerSiteCookieDecisionA,
    .wide => @This().InternetGetPerSiteCookieDecisionW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'InternetGetPerSiteCookieDecision' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const InternetEnumPerSiteCookieDecision = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().InternetEnumPerSiteCookieDecisionA,
    .wide => @This().InternetEnumPerSiteCookieDecisionW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'InternetEnumPerSiteCookieDecision' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const InternetAlgIdToString = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().InternetAlgIdToStringA,
    .wide => @This().InternetAlgIdToStringW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'InternetAlgIdToString' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const InternetSecurityProtocolToString = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().InternetSecurityProtocolToStringA,
    .wide => @This().InternetSecurityProtocolToStringW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'InternetSecurityProtocolToString' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const InternetWriteFileEx = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().InternetWriteFileExA,
    .wide => @This().InternetWriteFileExW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'InternetWriteFileEx' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const HttpCheckDavCompliance = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().HttpCheckDavComplianceA,
    .wide => @This().HttpCheckDavComplianceW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'HttpCheckDavCompliance' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const IsUrlCacheEntryExpired = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().IsUrlCacheEntryExpiredA,
    .wide => @This().IsUrlCacheEntryExpiredW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'IsUrlCacheEntryExpired' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const CreateUrlCacheContainer = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().CreateUrlCacheContainerA,
    .wide => @This().CreateUrlCacheContainerW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'CreateUrlCacheContainer' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const DeleteUrlCacheContainer = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().DeleteUrlCacheContainerA,
    .wide => @This().DeleteUrlCacheContainerW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'DeleteUrlCacheContainer' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const FindFirstUrlCacheContainer = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().FindFirstUrlCacheContainerA,
    .wide => @This().FindFirstUrlCacheContainerW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'FindFirstUrlCacheContainer' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const FindNextUrlCacheContainer = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().FindNextUrlCacheContainerA,
    .wide => @This().FindNextUrlCacheContainerW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'FindNextUrlCacheContainer' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const FreeUrlCacheSpace = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().FreeUrlCacheSpaceA,
    .wide => @This().FreeUrlCacheSpaceW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'FreeUrlCacheSpace' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const GetUrlCacheConfigInfo = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().GetUrlCacheConfigInfoA,
    .wide => @This().GetUrlCacheConfigInfoW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'GetUrlCacheConfigInfo' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const SetUrlCacheConfigInfo = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().SetUrlCacheConfigInfoA,
    .wide => @This().SetUrlCacheConfigInfoW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'SetUrlCacheConfigInfo' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const ImportCookieFile = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().ImportCookieFileA,
    .wide => @This().ImportCookieFileW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'ImportCookieFile' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const ExportCookieFile = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().ExportCookieFileA,
    .wide => @This().ExportCookieFileW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'ExportCookieFile' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const IsDomainLegalCookieDomain = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().IsDomainLegalCookieDomainA,
    .wide => @This().IsDomainLegalCookieDomainW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'IsDomainLegalCookieDomain' requires that UNICODE be set to true or false in the root module",
    ),
};
//--------------------------------------------------------------------------------
// Section: Imports (23)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const BOOL = @import("../foundation.zig").BOOL;
const BSTR = @import("../foundation.zig").BSTR;
const CERT_CHAIN_CONTEXT = @import("../security/cryptography.zig").CERT_CHAIN_CONTEXT;
const CERT_CONTEXT = @import("../security/cryptography.zig").CERT_CONTEXT;
const CHAR = @import("../foundation.zig").CHAR;
const FILETIME = @import("../foundation.zig").FILETIME;
const HANDLE = @import("../foundation.zig").HANDLE;
const HBITMAP = @import("../graphics/gdi.zig").HBITMAP;
const HINSTANCE = @import("../foundation.zig").HINSTANCE;
const HRESULT = @import("../foundation.zig").HRESULT;
const HWND = @import("../foundation.zig").HWND;
const IInspectable = @import("../system/win_rt.zig").IInspectable;
const IUnknown = @import("../system/com.zig").IUnknown;
const PSTR = @import("../foundation.zig").PSTR;
const PWSTR = @import("../foundation.zig").PWSTR;
const SecPkgContext_Bindings = @import("../security/authentication/identity.zig").SecPkgContext_Bindings;
const SecPkgContext_CipherInfo = @import("../security/authentication/identity.zig").SecPkgContext_CipherInfo;
const SecPkgContext_ConnectionInfo = @import("../security/authentication/identity.zig").SecPkgContext_ConnectionInfo;
const SYSTEMTIME = @import("../foundation.zig").SYSTEMTIME;
const WIN32_FIND_DATAA = @import("../storage/file_system.zig").WIN32_FIND_DATAA;
const WIN32_FIND_DATAW = @import("../storage/file_system.zig").WIN32_FIND_DATAW;
const WIN_HTTP_CREATE_URL_FLAGS = @import("../networking/win_http.zig").WIN_HTTP_CREATE_URL_FLAGS;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "LPINTERNET_STATUS_CALLBACK")) { _ = LPINTERNET_STATUS_CALLBACK; }
    if (@hasDecl(@This(), "GOPHER_ATTRIBUTE_ENUMERATOR")) { _ = GOPHER_ATTRIBUTE_ENUMERATOR; }
    if (@hasDecl(@This(), "PFN_AUTH_NOTIFY")) { _ = PFN_AUTH_NOTIFY; }
    if (@hasDecl(@This(), "pfnInternetInitializeAutoProxyDll")) { _ = pfnInternetInitializeAutoProxyDll; }
    if (@hasDecl(@This(), "pfnInternetDeInitializeAutoProxyDll")) { _ = pfnInternetDeInitializeAutoProxyDll; }
    if (@hasDecl(@This(), "pfnInternetGetProxyInfo")) { _ = pfnInternetGetProxyInfo; }
    if (@hasDecl(@This(), "PFN_DIAL_HANDLER")) { _ = PFN_DIAL_HANDLER; }
    if (@hasDecl(@This(), "CACHE_OPERATOR")) { _ = CACHE_OPERATOR; }
    if (@hasDecl(@This(), "HTTP_POLICY_EXTENSION_INIT")) { _ = HTTP_POLICY_EXTENSION_INIT; }
    if (@hasDecl(@This(), "HTTP_POLICY_EXTENSION_SHUTDOWN")) { _ = HTTP_POLICY_EXTENSION_SHUTDOWN; }

    @setEvalBranchQuota(
        comptime @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        _ = @field(@This(), decl.name);
    }
}
