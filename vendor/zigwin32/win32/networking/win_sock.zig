//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (1127)
//--------------------------------------------------------------------------------
pub const SOCKET_DEFAULT2_QM_POLICY = Guid.initString("aec2ef9c-3a4d-4d3e-8842-239942e39a47");
pub const REAL_TIME_NOTIFICATION_CAPABILITY = Guid.initString("6b59819a-5cae-492d-a901-2a3c2c50164f");
pub const REAL_TIME_NOTIFICATION_CAPABILITY_EX = Guid.initString("6843da03-154a-4616-a508-44371295f96b");
pub const ASSOCIATE_NAMERES_CONTEXT = Guid.initString("59a38b67-d4fe-46e1-ba3c-87ea74ca3049");
pub const SIO_RCVALL = @as(u32, 2550136833);
pub const SIO_RCVALL_MCAST = @as(u32, 2550136834);
pub const SIO_RCVALL_IGMPMCAST = @as(u32, 2550136835);
pub const SIO_KEEPALIVE_VALS = @as(u32, 2550136836);
pub const SIO_ABSORB_RTRALERT = @as(u32, 2550136837);
pub const SIO_UCAST_IF = @as(u32, 2550136838);
pub const SIO_LIMIT_BROADCASTS = @as(u32, 2550136839);
pub const SIO_INDEX_BIND = @as(u32, 2550136840);
pub const SIO_INDEX_MCASTIF = @as(u32, 2550136841);
pub const SIO_INDEX_ADD_MCAST = @as(u32, 2550136842);
pub const SIO_INDEX_DEL_MCAST = @as(u32, 2550136843);
pub const SIO_RCVALL_MCAST_IF = @as(u32, 2550136845);
pub const SIO_RCVALL_IF = @as(u32, 2550136846);
pub const SIO_LOOPBACK_FAST_PATH = @as(u32, 2550136848);
pub const SIO_TCP_INITIAL_RTO = @as(u32, 2550136849);
pub const SIO_APPLY_TRANSPORT_SETTING = @as(u32, 2550136851);
pub const SIO_QUERY_TRANSPORT_SETTING = @as(u32, 2550136852);
pub const SIO_TCP_SET_ICW = @as(u32, 2550136854);
pub const SIO_TCP_SET_ACK_FREQUENCY = @as(u32, 2550136855);
pub const SIO_SET_PRIORITY_HINT = @as(u32, 2550136856);
pub const SIO_PRIORITY_HINT = @as(u32, 2550136856);
pub const SIO_TCP_INFO = @as(u32, 3623878695);
pub const SIO_CPU_AFFINITY = @as(u32, 2550136853);
pub const SIO_TIMESTAMPING = @as(u32, 2550137067);
pub const TIMESTAMPING_FLAG_RX = @as(u32, 1);
pub const TIMESTAMPING_FLAG_TX = @as(u32, 2);
pub const SO_TIMESTAMP = @as(u32, 12298);
pub const SO_TIMESTAMP_ID = @as(u32, 12299);
pub const SIO_GET_TX_TIMESTAMP = @as(u32, 2550137066);
pub const TCP_INITIAL_RTO_DEFAULT_RTT = @as(u32, 0);
pub const TCP_INITIAL_RTO_DEFAULT_MAX_SYN_RETRANSMISSIONS = @as(u32, 0);
pub const SIO_ACQUIRE_PORT_RESERVATION = @as(u32, 2550136932);
pub const SIO_RELEASE_PORT_RESERVATION = @as(u32, 2550136933);
pub const SIO_ASSOCIATE_PORT_RESERVATION = @as(u32, 2550136934);
pub const SIO_SET_SECURITY = @as(u32, 2550137032);
pub const SIO_QUERY_SECURITY = @as(u32, 3623878857);
pub const SIO_SET_PEER_TARGET_NAME = @as(u32, 2550137034);
pub const SIO_DELETE_PEER_TARGET_NAME = @as(u32, 2550137035);
pub const SIO_QUERY_WFP_CONNECTION_REDIRECT_RECORDS = @as(u32, 2550137052);
pub const SIO_QUERY_WFP_CONNECTION_REDIRECT_CONTEXT = @as(u32, 2550137053);
pub const SIO_SET_WFP_CONNECTION_REDIRECT_RECORDS = @as(u32, 2550137054);
pub const SIO_SOCKET_USAGE_NOTIFICATION = @as(u32, 2550137036);
pub const SOCKET_SETTINGS_GUARANTEE_ENCRYPTION = @as(u32, 1);
pub const SOCKET_SETTINGS_ALLOW_INSECURE = @as(u32, 2);
pub const SOCKET_SETTINGS_IPSEC_SKIP_FILTER_INSTANTIATION = @as(u32, 1);
pub const SOCKET_SETTINGS_IPSEC_OPTIONAL_PEER_NAME_VERIFICATION = @as(u32, 2);
pub const SOCKET_SETTINGS_IPSEC_ALLOW_FIRST_INBOUND_PKT_UNENCRYPTED = @as(u32, 4);
pub const SOCKET_SETTINGS_IPSEC_PEER_NAME_IS_RAW_FORMAT = @as(u32, 8);
pub const SOCKET_QUERY_IPSEC2_ABORT_CONNECTION_ON_FIELD_CHANGE = @as(u32, 1);
pub const SOCKET_QUERY_IPSEC2_FIELD_MASK_MM_SA_ID = @as(u32, 1);
pub const SOCKET_QUERY_IPSEC2_FIELD_MASK_QM_SA_ID = @as(u32, 2);
pub const SOCKET_INFO_CONNECTION_SECURED = @as(u32, 1);
pub const SOCKET_INFO_CONNECTION_ENCRYPTED = @as(u32, 2);
pub const SOCKET_INFO_CONNECTION_IMPERSONATED = @as(u32, 4);
pub const SIO_QUERY_WFP_ALE_ENDPOINT_HANDLE = @as(u32, 1476395213);
pub const SIO_QUERY_RSS_SCALABILITY_INFO = @as(u32, 1476395218);
pub const IN4ADDR_LOOPBACK = @as(u32, 16777343);
pub const IN4ADDR_LOOPBACKPREFIX_LENGTH = @as(u32, 8);
pub const IN4ADDR_LINKLOCALPREFIX_LENGTH = @as(u32, 16);
pub const IN4ADDR_MULTICASTPREFIX_LENGTH = @as(u32, 4);
pub const SIO_SET_COMPATIBILITY_MODE = @as(u32, 2550137132);
pub const RIO_MSG_DONT_NOTIFY = @as(u32, 1);
pub const RIO_MSG_DEFER = @as(u32, 2);
pub const RIO_MSG_WAITALL = @as(u32, 4);
pub const RIO_MSG_COMMIT_ONLY = @as(u32, 8);
pub const RIO_MAX_CQ_SIZE = @as(u32, 134217728);
pub const RIO_CORRUPT_CQ = @as(u32, 4294967295);
pub const AF_UNIX = @as(u16, 1);
pub const AF_IMPLINK = @as(u16, 3);
pub const AF_PUP = @as(u16, 4);
pub const AF_CHAOS = @as(u16, 5);
pub const AF_NS = @as(u16, 6);
pub const AF_IPX = @as(u16, 6);
pub const AF_ISO = @as(u16, 7);
pub const AF_OSI = @as(u16, 7);
pub const AF_ECMA = @as(u16, 8);
pub const AF_DATAKIT = @as(u16, 9);
pub const AF_CCITT = @as(u16, 10);
pub const AF_SNA = @as(u16, 11);
pub const AF_DECnet = @as(u16, 12);
pub const AF_DLI = @as(u16, 13);
pub const AF_LAT = @as(u16, 14);
pub const AF_HYLINK = @as(u16, 15);
pub const AF_APPLETALK = @as(u16, 16);
pub const AF_NETBIOS = @as(u16, 17);
pub const AF_VOICEVIEW = @as(u16, 18);
pub const AF_FIREFOX = @as(u16, 19);
pub const AF_UNKNOWN1 = @as(u16, 20);
pub const AF_BAN = @as(u16, 21);
pub const AF_ATM = @as(u16, 22);
pub const AF_CLUSTER = @as(u16, 24);
pub const AF_12844 = @as(u16, 25);
pub const AF_IRDA = @as(u16, 26);
pub const AF_NETDES = @as(u16, 28);
pub const AF_MAX = @as(u16, 29);
pub const AF_TCNPROCESS = @as(u16, 29);
pub const AF_TCNMESSAGE = @as(u16, 30);
pub const AF_ICLFXBM = @as(u16, 31);
pub const AF_LINK = @as(u16, 33);
pub const AF_HYPERV = @as(u16, 34);
pub const SOCK_STREAM = @as(u16, 1);
pub const SOCK_DGRAM = @as(u16, 2);
pub const SOCK_RAW = @as(u16, 3);
pub const SOCK_RDM = @as(u16, 4);
pub const SOCK_SEQPACKET = @as(u16, 5);
pub const SOL_SOCKET = @as(u32, 65535);
pub const SO_DEBUG = @as(u32, 1);
pub const SO_ACCEPTCONN = @as(u32, 2);
pub const SO_REUSEADDR = @as(u32, 4);
pub const SO_KEEPALIVE = @as(u32, 8);
pub const SO_DONTROUTE = @as(u32, 16);
pub const SO_BROADCAST = @as(u32, 32);
pub const SO_USELOOPBACK = @as(u32, 64);
pub const SO_LINGER = @as(u32, 128);
pub const SO_OOBINLINE = @as(u32, 256);
pub const SO_SNDBUF = @as(u32, 4097);
pub const SO_RCVBUF = @as(u32, 4098);
pub const SO_SNDLOWAT = @as(u32, 4099);
pub const SO_RCVLOWAT = @as(u32, 4100);
pub const SO_SNDTIMEO = @as(u32, 4101);
pub const SO_RCVTIMEO = @as(u32, 4102);
pub const SO_ERROR = @as(u32, 4103);
pub const SO_TYPE = @as(u32, 4104);
pub const SO_BSP_STATE = @as(u32, 4105);
pub const SO_GROUP_ID = @as(u32, 8193);
pub const SO_GROUP_PRIORITY = @as(u32, 8194);
pub const SO_MAX_MSG_SIZE = @as(u32, 8195);
pub const SO_CONDITIONAL_ACCEPT = @as(u32, 12290);
pub const SO_PAUSE_ACCEPT = @as(u32, 12291);
pub const SO_COMPARTMENT_ID = @as(u32, 12292);
pub const SO_RANDOMIZE_PORT = @as(u32, 12293);
pub const SO_PORT_SCALABILITY = @as(u32, 12294);
pub const SO_REUSE_UNICASTPORT = @as(u32, 12295);
pub const SO_REUSE_MULTICASTPORT = @as(u32, 12296);
pub const SO_ORIGINAL_DST = @as(u32, 12303);
pub const IP6T_SO_ORIGINAL_DST = @as(u32, 12303);
pub const WSK_SO_BASE = @as(u32, 16384);
pub const TCP_NODELAY = @as(u32, 1);
pub const _SS_MAXSIZE = @as(u32, 128);
pub const IOC_UNIX = @as(u32, 0);
pub const IOC_WS2 = @as(u32, 134217728);
pub const IOC_PROTOCOL = @as(u32, 268435456);
pub const IOC_VENDOR = @as(u32, 402653184);
pub const SIO_ASSOCIATE_HANDLE = @as(u32, 2281701377);
pub const SIO_ENABLE_CIRCULAR_QUEUEING = @as(u32, 671088642);
pub const SIO_FIND_ROUTE = @as(u32, 1207959555);
pub const SIO_FLUSH = @as(u32, 671088644);
pub const SIO_GET_BROADCAST_ADDRESS = @as(u32, 1207959557);
pub const SIO_GET_EXTENSION_FUNCTION_POINTER = @as(u32, 3355443206);
pub const SIO_GET_QOS = @as(u32, 3355443207);
pub const SIO_GET_GROUP_QOS = @as(u32, 3355443208);
pub const SIO_MULTIPOINT_LOOPBACK = @as(u32, 2281701385);
pub const SIO_MULTICAST_SCOPE = @as(u32, 2281701386);
pub const SIO_SET_QOS = @as(u32, 2281701387);
pub const SIO_SET_GROUP_QOS = @as(u32, 2281701388);
pub const SIO_TRANSLATE_HANDLE = @as(u32, 3355443213);
pub const SIO_ROUTING_INTERFACE_QUERY = @as(u32, 3355443220);
pub const SIO_ROUTING_INTERFACE_CHANGE = @as(u32, 2281701397);
pub const SIO_ADDRESS_LIST_QUERY = @as(u32, 1207959574);
pub const SIO_ADDRESS_LIST_CHANGE = @as(u32, 671088663);
pub const SIO_QUERY_TARGET_PNP_HANDLE = @as(u32, 1207959576);
pub const SIO_QUERY_RSS_PROCESSOR_INFO = @as(u32, 1207959589);
pub const SIO_ADDRESS_LIST_SORT = @as(u32, 3355443225);
pub const SIO_RESERVED_1 = @as(u32, 2281701402);
pub const SIO_RESERVED_2 = @as(u32, 2281701409);
pub const SIO_GET_MULTIPLE_EXTENSION_FUNCTION_POINTER = @as(u32, 3355443236);
pub const IPPROTO_IP = @as(u32, 0);
pub const IPPORT_TCPMUX = @as(u32, 1);
pub const IPPORT_ECHO = @as(u32, 7);
pub const IPPORT_DISCARD = @as(u32, 9);
pub const IPPORT_SYSTAT = @as(u32, 11);
pub const IPPORT_DAYTIME = @as(u32, 13);
pub const IPPORT_NETSTAT = @as(u32, 15);
pub const IPPORT_QOTD = @as(u32, 17);
pub const IPPORT_MSP = @as(u32, 18);
pub const IPPORT_CHARGEN = @as(u32, 19);
pub const IPPORT_FTP_DATA = @as(u32, 20);
pub const IPPORT_FTP = @as(u32, 21);
pub const IPPORT_TELNET = @as(u32, 23);
pub const IPPORT_SMTP = @as(u32, 25);
pub const IPPORT_TIMESERVER = @as(u32, 37);
pub const IPPORT_NAMESERVER = @as(u32, 42);
pub const IPPORT_WHOIS = @as(u32, 43);
pub const IPPORT_MTP = @as(u32, 57);
pub const IPPORT_TFTP = @as(u32, 69);
pub const IPPORT_RJE = @as(u32, 77);
pub const IPPORT_FINGER = @as(u32, 79);
pub const IPPORT_TTYLINK = @as(u32, 87);
pub const IPPORT_SUPDUP = @as(u32, 95);
pub const IPPORT_POP3 = @as(u32, 110);
pub const IPPORT_NTP = @as(u32, 123);
pub const IPPORT_EPMAP = @as(u32, 135);
pub const IPPORT_NETBIOS_NS = @as(u32, 137);
pub const IPPORT_NETBIOS_DGM = @as(u32, 138);
pub const IPPORT_NETBIOS_SSN = @as(u32, 139);
pub const IPPORT_IMAP = @as(u32, 143);
pub const IPPORT_SNMP = @as(u32, 161);
pub const IPPORT_SNMP_TRAP = @as(u32, 162);
pub const IPPORT_IMAP3 = @as(u32, 220);
pub const IPPORT_LDAP = @as(u32, 389);
pub const IPPORT_HTTPS = @as(u32, 443);
pub const IPPORT_MICROSOFT_DS = @as(u32, 445);
pub const IPPORT_EXECSERVER = @as(u32, 512);
pub const IPPORT_LOGINSERVER = @as(u32, 513);
pub const IPPORT_CMDSERVER = @as(u32, 514);
pub const IPPORT_EFSSERVER = @as(u32, 520);
pub const IPPORT_BIFFUDP = @as(u32, 512);
pub const IPPORT_WHOSERVER = @as(u32, 513);
pub const IPPORT_ROUTESERVER = @as(u32, 520);
pub const IPPORT_RESERVED = @as(u32, 1024);
pub const IPPORT_REGISTERED_MIN = @as(u32, 1024);
pub const IPPORT_REGISTERED_MAX = @as(u32, 49151);
pub const IPPORT_DYNAMIC_MIN = @as(u32, 49152);
pub const IPPORT_DYNAMIC_MAX = @as(u32, 65535);
pub const IN_CLASSA_NET = @as(u32, 4278190080);
pub const IN_CLASSA_NSHIFT = @as(u32, 24);
pub const IN_CLASSA_HOST = @as(u32, 16777215);
pub const IN_CLASSA_MAX = @as(u32, 128);
pub const IN_CLASSB_NET = @as(u32, 4294901760);
pub const IN_CLASSB_NSHIFT = @as(u32, 16);
pub const IN_CLASSB_HOST = @as(u32, 65535);
pub const IN_CLASSB_MAX = @as(u32, 65536);
pub const IN_CLASSC_NET = @as(u32, 4294967040);
pub const IN_CLASSC_NSHIFT = @as(u32, 8);
pub const IN_CLASSC_HOST = @as(u32, 255);
pub const IN_CLASSD_NET = @as(u32, 4026531840);
pub const IN_CLASSD_NSHIFT = @as(u32, 28);
pub const IN_CLASSD_HOST = @as(u32, 268435455);
pub const INADDR_LOOPBACK = @as(u32, 2130706433);
pub const INADDR_NONE = @as(u32, 4294967295);
pub const IOCPARM_MASK = @as(u32, 127);
pub const IOC_VOID = @as(u32, 536870912);
pub const IOC_OUT = @as(u32, 1073741824);
pub const IOC_IN = @as(u32, 2147483648);
pub const MSG_TRUNC = @as(u32, 256);
pub const MSG_CTRUNC = @as(u32, 512);
pub const MSG_BCAST = @as(u32, 1024);
pub const MSG_MCAST = @as(u32, 2048);
pub const MSG_ERRQUEUE = @as(u32, 4096);
pub const AI_PASSIVE = @as(u32, 1);
pub const AI_CANONNAME = @as(u32, 2);
pub const AI_NUMERICHOST = @as(u32, 4);
pub const AI_NUMERICSERV = @as(u32, 8);
pub const AI_DNS_ONLY = @as(u32, 16);
pub const AI_FORCE_CLEAR_TEXT = @as(u32, 32);
pub const AI_BYPASS_DNS_CACHE = @as(u32, 64);
pub const AI_RETURN_TTL = @as(u32, 128);
pub const AI_ALL = @as(u32, 256);
pub const AI_ADDRCONFIG = @as(u32, 1024);
pub const AI_V4MAPPED = @as(u32, 2048);
pub const AI_NON_AUTHORITATIVE = @as(u32, 16384);
pub const AI_SECURE = @as(u32, 32768);
pub const AI_RETURN_PREFERRED_NAMES = @as(u32, 65536);
pub const AI_FQDN = @as(u32, 131072);
pub const AI_FILESERVER = @as(u32, 262144);
pub const AI_DISABLE_IDN_ENCODING = @as(u32, 524288);
pub const AI_SECURE_WITH_FALLBACK = @as(u32, 1048576);
pub const AI_EXCLUSIVE_CUSTOM_SERVERS = @as(u32, 2097152);
pub const AI_RETURN_RESPONSE_FLAGS = @as(u32, 268435456);
pub const AI_REQUIRE_SECURE = @as(u32, 536870912);
pub const AI_RESOLUTION_HANDLE = @as(u32, 1073741824);
pub const AI_EXTENDED = @as(u32, 2147483648);
pub const ADDRINFOEX_VERSION_2 = @as(u32, 2);
pub const ADDRINFOEX_VERSION_3 = @as(u32, 3);
pub const ADDRINFOEX_VERSION_4 = @as(u32, 4);
pub const ADDRINFOEX_VERSION_5 = @as(u32, 5);
pub const ADDRINFOEX_VERSION_6 = @as(u32, 6);
pub const AI_DNS_SERVER_TYPE_UDP = @as(u32, 1);
pub const AI_DNS_SERVER_TYPE_DOH = @as(u32, 2);
pub const AI_DNS_SERVER_UDP_FALLBACK = @as(u32, 1);
pub const AI_DNS_RESPONSE_SECURE = @as(u32, 1);
pub const AI_DNS_RESPONSE_HOSTFILE = @as(u32, 2);
pub const NS_ALL = @as(u32, 0);
pub const NS_SAP = @as(u32, 1);
pub const NS_NDS = @as(u32, 2);
pub const NS_PEER_BROWSE = @as(u32, 3);
pub const NS_SLP = @as(u32, 5);
pub const NS_DHCP = @as(u32, 6);
pub const NS_TCPIP_LOCAL = @as(u32, 10);
pub const NS_TCPIP_HOSTS = @as(u32, 11);
pub const NS_DNS = @as(u32, 12);
pub const NS_NETBT = @as(u32, 13);
pub const NS_WINS = @as(u32, 14);
pub const NS_NLA = @as(u32, 15);
pub const NS_NBP = @as(u32, 20);
pub const NS_MS = @as(u32, 30);
pub const NS_STDA = @as(u32, 31);
pub const NS_NTDS = @as(u32, 32);
pub const NS_EMAIL = @as(u32, 37);
pub const NS_X500 = @as(u32, 40);
pub const NS_NIS = @as(u32, 41);
pub const NS_NISPLUS = @as(u32, 42);
pub const NS_WRQ = @as(u32, 50);
pub const NS_NETDES = @as(u32, 60);
pub const NI_NOFQDN = @as(u32, 1);
pub const NI_NUMERICHOST = @as(u32, 2);
pub const NI_NAMEREQD = @as(u32, 4);
pub const NI_NUMERICSERV = @as(u32, 8);
pub const NI_DGRAM = @as(u32, 16);
pub const NI_MAXHOST = @as(u32, 1025);
pub const NI_MAXSERV = @as(u32, 32);
pub const IFF_UP = @as(u32, 1);
pub const IFF_BROADCAST = @as(u32, 2);
pub const IFF_LOOPBACK = @as(u32, 4);
pub const IFF_POINTTOPOINT = @as(u32, 8);
pub const IFF_MULTICAST = @as(u32, 16);
pub const IP_OPTIONS = @as(u32, 1);
pub const IP_HDRINCL = @as(u32, 2);
pub const IP_TOS = @as(u32, 3);
pub const IP_TTL = @as(u32, 4);
pub const IP_MULTICAST_IF = @as(u32, 9);
pub const IP_MULTICAST_TTL = @as(u32, 10);
pub const IP_MULTICAST_LOOP = @as(u32, 11);
pub const IP_ADD_MEMBERSHIP = @as(u32, 12);
pub const IP_DROP_MEMBERSHIP = @as(u32, 13);
pub const IP_DONTFRAGMENT = @as(u32, 14);
pub const IP_ADD_SOURCE_MEMBERSHIP = @as(u32, 15);
pub const IP_DROP_SOURCE_MEMBERSHIP = @as(u32, 16);
pub const IP_BLOCK_SOURCE = @as(u32, 17);
pub const IP_UNBLOCK_SOURCE = @as(u32, 18);
pub const IP_PKTINFO = @as(u32, 19);
pub const IP_HOPLIMIT = @as(u32, 21);
pub const IP_RECVTTL = @as(u32, 21);
pub const IP_RECEIVE_BROADCAST = @as(u32, 22);
pub const IP_RECVIF = @as(u32, 24);
pub const IP_RECVDSTADDR = @as(u32, 25);
pub const IP_IFLIST = @as(u32, 28);
pub const IP_ADD_IFLIST = @as(u32, 29);
pub const IP_DEL_IFLIST = @as(u32, 30);
pub const IP_UNICAST_IF = @as(u32, 31);
pub const IP_RTHDR = @as(u32, 32);
pub const IP_GET_IFLIST = @as(u32, 33);
pub const IP_RECVRTHDR = @as(u32, 38);
pub const IP_TCLASS = @as(u32, 39);
pub const IP_RECVTCLASS = @as(u32, 40);
pub const IP_RECVTOS = @as(u32, 40);
pub const IP_ORIGINAL_ARRIVAL_IF = @as(u32, 47);
pub const IP_ECN = @as(u32, 50);
pub const IP_RECVECN = @as(u32, 50);
pub const IP_PKTINFO_EX = @as(u32, 51);
pub const IP_WFP_REDIRECT_RECORDS = @as(u32, 60);
pub const IP_WFP_REDIRECT_CONTEXT = @as(u32, 70);
pub const IP_MTU_DISCOVER = @as(u32, 71);
pub const IP_MTU = @as(u32, 73);
pub const IP_NRT_INTERFACE = @as(u32, 74);
pub const IP_RECVERR = @as(u32, 75);
pub const IP_USER_MTU = @as(u32, 76);
pub const IP_UNSPECIFIED_TYPE_OF_SERVICE = @as(i32, -1);
pub const IP_UNSPECIFIED_USER_MTU = @as(u32, 4294967295);
pub const IN6ADDR_LINKLOCALPREFIX_LENGTH = @as(u32, 64);
pub const IN6ADDR_MULTICASTPREFIX_LENGTH = @as(u32, 8);
pub const IN6ADDR_SOLICITEDNODEMULTICASTPREFIX_LENGTH = @as(u32, 104);
pub const IN6ADDR_V4MAPPEDPREFIX_LENGTH = @as(u32, 96);
pub const IN6ADDR_6TO4PREFIX_LENGTH = @as(u32, 16);
pub const IN6ADDR_TEREDOPREFIX_LENGTH = @as(u32, 32);
pub const MCAST_JOIN_GROUP = @as(u32, 41);
pub const MCAST_LEAVE_GROUP = @as(u32, 42);
pub const MCAST_BLOCK_SOURCE = @as(u32, 43);
pub const MCAST_UNBLOCK_SOURCE = @as(u32, 44);
pub const MCAST_JOIN_SOURCE_GROUP = @as(u32, 45);
pub const MCAST_LEAVE_SOURCE_GROUP = @as(u32, 46);
pub const IPV6_HOPOPTS = @as(u32, 1);
pub const IPV6_HDRINCL = @as(u32, 2);
pub const IPV6_UNICAST_HOPS = @as(u32, 4);
pub const IPV6_MULTICAST_IF = @as(u32, 9);
pub const IPV6_MULTICAST_HOPS = @as(u32, 10);
pub const IPV6_MULTICAST_LOOP = @as(u32, 11);
pub const IPV6_ADD_MEMBERSHIP = @as(u32, 12);
pub const IPV6_JOIN_GROUP = @as(u32, 12);
pub const IPV6_DROP_MEMBERSHIP = @as(u32, 13);
pub const IPV6_LEAVE_GROUP = @as(u32, 13);
pub const IPV6_DONTFRAG = @as(u32, 14);
pub const IPV6_PKTINFO = @as(u32, 19);
pub const IPV6_HOPLIMIT = @as(u32, 21);
pub const IPV6_PROTECTION_LEVEL = @as(u32, 23);
pub const IPV6_RECVIF = @as(u32, 24);
pub const IPV6_RECVDSTADDR = @as(u32, 25);
pub const IPV6_CHECKSUM = @as(u32, 26);
pub const IPV6_V6ONLY = @as(u32, 27);
pub const IPV6_IFLIST = @as(u32, 28);
pub const IPV6_ADD_IFLIST = @as(u32, 29);
pub const IPV6_DEL_IFLIST = @as(u32, 30);
pub const IPV6_UNICAST_IF = @as(u32, 31);
pub const IPV6_RTHDR = @as(u32, 32);
pub const IPV6_GET_IFLIST = @as(u32, 33);
pub const IPV6_RECVRTHDR = @as(u32, 38);
pub const IPV6_TCLASS = @as(u32, 39);
pub const IPV6_RECVTCLASS = @as(u32, 40);
pub const IPV6_ECN = @as(u32, 50);
pub const IPV6_RECVECN = @as(u32, 50);
pub const IPV6_PKTINFO_EX = @as(u32, 51);
pub const IPV6_WFP_REDIRECT_RECORDS = @as(u32, 60);
pub const IPV6_WFP_REDIRECT_CONTEXT = @as(u32, 70);
pub const IPV6_MTU_DISCOVER = @as(u32, 71);
pub const IPV6_MTU = @as(u32, 72);
pub const IPV6_NRT_INTERFACE = @as(u32, 74);
pub const IPV6_RECVERR = @as(u32, 75);
pub const IPV6_USER_MTU = @as(u32, 76);
pub const IP_UNSPECIFIED_HOP_LIMIT = @as(i32, -1);
pub const IP_PROTECTION_LEVEL = @as(u32, 23);
pub const PROTECTION_LEVEL_UNRESTRICTED = @as(u32, 10);
pub const PROTECTION_LEVEL_EDGERESTRICTED = @as(u32, 20);
pub const PROTECTION_LEVEL_RESTRICTED = @as(u32, 30);
pub const PROTECTION_LEVEL_DEFAULT = @as(u32, 20);
pub const INET_ADDRSTRLEN = @as(u32, 22);
pub const INET6_ADDRSTRLEN = @as(u32, 65);
pub const TCP_OFFLOAD_NO_PREFERENCE = @as(u32, 0);
pub const TCP_OFFLOAD_NOT_PREFERRED = @as(u32, 1);
pub const TCP_OFFLOAD_PREFERRED = @as(u32, 2);
pub const TCP_EXPEDITED_1122 = @as(u32, 2);
pub const TCP_KEEPALIVE = @as(u32, 3);
pub const TCP_MAXSEG = @as(u32, 4);
pub const TCP_MAXRT = @as(u32, 5);
pub const TCP_STDURG = @as(u32, 6);
pub const TCP_NOURG = @as(u32, 7);
pub const TCP_ATMARK = @as(u32, 8);
pub const TCP_NOSYNRETRIES = @as(u32, 9);
pub const TCP_TIMESTAMPS = @as(u32, 10);
pub const TCP_OFFLOAD_PREFERENCE = @as(u32, 11);
pub const TCP_CONGESTION_ALGORITHM = @as(u32, 12);
pub const TCP_DELAY_FIN_ACK = @as(u32, 13);
pub const TCP_MAXRTMS = @as(u32, 14);
pub const TCP_FASTOPEN = @as(u32, 15);
pub const TCP_KEEPCNT = @as(u32, 16);
pub const TCP_KEEPIDLE = @as(u32, 3);
pub const TCP_KEEPINTVL = @as(u32, 17);
pub const TCP_FAIL_CONNECT_ON_ICMP_ERROR = @as(u32, 18);
pub const TCP_ICMP_ERROR_INFO = @as(u32, 19);
pub const UDP_SEND_MSG_SIZE = @as(u32, 2);
pub const UDP_RECV_MAX_COALESCED_SIZE = @as(u32, 3);
pub const UDP_COALESCED_INFO = @as(u32, 3);
pub const WINDOWS_AF_IRDA = @as(u32, 26);
pub const WINDOWS_PF_IRDA = @as(u32, 26);
pub const WCE_AF_IRDA = @as(u32, 22);
pub const WCE_PF_IRDA = @as(u32, 22);
pub const IRDA_PROTO_SOCK_STREAM = @as(u32, 1);
pub const PF_IRDA = @as(u16, 26);
pub const SOL_IRLMP = @as(u32, 255);
pub const IRLMP_ENUMDEVICES = @as(u32, 16);
pub const IRLMP_IAS_SET = @as(u32, 17);
pub const IRLMP_IAS_QUERY = @as(u32, 18);
pub const IRLMP_SEND_PDU_LEN = @as(u32, 19);
pub const IRLMP_EXCLUSIVE_MODE = @as(u32, 20);
pub const IRLMP_IRLPT_MODE = @as(u32, 21);
pub const IRLMP_9WIRE_MODE = @as(u32, 22);
pub const IRLMP_TINYTP_MODE = @as(u32, 23);
pub const IRLMP_PARAMETERS = @as(u32, 24);
pub const IRLMP_DISCOVERY_MODE = @as(u32, 25);
pub const IRLMP_SHARP_MODE = @as(u32, 32);
pub const IAS_ATTRIB_NO_CLASS = @as(u32, 16);
pub const IAS_ATTRIB_NO_ATTRIB = @as(u32, 0);
pub const IAS_ATTRIB_INT = @as(u32, 1);
pub const IAS_ATTRIB_OCTETSEQ = @as(u32, 2);
pub const IAS_ATTRIB_STR = @as(u32, 3);
pub const IAS_MAX_USER_STRING = @as(u32, 256);
pub const IAS_MAX_OCTET_STRING = @as(u32, 1024);
pub const IAS_MAX_CLASSNAME = @as(u32, 64);
pub const IAS_MAX_ATTRIBNAME = @as(u32, 256);
pub const LmCharSetASCII = @as(u32, 0);
pub const LmCharSetISO_8859_1 = @as(u32, 1);
pub const LmCharSetISO_8859_2 = @as(u32, 2);
pub const LmCharSetISO_8859_3 = @as(u32, 3);
pub const LmCharSetISO_8859_4 = @as(u32, 4);
pub const LmCharSetISO_8859_5 = @as(u32, 5);
pub const LmCharSetISO_8859_6 = @as(u32, 6);
pub const LmCharSetISO_8859_7 = @as(u32, 7);
pub const LmCharSetISO_8859_8 = @as(u32, 8);
pub const LmCharSetISO_8859_9 = @as(u32, 9);
pub const LmCharSetUNICODE = @as(u32, 255);
pub const LM_BAUD_1200 = @as(u32, 1200);
pub const LM_BAUD_2400 = @as(u32, 2400);
pub const LM_BAUD_9600 = @as(u32, 9600);
pub const LM_BAUD_19200 = @as(u32, 19200);
pub const LM_BAUD_38400 = @as(u32, 38400);
pub const LM_BAUD_57600 = @as(u32, 57600);
pub const LM_BAUD_115200 = @as(u32, 115200);
pub const LM_BAUD_576K = @as(u32, 576000);
pub const LM_BAUD_1152K = @as(u32, 1152000);
pub const LM_BAUD_4M = @as(u32, 4000000);
pub const LM_BAUD_16M = @as(u32, 16000000);
pub const SO_CONNDATA = @as(u32, 28672);
pub const SO_CONNOPT = @as(u32, 28673);
pub const SO_DISCDATA = @as(u32, 28674);
pub const SO_DISCOPT = @as(u32, 28675);
pub const SO_CONNDATALEN = @as(u32, 28676);
pub const SO_CONNOPTLEN = @as(u32, 28677);
pub const SO_DISCDATALEN = @as(u32, 28678);
pub const SO_DISCOPTLEN = @as(u32, 28679);
pub const SO_OPENTYPE = @as(u32, 28680);
pub const SO_SYNCHRONOUS_ALERT = @as(u32, 16);
pub const SO_SYNCHRONOUS_NONALERT = @as(u32, 32);
pub const SO_MAXDG = @as(u32, 28681);
pub const SO_MAXPATHDG = @as(u32, 28682);
pub const SO_UPDATE_ACCEPT_CONTEXT = @as(u32, 28683);
pub const SO_CONNECT_TIME = @as(u32, 28684);
pub const SO_UPDATE_CONNECT_CONTEXT = @as(u32, 28688);
pub const TCP_BSDURGENT = @as(u32, 28672);
pub const SIO_UDP_CONNRESET = @as(u32, 2550136844);
pub const SIO_SOCKET_CLOSE_NOTIFY = @as(u32, 2550136845);
pub const SIO_UDP_NETRESET = @as(u32, 2550136847);
pub const TF_DISCONNECT = @as(u32, 1);
pub const TF_REUSE_SOCKET = @as(u32, 2);
pub const TF_WRITE_BEHIND = @as(u32, 4);
pub const TF_USE_DEFAULT_WORKER = @as(u32, 0);
pub const TF_USE_SYSTEM_THREAD = @as(u32, 16);
pub const TF_USE_KERNEL_APC = @as(u32, 32);
pub const TP_ELEMENT_MEMORY = @as(u32, 1);
pub const TP_ELEMENT_FILE = @as(u32, 2);
pub const TP_ELEMENT_EOP = @as(u32, 4);
pub const TP_DISCONNECT = @as(u32, 1);
pub const TP_REUSE_SOCKET = @as(u32, 2);
pub const TP_USE_DEFAULT_WORKER = @as(u32, 0);
pub const TP_USE_SYSTEM_THREAD = @as(u32, 16);
pub const TP_USE_KERNEL_APC = @as(u32, 32);
pub const DE_REUSE_SOCKET = @as(u32, 2);
pub const NLA_ALLUSERS_NETWORK = @as(u32, 1);
pub const NLA_FRIENDLY_NAME = @as(u32, 2);
pub const SIO_BSP_HANDLE = @as(u32, 1207959579);
pub const SIO_BSP_HANDLE_SELECT = @as(u32, 1207959580);
pub const SIO_BSP_HANDLE_POLL = @as(u32, 1207959581);
pub const SIO_BASE_HANDLE = @as(u32, 1207959586);
pub const SIO_EXT_SELECT = @as(u32, 3355443230);
pub const SIO_EXT_POLL = @as(u32, 3355443231);
pub const SIO_EXT_SENDMSG = @as(u32, 3355443232);
pub const SERVICE_RESOURCE = @as(u32, 1);
pub const SERVICE_SERVICE = @as(u32, 2);
pub const SERVICE_LOCAL = @as(u32, 4);
pub const SERVICE_FLAG_DEFER = @as(u32, 1);
pub const SERVICE_FLAG_HARD = @as(u32, 2);
pub const PROP_COMMENT = @as(u32, 1);
pub const PROP_LOCALE = @as(u32, 2);
pub const PROP_DISPLAY_HINT = @as(u32, 4);
pub const PROP_VERSION = @as(u32, 8);
pub const PROP_START_TIME = @as(u32, 16);
pub const PROP_MACHINE = @as(u32, 32);
pub const PROP_ADDRESSES = @as(u32, 256);
pub const PROP_SD = @as(u32, 512);
pub const PROP_ALL = @as(u32, 2147483648);
pub const SERVICE_ADDRESS_FLAG_RPC_CN = @as(u32, 1);
pub const SERVICE_ADDRESS_FLAG_RPC_DG = @as(u32, 2);
pub const SERVICE_ADDRESS_FLAG_RPC_NB = @as(u32, 4);
pub const NS_DEFAULT = @as(u32, 0);
pub const NS_VNS = @as(u32, 50);
pub const NSTYPE_HIERARCHICAL = @as(u32, 1);
pub const NSTYPE_DYNAMIC = @as(u32, 2);
pub const NSTYPE_ENUMERABLE = @as(u32, 4);
pub const NSTYPE_WORKGROUP = @as(u32, 8);
pub const XP_CONNECTIONLESS = @as(u32, 1);
pub const XP_GUARANTEED_DELIVERY = @as(u32, 2);
pub const XP_GUARANTEED_ORDER = @as(u32, 4);
pub const XP_MESSAGE_ORIENTED = @as(u32, 8);
pub const XP_PSEUDO_STREAM = @as(u32, 16);
pub const XP_GRACEFUL_CLOSE = @as(u32, 32);
pub const XP_EXPEDITED_DATA = @as(u32, 64);
pub const XP_CONNECT_DATA = @as(u32, 128);
pub const XP_DISCONNECT_DATA = @as(u32, 256);
pub const XP_SUPPORTS_BROADCAST = @as(u32, 512);
pub const XP_SUPPORTS_MULTICAST = @as(u32, 1024);
pub const XP_BANDWIDTH_ALLOCATION = @as(u32, 2048);
pub const XP_FRAGMENTATION = @as(u32, 4096);
pub const XP_ENCRYPTS = @as(u32, 8192);
pub const RES_SOFT_SEARCH = @as(u32, 1);
pub const RES_FIND_MULTIPLE = @as(u32, 2);
pub const RES_SERVICE = @as(u32, 4);
pub const SERVICE_TYPE_VALUE_SAPIDA = "SapId";
pub const SERVICE_TYPE_VALUE_SAPIDW = "SapId";
pub const SERVICE_TYPE_VALUE_CONNA = "ConnectionOriented";
pub const SERVICE_TYPE_VALUE_CONNW = "ConnectionOriented";
pub const SERVICE_TYPE_VALUE_TCPPORTA = "TcpPort";
pub const SERVICE_TYPE_VALUE_TCPPORTW = "TcpPort";
pub const SERVICE_TYPE_VALUE_UDPPORTA = "UdpPort";
pub const SERVICE_TYPE_VALUE_UDPPORTW = "UdpPort";
pub const SERVICE_TYPE_VALUE_SAPID = "SapId";
pub const SERVICE_TYPE_VALUE_CONN = "ConnectionOriented";
pub const SERVICE_TYPE_VALUE_TCPPORT = "TcpPort";
pub const SERVICE_TYPE_VALUE_UDPPORT = "UdpPort";
pub const SET_SERVICE_PARTIAL_SUCCESS = @as(u32, 1);
pub const FD_SETSIZE = @as(u32, 64);
pub const IMPLINK_IP = @as(u32, 155);
pub const IMPLINK_LOWEXPER = @as(u32, 156);
pub const IMPLINK_HIGHEXPER = @as(u32, 158);
pub const WSADESCRIPTION_LEN = @as(u32, 256);
pub const WSASYS_STATUS_LEN = @as(u32, 128);
pub const IP_DEFAULT_MULTICAST_TTL = @as(u32, 1);
pub const IP_DEFAULT_MULTICAST_LOOP = @as(u32, 1);
pub const IP_MAX_MEMBERSHIPS = @as(u32, 20);
pub const SOCKET_ERROR = @as(i32, -1);
pub const PF_UNIX = @as(u16, 1);
pub const PF_IMPLINK = @as(u16, 3);
pub const PF_PUP = @as(u16, 4);
pub const PF_CHAOS = @as(u16, 5);
pub const PF_NS = @as(u16, 6);
pub const PF_IPX = @as(u16, 6);
pub const PF_ISO = @as(u16, 7);
pub const PF_OSI = @as(u16, 7);
pub const PF_ECMA = @as(u16, 8);
pub const PF_DATAKIT = @as(u16, 9);
pub const PF_CCITT = @as(u16, 10);
pub const PF_SNA = @as(u16, 11);
pub const PF_DECnet = @as(u16, 12);
pub const PF_DLI = @as(u16, 13);
pub const PF_LAT = @as(u16, 14);
pub const PF_HYLINK = @as(u16, 15);
pub const PF_APPLETALK = @as(u16, 16);
pub const PF_VOICEVIEW = @as(u16, 18);
pub const PF_FIREFOX = @as(u16, 19);
pub const PF_UNKNOWN1 = @as(u16, 20);
pub const PF_BAN = @as(u16, 21);
pub const PF_MAX = @as(u16, 29);
pub const SOMAXCONN = @as(u32, 5);
pub const MSG_MAXIOVLEN = @as(u32, 16);
pub const MSG_PARTIAL = @as(u32, 32768);
pub const MAXGETHOSTSTRUCT = @as(u32, 1024);
pub const FD_READ = @as(u32, 1);
pub const FD_WRITE = @as(u32, 2);
pub const FD_OOB = @as(u32, 4);
pub const FD_ACCEPT = @as(u32, 8);
pub const FD_CONNECT = @as(u32, 16);
pub const FD_CLOSE = @as(u32, 32);
pub const INCL_WINSOCK_API_PROTOTYPES = @as(u32, 1);
pub const INCL_WINSOCK_API_TYPEDEFS = @as(u32, 0);
pub const FROM_PROTOCOL_INFO = @as(i32, -1);
pub const SO_PROTOCOL_INFOA = @as(u32, 8196);
pub const SO_PROTOCOL_INFOW = @as(u32, 8197);
pub const SO_PROTOCOL_INFO = @as(u32, 8197);
pub const PVD_CONFIG = @as(u32, 12289);
pub const PF_ATM = @as(u16, 22);
pub const MSG_INTERRUPT = @as(u32, 16);
pub const FD_READ_BIT = @as(u32, 0);
pub const FD_WRITE_BIT = @as(u32, 1);
pub const FD_OOB_BIT = @as(u32, 2);
pub const FD_ACCEPT_BIT = @as(u32, 3);
pub const FD_CONNECT_BIT = @as(u32, 4);
pub const FD_CLOSE_BIT = @as(u32, 5);
pub const FD_QOS_BIT = @as(u32, 6);
pub const FD_GROUP_QOS_BIT = @as(u32, 7);
pub const FD_ROUTING_INTERFACE_CHANGE_BIT = @as(u32, 8);
pub const FD_ADDRESS_LIST_CHANGE_BIT = @as(u32, 9);
pub const FD_MAX_EVENTS = @as(u32, 10);
pub const WSA_MAXIMUM_WAIT_EVENTS = @as(u32, 64);
pub const WSA_WAIT_FAILED = @as(u32, 4294967295);
pub const CF_ACCEPT = @as(u32, 0);
pub const CF_REJECT = @as(u32, 1);
pub const CF_DEFER = @as(u32, 2);
pub const SD_RECEIVE = @as(u32, 0);
pub const SD_SEND = @as(u32, 1);
pub const SD_BOTH = @as(u32, 2);
pub const SG_UNCONSTRAINED_GROUP = @as(u32, 1);
pub const SG_CONSTRAINED_GROUP = @as(u32, 2);
pub const MAX_PROTOCOL_CHAIN = @as(u32, 7);
pub const BASE_PROTOCOL = @as(u32, 1);
pub const LAYERED_PROTOCOL = @as(u32, 0);
pub const WSAPROTOCOL_LEN = @as(u32, 255);
pub const PFL_MULTIPLE_PROTO_ENTRIES = @as(u32, 1);
pub const PFL_RECOMMENDED_PROTO_ENTRY = @as(u32, 2);
pub const PFL_HIDDEN = @as(u32, 4);
pub const PFL_MATCHES_PROTOCOL_ZERO = @as(u32, 8);
pub const PFL_NETWORKDIRECT_PROVIDER = @as(u32, 16);
pub const XP1_CONNECTIONLESS = @as(u32, 1);
pub const XP1_GUARANTEED_DELIVERY = @as(u32, 2);
pub const XP1_GUARANTEED_ORDER = @as(u32, 4);
pub const XP1_MESSAGE_ORIENTED = @as(u32, 8);
pub const XP1_PSEUDO_STREAM = @as(u32, 16);
pub const XP1_GRACEFUL_CLOSE = @as(u32, 32);
pub const XP1_EXPEDITED_DATA = @as(u32, 64);
pub const XP1_CONNECT_DATA = @as(u32, 128);
pub const XP1_DISCONNECT_DATA = @as(u32, 256);
pub const XP1_SUPPORT_BROADCAST = @as(u32, 512);
pub const XP1_SUPPORT_MULTIPOINT = @as(u32, 1024);
pub const XP1_MULTIPOINT_CONTROL_PLANE = @as(u32, 2048);
pub const XP1_MULTIPOINT_DATA_PLANE = @as(u32, 4096);
pub const XP1_QOS_SUPPORTED = @as(u32, 8192);
pub const XP1_INTERRUPT = @as(u32, 16384);
pub const XP1_UNI_SEND = @as(u32, 32768);
pub const XP1_UNI_RECV = @as(u32, 65536);
pub const XP1_IFS_HANDLES = @as(u32, 131072);
pub const XP1_PARTIAL_MESSAGE = @as(u32, 262144);
pub const XP1_SAN_SUPPORT_SDP = @as(u32, 524288);
pub const BIGENDIAN = @as(u32, 0);
pub const LITTLEENDIAN = @as(u32, 1);
pub const SECURITY_PROTOCOL_NONE = @as(u32, 0);
pub const JL_SENDER_ONLY = @as(u32, 1);
pub const JL_RECEIVER_ONLY = @as(u32, 2);
pub const JL_BOTH = @as(u32, 4);
pub const WSA_FLAG_OVERLAPPED = @as(u32, 1);
pub const WSA_FLAG_MULTIPOINT_C_ROOT = @as(u32, 2);
pub const WSA_FLAG_MULTIPOINT_C_LEAF = @as(u32, 4);
pub const WSA_FLAG_MULTIPOINT_D_ROOT = @as(u32, 8);
pub const WSA_FLAG_MULTIPOINT_D_LEAF = @as(u32, 16);
pub const WSA_FLAG_ACCESS_SYSTEM_SECURITY = @as(u32, 64);
pub const WSA_FLAG_NO_HANDLE_INHERIT = @as(u32, 128);
pub const WSA_FLAG_REGISTERED_IO = @as(u32, 256);
pub const SIO_NSP_NOTIFY_CHANGE = @as(u32, 2281701401);
pub const TH_NETDEV = @as(u32, 1);
pub const TH_TAPI = @as(u32, 2);
pub const SERVICE_MULTIPLE = @as(u32, 1);
pub const NS_LOCALNAME = @as(u32, 19);
pub const RES_UNUSED_1 = @as(u32, 1);
pub const RES_FLUSH_CACHE = @as(u32, 2);
pub const SERVICE_TYPE_VALUE_IPXPORTA = "IpxSocket";
pub const SERVICE_TYPE_VALUE_IPXPORTW = "IpxSocket";
pub const SERVICE_TYPE_VALUE_OBJECTIDA = "ObjectId";
pub const SERVICE_TYPE_VALUE_OBJECTIDW = "ObjectId";
pub const SERVICE_TYPE_VALUE_OBJECTID = "ObjectId";
pub const LUP_DEEP = @as(u32, 1);
pub const LUP_CONTAINERS = @as(u32, 2);
pub const LUP_NOCONTAINERS = @as(u32, 4);
pub const LUP_NEAREST = @as(u32, 8);
pub const LUP_RETURN_NAME = @as(u32, 16);
pub const LUP_RETURN_TYPE = @as(u32, 32);
pub const LUP_RETURN_VERSION = @as(u32, 64);
pub const LUP_RETURN_COMMENT = @as(u32, 128);
pub const LUP_RETURN_ADDR = @as(u32, 256);
pub const LUP_RETURN_BLOB = @as(u32, 512);
pub const LUP_RETURN_ALIASES = @as(u32, 1024);
pub const LUP_RETURN_QUERY_STRING = @as(u32, 2048);
pub const LUP_RETURN_ALL = @as(u32, 4080);
pub const LUP_RES_SERVICE = @as(u32, 32768);
pub const LUP_FLUSHCACHE = @as(u32, 4096);
pub const LUP_FLUSHPREVIOUS = @as(u32, 8192);
pub const LUP_NON_AUTHORITATIVE = @as(u32, 16384);
pub const LUP_SECURE = @as(u32, 32768);
pub const LUP_RETURN_PREFERRED_NAMES = @as(u32, 65536);
pub const LUP_DNS_ONLY = @as(u32, 131072);
pub const LUP_RETURN_RESPONSE_FLAGS = @as(u32, 262144);
pub const LUP_ADDRCONFIG = @as(u32, 1048576);
pub const LUP_DUAL_ADDR = @as(u32, 2097152);
pub const LUP_FILESERVER = @as(u32, 4194304);
pub const LUP_DISABLE_IDN_ENCODING = @as(u32, 8388608);
pub const LUP_API_ANSI = @as(u32, 16777216);
pub const LUP_EXTENDED_QUERYSET = @as(u32, 33554432);
pub const LUP_SECURE_WITH_FALLBACK = @as(u32, 67108864);
pub const LUP_EXCLUSIVE_CUSTOM_SERVERS = @as(u32, 134217728);
pub const LUP_REQUIRE_SECURE = @as(u32, 268435456);
pub const LUP_RETURN_TTL = @as(u32, 536870912);
pub const LUP_FORCE_CLEAR_TEXT = @as(u32, 1073741824);
pub const LUP_RESOLUTION_HANDLE = @as(u32, 2147483648);
pub const RESULT_IS_ALIAS = @as(u32, 1);
pub const RESULT_IS_ADDED = @as(u32, 16);
pub const RESULT_IS_CHANGED = @as(u32, 32);
pub const RESULT_IS_DELETED = @as(u32, 64);
pub const POLLRDNORM = @as(u16, 256);
pub const POLLRDBAND = @as(u16, 512);
pub const POLLPRI = @as(u16, 1024);
pub const POLLWRNORM = @as(u16, 16);
pub const POLLOUT = @as(u16, 16);
pub const POLLWRBAND = @as(u16, 32);
pub const POLLERR = @as(u16, 1);
pub const POLLHUP = @as(u16, 2);
pub const POLLNVAL = @as(u16, 4);
pub const SOCK_NOTIFY_REGISTER_EVENT_NONE = @as(u32, 0);
pub const SOCK_NOTIFY_REGISTER_EVENT_IN = @as(u32, 1);
pub const SOCK_NOTIFY_REGISTER_EVENT_OUT = @as(u32, 2);
pub const SOCK_NOTIFY_REGISTER_EVENT_HANGUP = @as(u32, 4);
pub const SOCK_NOTIFY_EVENT_IN = @as(u32, 1);
pub const SOCK_NOTIFY_EVENT_OUT = @as(u32, 2);
pub const SOCK_NOTIFY_EVENT_HANGUP = @as(u32, 4);
pub const SOCK_NOTIFY_EVENT_ERR = @as(u32, 64);
pub const SOCK_NOTIFY_EVENT_REMOVE = @as(u32, 128);
pub const SOCK_NOTIFY_OP_NONE = @as(u32, 0);
pub const SOCK_NOTIFY_OP_ENABLE = @as(u32, 1);
pub const SOCK_NOTIFY_OP_DISABLE = @as(u32, 2);
pub const SOCK_NOTIFY_OP_REMOVE = @as(u32, 4);
pub const SOCK_NOTIFY_TRIGGER_ONESHOT = @as(u32, 1);
pub const SOCK_NOTIFY_TRIGGER_PERSISTENT = @as(u32, 2);
pub const SOCK_NOTIFY_TRIGGER_LEVEL = @as(u32, 4);
pub const SOCK_NOTIFY_TRIGGER_EDGE = @as(u32, 8);
pub const ATMPROTO_AALUSER = @as(u32, 0);
pub const ATMPROTO_AAL1 = @as(u32, 1);
pub const ATMPROTO_AAL2 = @as(u32, 2);
pub const ATMPROTO_AAL34 = @as(u32, 3);
pub const ATMPROTO_AAL5 = @as(u32, 5);
pub const SAP_FIELD_ABSENT = @as(u32, 4294967294);
pub const SAP_FIELD_ANY = @as(u32, 4294967295);
pub const SAP_FIELD_ANY_AESA_SEL = @as(u32, 4294967290);
pub const SAP_FIELD_ANY_AESA_REST = @as(u32, 4294967291);
pub const ATM_E164 = @as(u32, 1);
pub const ATM_NSAP = @as(u32, 2);
pub const ATM_AESA = @as(u32, 2);
pub const ATM_ADDR_SIZE = @as(u32, 20);
pub const BLLI_L2_ISO_1745 = @as(u32, 1);
pub const BLLI_L2_Q921 = @as(u32, 2);
pub const BLLI_L2_X25L = @as(u32, 6);
pub const BLLI_L2_X25M = @as(u32, 7);
pub const BLLI_L2_ELAPB = @as(u32, 8);
pub const BLLI_L2_HDLC_ARM = @as(u32, 9);
pub const BLLI_L2_HDLC_NRM = @as(u32, 10);
pub const BLLI_L2_HDLC_ABM = @as(u32, 11);
pub const BLLI_L2_LLC = @as(u32, 12);
pub const BLLI_L2_X75 = @as(u32, 13);
pub const BLLI_L2_Q922 = @as(u32, 14);
pub const BLLI_L2_USER_SPECIFIED = @as(u32, 16);
pub const BLLI_L2_ISO_7776 = @as(u32, 17);
pub const BLLI_L3_X25 = @as(u32, 6);
pub const BLLI_L3_ISO_8208 = @as(u32, 7);
pub const BLLI_L3_X223 = @as(u32, 8);
pub const BLLI_L3_SIO_8473 = @as(u32, 9);
pub const BLLI_L3_T70 = @as(u32, 10);
pub const BLLI_L3_ISO_TR9577 = @as(u32, 11);
pub const BLLI_L3_USER_SPECIFIED = @as(u32, 16);
pub const BLLI_L3_IPI_SNAP = @as(u32, 128);
pub const BLLI_L3_IPI_IP = @as(u32, 204);
pub const BHLI_ISO = @as(u32, 0);
pub const BHLI_UserSpecific = @as(u32, 1);
pub const BHLI_HighLayerProfile = @as(u32, 2);
pub const BHLI_VendorSpecificAppId = @as(u32, 3);
pub const AAL5_MODE_MESSAGE = @as(u32, 1);
pub const AAL5_MODE_STREAMING = @as(u32, 2);
pub const AAL5_SSCS_NULL = @as(u32, 0);
pub const AAL5_SSCS_SSCOP_ASSURED = @as(u32, 1);
pub const AAL5_SSCS_SSCOP_NON_ASSURED = @as(u32, 2);
pub const AAL5_SSCS_FRAME_RELAY = @as(u32, 4);
pub const BCOB_A = @as(u32, 1);
pub const BCOB_C = @as(u32, 3);
pub const BCOB_X = @as(u32, 16);
pub const TT_NOIND = @as(u32, 0);
pub const TT_CBR = @as(u32, 4);
pub const TT_VBR = @as(u32, 8);
pub const TR_NOIND = @as(u32, 0);
pub const TR_END_TO_END = @as(u32, 1);
pub const TR_NO_END_TO_END = @as(u32, 2);
pub const CLIP_NOT = @as(u32, 0);
pub const CLIP_SUS = @as(u32, 32);
pub const UP_P2P = @as(u32, 0);
pub const UP_P2MP = @as(u32, 1);
pub const BLLI_L2_MODE_NORMAL = @as(u32, 64);
pub const BLLI_L2_MODE_EXT = @as(u32, 128);
pub const BLLI_L3_MODE_NORMAL = @as(u32, 64);
pub const BLLI_L3_MODE_EXT = @as(u32, 128);
pub const BLLI_L3_PACKET_16 = @as(u32, 4);
pub const BLLI_L3_PACKET_32 = @as(u32, 5);
pub const BLLI_L3_PACKET_64 = @as(u32, 6);
pub const BLLI_L3_PACKET_128 = @as(u32, 7);
pub const BLLI_L3_PACKET_256 = @as(u32, 8);
pub const BLLI_L3_PACKET_512 = @as(u32, 9);
pub const BLLI_L3_PACKET_1024 = @as(u32, 10);
pub const BLLI_L3_PACKET_2048 = @as(u32, 11);
pub const BLLI_L3_PACKET_4096 = @as(u32, 12);
pub const PI_ALLOWED = @as(u32, 0);
pub const PI_RESTRICTED = @as(u32, 64);
pub const PI_NUMBER_NOT_AVAILABLE = @as(u32, 128);
pub const SI_USER_NOT_SCREENED = @as(u32, 0);
pub const SI_USER_PASSED = @as(u32, 1);
pub const SI_USER_FAILED = @as(u32, 2);
pub const SI_NETWORK = @as(u32, 3);
pub const CAUSE_LOC_USER = @as(u32, 0);
pub const CAUSE_LOC_PRIVATE_LOCAL = @as(u32, 1);
pub const CAUSE_LOC_PUBLIC_LOCAL = @as(u32, 2);
pub const CAUSE_LOC_TRANSIT_NETWORK = @as(u32, 3);
pub const CAUSE_LOC_PUBLIC_REMOTE = @as(u32, 4);
pub const CAUSE_LOC_PRIVATE_REMOTE = @as(u32, 5);
pub const CAUSE_LOC_INTERNATIONAL_NETWORK = @as(u32, 7);
pub const CAUSE_LOC_BEYOND_INTERWORKING = @as(u32, 10);
pub const CAUSE_UNALLOCATED_NUMBER = @as(u32, 1);
pub const CAUSE_NO_ROUTE_TO_TRANSIT_NETWORK = @as(u32, 2);
pub const CAUSE_NO_ROUTE_TO_DESTINATION = @as(u32, 3);
pub const CAUSE_VPI_VCI_UNACCEPTABLE = @as(u32, 10);
pub const CAUSE_NORMAL_CALL_CLEARING = @as(u32, 16);
pub const CAUSE_USER_BUSY = @as(u32, 17);
pub const CAUSE_NO_USER_RESPONDING = @as(u32, 18);
pub const CAUSE_CALL_REJECTED = @as(u32, 21);
pub const CAUSE_NUMBER_CHANGED = @as(u32, 22);
pub const CAUSE_USER_REJECTS_CLIR = @as(u32, 23);
pub const CAUSE_DESTINATION_OUT_OF_ORDER = @as(u32, 27);
pub const CAUSE_INVALID_NUMBER_FORMAT = @as(u32, 28);
pub const CAUSE_STATUS_ENQUIRY_RESPONSE = @as(u32, 30);
pub const CAUSE_NORMAL_UNSPECIFIED = @as(u32, 31);
pub const CAUSE_VPI_VCI_UNAVAILABLE = @as(u32, 35);
pub const CAUSE_NETWORK_OUT_OF_ORDER = @as(u32, 38);
pub const CAUSE_TEMPORARY_FAILURE = @as(u32, 41);
pub const CAUSE_ACCESS_INFORMAION_DISCARDED = @as(u32, 43);
pub const CAUSE_NO_VPI_VCI_AVAILABLE = @as(u32, 45);
pub const CAUSE_RESOURCE_UNAVAILABLE = @as(u32, 47);
pub const CAUSE_QOS_UNAVAILABLE = @as(u32, 49);
pub const CAUSE_USER_CELL_RATE_UNAVAILABLE = @as(u32, 51);
pub const CAUSE_BEARER_CAPABILITY_UNAUTHORIZED = @as(u32, 57);
pub const CAUSE_BEARER_CAPABILITY_UNAVAILABLE = @as(u32, 58);
pub const CAUSE_OPTION_UNAVAILABLE = @as(u32, 63);
pub const CAUSE_BEARER_CAPABILITY_UNIMPLEMENTED = @as(u32, 65);
pub const CAUSE_UNSUPPORTED_TRAFFIC_PARAMETERS = @as(u32, 73);
pub const CAUSE_INVALID_CALL_REFERENCE = @as(u32, 81);
pub const CAUSE_CHANNEL_NONEXISTENT = @as(u32, 82);
pub const CAUSE_INCOMPATIBLE_DESTINATION = @as(u32, 88);
pub const CAUSE_INVALID_ENDPOINT_REFERENCE = @as(u32, 89);
pub const CAUSE_INVALID_TRANSIT_NETWORK_SELECTION = @as(u32, 91);
pub const CAUSE_TOO_MANY_PENDING_ADD_PARTY = @as(u32, 92);
pub const CAUSE_AAL_PARAMETERS_UNSUPPORTED = @as(u32, 93);
pub const CAUSE_MANDATORY_IE_MISSING = @as(u32, 96);
pub const CAUSE_UNIMPLEMENTED_MESSAGE_TYPE = @as(u32, 97);
pub const CAUSE_UNIMPLEMENTED_IE = @as(u32, 99);
pub const CAUSE_INVALID_IE_CONTENTS = @as(u32, 100);
pub const CAUSE_INVALID_STATE_FOR_MESSAGE = @as(u32, 101);
pub const CAUSE_RECOVERY_ON_TIMEOUT = @as(u32, 102);
pub const CAUSE_INCORRECT_MESSAGE_LENGTH = @as(u32, 104);
pub const CAUSE_PROTOCOL_ERROR = @as(u32, 111);
pub const CAUSE_COND_UNKNOWN = @as(u32, 0);
pub const CAUSE_COND_PERMANENT = @as(u32, 1);
pub const CAUSE_COND_TRANSIENT = @as(u32, 2);
pub const CAUSE_REASON_USER = @as(u32, 0);
pub const CAUSE_REASON_IE_MISSING = @as(u32, 4);
pub const CAUSE_REASON_IE_INSUFFICIENT = @as(u32, 8);
pub const CAUSE_PU_PROVIDER = @as(u32, 0);
pub const CAUSE_PU_USER = @as(u32, 8);
pub const CAUSE_NA_NORMAL = @as(u32, 0);
pub const CAUSE_NA_ABNORMAL = @as(u32, 4);
pub const QOS_CLASS0 = @as(u32, 0);
pub const QOS_CLASS1 = @as(u32, 1);
pub const QOS_CLASS2 = @as(u32, 2);
pub const QOS_CLASS3 = @as(u32, 3);
pub const QOS_CLASS4 = @as(u32, 4);
pub const TNS_TYPE_NATIONAL = @as(u32, 64);
pub const TNS_PLAN_CARRIER_ID_CODE = @as(u32, 1);
pub const SIO_GET_NUMBER_OF_ATM_DEVICES = @as(u32, 1343619073);
pub const SIO_GET_ATM_ADDRESS = @as(u32, 3491102722);
pub const SIO_ASSOCIATE_PVC = @as(u32, 2417360899);
pub const SIO_GET_ATM_CONNECTION_ID = @as(u32, 1343619076);
pub const WSPDESCRIPTION_LEN = @as(u32, 255);
pub const WSS_OPERATION_IN_PROGRESS = @as(i32, 259);
pub const LSP_SYSTEM = @as(u32, 2147483648);
pub const LSP_INSPECTOR = @as(u32, 1);
pub const LSP_REDIRECTOR = @as(u32, 2);
pub const LSP_PROXY = @as(u32, 4);
pub const LSP_FIREWALL = @as(u32, 8);
pub const LSP_INBOUND_MODIFY = @as(u32, 16);
pub const LSP_OUTBOUND_MODIFY = @as(u32, 32);
pub const LSP_CRYPTO_COMPRESS = @as(u32, 64);
pub const LSP_LOCAL_CACHE = @as(u32, 128);
pub const UDP_NOCHECKSUM = @as(u32, 1);
pub const UDP_CHECKSUM_COVERAGE = @as(u32, 20);
pub const GAI_STRERROR_BUFFER_SIZE = @as(u32, 1024);
pub const IPX_PTYPE = @as(u32, 16384);
pub const IPX_FILTERPTYPE = @as(u32, 16385);
pub const IPX_STOPFILTERPTYPE = @as(u32, 16387);
pub const IPX_DSTYPE = @as(u32, 16386);
pub const IPX_EXTENDED_ADDRESS = @as(u32, 16388);
pub const IPX_RECVHDR = @as(u32, 16389);
pub const IPX_MAXSIZE = @as(u32, 16390);
pub const IPX_ADDRESS = @as(u32, 16391);
pub const IPX_GETNETINFO = @as(u32, 16392);
pub const IPX_GETNETINFO_NORIP = @as(u32, 16393);
pub const IPX_SPXGETCONNECTIONSTATUS = @as(u32, 16395);
pub const IPX_ADDRESS_NOTIFY = @as(u32, 16396);
pub const IPX_MAX_ADAPTER_NUM = @as(u32, 16397);
pub const IPX_RERIPNETNUMBER = @as(u32, 16398);
pub const IPX_RECEIVE_BROADCAST = @as(u32, 16399);
pub const IPX_IMMEDIATESPXACK = @as(u32, 16400);
pub const IPPROTO_RM = @as(u32, 113);
pub const MAX_MCAST_TTL = @as(u32, 255);
pub const RM_OPTIONSBASE = @as(u32, 1000);
pub const RM_RATE_WINDOW_SIZE = @as(u32, 1001);
pub const RM_SET_MESSAGE_BOUNDARY = @as(u32, 1002);
pub const RM_FLUSHCACHE = @as(u32, 1003);
pub const RM_SENDER_WINDOW_ADVANCE_METHOD = @as(u32, 1004);
pub const RM_SENDER_STATISTICS = @as(u32, 1005);
pub const RM_LATEJOIN = @as(u32, 1006);
pub const RM_SET_SEND_IF = @as(u32, 1007);
pub const RM_ADD_RECEIVE_IF = @as(u32, 1008);
pub const RM_DEL_RECEIVE_IF = @as(u32, 1009);
pub const RM_SEND_WINDOW_ADV_RATE = @as(u32, 1010);
pub const RM_USE_FEC = @as(u32, 1011);
pub const RM_SET_MCAST_TTL = @as(u32, 1012);
pub const RM_RECEIVER_STATISTICS = @as(u32, 1013);
pub const RM_HIGH_SPEED_INTRANET_OPT = @as(u32, 1014);
pub const SENDER_DEFAULT_RATE_KBITS_PER_SEC = @as(u32, 56);
pub const SENDER_DEFAULT_WINDOW_ADV_PERCENTAGE = @as(u32, 15);
pub const MAX_WINDOW_INCREMENT_PERCENTAGE = @as(u32, 25);
pub const SENDER_DEFAULT_LATE_JOINER_PERCENTAGE = @as(u32, 0);
pub const SENDER_MAX_LATE_JOINER_PERCENTAGE = @as(u32, 75);
pub const BITS_PER_BYTE = @as(u32, 8);
pub const LOG2_BITS_PER_BYTE = @as(u32, 3);
pub const UNIX_PATH_MAX = @as(u32, 108);
pub const SIO_AF_UNIX_GETPEERPID = @as(u32, 1476395264);
pub const SIO_AF_UNIX_SETBINDPARENTPATH = @as(u32, 2550137089);
pub const SIO_AF_UNIX_SETCONNPARENTPATH = @as(u32, 2550137090);
pub const ISOPROTO_TP0 = @as(u32, 25);
pub const ISOPROTO_TP1 = @as(u32, 26);
pub const ISOPROTO_TP2 = @as(u32, 27);
pub const ISOPROTO_TP3 = @as(u32, 28);
pub const ISOPROTO_TP4 = @as(u32, 29);
pub const ISOPROTO_TP = @as(u32, 29);
pub const ISOPROTO_CLTP = @as(u32, 30);
pub const ISOPROTO_CLNP = @as(u32, 31);
pub const ISOPROTO_X25 = @as(u32, 32);
pub const ISOPROTO_INACT_NL = @as(u32, 33);
pub const ISOPROTO_ESIS = @as(u32, 34);
pub const ISOPROTO_INTRAISIS = @as(u32, 35);
pub const ISO_MAX_ADDR_LENGTH = @as(u32, 64);
pub const ISO_HIERARCHICAL = @as(u32, 0);
pub const ISO_NON_HIERARCHICAL = @as(u32, 1);
pub const ISO_EXP_DATA_USE = @as(u32, 0);
pub const ISO_EXP_DATA_NUSE = @as(u32, 1);
pub const NSPROTO_IPX = @as(u32, 1000);
pub const NSPROTO_SPX = @as(u32, 1256);
pub const NSPROTO_SPXII = @as(u32, 1257);
pub const NETBIOS_NAME_LENGTH = @as(u32, 16);
pub const NETBIOS_UNIQUE_NAME = @as(u32, 0);
pub const NETBIOS_GROUP_NAME = @as(u32, 1);
pub const NETBIOS_TYPE_QUICK_UNIQUE = @as(u32, 2);
pub const NETBIOS_TYPE_QUICK_GROUP = @as(u32, 3);
pub const VNSPROTO_IPC = @as(u32, 1);
pub const VNSPROTO_RELIABLE_IPC = @as(u32, 2);
pub const VNSPROTO_SPP = @as(u32, 3);
pub const _LITTLE_ENDIAN = @as(u32, 1234);
pub const _BIG_ENDIAN = @as(u32, 4321);
pub const _PDP_ENDIAN = @as(u32, 3412);
pub const BYTE_ORDER = @as(u32, 1234);
pub const DL_ADDRESS_LENGTH_MAXIMUM = @as(u32, 32);
pub const DL_HEADER_LENGTH_MAXIMUM = @as(u32, 64);
pub const SNAP_DSAP = @as(u32, 170);
pub const SNAP_SSAP = @as(u32, 170);
pub const SNAP_CONTROL = @as(u32, 3);
pub const SNAP_OUI = @as(u32, 0);
pub const ETH_LENGTH_OF_HEADER = @as(u32, 14);
pub const ETH_LENGTH_OF_VLAN_HEADER = @as(u32, 4);
pub const ETH_LENGTH_OF_SNAP_HEADER = @as(u32, 8);
pub const ETHERNET_TYPE_MINIMUM = @as(u32, 1536);
pub const ETHERNET_TYPE_IPV4 = @as(u32, 2048);
pub const ETHERNET_TYPE_ARP = @as(u32, 2054);
pub const ETHERNET_TYPE_IPV6 = @as(u32, 34525);
pub const ETHERNET_TYPE_802_1Q = @as(u32, 33024);
pub const ETHERNET_TYPE_802_1AD = @as(u32, 34984);
pub const IP_VER_MASK = @as(u32, 240);
pub const IPV4_VERSION = @as(u32, 4);
pub const MAX_IPV4_PACKET = @as(u32, 65535);
pub const MAX_IPV4_HLEN = @as(u32, 60);
pub const IPV4_MINIMUM_MTU = @as(u32, 576);
pub const IPV4_MIN_MINIMUM_MTU = @as(u32, 352);
pub const IPV4_MAX_MINIMUM_MTU = @as(u32, 576);
pub const SIZEOF_IP_OPT_ROUTING_HEADER = @as(u32, 3);
pub const SIZEOF_IP_OPT_TIMESTAMP_HEADER = @as(u32, 4);
pub const SIZEOF_IP_OPT_SECURITY = @as(u32, 11);
pub const SIZEOF_IP_OPT_STREAMIDENTIFIER = @as(u32, 4);
pub const SIZEOF_IP_OPT_ROUTERALERT = @as(u32, 4);
pub const IP4_OFF_MASK = @as(u32, 65311);
pub const ICMPV4_INVALID_PREFERENCE_LEVEL = @as(u32, 2147483648);
pub const IGMP_QUERY_TYPE = @as(u32, 17);
pub const IGMP_VERSION1_REPORT_TYPE = @as(u32, 18);
pub const IGMP_VERSION2_REPORT_TYPE = @as(u32, 22);
pub const IGMP_LEAVE_GROUP_TYPE = @as(u32, 23);
pub const IGMP_VERSION3_REPORT_TYPE = @as(u32, 34);
pub const IPV6_VERSION = @as(u32, 96);
pub const IPV6_TRAFFIC_CLASS_MASK = @as(u32, 49167);
pub const IPV6_FULL_TRAFFIC_CLASS_MASK = @as(u32, 61455);
pub const IPV6_ECN_MASK = @as(u32, 12288);
pub const IPV6_FLOW_LABEL_MASK = @as(u32, 4294905600);
pub const MAX_IPV6_PAYLOAD = @as(u32, 65535);
pub const IPV6_ECN_SHIFT = @as(u32, 12);
pub const IPV6_MINIMUM_MTU = @as(u32, 1280);
pub const IP6F_OFF_MASK = @as(u32, 63743);
pub const IP6F_RESERVED_MASK = @as(u32, 1536);
pub const IP6F_MORE_FRAG = @as(u32, 256);
pub const EXT_LEN_UNIT = @as(u32, 8);
pub const IP6OPT_TYPE_SKIP = @as(u32, 0);
pub const IP6OPT_TYPE_DISCARD = @as(u32, 64);
pub const IP6OPT_TYPE_FORCEICMP = @as(u32, 128);
pub const IP6OPT_TYPE_ICMP = @as(u32, 192);
pub const IP6OPT_MUTABLE = @as(u32, 32);
pub const ICMP6_DST_UNREACH_NOROUTE = @as(u32, 0);
pub const ICMP6_DST_UNREACH_ADMIN = @as(u32, 1);
pub const ICMP6_DST_UNREACH_BEYONDSCOPE = @as(u32, 2);
pub const ICMP6_DST_UNREACH_ADDR = @as(u32, 3);
pub const ICMP6_DST_UNREACH_NOPORT = @as(u32, 4);
pub const ICMP6_TIME_EXCEED_TRANSIT = @as(u32, 0);
pub const ICMP6_TIME_EXCEED_REASSEMBLY = @as(u32, 1);
pub const ICMP6_PARAMPROB_HEADER = @as(u32, 0);
pub const ICMP6_PARAMPROB_NEXTHEADER = @as(u32, 1);
pub const ICMP6_PARAMPROB_OPTION = @as(u32, 2);
pub const ICMPV6_ECHO_REQUEST_FLAG_REVERSE = @as(u32, 1);
pub const ND_RA_FLAG_MANAGED = @as(u32, 128);
pub const ND_RA_FLAG_OTHER = @as(u32, 64);
pub const ND_RA_FLAG_HOME_AGENT = @as(u32, 32);
pub const ND_RA_FLAG_PREFERENCE = @as(u32, 24);
pub const ND_NA_FLAG_ROUTER = @as(u32, 2147483648);
pub const ND_NA_FLAG_SOLICITED = @as(u32, 1073741824);
pub const ND_NA_FLAG_OVERRIDE = @as(u32, 536870912);
pub const ND_OPT_PI_FLAG_ONLINK = @as(u32, 128);
pub const ND_OPT_PI_FLAG_AUTO = @as(u32, 64);
pub const ND_OPT_PI_FLAG_ROUTER_ADDR = @as(u32, 32);
pub const ND_OPT_PI_FLAG_SITE_PREFIX = @as(u32, 16);
pub const ND_OPT_PI_FLAG_ROUTE = @as(u32, 1);
pub const ND_OPT_RI_FLAG_PREFERENCE = @as(u32, 24);
pub const ND_OPT_RDNSS_MIN_LEN = @as(u32, 24);
pub const ND_OPT_DNSSL_MIN_LEN = @as(u32, 16);
pub const IN6_EMBEDDEDV4_UOCTET_POSITION = @as(u32, 8);
pub const IN6_EMBEDDEDV4_BITS_IN_BYTE = @as(u32, 8);
pub const TH_FIN = @as(u32, 1);
pub const TH_SYN = @as(u32, 2);
pub const TH_RST = @as(u32, 4);
pub const TH_PSH = @as(u32, 8);
pub const TH_ACK = @as(u32, 16);
pub const TH_URG = @as(u32, 32);
pub const TH_ECE = @as(u32, 64);
pub const TH_CWR = @as(u32, 128);
pub const TH_OPT_EOL = @as(u32, 0);
pub const TH_OPT_NOP = @as(u32, 1);
pub const TH_OPT_MSS = @as(u32, 2);
pub const TH_OPT_WS = @as(u32, 3);
pub const TH_OPT_SACK_PERMITTED = @as(u32, 4);
pub const TH_OPT_SACK = @as(u32, 5);
pub const TH_OPT_TS = @as(u32, 8);
pub const TH_OPT_FASTOPEN = @as(u32, 34);
pub const INVALID_SOCKET = @import("../zig.zig").typedConst(SOCKET, @as(i32, -1));
pub const WSA_INFINITE = @as(u32, 4294967295);
pub const IOC_INOUT = @as(u32, 3221225472);
pub const FIONREAD = @as(i32, 1074030207);
pub const FIONBIO = @as(i32, -2147195266);
pub const FIOASYNC = @as(i32, -2147195267);
pub const SIOCSHIWAT = @as(i32, -2147192064);
pub const SIOCGHIWAT = @as(i32, 1074033409);
pub const SIOCSLOWAT = @as(i32, -2147192062);
pub const SIOCGLOWAT = @as(i32, 1074033411);
pub const SIOCATMARK = @as(i32, 1074033415);
pub const POLLIN = @as(u16, 768);
pub const LM_HB_Extension = @as(i32, 128);
pub const LM_HB1_PnP = @as(i32, 1);
pub const LM_HB1_PDA_Palmtop = @as(i32, 2);
pub const LM_HB1_Computer = @as(i32, 4);
pub const LM_HB1_Printer = @as(i32, 8);
pub const LM_HB1_Modem = @as(i32, 16);
pub const LM_HB1_Fax = @as(i32, 32);
pub const LM_HB1_LANAccess = @as(i32, 64);
pub const LM_HB2_Telephony = @as(i32, 1);
pub const LM_HB2_FileServer = @as(i32, 2);

//--------------------------------------------------------------------------------
// Section: Types (415)
//--------------------------------------------------------------------------------
pub const WSA_ERROR = enum(i32) {
    _IO_PENDING = 997,
    _IO_INCOMPLETE = 996,
    _INVALID_HANDLE = 6,
    _INVALID_PARAMETER = 87,
    _NOT_ENOUGH_MEMORY = 8,
    _OPERATION_ABORTED = 995,
    _WAIT_EVENT_0 = 0,
    _WAIT_IO_COMPLETION = 129,
    BASEERR = 10000,
    EINTR = 10004,
    EBADF = 10009,
    EACCES = 10013,
    EFAULT = 10014,
    EINVAL = 10022,
    EMFILE = 10024,
    EWOULDBLOCK = 10035,
    EINPROGRESS = 10036,
    EALREADY = 10037,
    ENOTSOCK = 10038,
    EDESTADDRREQ = 10039,
    EMSGSIZE = 10040,
    EPROTOTYPE = 10041,
    ENOPROTOOPT = 10042,
    EPROTONOSUPPORT = 10043,
    ESOCKTNOSUPPORT = 10044,
    EOPNOTSUPP = 10045,
    EPFNOSUPPORT = 10046,
    EAFNOSUPPORT = 10047,
    EADDRINUSE = 10048,
    EADDRNOTAVAIL = 10049,
    ENETDOWN = 10050,
    ENETUNREACH = 10051,
    ENETRESET = 10052,
    ECONNABORTED = 10053,
    ECONNRESET = 10054,
    ENOBUFS = 10055,
    EISCONN = 10056,
    ENOTCONN = 10057,
    ESHUTDOWN = 10058,
    ETOOMANYREFS = 10059,
    ETIMEDOUT = 10060,
    ECONNREFUSED = 10061,
    ELOOP = 10062,
    ENAMETOOLONG = 10063,
    EHOSTDOWN = 10064,
    EHOSTUNREACH = 10065,
    ENOTEMPTY = 10066,
    EPROCLIM = 10067,
    EUSERS = 10068,
    EDQUOT = 10069,
    ESTALE = 10070,
    EREMOTE = 10071,
    SYSNOTREADY = 10091,
    VERNOTSUPPORTED = 10092,
    NOTINITIALISED = 10093,
    EDISCON = 10101,
    ENOMORE = 10102,
    ECANCELLED = 10103,
    EINVALIDPROCTABLE = 10104,
    EINVALIDPROVIDER = 10105,
    EPROVIDERFAILEDINIT = 10106,
    SYSCALLFAILURE = 10107,
    SERVICE_NOT_FOUND = 10108,
    TYPE_NOT_FOUND = 10109,
    _E_NO_MORE = 10110,
    _E_CANCELLED = 10111,
    EREFUSED = 10112,
    HOST_NOT_FOUND = 11001,
    TRY_AGAIN = 11002,
    NO_RECOVERY = 11003,
    NO_DATA = 11004,
    _QOS_RECEIVERS = 11005,
    _QOS_SENDERS = 11006,
    _QOS_NO_SENDERS = 11007,
    _QOS_NO_RECEIVERS = 11008,
    _QOS_REQUEST_CONFIRMED = 11009,
    _QOS_ADMISSION_FAILURE = 11010,
    _QOS_POLICY_FAILURE = 11011,
    _QOS_BAD_STYLE = 11012,
    _QOS_BAD_OBJECT = 11013,
    _QOS_TRAFFIC_CTRL_ERROR = 11014,
    _QOS_GENERIC_ERROR = 11015,
    _QOS_ESERVICETYPE = 11016,
    _QOS_EFLOWSPEC = 11017,
    _QOS_EPROVSPECBUF = 11018,
    _QOS_EFILTERSTYLE = 11019,
    _QOS_EFILTERTYPE = 11020,
    _QOS_EFILTERCOUNT = 11021,
    _QOS_EOBJLENGTH = 11022,
    _QOS_EFLOWCOUNT = 11023,
    _QOS_EUNKOWNPSOBJ = 11024,
    _QOS_EPOLICYOBJ = 11025,
    _QOS_EFLOWDESC = 11026,
    _QOS_EPSFLOWSPEC = 11027,
    _QOS_EPSFILTERSPEC = 11028,
    _QOS_ESDMODEOBJ = 11029,
    _QOS_ESHAPERATEOBJ = 11030,
    _QOS_RESERVED_PETYPE = 11031,
    _SECURE_HOST_NOT_FOUND = 11032,
    _IPSEC_NAME_POLICY_ERROR = 11033,
};
pub const WSA_IO_PENDING = WSA_ERROR._IO_PENDING;
pub const WSA_IO_INCOMPLETE = WSA_ERROR._IO_INCOMPLETE;
pub const WSA_INVALID_HANDLE = WSA_ERROR._INVALID_HANDLE;
pub const WSA_INVALID_PARAMETER = WSA_ERROR._INVALID_PARAMETER;
pub const WSA_NOT_ENOUGH_MEMORY = WSA_ERROR._NOT_ENOUGH_MEMORY;
pub const WSA_OPERATION_ABORTED = WSA_ERROR._OPERATION_ABORTED;
pub const WSA_WAIT_EVENT_0 = WSA_ERROR._WAIT_EVENT_0;
pub const WSA_WAIT_IO_COMPLETION = WSA_ERROR._WAIT_IO_COMPLETION;
pub const WSABASEERR = WSA_ERROR.BASEERR;
pub const WSAEINTR = WSA_ERROR.EINTR;
pub const WSAEBADF = WSA_ERROR.EBADF;
pub const WSAEACCES = WSA_ERROR.EACCES;
pub const WSAEFAULT = WSA_ERROR.EFAULT;
pub const WSAEINVAL = WSA_ERROR.EINVAL;
pub const WSAEMFILE = WSA_ERROR.EMFILE;
pub const WSAEWOULDBLOCK = WSA_ERROR.EWOULDBLOCK;
pub const WSAEINPROGRESS = WSA_ERROR.EINPROGRESS;
pub const WSAEALREADY = WSA_ERROR.EALREADY;
pub const WSAENOTSOCK = WSA_ERROR.ENOTSOCK;
pub const WSAEDESTADDRREQ = WSA_ERROR.EDESTADDRREQ;
pub const WSAEMSGSIZE = WSA_ERROR.EMSGSIZE;
pub const WSAEPROTOTYPE = WSA_ERROR.EPROTOTYPE;
pub const WSAENOPROTOOPT = WSA_ERROR.ENOPROTOOPT;
pub const WSAEPROTONOSUPPORT = WSA_ERROR.EPROTONOSUPPORT;
pub const WSAESOCKTNOSUPPORT = WSA_ERROR.ESOCKTNOSUPPORT;
pub const WSAEOPNOTSUPP = WSA_ERROR.EOPNOTSUPP;
pub const WSAEPFNOSUPPORT = WSA_ERROR.EPFNOSUPPORT;
pub const WSAEAFNOSUPPORT = WSA_ERROR.EAFNOSUPPORT;
pub const WSAEADDRINUSE = WSA_ERROR.EADDRINUSE;
pub const WSAEADDRNOTAVAIL = WSA_ERROR.EADDRNOTAVAIL;
pub const WSAENETDOWN = WSA_ERROR.ENETDOWN;
pub const WSAENETUNREACH = WSA_ERROR.ENETUNREACH;
pub const WSAENETRESET = WSA_ERROR.ENETRESET;
pub const WSAECONNABORTED = WSA_ERROR.ECONNABORTED;
pub const WSAECONNRESET = WSA_ERROR.ECONNRESET;
pub const WSAENOBUFS = WSA_ERROR.ENOBUFS;
pub const WSAEISCONN = WSA_ERROR.EISCONN;
pub const WSAENOTCONN = WSA_ERROR.ENOTCONN;
pub const WSAESHUTDOWN = WSA_ERROR.ESHUTDOWN;
pub const WSAETOOMANYREFS = WSA_ERROR.ETOOMANYREFS;
pub const WSAETIMEDOUT = WSA_ERROR.ETIMEDOUT;
pub const WSAECONNREFUSED = WSA_ERROR.ECONNREFUSED;
pub const WSAELOOP = WSA_ERROR.ELOOP;
pub const WSAENAMETOOLONG = WSA_ERROR.ENAMETOOLONG;
pub const WSAEHOSTDOWN = WSA_ERROR.EHOSTDOWN;
pub const WSAEHOSTUNREACH = WSA_ERROR.EHOSTUNREACH;
pub const WSAENOTEMPTY = WSA_ERROR.ENOTEMPTY;
pub const WSAEPROCLIM = WSA_ERROR.EPROCLIM;
pub const WSAEUSERS = WSA_ERROR.EUSERS;
pub const WSAEDQUOT = WSA_ERROR.EDQUOT;
pub const WSAESTALE = WSA_ERROR.ESTALE;
pub const WSAEREMOTE = WSA_ERROR.EREMOTE;
pub const WSASYSNOTREADY = WSA_ERROR.SYSNOTREADY;
pub const WSAVERNOTSUPPORTED = WSA_ERROR.VERNOTSUPPORTED;
pub const WSANOTINITIALISED = WSA_ERROR.NOTINITIALISED;
pub const WSAEDISCON = WSA_ERROR.EDISCON;
pub const WSAENOMORE = WSA_ERROR.ENOMORE;
pub const WSAECANCELLED = WSA_ERROR.ECANCELLED;
pub const WSAEINVALIDPROCTABLE = WSA_ERROR.EINVALIDPROCTABLE;
pub const WSAEINVALIDPROVIDER = WSA_ERROR.EINVALIDPROVIDER;
pub const WSAEPROVIDERFAILEDINIT = WSA_ERROR.EPROVIDERFAILEDINIT;
pub const WSASYSCALLFAILURE = WSA_ERROR.SYSCALLFAILURE;
pub const WSASERVICE_NOT_FOUND = WSA_ERROR.SERVICE_NOT_FOUND;
pub const WSATYPE_NOT_FOUND = WSA_ERROR.TYPE_NOT_FOUND;
pub const WSA_E_NO_MORE = WSA_ERROR._E_NO_MORE;
pub const WSA_E_CANCELLED = WSA_ERROR._E_CANCELLED;
pub const WSAEREFUSED = WSA_ERROR.EREFUSED;
pub const WSAHOST_NOT_FOUND = WSA_ERROR.HOST_NOT_FOUND;
pub const WSATRY_AGAIN = WSA_ERROR.TRY_AGAIN;
pub const WSANO_RECOVERY = WSA_ERROR.NO_RECOVERY;
pub const WSANO_DATA = WSA_ERROR.NO_DATA;
pub const WSA_QOS_RECEIVERS = WSA_ERROR._QOS_RECEIVERS;
pub const WSA_QOS_SENDERS = WSA_ERROR._QOS_SENDERS;
pub const WSA_QOS_NO_SENDERS = WSA_ERROR._QOS_NO_SENDERS;
pub const WSA_QOS_NO_RECEIVERS = WSA_ERROR._QOS_NO_RECEIVERS;
pub const WSA_QOS_REQUEST_CONFIRMED = WSA_ERROR._QOS_REQUEST_CONFIRMED;
pub const WSA_QOS_ADMISSION_FAILURE = WSA_ERROR._QOS_ADMISSION_FAILURE;
pub const WSA_QOS_POLICY_FAILURE = WSA_ERROR._QOS_POLICY_FAILURE;
pub const WSA_QOS_BAD_STYLE = WSA_ERROR._QOS_BAD_STYLE;
pub const WSA_QOS_BAD_OBJECT = WSA_ERROR._QOS_BAD_OBJECT;
pub const WSA_QOS_TRAFFIC_CTRL_ERROR = WSA_ERROR._QOS_TRAFFIC_CTRL_ERROR;
pub const WSA_QOS_GENERIC_ERROR = WSA_ERROR._QOS_GENERIC_ERROR;
pub const WSA_QOS_ESERVICETYPE = WSA_ERROR._QOS_ESERVICETYPE;
pub const WSA_QOS_EFLOWSPEC = WSA_ERROR._QOS_EFLOWSPEC;
pub const WSA_QOS_EPROVSPECBUF = WSA_ERROR._QOS_EPROVSPECBUF;
pub const WSA_QOS_EFILTERSTYLE = WSA_ERROR._QOS_EFILTERSTYLE;
pub const WSA_QOS_EFILTERTYPE = WSA_ERROR._QOS_EFILTERTYPE;
pub const WSA_QOS_EFILTERCOUNT = WSA_ERROR._QOS_EFILTERCOUNT;
pub const WSA_QOS_EOBJLENGTH = WSA_ERROR._QOS_EOBJLENGTH;
pub const WSA_QOS_EFLOWCOUNT = WSA_ERROR._QOS_EFLOWCOUNT;
pub const WSA_QOS_EUNKOWNPSOBJ = WSA_ERROR._QOS_EUNKOWNPSOBJ;
pub const WSA_QOS_EPOLICYOBJ = WSA_ERROR._QOS_EPOLICYOBJ;
pub const WSA_QOS_EFLOWDESC = WSA_ERROR._QOS_EFLOWDESC;
pub const WSA_QOS_EPSFLOWSPEC = WSA_ERROR._QOS_EPSFLOWSPEC;
pub const WSA_QOS_EPSFILTERSPEC = WSA_ERROR._QOS_EPSFILTERSPEC;
pub const WSA_QOS_ESDMODEOBJ = WSA_ERROR._QOS_ESDMODEOBJ;
pub const WSA_QOS_ESHAPERATEOBJ = WSA_ERROR._QOS_ESHAPERATEOBJ;
pub const WSA_QOS_RESERVED_PETYPE = WSA_ERROR._QOS_RESERVED_PETYPE;
pub const WSA_SECURE_HOST_NOT_FOUND = WSA_ERROR._SECURE_HOST_NOT_FOUND;
pub const WSA_IPSEC_NAME_POLICY_ERROR = WSA_ERROR._IPSEC_NAME_POLICY_ERROR;

pub const ADDRESS_FAMILY = enum(u32) {
    INET = 2,
    INET6 = 23,
    UNSPEC = 0,
};
pub const AF_INET = ADDRESS_FAMILY.INET;
pub const AF_INET6 = ADDRESS_FAMILY.INET6;
pub const AF_UNSPEC = ADDRESS_FAMILY.UNSPEC;

pub const SET_SERVICE_OPERATION = enum(u32) {
    REGISTER = 1,
    DEREGISTER = 2,
    FLUSH = 3,
    ADD_TYPE = 4,
    DELETE_TYPE = 5,
};
pub const SERVICE_REGISTER = SET_SERVICE_OPERATION.REGISTER;
pub const SERVICE_DEREGISTER = SET_SERVICE_OPERATION.DEREGISTER;
pub const SERVICE_FLUSH = SET_SERVICE_OPERATION.FLUSH;
pub const SERVICE_ADD_TYPE = SET_SERVICE_OPERATION.ADD_TYPE;
pub const SERVICE_DELETE_TYPE = SET_SERVICE_OPERATION.DELETE_TYPE;

pub const SEND_RECV_FLAGS = packed struct(i32) {
    OOB: u1 = 0,
    PEEK: u1 = 0,
    DONTROUTE: u1 = 0,
    WAITALL: u1 = 0,
    _4: u1 = 0,
    PUSH_IMMEDIATE: u1 = 0,
    _6: u1 = 0,
    _7: u1 = 0,
    _8: u1 = 0,
    _9: u1 = 0,
    _10: u1 = 0,
    _11: u1 = 0,
    _12: u1 = 0,
    _13: u1 = 0,
    _14: u1 = 0,
    _15: u1 = 0,
    _16: u1 = 0,
    _17: u1 = 0,
    _18: u1 = 0,
    _19: u1 = 0,
    _20: u1 = 0,
    _21: u1 = 0,
    _22: u1 = 0,
    _23: u1 = 0,
    _24: u1 = 0,
    _25: u1 = 0,
    _26: u1 = 0,
    _27: u1 = 0,
    _28: u1 = 0,
    _29: u1 = 0,
    _30: u1 = 0,
    _31: u1 = 0,
};
pub const MSG_OOB = SEND_RECV_FLAGS{ .OOB = 1 };
pub const MSG_PEEK = SEND_RECV_FLAGS{ .PEEK = 1 };
pub const MSG_DONTROUTE = SEND_RECV_FLAGS{ .DONTROUTE = 1 };
pub const MSG_WAITALL = SEND_RECV_FLAGS{ .WAITALL = 1 };
pub const MSG_PUSH_IMMEDIATE = SEND_RECV_FLAGS{ .PUSH_IMMEDIATE = 1 };

pub const RESOURCE_DISPLAY_TYPE = enum(u32) {
    DOMAIN = 1,
    FILE = 4,
    GENERIC = 0,
    GROUP = 5,
    SERVER = 2,
    SHARE = 3,
    TREE = 10,
};
pub const RESOURCEDISPLAYTYPE_DOMAIN = RESOURCE_DISPLAY_TYPE.DOMAIN;
pub const RESOURCEDISPLAYTYPE_FILE = RESOURCE_DISPLAY_TYPE.FILE;
pub const RESOURCEDISPLAYTYPE_GENERIC = RESOURCE_DISPLAY_TYPE.GENERIC;
pub const RESOURCEDISPLAYTYPE_GROUP = RESOURCE_DISPLAY_TYPE.GROUP;
pub const RESOURCEDISPLAYTYPE_SERVER = RESOURCE_DISPLAY_TYPE.SERVER;
pub const RESOURCEDISPLAYTYPE_SHARE = RESOURCE_DISPLAY_TYPE.SHARE;
pub const RESOURCEDISPLAYTYPE_TREE = RESOURCE_DISPLAY_TYPE.TREE;

pub const RIO_BUFFERID_t = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const RIO_CQ_t = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const RIO_RQ_t = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

// TODO: this type has a FreeFunc 'WSACloseEvent', what can Zig do with this information?
// TODO: this type has an InvalidHandleValue of '0', what can Zig do with this information?
pub const HWSAEVENT = *opaque{};

// TODO: this type has a FreeFunc 'closesocket', what can Zig do with this information?
pub const SOCKET = @import("std").os.windows.ws2_32.SOCKET;

pub const FLOWSPEC = extern struct {
    TokenRate: u32,
    TokenBucketSize: u32,
    PeakBandwidth: u32,
    Latency: u32,
    DelayVariation: u32,
    ServiceType: u32,
    MaxSduSize: u32,
    MinimumPolicedSize: u32,
};

pub const IN_ADDR = extern struct {
    S_un: extern union {
        S_un_b: extern struct {
            s_b1: u8,
            s_b2: u8,
            s_b3: u8,
            s_b4: u8,
        },
        S_un_w: extern struct {
            s_w1: u16,
            s_w2: u16,
        },
        S_addr: u32,
    },
};

pub const SOCKADDR = extern struct {
    sa_family: u16,
    sa_data: [14]CHAR,
};

pub const SOCKET_ADDRESS = extern struct {
    lpSockaddr: ?*SOCKADDR,
    iSockaddrLength: i32,
};

pub const SOCKET_ADDRESS_LIST = extern struct {
    iAddressCount: i32,
    Address: [1]SOCKET_ADDRESS,
};

pub const CSADDR_INFO = extern struct {
    LocalAddr: SOCKET_ADDRESS,
    RemoteAddr: SOCKET_ADDRESS,
    iSocketType: i32,
    iProtocol: i32,
};

pub const SOCKADDR_STORAGE = extern struct {
    ss_family: u16,
    __ss_pad1: [6]CHAR,
    __ss_align: i64,
    __ss_pad2: [112]CHAR,
};

pub const SOCKADDR_STORAGE_XP = extern struct {
    ss_family: i16,
    __ss_pad1: [6]CHAR,
    __ss_align: i64,
    __ss_pad2: [112]CHAR,
};

pub const SOCKET_PROCESSOR_AFFINITY = extern struct {
    Processor: PROCESSOR_NUMBER,
    NumaNodeId: u16,
    Reserved: u16,
};

pub const IPPROTO = enum(i32) {
    HOPOPTS = 0,
    ICMP = 1,
    IGMP = 2,
    GGP = 3,
    IPV4 = 4,
    ST = 5,
    TCP = 6,
    CBT = 7,
    EGP = 8,
    IGP = 9,
    PUP = 12,
    UDP = 17,
    IDP = 22,
    RDP = 27,
    IPV6 = 41,
    ROUTING = 43,
    FRAGMENT = 44,
    ESP = 50,
    AH = 51,
    ICMPV6 = 58,
    NONE = 59,
    DSTOPTS = 60,
    ND = 77,
    ICLFXBM = 78,
    PIM = 103,
    PGM = 113,
    L2TP = 115,
    SCTP = 132,
    RAW = 255,
    MAX = 256,
    RESERVED_RAW = 257,
    RESERVED_IPSEC = 258,
    RESERVED_IPSECOFFLOAD = 259,
    RESERVED_WNV = 260,
    RESERVED_MAX = 261,
};
pub const IPPROTO_HOPOPTS = IPPROTO.HOPOPTS;
pub const IPPROTO_ICMP = IPPROTO.ICMP;
pub const IPPROTO_IGMP = IPPROTO.IGMP;
pub const IPPROTO_GGP = IPPROTO.GGP;
pub const IPPROTO_IPV4 = IPPROTO.IPV4;
pub const IPPROTO_ST = IPPROTO.ST;
pub const IPPROTO_TCP = IPPROTO.TCP;
pub const IPPROTO_CBT = IPPROTO.CBT;
pub const IPPROTO_EGP = IPPROTO.EGP;
pub const IPPROTO_IGP = IPPROTO.IGP;
pub const IPPROTO_PUP = IPPROTO.PUP;
pub const IPPROTO_UDP = IPPROTO.UDP;
pub const IPPROTO_IDP = IPPROTO.IDP;
pub const IPPROTO_RDP = IPPROTO.RDP;
pub const IPPROTO_IPV6 = IPPROTO.IPV6;
pub const IPPROTO_ROUTING = IPPROTO.ROUTING;
pub const IPPROTO_FRAGMENT = IPPROTO.FRAGMENT;
pub const IPPROTO_ESP = IPPROTO.ESP;
pub const IPPROTO_AH = IPPROTO.AH;
pub const IPPROTO_ICMPV6 = IPPROTO.ICMPV6;
pub const IPPROTO_NONE = IPPROTO.NONE;
pub const IPPROTO_DSTOPTS = IPPROTO.DSTOPTS;
pub const IPPROTO_ND = IPPROTO.ND;
pub const IPPROTO_ICLFXBM = IPPROTO.ICLFXBM;
pub const IPPROTO_PIM = IPPROTO.PIM;
pub const IPPROTO_PGM = IPPROTO.PGM;
pub const IPPROTO_L2TP = IPPROTO.L2TP;
pub const IPPROTO_SCTP = IPPROTO.SCTP;
pub const IPPROTO_RAW = IPPROTO.RAW;
pub const IPPROTO_MAX = IPPROTO.MAX;
pub const IPPROTO_RESERVED_RAW = IPPROTO.RESERVED_RAW;
pub const IPPROTO_RESERVED_IPSEC = IPPROTO.RESERVED_IPSEC;
pub const IPPROTO_RESERVED_IPSECOFFLOAD = IPPROTO.RESERVED_IPSECOFFLOAD;
pub const IPPROTO_RESERVED_WNV = IPPROTO.RESERVED_WNV;
pub const IPPROTO_RESERVED_MAX = IPPROTO.RESERVED_MAX;

pub const SCOPE_LEVEL = enum(i32) {
    Interface = 1,
    Link = 2,
    Subnet = 3,
    Admin = 4,
    Site = 5,
    Organization = 8,
    Global = 14,
    Count = 16,
};
pub const ScopeLevelInterface = SCOPE_LEVEL.Interface;
pub const ScopeLevelLink = SCOPE_LEVEL.Link;
pub const ScopeLevelSubnet = SCOPE_LEVEL.Subnet;
pub const ScopeLevelAdmin = SCOPE_LEVEL.Admin;
pub const ScopeLevelSite = SCOPE_LEVEL.Site;
pub const ScopeLevelOrganization = SCOPE_LEVEL.Organization;
pub const ScopeLevelGlobal = SCOPE_LEVEL.Global;
pub const ScopeLevelCount = SCOPE_LEVEL.Count;

pub const SCOPE_ID = extern struct {
    Anonymous: extern union {
        Anonymous: extern struct {
            _bitfield: u32,
        },
        Value: u32,
    },
};

pub const SOCKADDR_IN = extern struct {
    sin_family: u16,
    sin_port: u16,
    sin_addr: IN_ADDR,
    sin_zero: [8]CHAR,
};

pub const SOCKADDR_DL = extern struct {
    sdl_family: u16,
    sdl_data: [8]u8,
    sdl_zero: [4]u8,
};

pub const WSABUF = extern struct {
    len: u32,
    buf: ?PSTR,
};

pub const WSAMSG = extern struct {
    name: ?*SOCKADDR,
    namelen: i32,
    lpBuffers: ?*WSABUF,
    dwBufferCount: u32,
    Control: WSABUF,
    dwFlags: u32,
};

pub const cmsghdr = extern struct {
    cmsg_len: usize,
    cmsg_level: i32,
    cmsg_type: i32,
};

pub const ADDRINFOA = extern struct {
    ai_flags: i32,
    ai_family: i32,
    ai_socktype: i32,
    ai_protocol: i32,
    ai_addrlen: usize,
    ai_canonname: ?PSTR,
    ai_addr: ?*SOCKADDR,
    ai_next: ?*ADDRINFOA,
};

pub const addrinfoW = extern struct {
    ai_flags: i32,
    ai_family: i32,
    ai_socktype: i32,
    ai_protocol: i32,
    ai_addrlen: usize,
    ai_canonname: ?PWSTR,
    ai_addr: ?*SOCKADDR,
    ai_next: ?*addrinfoW,
};

pub const addrinfoexA = extern struct {
    ai_flags: i32,
    ai_family: i32,
    ai_socktype: i32,
    ai_protocol: i32,
    ai_addrlen: usize,
    ai_canonname: ?PSTR,
    ai_addr: ?*SOCKADDR,
    ai_blob: ?*anyopaque,
    ai_bloblen: usize,
    ai_provider: ?*Guid,
    ai_next: ?*addrinfoexA,
};

pub const addrinfoexW = extern struct {
    ai_flags: i32,
    ai_family: i32,
    ai_socktype: i32,
    ai_protocol: i32,
    ai_addrlen: usize,
    ai_canonname: ?PWSTR,
    ai_addr: ?*SOCKADDR,
    ai_blob: ?*anyopaque,
    ai_bloblen: usize,
    ai_provider: ?*Guid,
    ai_next: ?*addrinfoexW,
};

pub const addrinfoex2A = extern struct {
    ai_flags: i32,
    ai_family: i32,
    ai_socktype: i32,
    ai_protocol: i32,
    ai_addrlen: usize,
    ai_canonname: ?PSTR,
    ai_addr: ?*SOCKADDR,
    ai_blob: ?*anyopaque,
    ai_bloblen: usize,
    ai_provider: ?*Guid,
    ai_next: ?*addrinfoex2A,
    ai_version: i32,
    ai_fqdn: ?PSTR,
};

pub const addrinfoex2W = extern struct {
    ai_flags: i32,
    ai_family: i32,
    ai_socktype: i32,
    ai_protocol: i32,
    ai_addrlen: usize,
    ai_canonname: ?PWSTR,
    ai_addr: ?*SOCKADDR,
    ai_blob: ?*anyopaque,
    ai_bloblen: usize,
    ai_provider: ?*Guid,
    ai_next: ?*addrinfoex2W,
    ai_version: i32,
    ai_fqdn: ?PWSTR,
};

pub const addrinfoex3 = extern struct {
    ai_flags: i32,
    ai_family: i32,
    ai_socktype: i32,
    ai_protocol: i32,
    ai_addrlen: usize,
    ai_canonname: ?PWSTR,
    ai_addr: ?*SOCKADDR,
    ai_blob: ?*anyopaque,
    ai_bloblen: usize,
    ai_provider: ?*Guid,
    ai_next: ?*addrinfoex3,
    ai_version: i32,
    ai_fqdn: ?PWSTR,
    ai_interfaceindex: i32,
};

pub const addrinfoex4 = extern struct {
    ai_flags: i32,
    ai_family: i32,
    ai_socktype: i32,
    ai_protocol: i32,
    ai_addrlen: usize,
    ai_canonname: ?PWSTR,
    ai_addr: ?*SOCKADDR,
    ai_blob: ?*anyopaque,
    ai_bloblen: usize,
    ai_provider: ?*Guid,
    ai_next: ?*addrinfoex4,
    ai_version: i32,
    ai_fqdn: ?PWSTR,
    ai_interfaceindex: i32,
    ai_resolutionhandle: ?HANDLE,
};

pub const addrinfoex5 = extern struct {
    ai_flags: i32,
    ai_family: i32,
    ai_socktype: i32,
    ai_protocol: i32,
    ai_addrlen: usize,
    ai_canonname: ?PWSTR,
    ai_addr: ?*SOCKADDR,
    ai_blob: ?*anyopaque,
    ai_bloblen: usize,
    ai_provider: ?*Guid,
    ai_next: ?*addrinfoex5,
    ai_version: i32,
    ai_fqdn: ?PWSTR,
    ai_interfaceindex: i32,
    ai_resolutionhandle: ?HANDLE,
    ai_ttl: u32,
};

pub const addrinfo_dns_server = extern struct {
    ai_servertype: u32,
    ai_flags: u64,
    ai_addrlen: u32,
    ai_addr: ?*SOCKADDR,
    Anonymous: extern union {
        ai_template: ?PWSTR,
    },
};

pub const addrinfoex6 = extern struct {
    ai_flags: i32,
    ai_family: i32,
    ai_socktype: i32,
    ai_protocol: i32,
    ai_addrlen: usize,
    ai_canonname: ?PWSTR,
    ai_addr: ?*SOCKADDR,
    ai_blob: ?*anyopaque,
    ai_bloblen: usize,
    ai_provider: ?*Guid,
    ai_next: ?*addrinfoex5,
    ai_version: i32,
    ai_fqdn: ?PWSTR,
    ai_interfaceindex: i32,
    ai_resolutionhandle: ?HANDLE,
    ai_ttl: u32,
    ai_numservers: u32,
    ai_servers: ?*addrinfo_dns_server,
    ai_responseflags: u64,
};

pub const fd_set = extern struct {
    fd_count: u32,
    fd_array: [64]?SOCKET,
};

pub const timeval = extern struct {
    tv_sec: i32,
    tv_usec: i32,
};

pub const hostent = extern struct {
    h_name: ?PSTR,
    h_aliases: ?*?*i8,
    h_addrtype: i16,
    h_length: i16,
    h_addr_list: ?*?*i8,
};

pub const netent = extern struct {
    n_name: ?PSTR,
    n_aliases: ?*?*i8,
    n_addrtype: i16,
    n_net: u32,
};


pub const protoent = extern struct {
    p_name: ?PSTR,
    p_aliases: ?*?*i8,
    p_proto: i16,
};


pub const sockproto = extern struct {
    sp_family: u16,
    sp_protocol: u16,
};

pub const linger = extern struct {
    l_onoff: u16,
    l_linger: u16,
};

pub const QOS = extern struct {
    SendingFlowspec: FLOWSPEC,
    ReceivingFlowspec: FLOWSPEC,
    ProviderSpecific: WSABUF,
};

pub const WSANETWORKEVENTS = extern struct {
    lNetworkEvents: i32,
    iErrorCode: [10]i32,
};

pub const WSAPROTOCOLCHAIN = extern struct {
    ChainLen: i32,
    ChainEntries: [7]u32,
};

pub const WSAPROTOCOL_INFOA = extern struct {
    dwServiceFlags1: u32,
    dwServiceFlags2: u32,
    dwServiceFlags3: u32,
    dwServiceFlags4: u32,
    dwProviderFlags: u32,
    ProviderId: Guid,
    dwCatalogEntryId: u32,
    ProtocolChain: WSAPROTOCOLCHAIN,
    iVersion: i32,
    iAddressFamily: i32,
    iMaxSockAddr: i32,
    iMinSockAddr: i32,
    iSocketType: i32,
    iProtocol: i32,
    iProtocolMaxOffset: i32,
    iNetworkByteOrder: i32,
    iSecurityScheme: i32,
    dwMessageSize: u32,
    dwProviderReserved: u32,
    szProtocol: [256]CHAR,
};

pub const WSAPROTOCOL_INFOW = extern struct {
    dwServiceFlags1: u32,
    dwServiceFlags2: u32,
    dwServiceFlags3: u32,
    dwServiceFlags4: u32,
    dwProviderFlags: u32,
    ProviderId: Guid,
    dwCatalogEntryId: u32,
    ProtocolChain: WSAPROTOCOLCHAIN,
    iVersion: i32,
    iAddressFamily: i32,
    iMaxSockAddr: i32,
    iMinSockAddr: i32,
    iSocketType: i32,
    iProtocol: i32,
    iProtocolMaxOffset: i32,
    iNetworkByteOrder: i32,
    iSecurityScheme: i32,
    dwMessageSize: u32,
    dwProviderReserved: u32,
    szProtocol: [256]u16,
};

pub const LPCONDITIONPROC = *const fn(
    lpCallerId: ?*WSABUF,
    lpCallerData: ?*WSABUF,
    lpSQOS: ?*QOS,
    lpGQOS: ?*QOS,
    lpCalleeId: ?*WSABUF,
    lpCalleeData: ?*WSABUF,
    g: ?*u32,
    dwCallbackData: usize,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSAOVERLAPPED_COMPLETION_ROUTINE = *const fn(
    dwError: u32,
    cbTransferred: u32,
    lpOverlapped: ?*OVERLAPPED,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) void;

pub const WSACOMPLETIONTYPE = enum(i32) {
    IMMEDIATELY = 0,
    HWND = 1,
    EVENT = 2,
    PORT = 3,
    APC = 4,
};
pub const NSP_NOTIFY_IMMEDIATELY = WSACOMPLETIONTYPE.IMMEDIATELY;
pub const NSP_NOTIFY_HWND = WSACOMPLETIONTYPE.HWND;
pub const NSP_NOTIFY_EVENT = WSACOMPLETIONTYPE.EVENT;
pub const NSP_NOTIFY_PORT = WSACOMPLETIONTYPE.PORT;
pub const NSP_NOTIFY_APC = WSACOMPLETIONTYPE.APC;

pub const WSACOMPLETION = extern struct {
    Type: WSACOMPLETIONTYPE,
    Parameters: extern union {
        WindowMessage: extern struct {
            hWnd: ?HWND,
            uMsg: u32,
            context: WPARAM,
        },
        Event: extern struct {
            lpOverlapped: ?*OVERLAPPED,
        },
        Apc: extern struct {
            lpOverlapped: ?*OVERLAPPED,
            lpfnCompletionProc: ?LPWSAOVERLAPPED_COMPLETION_ROUTINE,
        },
        Port: extern struct {
            lpOverlapped: ?*OVERLAPPED,
            hPort: ?HANDLE,
            Key: usize,
        },
    },
};

pub const AFPROTOCOLS = extern struct {
    iAddressFamily: i32,
    iProtocol: i32,
};

pub const WSAECOMPARATOR = enum(i32) {
    EQUAL = 0,
    NOTLESS = 1,
};
pub const COMP_EQUAL = WSAECOMPARATOR.EQUAL;
pub const COMP_NOTLESS = WSAECOMPARATOR.NOTLESS;

pub const WSAVERSION = extern struct {
    dwVersion: u32,
    ecHow: WSAECOMPARATOR,
};

pub const WSAQUERYSETA = extern struct {
    dwSize: u32,
    lpszServiceInstanceName: ?PSTR,
    lpServiceClassId: ?*Guid,
    lpVersion: ?*WSAVERSION,
    lpszComment: ?PSTR,
    dwNameSpace: u32,
    lpNSProviderId: ?*Guid,
    lpszContext: ?PSTR,
    dwNumberOfProtocols: u32,
    lpafpProtocols: ?*AFPROTOCOLS,
    lpszQueryString: ?PSTR,
    dwNumberOfCsAddrs: u32,
    lpcsaBuffer: ?*CSADDR_INFO,
    dwOutputFlags: u32,
    lpBlob: ?*BLOB,
};

pub const WSAQUERYSETW = extern struct {
    dwSize: u32,
    lpszServiceInstanceName: ?PWSTR,
    lpServiceClassId: ?*Guid,
    lpVersion: ?*WSAVERSION,
    lpszComment: ?PWSTR,
    dwNameSpace: u32,
    lpNSProviderId: ?*Guid,
    lpszContext: ?PWSTR,
    dwNumberOfProtocols: u32,
    lpafpProtocols: ?*AFPROTOCOLS,
    lpszQueryString: ?PWSTR,
    dwNumberOfCsAddrs: u32,
    lpcsaBuffer: ?*CSADDR_INFO,
    dwOutputFlags: u32,
    lpBlob: ?*BLOB,
};

pub const WSAQUERYSET2A = extern struct {
    dwSize: u32,
    lpszServiceInstanceName: ?PSTR,
    lpVersion: ?*WSAVERSION,
    lpszComment: ?PSTR,
    dwNameSpace: u32,
    lpNSProviderId: ?*Guid,
    lpszContext: ?PSTR,
    dwNumberOfProtocols: u32,
    lpafpProtocols: ?*AFPROTOCOLS,
    lpszQueryString: ?PSTR,
    dwNumberOfCsAddrs: u32,
    lpcsaBuffer: ?*CSADDR_INFO,
    dwOutputFlags: u32,
    lpBlob: ?*BLOB,
};

pub const WSAQUERYSET2W = extern struct {
    dwSize: u32,
    lpszServiceInstanceName: ?PWSTR,
    lpVersion: ?*WSAVERSION,
    lpszComment: ?PWSTR,
    dwNameSpace: u32,
    lpNSProviderId: ?*Guid,
    lpszContext: ?PWSTR,
    dwNumberOfProtocols: u32,
    lpafpProtocols: ?*AFPROTOCOLS,
    lpszQueryString: ?PWSTR,
    dwNumberOfCsAddrs: u32,
    lpcsaBuffer: ?*CSADDR_INFO,
    dwOutputFlags: u32,
    lpBlob: ?*BLOB,
};

pub const WSAESETSERVICEOP = enum(i32) {
    REGISTER = 0,
    DEREGISTER = 1,
    DELETE = 2,
};
pub const RNRSERVICE_REGISTER = WSAESETSERVICEOP.REGISTER;
pub const RNRSERVICE_DEREGISTER = WSAESETSERVICEOP.DEREGISTER;
pub const RNRSERVICE_DELETE = WSAESETSERVICEOP.DELETE;

pub const WSANSCLASSINFOA = extern struct {
    lpszName: ?PSTR,
    dwNameSpace: u32,
    dwValueType: u32,
    dwValueSize: u32,
    lpValue: ?*anyopaque,
};

pub const WSANSCLASSINFOW = extern struct {
    lpszName: ?PWSTR,
    dwNameSpace: u32,
    dwValueType: u32,
    dwValueSize: u32,
    lpValue: ?*anyopaque,
};

pub const WSASERVICECLASSINFOA = extern struct {
    lpServiceClassId: ?*Guid,
    lpszServiceClassName: ?PSTR,
    dwCount: u32,
    lpClassInfos: ?*WSANSCLASSINFOA,
};

pub const WSASERVICECLASSINFOW = extern struct {
    lpServiceClassId: ?*Guid,
    lpszServiceClassName: ?PWSTR,
    dwCount: u32,
    lpClassInfos: ?*WSANSCLASSINFOW,
};

pub const WSANAMESPACE_INFOA = extern struct {
    NSProviderId: Guid,
    dwNameSpace: u32,
    fActive: BOOL,
    dwVersion: u32,
    lpszIdentifier: ?PSTR,
};

pub const WSANAMESPACE_INFOW = extern struct {
    NSProviderId: Guid,
    dwNameSpace: u32,
    fActive: BOOL,
    dwVersion: u32,
    lpszIdentifier: ?PWSTR,
};

pub const WSANAMESPACE_INFOEXA = extern struct {
    NSProviderId: Guid,
    dwNameSpace: u32,
    fActive: BOOL,
    dwVersion: u32,
    lpszIdentifier: ?PSTR,
    ProviderSpecific: BLOB,
};

pub const WSANAMESPACE_INFOEXW = extern struct {
    NSProviderId: Guid,
    dwNameSpace: u32,
    fActive: BOOL,
    dwVersion: u32,
    lpszIdentifier: ?PWSTR,
    ProviderSpecific: BLOB,
};

pub const WSAPOLLFD = extern struct {
    fd: ?SOCKET,
    events: i16,
    revents: i16,
};

pub const SOCK_NOTIFY_REGISTRATION = extern struct {
    socket: ?SOCKET,
    completionKey: ?*anyopaque,
    eventFilter: u16,
    operation: u8,
    triggerFlags: u8,
    registrationResult: u32,
};

pub const IN6_ADDR = extern struct {
    u: extern union {
        Byte: [16]u8,
        Word: [8]u16,
    },
};

pub const sockaddr_in6_old = extern struct {
    sin6_family: i16,
    sin6_port: u16,
    sin6_flowinfo: u32,
    sin6_addr: IN6_ADDR,
};

pub const sockaddr_gen = extern union {
    Address: SOCKADDR,
    AddressIn: SOCKADDR_IN,
    AddressIn6: sockaddr_in6_old,
};

pub const INTERFACE_INFO = extern struct {
    iiFlags: u32,
    iiAddress: sockaddr_gen,
    iiBroadcastAddress: sockaddr_gen,
    iiNetmask: sockaddr_gen,
};

pub const INTERFACE_INFO_EX = extern struct {
    iiFlags: u32,
    iiAddress: SOCKET_ADDRESS,
    iiBroadcastAddress: SOCKET_ADDRESS,
    iiNetmask: SOCKET_ADDRESS,
};

pub const PMTUD_STATE = enum(i32) {
    NOT_SET = 0,
    DO = 1,
    DONT = 2,
    PROBE = 3,
    MAX = 4,
};
pub const IP_PMTUDISC_NOT_SET = PMTUD_STATE.NOT_SET;
pub const IP_PMTUDISC_DO = PMTUD_STATE.DO;
pub const IP_PMTUDISC_DONT = PMTUD_STATE.DONT;
pub const IP_PMTUDISC_PROBE = PMTUD_STATE.PROBE;
pub const IP_PMTUDISC_MAX = PMTUD_STATE.MAX;

pub const SOCKADDR_IN6 = extern struct {
    sin6_family: u16,
    sin6_port: u16,
    sin6_flowinfo: u32,
    sin6_addr: IN6_ADDR,
    Anonymous: extern union {
        sin6_scope_id: u32,
        sin6_scope_struct: SCOPE_ID,
    },
};

pub const SOCKADDR_IN6_W2KSP1 = extern struct {
    sin6_family: i16,
    sin6_port: u16,
    sin6_flowinfo: u32,
    sin6_addr: IN6_ADDR,
    sin6_scope_id: u32,
};

pub const SOCKADDR_INET = extern union {
    Ipv4: SOCKADDR_IN,
    Ipv6: SOCKADDR_IN6,
    si_family: u16,
};

pub const SOCKADDR_IN6_PAIR = extern struct {
    SourceAddress: ?*SOCKADDR_IN6,
    DestinationAddress: ?*SOCKADDR_IN6,
};

pub const MULTICAST_MODE_TYPE = enum(i32) {
    INCLUDE = 0,
    EXCLUDE = 1,
};
pub const MCAST_INCLUDE = MULTICAST_MODE_TYPE.INCLUDE;
pub const MCAST_EXCLUDE = MULTICAST_MODE_TYPE.EXCLUDE;

pub const IP_MREQ = extern struct {
    imr_multiaddr: IN_ADDR,
    imr_interface: IN_ADDR,
};

pub const IP_MREQ_SOURCE = extern struct {
    imr_multiaddr: IN_ADDR,
    imr_sourceaddr: IN_ADDR,
    imr_interface: IN_ADDR,
};

pub const IP_MSFILTER = extern struct {
    imsf_multiaddr: IN_ADDR,
    imsf_interface: IN_ADDR,
    imsf_fmode: MULTICAST_MODE_TYPE,
    imsf_numsrc: u32,
    imsf_slist: [1]IN_ADDR,
};

pub const IPV6_MREQ = extern struct {
    ipv6mr_multiaddr: IN6_ADDR,
    ipv6mr_interface: u32,
};

pub const GROUP_REQ = extern struct {
    gr_interface: u32,
    gr_group: SOCKADDR_STORAGE,
};

pub const GROUP_SOURCE_REQ = extern struct {
    gsr_interface: u32,
    gsr_group: SOCKADDR_STORAGE,
    gsr_source: SOCKADDR_STORAGE,
};

pub const GROUP_FILTER = extern struct {
    gf_interface: u32,
    gf_group: SOCKADDR_STORAGE,
    gf_fmode: MULTICAST_MODE_TYPE,
    gf_numsrc: u32,
    gf_slist: [1]SOCKADDR_STORAGE,
};

pub const IN_PKTINFO = extern struct {
    ipi_addr: IN_ADDR,
    ipi_ifindex: u32,
};

pub const IN6_PKTINFO = extern struct {
    ipi6_addr: IN6_ADDR,
    ipi6_ifindex: u32,
};

pub const IN_PKTINFO_EX = extern struct {
    pkt_info: IN_PKTINFO,
    scope_id: SCOPE_ID,
};

pub const in6_pktinfo_ex = extern struct {
    pkt_info: IN6_PKTINFO,
    scope_id: SCOPE_ID,
};

pub const IN_RECVERR = extern struct {
    protocol: IPPROTO,
    info: u32,
    type: u8,
    code: u8,
};

pub const ICMP_ERROR_INFO = extern struct {
    srcaddress: SOCKADDR_INET,
    protocol: IPPROTO,
    type: u8,
    code: u8,
};

pub const eWINDOW_ADVANCE_METHOD = enum(i32) {
    ADVANCE_BY_TIME = 1,
    USE_AS_DATA_CACHE = 2,
};
pub const E_WINDOW_ADVANCE_BY_TIME = eWINDOW_ADVANCE_METHOD.ADVANCE_BY_TIME;
pub const E_WINDOW_USE_AS_DATA_CACHE = eWINDOW_ADVANCE_METHOD.USE_AS_DATA_CACHE;

pub const RM_SEND_WINDOW = extern struct {
    RateKbitsPerSec: u32,
    WindowSizeInMSecs: u32,
    WindowSizeInBytes: u32,
};

pub const RM_SENDER_STATS = extern struct {
    DataBytesSent: u64,
    TotalBytesSent: u64,
    NaksReceived: u64,
    NaksReceivedTooLate: u64,
    NumOutstandingNaks: u64,
    NumNaksAfterRData: u64,
    RepairPacketsSent: u64,
    BufferSpaceAvailable: u64,
    TrailingEdgeSeqId: u64,
    LeadingEdgeSeqId: u64,
    RateKBitsPerSecOverall: u64,
    RateKBitsPerSecLast: u64,
    TotalODataPacketsSent: u64,
};

pub const RM_RECEIVER_STATS = extern struct {
    NumODataPacketsReceived: u64,
    NumRDataPacketsReceived: u64,
    NumDuplicateDataPackets: u64,
    DataBytesReceived: u64,
    TotalBytesReceived: u64,
    RateKBitsPerSecOverall: u64,
    RateKBitsPerSecLast: u64,
    TrailingEdgeSeqId: u64,
    LeadingEdgeSeqId: u64,
    AverageSequencesInWindow: u64,
    MinSequencesInWindow: u64,
    MaxSequencesInWindow: u64,
    FirstNakSequenceNumber: u64,
    NumPendingNaks: u64,
    NumOutstandingNaks: u64,
    NumDataPacketsBuffered: u64,
    TotalSelectiveNaksSent: u64,
    TotalParityNaksSent: u64,
};

pub const RM_FEC_INFO = extern struct {
    FECBlockSize: u16,
    FECProActivePackets: u16,
    FECGroupSize: u8,
    fFECOnDemandParityEnabled: BOOLEAN,
};

pub const IPX_ADDRESS_DATA = extern struct {
    adapternum: i32,
    netnum: [4]u8,
    nodenum: [6]u8,
    wan: BOOLEAN,
    status: BOOLEAN,
    maxpkt: i32,
    linkspeed: u32,
};

pub const IPX_NETNUM_DATA = extern struct {
    netnum: [4]u8,
    hopcount: u16,
    netdelay: u16,
    cardnum: i32,
    router: [6]u8,
};

pub const IPX_SPXCONNSTATUS_DATA = extern struct {
    ConnectionState: u8,
    WatchDogActive: u8,
    LocalConnectionId: u16,
    RemoteConnectionId: u16,
    LocalSequenceNumber: u16,
    LocalAckNumber: u16,
    LocalAllocNumber: u16,
    RemoteAckNumber: u16,
    RemoteAllocNumber: u16,
    LocalSocket: u16,
    ImmediateAddress: [6]u8,
    RemoteNetwork: [4]u8,
    RemoteNode: [6]u8,
    RemoteSocket: u16,
    RetransmissionCount: u16,
    EstimatedRoundTripDelay: u16,
    RetransmittedPackets: u16,
    SuppressedPacket: u16,
};

pub const LM_IRPARMS = extern struct {
    nTXDataBytes: u32,
    nRXDataBytes: u32,
    nBaudRate: u32,
    thresholdTime: u32,
    discTime: u32,
    nMSLinkTurn: u16,
    nTXPackets: u8,
    nRXPackets: u8,
};

pub const SOCKADDR_IRDA = extern struct {
    irdaAddressFamily: u16,
    irdaDeviceID: [4]u8,
    irdaServiceName: [25]CHAR,
};

pub const WINDOWS_IRDA_DEVICE_INFO = extern struct {
    irdaDeviceID: [4]u8,
    irdaDeviceName: [22]CHAR,
    irdaDeviceHints1: u8,
    irdaDeviceHints2: u8,
    irdaCharSet: u8,
};

pub const WCE_IRDA_DEVICE_INFO = extern struct {
    irdaDeviceID: [4]u8,
    irdaDeviceName: [22]CHAR,
    Reserved: [2]u8,
};

pub const WINDOWS_DEVICELIST = extern struct {
    numDevice: u32,
    Device: [1]WINDOWS_IRDA_DEVICE_INFO,
};

pub const WCE_DEVICELIST = extern struct {
    numDevice: u32,
    Device: [1]WCE_IRDA_DEVICE_INFO,
};

pub const WINDOWS_IAS_SET = extern struct {
    irdaClassName: [64]CHAR,
    irdaAttribName: [256]CHAR,
    irdaAttribType: u32,
    irdaAttribute: extern union {
        irdaAttribInt: i32,
        irdaAttribOctetSeq: extern struct {
            Len: u16,
            OctetSeq: [1024]u8,
        },
        irdaAttribUsrStr: extern struct {
            Len: u8,
            CharSet: u8,
            UsrStr: [256]u8,
        },
    },
};

pub const WINDOWS_IAS_QUERY = extern struct {
    irdaDeviceID: [4]u8,
    irdaClassName: [64]CHAR,
    irdaAttribName: [256]CHAR,
    irdaAttribType: u32,
    irdaAttribute: extern union {
        irdaAttribInt: i32,
        irdaAttribOctetSeq: extern struct {
            Len: u32,
            OctetSeq: [1024]u8,
        },
        irdaAttribUsrStr: extern struct {
            Len: u32,
            CharSet: u32,
            UsrStr: [256]u8,
        },
    },
};

pub const NL_PREFIX_ORIGIN = enum(i32) {
    Other = 0,
    Manual = 1,
    WellKnown = 2,
    Dhcp = 3,
    RouterAdvertisement = 4,
    Unchanged = 16,
};
pub const IpPrefixOriginOther = NL_PREFIX_ORIGIN.Other;
pub const IpPrefixOriginManual = NL_PREFIX_ORIGIN.Manual;
pub const IpPrefixOriginWellKnown = NL_PREFIX_ORIGIN.WellKnown;
pub const IpPrefixOriginDhcp = NL_PREFIX_ORIGIN.Dhcp;
pub const IpPrefixOriginRouterAdvertisement = NL_PREFIX_ORIGIN.RouterAdvertisement;
pub const IpPrefixOriginUnchanged = NL_PREFIX_ORIGIN.Unchanged;

pub const NL_SUFFIX_ORIGIN = enum(i32) {
    NlsoOther = 0,
    NlsoManual = 1,
    NlsoWellKnown = 2,
    NlsoDhcp = 3,
    NlsoLinkLayerAddress = 4,
    NlsoRandom = 5,
    IpSuffixOriginUnchanged = 16,
    pub const IpSuffixOriginOther = .NlsoOther;
    pub const IpSuffixOriginManual = .NlsoManual;
    pub const IpSuffixOriginWellKnown = .NlsoWellKnown;
    pub const IpSuffixOriginDhcp = .NlsoDhcp;
    pub const IpSuffixOriginLinkLayerAddress = .NlsoLinkLayerAddress;
    pub const IpSuffixOriginRandom = .NlsoRandom;
};
pub const NlsoOther = NL_SUFFIX_ORIGIN.NlsoOther;
pub const NlsoManual = NL_SUFFIX_ORIGIN.NlsoManual;
pub const NlsoWellKnown = NL_SUFFIX_ORIGIN.NlsoWellKnown;
pub const NlsoDhcp = NL_SUFFIX_ORIGIN.NlsoDhcp;
pub const NlsoLinkLayerAddress = NL_SUFFIX_ORIGIN.NlsoLinkLayerAddress;
pub const NlsoRandom = NL_SUFFIX_ORIGIN.NlsoRandom;
pub const IpSuffixOriginOther = NL_SUFFIX_ORIGIN.NlsoOther;
pub const IpSuffixOriginManual = NL_SUFFIX_ORIGIN.NlsoManual;
pub const IpSuffixOriginWellKnown = NL_SUFFIX_ORIGIN.NlsoWellKnown;
pub const IpSuffixOriginDhcp = NL_SUFFIX_ORIGIN.NlsoDhcp;
pub const IpSuffixOriginLinkLayerAddress = NL_SUFFIX_ORIGIN.NlsoLinkLayerAddress;
pub const IpSuffixOriginRandom = NL_SUFFIX_ORIGIN.NlsoRandom;
pub const IpSuffixOriginUnchanged = NL_SUFFIX_ORIGIN.IpSuffixOriginUnchanged;

pub const NL_DAD_STATE = enum(i32) {
    NldsInvalid = 0,
    NldsTentative = 1,
    NldsDuplicate = 2,
    NldsDeprecated = 3,
    NldsPreferred = 4,
    pub const IpDadStateInvalid = .NldsInvalid;
    pub const IpDadStateTentative = .NldsTentative;
    pub const IpDadStateDuplicate = .NldsDuplicate;
    pub const IpDadStateDeprecated = .NldsDeprecated;
    pub const IpDadStatePreferred = .NldsPreferred;
};
pub const NldsInvalid = NL_DAD_STATE.NldsInvalid;
pub const NldsTentative = NL_DAD_STATE.NldsTentative;
pub const NldsDuplicate = NL_DAD_STATE.NldsDuplicate;
pub const NldsDeprecated = NL_DAD_STATE.NldsDeprecated;
pub const NldsPreferred = NL_DAD_STATE.NldsPreferred;
pub const IpDadStateInvalid = NL_DAD_STATE.NldsInvalid;
pub const IpDadStateTentative = NL_DAD_STATE.NldsTentative;
pub const IpDadStateDuplicate = NL_DAD_STATE.NldsDuplicate;
pub const IpDadStateDeprecated = NL_DAD_STATE.NldsDeprecated;
pub const IpDadStatePreferred = NL_DAD_STATE.NldsPreferred;

pub const NL_ROUTE_PROTOCOL = enum(i32) {
    RouteProtocolOther = 1,
    RouteProtocolLocal = 2,
    RouteProtocolNetMgmt = 3,
    RouteProtocolIcmp = 4,
    RouteProtocolEgp = 5,
    RouteProtocolGgp = 6,
    RouteProtocolHello = 7,
    RouteProtocolRip = 8,
    RouteProtocolIsIs = 9,
    RouteProtocolEsIs = 10,
    RouteProtocolCisco = 11,
    RouteProtocolBbn = 12,
    RouteProtocolOspf = 13,
    RouteProtocolBgp = 14,
    RouteProtocolIdpr = 15,
    RouteProtocolEigrp = 16,
    RouteProtocolDvmrp = 17,
    RouteProtocolRpl = 18,
    RouteProtocolDhcp = 19,
    MIB_IPPROTO_NT_AUTOSTATIC = 10002,
    MIB_IPPROTO_NT_STATIC = 10006,
    MIB_IPPROTO_NT_STATIC_NON_DOD = 10007,
    pub const MIB_IPPROTO_OTHER = .RouteProtocolOther;
    pub const PROTO_IP_OTHER = .RouteProtocolOther;
    pub const MIB_IPPROTO_LOCAL = .RouteProtocolLocal;
    pub const PROTO_IP_LOCAL = .RouteProtocolLocal;
    pub const MIB_IPPROTO_NETMGMT = .RouteProtocolNetMgmt;
    pub const PROTO_IP_NETMGMT = .RouteProtocolNetMgmt;
    pub const MIB_IPPROTO_ICMP = .RouteProtocolIcmp;
    pub const PROTO_IP_ICMP = .RouteProtocolIcmp;
    pub const MIB_IPPROTO_EGP = .RouteProtocolEgp;
    pub const PROTO_IP_EGP = .RouteProtocolEgp;
    pub const MIB_IPPROTO_GGP = .RouteProtocolGgp;
    pub const PROTO_IP_GGP = .RouteProtocolGgp;
    pub const MIB_IPPROTO_HELLO = .RouteProtocolHello;
    pub const PROTO_IP_HELLO = .RouteProtocolHello;
    pub const MIB_IPPROTO_RIP = .RouteProtocolRip;
    pub const PROTO_IP_RIP = .RouteProtocolRip;
    pub const MIB_IPPROTO_IS_IS = .RouteProtocolIsIs;
    pub const PROTO_IP_IS_IS = .RouteProtocolIsIs;
    pub const MIB_IPPROTO_ES_IS = .RouteProtocolEsIs;
    pub const PROTO_IP_ES_IS = .RouteProtocolEsIs;
    pub const MIB_IPPROTO_CISCO = .RouteProtocolCisco;
    pub const PROTO_IP_CISCO = .RouteProtocolCisco;
    pub const MIB_IPPROTO_BBN = .RouteProtocolBbn;
    pub const PROTO_IP_BBN = .RouteProtocolBbn;
    pub const MIB_IPPROTO_OSPF = .RouteProtocolOspf;
    pub const PROTO_IP_OSPF = .RouteProtocolOspf;
    pub const MIB_IPPROTO_BGP = .RouteProtocolBgp;
    pub const PROTO_IP_BGP = .RouteProtocolBgp;
    pub const MIB_IPPROTO_IDPR = .RouteProtocolIdpr;
    pub const PROTO_IP_IDPR = .RouteProtocolIdpr;
    pub const MIB_IPPROTO_EIGRP = .RouteProtocolEigrp;
    pub const PROTO_IP_EIGRP = .RouteProtocolEigrp;
    pub const MIB_IPPROTO_DVMRP = .RouteProtocolDvmrp;
    pub const PROTO_IP_DVMRP = .RouteProtocolDvmrp;
    pub const MIB_IPPROTO_RPL = .RouteProtocolRpl;
    pub const PROTO_IP_RPL = .RouteProtocolRpl;
    pub const MIB_IPPROTO_DHCP = .RouteProtocolDhcp;
    pub const PROTO_IP_DHCP = .RouteProtocolDhcp;
    pub const PROTO_IP_NT_AUTOSTATIC = .MIB_IPPROTO_NT_AUTOSTATIC;
    pub const PROTO_IP_NT_STATIC = .MIB_IPPROTO_NT_STATIC;
    pub const PROTO_IP_NT_STATIC_NON_DOD = .MIB_IPPROTO_NT_STATIC_NON_DOD;
};
pub const RouteProtocolOther = NL_ROUTE_PROTOCOL.RouteProtocolOther;
pub const RouteProtocolLocal = NL_ROUTE_PROTOCOL.RouteProtocolLocal;
pub const RouteProtocolNetMgmt = NL_ROUTE_PROTOCOL.RouteProtocolNetMgmt;
pub const RouteProtocolIcmp = NL_ROUTE_PROTOCOL.RouteProtocolIcmp;
pub const RouteProtocolEgp = NL_ROUTE_PROTOCOL.RouteProtocolEgp;
pub const RouteProtocolGgp = NL_ROUTE_PROTOCOL.RouteProtocolGgp;
pub const RouteProtocolHello = NL_ROUTE_PROTOCOL.RouteProtocolHello;
pub const RouteProtocolRip = NL_ROUTE_PROTOCOL.RouteProtocolRip;
pub const RouteProtocolIsIs = NL_ROUTE_PROTOCOL.RouteProtocolIsIs;
pub const RouteProtocolEsIs = NL_ROUTE_PROTOCOL.RouteProtocolEsIs;
pub const RouteProtocolCisco = NL_ROUTE_PROTOCOL.RouteProtocolCisco;
pub const RouteProtocolBbn = NL_ROUTE_PROTOCOL.RouteProtocolBbn;
pub const RouteProtocolOspf = NL_ROUTE_PROTOCOL.RouteProtocolOspf;
pub const RouteProtocolBgp = NL_ROUTE_PROTOCOL.RouteProtocolBgp;
pub const RouteProtocolIdpr = NL_ROUTE_PROTOCOL.RouteProtocolIdpr;
pub const RouteProtocolEigrp = NL_ROUTE_PROTOCOL.RouteProtocolEigrp;
pub const RouteProtocolDvmrp = NL_ROUTE_PROTOCOL.RouteProtocolDvmrp;
pub const RouteProtocolRpl = NL_ROUTE_PROTOCOL.RouteProtocolRpl;
pub const RouteProtocolDhcp = NL_ROUTE_PROTOCOL.RouteProtocolDhcp;
pub const MIB_IPPROTO_OTHER = NL_ROUTE_PROTOCOL.RouteProtocolOther;
pub const PROTO_IP_OTHER = NL_ROUTE_PROTOCOL.RouteProtocolOther;
pub const MIB_IPPROTO_LOCAL = NL_ROUTE_PROTOCOL.RouteProtocolLocal;
pub const PROTO_IP_LOCAL = NL_ROUTE_PROTOCOL.RouteProtocolLocal;
pub const MIB_IPPROTO_NETMGMT = NL_ROUTE_PROTOCOL.RouteProtocolNetMgmt;
pub const PROTO_IP_NETMGMT = NL_ROUTE_PROTOCOL.RouteProtocolNetMgmt;
pub const MIB_IPPROTO_ICMP = NL_ROUTE_PROTOCOL.RouteProtocolIcmp;
pub const PROTO_IP_ICMP = NL_ROUTE_PROTOCOL.RouteProtocolIcmp;
pub const MIB_IPPROTO_EGP = NL_ROUTE_PROTOCOL.RouteProtocolEgp;
pub const PROTO_IP_EGP = NL_ROUTE_PROTOCOL.RouteProtocolEgp;
pub const MIB_IPPROTO_GGP = NL_ROUTE_PROTOCOL.RouteProtocolGgp;
pub const PROTO_IP_GGP = NL_ROUTE_PROTOCOL.RouteProtocolGgp;
pub const MIB_IPPROTO_HELLO = NL_ROUTE_PROTOCOL.RouteProtocolHello;
pub const PROTO_IP_HELLO = NL_ROUTE_PROTOCOL.RouteProtocolHello;
pub const MIB_IPPROTO_RIP = NL_ROUTE_PROTOCOL.RouteProtocolRip;
pub const PROTO_IP_RIP = NL_ROUTE_PROTOCOL.RouteProtocolRip;
pub const MIB_IPPROTO_IS_IS = NL_ROUTE_PROTOCOL.RouteProtocolIsIs;
pub const PROTO_IP_IS_IS = NL_ROUTE_PROTOCOL.RouteProtocolIsIs;
pub const MIB_IPPROTO_ES_IS = NL_ROUTE_PROTOCOL.RouteProtocolEsIs;
pub const PROTO_IP_ES_IS = NL_ROUTE_PROTOCOL.RouteProtocolEsIs;
pub const MIB_IPPROTO_CISCO = NL_ROUTE_PROTOCOL.RouteProtocolCisco;
pub const PROTO_IP_CISCO = NL_ROUTE_PROTOCOL.RouteProtocolCisco;
pub const MIB_IPPROTO_BBN = NL_ROUTE_PROTOCOL.RouteProtocolBbn;
pub const PROTO_IP_BBN = NL_ROUTE_PROTOCOL.RouteProtocolBbn;
pub const MIB_IPPROTO_OSPF = NL_ROUTE_PROTOCOL.RouteProtocolOspf;
pub const PROTO_IP_OSPF = NL_ROUTE_PROTOCOL.RouteProtocolOspf;
pub const MIB_IPPROTO_BGP = NL_ROUTE_PROTOCOL.RouteProtocolBgp;
pub const PROTO_IP_BGP = NL_ROUTE_PROTOCOL.RouteProtocolBgp;
pub const MIB_IPPROTO_IDPR = NL_ROUTE_PROTOCOL.RouteProtocolIdpr;
pub const PROTO_IP_IDPR = NL_ROUTE_PROTOCOL.RouteProtocolIdpr;
pub const MIB_IPPROTO_EIGRP = NL_ROUTE_PROTOCOL.RouteProtocolEigrp;
pub const PROTO_IP_EIGRP = NL_ROUTE_PROTOCOL.RouteProtocolEigrp;
pub const MIB_IPPROTO_DVMRP = NL_ROUTE_PROTOCOL.RouteProtocolDvmrp;
pub const PROTO_IP_DVMRP = NL_ROUTE_PROTOCOL.RouteProtocolDvmrp;
pub const MIB_IPPROTO_RPL = NL_ROUTE_PROTOCOL.RouteProtocolRpl;
pub const PROTO_IP_RPL = NL_ROUTE_PROTOCOL.RouteProtocolRpl;
pub const MIB_IPPROTO_DHCP = NL_ROUTE_PROTOCOL.RouteProtocolDhcp;
pub const PROTO_IP_DHCP = NL_ROUTE_PROTOCOL.RouteProtocolDhcp;
pub const MIB_IPPROTO_NT_AUTOSTATIC = NL_ROUTE_PROTOCOL.MIB_IPPROTO_NT_AUTOSTATIC;
pub const PROTO_IP_NT_AUTOSTATIC = NL_ROUTE_PROTOCOL.MIB_IPPROTO_NT_AUTOSTATIC;
pub const MIB_IPPROTO_NT_STATIC = NL_ROUTE_PROTOCOL.MIB_IPPROTO_NT_STATIC;
pub const PROTO_IP_NT_STATIC = NL_ROUTE_PROTOCOL.MIB_IPPROTO_NT_STATIC;
pub const MIB_IPPROTO_NT_STATIC_NON_DOD = NL_ROUTE_PROTOCOL.MIB_IPPROTO_NT_STATIC_NON_DOD;
pub const PROTO_IP_NT_STATIC_NON_DOD = NL_ROUTE_PROTOCOL.MIB_IPPROTO_NT_STATIC_NON_DOD;

pub const NL_ADDRESS_TYPE = enum(i32) {
    Unspecified = 0,
    Unicast = 1,
    Anycast = 2,
    Multicast = 3,
    Broadcast = 4,
    Invalid = 5,
};
pub const NlatUnspecified = NL_ADDRESS_TYPE.Unspecified;
pub const NlatUnicast = NL_ADDRESS_TYPE.Unicast;
pub const NlatAnycast = NL_ADDRESS_TYPE.Anycast;
pub const NlatMulticast = NL_ADDRESS_TYPE.Multicast;
pub const NlatBroadcast = NL_ADDRESS_TYPE.Broadcast;
pub const NlatInvalid = NL_ADDRESS_TYPE.Invalid;

pub const NL_ROUTE_ORIGIN = enum(i32) {
    Manual = 0,
    WellKnown = 1,
    DHCP = 2,
    RouterAdvertisement = 3,
    @"6to4" = 4,
};
pub const NlroManual = NL_ROUTE_ORIGIN.Manual;
pub const NlroWellKnown = NL_ROUTE_ORIGIN.WellKnown;
pub const NlroDHCP = NL_ROUTE_ORIGIN.DHCP;
pub const NlroRouterAdvertisement = NL_ROUTE_ORIGIN.RouterAdvertisement;
pub const Nlro6to4 = NL_ROUTE_ORIGIN.@"6to4";

pub const NL_NEIGHBOR_STATE = enum(i32) {
    Unreachable = 0,
    Incomplete = 1,
    Probe = 2,
    Delay = 3,
    Stale = 4,
    Reachable = 5,
    Permanent = 6,
    Maximum = 7,
};
pub const NlnsUnreachable = NL_NEIGHBOR_STATE.Unreachable;
pub const NlnsIncomplete = NL_NEIGHBOR_STATE.Incomplete;
pub const NlnsProbe = NL_NEIGHBOR_STATE.Probe;
pub const NlnsDelay = NL_NEIGHBOR_STATE.Delay;
pub const NlnsStale = NL_NEIGHBOR_STATE.Stale;
pub const NlnsReachable = NL_NEIGHBOR_STATE.Reachable;
pub const NlnsPermanent = NL_NEIGHBOR_STATE.Permanent;
pub const NlnsMaximum = NL_NEIGHBOR_STATE.Maximum;

pub const NL_LINK_LOCAL_ADDRESS_BEHAVIOR = enum(i32) {
    AlwaysOff = 0,
    Delayed = 1,
    AlwaysOn = 2,
    Unchanged = -1,
};
pub const LinkLocalAlwaysOff = NL_LINK_LOCAL_ADDRESS_BEHAVIOR.AlwaysOff;
pub const LinkLocalDelayed = NL_LINK_LOCAL_ADDRESS_BEHAVIOR.Delayed;
pub const LinkLocalAlwaysOn = NL_LINK_LOCAL_ADDRESS_BEHAVIOR.AlwaysOn;
pub const LinkLocalUnchanged = NL_LINK_LOCAL_ADDRESS_BEHAVIOR.Unchanged;

pub const NL_INTERFACE_OFFLOAD_ROD = extern struct {
    _bitfield: u8,
};

pub const NL_ROUTER_DISCOVERY_BEHAVIOR = enum(i32) {
    Disabled = 0,
    Enabled = 1,
    Dhcp = 2,
    Unchanged = -1,
};
pub const RouterDiscoveryDisabled = NL_ROUTER_DISCOVERY_BEHAVIOR.Disabled;
pub const RouterDiscoveryEnabled = NL_ROUTER_DISCOVERY_BEHAVIOR.Enabled;
pub const RouterDiscoveryDhcp = NL_ROUTER_DISCOVERY_BEHAVIOR.Dhcp;
pub const RouterDiscoveryUnchanged = NL_ROUTER_DISCOVERY_BEHAVIOR.Unchanged;

pub const NL_BANDWIDTH_FLAG = enum(i32) {
    Disabled = 0,
    Enabled = 1,
    Unchanged = -1,
};
pub const NlbwDisabled = NL_BANDWIDTH_FLAG.Disabled;
pub const NlbwEnabled = NL_BANDWIDTH_FLAG.Enabled;
pub const NlbwUnchanged = NL_BANDWIDTH_FLAG.Unchanged;

pub const NL_PATH_BANDWIDTH_ROD = extern struct {
    Bandwidth: u64,
    Instability: u64,
    BandwidthPeaked: BOOLEAN,
};

pub const NL_NETWORK_CATEGORY = enum(i32) {
    Public = 0,
    Private = 1,
    DomainAuthenticated = 2,
    Unchanged = -1,
    pub const Unknown = .Unchanged;
};
pub const NetworkCategoryPublic = NL_NETWORK_CATEGORY.Public;
pub const NetworkCategoryPrivate = NL_NETWORK_CATEGORY.Private;
pub const NetworkCategoryDomainAuthenticated = NL_NETWORK_CATEGORY.DomainAuthenticated;
pub const NetworkCategoryUnchanged = NL_NETWORK_CATEGORY.Unchanged;
pub const NetworkCategoryUnknown = NL_NETWORK_CATEGORY.Unchanged;

pub const NL_INTERFACE_NETWORK_CATEGORY_STATE = enum(i32) {
    CategoryUnknown = 0,
    Public = 1,
    Private = 2,
    DomainAuthenticated = 3,
    CategoryStateMax = 4,
};
pub const NlincCategoryUnknown = NL_INTERFACE_NETWORK_CATEGORY_STATE.CategoryUnknown;
pub const NlincPublic = NL_INTERFACE_NETWORK_CATEGORY_STATE.Public;
pub const NlincPrivate = NL_INTERFACE_NETWORK_CATEGORY_STATE.Private;
pub const NlincDomainAuthenticated = NL_INTERFACE_NETWORK_CATEGORY_STATE.DomainAuthenticated;
pub const NlincCategoryStateMax = NL_INTERFACE_NETWORK_CATEGORY_STATE.CategoryStateMax;

pub const NL_NETWORK_CONNECTIVITY_LEVEL_HINT = enum(i32) {
    Unknown = 0,
    None = 1,
    LocalAccess = 2,
    InternetAccess = 3,
    ConstrainedInternetAccess = 4,
    Hidden = 5,
};
pub const NetworkConnectivityLevelHintUnknown = NL_NETWORK_CONNECTIVITY_LEVEL_HINT.Unknown;
pub const NetworkConnectivityLevelHintNone = NL_NETWORK_CONNECTIVITY_LEVEL_HINT.None;
pub const NetworkConnectivityLevelHintLocalAccess = NL_NETWORK_CONNECTIVITY_LEVEL_HINT.LocalAccess;
pub const NetworkConnectivityLevelHintInternetAccess = NL_NETWORK_CONNECTIVITY_LEVEL_HINT.InternetAccess;
pub const NetworkConnectivityLevelHintConstrainedInternetAccess = NL_NETWORK_CONNECTIVITY_LEVEL_HINT.ConstrainedInternetAccess;
pub const NetworkConnectivityLevelHintHidden = NL_NETWORK_CONNECTIVITY_LEVEL_HINT.Hidden;

pub const NL_NETWORK_CONNECTIVITY_COST_HINT = enum(i32) {
    Unknown = 0,
    Unrestricted = 1,
    Fixed = 2,
    Variable = 3,
};
pub const NetworkConnectivityCostHintUnknown = NL_NETWORK_CONNECTIVITY_COST_HINT.Unknown;
pub const NetworkConnectivityCostHintUnrestricted = NL_NETWORK_CONNECTIVITY_COST_HINT.Unrestricted;
pub const NetworkConnectivityCostHintFixed = NL_NETWORK_CONNECTIVITY_COST_HINT.Fixed;
pub const NetworkConnectivityCostHintVariable = NL_NETWORK_CONNECTIVITY_COST_HINT.Variable;

pub const NL_NETWORK_CONNECTIVITY_HINT = extern struct {
    ConnectivityLevel: NL_NETWORK_CONNECTIVITY_LEVEL_HINT,
    ConnectivityCost: NL_NETWORK_CONNECTIVITY_COST_HINT,
    ApproachingDataLimit: BOOLEAN,
    OverDataLimit: BOOLEAN,
    Roaming: BOOLEAN,
};

pub const NL_BANDWIDTH_INFORMATION = extern struct {
    Bandwidth: u64,
    Instability: u64,
    BandwidthPeaked: BOOLEAN,
};

pub const TCPSTATE = enum(i32) {
    CLOSED = 0,
    LISTEN = 1,
    SYN_SENT = 2,
    SYN_RCVD = 3,
    ESTABLISHED = 4,
    FIN_WAIT_1 = 5,
    FIN_WAIT_2 = 6,
    CLOSE_WAIT = 7,
    CLOSING = 8,
    LAST_ACK = 9,
    TIME_WAIT = 10,
    MAX = 11,
};
pub const TCPSTATE_CLOSED = TCPSTATE.CLOSED;
pub const TCPSTATE_LISTEN = TCPSTATE.LISTEN;
pub const TCPSTATE_SYN_SENT = TCPSTATE.SYN_SENT;
pub const TCPSTATE_SYN_RCVD = TCPSTATE.SYN_RCVD;
pub const TCPSTATE_ESTABLISHED = TCPSTATE.ESTABLISHED;
pub const TCPSTATE_FIN_WAIT_1 = TCPSTATE.FIN_WAIT_1;
pub const TCPSTATE_FIN_WAIT_2 = TCPSTATE.FIN_WAIT_2;
pub const TCPSTATE_CLOSE_WAIT = TCPSTATE.CLOSE_WAIT;
pub const TCPSTATE_CLOSING = TCPSTATE.CLOSING;
pub const TCPSTATE_LAST_ACK = TCPSTATE.LAST_ACK;
pub const TCPSTATE_TIME_WAIT = TCPSTATE.TIME_WAIT;
pub const TCPSTATE_MAX = TCPSTATE.MAX;

pub const TRANSPORT_SETTING_ID = extern struct {
    Guid: Guid,
};

pub const tcp_keepalive = extern struct {
    onoff: u32,
    keepalivetime: u32,
    keepaliveinterval: u32,
};

pub const CONTROL_CHANNEL_TRIGGER_STATUS = enum(i32) {
    INVALID = 0,
    SOFTWARE_SLOT_ALLOCATED = 1,
    HARDWARE_SLOT_ALLOCATED = 2,
    POLICY_ERROR = 3,
    SYSTEM_ERROR = 4,
    TRANSPORT_DISCONNECTED = 5,
    SERVICE_UNAVAILABLE = 6,
};
pub const CONTROL_CHANNEL_TRIGGER_STATUS_INVALID = CONTROL_CHANNEL_TRIGGER_STATUS.INVALID;
pub const CONTROL_CHANNEL_TRIGGER_STATUS_SOFTWARE_SLOT_ALLOCATED = CONTROL_CHANNEL_TRIGGER_STATUS.SOFTWARE_SLOT_ALLOCATED;
pub const CONTROL_CHANNEL_TRIGGER_STATUS_HARDWARE_SLOT_ALLOCATED = CONTROL_CHANNEL_TRIGGER_STATUS.HARDWARE_SLOT_ALLOCATED;
pub const CONTROL_CHANNEL_TRIGGER_STATUS_POLICY_ERROR = CONTROL_CHANNEL_TRIGGER_STATUS.POLICY_ERROR;
pub const CONTROL_CHANNEL_TRIGGER_STATUS_SYSTEM_ERROR = CONTROL_CHANNEL_TRIGGER_STATUS.SYSTEM_ERROR;
pub const CONTROL_CHANNEL_TRIGGER_STATUS_TRANSPORT_DISCONNECTED = CONTROL_CHANNEL_TRIGGER_STATUS.TRANSPORT_DISCONNECTED;
pub const CONTROL_CHANNEL_TRIGGER_STATUS_SERVICE_UNAVAILABLE = CONTROL_CHANNEL_TRIGGER_STATUS.SERVICE_UNAVAILABLE;

pub const REAL_TIME_NOTIFICATION_SETTING_INPUT = extern struct {
    TransportSettingId: TRANSPORT_SETTING_ID,
    BrokerEventGuid: Guid,
};

pub const REAL_TIME_NOTIFICATION_SETTING_INPUT_EX = extern struct {
    TransportSettingId: TRANSPORT_SETTING_ID,
    BrokerEventGuid: Guid,
    Unmark: BOOLEAN,
};

pub const REAL_TIME_NOTIFICATION_SETTING_OUTPUT = extern struct {
    ChannelStatus: CONTROL_CHANNEL_TRIGGER_STATUS,
};

pub const ASSOCIATE_NAMERES_CONTEXT_INPUT = extern struct {
    TransportSettingId: TRANSPORT_SETTING_ID,
    Handle: u64,
};

pub const TIMESTAMPING_CONFIG = extern struct {
    Flags: u32,
    TxTimestampsBuffered: u16,
};

pub const SOCKET_PRIORITY_HINT = enum(i32) {
    PriorityHintVeryLow = 0,
    PriorityHintLow = 1,
    PriorityHintNormal = 2,
    MaximumPriorityHintType = 3,
};
pub const SocketPriorityHintVeryLow = SOCKET_PRIORITY_HINT.PriorityHintVeryLow;
pub const SocketPriorityHintLow = SOCKET_PRIORITY_HINT.PriorityHintLow;
pub const SocketPriorityHintNormal = SOCKET_PRIORITY_HINT.PriorityHintNormal;
pub const SocketMaximumPriorityHintType = SOCKET_PRIORITY_HINT.MaximumPriorityHintType;

pub const PRIORITY_STATUS = extern struct {
    Sender: SOCKET_PRIORITY_HINT,
    Receiver: SOCKET_PRIORITY_HINT,
};

pub const RCVALL_VALUE = enum(i32) {
    OFF = 0,
    ON = 1,
    SOCKETLEVELONLY = 2,
    IPLEVEL = 3,
};
pub const RCVALL_OFF = RCVALL_VALUE.OFF;
pub const RCVALL_ON = RCVALL_VALUE.ON;
pub const RCVALL_SOCKETLEVELONLY = RCVALL_VALUE.SOCKETLEVELONLY;
pub const RCVALL_IPLEVEL = RCVALL_VALUE.IPLEVEL;

pub const RCVALL_IF = extern struct {
    Mode: RCVALL_VALUE,
    Interface: u32,
};

pub const TCP_INITIAL_RTO_PARAMETERS = extern struct {
    Rtt: u16,
    MaxSynRetransmissions: u8,
};

pub const TCP_ICW_LEVEL = enum(i32) {
    DEFAULT = 0,
    HIGH = 1,
    VERY_HIGH = 2,
    AGGRESSIVE = 3,
    EXPERIMENTAL = 4,
    COMPAT = 254,
    MAX = 255,
};
pub const TCP_ICW_LEVEL_DEFAULT = TCP_ICW_LEVEL.DEFAULT;
pub const TCP_ICW_LEVEL_HIGH = TCP_ICW_LEVEL.HIGH;
pub const TCP_ICW_LEVEL_VERY_HIGH = TCP_ICW_LEVEL.VERY_HIGH;
pub const TCP_ICW_LEVEL_AGGRESSIVE = TCP_ICW_LEVEL.AGGRESSIVE;
pub const TCP_ICW_LEVEL_EXPERIMENTAL = TCP_ICW_LEVEL.EXPERIMENTAL;
pub const TCP_ICW_LEVEL_COMPAT = TCP_ICW_LEVEL.COMPAT;
pub const TCP_ICW_LEVEL_MAX = TCP_ICW_LEVEL.MAX;

pub const TCP_ICW_PARAMETERS = extern struct {
    Level: TCP_ICW_LEVEL,
};

pub const TCP_ACK_FREQUENCY_PARAMETERS = extern struct {
    TcpDelayedAckFrequency: u8,
};

pub const TCP_INFO_v0 = extern struct {
    State: TCPSTATE,
    Mss: u32,
    ConnectionTimeMs: u64,
    TimestampsEnabled: BOOLEAN,
    RttUs: u32,
    MinRttUs: u32,
    BytesInFlight: u32,
    Cwnd: u32,
    SndWnd: u32,
    RcvWnd: u32,
    RcvBuf: u32,
    BytesOut: u64,
    BytesIn: u64,
    BytesReordered: u32,
    BytesRetrans: u32,
    FastRetrans: u32,
    DupAcksIn: u32,
    TimeoutEpisodes: u32,
    SynRetrans: u8,
};

pub const TCP_INFO_v1 = extern struct {
    State: TCPSTATE,
    Mss: u32,
    ConnectionTimeMs: u64,
    TimestampsEnabled: BOOLEAN,
    RttUs: u32,
    MinRttUs: u32,
    BytesInFlight: u32,
    Cwnd: u32,
    SndWnd: u32,
    RcvWnd: u32,
    RcvBuf: u32,
    BytesOut: u64,
    BytesIn: u64,
    BytesReordered: u32,
    BytesRetrans: u32,
    FastRetrans: u32,
    DupAcksIn: u32,
    TimeoutEpisodes: u32,
    SynRetrans: u8,
    SndLimTransRwin: u32,
    SndLimTimeRwin: u32,
    SndLimBytesRwin: u64,
    SndLimTransCwnd: u32,
    SndLimTimeCwnd: u32,
    SndLimBytesCwnd: u64,
    SndLimTransSnd: u32,
    SndLimTimeSnd: u32,
    SndLimBytesSnd: u64,
};

pub const INET_PORT_RANGE = extern struct {
    StartPort: u16,
    NumberOfPorts: u16,
};

pub const INET_PORT_RESERVATION_TOKEN = extern struct {
    Token: u64,
};

pub const INET_PORT_RESERVATION_INSTANCE = extern struct {
    Reservation: INET_PORT_RANGE,
    Token: INET_PORT_RESERVATION_TOKEN,
};

pub const INET_PORT_RESERVATION_INFORMATION = extern struct {
    OwningPid: u32,
};

pub const SOCKET_USAGE_TYPE = enum(i32) {
    T = 1,
};
pub const SYSTEM_CRITICAL_SOCKET = SOCKET_USAGE_TYPE.T;

pub const SOCKET_SECURITY_PROTOCOL = enum(i32) {
    DEFAULT = 0,
    IPSEC = 1,
    IPSEC2 = 2,
    INVALID = 3,
};
pub const SOCKET_SECURITY_PROTOCOL_DEFAULT = SOCKET_SECURITY_PROTOCOL.DEFAULT;
pub const SOCKET_SECURITY_PROTOCOL_IPSEC = SOCKET_SECURITY_PROTOCOL.IPSEC;
pub const SOCKET_SECURITY_PROTOCOL_IPSEC2 = SOCKET_SECURITY_PROTOCOL.IPSEC2;
pub const SOCKET_SECURITY_PROTOCOL_INVALID = SOCKET_SECURITY_PROTOCOL.INVALID;

pub const SOCKET_SECURITY_SETTINGS = extern struct {
    SecurityProtocol: SOCKET_SECURITY_PROTOCOL,
    SecurityFlags: u32,
};

pub const SOCKET_SECURITY_SETTINGS_IPSEC = extern struct {
    SecurityProtocol: SOCKET_SECURITY_PROTOCOL,
    SecurityFlags: u32,
    IpsecFlags: u32,
    AuthipMMPolicyKey: Guid,
    AuthipQMPolicyKey: Guid,
    Reserved: Guid,
    Reserved2: u64,
    UserNameStringLen: u32,
    DomainNameStringLen: u32,
    PasswordStringLen: u32,
    AllStrings: [1]u16,
};

pub const SOCKET_PEER_TARGET_NAME = extern struct {
    SecurityProtocol: SOCKET_SECURITY_PROTOCOL,
    PeerAddress: SOCKADDR_STORAGE,
    PeerTargetNameStringLen: u32,
    AllStrings: [1]u16,
};

pub const SOCKET_SECURITY_QUERY_TEMPLATE = extern struct {
    SecurityProtocol: SOCKET_SECURITY_PROTOCOL,
    PeerAddress: SOCKADDR_STORAGE,
    PeerTokenAccessMask: u32,
};

pub const SOCKET_SECURITY_QUERY_TEMPLATE_IPSEC2 = extern struct {
    SecurityProtocol: SOCKET_SECURITY_PROTOCOL,
    PeerAddress: SOCKADDR_STORAGE,
    PeerTokenAccessMask: u32,
    Flags: u32,
    FieldMask: u32,
};

pub const SOCKET_SECURITY_QUERY_INFO = extern struct {
    SecurityProtocol: SOCKET_SECURITY_PROTOCOL,
    Flags: u32,
    PeerApplicationAccessTokenHandle: u64,
    PeerMachineAccessTokenHandle: u64,
};

pub const SOCKET_SECURITY_QUERY_INFO_IPSEC2 = extern struct {
    SecurityProtocol: SOCKET_SECURITY_PROTOCOL,
    Flags: u32,
    PeerApplicationAccessTokenHandle: u64,
    PeerMachineAccessTokenHandle: u64,
    MmSaId: u64,
    QmSaId: u64,
    NegotiationWinerr: u32,
    SaLookupContext: Guid,
};

pub const RSS_SCALABILITY_INFO = extern struct {
    RssEnabled: BOOLEAN,
};

pub const WSA_COMPATIBILITY_BEHAVIOR_ID = enum(i32) {
    All = 0,
    ReceiveBuffering = 1,
    AutoTuning = 2,
};
pub const WsaBehaviorAll = WSA_COMPATIBILITY_BEHAVIOR_ID.All;
pub const WsaBehaviorReceiveBuffering = WSA_COMPATIBILITY_BEHAVIOR_ID.ReceiveBuffering;
pub const WsaBehaviorAutoTuning = WSA_COMPATIBILITY_BEHAVIOR_ID.AutoTuning;

pub const WSA_COMPATIBILITY_MODE = extern struct {
    BehaviorId: WSA_COMPATIBILITY_BEHAVIOR_ID,
    TargetOsVersion: u32,
};

pub const RIORESULT = extern struct {
    Status: i32,
    BytesTransferred: u32,
    SocketContext: u64,
    RequestContext: u64,
};

pub const RIO_BUF = extern struct {
    BufferId: ?*RIO_BUFFERID_t,
    Offset: u32,
    Length: u32,
};

pub const RIO_CMSG_BUFFER = extern struct {
    TotalLength: u32,
};

pub const ATM_ADDRESS = extern struct {
    AddressType: u32,
    NumofDigits: u32,
    Addr: [20]u8,
};

pub const ATM_BLLI = extern struct {
    Layer2Protocol: u32,
    Layer2UserSpecifiedProtocol: u32,
    Layer3Protocol: u32,
    Layer3UserSpecifiedProtocol: u32,
    Layer3IPI: u32,
    SnapID: [5]u8,
};

pub const ATM_BHLI = extern struct {
    HighLayerInfoType: u32,
    HighLayerInfoLength: u32,
    HighLayerInfo: [8]u8,
};

pub const sockaddr_atm = extern struct {
    satm_family: u16,
    satm_number: ATM_ADDRESS,
    satm_blli: ATM_BLLI,
    satm_bhli: ATM_BHLI,
};

pub const Q2931_IE_TYPE = enum(i32) {
    AALParameters = 0,
    TrafficDescriptor = 1,
    BroadbandBearerCapability = 2,
    BHLI = 3,
    BLLI = 4,
    CalledPartyNumber = 5,
    CalledPartySubaddress = 6,
    CallingPartyNumber = 7,
    CallingPartySubaddress = 8,
    Cause = 9,
    QOSClass = 10,
    TransitNetworkSelection = 11,
};
pub const IE_AALParameters = Q2931_IE_TYPE.AALParameters;
pub const IE_TrafficDescriptor = Q2931_IE_TYPE.TrafficDescriptor;
pub const IE_BroadbandBearerCapability = Q2931_IE_TYPE.BroadbandBearerCapability;
pub const IE_BHLI = Q2931_IE_TYPE.BHLI;
pub const IE_BLLI = Q2931_IE_TYPE.BLLI;
pub const IE_CalledPartyNumber = Q2931_IE_TYPE.CalledPartyNumber;
pub const IE_CalledPartySubaddress = Q2931_IE_TYPE.CalledPartySubaddress;
pub const IE_CallingPartyNumber = Q2931_IE_TYPE.CallingPartyNumber;
pub const IE_CallingPartySubaddress = Q2931_IE_TYPE.CallingPartySubaddress;
pub const IE_Cause = Q2931_IE_TYPE.Cause;
pub const IE_QOSClass = Q2931_IE_TYPE.QOSClass;
pub const IE_TransitNetworkSelection = Q2931_IE_TYPE.TransitNetworkSelection;

pub const Q2931_IE = extern struct {
    IEType: Q2931_IE_TYPE,
    IELength: u32,
    IE: [1]u8,
};

pub const AAL_TYPE = enum(i32) {
    @"5" = 5,
    USER = 16,
};
pub const AALTYPE_5 = AAL_TYPE.@"5";
pub const AALTYPE_USER = AAL_TYPE.USER;

pub const AAL5_PARAMETERS = extern struct {
    ForwardMaxCPCSSDUSize: u32,
    BackwardMaxCPCSSDUSize: u32,
    Mode: u8,
    SSCSType: u8,
};

pub const AALUSER_PARAMETERS = extern struct {
    UserDefined: u32,
};

pub const AAL_PARAMETERS_IE = extern struct {
    AALType: AAL_TYPE,
    AALSpecificParameters: extern union {
        AAL5Parameters: AAL5_PARAMETERS,
        AALUserParameters: AALUSER_PARAMETERS,
    },
};

pub const ATM_TD = extern struct {
    PeakCellRate_CLP0: u32,
    PeakCellRate_CLP01: u32,
    SustainableCellRate_CLP0: u32,
    SustainableCellRate_CLP01: u32,
    MaxBurstSize_CLP0: u32,
    MaxBurstSize_CLP01: u32,
    Tagging: BOOL,
};

pub const ATM_TRAFFIC_DESCRIPTOR_IE = extern struct {
    Forward: ATM_TD,
    Backward: ATM_TD,
    BestEffort: BOOL,
};

pub const ATM_BROADBAND_BEARER_CAPABILITY_IE = extern struct {
    BearerClass: u8,
    TrafficType: u8,
    TimingRequirements: u8,
    ClippingSusceptability: u8,
    UserPlaneConnectionConfig: u8,
};

pub const ATM_BLLI_IE = extern struct {
    Layer2Protocol: u32,
    Layer2Mode: u8,
    Layer2WindowSize: u8,
    Layer2UserSpecifiedProtocol: u32,
    Layer3Protocol: u32,
    Layer3Mode: u8,
    Layer3DefaultPacketSize: u8,
    Layer3PacketWindowSize: u8,
    Layer3UserSpecifiedProtocol: u32,
    Layer3IPI: u32,
    SnapID: [5]u8,
};

pub const ATM_CALLING_PARTY_NUMBER_IE = extern struct {
    ATM_Number: ATM_ADDRESS,
    Presentation_Indication: u8,
    Screening_Indicator: u8,
};

pub const ATM_CAUSE_IE = extern struct {
    Location: u8,
    Cause: u8,
    DiagnosticsLength: u8,
    Diagnostics: [4]u8,
};

pub const ATM_QOS_CLASS_IE = extern struct {
    QOSClassForward: u8,
    QOSClassBackward: u8,
};

pub const ATM_TRANSIT_NETWORK_SELECTION_IE = extern struct {
    TypeOfNetworkId: u8,
    NetworkIdPlan: u8,
    NetworkIdLength: u8,
    NetworkId: [1]u8,
};

pub const ATM_CONNECTION_ID = extern struct {
    DeviceNumber: u32,
    VPI: u32,
    VCI: u32,
};

pub const ATM_PVC_PARAMS = extern struct {
    PvcConnectionId: ATM_CONNECTION_ID align(4),
    PvcQos: QOS align(4),
};

pub const NAPI_PROVIDER_TYPE = enum(i32) {
    Application = 1,
    Service = 2,
};
pub const ProviderType_Application = NAPI_PROVIDER_TYPE.Application;
pub const ProviderType_Service = NAPI_PROVIDER_TYPE.Service;

pub const NAPI_PROVIDER_LEVEL = enum(i32) {
    None = 0,
    Secondary = 1,
    Primary = 2,
};
pub const ProviderLevel_None = NAPI_PROVIDER_LEVEL.None;
pub const ProviderLevel_Secondary = NAPI_PROVIDER_LEVEL.Secondary;
pub const ProviderLevel_Primary = NAPI_PROVIDER_LEVEL.Primary;

pub const NAPI_DOMAIN_DESCRIPTION_BLOB = extern struct {
    AuthLevel: u32,
    cchDomainName: u32,
    OffsetNextDomainDescription: u32,
    OffsetThisDomainName: u32,
};

pub const NAPI_PROVIDER_INSTALLATION_BLOB = extern struct {
    dwVersion: u32,
    dwProviderType: u32,
    fSupportsWildCard: u32,
    cDomains: u32,
    OffsetFirstDomain: u32,
};

pub const TRANSMIT_FILE_BUFFERS = extern struct {
    Head: ?*anyopaque,
    HeadLength: u32,
    Tail: ?*anyopaque,
    TailLength: u32,
};

pub const LPFN_TRANSMITFILE = *const fn(
    hSocket: ?SOCKET,
    hFile: ?HANDLE,
    nNumberOfBytesToWrite: u32,
    nNumberOfBytesPerSend: u32,
    lpOverlapped: ?*OVERLAPPED,
    lpTransmitBuffers: ?*TRANSMIT_FILE_BUFFERS,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const LPFN_ACCEPTEX = *const fn(
    sListenSocket: ?SOCKET,
    sAcceptSocket: ?SOCKET,
    lpOutputBuffer: ?*anyopaque,
    dwReceiveDataLength: u32,
    dwLocalAddressLength: u32,
    dwRemoteAddressLength: u32,
    lpdwBytesReceived: ?*u32,
    lpOverlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const LPFN_GETACCEPTEXSOCKADDRS = *const fn(
    lpOutputBuffer: ?*anyopaque,
    dwReceiveDataLength: u32,
    dwLocalAddressLength: u32,
    dwRemoteAddressLength: u32,
    LocalSockaddr: ?*?*SOCKADDR,
    LocalSockaddrLength: ?*i32,
    RemoteSockaddr: ?*?*SOCKADDR,
    RemoteSockaddrLength: ?*i32,
) callconv(@import("std").os.windows.WINAPI) void;

pub const TRANSMIT_PACKETS_ELEMENT = extern struct {
    dwElFlags: u32,
    cLength: u32,
    Anonymous: extern union {
        Anonymous: extern struct {
            nFileOffset: LARGE_INTEGER,
            hFile: ?HANDLE,
        },
        pBuffer: ?*anyopaque,
    },
};

pub const LPFN_TRANSMITPACKETS = *const fn(
    hSocket: ?SOCKET,
    lpPacketArray: ?*TRANSMIT_PACKETS_ELEMENT,
    nElementCount: u32,
    nSendSize: u32,
    lpOverlapped: ?*OVERLAPPED,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const LPFN_CONNECTEX = *const fn(
    s: ?SOCKET,
    // TODO: what to do with BytesParamIndex 2?
    name: ?*const SOCKADDR,
    namelen: i32,
    // TODO: what to do with BytesParamIndex 4?
    lpSendBuffer: ?*anyopaque,
    dwSendDataLength: u32,
    lpdwBytesSent: ?*u32,
    lpOverlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const LPFN_DISCONNECTEX = *const fn(
    s: ?SOCKET,
    lpOverlapped: ?*OVERLAPPED,
    dwFlags: u32,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const NLA_BLOB_DATA_TYPE = enum(i32) {
    RAW_DATA = 0,
    INTERFACE = 1,
    @"802_1X_LOCATION" = 2,
    CONNECTIVITY = 3,
    ICS = 4,
};
pub const NLA_RAW_DATA = NLA_BLOB_DATA_TYPE.RAW_DATA;
pub const NLA_INTERFACE = NLA_BLOB_DATA_TYPE.INTERFACE;
pub const NLA_802_1X_LOCATION = NLA_BLOB_DATA_TYPE.@"802_1X_LOCATION";
pub const NLA_CONNECTIVITY = NLA_BLOB_DATA_TYPE.CONNECTIVITY;
pub const NLA_ICS = NLA_BLOB_DATA_TYPE.ICS;

pub const NLA_CONNECTIVITY_TYPE = enum(i32) {
    AD_HOC = 0,
    MANAGED = 1,
    UNMANAGED = 2,
    UNKNOWN = 3,
};
pub const NLA_NETWORK_AD_HOC = NLA_CONNECTIVITY_TYPE.AD_HOC;
pub const NLA_NETWORK_MANAGED = NLA_CONNECTIVITY_TYPE.MANAGED;
pub const NLA_NETWORK_UNMANAGED = NLA_CONNECTIVITY_TYPE.UNMANAGED;
pub const NLA_NETWORK_UNKNOWN = NLA_CONNECTIVITY_TYPE.UNKNOWN;

pub const NLA_INTERNET = enum(i32) {
    UNKNOWN = 0,
    NO = 1,
    YES = 2,
};
pub const NLA_INTERNET_UNKNOWN = NLA_INTERNET.UNKNOWN;
pub const NLA_INTERNET_NO = NLA_INTERNET.NO;
pub const NLA_INTERNET_YES = NLA_INTERNET.YES;

pub const NLA_BLOB = extern struct {
    header: extern struct {
        type: NLA_BLOB_DATA_TYPE,
        dwSize: u32,
        nextOffset: u32,
    },
    data: extern union {
        rawData: [1]CHAR,
        interfaceData: extern struct {
            dwType: u32,
            dwSpeed: u32,
            adapterName: [1]CHAR,
        },
        locationData: extern struct {
            information: [1]CHAR,
        },
        connectivity: extern struct {
            type: NLA_CONNECTIVITY_TYPE,
            internet: NLA_INTERNET,
        },
        ICS: extern struct {
            remote: extern struct {
                speed: u32,
                type: u32,
                state: u32,
                machineName: [256]u16,
                sharedAdapterName: [256]u16,
            },
        },
    },
};

pub const LPFN_WSARECVMSG = *const fn(
    s: ?SOCKET,
    lpMsg: ?*WSAMSG,
    lpdwNumberOfBytesRecvd: ?*u32,
    lpOverlapped: ?*OVERLAPPED,
    lpCompletionRoutine: ?LPWSAOVERLAPPED_COMPLETION_ROUTINE,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const WSAPOLLDATA = extern struct {
    result: i32,
    fds: u32,
    timeout: i32,
    fdArray: [1]WSAPOLLFD,
};

pub const WSASENDMSG = extern struct {
    lpMsg: ?*WSAMSG,
    dwFlags: u32,
    lpNumberOfBytesSent: ?*u32,
    lpOverlapped: ?*OVERLAPPED,
    lpCompletionRoutine: ?LPWSAOVERLAPPED_COMPLETION_ROUTINE,
};

pub const LPFN_WSASENDMSG = *const fn(
    s: ?SOCKET,
    lpMsg: ?*WSAMSG,
    dwFlags: u32,
    lpNumberOfBytesSent: ?*u32,
    lpOverlapped: ?*OVERLAPPED,
    lpCompletionRoutine: ?LPWSAOVERLAPPED_COMPLETION_ROUTINE,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPFN_WSAPOLL = *const fn(
    fdarray: ?*WSAPOLLFD,
    nfds: u32,
    timeout: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPFN_RIORECEIVE = *const fn(
    SocketQueue: ?*RIO_RQ_t,
    pData: [*]RIO_BUF,
    DataBufferCount: u32,
    Flags: u32,
    RequestContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const LPFN_RIORECEIVEEX = *const fn(
    SocketQueue: ?*RIO_RQ_t,
    pData: [*]RIO_BUF,
    DataBufferCount: u32,
    pLocalAddress: ?*RIO_BUF,
    pRemoteAddress: ?*RIO_BUF,
    pControlContext: ?*RIO_BUF,
    pFlags: ?*RIO_BUF,
    Flags: u32,
    RequestContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPFN_RIOSEND = *const fn(
    SocketQueue: ?*RIO_RQ_t,
    pData: [*]RIO_BUF,
    DataBufferCount: u32,
    Flags: u32,
    RequestContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const LPFN_RIOSENDEX = *const fn(
    SocketQueue: ?*RIO_RQ_t,
    pData: [*]RIO_BUF,
    DataBufferCount: u32,
    pLocalAddress: ?*RIO_BUF,
    pRemoteAddress: ?*RIO_BUF,
    pControlContext: ?*RIO_BUF,
    pFlags: ?*RIO_BUF,
    Flags: u32,
    RequestContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const LPFN_RIOCLOSECOMPLETIONQUEUE = *const fn(
    CQ: ?*RIO_CQ_t,
) callconv(@import("std").os.windows.WINAPI) void;

pub const RIO_NOTIFICATION_COMPLETION_TYPE = enum(i32) {
    EVENT_COMPLETION = 1,
    IOCP_COMPLETION = 2,
};
pub const RIO_EVENT_COMPLETION = RIO_NOTIFICATION_COMPLETION_TYPE.EVENT_COMPLETION;
pub const RIO_IOCP_COMPLETION = RIO_NOTIFICATION_COMPLETION_TYPE.IOCP_COMPLETION;

pub const RIO_NOTIFICATION_COMPLETION = extern struct {
    Type: RIO_NOTIFICATION_COMPLETION_TYPE,
    Anonymous: extern union {
        Event: extern struct {
            EventHandle: ?HANDLE,
            NotifyReset: BOOL,
        },
        Iocp: extern struct {
            IocpHandle: ?HANDLE,
            CompletionKey: ?*anyopaque,
            Overlapped: ?*anyopaque,
        },
    },
};

pub const LPFN_RIOCREATECOMPLETIONQUEUE = *const fn(
    QueueSize: u32,
    NotificationCompletion: ?*RIO_NOTIFICATION_COMPLETION,
) callconv(@import("std").os.windows.WINAPI) ?*RIO_CQ_t;

pub const LPFN_RIOCREATEREQUESTQUEUE = *const fn(
    Socket: ?SOCKET,
    MaxOutstandingReceive: u32,
    MaxReceiveDataBuffers: u32,
    MaxOutstandingSend: u32,
    MaxSendDataBuffers: u32,
    ReceiveCQ: ?*RIO_CQ_t,
    SendCQ: ?*RIO_CQ_t,
    SocketContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) ?*RIO_RQ_t;

pub const LPFN_RIODEQUEUECOMPLETION = *const fn(
    CQ: ?*RIO_CQ_t,
    Array: [*]RIORESULT,
    ArraySize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPFN_RIODEREGISTERBUFFER = *const fn(
    BufferId: ?*RIO_BUFFERID_t,
) callconv(@import("std").os.windows.WINAPI) void;

pub const LPFN_RIONOTIFY = *const fn(
    CQ: ?*RIO_CQ_t,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPFN_RIOREGISTERBUFFER = *const fn(
    DataBuffer: ?[*]u8,
    DataLength: u32,
) callconv(@import("std").os.windows.WINAPI) ?*RIO_BUFFERID_t;

pub const LPFN_RIORESIZECOMPLETIONQUEUE = *const fn(
    CQ: ?*RIO_CQ_t,
    QueueSize: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const LPFN_RIORESIZEREQUESTQUEUE = *const fn(
    RQ: ?*RIO_RQ_t,
    MaxOutstandingReceive: u32,
    MaxOutstandingSend: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const RIO_EXTENSION_FUNCTION_TABLE = extern struct {
    cbSize: u32,
    RIOReceive: ?LPFN_RIORECEIVE,
    RIOReceiveEx: ?LPFN_RIORECEIVEEX,
    RIOSend: ?LPFN_RIOSEND,
    RIOSendEx: ?LPFN_RIOSENDEX,
    RIOCloseCompletionQueue: ?LPFN_RIOCLOSECOMPLETIONQUEUE,
    RIOCreateCompletionQueue: ?LPFN_RIOCREATECOMPLETIONQUEUE,
    RIOCreateRequestQueue: ?LPFN_RIOCREATEREQUESTQUEUE,
    RIODequeueCompletion: ?LPFN_RIODEQUEUECOMPLETION,
    RIODeregisterBuffer: ?LPFN_RIODEREGISTERBUFFER,
    RIONotify: ?LPFN_RIONOTIFY,
    RIORegisterBuffer: ?LPFN_RIOREGISTERBUFFER,
    RIOResizeCompletionQueue: ?LPFN_RIORESIZECOMPLETIONQUEUE,
    RIOResizeRequestQueue: ?LPFN_RIORESIZEREQUESTQUEUE,
};

pub const WSPData = extern struct {
    wVersion: u16,
    wHighVersion: u16,
    szDescription: [256]u16,
};

pub const WSATHREADID = extern struct {
    ThreadHandle: ?HANDLE,
    Reserved: usize,
};

pub const LPBLOCKINGCALLBACK = *const fn(
    dwContext: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const LPWSAUSERAPC = *const fn(
    dwContext: usize,
) callconv(@import("std").os.windows.WINAPI) void;

pub const LPWSPACCEPT = *const fn(
    s: ?SOCKET,
    // TODO: what to do with BytesParamIndex 2?
    addr: ?*SOCKADDR,
    addrlen: ?*i32,
    lpfnCondition: ?LPCONDITIONPROC,
    dwCallbackData: usize,
    lpErrno: ?*i32,
) callconv(@import("std").os.windows.WINAPI) ?SOCKET;

pub const LPWSPADDRESSTOSTRING = *const fn(
    // TODO: what to do with BytesParamIndex 1?
    lpsaAddress: ?*SOCKADDR,
    dwAddressLength: u32,
    lpProtocolInfo: ?*WSAPROTOCOL_INFOW,
    lpszAddressString: [*:0]u16,
    lpdwAddressStringLength: ?*u32,
    lpErrno: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSPASYNCSELECT = *const fn(
    s: ?SOCKET,
    hWnd: ?HWND,
    wMsg: u32,
    lEvent: i32,
    lpErrno: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSPBIND = *const fn(
    s: ?SOCKET,
    // TODO: what to do with BytesParamIndex 2?
    name: ?*const SOCKADDR,
    namelen: i32,
    lpErrno: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSPCANCELBLOCKINGCALL = *const fn(
    lpErrno: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSPCLEANUP = *const fn(
    lpErrno: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSPCLOSESOCKET = *const fn(
    s: ?SOCKET,
    lpErrno: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSPCONNECT = *const fn(
    s: ?SOCKET,
    // TODO: what to do with BytesParamIndex 2?
    name: ?*const SOCKADDR,
    namelen: i32,
    lpCallerData: ?*WSABUF,
    lpCalleeData: ?*WSABUF,
    lpSQOS: ?*QOS,
    lpGQOS: ?*QOS,
    lpErrno: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSPDUPLICATESOCKET = *const fn(
    s: ?SOCKET,
    dwProcessId: u32,
    lpProtocolInfo: ?*WSAPROTOCOL_INFOW,
    lpErrno: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSPENUMNETWORKEVENTS = *const fn(
    s: ?SOCKET,
    hEventObject: ?HANDLE,
    lpNetworkEvents: ?*WSANETWORKEVENTS,
    lpErrno: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSPEVENTSELECT = *const fn(
    s: ?SOCKET,
    hEventObject: ?HANDLE,
    lNetworkEvents: i32,
    lpErrno: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSPGETOVERLAPPEDRESULT = *const fn(
    s: ?SOCKET,
    lpOverlapped: ?*OVERLAPPED,
    lpcbTransfer: ?*u32,
    fWait: BOOL,
    lpdwFlags: ?*u32,
    lpErrno: ?*i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const LPWSPGETPEERNAME = *const fn(
    s: ?SOCKET,
    // TODO: what to do with BytesParamIndex 2?
    name: ?*SOCKADDR,
    namelen: ?*i32,
    lpErrno: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSPGETSOCKNAME = *const fn(
    s: ?SOCKET,
    // TODO: what to do with BytesParamIndex 2?
    name: ?*SOCKADDR,
    namelen: ?*i32,
    lpErrno: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSPGETSOCKOPT = *const fn(
    s: ?SOCKET,
    level: i32,
    optname: i32,
    // TODO: what to do with BytesParamIndex 4?
    optval: ?PSTR,
    optlen: ?*i32,
    lpErrno: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSPGETQOSBYNAME = *const fn(
    s: ?SOCKET,
    lpQOSName: ?*WSABUF,
    lpQOS: ?*QOS,
    lpErrno: ?*i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const LPWSPIOCTL = *const fn(
    s: ?SOCKET,
    dwIoControlCode: u32,
    // TODO: what to do with BytesParamIndex 3?
    lpvInBuffer: ?*anyopaque,
    cbInBuffer: u32,
    // TODO: what to do with BytesParamIndex 5?
    lpvOutBuffer: ?*anyopaque,
    cbOutBuffer: u32,
    lpcbBytesReturned: ?*u32,
    lpOverlapped: ?*OVERLAPPED,
    lpCompletionRoutine: ?LPWSAOVERLAPPED_COMPLETION_ROUTINE,
    lpThreadId: ?*WSATHREADID,
    lpErrno: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSPJOINLEAF = *const fn(
    s: ?SOCKET,
    // TODO: what to do with BytesParamIndex 2?
    name: ?*const SOCKADDR,
    namelen: i32,
    lpCallerData: ?*WSABUF,
    lpCalleeData: ?*WSABUF,
    lpSQOS: ?*QOS,
    lpGQOS: ?*QOS,
    dwFlags: u32,
    lpErrno: ?*i32,
) callconv(@import("std").os.windows.WINAPI) ?SOCKET;

pub const LPWSPLISTEN = *const fn(
    s: ?SOCKET,
    backlog: i32,
    lpErrno: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSPRECV = *const fn(
    s: ?SOCKET,
    lpBuffers: [*]WSABUF,
    dwBufferCount: u32,
    lpNumberOfBytesRecvd: ?*u32,
    lpFlags: ?*u32,
    lpOverlapped: ?*OVERLAPPED,
    lpCompletionRoutine: ?LPWSAOVERLAPPED_COMPLETION_ROUTINE,
    lpThreadId: ?*WSATHREADID,
    lpErrno: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSPRECVDISCONNECT = *const fn(
    s: ?SOCKET,
    lpInboundDisconnectData: ?*WSABUF,
    lpErrno: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSPRECVFROM = *const fn(
    s: ?SOCKET,
    lpBuffers: [*]WSABUF,
    dwBufferCount: u32,
    lpNumberOfBytesRecvd: ?*u32,
    lpFlags: ?*u32,
    // TODO: what to do with BytesParamIndex 6?
    lpFrom: ?*SOCKADDR,
    lpFromlen: ?*i32,
    lpOverlapped: ?*OVERLAPPED,
    lpCompletionRoutine: ?LPWSAOVERLAPPED_COMPLETION_ROUTINE,
    lpThreadId: ?*WSATHREADID,
    lpErrno: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSPSELECT = *const fn(
    nfds: i32,
    readfds: ?*fd_set,
    writefds: ?*fd_set,
    exceptfds: ?*fd_set,
    timeout: ?*const timeval,
    lpErrno: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSPSEND = *const fn(
    s: ?SOCKET,
    lpBuffers: [*]WSABUF,
    dwBufferCount: u32,
    lpNumberOfBytesSent: ?*u32,
    dwFlags: u32,
    lpOverlapped: ?*OVERLAPPED,
    lpCompletionRoutine: ?LPWSAOVERLAPPED_COMPLETION_ROUTINE,
    lpThreadId: ?*WSATHREADID,
    lpErrno: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSPSENDDISCONNECT = *const fn(
    s: ?SOCKET,
    lpOutboundDisconnectData: ?*WSABUF,
    lpErrno: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSPSENDTO = *const fn(
    s: ?SOCKET,
    lpBuffers: [*]WSABUF,
    dwBufferCount: u32,
    lpNumberOfBytesSent: ?*u32,
    dwFlags: u32,
    // TODO: what to do with BytesParamIndex 6?
    lpTo: ?*const SOCKADDR,
    iTolen: i32,
    lpOverlapped: ?*OVERLAPPED,
    lpCompletionRoutine: ?LPWSAOVERLAPPED_COMPLETION_ROUTINE,
    lpThreadId: ?*WSATHREADID,
    lpErrno: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSPSETSOCKOPT = *const fn(
    s: ?SOCKET,
    level: i32,
    optname: i32,
    // TODO: what to do with BytesParamIndex 4?
    optval: ?[*:0]const u8,
    optlen: i32,
    lpErrno: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSPSHUTDOWN = *const fn(
    s: ?SOCKET,
    how: i32,
    lpErrno: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSPSOCKET = *const fn(
    af: i32,
    type: i32,
    protocol: i32,
    lpProtocolInfo: ?*WSAPROTOCOL_INFOW,
    g: u32,
    dwFlags: u32,
    lpErrno: ?*i32,
) callconv(@import("std").os.windows.WINAPI) ?SOCKET;

pub const LPWSPSTRINGTOADDRESS = *const fn(
    AddressString: ?PWSTR,
    AddressFamily: i32,
    lpProtocolInfo: ?*WSAPROTOCOL_INFOW,
    // TODO: what to do with BytesParamIndex 4?
    lpAddress: ?*SOCKADDR,
    lpAddressLength: ?*i32,
    lpErrno: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const WSPPROC_TABLE = extern struct {
    lpWSPAccept: ?LPWSPACCEPT,
    lpWSPAddressToString: ?LPWSPADDRESSTOSTRING,
    lpWSPAsyncSelect: ?LPWSPASYNCSELECT,
    lpWSPBind: ?LPWSPBIND,
    lpWSPCancelBlockingCall: ?LPWSPCANCELBLOCKINGCALL,
    lpWSPCleanup: ?LPWSPCLEANUP,
    lpWSPCloseSocket: ?LPWSPCLOSESOCKET,
    lpWSPConnect: ?LPWSPCONNECT,
    lpWSPDuplicateSocket: ?LPWSPDUPLICATESOCKET,
    lpWSPEnumNetworkEvents: ?LPWSPENUMNETWORKEVENTS,
    lpWSPEventSelect: ?LPWSPEVENTSELECT,
    lpWSPGetOverlappedResult: ?LPWSPGETOVERLAPPEDRESULT,
    lpWSPGetPeerName: ?LPWSPGETPEERNAME,
    lpWSPGetSockName: ?LPWSPGETSOCKNAME,
    lpWSPGetSockOpt: ?LPWSPGETSOCKOPT,
    lpWSPGetQOSByName: ?LPWSPGETQOSBYNAME,
    lpWSPIoctl: ?LPWSPIOCTL,
    lpWSPJoinLeaf: ?LPWSPJOINLEAF,
    lpWSPListen: ?LPWSPLISTEN,
    lpWSPRecv: ?LPWSPRECV,
    lpWSPRecvDisconnect: ?LPWSPRECVDISCONNECT,
    lpWSPRecvFrom: ?LPWSPRECVFROM,
    lpWSPSelect: ?LPWSPSELECT,
    lpWSPSend: ?LPWSPSEND,
    lpWSPSendDisconnect: ?LPWSPSENDDISCONNECT,
    lpWSPSendTo: ?LPWSPSENDTO,
    lpWSPSetSockOpt: ?LPWSPSETSOCKOPT,
    lpWSPShutdown: ?LPWSPSHUTDOWN,
    lpWSPSocket: ?LPWSPSOCKET,
    lpWSPStringToAddress: ?LPWSPSTRINGTOADDRESS,
};

pub const LPWPUCLOSEEVENT = *const fn(
    hEvent: ?HANDLE,
    lpErrno: ?*i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const LPWPUCLOSESOCKETHANDLE = *const fn(
    s: ?SOCKET,
    lpErrno: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWPUCREATEEVENT = *const fn(
    lpErrno: ?*i32,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

pub const LPWPUCREATESOCKETHANDLE = *const fn(
    dwCatalogEntryId: u32,
    dwContext: usize,
    lpErrno: ?*i32,
) callconv(@import("std").os.windows.WINAPI) ?SOCKET;

pub const LPWPUFDISSET = *const fn(
    s: ?SOCKET,
    fdset: ?*fd_set,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWPUGETPROVIDERPATH = *const fn(
    lpProviderId: ?*Guid,
    lpszProviderDllPath: [*:0]u16,
    lpProviderDllPathLen: ?*i32,
    lpErrno: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWPUMODIFYIFSHANDLE = *const fn(
    dwCatalogEntryId: u32,
    ProposedHandle: ?SOCKET,
    lpErrno: ?*i32,
) callconv(@import("std").os.windows.WINAPI) ?SOCKET;

pub const LPWPUPOSTMESSAGE = *const fn(
    hWnd: ?HWND,
    Msg: u32,
    wParam: WPARAM,
    lParam: LPARAM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const LPWPUQUERYBLOCKINGCALLBACK = *const fn(
    dwCatalogEntryId: u32,
    lplpfnCallback: ?*?LPBLOCKINGCALLBACK,
    lpdwContext: ?*usize,
    lpErrno: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWPUQUERYSOCKETHANDLECONTEXT = *const fn(
    s: ?SOCKET,
    lpContext: ?*usize,
    lpErrno: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWPUQUEUEAPC = *const fn(
    lpThreadId: ?*WSATHREADID,
    lpfnUserApc: ?LPWSAUSERAPC,
    dwContext: usize,
    lpErrno: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWPURESETEVENT = *const fn(
    hEvent: ?HANDLE,
    lpErrno: ?*i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const LPWPUSETEVENT = *const fn(
    hEvent: ?HANDLE,
    lpErrno: ?*i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const LPWPUOPENCURRENTTHREAD = *const fn(
    lpThreadId: ?*WSATHREADID,
    lpErrno: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWPUCLOSETHREAD = *const fn(
    lpThreadId: ?*WSATHREADID,
    lpErrno: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWPUCOMPLETEOVERLAPPEDREQUEST = *const fn(
    s: ?SOCKET,
    lpOverlapped: ?*OVERLAPPED,
    dwError: u32,
    cbTransferred: u32,
    lpErrno: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const WSPUPCALLTABLE = extern struct {
    lpWPUCloseEvent: ?LPWPUCLOSEEVENT,
    lpWPUCloseSocketHandle: ?LPWPUCLOSESOCKETHANDLE,
    lpWPUCreateEvent: ?LPWPUCREATEEVENT,
    lpWPUCreateSocketHandle: ?LPWPUCREATESOCKETHANDLE,
    lpWPUFDIsSet: ?LPWPUFDISSET,
    lpWPUGetProviderPath: ?LPWPUGETPROVIDERPATH,
    lpWPUModifyIFSHandle: ?LPWPUMODIFYIFSHANDLE,
    lpWPUPostMessage: ?LPWPUPOSTMESSAGE,
    lpWPUQueryBlockingCallback: ?LPWPUQUERYBLOCKINGCALLBACK,
    lpWPUQuerySocketHandleContext: ?LPWPUQUERYSOCKETHANDLECONTEXT,
    lpWPUQueueApc: ?LPWPUQUEUEAPC,
    lpWPUResetEvent: ?LPWPURESETEVENT,
    lpWPUSetEvent: ?LPWPUSETEVENT,
    lpWPUOpenCurrentThread: ?LPWPUOPENCURRENTTHREAD,
    lpWPUCloseThread: ?LPWPUCLOSETHREAD,
};

pub const LPWSPSTARTUP = *const fn(
    wVersionRequested: u16,
    lpWSPData: ?*WSPData,
    lpProtocolInfo: ?*WSAPROTOCOL_INFOW,
    UpcallTable: WSPUPCALLTABLE,
    lpProcTable: ?*WSPPROC_TABLE,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSCENUMPROTOCOLS = *const fn(
    lpiProtocols: ?*i32,
    // TODO: what to do with BytesParamIndex 2?
    lpProtocolBuffer: ?*WSAPROTOCOL_INFOW,
    lpdwBufferLength: ?*u32,
    lpErrno: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSCDEINSTALLPROVIDER = *const fn(
    lpProviderId: ?*Guid,
    lpErrno: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSCINSTALLPROVIDER = *const fn(
    lpProviderId: ?*Guid,
    lpszProviderDllPath: ?[*:0]const u16,
    lpProtocolInfoList: [*]const WSAPROTOCOL_INFOW,
    dwNumberOfEntries: u32,
    lpErrno: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSCGETPROVIDERPATH = *const fn(
    lpProviderId: ?*Guid,
    lpszProviderDllPath: [*:0]u16,
    lpProviderDllPathLen: ?*i32,
    lpErrno: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSCUPDATEPROVIDER = *const fn(
    lpProviderId: ?*Guid,
    lpszProviderDllPath: ?[*:0]const u16,
    lpProtocolInfoList: [*]const WSAPROTOCOL_INFOW,
    dwNumberOfEntries: u32,
    lpErrno: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const WSC_PROVIDER_INFO_TYPE = enum(i32) {
    LspCategories = 0,
    Audit = 1,
};
pub const ProviderInfoLspCategories = WSC_PROVIDER_INFO_TYPE.LspCategories;
pub const ProviderInfoAudit = WSC_PROVIDER_INFO_TYPE.Audit;

pub const WSC_PROVIDER_AUDIT_INFO = extern struct {
    RecordSize: u32,
    Reserved: ?*anyopaque,
};

pub const LPWSCINSTALLNAMESPACE = *const fn(
    lpszIdentifier: ?PWSTR,
    lpszPathName: ?PWSTR,
    dwNameSpace: u32,
    dwVersion: u32,
    lpProviderId: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSCUNINSTALLNAMESPACE = *const fn(
    lpProviderId: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSCENABLENSPROVIDER = *const fn(
    lpProviderId: ?*Guid,
    fEnable: BOOL,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPNSPCLEANUP = *const fn(
    lpProviderId: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPNSPLOOKUPSERVICEBEGIN = *const fn(
    lpProviderId: ?*Guid,
    lpqsRestrictions: ?*WSAQUERYSETW,
    lpServiceClassInfo: ?*WSASERVICECLASSINFOW,
    dwControlFlags: u32,
    lphLookup: ?*?HANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPNSPLOOKUPSERVICENEXT = *const fn(
    hLookup: ?HANDLE,
    dwControlFlags: u32,
    lpdwBufferLength: ?*u32,
    // TODO: what to do with BytesParamIndex 2?
    lpqsResults: ?*WSAQUERYSETW,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPNSPIOCTL = *const fn(
    hLookup: ?HANDLE,
    dwControlCode: u32,
    // TODO: what to do with BytesParamIndex 3?
    lpvInBuffer: ?*anyopaque,
    cbInBuffer: u32,
    // TODO: what to do with BytesParamIndex 5?
    lpvOutBuffer: ?*anyopaque,
    cbOutBuffer: u32,
    lpcbBytesReturned: ?*u32,
    lpCompletion: ?*WSACOMPLETION,
    lpThreadId: ?*WSATHREADID,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPNSPLOOKUPSERVICEEND = *const fn(
    hLookup: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPNSPSETSERVICE = *const fn(
    lpProviderId: ?*Guid,
    lpServiceClassInfo: ?*WSASERVICECLASSINFOW,
    lpqsRegInfo: ?*WSAQUERYSETW,
    essOperation: WSAESETSERVICEOP,
    dwControlFlags: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPNSPINSTALLSERVICECLASS = *const fn(
    lpProviderId: ?*Guid,
    lpServiceClassInfo: ?*WSASERVICECLASSINFOW,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPNSPREMOVESERVICECLASS = *const fn(
    lpProviderId: ?*Guid,
    lpServiceClassId: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPNSPGETSERVICECLASSINFO = *const fn(
    lpProviderId: ?*Guid,
    lpdwBufSize: ?*u32,
    lpServiceClassInfo: ?*WSASERVICECLASSINFOW,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const NSP_ROUTINE = extern struct {
    cbSize: u32,
    dwMajorVersion: u32,
    dwMinorVersion: u32,
    NSPCleanup: ?LPNSPCLEANUP,
    NSPLookupServiceBegin: ?LPNSPLOOKUPSERVICEBEGIN,
    NSPLookupServiceNext: ?LPNSPLOOKUPSERVICENEXT,
    NSPLookupServiceEnd: ?LPNSPLOOKUPSERVICEEND,
    NSPSetService: ?LPNSPSETSERVICE,
    NSPInstallServiceClass: ?LPNSPINSTALLSERVICECLASS,
    NSPRemoveServiceClass: ?LPNSPREMOVESERVICECLASS,
    NSPGetServiceClassInfo: ?LPNSPGETSERVICECLASSINFO,
    NSPIoctl: ?LPNSPIOCTL,
};

pub const LPNSPSTARTUP = *const fn(
    lpProviderId: ?*Guid,
    lpnspRoutines: ?*NSP_ROUTINE,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPNSPV2STARTUP = *const fn(
    lpProviderId: ?*Guid,
    ppvClientSessionArg: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPNSPV2CLEANUP = *const fn(
    lpProviderId: ?*Guid,
    pvClientSessionArg: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPNSPV2LOOKUPSERVICEBEGIN = *const fn(
    lpProviderId: ?*Guid,
    lpqsRestrictions: ?*WSAQUERYSET2W,
    dwControlFlags: u32,
    lpvClientSessionArg: ?*anyopaque,
    lphLookup: ?*?HANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPNSPV2LOOKUPSERVICENEXTEX = *const fn(
    hAsyncCall: ?HANDLE,
    hLookup: ?HANDLE,
    dwControlFlags: u32,
    lpdwBufferLength: ?*u32,
    lpqsResults: ?*WSAQUERYSET2W,
) callconv(@import("std").os.windows.WINAPI) void;

pub const LPNSPV2LOOKUPSERVICEEND = *const fn(
    hLookup: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPNSPV2SETSERVICEEX = *const fn(
    hAsyncCall: ?HANDLE,
    lpProviderId: ?*Guid,
    lpqsRegInfo: ?*WSAQUERYSET2W,
    essOperation: WSAESETSERVICEOP,
    dwControlFlags: u32,
    lpvClientSessionArg: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

pub const LPNSPV2CLIENTSESSIONRUNDOWN = *const fn(
    lpProviderId: ?*Guid,
    pvClientSessionArg: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

pub const NSPV2_ROUTINE = extern struct {
    cbSize: u32,
    dwMajorVersion: u32,
    dwMinorVersion: u32,
    NSPv2Startup: ?LPNSPV2STARTUP,
    NSPv2Cleanup: ?LPNSPV2CLEANUP,
    NSPv2LookupServiceBegin: ?LPNSPV2LOOKUPSERVICEBEGIN,
    NSPv2LookupServiceNextEx: ?LPNSPV2LOOKUPSERVICENEXTEX,
    NSPv2LookupServiceEnd: ?LPNSPV2LOOKUPSERVICEEND,
    NSPv2SetServiceEx: ?LPNSPV2SETSERVICEEX,
    NSPv2ClientSessionRundown: ?LPNSPV2CLIENTSESSIONRUNDOWN,
};

pub const NS_INFOA = extern struct {
    dwNameSpace: u32,
    dwNameSpaceFlags: u32,
    lpNameSpace: ?PSTR,
};

pub const NS_INFOW = extern struct {
    dwNameSpace: u32,
    dwNameSpaceFlags: u32,
    lpNameSpace: ?PWSTR,
};

pub const SERVICE_TYPE_VALUE = extern struct {
    dwNameSpace: u32,
    dwValueType: u32,
    dwValueSize: u32,
    dwValueNameOffset: u32,
    dwValueOffset: u32,
};

pub const SERVICE_TYPE_VALUE_ABSA = extern struct {
    dwNameSpace: u32,
    dwValueType: u32,
    dwValueSize: u32,
    lpValueName: ?PSTR,
    lpValue: ?*anyopaque,
};

pub const SERVICE_TYPE_VALUE_ABSW = extern struct {
    dwNameSpace: u32,
    dwValueType: u32,
    dwValueSize: u32,
    lpValueName: ?PWSTR,
    lpValue: ?*anyopaque,
};

pub const SERVICE_TYPE_INFO = extern struct {
    dwTypeNameOffset: u32,
    dwValueCount: u32,
    Values: [1]SERVICE_TYPE_VALUE,
};

pub const SERVICE_TYPE_INFO_ABSA = extern struct {
    lpTypeName: ?PSTR,
    dwValueCount: u32,
    Values: [1]SERVICE_TYPE_VALUE_ABSA,
};

pub const SERVICE_TYPE_INFO_ABSW = extern struct {
    lpTypeName: ?PWSTR,
    dwValueCount: u32,
    Values: [1]SERVICE_TYPE_VALUE_ABSW,
};

pub const SERVICE_ADDRESS = extern struct {
    dwAddressType: u32,
    dwAddressFlags: u32,
    dwAddressLength: u32,
    dwPrincipalLength: u32,
    lpAddress: ?*u8,
    lpPrincipal: ?*u8,
};

pub const SERVICE_ADDRESSES = extern struct {
    dwAddressCount: u32,
    Addresses: [1]SERVICE_ADDRESS,
};

pub const SERVICE_INFOA = extern struct {
    lpServiceType: ?*Guid,
    lpServiceName: ?PSTR,
    lpComment: ?PSTR,
    lpLocale: ?PSTR,
    dwDisplayHint: RESOURCE_DISPLAY_TYPE,
    dwVersion: u32,
    dwTime: u32,
    lpMachineName: ?PSTR,
    lpServiceAddress: ?*SERVICE_ADDRESSES,
    ServiceSpecificInfo: BLOB,
};

pub const SERVICE_INFOW = extern struct {
    lpServiceType: ?*Guid,
    lpServiceName: ?PWSTR,
    lpComment: ?PWSTR,
    lpLocale: ?PWSTR,
    dwDisplayHint: RESOURCE_DISPLAY_TYPE,
    dwVersion: u32,
    dwTime: u32,
    lpMachineName: ?PWSTR,
    lpServiceAddress: ?*SERVICE_ADDRESSES,
    ServiceSpecificInfo: BLOB,
};

pub const NS_SERVICE_INFOA = extern struct {
    dwNameSpace: u32,
    ServiceInfo: SERVICE_INFOA,
};

pub const NS_SERVICE_INFOW = extern struct {
    dwNameSpace: u32,
    ServiceInfo: SERVICE_INFOW,
};

pub const PROTOCOL_INFOA = extern struct {
    dwServiceFlags: u32,
    iAddressFamily: i32,
    iMaxSockAddr: i32,
    iMinSockAddr: i32,
    iSocketType: i32,
    iProtocol: i32,
    dwMessageSize: u32,
    lpProtocol: ?PSTR,
};

pub const PROTOCOL_INFOW = extern struct {
    dwServiceFlags: u32,
    iAddressFamily: i32,
    iMaxSockAddr: i32,
    iMinSockAddr: i32,
    iSocketType: i32,
    iProtocol: i32,
    dwMessageSize: u32,
    lpProtocol: ?PWSTR,
};

pub const NETRESOURCE2A = extern struct {
    dwScope: u32,
    dwType: u32,
    dwUsage: u32,
    dwDisplayType: u32,
    lpLocalName: ?PSTR,
    lpRemoteName: ?PSTR,
    lpComment: ?PSTR,
    ns_info: NS_INFOA,
    ServiceType: Guid,
    dwProtocols: u32,
    lpiProtocols: ?*i32,
};

pub const NETRESOURCE2W = extern struct {
    dwScope: u32,
    dwType: u32,
    dwUsage: u32,
    dwDisplayType: u32,
    lpLocalName: ?PWSTR,
    lpRemoteName: ?PWSTR,
    lpComment: ?PWSTR,
    ns_info: NS_INFOA,
    ServiceType: Guid,
    dwProtocols: u32,
    lpiProtocols: ?*i32,
};

pub const LPFN_NSPAPI = *const fn(
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPSERVICE_CALLBACK_PROC = *const fn(
    lParam: LPARAM,
    hAsyncTaskHandle: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) void;

pub const SERVICE_ASYNC_INFO = extern struct {
    lpServiceCallbackProc: ?LPSERVICE_CALLBACK_PROC,
    lParam: LPARAM,
    hAsyncTaskHandle: ?HANDLE,
};

pub const LPLOOKUPSERVICE_COMPLETION_ROUTINE = *const fn(
    dwError: u32,
    dwBytes: u32,
    lpOverlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) void;

pub const LPWSCWRITEPROVIDERORDER = *const fn(
    lpwdCatalogEntryId: ?*u32,
    dwNumberOfEntries: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSCWRITENAMESPACEORDER = *const fn(
    lpProviderId: ?*Guid,
    dwNumberOfEntries: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const sockaddr_un = extern struct {
    sun_family: u16,
    sun_path: [108]CHAR,
};

pub const sockaddr_ipx = extern struct {
    sa_family: i16,
    sa_netnum: [4]CHAR,
    sa_nodenum: [6]CHAR,
    sa_socket: u16,
};

pub const sockaddr_tp = extern struct {
    tp_family: u16,
    tp_addr_type: u16,
    tp_taddr_len: u16,
    tp_tsel_len: u16,
    tp_addr: [64]u8,
};

pub const sockaddr_nb = extern struct {
    snb_family: i16,
    snb_type: u16,
    snb_name: [16]CHAR,
};

pub const sockaddr_vns = extern struct {
    sin_family: u16,
    net_address: [4]u8,
    subnet_addr: [2]u8,
    port: [2]u8,
    hops: u8,
    filler: [5]u8,
};

pub const DL_OUI = extern union {
    Byte: [3]u8,
    Anonymous: extern struct {
        _bitfield: u8,
    },
};

pub const DL_EI48 = extern union {
    Byte: [3]u8,
};

pub const DL_EUI48 = extern union {
    Byte: [6]u8,
    Anonymous: extern struct {
        Oui: DL_OUI,
        Ei48: DL_EI48,
    },
};

pub const DL_EI64 = extern union {
    Byte: [5]u8,
};

pub const DL_EUI64 = extern union {
    Byte: [8]u8,
    Value: u64,
    Anonymous: extern struct {
        Oui: DL_OUI,
        Anonymous: extern union {
            Ei64: DL_EI64,
            Anonymous: extern struct {
                Type: u8,
                Tse: u8,
                Ei48: DL_EI48,
            },
        },
    },
};

pub const SNAP_HEADER = extern struct {
    Dsap: u8,
    Ssap: u8,
    Control: u8,
    Oui: [3]u8,
    Type: u16,
};

pub const ETHERNET_HEADER = extern struct {
    Destination: DL_EUI48,
    Source: DL_EUI48,
    Anonymous: extern union {
        Type: u16,
        Length: u16,
    },
};

pub const VLAN_TAG = extern struct {
    Anonymous: extern union {
        Tag: u16,
        Anonymous: extern struct {
            _bitfield: u16,
        },
    },
    Type: u16,
};

pub const ICMP_HEADER = extern struct {
    Type: u8,
    Code: u8,
    Checksum: u16,
};

pub const ICMP_MESSAGE = extern struct {
    Header: ICMP_HEADER,
    Data: extern union {
        Data32: [1]u32,
        Data16: [2]u16,
        Data8: [4]u8,
    },
};

pub const IPV4_HEADER = extern struct {
    Anonymous1: extern union {
        VersionAndHeaderLength: u8,
        Anonymous: extern struct {
            _bitfield: u8,
        },
    },
    Anonymous2: extern union {
        TypeOfServiceAndEcnField: u8,
        Anonymous: extern struct {
            _bitfield: u8,
        },
    },
    TotalLength: u16,
    Identification: u16,
    Anonymous3: extern union {
        FlagsAndOffset: u16,
        Anonymous: extern struct {
            _bitfield: u16,
        },
    },
    TimeToLive: u8,
    Protocol: u8,
    HeaderChecksum: u16,
    SourceAddress: IN_ADDR,
    DestinationAddress: IN_ADDR,
};

pub const IPV4_OPTION_HEADER = extern struct {
    Anonymous: extern union {
        OptionType: u8,
        Anonymous: extern struct {
            _bitfield: u8,
        },
    },
    OptionLength: u8,
};

pub const IPV4_OPTION_TYPE = enum(i32) {
    EOL = 0,
    NOP = 1,
    SECURITY = 130,
    LSRR = 131,
    TS = 68,
    RR = 7,
    SSRR = 137,
    SID = 136,
    ROUTER_ALERT = 148,
    MULTIDEST = 149,
};
pub const IP_OPT_EOL = IPV4_OPTION_TYPE.EOL;
pub const IP_OPT_NOP = IPV4_OPTION_TYPE.NOP;
pub const IP_OPT_SECURITY = IPV4_OPTION_TYPE.SECURITY;
pub const IP_OPT_LSRR = IPV4_OPTION_TYPE.LSRR;
pub const IP_OPT_TS = IPV4_OPTION_TYPE.TS;
pub const IP_OPT_RR = IPV4_OPTION_TYPE.RR;
pub const IP_OPT_SSRR = IPV4_OPTION_TYPE.SSRR;
pub const IP_OPT_SID = IPV4_OPTION_TYPE.SID;
pub const IP_OPT_ROUTER_ALERT = IPV4_OPTION_TYPE.ROUTER_ALERT;
pub const IP_OPT_MULTIDEST = IPV4_OPTION_TYPE.MULTIDEST;

pub const IPV4_TIMESTAMP_OPTION = extern struct {
    OptionHeader: IPV4_OPTION_HEADER,
    Pointer: u8,
    Anonymous: extern union {
        FlagsOverflow: u8,
        Anonymous: extern struct {
            _bitfield: u8,
        },
    },
};

pub const IP_OPTION_TIMESTAMP_FLAGS = enum(i32) {
    ONLY = 0,
    ADDRESS = 1,
    SPECIFIC_ADDRESS = 3,
};
pub const IP_OPTION_TIMESTAMP_ONLY = IP_OPTION_TIMESTAMP_FLAGS.ONLY;
pub const IP_OPTION_TIMESTAMP_ADDRESS = IP_OPTION_TIMESTAMP_FLAGS.ADDRESS;
pub const IP_OPTION_TIMESTAMP_SPECIFIC_ADDRESS = IP_OPTION_TIMESTAMP_FLAGS.SPECIFIC_ADDRESS;

pub const IPV4_ROUTING_HEADER = extern struct {
    OptionHeader: IPV4_OPTION_HEADER,
    Pointer: u8,
};

pub const ICMP4_UNREACH_CODE = enum(i32) {
    NET = 0,
    HOST = 1,
    PROTOCOL = 2,
    PORT = 3,
    FRAG_NEEDED = 4,
    SOURCEROUTE_FAILED = 5,
    NET_UNKNOWN = 6,
    HOST_UNKNOWN = 7,
    ISOLATED = 8,
    NET_ADMIN = 9,
    HOST_ADMIN = 10,
    NET_TOS = 11,
    HOST_TOS = 12,
    ADMIN = 13,
};
pub const ICMP4_UNREACH_NET = ICMP4_UNREACH_CODE.NET;
pub const ICMP4_UNREACH_HOST = ICMP4_UNREACH_CODE.HOST;
pub const ICMP4_UNREACH_PROTOCOL = ICMP4_UNREACH_CODE.PROTOCOL;
pub const ICMP4_UNREACH_PORT = ICMP4_UNREACH_CODE.PORT;
pub const ICMP4_UNREACH_FRAG_NEEDED = ICMP4_UNREACH_CODE.FRAG_NEEDED;
pub const ICMP4_UNREACH_SOURCEROUTE_FAILED = ICMP4_UNREACH_CODE.SOURCEROUTE_FAILED;
pub const ICMP4_UNREACH_NET_UNKNOWN = ICMP4_UNREACH_CODE.NET_UNKNOWN;
pub const ICMP4_UNREACH_HOST_UNKNOWN = ICMP4_UNREACH_CODE.HOST_UNKNOWN;
pub const ICMP4_UNREACH_ISOLATED = ICMP4_UNREACH_CODE.ISOLATED;
pub const ICMP4_UNREACH_NET_ADMIN = ICMP4_UNREACH_CODE.NET_ADMIN;
pub const ICMP4_UNREACH_HOST_ADMIN = ICMP4_UNREACH_CODE.HOST_ADMIN;
pub const ICMP4_UNREACH_NET_TOS = ICMP4_UNREACH_CODE.NET_TOS;
pub const ICMP4_UNREACH_HOST_TOS = ICMP4_UNREACH_CODE.HOST_TOS;
pub const ICMP4_UNREACH_ADMIN = ICMP4_UNREACH_CODE.ADMIN;

pub const ICMP4_TIME_EXCEED_CODE = enum(i32) {
    TRANSIT = 0,
    REASSEMBLY = 1,
};
pub const ICMP4_TIME_EXCEED_TRANSIT = ICMP4_TIME_EXCEED_CODE.TRANSIT;
pub const ICMP4_TIME_EXCEED_REASSEMBLY = ICMP4_TIME_EXCEED_CODE.REASSEMBLY;

pub const ICMPV4_ROUTER_SOLICIT = extern struct {
    RsHeader: ICMP_MESSAGE,
};

pub const ICMPV4_ROUTER_ADVERT_HEADER = extern struct {
    RaHeader: ICMP_MESSAGE,
};

pub const ICMPV4_ROUTER_ADVERT_ENTRY = extern struct {
    RouterAdvertAddr: IN_ADDR,
    PreferenceLevel: i32,
};

pub const ICMPV4_TIMESTAMP_MESSAGE = extern struct {
    Header: ICMP_MESSAGE,
    OriginateTimestamp: u32,
    ReceiveTimestamp: u32,
    TransmitTimestamp: u32,
};

pub const ICMPV4_ADDRESS_MASK_MESSAGE = extern struct {
    Header: ICMP_MESSAGE,
    AddressMask: u32,
};

pub const ARP_HEADER = extern struct {
    HardwareAddressSpace: u16,
    ProtocolAddressSpace: u16,
    HardwareAddressLength: u8,
    ProtocolAddressLength: u8,
    Opcode: u16,
    SenderHardwareAddress: [1]u8,
};

pub const ARP_OPCODE = enum(i32) {
    QUEST = 1,
    SPONSE = 2,
};
pub const ARP_REQUEST = ARP_OPCODE.QUEST;
pub const ARP_RESPONSE = ARP_OPCODE.SPONSE;

pub const ARP_HARDWARE_TYPE = enum(i32) {
    ENET = 1,
    @"802" = 6,
};
pub const ARP_HW_ENET = ARP_HARDWARE_TYPE.ENET;
pub const ARP_HW_802 = ARP_HARDWARE_TYPE.@"802";

pub const IGMP_HEADER = extern struct {
    Anonymous1: extern union {
        Anonymous: extern struct {
            _bitfield: u8,
        },
        VersionType: u8,
    },
    Anonymous2: extern union {
        Reserved: u8,
        MaxRespTime: u8,
        Code: u8,
    },
    Checksum: u16,
    MulticastAddress: IN_ADDR,
};

pub const IGMP_MAX_RESP_CODE_TYPE = enum(i32) {
    NORMAL = 0,
    FLOAT = 1,
};
pub const IGMP_MAX_RESP_CODE_TYPE_NORMAL = IGMP_MAX_RESP_CODE_TYPE.NORMAL;
pub const IGMP_MAX_RESP_CODE_TYPE_FLOAT = IGMP_MAX_RESP_CODE_TYPE.FLOAT;

pub const IGMPV3_QUERY_HEADER = extern struct {
    Type: u8,
    Anonymous1: extern union {
        MaxRespCode: u8,
        Anonymous: extern struct {
            _bitfield: u8,
        },
    },
    Checksum: u16,
    MulticastAddress: IN_ADDR,
    _bitfield: u8,
    Anonymous2: extern union {
        QueriersQueryInterfaceCode: u8,
        Anonymous: extern struct {
            _bitfield: u8,
        },
    },
    SourceCount: u16,
};

pub const IGMPV3_REPORT_RECORD_HEADER = extern struct {
    Type: u8,
    AuxillaryDataLength: u8,
    SourceCount: u16,
    MulticastAddress: IN_ADDR,
};

pub const IGMPV3_REPORT_HEADER = extern struct {
    Type: u8,
    Reserved: u8,
    Checksum: u16,
    Reserved2: u16,
    RecordCount: u16,
};

pub const IPV6_HEADER = extern struct {
    Anonymous: extern union {
        VersionClassFlow: u32,
        Anonymous: extern struct {
            _bitfield: u32,
        },
    },
    PayloadLength: u16,
    NextHeader: u8,
    HopLimit: u8,
    SourceAddress: IN6_ADDR,
    DestinationAddress: IN6_ADDR,
};

pub const IPV6_FRAGMENT_HEADER = extern struct {
    NextHeader: u8,
    Reserved: u8,
    Anonymous: extern union {
        Anonymous: extern struct {
            _bitfield: u16,
        },
        OffsetAndFlags: u16,
    },
    Id: u32,
};

pub const IPV6_EXTENSION_HEADER = extern struct {
    NextHeader: u8,
    Length: u8,
};

pub const IPV6_OPTION_HEADER = extern struct {
    Type: u8,
    DataLength: u8,
};

pub const IPV6_OPTION_TYPE = enum(i32) {
    PAD1 = 0,
    PADN = 1,
    TUNNEL_LIMIT = 4,
    ROUTER_ALERT = 5,
    JUMBO = 194,
    NSAP_ADDR = 195,
};
pub const IP6OPT_PAD1 = IPV6_OPTION_TYPE.PAD1;
pub const IP6OPT_PADN = IPV6_OPTION_TYPE.PADN;
pub const IP6OPT_TUNNEL_LIMIT = IPV6_OPTION_TYPE.TUNNEL_LIMIT;
pub const IP6OPT_ROUTER_ALERT = IPV6_OPTION_TYPE.ROUTER_ALERT;
pub const IP6OPT_JUMBO = IPV6_OPTION_TYPE.JUMBO;
pub const IP6OPT_NSAP_ADDR = IPV6_OPTION_TYPE.NSAP_ADDR;

pub const IPV6_OPTION_JUMBOGRAM = extern struct {
    Header: IPV6_OPTION_HEADER,
    JumbogramLength: [4]u8,
};

pub const IPV6_OPTION_ROUTER_ALERT = extern struct {
    Header: IPV6_OPTION_HEADER,
    Value: [2]u8,
};

pub const IPV6_ROUTING_HEADER = extern struct {
    NextHeader: u8,
    Length: u8,
    RoutingType: u8,
    SegmentsLeft: u8,
    Reserved: [4]u8,
};

pub const nd_router_solicit = extern struct {
    nd_rs_hdr: ICMP_MESSAGE,
};

pub const nd_router_advert = extern struct {
    nd_ra_hdr: ICMP_MESSAGE,
    nd_ra_reachable: u32,
    nd_ra_retransmit: u32,
};

pub const IPV6_ROUTER_ADVERTISEMENT_FLAGS = extern union {
    Anonymous: extern struct {
        _bitfield: u8,
    },
    Value: u8,
};

pub const nd_neighbor_solicit = extern struct {
    nd_ns_hdr: ICMP_MESSAGE,
    nd_ns_target: IN6_ADDR,
};

pub const nd_neighbor_advert = extern struct {
    nd_na_hdr: ICMP_MESSAGE,
    nd_na_target: IN6_ADDR,
};

pub const IPV6_NEIGHBOR_ADVERTISEMENT_FLAGS = extern union {
    Anonymous: extern struct {
        _bitfield: u8,
        Reserved2: [3]u8,
    },
    Value: u32,
};

pub const nd_redirect = extern struct {
    nd_rd_hdr: ICMP_MESSAGE,
    nd_rd_target: IN6_ADDR,
    nd_rd_dst: IN6_ADDR,
};

pub const nd_opt_hdr = extern struct {
    nd_opt_type: u8,
    nd_opt_len: u8,
};

pub const ND_OPTION_TYPE = enum(i32) {
    SOURCE_LINKADDR = 1,
    TARGET_LINKADDR = 2,
    PREFIX_INFORMATION = 3,
    REDIRECTED_HEADER = 4,
    MTU = 5,
    NBMA_SHORTCUT_LIMIT = 6,
    ADVERTISEMENT_INTERVAL = 7,
    HOME_AGENT_INFORMATION = 8,
    SOURCE_ADDR_LIST = 9,
    TARGET_ADDR_LIST = 10,
    ROUTE_INFO = 24,
    RDNSS = 25,
    DNSSL = 31,
};
pub const ND_OPT_SOURCE_LINKADDR = ND_OPTION_TYPE.SOURCE_LINKADDR;
pub const ND_OPT_TARGET_LINKADDR = ND_OPTION_TYPE.TARGET_LINKADDR;
pub const ND_OPT_PREFIX_INFORMATION = ND_OPTION_TYPE.PREFIX_INFORMATION;
pub const ND_OPT_REDIRECTED_HEADER = ND_OPTION_TYPE.REDIRECTED_HEADER;
pub const ND_OPT_MTU = ND_OPTION_TYPE.MTU;
pub const ND_OPT_NBMA_SHORTCUT_LIMIT = ND_OPTION_TYPE.NBMA_SHORTCUT_LIMIT;
pub const ND_OPT_ADVERTISEMENT_INTERVAL = ND_OPTION_TYPE.ADVERTISEMENT_INTERVAL;
pub const ND_OPT_HOME_AGENT_INFORMATION = ND_OPTION_TYPE.HOME_AGENT_INFORMATION;
pub const ND_OPT_SOURCE_ADDR_LIST = ND_OPTION_TYPE.SOURCE_ADDR_LIST;
pub const ND_OPT_TARGET_ADDR_LIST = ND_OPTION_TYPE.TARGET_ADDR_LIST;
pub const ND_OPT_ROUTE_INFO = ND_OPTION_TYPE.ROUTE_INFO;
pub const ND_OPT_RDNSS = ND_OPTION_TYPE.RDNSS;
pub const ND_OPT_DNSSL = ND_OPTION_TYPE.DNSSL;

pub const nd_opt_prefix_info = extern struct {
    nd_opt_pi_type: u8,
    nd_opt_pi_len: u8,
    nd_opt_pi_prefix_len: u8,
    Anonymous1: extern union {
        nd_opt_pi_flags_reserved: u8,
        Flags: extern struct {
            _bitfield: u8,
        },
    },
    nd_opt_pi_valid_time: u32,
    nd_opt_pi_preferred_time: u32,
    Anonymous2: extern union {
        nd_opt_pi_reserved2: u32,
        Anonymous: extern struct {
            nd_opt_pi_reserved3: [3]u8,
            nd_opt_pi_site_prefix_len: u8,
        },
    },
    nd_opt_pi_prefix: IN6_ADDR,
};

pub const nd_opt_rd_hdr = extern struct {
    nd_opt_rh_type: u8,
    nd_opt_rh_len: u8,
    nd_opt_rh_reserved1: u16,
    nd_opt_rh_reserved2: u32,
};

pub const nd_opt_mtu = extern struct {
    nd_opt_mtu_type: u8,
    nd_opt_mtu_len: u8,
    nd_opt_mtu_reserved: u16,
    nd_opt_mtu_mtu: u32,
};

pub const nd_opt_route_info = extern struct {
    nd_opt_ri_type: u8,
    nd_opt_ri_len: u8,
    nd_opt_ri_prefix_len: u8,
    Anonymous: extern union {
        nd_opt_ri_flags_reserved: u8,
        Flags: extern struct {
            _bitfield: u8,
        },
    },
    nd_opt_ri_route_lifetime: u32,
    nd_opt_ri_prefix: IN6_ADDR,
};

pub const nd_opt_rdnss = extern struct {
    nd_opt_rdnss_type: u8,
    nd_opt_rdnss_len: u8,
    nd_opt_rdnss_reserved: u16,
    nd_opt_rdnss_lifetime: u32,
};

pub const nd_opt_dnssl = extern struct {
    nd_opt_dnssl_type: u8,
    nd_opt_dnssl_len: u8,
    nd_opt_dnssl_reserved: u16,
    nd_opt_dnssl_lifetime: u32,
};

pub const MLD_HEADER = extern struct {
    IcmpHeader: ICMP_HEADER,
    MaxRespTime: u16,
    Reserved: u16,
    MulticastAddress: IN6_ADDR,
};

pub const MLD_MAX_RESP_CODE_TYPE = enum(i32) {
    NORMAL = 0,
    FLOAT = 1,
};
pub const MLD_MAX_RESP_CODE_TYPE_NORMAL = MLD_MAX_RESP_CODE_TYPE.NORMAL;
pub const MLD_MAX_RESP_CODE_TYPE_FLOAT = MLD_MAX_RESP_CODE_TYPE.FLOAT;

pub const MLDV2_QUERY_HEADER = extern struct {
    IcmpHeader: ICMP_HEADER,
    Anonymous1: extern union {
        MaxRespCode: u16,
        Anonymous: extern struct {
            _bitfield: u16,
        },
    },
    Reserved: u16,
    MulticastAddress: IN6_ADDR,
    _bitfield: u8,
    Anonymous2: extern union {
        QueriersQueryInterfaceCode: u8,
        Anonymous: extern struct {
            _bitfield: u8,
        },
    },
    SourceCount: u16,
};

pub const MLDV2_REPORT_RECORD_HEADER = extern struct {
    Type: u8,
    AuxillaryDataLength: u8,
    SourceCount: u16,
    MulticastAddress: IN6_ADDR,
};

pub const MLDV2_REPORT_HEADER = extern struct {
    IcmpHeader: ICMP_HEADER,
    Reserved: u16,
    RecordCount: u16,
};

pub const tcp_hdr = extern struct {
    th_sport: u16 align(1),
    th_dport: u16 align(1),
    th_seq: u32 align(1),
    th_ack: u32 align(1),
    _bitfield: u8 align(1),
    th_flags: u8 align(1),
    th_win: u16 align(1),
    th_sum: u16 align(1),
    th_urp: u16 align(1),
};

pub const tcp_opt_mss = extern struct {
    Kind: u8 align(1),
    Length: u8 align(1),
    Mss: u16 align(1),
};

pub const tcp_opt_ws = extern struct {
    Kind: u8,
    Length: u8,
    ShiftCnt: u8,
};

pub const tcp_opt_sack_permitted = extern struct {
    Kind: u8,
    Length: u8,
};

pub const tcp_opt_sack = extern struct {
    pub const tcp_opt_sack_block = extern struct {
        Left: u32 align(1),
        Right: u32 align(1),
    };
    Kind: u8,
    Length: u8,
    Block: [1]tcp_opt_sack_block,
};

pub const tcp_opt_ts = extern struct {
    Kind: u8 align(1),
    Length: u8 align(1),
    Val: u32 align(1),
    EcR: u32 align(1),
};

pub const tcp_opt_unknown = extern struct {
    Kind: u8,
    Length: u8,
};

pub const tcp_opt_fastopen = extern struct {
    Kind: u8,
    Length: u8,
    Cookie: [1]u8,
};

pub const DL_TUNNEL_ADDRESS = extern struct {
    CompartmentId: COMPARTMENT_ID,
    ScopeId: SCOPE_ID,
    IpAddress: [1]u8,
};

pub const TUNNEL_SUB_TYPE = enum(i32) {
    NONE = 0,
    CP = 1,
    IPTLS = 2,
    HA = 3,
};
pub const TUNNEL_SUB_TYPE_NONE = TUNNEL_SUB_TYPE.NONE;
pub const TUNNEL_SUB_TYPE_CP = TUNNEL_SUB_TYPE.CP;
pub const TUNNEL_SUB_TYPE_IPTLS = TUNNEL_SUB_TYPE.IPTLS;
pub const TUNNEL_SUB_TYPE_HA = TUNNEL_SUB_TYPE.HA;

pub const DL_TEREDO_ADDRESS = extern struct {
    Reserved: [6]u8,
    Anonymous: extern union {
        Eui64: DL_EUI64 align(1),
        Anonymous: extern struct {
            Flags: u16 align(1),
            MappedPort: u16 align(1),
            MappedAddress: IN_ADDR align(1),
        } align(1),
    },
};

pub const DL_TEREDO_ADDRESS_PRV = extern struct {
    Reserved: [6]u8,
    Anonymous: extern union {
        Eui64: DL_EUI64 align(1),
        Anonymous: extern struct {
            Flags: u16 align(1),
            MappedPort: u16 align(1),
            MappedAddress: IN_ADDR align(1),
            LocalAddress: IN_ADDR align(1),
            InterfaceIndex: u32 align(1),
            LocalPort: u16 align(1),
            DlDestination: DL_EUI48 align(1),
        } align(1),
    },
};

pub const IPTLS_METADATA = extern struct {
    SequenceNumber: u64 align(1),
};

pub const NPI_MODULEID_TYPE = enum(i32) {
    GUID = 1,
    IF_LUID = 2,
};
pub const MIT_GUID = NPI_MODULEID_TYPE.GUID;
pub const MIT_IF_LUID = NPI_MODULEID_TYPE.IF_LUID;

pub const NPI_MODULEID = extern struct {
    Length: u16,
    Type: NPI_MODULEID_TYPE,
    Anonymous: extern union {
        Guid: Guid,
        IfLuid: LUID,
    },
};

pub const FALLBACK_INDEX = enum(i32) {
    TcpFastopen = 0,
    Max = 1,
};
pub const FallbackIndexTcpFastopen = FALLBACK_INDEX.TcpFastopen;
pub const FallbackIndexMax = FALLBACK_INDEX.Max;



pub const servent = switch(@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        s_name: ?PSTR,
        s_aliases: ?*?*i8,
        s_proto: ?PSTR,
        s_port: i16,
    },
    .X86 => extern struct {
        s_name: ?PSTR,
        s_aliases: ?*?*i8,
        s_port: i16,
        s_proto: ?PSTR,
    },
};
pub const WSAData = switch(@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        wVersion: u16,
        wHighVersion: u16,
        iMaxSockets: u16,
        iMaxUdpDg: u16,
        lpVendorInfo: ?PSTR,
        szDescription: [257]CHAR,
        szSystemStatus: [129]CHAR,
    },
    .X86 => extern struct {
        wVersion: u16,
        wHighVersion: u16,
        szDescription: [257]CHAR,
        szSystemStatus: [129]CHAR,
        iMaxSockets: u16,
        iMaxUdpDg: u16,
        lpVendorInfo: ?PSTR,
    },
};

//--------------------------------------------------------------------------------
// Section: Functions (203)
//--------------------------------------------------------------------------------
// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn __WSAFDIsSet(
    fd: ?SOCKET,
    param1: ?*fd_set,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn accept(
    s: ?SOCKET,
    // TODO: what to do with BytesParamIndex 2?
    addr: ?*SOCKADDR,
    addrlen: ?*i32,
) callconv(@import("std").os.windows.WINAPI) SOCKET;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn bind(
    s: ?SOCKET,
    // TODO: what to do with BytesParamIndex 2?
    name: ?*const SOCKADDR,
    namelen: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn closesocket(
    s: ?SOCKET,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ws2_32" fn connect(
    s: ?SOCKET,
    // TODO: what to do with BytesParamIndex 2?
    name: ?*const SOCKADDR,
    namelen: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn ioctlsocket(
    s: ?SOCKET,
    cmd: i32,
    argp: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn getpeername(
    s: ?SOCKET,
    // TODO: what to do with BytesParamIndex 2?
    name: ?*SOCKADDR,
    namelen: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn getsockname(
    s: ?SOCKET,
    // TODO: what to do with BytesParamIndex 2?
    name: ?*SOCKADDR,
    namelen: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn getsockopt(
    s: ?SOCKET,
    level: i32,
    optname: i32,
    // TODO: what to do with BytesParamIndex 4?
    optval: ?PSTR,
    optlen: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn htonl(
    hostlong: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn htons(
    hostshort: u16,
) callconv(@import("std").os.windows.WINAPI) u16;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn inet_addr(
    cp: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn inet_ntoa(
    in: IN_ADDR,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn listen(
    s: ?SOCKET,
    backlog: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn ntohl(
    netlong: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn ntohs(
    netshort: u16,
) callconv(@import("std").os.windows.WINAPI) u16;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn recv(
    s: ?SOCKET,
    // TODO: what to do with BytesParamIndex 2?
    buf: ?PSTR,
    len: i32,
    flags: SEND_RECV_FLAGS,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn recvfrom(
    s: ?SOCKET,
    // TODO: what to do with BytesParamIndex 2?
    buf: ?PSTR,
    len: i32,
    flags: i32,
    // TODO: what to do with BytesParamIndex 5?
    from: ?*SOCKADDR,
    fromlen: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn select(
    nfds: i32,
    readfds: ?*fd_set,
    writefds: ?*fd_set,
    exceptfds: ?*fd_set,
    timeout: ?*const timeval,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn send(
    s: ?SOCKET,
    // TODO: what to do with BytesParamIndex 2?
    buf: ?[*:0]const u8,
    len: i32,
    flags: SEND_RECV_FLAGS,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn sendto(
    s: ?SOCKET,
    // TODO: what to do with BytesParamIndex 2?
    buf: ?[*:0]const u8,
    len: i32,
    flags: i32,
    // TODO: what to do with BytesParamIndex 5?
    to: ?*const SOCKADDR,
    tolen: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn setsockopt(
    s: ?SOCKET,
    level: i32,
    optname: i32,
    // TODO: what to do with BytesParamIndex 4?
    optval: ?[*:0]const u8,
    optlen: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn shutdown(
    s: ?SOCKET,
    how: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn socket(
    af: i32,
    type: i32,
    protocol: i32,
) callconv(@import("std").os.windows.WINAPI) SOCKET;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn gethostbyaddr(
    // TODO: what to do with BytesParamIndex 1?
    addr: ?[*:0]const u8,
    len: i32,
    type: i32,
) callconv(@import("std").os.windows.WINAPI) ?*hostent;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn gethostbyname(
    name: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) ?*hostent;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn gethostname(
    // TODO: what to do with BytesParamIndex 1?
    name: ?PSTR,
    namelen: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn GetHostNameW(
    name: [*:0]u16,
    namelen: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn getservbyport(
    port: i32,
    proto: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) ?*servent;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn getservbyname(
    name: ?[*:0]const u8,
    proto: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) ?*servent;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn getprotobynumber(
    number: i32,
) callconv(@import("std").os.windows.WINAPI) ?*protoent;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn getprotobyname(
    name: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) ?*protoent;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSAStartup(
    wVersionRequested: u16,
    lpWSAData: ?*WSAData,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSACleanup(
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSASetLastError(
    iError: i32,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSAGetLastError(
) callconv(@import("std").os.windows.WINAPI) WSA_ERROR;

pub extern "ws2_32" fn WSAIsBlocking(
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "ws2_32" fn WSAUnhookBlockingHook(
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ws2_32" fn WSASetBlockingHook(
    lpBlockFunc: ?FARPROC,
) callconv(@import("std").os.windows.WINAPI) ?FARPROC;

pub extern "ws2_32" fn WSACancelBlockingCall(
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ws2_32" fn WSAAsyncGetServByName(
    hWnd: ?HWND,
    wMsg: u32,
    name: ?[*:0]const u8,
    proto: ?[*:0]const u8,
    // TODO: what to do with BytesParamIndex 5?
    buf: ?PSTR,
    buflen: i32,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ws2_32" fn WSAAsyncGetServByPort(
    hWnd: ?HWND,
    wMsg: u32,
    port: i32,
    proto: ?[*:0]const u8,
    // TODO: what to do with BytesParamIndex 5?
    buf: ?PSTR,
    buflen: i32,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ws2_32" fn WSAAsyncGetProtoByName(
    hWnd: ?HWND,
    wMsg: u32,
    name: ?[*:0]const u8,
    // TODO: what to do with BytesParamIndex 4?
    buf: ?PSTR,
    buflen: i32,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ws2_32" fn WSAAsyncGetProtoByNumber(
    hWnd: ?HWND,
    wMsg: u32,
    number: i32,
    // TODO: what to do with BytesParamIndex 4?
    buf: ?PSTR,
    buflen: i32,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ws2_32" fn WSAAsyncGetHostByName(
    hWnd: ?HWND,
    wMsg: u32,
    name: ?[*:0]const u8,
    // TODO: what to do with BytesParamIndex 4?
    buf: ?PSTR,
    buflen: i32,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ws2_32" fn WSAAsyncGetHostByAddr(
    hWnd: ?HWND,
    wMsg: u32,
    // TODO: what to do with BytesParamIndex 3?
    addr: ?[*:0]const u8,
    len: i32,
    type: i32,
    // TODO: what to do with BytesParamIndex 6?
    buf: ?PSTR,
    buflen: i32,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ws2_32" fn WSACancelAsyncRequest(
    hAsyncTaskHandle: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ws2_32" fn WSAAsyncSelect(
    s: ?SOCKET,
    hWnd: ?HWND,
    wMsg: u32,
    lEvent: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSAAccept(
    s: ?SOCKET,
    // TODO: what to do with BytesParamIndex 2?
    addr: ?*SOCKADDR,
    addrlen: ?*i32,
    lpfnCondition: ?LPCONDITIONPROC,
    dwCallbackData: usize,
) callconv(@import("std").os.windows.WINAPI) ?SOCKET;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSACloseEvent(
    hEvent: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSAConnect(
    s: ?SOCKET,
    // TODO: what to do with BytesParamIndex 2?
    name: ?*const SOCKADDR,
    namelen: i32,
    lpCallerData: ?*WSABUF,
    lpCalleeData: ?*WSABUF,
    lpSQOS: ?*QOS,
    lpGQOS: ?*QOS,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSAConnectByNameW(
    s: ?SOCKET,
    nodename: ?PWSTR,
    servicename: ?PWSTR,
    LocalAddressLength: ?*u32,
    // TODO: what to do with BytesParamIndex 3?
    LocalAddress: ?*SOCKADDR,
    RemoteAddressLength: ?*u32,
    // TODO: what to do with BytesParamIndex 5?
    RemoteAddress: ?*SOCKADDR,
    timeout: ?*const timeval,
    Reserved: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSAConnectByNameA(
    s: ?SOCKET,
    nodename: ?[*:0]const u8,
    servicename: ?[*:0]const u8,
    LocalAddressLength: ?*u32,
    // TODO: what to do with BytesParamIndex 3?
    LocalAddress: ?*SOCKADDR,
    RemoteAddressLength: ?*u32,
    // TODO: what to do with BytesParamIndex 5?
    RemoteAddress: ?*SOCKADDR,
    timeout: ?*const timeval,
    Reserved: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSAConnectByList(
    s: ?SOCKET,
    SocketAddress: ?*SOCKET_ADDRESS_LIST,
    LocalAddressLength: ?*u32,
    // TODO: what to do with BytesParamIndex 2?
    LocalAddress: ?*SOCKADDR,
    RemoteAddressLength: ?*u32,
    // TODO: what to do with BytesParamIndex 4?
    RemoteAddress: ?*SOCKADDR,
    timeout: ?*const timeval,
    Reserved: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSACreateEvent(
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSADuplicateSocketA(
    s: ?SOCKET,
    dwProcessId: u32,
    lpProtocolInfo: ?*WSAPROTOCOL_INFOA,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSADuplicateSocketW(
    s: ?SOCKET,
    dwProcessId: u32,
    lpProtocolInfo: ?*WSAPROTOCOL_INFOW,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSAEnumNetworkEvents(
    s: ?SOCKET,
    hEventObject: ?HANDLE,
    lpNetworkEvents: ?*WSANETWORKEVENTS,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSAEnumProtocolsA(
    lpiProtocols: ?*i32,
    // TODO: what to do with BytesParamIndex 2?
    lpProtocolBuffer: ?*WSAPROTOCOL_INFOA,
    lpdwBufferLength: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSAEnumProtocolsW(
    lpiProtocols: ?*i32,
    // TODO: what to do with BytesParamIndex 2?
    lpProtocolBuffer: ?*WSAPROTOCOL_INFOW,
    lpdwBufferLength: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSAEventSelect(
    s: ?SOCKET,
    hEventObject: ?HANDLE,
    lNetworkEvents: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSAGetOverlappedResult(
    s: ?SOCKET,
    lpOverlapped: ?*OVERLAPPED,
    lpcbTransfer: ?*u32,
    fWait: BOOL,
    lpdwFlags: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ws2_32" fn WSAGetQOSByName(
    s: ?SOCKET,
    lpQOSName: ?*WSABUF,
    lpQOS: ?*QOS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSAHtonl(
    s: ?SOCKET,
    hostlong: u32,
    lpnetlong: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSAHtons(
    s: ?SOCKET,
    hostshort: u16,
    lpnetshort: ?*u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSAIoctl(
    s: ?SOCKET,
    dwIoControlCode: u32,
    // TODO: what to do with BytesParamIndex 3?
    lpvInBuffer: ?*anyopaque,
    cbInBuffer: u32,
    // TODO: what to do with BytesParamIndex 5?
    lpvOutBuffer: ?*anyopaque,
    cbOutBuffer: u32,
    lpcbBytesReturned: ?*u32,
    lpOverlapped: ?*OVERLAPPED,
    lpCompletionRoutine: ?LPWSAOVERLAPPED_COMPLETION_ROUTINE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSAJoinLeaf(
    s: ?SOCKET,
    // TODO: what to do with BytesParamIndex 2?
    name: ?*const SOCKADDR,
    namelen: i32,
    lpCallerData: ?*WSABUF,
    lpCalleeData: ?*WSABUF,
    lpSQOS: ?*QOS,
    lpGQOS: ?*QOS,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) ?SOCKET;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSANtohl(
    s: ?SOCKET,
    netlong: u32,
    lphostlong: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSANtohs(
    s: ?SOCKET,
    netshort: u16,
    lphostshort: ?*u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSARecv(
    s: ?SOCKET,
    lpBuffers: [*]WSABUF,
    dwBufferCount: u32,
    lpNumberOfBytesRecvd: ?*u32,
    lpFlags: ?*u32,
    lpOverlapped: ?*OVERLAPPED,
    lpCompletionRoutine: ?LPWSAOVERLAPPED_COMPLETION_ROUTINE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ws2_32" fn WSARecvDisconnect(
    s: ?SOCKET,
    lpInboundDisconnectData: ?*WSABUF,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSARecvFrom(
    s: ?SOCKET,
    lpBuffers: [*]WSABUF,
    dwBufferCount: u32,
    lpNumberOfBytesRecvd: ?*u32,
    lpFlags: ?*u32,
    // TODO: what to do with BytesParamIndex 6?
    lpFrom: ?*SOCKADDR,
    lpFromlen: ?*i32,
    lpOverlapped: ?*OVERLAPPED,
    lpCompletionRoutine: ?LPWSAOVERLAPPED_COMPLETION_ROUTINE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSAResetEvent(
    hEvent: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSASend(
    s: ?SOCKET,
    lpBuffers: [*]WSABUF,
    dwBufferCount: u32,
    lpNumberOfBytesSent: ?*u32,
    dwFlags: u32,
    lpOverlapped: ?*OVERLAPPED,
    lpCompletionRoutine: ?LPWSAOVERLAPPED_COMPLETION_ROUTINE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSASendMsg(
    Handle: ?SOCKET,
    lpMsg: ?*WSAMSG,
    dwFlags: u32,
    lpNumberOfBytesSent: ?*u32,
    lpOverlapped: ?*OVERLAPPED,
    lpCompletionRoutine: ?LPWSAOVERLAPPED_COMPLETION_ROUTINE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ws2_32" fn WSASendDisconnect(
    s: ?SOCKET,
    lpOutboundDisconnectData: ?*WSABUF,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSASendTo(
    s: ?SOCKET,
    lpBuffers: [*]WSABUF,
    dwBufferCount: u32,
    lpNumberOfBytesSent: ?*u32,
    dwFlags: u32,
    // TODO: what to do with BytesParamIndex 6?
    lpTo: ?*const SOCKADDR,
    iTolen: i32,
    lpOverlapped: ?*OVERLAPPED,
    lpCompletionRoutine: ?LPWSAOVERLAPPED_COMPLETION_ROUTINE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSASetEvent(
    hEvent: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSASocketA(
    af: i32,
    type: i32,
    protocol: i32,
    lpProtocolInfo: ?*WSAPROTOCOL_INFOA,
    g: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) SOCKET;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSASocketW(
    af: i32,
    type: i32,
    protocol: i32,
    lpProtocolInfo: ?*WSAPROTOCOL_INFOW,
    g: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) SOCKET;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSAWaitForMultipleEvents(
    cEvents: u32,
    lphEvents: [*]const ?HANDLE,
    fWaitAll: BOOL,
    dwTimeout: u32,
    fAlertable: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSAAddressToStringA(
    // TODO: what to do with BytesParamIndex 1?
    lpsaAddress: ?*SOCKADDR,
    dwAddressLength: u32,
    lpProtocolInfo: ?*WSAPROTOCOL_INFOA,
    lpszAddressString: [*:0]u8,
    lpdwAddressStringLength: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSAAddressToStringW(
    // TODO: what to do with BytesParamIndex 1?
    lpsaAddress: ?*SOCKADDR,
    dwAddressLength: u32,
    lpProtocolInfo: ?*WSAPROTOCOL_INFOW,
    lpszAddressString: [*:0]u16,
    lpdwAddressStringLength: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSAStringToAddressA(
    AddressString: ?PSTR,
    AddressFamily: i32,
    lpProtocolInfo: ?*WSAPROTOCOL_INFOA,
    // TODO: what to do with BytesParamIndex 4?
    lpAddress: ?*SOCKADDR,
    lpAddressLength: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSAStringToAddressW(
    AddressString: ?PWSTR,
    AddressFamily: i32,
    lpProtocolInfo: ?*WSAPROTOCOL_INFOW,
    // TODO: what to do with BytesParamIndex 4?
    lpAddress: ?*SOCKADDR,
    lpAddressLength: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSALookupServiceBeginA(
    lpqsRestrictions: ?*WSAQUERYSETA,
    dwControlFlags: u32,
    lphLookup: ?*?HANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSALookupServiceBeginW(
    lpqsRestrictions: ?*WSAQUERYSETW,
    dwControlFlags: u32,
    lphLookup: ?*?HANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSALookupServiceNextA(
    hLookup: ?HANDLE,
    dwControlFlags: u32,
    lpdwBufferLength: ?*u32,
    // TODO: what to do with BytesParamIndex 2?
    lpqsResults: ?*WSAQUERYSETA,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSALookupServiceNextW(
    hLookup: ?HANDLE,
    dwControlFlags: u32,
    lpdwBufferLength: ?*u32,
    // TODO: what to do with BytesParamIndex 2?
    lpqsResults: ?*WSAQUERYSETW,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSANSPIoctl(
    hLookup: ?HANDLE,
    dwControlCode: u32,
    // TODO: what to do with BytesParamIndex 3?
    lpvInBuffer: ?*anyopaque,
    cbInBuffer: u32,
    // TODO: what to do with BytesParamIndex 5?
    lpvOutBuffer: ?*anyopaque,
    cbOutBuffer: u32,
    lpcbBytesReturned: ?*u32,
    lpCompletion: ?*WSACOMPLETION,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSALookupServiceEnd(
    hLookup: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ws2_32" fn WSAInstallServiceClassA(
    lpServiceClassInfo: ?*WSASERVICECLASSINFOA,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ws2_32" fn WSAInstallServiceClassW(
    lpServiceClassInfo: ?*WSASERVICECLASSINFOW,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ws2_32" fn WSARemoveServiceClass(
    lpServiceClassId: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ws2_32" fn WSAGetServiceClassInfoA(
    lpProviderId: ?*Guid,
    lpServiceClassId: ?*Guid,
    lpdwBufSize: ?*u32,
    // TODO: what to do with BytesParamIndex 2?
    lpServiceClassInfo: ?*WSASERVICECLASSINFOA,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ws2_32" fn WSAGetServiceClassInfoW(
    lpProviderId: ?*Guid,
    lpServiceClassId: ?*Guid,
    lpdwBufSize: ?*u32,
    // TODO: what to do with BytesParamIndex 2?
    lpServiceClassInfo: ?*WSASERVICECLASSINFOW,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSAEnumNameSpaceProvidersA(
    lpdwBufferLength: ?*u32,
    // TODO: what to do with BytesParamIndex 0?
    lpnspBuffer: ?*WSANAMESPACE_INFOA,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSAEnumNameSpaceProvidersW(
    lpdwBufferLength: ?*u32,
    // TODO: what to do with BytesParamIndex 0?
    lpnspBuffer: ?*WSANAMESPACE_INFOW,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSAEnumNameSpaceProvidersExA(
    lpdwBufferLength: ?*u32,
    // TODO: what to do with BytesParamIndex 0?
    lpnspBuffer: ?*WSANAMESPACE_INFOEXA,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSAEnumNameSpaceProvidersExW(
    lpdwBufferLength: ?*u32,
    // TODO: what to do with BytesParamIndex 0?
    lpnspBuffer: ?*WSANAMESPACE_INFOEXW,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ws2_32" fn WSAGetServiceClassNameByClassIdA(
    lpServiceClassId: ?*Guid,
    // TODO: what to do with BytesParamIndex 2?
    lpszServiceClassName: ?PSTR,
    lpdwBufferLength: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ws2_32" fn WSAGetServiceClassNameByClassIdW(
    lpServiceClassId: ?*Guid,
    // TODO: what to do with BytesParamIndex 2?
    lpszServiceClassName: ?PWSTR,
    lpdwBufferLength: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSASetServiceA(
    lpqsRegInfo: ?*WSAQUERYSETA,
    essoperation: WSAESETSERVICEOP,
    dwControlFlags: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSASetServiceW(
    lpqsRegInfo: ?*WSAQUERYSETW,
    essoperation: WSAESETSERVICEOP,
    dwControlFlags: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSAProviderConfigChange(
    lpNotificationHandle: ?*?HANDLE,
    lpOverlapped: ?*OVERLAPPED,
    lpCompletionRoutine: ?LPWSAOVERLAPPED_COMPLETION_ROUTINE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSAPoll(
    fdArray: ?*WSAPOLLFD,
    fds: u32,
    timeout: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ws2_32" fn ProcessSocketNotifications(
    completionPort: ?HANDLE,
    registrationCount: u32,
    registrationInfos: ?[*]SOCK_NOTIFY_REGISTRATION,
    timeoutMs: u32,
    completionCount: u32,
    completionPortEntries: ?[*]OVERLAPPED_ENTRY,
    receivedEntryCount: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ntdll" fn RtlIpv4AddressToStringA(
    Addr: ?*const IN_ADDR,
    S: *[16]u8,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "ntdll" fn RtlIpv4AddressToStringExA(
    Address: ?*const IN_ADDR,
    Port: u16,
    AddressString: [*:0]u8,
    AddressStringLength: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ntdll" fn RtlIpv4AddressToStringW(
    Addr: ?*const IN_ADDR,
    S: *[16]u16,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ntdll" fn RtlIpv4AddressToStringExW(
    Address: ?*const IN_ADDR,
    Port: u16,
    AddressString: [*:0]u16,
    AddressStringLength: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ntdll" fn RtlIpv4StringToAddressA(
    S: ?[*:0]const u8,
    Strict: BOOLEAN,
    Terminator: ?*?PSTR,
    Addr: ?*IN_ADDR,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ntdll" fn RtlIpv4StringToAddressExA(
    AddressString: ?[*:0]const u8,
    Strict: BOOLEAN,
    Address: ?*IN_ADDR,
    Port: ?*u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ntdll" fn RtlIpv4StringToAddressW(
    S: ?[*:0]const u16,
    Strict: BOOLEAN,
    Terminator: ?*?PWSTR,
    Addr: ?*IN_ADDR,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ntdll" fn RtlIpv4StringToAddressExW(
    AddressString: ?[*:0]const u16,
    Strict: BOOLEAN,
    Address: ?*IN_ADDR,
    Port: ?*u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ntdll" fn RtlIpv6AddressToStringA(
    Addr: ?*const IN6_ADDR,
    S: *[46]u8,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "ntdll" fn RtlIpv6AddressToStringExA(
    Address: ?*const IN6_ADDR,
    ScopeId: u32,
    Port: u16,
    AddressString: [*:0]u8,
    AddressStringLength: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ntdll" fn RtlIpv6AddressToStringW(
    Addr: ?*const IN6_ADDR,
    S: *[46]u16,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ntdll" fn RtlIpv6AddressToStringExW(
    Address: ?*const IN6_ADDR,
    ScopeId: u32,
    Port: u16,
    AddressString: [*:0]u16,
    AddressStringLength: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ntdll" fn RtlIpv6StringToAddressA(
    S: ?[*:0]const u8,
    Terminator: ?*?PSTR,
    Addr: ?*IN6_ADDR,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ntdll" fn RtlIpv6StringToAddressExA(
    AddressString: ?[*:0]const u8,
    Address: ?*IN6_ADDR,
    ScopeId: ?*u32,
    Port: ?*u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ntdll" fn RtlIpv6StringToAddressW(
    S: ?[*:0]const u16,
    Terminator: ?*?PWSTR,
    Addr: ?*IN6_ADDR,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ntdll" fn RtlIpv6StringToAddressExW(
    AddressString: ?[*:0]const u16,
    Address: ?*IN6_ADDR,
    ScopeId: ?*u32,
    Port: ?*u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "ntdll" fn RtlEthernetAddressToStringA(
    Addr: ?*const DL_EUI48,
    S: *[18]u8,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

// TODO: this type is limited to platform 'windows6.1'
pub extern "ntdll" fn RtlEthernetAddressToStringW(
    Addr: ?*const DL_EUI48,
    S: *[18]u16,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

// TODO: this type is limited to platform 'windows6.1'
pub extern "ntdll" fn RtlEthernetStringToAddressA(
    S: ?[*:0]const u8,
    Terminator: ?*?PSTR,
    Addr: ?*DL_EUI48,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "ntdll" fn RtlEthernetStringToAddressW(
    S: ?[*:0]const u16,
    Terminator: ?*?PWSTR,
    Addr: ?*DL_EUI48,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "mswsock" fn WSARecvEx(
    s: ?SOCKET,
    // TODO: what to do with BytesParamIndex 2?
    buf: ?PSTR,
    len: i32,
    flags: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "mswsock" fn TransmitFile(
    hSocket: ?SOCKET,
    hFile: ?HANDLE,
    nNumberOfBytesToWrite: u32,
    nNumberOfBytesPerSend: u32,
    lpOverlapped: ?*OVERLAPPED,
    lpTransmitBuffers: ?*TRANSMIT_FILE_BUFFERS,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.1'
pub extern "mswsock" fn AcceptEx(
    sListenSocket: ?SOCKET,
    sAcceptSocket: ?SOCKET,
    lpOutputBuffer: ?*anyopaque,
    dwReceiveDataLength: u32,
    dwLocalAddressLength: u32,
    dwRemoteAddressLength: u32,
    lpdwBytesReceived: ?*u32,
    lpOverlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.1'
pub extern "mswsock" fn GetAcceptExSockaddrs(
    lpOutputBuffer: ?*anyopaque,
    dwReceiveDataLength: u32,
    dwLocalAddressLength: u32,
    dwRemoteAddressLength: u32,
    LocalSockaddr: ?*?*SOCKADDR,
    LocalSockaddrLength: ?*i32,
    RemoteSockaddr: ?*?*SOCKADDR,
    RemoteSockaddrLength: ?*i32,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ws2_32" fn WSCEnumProtocols(
    lpiProtocols: ?*i32,
    // TODO: what to do with BytesParamIndex 2?
    lpProtocolBuffer: ?*WSAPROTOCOL_INFOW,
    lpdwBufferLength: ?*u32,
    lpErrno: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const WSCEnumProtocols32 = switch (@import("../zig.zig").arch) {
.X64, .Arm64 => (struct {

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ws2_32" fn WSCEnumProtocols32(
    lpiProtocols: ?*i32,
    // TODO: what to do with BytesParamIndex 2?
    lpProtocolBuffer: ?*WSAPROTOCOL_INFOW,
    lpdwBufferLength: ?*u32,
    lpErrno: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

}).WSCEnumProtocols32,
    else => |a| if (@import("builtin").is_test) void else @compileError("function 'WSCEnumProtocols32' is not supported on architecture " ++ @tagName(a)),
};

// TODO: this type is limited to platform 'windows5.0'
pub extern "ws2_32" fn WSCDeinstallProvider(
    lpProviderId: ?*Guid,
    lpErrno: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const WSCDeinstallProvider32 = switch (@import("../zig.zig").arch) {
.X64, .Arm64 => (struct {

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ws2_32" fn WSCDeinstallProvider32(
    lpProviderId: ?*Guid,
    lpErrno: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

}).WSCDeinstallProvider32,
    else => |a| if (@import("builtin").is_test) void else @compileError("function 'WSCDeinstallProvider32' is not supported on architecture " ++ @tagName(a)),
};

// TODO: this type is limited to platform 'windows5.0'
pub extern "ws2_32" fn WSCInstallProvider(
    lpProviderId: ?*Guid,
    lpszProviderDllPath: ?[*:0]const u16,
    lpProtocolInfoList: [*]const WSAPROTOCOL_INFOW,
    dwNumberOfEntries: u32,
    lpErrno: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const WSCInstallProvider64_32 = switch (@import("../zig.zig").arch) {
.X64, .Arm64 => (struct {

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ws2_32" fn WSCInstallProvider64_32(
    lpProviderId: ?*Guid,
    lpszProviderDllPath: ?[*:0]const u16,
    lpProtocolInfoList: [*]const WSAPROTOCOL_INFOW,
    dwNumberOfEntries: u32,
    lpErrno: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

}).WSCInstallProvider64_32,
    else => |a| if (@import("builtin").is_test) void else @compileError("function 'WSCInstallProvider64_32' is not supported on architecture " ++ @tagName(a)),
};

// TODO: this type is limited to platform 'windows5.0'
pub extern "ws2_32" fn WSCGetProviderPath(
    lpProviderId: ?*Guid,
    lpszProviderDllPath: [*:0]u16,
    lpProviderDllPathLen: ?*i32,
    lpErrno: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const WSCGetProviderPath32 = switch (@import("../zig.zig").arch) {
.X64, .Arm64 => (struct {

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ws2_32" fn WSCGetProviderPath32(
    lpProviderId: ?*Guid,
    lpszProviderDllPath: [*:0]u16,
    lpProviderDllPathLen: ?*i32,
    lpErrno: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

}).WSCGetProviderPath32,
    else => |a| if (@import("builtin").is_test) void else @compileError("function 'WSCGetProviderPath32' is not supported on architecture " ++ @tagName(a)),
};

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ws2_32" fn WSCUpdateProvider(
    lpProviderId: ?*Guid,
    lpszProviderDllPath: ?[*:0]const u16,
    lpProtocolInfoList: [*]const WSAPROTOCOL_INFOW,
    dwNumberOfEntries: u32,
    lpErrno: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const WSCUpdateProvider32 = switch (@import("../zig.zig").arch) {
.X64, .Arm64 => (struct {

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ws2_32" fn WSCUpdateProvider32(
    lpProviderId: ?*Guid,
    lpszProviderDllPath: ?[*:0]const u16,
    lpProtocolInfoList: [*]const WSAPROTOCOL_INFOW,
    dwNumberOfEntries: u32,
    lpErrno: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

}).WSCUpdateProvider32,
    else => |a| if (@import("builtin").is_test) void else @compileError("function 'WSCUpdateProvider32' is not supported on architecture " ++ @tagName(a)),
};

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ws2_32" fn WSCSetProviderInfo(
    lpProviderId: ?*Guid,
    InfoType: WSC_PROVIDER_INFO_TYPE,
    // TODO: what to do with BytesParamIndex 3?
    Info: ?*u8,
    InfoSize: usize,
    Flags: u32,
    lpErrno: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ws2_32" fn WSCGetProviderInfo(
    lpProviderId: ?*Guid,
    InfoType: WSC_PROVIDER_INFO_TYPE,
    // TODO: what to do with BytesParamIndex 3?
    Info: ?*u8,
    InfoSize: ?*usize,
    Flags: u32,
    lpErrno: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const WSCSetProviderInfo32 = switch (@import("../zig.zig").arch) {
.X64, .Arm64 => (struct {

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ws2_32" fn WSCSetProviderInfo32(
    lpProviderId: ?*Guid,
    InfoType: WSC_PROVIDER_INFO_TYPE,
    // TODO: what to do with BytesParamIndex 3?
    Info: ?*u8,
    InfoSize: usize,
    Flags: u32,
    lpErrno: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

}).WSCSetProviderInfo32,
    else => |a| if (@import("builtin").is_test) void else @compileError("function 'WSCSetProviderInfo32' is not supported on architecture " ++ @tagName(a)),
};

pub const WSCGetProviderInfo32 = switch (@import("../zig.zig").arch) {
.X64, .Arm64 => (struct {

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ws2_32" fn WSCGetProviderInfo32(
    lpProviderId: ?*Guid,
    InfoType: WSC_PROVIDER_INFO_TYPE,
    // TODO: what to do with BytesParamIndex 3?
    Info: ?*u8,
    InfoSize: ?*usize,
    Flags: u32,
    lpErrno: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

}).WSCGetProviderInfo32,
    else => |a| if (@import("builtin").is_test) void else @compileError("function 'WSCGetProviderInfo32' is not supported on architecture " ++ @tagName(a)),
};

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ws2_32" fn WSCSetApplicationCategory(
    Path: [*:0]const u16,
    PathLength: u32,
    Extra: ?[*:0]const u16,
    ExtraLength: u32,
    PermittedLspCategories: u32,
    pPrevPermLspCat: ?*u32,
    lpErrno: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ws2_32" fn WSCGetApplicationCategory(
    Path: [*:0]const u16,
    PathLength: u32,
    Extra: ?[*:0]const u16,
    ExtraLength: u32,
    pPermittedLspCategories: ?*u32,
    lpErrno: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ws2_32" fn WPUCompleteOverlappedRequest(
    s: ?SOCKET,
    lpOverlapped: ?*OVERLAPPED,
    dwError: u32,
    cbTransferred: u32,
    lpErrno: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const WSCEnumNameSpaceProviders32 = switch (@import("../zig.zig").arch) {
.X64, .Arm64 => (struct {

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ws2_32" fn WSCEnumNameSpaceProviders32(
    lpdwBufferLength: ?*u32,
    // TODO: what to do with BytesParamIndex 0?
    lpnspBuffer: ?*WSANAMESPACE_INFOW,
) callconv(@import("std").os.windows.WINAPI) i32;

}).WSCEnumNameSpaceProviders32,
    else => |a| if (@import("builtin").is_test) void else @compileError("function 'WSCEnumNameSpaceProviders32' is not supported on architecture " ++ @tagName(a)),
};

pub const WSCEnumNameSpaceProvidersEx32 = switch (@import("../zig.zig").arch) {
.X64, .Arm64 => (struct {

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ws2_32" fn WSCEnumNameSpaceProvidersEx32(
    lpdwBufferLength: ?*u32,
    // TODO: what to do with BytesParamIndex 0?
    lpnspBuffer: ?*WSANAMESPACE_INFOEXW,
) callconv(@import("std").os.windows.WINAPI) i32;

}).WSCEnumNameSpaceProvidersEx32,
    else => |a| if (@import("builtin").is_test) void else @compileError("function 'WSCEnumNameSpaceProvidersEx32' is not supported on architecture " ++ @tagName(a)),
};

// TODO: this type is limited to platform 'windows5.0'
pub extern "ws2_32" fn WSCInstallNameSpace(
    lpszIdentifier: ?PWSTR,
    lpszPathName: ?PWSTR,
    dwNameSpace: u32,
    dwVersion: u32,
    lpProviderId: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const WSCInstallNameSpace32 = switch (@import("../zig.zig").arch) {
.X64, .Arm64 => (struct {

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ws2_32" fn WSCInstallNameSpace32(
    lpszIdentifier: ?PWSTR,
    lpszPathName: ?PWSTR,
    dwNameSpace: u32,
    dwVersion: u32,
    lpProviderId: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) i32;

}).WSCInstallNameSpace32,
    else => |a| if (@import("builtin").is_test) void else @compileError("function 'WSCInstallNameSpace32' is not supported on architecture " ++ @tagName(a)),
};

// TODO: this type is limited to platform 'windows5.0'
pub extern "ws2_32" fn WSCUnInstallNameSpace(
    lpProviderId: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ws2_32" fn WSCInstallNameSpaceEx(
    lpszIdentifier: ?PWSTR,
    lpszPathName: ?PWSTR,
    dwNameSpace: u32,
    dwVersion: u32,
    lpProviderId: ?*Guid,
    lpProviderSpecific: ?*BLOB,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const WSCInstallNameSpaceEx32 = switch (@import("../zig.zig").arch) {
.X64, .Arm64 => (struct {

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ws2_32" fn WSCInstallNameSpaceEx32(
    lpszIdentifier: ?PWSTR,
    lpszPathName: ?PWSTR,
    dwNameSpace: u32,
    dwVersion: u32,
    lpProviderId: ?*Guid,
    lpProviderSpecific: ?*BLOB,
) callconv(@import("std").os.windows.WINAPI) i32;

}).WSCInstallNameSpaceEx32,
    else => |a| if (@import("builtin").is_test) void else @compileError("function 'WSCInstallNameSpaceEx32' is not supported on architecture " ++ @tagName(a)),
};

pub const WSCUnInstallNameSpace32 = switch (@import("../zig.zig").arch) {
.X64, .Arm64 => (struct {

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ws2_32" fn WSCUnInstallNameSpace32(
    lpProviderId: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) i32;

}).WSCUnInstallNameSpace32,
    else => |a| if (@import("builtin").is_test) void else @compileError("function 'WSCUnInstallNameSpace32' is not supported on architecture " ++ @tagName(a)),
};

// TODO: this type is limited to platform 'windows5.0'
pub extern "ws2_32" fn WSCEnableNSProvider(
    lpProviderId: ?*Guid,
    fEnable: BOOL,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const WSCEnableNSProvider32 = switch (@import("../zig.zig").arch) {
.X64, .Arm64 => (struct {

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ws2_32" fn WSCEnableNSProvider32(
    lpProviderId: ?*Guid,
    fEnable: BOOL,
) callconv(@import("std").os.windows.WINAPI) i32;

}).WSCEnableNSProvider32,
    else => |a| if (@import("builtin").is_test) void else @compileError("function 'WSCEnableNSProvider32' is not supported on architecture " ++ @tagName(a)),
};

pub const WSCInstallProviderAndChains64_32 = switch (@import("../zig.zig").arch) {
.X64, .Arm64 => (struct {

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ws2_32" fn WSCInstallProviderAndChains64_32(
    lpProviderId: ?*Guid,
    lpszProviderDllPath: ?[*:0]const u16,
    lpszProviderDllPath32: ?[*:0]const u16,
    lpszLspName: ?[*:0]const u16,
    dwServiceFlags: u32,
    lpProtocolInfoList: [*]WSAPROTOCOL_INFOW,
    dwNumberOfEntries: u32,
    lpdwCatalogEntryId: ?*u32,
    lpErrno: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

}).WSCInstallProviderAndChains64_32,
    else => |a| if (@import("builtin").is_test) void else @compileError("function 'WSCInstallProviderAndChains64_32' is not supported on architecture " ++ @tagName(a)),
};

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ws2_32" fn WSAAdvertiseProvider(
    puuidProviderId: ?*const Guid,
    pNSPv2Routine: ?*const NSPV2_ROUTINE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ws2_32" fn WSAUnadvertiseProvider(
    puuidProviderId: ?*const Guid,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ws2_32" fn WSAProviderCompleteAsyncCall(
    hAsyncCall: ?HANDLE,
    iRetCode: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "mswsock" fn EnumProtocolsA(
    lpiProtocols: ?*i32,
    // TODO: what to do with BytesParamIndex 2?
    lpProtocolBuffer: ?*anyopaque,
    lpdwBufferLength: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "mswsock" fn EnumProtocolsW(
    lpiProtocols: ?*i32,
    // TODO: what to do with BytesParamIndex 2?
    lpProtocolBuffer: ?*anyopaque,
    lpdwBufferLength: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "mswsock" fn GetAddressByNameA(
    dwNameSpace: u32,
    lpServiceType: ?*Guid,
    lpServiceName: ?PSTR,
    lpiProtocols: ?*i32,
    dwResolution: u32,
    lpServiceAsyncInfo: ?*SERVICE_ASYNC_INFO,
    // TODO: what to do with BytesParamIndex 7?
    lpCsaddrBuffer: ?*anyopaque,
    lpdwBufferLength: ?*u32,
    lpAliasBuffer: ?[*:0]u8,
    lpdwAliasBufferLength: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "mswsock" fn GetAddressByNameW(
    dwNameSpace: u32,
    lpServiceType: ?*Guid,
    lpServiceName: ?PWSTR,
    lpiProtocols: ?*i32,
    dwResolution: u32,
    lpServiceAsyncInfo: ?*SERVICE_ASYNC_INFO,
    // TODO: what to do with BytesParamIndex 7?
    lpCsaddrBuffer: ?*anyopaque,
    lpdwBufferLength: ?*u32,
    lpAliasBuffer: ?[*:0]u16,
    lpdwAliasBufferLength: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "mswsock" fn GetTypeByNameA(
    lpServiceName: ?PSTR,
    lpServiceType: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "mswsock" fn GetTypeByNameW(
    lpServiceName: ?PWSTR,
    lpServiceType: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "mswsock" fn GetNameByTypeA(
    lpServiceType: ?*Guid,
    // TODO: what to do with BytesParamIndex 2?
    lpServiceName: ?PSTR,
    dwNameLength: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "mswsock" fn GetNameByTypeW(
    lpServiceType: ?*Guid,
    // TODO: what to do with BytesParamIndex 2?
    lpServiceName: ?PWSTR,
    dwNameLength: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "mswsock" fn SetServiceA(
    dwNameSpace: u32,
    dwOperation: SET_SERVICE_OPERATION,
    dwFlags: u32,
    lpServiceInfo: ?*SERVICE_INFOA,
    lpServiceAsyncInfo: ?*SERVICE_ASYNC_INFO,
    lpdwStatusFlags: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "mswsock" fn SetServiceW(
    dwNameSpace: u32,
    dwOperation: SET_SERVICE_OPERATION,
    dwFlags: u32,
    lpServiceInfo: ?*SERVICE_INFOW,
    lpServiceAsyncInfo: ?*SERVICE_ASYNC_INFO,
    lpdwStatusFlags: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "mswsock" fn GetServiceA(
    dwNameSpace: u32,
    lpGuid: ?*Guid,
    lpServiceName: ?PSTR,
    dwProperties: u32,
    // TODO: what to do with BytesParamIndex 5?
    lpBuffer: ?*anyopaque,
    lpdwBufferSize: ?*u32,
    lpServiceAsyncInfo: ?*SERVICE_ASYNC_INFO,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "mswsock" fn GetServiceW(
    dwNameSpace: u32,
    lpGuid: ?*Guid,
    lpServiceName: ?PWSTR,
    dwProperties: u32,
    // TODO: what to do with BytesParamIndex 5?
    lpBuffer: ?*anyopaque,
    lpdwBufferSize: ?*u32,
    lpServiceAsyncInfo: ?*SERVICE_ASYNC_INFO,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn getaddrinfo(
    pNodeName: ?[*:0]const u8,
    pServiceName: ?[*:0]const u8,
    pHints: ?*const ADDRINFOA,
    ppResult: ?*?*ADDRINFOA,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn GetAddrInfoW(
    pNodeName: ?[*:0]const u16,
    pServiceName: ?[*:0]const u16,
    pHints: ?*const addrinfoW,
    ppResult: ?*?*addrinfoW,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ws2_32" fn GetAddrInfoExA(
    pName: ?[*:0]const u8,
    pServiceName: ?[*:0]const u8,
    dwNameSpace: u32,
    lpNspId: ?*Guid,
    hints: ?*const addrinfoexA,
    ppResult: ?*?*addrinfoexA,
    timeout: ?*timeval,
    lpOverlapped: ?*OVERLAPPED,
    lpCompletionRoutine: ?LPLOOKUPSERVICE_COMPLETION_ROUTINE,
    lpNameHandle: ?*?HANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ws2_32" fn GetAddrInfoExW(
    pName: ?[*:0]const u16,
    pServiceName: ?[*:0]const u16,
    dwNameSpace: u32,
    lpNspId: ?*Guid,
    hints: ?*const addrinfoexW,
    ppResult: ?*?*addrinfoexW,
    timeout: ?*timeval,
    lpOverlapped: ?*OVERLAPPED,
    lpCompletionRoutine: ?LPLOOKUPSERVICE_COMPLETION_ROUTINE,
    lpHandle: ?*?HANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn GetAddrInfoExCancel(
    lpHandle: ?*?HANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn GetAddrInfoExOverlappedResult(
    lpOverlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn SetAddrInfoExA(
    pName: ?[*:0]const u8,
    pServiceName: ?[*:0]const u8,
    pAddresses: ?*SOCKET_ADDRESS,
    dwAddressCount: u32,
    lpBlob: ?*BLOB,
    dwFlags: u32,
    dwNameSpace: u32,
    lpNspId: ?*Guid,
    timeout: ?*timeval,
    lpOverlapped: ?*OVERLAPPED,
    lpCompletionRoutine: ?LPLOOKUPSERVICE_COMPLETION_ROUTINE,
    lpNameHandle: ?*?HANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn SetAddrInfoExW(
    pName: ?[*:0]const u16,
    pServiceName: ?[*:0]const u16,
    pAddresses: ?*SOCKET_ADDRESS,
    dwAddressCount: u32,
    lpBlob: ?*BLOB,
    dwFlags: u32,
    dwNameSpace: u32,
    lpNspId: ?*Guid,
    timeout: ?*timeval,
    lpOverlapped: ?*OVERLAPPED,
    lpCompletionRoutine: ?LPLOOKUPSERVICE_COMPLETION_ROUTINE,
    lpNameHandle: ?*?HANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn freeaddrinfo(
    pAddrInfo: ?*ADDRINFOA,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn FreeAddrInfoW(
    pAddrInfo: ?*addrinfoW,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn FreeAddrInfoEx(
    pAddrInfoEx: ?*addrinfoexA,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn FreeAddrInfoExW(
    pAddrInfoEx: ?*addrinfoexW,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn getnameinfo(
    // TODO: what to do with BytesParamIndex 1?
    pSockaddr: ?*const SOCKADDR,
    SockaddrLength: i32,
    pNodeBuffer: ?[*]u8,
    NodeBufferSize: u32,
    pServiceBuffer: ?[*]u8,
    ServiceBufferSize: u32,
    Flags: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn GetNameInfoW(
    // TODO: what to do with BytesParamIndex 1?
    pSockaddr: ?*const SOCKADDR,
    SockaddrLength: i32,
    pNodeBuffer: ?[*]u16,
    NodeBufferSize: u32,
    pServiceBuffer: ?[*]u16,
    ServiceBufferSize: u32,
    Flags: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn inet_pton(
    Family: i32,
    pszAddrString: ?[*:0]const u8,
    pAddrBuf: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn InetPtonW(
    Family: i32,
    pszAddrString: ?[*:0]const u16,
    pAddrBuf: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn inet_ntop(
    Family: i32,
    pAddr: ?*const anyopaque,
    pStringBuf: [*:0]u8,
    StringBufSize: usize,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn InetNtopW(
    Family: i32,
    pAddr: ?*const anyopaque,
    pStringBuf: [*:0]u16,
    StringBufSize: usize,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "fwpuclnt" fn WSASetSocketSecurity(
    Socket: ?SOCKET,
    // TODO: what to do with BytesParamIndex 2?
    SecuritySettings: ?*const SOCKET_SECURITY_SETTINGS,
    SecuritySettingsLen: u32,
    Overlapped: ?*OVERLAPPED,
    CompletionRoutine: ?LPWSAOVERLAPPED_COMPLETION_ROUTINE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "fwpuclnt" fn WSAQuerySocketSecurity(
    Socket: ?SOCKET,
    // TODO: what to do with BytesParamIndex 2?
    SecurityQueryTemplate: ?*const SOCKET_SECURITY_QUERY_TEMPLATE,
    SecurityQueryTemplateLen: u32,
    // TODO: what to do with BytesParamIndex 4?
    SecurityQueryInfo: ?*SOCKET_SECURITY_QUERY_INFO,
    SecurityQueryInfoLen: ?*u32,
    Overlapped: ?*OVERLAPPED,
    CompletionRoutine: ?LPWSAOVERLAPPED_COMPLETION_ROUTINE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "fwpuclnt" fn WSASetSocketPeerTargetName(
    Socket: ?SOCKET,
    // TODO: what to do with BytesParamIndex 2?
    PeerTargetName: ?*const SOCKET_PEER_TARGET_NAME,
    PeerTargetNameLen: u32,
    Overlapped: ?*OVERLAPPED,
    CompletionRoutine: ?LPWSAOVERLAPPED_COMPLETION_ROUTINE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "fwpuclnt" fn WSADeleteSocketPeerTargetName(
    Socket: ?SOCKET,
    // TODO: what to do with BytesParamIndex 2?
    PeerAddr: ?*const SOCKADDR,
    PeerAddrLen: u32,
    Overlapped: ?*OVERLAPPED,
    CompletionRoutine: ?LPWSAOVERLAPPED_COMPLETION_ROUTINE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "fwpuclnt" fn WSAImpersonateSocketPeer(
    Socket: ?SOCKET,
    // TODO: what to do with BytesParamIndex 2?
    PeerAddr: ?*const SOCKADDR,
    PeerAddrLen: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "fwpuclnt" fn WSARevertImpersonation(
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "windows.networking" fn SetSocketMediaStreamingMode(
    value: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ws2_32" fn WSCWriteProviderOrder(
    lpwdCatalogEntryId: ?*u32,
    dwNumberOfEntries: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const WSCWriteProviderOrder32 = switch (@import("../zig.zig").arch) {
.X64, .Arm64 => (struct {

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ws2_32" fn WSCWriteProviderOrder32(
    lpwdCatalogEntryId: ?*u32,
    dwNumberOfEntries: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

}).WSCWriteProviderOrder32,
    else => |a| if (@import("builtin").is_test) void else @compileError("function 'WSCWriteProviderOrder32' is not supported on architecture " ++ @tagName(a)),
};

// TODO: this type is limited to platform 'windows5.0'
pub extern "ws2_32" fn WSCWriteNameSpaceOrder(
    lpProviderId: ?*Guid,
    dwNumberOfEntries: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const WSCWriteNameSpaceOrder32 = switch (@import("../zig.zig").arch) {
.X64, .Arm64 => (struct {

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ws2_32" fn WSCWriteNameSpaceOrder32(
    lpProviderId: ?*Guid,
    dwNumberOfEntries: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

}).WSCWriteNameSpaceOrder32,
    else => |a| if (@import("builtin").is_test) void else @compileError("function 'WSCWriteNameSpaceOrder32' is not supported on architecture " ++ @tagName(a)),
};


//--------------------------------------------------------------------------------
// Section: Unicode Aliases (48)
//--------------------------------------------------------------------------------
pub const addrinfoex = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().addrinfoexA,
    .wide => @This().addrinfoexW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'addrinfoex' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const addrinfoex2 = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().addrinfoex2A,
    .wide => @This().addrinfoex2W,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'addrinfoex2' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const WSAPROTOCOL_INFO = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().WSAPROTOCOL_INFOA,
    .wide => @This().WSAPROTOCOL_INFOW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'WSAPROTOCOL_INFO' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const WSAQUERYSET = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().WSAQUERYSETA,
    .wide => @This().WSAQUERYSETW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'WSAQUERYSET' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const WSAQUERYSET2 = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().WSAQUERYSET2A,
    .wide => @This().WSAQUERYSET2W,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'WSAQUERYSET2' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const WSANSCLASSINFO = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().WSANSCLASSINFOA,
    .wide => @This().WSANSCLASSINFOW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'WSANSCLASSINFO' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const WSASERVICECLASSINFO = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().WSASERVICECLASSINFOA,
    .wide => @This().WSASERVICECLASSINFOW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'WSASERVICECLASSINFO' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const WSANAMESPACE_INFO = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().WSANAMESPACE_INFOA,
    .wide => @This().WSANAMESPACE_INFOW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'WSANAMESPACE_INFO' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const WSANAMESPACE_INFOEX = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().WSANAMESPACE_INFOEXA,
    .wide => @This().WSANAMESPACE_INFOEXW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'WSANAMESPACE_INFOEX' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const NS_INFO = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().NS_INFOA,
    .wide => @This().NS_INFOW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'NS_INFO' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const SERVICE_TYPE_VALUE_ABS = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().SERVICE_TYPE_VALUE_ABSA,
    .wide => @This().SERVICE_TYPE_VALUE_ABSW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'SERVICE_TYPE_VALUE_ABS' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const SERVICE_TYPE_INFO_ABS = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().SERVICE_TYPE_INFO_ABSA,
    .wide => @This().SERVICE_TYPE_INFO_ABSW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'SERVICE_TYPE_INFO_ABS' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const SERVICE_INFO = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().SERVICE_INFOA,
    .wide => @This().SERVICE_INFOW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'SERVICE_INFO' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const NS_SERVICE_INFO = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().NS_SERVICE_INFOA,
    .wide => @This().NS_SERVICE_INFOW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'NS_SERVICE_INFO' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const PROTOCOL_INFO = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().PROTOCOL_INFOA,
    .wide => @This().PROTOCOL_INFOW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'PROTOCOL_INFO' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const NETRESOURCE2 = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().NETRESOURCE2A,
    .wide => @This().NETRESOURCE2W,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'NETRESOURCE2' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const WSAConnectByName = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().WSAConnectByNameA,
    .wide => @This().WSAConnectByNameW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'WSAConnectByName' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const WSADuplicateSocket = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().WSADuplicateSocketA,
    .wide => @This().WSADuplicateSocketW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'WSADuplicateSocket' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const WSAEnumProtocols = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().WSAEnumProtocolsA,
    .wide => @This().WSAEnumProtocolsW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'WSAEnumProtocols' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const WSASocket = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().WSASocketA,
    .wide => @This().WSASocketW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'WSASocket' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const WSAAddressToString = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().WSAAddressToStringA,
    .wide => @This().WSAAddressToStringW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'WSAAddressToString' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const WSAStringToAddress = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().WSAStringToAddressA,
    .wide => @This().WSAStringToAddressW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'WSAStringToAddress' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const WSALookupServiceBegin = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().WSALookupServiceBeginA,
    .wide => @This().WSALookupServiceBeginW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'WSALookupServiceBegin' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const WSALookupServiceNext = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().WSALookupServiceNextA,
    .wide => @This().WSALookupServiceNextW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'WSALookupServiceNext' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const WSAInstallServiceClass = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().WSAInstallServiceClassA,
    .wide => @This().WSAInstallServiceClassW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'WSAInstallServiceClass' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const WSAGetServiceClassInfo = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().WSAGetServiceClassInfoA,
    .wide => @This().WSAGetServiceClassInfoW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'WSAGetServiceClassInfo' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const WSAEnumNameSpaceProviders = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().WSAEnumNameSpaceProvidersA,
    .wide => @This().WSAEnumNameSpaceProvidersW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'WSAEnumNameSpaceProviders' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const WSAEnumNameSpaceProvidersEx = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().WSAEnumNameSpaceProvidersExA,
    .wide => @This().WSAEnumNameSpaceProvidersExW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'WSAEnumNameSpaceProvidersEx' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const WSAGetServiceClassNameByClassId = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().WSAGetServiceClassNameByClassIdA,
    .wide => @This().WSAGetServiceClassNameByClassIdW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'WSAGetServiceClassNameByClassId' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const WSASetService = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().WSASetServiceA,
    .wide => @This().WSASetServiceW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'WSASetService' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const RtlIpv4AddressToString = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().RtlIpv4AddressToStringA,
    .wide => @This().RtlIpv4AddressToStringW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'RtlIpv4AddressToString' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const RtlIpv4AddressToStringEx = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().RtlIpv4AddressToStringExA,
    .wide => @This().RtlIpv4AddressToStringExW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'RtlIpv4AddressToStringEx' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const RtlIpv4StringToAddress = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().RtlIpv4StringToAddressA,
    .wide => @This().RtlIpv4StringToAddressW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'RtlIpv4StringToAddress' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const RtlIpv4StringToAddressEx = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().RtlIpv4StringToAddressExA,
    .wide => @This().RtlIpv4StringToAddressExW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'RtlIpv4StringToAddressEx' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const RtlIpv6AddressToString = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().RtlIpv6AddressToStringA,
    .wide => @This().RtlIpv6AddressToStringW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'RtlIpv6AddressToString' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const RtlIpv6AddressToStringEx = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().RtlIpv6AddressToStringExA,
    .wide => @This().RtlIpv6AddressToStringExW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'RtlIpv6AddressToStringEx' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const RtlIpv6StringToAddress = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().RtlIpv6StringToAddressA,
    .wide => @This().RtlIpv6StringToAddressW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'RtlIpv6StringToAddress' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const RtlIpv6StringToAddressEx = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().RtlIpv6StringToAddressExA,
    .wide => @This().RtlIpv6StringToAddressExW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'RtlIpv6StringToAddressEx' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const RtlEthernetAddressToString = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().RtlEthernetAddressToStringA,
    .wide => @This().RtlEthernetAddressToStringW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'RtlEthernetAddressToString' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const RtlEthernetStringToAddress = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().RtlEthernetStringToAddressA,
    .wide => @This().RtlEthernetStringToAddressW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'RtlEthernetStringToAddress' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const EnumProtocols = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().EnumProtocolsA,
    .wide => @This().EnumProtocolsW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'EnumProtocols' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const GetAddressByName = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().GetAddressByNameA,
    .wide => @This().GetAddressByNameW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'GetAddressByName' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const GetTypeByName = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().GetTypeByNameA,
    .wide => @This().GetTypeByNameW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'GetTypeByName' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const GetNameByType = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().GetNameByTypeA,
    .wide => @This().GetNameByTypeW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'GetNameByType' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const SetService = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().SetServiceA,
    .wide => @This().SetServiceW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'SetService' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const GetService = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().GetServiceA,
    .wide => @This().GetServiceW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'GetService' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const GetAddrInfoEx = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().GetAddrInfoExA,
    .wide => @This().GetAddrInfoExW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'GetAddrInfoEx' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const SetAddrInfoEx = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().SetAddrInfoExA,
    .wide => @This().SetAddrInfoExW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'SetAddrInfoEx' requires that UNICODE be set to true or false in the root module",
    ),
};
//--------------------------------------------------------------------------------
// Section: Imports (19)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const BLOB = @import("../system/com.zig").BLOB;
const BOOL = @import("../foundation.zig").BOOL;
const BOOLEAN = @import("../foundation.zig").BOOLEAN;
const CHAR = @import("../foundation.zig").CHAR;
const COMPARTMENT_ID = @import("../system/kernel.zig").COMPARTMENT_ID;
const FARPROC = @import("../foundation.zig").FARPROC;
const HANDLE = @import("../foundation.zig").HANDLE;
const HRESULT = @import("../foundation.zig").HRESULT;
const HWND = @import("../foundation.zig").HWND;
const LARGE_INTEGER = @import("../foundation.zig").LARGE_INTEGER;
const LPARAM = @import("../foundation.zig").LPARAM;
const LUID = @import("../foundation.zig").LUID;
const OVERLAPPED = @import("../system/io.zig").OVERLAPPED;
const OVERLAPPED_ENTRY = @import("../system/io.zig").OVERLAPPED_ENTRY;
const PROCESSOR_NUMBER = @import("../system/kernel.zig").PROCESSOR_NUMBER;
const PSTR = @import("../foundation.zig").PSTR;
const PWSTR = @import("../foundation.zig").PWSTR;
const WPARAM = @import("../foundation.zig").WPARAM;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "LPCONDITIONPROC")) { _ = LPCONDITIONPROC; }
    if (@hasDecl(@This(), "LPWSAOVERLAPPED_COMPLETION_ROUTINE")) { _ = LPWSAOVERLAPPED_COMPLETION_ROUTINE; }
    if (@hasDecl(@This(), "LPFN_TRANSMITFILE")) { _ = LPFN_TRANSMITFILE; }
    if (@hasDecl(@This(), "LPFN_ACCEPTEX")) { _ = LPFN_ACCEPTEX; }
    if (@hasDecl(@This(), "LPFN_GETACCEPTEXSOCKADDRS")) { _ = LPFN_GETACCEPTEXSOCKADDRS; }
    if (@hasDecl(@This(), "LPFN_TRANSMITPACKETS")) { _ = LPFN_TRANSMITPACKETS; }
    if (@hasDecl(@This(), "LPFN_CONNECTEX")) { _ = LPFN_CONNECTEX; }
    if (@hasDecl(@This(), "LPFN_DISCONNECTEX")) { _ = LPFN_DISCONNECTEX; }
    if (@hasDecl(@This(), "LPFN_WSARECVMSG")) { _ = LPFN_WSARECVMSG; }
    if (@hasDecl(@This(), "LPFN_WSASENDMSG")) { _ = LPFN_WSASENDMSG; }
    if (@hasDecl(@This(), "LPFN_WSAPOLL")) { _ = LPFN_WSAPOLL; }
    if (@hasDecl(@This(), "LPFN_RIORECEIVE")) { _ = LPFN_RIORECEIVE; }
    if (@hasDecl(@This(), "LPFN_RIORECEIVEEX")) { _ = LPFN_RIORECEIVEEX; }
    if (@hasDecl(@This(), "LPFN_RIOSEND")) { _ = LPFN_RIOSEND; }
    if (@hasDecl(@This(), "LPFN_RIOSENDEX")) { _ = LPFN_RIOSENDEX; }
    if (@hasDecl(@This(), "LPFN_RIOCLOSECOMPLETIONQUEUE")) { _ = LPFN_RIOCLOSECOMPLETIONQUEUE; }
    if (@hasDecl(@This(), "LPFN_RIOCREATECOMPLETIONQUEUE")) { _ = LPFN_RIOCREATECOMPLETIONQUEUE; }
    if (@hasDecl(@This(), "LPFN_RIOCREATEREQUESTQUEUE")) { _ = LPFN_RIOCREATEREQUESTQUEUE; }
    if (@hasDecl(@This(), "LPFN_RIODEQUEUECOMPLETION")) { _ = LPFN_RIODEQUEUECOMPLETION; }
    if (@hasDecl(@This(), "LPFN_RIODEREGISTERBUFFER")) { _ = LPFN_RIODEREGISTERBUFFER; }
    if (@hasDecl(@This(), "LPFN_RIONOTIFY")) { _ = LPFN_RIONOTIFY; }
    if (@hasDecl(@This(), "LPFN_RIOREGISTERBUFFER")) { _ = LPFN_RIOREGISTERBUFFER; }
    if (@hasDecl(@This(), "LPFN_RIORESIZECOMPLETIONQUEUE")) { _ = LPFN_RIORESIZECOMPLETIONQUEUE; }
    if (@hasDecl(@This(), "LPFN_RIORESIZEREQUESTQUEUE")) { _ = LPFN_RIORESIZEREQUESTQUEUE; }
    if (@hasDecl(@This(), "LPBLOCKINGCALLBACK")) { _ = LPBLOCKINGCALLBACK; }
    if (@hasDecl(@This(), "LPWSAUSERAPC")) { _ = LPWSAUSERAPC; }
    if (@hasDecl(@This(), "LPWSPACCEPT")) { _ = LPWSPACCEPT; }
    if (@hasDecl(@This(), "LPWSPADDRESSTOSTRING")) { _ = LPWSPADDRESSTOSTRING; }
    if (@hasDecl(@This(), "LPWSPASYNCSELECT")) { _ = LPWSPASYNCSELECT; }
    if (@hasDecl(@This(), "LPWSPBIND")) { _ = LPWSPBIND; }
    if (@hasDecl(@This(), "LPWSPCANCELBLOCKINGCALL")) { _ = LPWSPCANCELBLOCKINGCALL; }
    if (@hasDecl(@This(), "LPWSPCLEANUP")) { _ = LPWSPCLEANUP; }
    if (@hasDecl(@This(), "LPWSPCLOSESOCKET")) { _ = LPWSPCLOSESOCKET; }
    if (@hasDecl(@This(), "LPWSPCONNECT")) { _ = LPWSPCONNECT; }
    if (@hasDecl(@This(), "LPWSPDUPLICATESOCKET")) { _ = LPWSPDUPLICATESOCKET; }
    if (@hasDecl(@This(), "LPWSPENUMNETWORKEVENTS")) { _ = LPWSPENUMNETWORKEVENTS; }
    if (@hasDecl(@This(), "LPWSPEVENTSELECT")) { _ = LPWSPEVENTSELECT; }
    if (@hasDecl(@This(), "LPWSPGETOVERLAPPEDRESULT")) { _ = LPWSPGETOVERLAPPEDRESULT; }
    if (@hasDecl(@This(), "LPWSPGETPEERNAME")) { _ = LPWSPGETPEERNAME; }
    if (@hasDecl(@This(), "LPWSPGETSOCKNAME")) { _ = LPWSPGETSOCKNAME; }
    if (@hasDecl(@This(), "LPWSPGETSOCKOPT")) { _ = LPWSPGETSOCKOPT; }
    if (@hasDecl(@This(), "LPWSPGETQOSBYNAME")) { _ = LPWSPGETQOSBYNAME; }
    if (@hasDecl(@This(), "LPWSPIOCTL")) { _ = LPWSPIOCTL; }
    if (@hasDecl(@This(), "LPWSPJOINLEAF")) { _ = LPWSPJOINLEAF; }
    if (@hasDecl(@This(), "LPWSPLISTEN")) { _ = LPWSPLISTEN; }
    if (@hasDecl(@This(), "LPWSPRECV")) { _ = LPWSPRECV; }
    if (@hasDecl(@This(), "LPWSPRECVDISCONNECT")) { _ = LPWSPRECVDISCONNECT; }
    if (@hasDecl(@This(), "LPWSPRECVFROM")) { _ = LPWSPRECVFROM; }
    if (@hasDecl(@This(), "LPWSPSELECT")) { _ = LPWSPSELECT; }
    if (@hasDecl(@This(), "LPWSPSEND")) { _ = LPWSPSEND; }
    if (@hasDecl(@This(), "LPWSPSENDDISCONNECT")) { _ = LPWSPSENDDISCONNECT; }
    if (@hasDecl(@This(), "LPWSPSENDTO")) { _ = LPWSPSENDTO; }
    if (@hasDecl(@This(), "LPWSPSETSOCKOPT")) { _ = LPWSPSETSOCKOPT; }
    if (@hasDecl(@This(), "LPWSPSHUTDOWN")) { _ = LPWSPSHUTDOWN; }
    if (@hasDecl(@This(), "LPWSPSOCKET")) { _ = LPWSPSOCKET; }
    if (@hasDecl(@This(), "LPWSPSTRINGTOADDRESS")) { _ = LPWSPSTRINGTOADDRESS; }
    if (@hasDecl(@This(), "LPWPUCLOSEEVENT")) { _ = LPWPUCLOSEEVENT; }
    if (@hasDecl(@This(), "LPWPUCLOSESOCKETHANDLE")) { _ = LPWPUCLOSESOCKETHANDLE; }
    if (@hasDecl(@This(), "LPWPUCREATEEVENT")) { _ = LPWPUCREATEEVENT; }
    if (@hasDecl(@This(), "LPWPUCREATESOCKETHANDLE")) { _ = LPWPUCREATESOCKETHANDLE; }
    if (@hasDecl(@This(), "LPWPUFDISSET")) { _ = LPWPUFDISSET; }
    if (@hasDecl(@This(), "LPWPUGETPROVIDERPATH")) { _ = LPWPUGETPROVIDERPATH; }
    if (@hasDecl(@This(), "LPWPUMODIFYIFSHANDLE")) { _ = LPWPUMODIFYIFSHANDLE; }
    if (@hasDecl(@This(), "LPWPUPOSTMESSAGE")) { _ = LPWPUPOSTMESSAGE; }
    if (@hasDecl(@This(), "LPWPUQUERYBLOCKINGCALLBACK")) { _ = LPWPUQUERYBLOCKINGCALLBACK; }
    if (@hasDecl(@This(), "LPWPUQUERYSOCKETHANDLECONTEXT")) { _ = LPWPUQUERYSOCKETHANDLECONTEXT; }
    if (@hasDecl(@This(), "LPWPUQUEUEAPC")) { _ = LPWPUQUEUEAPC; }
    if (@hasDecl(@This(), "LPWPURESETEVENT")) { _ = LPWPURESETEVENT; }
    if (@hasDecl(@This(), "LPWPUSETEVENT")) { _ = LPWPUSETEVENT; }
    if (@hasDecl(@This(), "LPWPUOPENCURRENTTHREAD")) { _ = LPWPUOPENCURRENTTHREAD; }
    if (@hasDecl(@This(), "LPWPUCLOSETHREAD")) { _ = LPWPUCLOSETHREAD; }
    if (@hasDecl(@This(), "LPWPUCOMPLETEOVERLAPPEDREQUEST")) { _ = LPWPUCOMPLETEOVERLAPPEDREQUEST; }
    if (@hasDecl(@This(), "LPWSPSTARTUP")) { _ = LPWSPSTARTUP; }
    if (@hasDecl(@This(), "LPWSCENUMPROTOCOLS")) { _ = LPWSCENUMPROTOCOLS; }
    if (@hasDecl(@This(), "LPWSCDEINSTALLPROVIDER")) { _ = LPWSCDEINSTALLPROVIDER; }
    if (@hasDecl(@This(), "LPWSCINSTALLPROVIDER")) { _ = LPWSCINSTALLPROVIDER; }
    if (@hasDecl(@This(), "LPWSCGETPROVIDERPATH")) { _ = LPWSCGETPROVIDERPATH; }
    if (@hasDecl(@This(), "LPWSCUPDATEPROVIDER")) { _ = LPWSCUPDATEPROVIDER; }
    if (@hasDecl(@This(), "LPWSCINSTALLNAMESPACE")) { _ = LPWSCINSTALLNAMESPACE; }
    if (@hasDecl(@This(), "LPWSCUNINSTALLNAMESPACE")) { _ = LPWSCUNINSTALLNAMESPACE; }
    if (@hasDecl(@This(), "LPWSCENABLENSPROVIDER")) { _ = LPWSCENABLENSPROVIDER; }
    if (@hasDecl(@This(), "LPNSPCLEANUP")) { _ = LPNSPCLEANUP; }
    if (@hasDecl(@This(), "LPNSPLOOKUPSERVICEBEGIN")) { _ = LPNSPLOOKUPSERVICEBEGIN; }
    if (@hasDecl(@This(), "LPNSPLOOKUPSERVICENEXT")) { _ = LPNSPLOOKUPSERVICENEXT; }
    if (@hasDecl(@This(), "LPNSPIOCTL")) { _ = LPNSPIOCTL; }
    if (@hasDecl(@This(), "LPNSPLOOKUPSERVICEEND")) { _ = LPNSPLOOKUPSERVICEEND; }
    if (@hasDecl(@This(), "LPNSPSETSERVICE")) { _ = LPNSPSETSERVICE; }
    if (@hasDecl(@This(), "LPNSPINSTALLSERVICECLASS")) { _ = LPNSPINSTALLSERVICECLASS; }
    if (@hasDecl(@This(), "LPNSPREMOVESERVICECLASS")) { _ = LPNSPREMOVESERVICECLASS; }
    if (@hasDecl(@This(), "LPNSPGETSERVICECLASSINFO")) { _ = LPNSPGETSERVICECLASSINFO; }
    if (@hasDecl(@This(), "LPNSPSTARTUP")) { _ = LPNSPSTARTUP; }
    if (@hasDecl(@This(), "LPNSPV2STARTUP")) { _ = LPNSPV2STARTUP; }
    if (@hasDecl(@This(), "LPNSPV2CLEANUP")) { _ = LPNSPV2CLEANUP; }
    if (@hasDecl(@This(), "LPNSPV2LOOKUPSERVICEBEGIN")) { _ = LPNSPV2LOOKUPSERVICEBEGIN; }
    if (@hasDecl(@This(), "LPNSPV2LOOKUPSERVICENEXTEX")) { _ = LPNSPV2LOOKUPSERVICENEXTEX; }
    if (@hasDecl(@This(), "LPNSPV2LOOKUPSERVICEEND")) { _ = LPNSPV2LOOKUPSERVICEEND; }
    if (@hasDecl(@This(), "LPNSPV2SETSERVICEEX")) { _ = LPNSPV2SETSERVICEEX; }
    if (@hasDecl(@This(), "LPNSPV2CLIENTSESSIONRUNDOWN")) { _ = LPNSPV2CLIENTSESSIONRUNDOWN; }
    if (@hasDecl(@This(), "LPFN_NSPAPI")) { _ = LPFN_NSPAPI; }
    if (@hasDecl(@This(), "LPSERVICE_CALLBACK_PROC")) { _ = LPSERVICE_CALLBACK_PROC; }
    if (@hasDecl(@This(), "LPLOOKUPSERVICE_COMPLETION_ROUTINE")) { _ = LPLOOKUPSERVICE_COMPLETION_ROUTINE; }
    if (@hasDecl(@This(), "LPWSCWRITEPROVIDERORDER")) { _ = LPWSCWRITEPROVIDERORDER; }
    if (@hasDecl(@This(), "LPWSCWRITENAMESPACEORDER")) { _ = LPWSCWRITENAMESPACEORDER; }

    @setEvalBranchQuota(
        comptime @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        _ = @field(@This(), decl.name);
    }
}
