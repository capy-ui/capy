//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (939)
//--------------------------------------------------------------------------------
pub const SOCKET_DEFAULT2_QM_POLICY = Guid.initString("aec2ef9c-3a4d-4d3e-8842-239942e39a47");
pub const REAL_TIME_NOTIFICATION_CAPABILITY = Guid.initString("6b59819a-5cae-492d-a901-2a3c2c50164f");
pub const REAL_TIME_NOTIFICATION_CAPABILITY_EX = Guid.initString("6843da03-154a-4616-a508-44371295f96b");
pub const ASSOCIATE_NAMERES_CONTEXT = Guid.initString("59a38b67-d4fe-46e1-ba3c-87ea74ca3049");
pub const TIMESTAMPING_FLAG_RX = @as(u32, 1);
pub const TIMESTAMPING_FLAG_TX = @as(u32, 2);
pub const SO_TIMESTAMP = @as(u32, 12298);
pub const SO_TIMESTAMP_ID = @as(u32, 12299);
pub const TCP_INITIAL_RTO_DEFAULT_RTT = @as(u32, 0);
pub const TCP_INITIAL_RTO_DEFAULT_MAX_SYN_RETRANSMISSIONS = @as(u32, 0);
pub const SOCKET_SETTINGS_GUARANTEE_ENCRYPTION = @as(u32, 1);
pub const SOCKET_SETTINGS_ALLOW_INSECURE = @as(u32, 2);
pub const SOCKET_SETTINGS_IPSEC_SKIP_FILTER_INSTANTIATION = @as(u32, 1);
pub const SOCKET_SETTINGS_IPSEC_OPTIONAL_PEER_NAME_VERIFICATION = @as(u32, 2);
pub const SOCKET_SETTINGS_IPSEC_ALLOW_FIRST_INBOUND_PKT_UNENCRYPTED = @as(u32, 4);
pub const SOCKET_SETTINGS_IPSEC_PEER_NAME_IS_RAW_FORMAT = @as(u32, 8);
pub const SOCKET_QUERY_IPSEC2_ABORT_CONNECTION_ON_FIELD_CHANGE = @as(u32, 1);
pub const SOCKET_QUERY_IPSEC2_FIELD_MASK_MM_SA_ID = @as(u32, 1);
pub const SOCKET_QUERY_IPSEC2_FIELD_MASK_QM_SA_ID = @as(u32, 2);
pub const SOCKET_INFO_CONNECTION_SECURED = @as(u32, 1);
pub const SOCKET_INFO_CONNECTION_ENCRYPTED = @as(u32, 2);
pub const SOCKET_INFO_CONNECTION_IMPERSONATED = @as(u32, 4);
pub const IN4ADDR_LOOPBACK = @as(u32, 16777343);
pub const IN4ADDR_LOOPBACKPREFIX_LENGTH = @as(u32, 8);
pub const IN4ADDR_LINKLOCALPREFIX_LENGTH = @as(u32, 16);
pub const IN4ADDR_MULTICASTPREFIX_LENGTH = @as(u32, 4);
pub const RIO_MSG_DONT_NOTIFY = @as(u32, 1);
pub const RIO_MSG_DEFER = @as(u32, 2);
pub const RIO_MSG_WAITALL = @as(u32, 4);
pub const RIO_MSG_COMMIT_ONLY = @as(u32, 8);
pub const RIO_MAX_CQ_SIZE = @as(u32, 134217728);
pub const RIO_CORRUPT_CQ = @as(u32, 4294967295);
pub const AF_UNIX = @as(u16, 1);
pub const AF_IMPLINK = @as(u16, 3);
pub const AF_PUP = @as(u16, 4);
pub const AF_CHAOS = @as(u16, 5);
pub const AF_NS = @as(u16, 6);
pub const AF_IPX = @as(u16, 6);
pub const AF_ISO = @as(u16, 7);
pub const AF_OSI = @as(u16, 7);
pub const AF_ECMA = @as(u16, 8);
pub const AF_DATAKIT = @as(u16, 9);
pub const AF_CCITT = @as(u16, 10);
pub const AF_SNA = @as(u16, 11);
pub const AF_DECnet = @as(u16, 12);
pub const AF_DLI = @as(u16, 13);
pub const AF_LAT = @as(u16, 14);
pub const AF_HYLINK = @as(u16, 15);
pub const AF_APPLETALK = @as(u16, 16);
pub const AF_NETBIOS = @as(u16, 17);
pub const AF_VOICEVIEW = @as(u16, 18);
pub const AF_FIREFOX = @as(u16, 19);
pub const AF_UNKNOWN1 = @as(u16, 20);
pub const AF_BAN = @as(u16, 21);
pub const AF_ATM = @as(u16, 22);
pub const AF_CLUSTER = @as(u16, 24);
pub const AF_12844 = @as(u16, 25);
pub const AF_IRDA = @as(u16, 26);
pub const AF_NETDES = @as(u16, 28);
pub const AF_MAX = @as(u16, 29);
pub const AF_TCNPROCESS = @as(u16, 29);
pub const AF_TCNMESSAGE = @as(u16, 30);
pub const AF_ICLFXBM = @as(u16, 31);
pub const AF_LINK = @as(u16, 33);
pub const AF_HYPERV = @as(u16, 34);
pub const SOCK_STREAM = @as(u16, 1);
pub const SOCK_DGRAM = @as(u16, 2);
pub const SOCK_RAW = @as(u16, 3);
pub const SOCK_RDM = @as(u16, 4);
pub const SOCK_SEQPACKET = @as(u16, 5);
pub const SOL_SOCKET = @as(u32, 65535);
pub const SO_DEBUG = @as(u32, 1);
pub const SO_ACCEPTCONN = @as(u32, 2);
pub const SO_REUSEADDR = @as(u32, 4);
pub const SO_KEEPALIVE = @as(u32, 8);
pub const SO_DONTROUTE = @as(u32, 16);
pub const SO_BROADCAST = @as(u32, 32);
pub const SO_USELOOPBACK = @as(u32, 64);
pub const SO_LINGER = @as(u32, 128);
pub const SO_OOBINLINE = @as(u32, 256);
pub const SO_SNDBUF = @as(u32, 4097);
pub const SO_RCVBUF = @as(u32, 4098);
pub const SO_SNDLOWAT = @as(u32, 4099);
pub const SO_RCVLOWAT = @as(u32, 4100);
pub const SO_SNDTIMEO = @as(u32, 4101);
pub const SO_RCVTIMEO = @as(u32, 4102);
pub const SO_ERROR = @as(u32, 4103);
pub const SO_TYPE = @as(u32, 4104);
pub const SO_BSP_STATE = @as(u32, 4105);
pub const SO_GROUP_ID = @as(u32, 8193);
pub const SO_GROUP_PRIORITY = @as(u32, 8194);
pub const SO_MAX_MSG_SIZE = @as(u32, 8195);
pub const SO_CONDITIONAL_ACCEPT = @as(u32, 12290);
pub const SO_PAUSE_ACCEPT = @as(u32, 12291);
pub const SO_COMPARTMENT_ID = @as(u32, 12292);
pub const SO_RANDOMIZE_PORT = @as(u32, 12293);
pub const SO_PORT_SCALABILITY = @as(u32, 12294);
pub const SO_REUSE_UNICASTPORT = @as(u32, 12295);
pub const SO_REUSE_MULTICASTPORT = @as(u32, 12296);
pub const SO_ORIGINAL_DST = @as(u32, 12303);
pub const IP6T_SO_ORIGINAL_DST = @as(u32, 12303);
pub const WSK_SO_BASE = @as(u32, 16384);
pub const TCP_NODELAY = @as(u32, 1);
pub const _SS_MAXSIZE = @as(u32, 128);
pub const IOC_UNIX = @as(u32, 0);
pub const IOC_WS2 = @as(u32, 134217728);
pub const IOC_PROTOCOL = @as(u32, 268435456);
pub const IOC_VENDOR = @as(u32, 402653184);
pub const IPPROTO_IP = @as(u32, 0);
pub const IPPORT_TCPMUX = @as(u32, 1);
pub const IPPORT_ECHO = @as(u32, 7);
pub const IPPORT_DISCARD = @as(u32, 9);
pub const IPPORT_SYSTAT = @as(u32, 11);
pub const IPPORT_DAYTIME = @as(u32, 13);
pub const IPPORT_NETSTAT = @as(u32, 15);
pub const IPPORT_QOTD = @as(u32, 17);
pub const IPPORT_MSP = @as(u32, 18);
pub const IPPORT_CHARGEN = @as(u32, 19);
pub const IPPORT_FTP_DATA = @as(u32, 20);
pub const IPPORT_FTP = @as(u32, 21);
pub const IPPORT_TELNET = @as(u32, 23);
pub const IPPORT_SMTP = @as(u32, 25);
pub const IPPORT_TIMESERVER = @as(u32, 37);
pub const IPPORT_NAMESERVER = @as(u32, 42);
pub const IPPORT_WHOIS = @as(u32, 43);
pub const IPPORT_MTP = @as(u32, 57);
pub const IPPORT_TFTP = @as(u32, 69);
pub const IPPORT_RJE = @as(u32, 77);
pub const IPPORT_FINGER = @as(u32, 79);
pub const IPPORT_TTYLINK = @as(u32, 87);
pub const IPPORT_SUPDUP = @as(u32, 95);
pub const IPPORT_POP3 = @as(u32, 110);
pub const IPPORT_NTP = @as(u32, 123);
pub const IPPORT_EPMAP = @as(u32, 135);
pub const IPPORT_NETBIOS_NS = @as(u32, 137);
pub const IPPORT_NETBIOS_DGM = @as(u32, 138);
pub const IPPORT_NETBIOS_SSN = @as(u32, 139);
pub const IPPORT_IMAP = @as(u32, 143);
pub const IPPORT_SNMP = @as(u32, 161);
pub const IPPORT_SNMP_TRAP = @as(u32, 162);
pub const IPPORT_IMAP3 = @as(u32, 220);
pub const IPPORT_LDAP = @as(u32, 389);
pub const IPPORT_HTTPS = @as(u32, 443);
pub const IPPORT_MICROSOFT_DS = @as(u32, 445);
pub const IPPORT_EXECSERVER = @as(u32, 512);
pub const IPPORT_LOGINSERVER = @as(u32, 513);
pub const IPPORT_CMDSERVER = @as(u32, 514);
pub const IPPORT_EFSSERVER = @as(u32, 520);
pub const IPPORT_BIFFUDP = @as(u32, 512);
pub const IPPORT_WHOSERVER = @as(u32, 513);
pub const IPPORT_ROUTESERVER = @as(u32, 520);
pub const IPPORT_RESERVED = @as(u32, 1024);
pub const IPPORT_REGISTERED_MIN = @as(u32, 1024);
pub const IPPORT_REGISTERED_MAX = @as(u32, 49151);
pub const IPPORT_DYNAMIC_MIN = @as(u32, 49152);
pub const IPPORT_DYNAMIC_MAX = @as(u32, 65535);
pub const IN_CLASSA_NET = @as(u32, 4278190080);
pub const IN_CLASSA_NSHIFT = @as(u32, 24);
pub const IN_CLASSA_HOST = @as(u32, 16777215);
pub const IN_CLASSA_MAX = @as(u32, 128);
pub const IN_CLASSB_NET = @as(u32, 4294901760);
pub const IN_CLASSB_NSHIFT = @as(u32, 16);
pub const IN_CLASSB_HOST = @as(u32, 65535);
pub const IN_CLASSB_MAX = @as(u32, 65536);
pub const IN_CLASSC_NET = @as(u32, 4294967040);
pub const IN_CLASSC_NSHIFT = @as(u32, 8);
pub const IN_CLASSC_HOST = @as(u32, 255);
pub const IN_CLASSD_NET = @as(u32, 4026531840);
pub const IN_CLASSD_NSHIFT = @as(u32, 28);
pub const IN_CLASSD_HOST = @as(u32, 268435455);
pub const INADDR_LOOPBACK = @as(u32, 2130706433);
pub const INADDR_NONE = @as(u32, 4294967295);
pub const IOCPARM_MASK = @as(u32, 127);
pub const IOC_VOID = @as(u32, 536870912);
pub const IOC_OUT = @as(u32, 1073741824);
pub const IOC_IN = @as(u32, 2147483648);
pub const MSG_TRUNC = @as(u32, 256);
pub const MSG_CTRUNC = @as(u32, 512);
pub const MSG_BCAST = @as(u32, 1024);
pub const MSG_MCAST = @as(u32, 2048);
pub const MSG_ERRQUEUE = @as(u32, 4096);
pub const AI_PASSIVE = @as(u32, 1);
pub const AI_CANONNAME = @as(u32, 2);
pub const AI_NUMERICHOST = @as(u32, 4);
pub const AI_NUMERICSERV = @as(u32, 8);
pub const AI_DNS_ONLY = @as(u32, 16);
pub const AI_FORCE_CLEAR_TEXT = @as(u32, 32);
pub const AI_BYPASS_DNS_CACHE = @as(u32, 64);
pub const AI_RETURN_TTL = @as(u32, 128);
pub const AI_ALL = @as(u32, 256);
pub const AI_ADDRCONFIG = @as(u32, 1024);
pub const AI_V4MAPPED = @as(u32, 2048);
pub const AI_NON_AUTHORITATIVE = @as(u32, 16384);
pub const AI_SECURE = @as(u32, 32768);
pub const AI_RETURN_PREFERRED_NAMES = @as(u32, 65536);
pub const AI_FQDN = @as(u32, 131072);
pub const AI_FILESERVER = @as(u32, 262144);
pub const AI_DISABLE_IDN_ENCODING = @as(u32, 524288);
pub const AI_SECURE_WITH_FALLBACK = @as(u32, 1048576);
pub const AI_EXCLUSIVE_CUSTOM_SERVERS = @as(u32, 2097152);
pub const AI_RETURN_RESPONSE_FLAGS = @as(u32, 268435456);
pub const AI_REQUIRE_SECURE = @as(u32, 536870912);
pub const AI_RESOLUTION_HANDLE = @as(u32, 1073741824);
pub const AI_EXTENDED = @as(u32, 2147483648);
pub const ADDRINFOEX_VERSION_2 = @as(u32, 2);
pub const ADDRINFOEX_VERSION_3 = @as(u32, 3);
pub const ADDRINFOEX_VERSION_4 = @as(u32, 4);
pub const ADDRINFOEX_VERSION_5 = @as(u32, 5);
pub const ADDRINFOEX_VERSION_6 = @as(u32, 6);
pub const AI_DNS_SERVER_TYPE_UDP = @as(u32, 1);
pub const AI_DNS_SERVER_TYPE_DOH = @as(u32, 2);
pub const AI_DNS_SERVER_UDP_FALLBACK = @as(u32, 1);
pub const AI_DNS_RESPONSE_SECURE = @as(u32, 1);
pub const AI_DNS_RESPONSE_HOSTFILE = @as(u32, 2);
pub const NS_ALL = @as(u32, 0);
pub const NS_SAP = @as(u32, 1);
pub const NS_NDS = @as(u32, 2);
pub const NS_PEER_BROWSE = @as(u32, 3);
pub const NS_SLP = @as(u32, 5);
pub const NS_DHCP = @as(u32, 6);
pub const NS_TCPIP_LOCAL = @as(u32, 10);
pub const NS_TCPIP_HOSTS = @as(u32, 11);
pub const NS_DNS = @as(u32, 12);
pub const NS_NETBT = @as(u32, 13);
pub const NS_WINS = @as(u32, 14);
pub const NS_NLA = @as(u32, 15);
pub const NS_NBP = @as(u32, 20);
pub const NS_MS = @as(u32, 30);
pub const NS_STDA = @as(u32, 31);
pub const NS_NTDS = @as(u32, 32);
pub const NS_EMAIL = @as(u32, 37);
pub const NS_X500 = @as(u32, 40);
pub const NS_NIS = @as(u32, 41);
pub const NS_NISPLUS = @as(u32, 42);
pub const NS_WRQ = @as(u32, 50);
pub const NS_NETDES = @as(u32, 60);
pub const NI_NOFQDN = @as(u32, 1);
pub const NI_NUMERICHOST = @as(u32, 2);
pub const NI_NAMEREQD = @as(u32, 4);
pub const NI_NUMERICSERV = @as(u32, 8);
pub const NI_DGRAM = @as(u32, 16);
pub const NI_MAXHOST = @as(u32, 1025);
pub const NI_MAXSERV = @as(u32, 32);
pub const IFF_UP = @as(u32, 1);
pub const IFF_BROADCAST = @as(u32, 2);
pub const IFF_LOOPBACK = @as(u32, 4);
pub const IFF_POINTTOPOINT = @as(u32, 8);
pub const IFF_MULTICAST = @as(u32, 16);
pub const IP_OPTIONS = @as(u32, 1);
pub const IP_HDRINCL = @as(u32, 2);
pub const IP_TOS = @as(u32, 3);
pub const IP_TTL = @as(u32, 4);
pub const IP_MULTICAST_IF = @as(u32, 9);
pub const IP_MULTICAST_TTL = @as(u32, 10);
pub const IP_MULTICAST_LOOP = @as(u32, 11);
pub const IP_ADD_MEMBERSHIP = @as(u32, 12);
pub const IP_DROP_MEMBERSHIP = @as(u32, 13);
pub const IP_DONTFRAGMENT = @as(u32, 14);
pub const IP_ADD_SOURCE_MEMBERSHIP = @as(u32, 15);
pub const IP_DROP_SOURCE_MEMBERSHIP = @as(u32, 16);
pub const IP_BLOCK_SOURCE = @as(u32, 17);
pub const IP_UNBLOCK_SOURCE = @as(u32, 18);
pub const IP_PKTINFO = @as(u32, 19);
pub const IP_HOPLIMIT = @as(u32, 21);
pub const IP_RECVTTL = @as(u32, 21);
pub const IP_RECEIVE_BROADCAST = @as(u32, 22);
pub const IP_RECVIF = @as(u32, 24);
pub const IP_RECVDSTADDR = @as(u32, 25);
pub const IP_IFLIST = @as(u32, 28);
pub const IP_ADD_IFLIST = @as(u32, 29);
pub const IP_DEL_IFLIST = @as(u32, 30);
pub const IP_UNICAST_IF = @as(u32, 31);
pub const IP_RTHDR = @as(u32, 32);
pub const IP_GET_IFLIST = @as(u32, 33);
pub const IP_RECVRTHDR = @as(u32, 38);
pub const IP_TCLASS = @as(u32, 39);
pub const IP_RECVTCLASS = @as(u32, 40);
pub const IP_RECVTOS = @as(u32, 40);
pub const IP_ORIGINAL_ARRIVAL_IF = @as(u32, 47);
pub const IP_ECN = @as(u32, 50);
pub const IP_RECVECN = @as(u32, 50);
pub const IP_PKTINFO_EX = @as(u32, 51);
pub const IP_WFP_REDIRECT_RECORDS = @as(u32, 60);
pub const IP_WFP_REDIRECT_CONTEXT = @as(u32, 70);
pub const IP_MTU_DISCOVER = @as(u32, 71);
pub const IP_MTU = @as(u32, 73);
pub const IP_NRT_INTERFACE = @as(u32, 74);
pub const IP_RECVERR = @as(u32, 75);
pub const IP_USER_MTU = @as(u32, 76);
pub const IP_UNSPECIFIED_TYPE_OF_SERVICE = @as(i32, -1);
pub const IP_UNSPECIFIED_USER_MTU = @as(u32, 4294967295);
pub const IN6ADDR_LINKLOCALPREFIX_LENGTH = @as(u32, 64);
pub const IN6ADDR_MULTICASTPREFIX_LENGTH = @as(u32, 8);
pub const IN6ADDR_SOLICITEDNODEMULTICASTPREFIX_LENGTH = @as(u32, 104);
pub const IN6ADDR_V4MAPPEDPREFIX_LENGTH = @as(u32, 96);
pub const IN6ADDR_6TO4PREFIX_LENGTH = @as(u32, 16);
pub const IN6ADDR_TEREDOPREFIX_LENGTH = @as(u32, 32);
pub const MCAST_JOIN_GROUP = @as(u32, 41);
pub const MCAST_LEAVE_GROUP = @as(u32, 42);
pub const MCAST_BLOCK_SOURCE = @as(u32, 43);
pub const MCAST_UNBLOCK_SOURCE = @as(u32, 44);
pub const MCAST_JOIN_SOURCE_GROUP = @as(u32, 45);
pub const MCAST_LEAVE_SOURCE_GROUP = @as(u32, 46);
pub const IPV6_HOPOPTS = @as(u32, 1);
pub const IPV6_HDRINCL = @as(u32, 2);
pub const IPV6_UNICAST_HOPS = @as(u32, 4);
pub const IPV6_MULTICAST_IF = @as(u32, 9);
pub const IPV6_MULTICAST_HOPS = @as(u32, 10);
pub const IPV6_MULTICAST_LOOP = @as(u32, 11);
pub const IPV6_ADD_MEMBERSHIP = @as(u32, 12);
pub const IPV6_JOIN_GROUP = @as(u32, 12);
pub const IPV6_DROP_MEMBERSHIP = @as(u32, 13);
pub const IPV6_LEAVE_GROUP = @as(u32, 13);
pub const IPV6_DONTFRAG = @as(u32, 14);
pub const IPV6_PKTINFO = @as(u32, 19);
pub const IPV6_HOPLIMIT = @as(u32, 21);
pub const IPV6_PROTECTION_LEVEL = @as(u32, 23);
pub const IPV6_RECVIF = @as(u32, 24);
pub const IPV6_RECVDSTADDR = @as(u32, 25);
pub const IPV6_CHECKSUM = @as(u32, 26);
pub const IPV6_V6ONLY = @as(u32, 27);
pub const IPV6_IFLIST = @as(u32, 28);
pub const IPV6_ADD_IFLIST = @as(u32, 29);
pub const IPV6_DEL_IFLIST = @as(u32, 30);
pub const IPV6_UNICAST_IF = @as(u32, 31);
pub const IPV6_RTHDR = @as(u32, 32);
pub const IPV6_GET_IFLIST = @as(u32, 33);
pub const IPV6_RECVRTHDR = @as(u32, 38);
pub const IPV6_TCLASS = @as(u32, 39);
pub const IPV6_RECVTCLASS = @as(u32, 40);
pub const IPV6_ECN = @as(u32, 50);
pub const IPV6_RECVECN = @as(u32, 50);
pub const IPV6_PKTINFO_EX = @as(u32, 51);
pub const IPV6_WFP_REDIRECT_RECORDS = @as(u32, 60);
pub const IPV6_WFP_REDIRECT_CONTEXT = @as(u32, 70);
pub const IPV6_MTU_DISCOVER = @as(u32, 71);
pub const IPV6_MTU = @as(u32, 72);
pub const IPV6_NRT_INTERFACE = @as(u32, 74);
pub const IPV6_RECVERR = @as(u32, 75);
pub const IPV6_USER_MTU = @as(u32, 76);
pub const IP_UNSPECIFIED_HOP_LIMIT = @as(i32, -1);
pub const IP_PROTECTION_LEVEL = @as(u32, 23);
pub const PROTECTION_LEVEL_UNRESTRICTED = @as(u32, 10);
pub const PROTECTION_LEVEL_EDGERESTRICTED = @as(u32, 20);
pub const PROTECTION_LEVEL_RESTRICTED = @as(u32, 30);
pub const PROTECTION_LEVEL_DEFAULT = @as(u32, 20);
pub const INET_ADDRSTRLEN = @as(u32, 22);
pub const INET6_ADDRSTRLEN = @as(u32, 65);
pub const TCP_OFFLOAD_NO_PREFERENCE = @as(u32, 0);
pub const TCP_OFFLOAD_NOT_PREFERRED = @as(u32, 1);
pub const TCP_OFFLOAD_PREFERRED = @as(u32, 2);
pub const TCP_EXPEDITED_1122 = @as(u32, 2);
pub const TCP_KEEPALIVE = @as(u32, 3);
pub const TCP_MAXSEG = @as(u32, 4);
pub const TCP_MAXRT = @as(u32, 5);
pub const TCP_STDURG = @as(u32, 6);
pub const TCP_NOURG = @as(u32, 7);
pub const TCP_ATMARK = @as(u32, 8);
pub const TCP_NOSYNRETRIES = @as(u32, 9);
pub const TCP_TIMESTAMPS = @as(u32, 10);
pub const TCP_OFFLOAD_PREFERENCE = @as(u32, 11);
pub const TCP_CONGESTION_ALGORITHM = @as(u32, 12);
pub const TCP_DELAY_FIN_ACK = @as(u32, 13);
pub const TCP_MAXRTMS = @as(u32, 14);
pub const TCP_FASTOPEN = @as(u32, 15);
pub const TCP_KEEPCNT = @as(u32, 16);
pub const TCP_KEEPIDLE = @as(u32, 3);
pub const TCP_KEEPINTVL = @as(u32, 17);
pub const TCP_FAIL_CONNECT_ON_ICMP_ERROR = @as(u32, 18);
pub const TCP_ICMP_ERROR_INFO = @as(u32, 19);
pub const UDP_SEND_MSG_SIZE = @as(u32, 2);
pub const UDP_RECV_MAX_COALESCED_SIZE = @as(u32, 3);
pub const UDP_COALESCED_INFO = @as(u32, 3);
pub const WINDOWS_AF_IRDA = @as(u32, 26);
pub const WINDOWS_PF_IRDA = @as(u32, 26);
pub const WCE_AF_IRDA = @as(u32, 22);
pub const WCE_PF_IRDA = @as(u32, 22);
pub const IRDA_PROTO_SOCK_STREAM = @as(u32, 1);
pub const PF_IRDA = @as(u16, 26);
pub const SOL_IRLMP = @as(u32, 255);
pub const IRLMP_ENUMDEVICES = @as(u32, 16);
pub const IRLMP_IAS_SET = @as(u32, 17);
pub const IRLMP_IAS_QUERY = @as(u32, 18);
pub const IRLMP_SEND_PDU_LEN = @as(u32, 19);
pub const IRLMP_EXCLUSIVE_MODE = @as(u32, 20);
pub const IRLMP_IRLPT_MODE = @as(u32, 21);
pub const IRLMP_9WIRE_MODE = @as(u32, 22);
pub const IRLMP_TINYTP_MODE = @as(u32, 23);
pub const IRLMP_PARAMETERS = @as(u32, 24);
pub const IRLMP_DISCOVERY_MODE = @as(u32, 25);
pub const IRLMP_SHARP_MODE = @as(u32, 32);
pub const IAS_ATTRIB_NO_CLASS = @as(u32, 16);
pub const IAS_ATTRIB_NO_ATTRIB = @as(u32, 0);
pub const IAS_ATTRIB_INT = @as(u32, 1);
pub const IAS_ATTRIB_OCTETSEQ = @as(u32, 2);
pub const IAS_ATTRIB_STR = @as(u32, 3);
pub const IAS_MAX_USER_STRING = @as(u32, 256);
pub const IAS_MAX_OCTET_STRING = @as(u32, 1024);
pub const IAS_MAX_CLASSNAME = @as(u32, 64);
pub const IAS_MAX_ATTRIBNAME = @as(u32, 256);
pub const LmCharSetASCII = @as(u32, 0);
pub const LmCharSetISO_8859_1 = @as(u32, 1);
pub const LmCharSetISO_8859_2 = @as(u32, 2);
pub const LmCharSetISO_8859_3 = @as(u32, 3);
pub const LmCharSetISO_8859_4 = @as(u32, 4);
pub const LmCharSetISO_8859_5 = @as(u32, 5);
pub const LmCharSetISO_8859_6 = @as(u32, 6);
pub const LmCharSetISO_8859_7 = @as(u32, 7);
pub const LmCharSetISO_8859_8 = @as(u32, 8);
pub const LmCharSetISO_8859_9 = @as(u32, 9);
pub const LmCharSetUNICODE = @as(u32, 255);
pub const LM_BAUD_1200 = @as(u32, 1200);
pub const LM_BAUD_2400 = @as(u32, 2400);
pub const LM_BAUD_9600 = @as(u32, 9600);
pub const LM_BAUD_19200 = @as(u32, 19200);
pub const LM_BAUD_38400 = @as(u32, 38400);
pub const LM_BAUD_57600 = @as(u32, 57600);
pub const LM_BAUD_115200 = @as(u32, 115200);
pub const LM_BAUD_576K = @as(u32, 576000);
pub const LM_BAUD_1152K = @as(u32, 1152000);
pub const LM_BAUD_4M = @as(u32, 4000000);
pub const LM_BAUD_16M = @as(u32, 16000000);
pub const SO_CONNDATA = @as(u32, 28672);
pub const SO_CONNOPT = @as(u32, 28673);
pub const SO_DISCDATA = @as(u32, 28674);
pub const SO_DISCOPT = @as(u32, 28675);
pub const SO_CONNDATALEN = @as(u32, 28676);
pub const SO_CONNOPTLEN = @as(u32, 28677);
pub const SO_DISCDATALEN = @as(u32, 28678);
pub const SO_DISCOPTLEN = @as(u32, 28679);
pub const SO_OPENTYPE = @as(u32, 28680);
pub const SO_SYNCHRONOUS_ALERT = @as(u32, 16);
pub const SO_SYNCHRONOUS_NONALERT = @as(u32, 32);
pub const SO_MAXDG = @as(u32, 28681);
pub const SO_MAXPATHDG = @as(u32, 28682);
pub const SO_UPDATE_ACCEPT_CONTEXT = @as(u32, 28683);
pub const SO_CONNECT_TIME = @as(u32, 28684);
pub const SO_UPDATE_CONNECT_CONTEXT = @as(u32, 28688);
pub const TCP_BSDURGENT = @as(u32, 28672);
pub const TF_DISCONNECT = @as(u32, 1);
pub const TF_REUSE_SOCKET = @as(u32, 2);
pub const TF_WRITE_BEHIND = @as(u32, 4);
pub const TF_USE_DEFAULT_WORKER = @as(u32, 0);
pub const TF_USE_SYSTEM_THREAD = @as(u32, 16);
pub const TF_USE_KERNEL_APC = @as(u32, 32);
pub const TP_ELEMENT_MEMORY = @as(u32, 1);
pub const TP_ELEMENT_FILE = @as(u32, 2);
pub const TP_ELEMENT_EOP = @as(u32, 4);
pub const TP_DISCONNECT = @as(u32, 1);
pub const TP_REUSE_SOCKET = @as(u32, 2);
pub const TP_USE_DEFAULT_WORKER = @as(u32, 0);
pub const TP_USE_SYSTEM_THREAD = @as(u32, 16);
pub const TP_USE_KERNEL_APC = @as(u32, 32);
pub const DE_REUSE_SOCKET = @as(u32, 2);
pub const NLA_ALLUSERS_NETWORK = @as(u32, 1);
pub const NLA_FRIENDLY_NAME = @as(u32, 2);
pub const SERVICE_RESOURCE = @as(u32, 1);
pub const SERVICE_SERVICE = @as(u32, 2);
pub const SERVICE_LOCAL = @as(u32, 4);
pub const SERVICE_FLAG_DEFER = @as(u32, 1);
pub const SERVICE_FLAG_HARD = @as(u32, 2);
pub const PROP_COMMENT = @as(u32, 1);
pub const PROP_LOCALE = @as(u32, 2);
pub const PROP_DISPLAY_HINT = @as(u32, 4);
pub const PROP_VERSION = @as(u32, 8);
pub const PROP_START_TIME = @as(u32, 16);
pub const PROP_MACHINE = @as(u32, 32);
pub const PROP_ADDRESSES = @as(u32, 256);
pub const PROP_SD = @as(u32, 512);
pub const PROP_ALL = @as(u32, 2147483648);
pub const SERVICE_ADDRESS_FLAG_RPC_CN = @as(u32, 1);
pub const SERVICE_ADDRESS_FLAG_RPC_DG = @as(u32, 2);
pub const SERVICE_ADDRESS_FLAG_RPC_NB = @as(u32, 4);
pub const NS_DEFAULT = @as(u32, 0);
pub const NS_VNS = @as(u32, 50);
pub const NSTYPE_HIERARCHICAL = @as(u32, 1);
pub const NSTYPE_DYNAMIC = @as(u32, 2);
pub const NSTYPE_ENUMERABLE = @as(u32, 4);
pub const NSTYPE_WORKGROUP = @as(u32, 8);
pub const XP_CONNECTIONLESS = @as(u32, 1);
pub const XP_GUARANTEED_DELIVERY = @as(u32, 2);
pub const XP_GUARANTEED_ORDER = @as(u32, 4);
pub const XP_MESSAGE_ORIENTED = @as(u32, 8);
pub const XP_PSEUDO_STREAM = @as(u32, 16);
pub const XP_GRACEFUL_CLOSE = @as(u32, 32);
pub const XP_EXPEDITED_DATA = @as(u32, 64);
pub const XP_CONNECT_DATA = @as(u32, 128);
pub const XP_DISCONNECT_DATA = @as(u32, 256);
pub const XP_SUPPORTS_BROADCAST = @as(u32, 512);
pub const XP_SUPPORTS_MULTICAST = @as(u32, 1024);
pub const XP_BANDWIDTH_ALLOCATION = @as(u32, 2048);
pub const XP_FRAGMENTATION = @as(u32, 4096);
pub const XP_ENCRYPTS = @as(u32, 8192);
pub const RES_SOFT_SEARCH = @as(u32, 1);
pub const RES_FIND_MULTIPLE = @as(u32, 2);
pub const RES_SERVICE = @as(u32, 4);
pub const SET_SERVICE_PARTIAL_SUCCESS = @as(u32, 1);
pub const FD_SETSIZE = @as(u32, 64);
pub const IMPLINK_IP = @as(u32, 155);
pub const IMPLINK_LOWEXPER = @as(u32, 156);
pub const IMPLINK_HIGHEXPER = @as(u32, 158);
pub const WSADESCRIPTION_LEN = @as(u32, 256);
pub const WSASYS_STATUS_LEN = @as(u32, 128);
pub const IP_DEFAULT_MULTICAST_TTL = @as(u32, 1);
pub const IP_DEFAULT_MULTICAST_LOOP = @as(u32, 1);
pub const IP_MAX_MEMBERSHIPS = @as(u32, 20);
pub const SOCKET_ERROR = @as(i32, -1);
pub const PF_UNIX = @as(u16, 1);
pub const PF_IMPLINK = @as(u16, 3);
pub const PF_PUP = @as(u16, 4);
pub const PF_CHAOS = @as(u16, 5);
pub const PF_NS = @as(u16, 6);
pub const PF_IPX = @as(u16, 6);
pub const PF_ISO = @as(u16, 7);
pub const PF_OSI = @as(u16, 7);
pub const PF_ECMA = @as(u16, 8);
pub const PF_DATAKIT = @as(u16, 9);
pub const PF_CCITT = @as(u16, 10);
pub const PF_SNA = @as(u16, 11);
pub const PF_DECnet = @as(u16, 12);
pub const PF_DLI = @as(u16, 13);
pub const PF_LAT = @as(u16, 14);
pub const PF_HYLINK = @as(u16, 15);
pub const PF_APPLETALK = @as(u16, 16);
pub const PF_VOICEVIEW = @as(u16, 18);
pub const PF_FIREFOX = @as(u16, 19);
pub const PF_UNKNOWN1 = @as(u16, 20);
pub const PF_BAN = @as(u16, 21);
pub const PF_MAX = @as(u16, 29);
pub const SOMAXCONN = @as(u32, 5);
pub const MSG_PEEK = @as(u32, 2);
pub const MSG_MAXIOVLEN = @as(u32, 16);
pub const MSG_PARTIAL = @as(u32, 32768);
pub const MAXGETHOSTSTRUCT = @as(u32, 1024);
pub const FD_READ = @as(u32, 1);
pub const FD_WRITE = @as(u32, 2);
pub const FD_OOB = @as(u32, 4);
pub const FD_ACCEPT = @as(u32, 8);
pub const FD_CONNECT = @as(u32, 16);
pub const FD_CLOSE = @as(u32, 32);
pub const INCL_WINSOCK_API_PROTOTYPES = @as(u32, 1);
pub const INCL_WINSOCK_API_TYPEDEFS = @as(u32, 0);
pub const FROM_PROTOCOL_INFO = @as(i32, -1);
pub const SO_PROTOCOL_INFOA = @as(u32, 8196);
pub const SO_PROTOCOL_INFOW = @as(u32, 8197);
pub const SO_PROTOCOL_INFO = @as(u32, 8197);
pub const PVD_CONFIG = @as(u32, 12289);
pub const PF_ATM = @as(u16, 22);
pub const MSG_WAITALL = @as(u32, 8);
pub const MSG_PUSH_IMMEDIATE = @as(u32, 32);
pub const MSG_INTERRUPT = @as(u32, 16);
pub const FD_READ_BIT = @as(u32, 0);
pub const FD_WRITE_BIT = @as(u32, 1);
pub const FD_OOB_BIT = @as(u32, 2);
pub const FD_ACCEPT_BIT = @as(u32, 3);
pub const FD_CONNECT_BIT = @as(u32, 4);
pub const FD_CLOSE_BIT = @as(u32, 5);
pub const FD_QOS_BIT = @as(u32, 6);
pub const FD_GROUP_QOS_BIT = @as(u32, 7);
pub const FD_ROUTING_INTERFACE_CHANGE_BIT = @as(u32, 8);
pub const FD_ADDRESS_LIST_CHANGE_BIT = @as(u32, 9);
pub const FD_MAX_EVENTS = @as(u32, 10);
pub const WSA_MAXIMUM_WAIT_EVENTS = @as(u32, 64);
pub const WSA_WAIT_EVENT_0 = @as(u32, 0);
pub const WSA_WAIT_IO_COMPLETION = @as(u32, 192);
pub const WSA_WAIT_FAILED = @as(u32, 4294967295);
pub const CF_ACCEPT = @as(u32, 0);
pub const CF_REJECT = @as(u32, 1);
pub const CF_DEFER = @as(u32, 2);
pub const SD_RECEIVE = @as(u32, 0);
pub const SD_SEND = @as(u32, 1);
pub const SD_BOTH = @as(u32, 2);
pub const SG_UNCONSTRAINED_GROUP = @as(u32, 1);
pub const SG_CONSTRAINED_GROUP = @as(u32, 2);
pub const MAX_PROTOCOL_CHAIN = @as(u32, 7);
pub const BASE_PROTOCOL = @as(u32, 1);
pub const LAYERED_PROTOCOL = @as(u32, 0);
pub const WSAPROTOCOL_LEN = @as(u32, 255);
pub const PFL_MULTIPLE_PROTO_ENTRIES = @as(u32, 1);
pub const PFL_RECOMMENDED_PROTO_ENTRY = @as(u32, 2);
pub const PFL_HIDDEN = @as(u32, 4);
pub const PFL_MATCHES_PROTOCOL_ZERO = @as(u32, 8);
pub const PFL_NETWORKDIRECT_PROVIDER = @as(u32, 16);
pub const XP1_CONNECTIONLESS = @as(u32, 1);
pub const XP1_GUARANTEED_DELIVERY = @as(u32, 2);
pub const XP1_GUARANTEED_ORDER = @as(u32, 4);
pub const XP1_MESSAGE_ORIENTED = @as(u32, 8);
pub const XP1_PSEUDO_STREAM = @as(u32, 16);
pub const XP1_GRACEFUL_CLOSE = @as(u32, 32);
pub const XP1_EXPEDITED_DATA = @as(u32, 64);
pub const XP1_CONNECT_DATA = @as(u32, 128);
pub const XP1_DISCONNECT_DATA = @as(u32, 256);
pub const XP1_SUPPORT_BROADCAST = @as(u32, 512);
pub const XP1_SUPPORT_MULTIPOINT = @as(u32, 1024);
pub const XP1_MULTIPOINT_CONTROL_PLANE = @as(u32, 2048);
pub const XP1_MULTIPOINT_DATA_PLANE = @as(u32, 4096);
pub const XP1_QOS_SUPPORTED = @as(u32, 8192);
pub const XP1_INTERRUPT = @as(u32, 16384);
pub const XP1_UNI_SEND = @as(u32, 32768);
pub const XP1_UNI_RECV = @as(u32, 65536);
pub const XP1_IFS_HANDLES = @as(u32, 131072);
pub const XP1_PARTIAL_MESSAGE = @as(u32, 262144);
pub const XP1_SAN_SUPPORT_SDP = @as(u32, 524288);
pub const BIGENDIAN = @as(u32, 0);
pub const LITTLEENDIAN = @as(u32, 1);
pub const SECURITY_PROTOCOL_NONE = @as(u32, 0);
pub const JL_SENDER_ONLY = @as(u32, 1);
pub const JL_RECEIVER_ONLY = @as(u32, 2);
pub const JL_BOTH = @as(u32, 4);
pub const WSA_FLAG_OVERLAPPED = @as(u32, 1);
pub const WSA_FLAG_MULTIPOINT_C_ROOT = @as(u32, 2);
pub const WSA_FLAG_MULTIPOINT_C_LEAF = @as(u32, 4);
pub const WSA_FLAG_MULTIPOINT_D_ROOT = @as(u32, 8);
pub const WSA_FLAG_MULTIPOINT_D_LEAF = @as(u32, 16);
pub const WSA_FLAG_ACCESS_SYSTEM_SECURITY = @as(u32, 64);
pub const WSA_FLAG_NO_HANDLE_INHERIT = @as(u32, 128);
pub const WSA_FLAG_REGISTERED_IO = @as(u32, 256);
pub const TH_NETDEV = @as(u32, 1);
pub const TH_TAPI = @as(u32, 2);
pub const SERVICE_MULTIPLE = @as(u32, 1);
pub const NS_LOCALNAME = @as(u32, 19);
pub const RES_UNUSED_1 = @as(u32, 1);
pub const RES_FLUSH_CACHE = @as(u32, 2);
pub const LUP_DEEP = @as(u32, 1);
pub const LUP_CONTAINERS = @as(u32, 2);
pub const LUP_NOCONTAINERS = @as(u32, 4);
pub const LUP_NEAREST = @as(u32, 8);
pub const LUP_RETURN_NAME = @as(u32, 16);
pub const LUP_RETURN_TYPE = @as(u32, 32);
pub const LUP_RETURN_VERSION = @as(u32, 64);
pub const LUP_RETURN_COMMENT = @as(u32, 128);
pub const LUP_RETURN_ADDR = @as(u32, 256);
pub const LUP_RETURN_BLOB = @as(u32, 512);
pub const LUP_RETURN_ALIASES = @as(u32, 1024);
pub const LUP_RETURN_QUERY_STRING = @as(u32, 2048);
pub const LUP_RETURN_ALL = @as(u32, 4080);
pub const LUP_RES_SERVICE = @as(u32, 32768);
pub const LUP_FLUSHCACHE = @as(u32, 4096);
pub const LUP_FLUSHPREVIOUS = @as(u32, 8192);
pub const LUP_NON_AUTHORITATIVE = @as(u32, 16384);
pub const LUP_SECURE = @as(u32, 32768);
pub const LUP_RETURN_PREFERRED_NAMES = @as(u32, 65536);
pub const LUP_DNS_ONLY = @as(u32, 131072);
pub const LUP_RETURN_RESPONSE_FLAGS = @as(u32, 262144);
pub const LUP_ADDRCONFIG = @as(u32, 1048576);
pub const LUP_DUAL_ADDR = @as(u32, 2097152);
pub const LUP_FILESERVER = @as(u32, 4194304);
pub const LUP_DISABLE_IDN_ENCODING = @as(u32, 8388608);
pub const LUP_API_ANSI = @as(u32, 16777216);
pub const LUP_EXTENDED_QUERYSET = @as(u32, 33554432);
pub const LUP_SECURE_WITH_FALLBACK = @as(u32, 67108864);
pub const LUP_EXCLUSIVE_CUSTOM_SERVERS = @as(u32, 134217728);
pub const LUP_REQUIRE_SECURE = @as(u32, 268435456);
pub const LUP_RETURN_TTL = @as(u32, 536870912);
pub const LUP_FORCE_CLEAR_TEXT = @as(u32, 1073741824);
pub const LUP_RESOLUTION_HANDLE = @as(u32, 2147483648);
pub const RESULT_IS_ALIAS = @as(u32, 1);
pub const RESULT_IS_ADDED = @as(u32, 16);
pub const RESULT_IS_CHANGED = @as(u32, 32);
pub const RESULT_IS_DELETED = @as(u32, 64);
pub const POLLRDNORM = @as(u32, 256);
pub const POLLRDBAND = @as(u32, 512);
pub const POLLPRI = @as(u32, 1024);
pub const POLLWRNORM = @as(u32, 16);
pub const POLLOUT = @as(u32, 16);
pub const POLLWRBAND = @as(u32, 32);
pub const POLLERR = @as(u32, 1);
pub const POLLHUP = @as(u32, 2);
pub const POLLNVAL = @as(u32, 4);
pub const SOCK_NOTIFY_REGISTER_EVENT_NONE = @as(u32, 0);
pub const SOCK_NOTIFY_REGISTER_EVENT_IN = @as(u32, 1);
pub const SOCK_NOTIFY_REGISTER_EVENT_OUT = @as(u32, 2);
pub const SOCK_NOTIFY_REGISTER_EVENT_HANGUP = @as(u32, 4);
pub const SOCK_NOTIFY_EVENT_IN = @as(u32, 1);
pub const SOCK_NOTIFY_EVENT_OUT = @as(u32, 2);
pub const SOCK_NOTIFY_EVENT_HANGUP = @as(u32, 4);
pub const SOCK_NOTIFY_EVENT_ERR = @as(u32, 64);
pub const SOCK_NOTIFY_EVENT_REMOVE = @as(u32, 128);
pub const SOCK_NOTIFY_OP_NONE = @as(u32, 0);
pub const SOCK_NOTIFY_OP_ENABLE = @as(u32, 1);
pub const SOCK_NOTIFY_OP_DISABLE = @as(u32, 2);
pub const SOCK_NOTIFY_OP_REMOVE = @as(u32, 4);
pub const SOCK_NOTIFY_TRIGGER_ONESHOT = @as(u32, 1);
pub const SOCK_NOTIFY_TRIGGER_PERSISTENT = @as(u32, 2);
pub const SOCK_NOTIFY_TRIGGER_LEVEL = @as(u32, 4);
pub const SOCK_NOTIFY_TRIGGER_EDGE = @as(u32, 8);
pub const ATMPROTO_AALUSER = @as(u32, 0);
pub const ATMPROTO_AAL1 = @as(u32, 1);
pub const ATMPROTO_AAL2 = @as(u32, 2);
pub const ATMPROTO_AAL34 = @as(u32, 3);
pub const ATMPROTO_AAL5 = @as(u32, 5);
pub const SAP_FIELD_ABSENT = @as(u32, 4294967294);
pub const SAP_FIELD_ANY = @as(u32, 4294967295);
pub const SAP_FIELD_ANY_AESA_SEL = @as(u32, 4294967290);
pub const SAP_FIELD_ANY_AESA_REST = @as(u32, 4294967291);
pub const ATM_E164 = @as(u32, 1);
pub const ATM_NSAP = @as(u32, 2);
pub const ATM_AESA = @as(u32, 2);
pub const ATM_ADDR_SIZE = @as(u32, 20);
pub const BLLI_L2_ISO_1745 = @as(u32, 1);
pub const BLLI_L2_Q921 = @as(u32, 2);
pub const BLLI_L2_X25L = @as(u32, 6);
pub const BLLI_L2_X25M = @as(u32, 7);
pub const BLLI_L2_ELAPB = @as(u32, 8);
pub const BLLI_L2_HDLC_ARM = @as(u32, 9);
pub const BLLI_L2_HDLC_NRM = @as(u32, 10);
pub const BLLI_L2_HDLC_ABM = @as(u32, 11);
pub const BLLI_L2_LLC = @as(u32, 12);
pub const BLLI_L2_X75 = @as(u32, 13);
pub const BLLI_L2_Q922 = @as(u32, 14);
pub const BLLI_L2_USER_SPECIFIED = @as(u32, 16);
pub const BLLI_L2_ISO_7776 = @as(u32, 17);
pub const BLLI_L3_X25 = @as(u32, 6);
pub const BLLI_L3_ISO_8208 = @as(u32, 7);
pub const BLLI_L3_X223 = @as(u32, 8);
pub const BLLI_L3_SIO_8473 = @as(u32, 9);
pub const BLLI_L3_T70 = @as(u32, 10);
pub const BLLI_L3_ISO_TR9577 = @as(u32, 11);
pub const BLLI_L3_USER_SPECIFIED = @as(u32, 16);
pub const BLLI_L3_IPI_SNAP = @as(u32, 128);
pub const BLLI_L3_IPI_IP = @as(u32, 204);
pub const BHLI_ISO = @as(u32, 0);
pub const BHLI_UserSpecific = @as(u32, 1);
pub const BHLI_HighLayerProfile = @as(u32, 2);
pub const BHLI_VendorSpecificAppId = @as(u32, 3);
pub const AAL5_MODE_MESSAGE = @as(u32, 1);
pub const AAL5_MODE_STREAMING = @as(u32, 2);
pub const AAL5_SSCS_NULL = @as(u32, 0);
pub const AAL5_SSCS_SSCOP_ASSURED = @as(u32, 1);
pub const AAL5_SSCS_SSCOP_NON_ASSURED = @as(u32, 2);
pub const AAL5_SSCS_FRAME_RELAY = @as(u32, 4);
pub const BCOB_A = @as(u32, 1);
pub const BCOB_C = @as(u32, 3);
pub const BCOB_X = @as(u32, 16);
pub const TT_NOIND = @as(u32, 0);
pub const TT_CBR = @as(u32, 4);
pub const TT_VBR = @as(u32, 8);
pub const TR_NOIND = @as(u32, 0);
pub const TR_END_TO_END = @as(u32, 1);
pub const TR_NO_END_TO_END = @as(u32, 2);
pub const CLIP_NOT = @as(u32, 0);
pub const CLIP_SUS = @as(u32, 32);
pub const UP_P2P = @as(u32, 0);
pub const UP_P2MP = @as(u32, 1);
pub const BLLI_L2_MODE_NORMAL = @as(u32, 64);
pub const BLLI_L2_MODE_EXT = @as(u32, 128);
pub const BLLI_L3_MODE_NORMAL = @as(u32, 64);
pub const BLLI_L3_MODE_EXT = @as(u32, 128);
pub const BLLI_L3_PACKET_16 = @as(u32, 4);
pub const BLLI_L3_PACKET_32 = @as(u32, 5);
pub const BLLI_L3_PACKET_64 = @as(u32, 6);
pub const BLLI_L3_PACKET_128 = @as(u32, 7);
pub const BLLI_L3_PACKET_256 = @as(u32, 8);
pub const BLLI_L3_PACKET_512 = @as(u32, 9);
pub const BLLI_L3_PACKET_1024 = @as(u32, 10);
pub const BLLI_L3_PACKET_2048 = @as(u32, 11);
pub const BLLI_L3_PACKET_4096 = @as(u32, 12);
pub const PI_ALLOWED = @as(u32, 0);
pub const PI_RESTRICTED = @as(u32, 64);
pub const PI_NUMBER_NOT_AVAILABLE = @as(u32, 128);
pub const SI_USER_NOT_SCREENED = @as(u32, 0);
pub const SI_USER_PASSED = @as(u32, 1);
pub const SI_USER_FAILED = @as(u32, 2);
pub const SI_NETWORK = @as(u32, 3);
pub const CAUSE_LOC_USER = @as(u32, 0);
pub const CAUSE_LOC_PRIVATE_LOCAL = @as(u32, 1);
pub const CAUSE_LOC_PUBLIC_LOCAL = @as(u32, 2);
pub const CAUSE_LOC_TRANSIT_NETWORK = @as(u32, 3);
pub const CAUSE_LOC_PUBLIC_REMOTE = @as(u32, 4);
pub const CAUSE_LOC_PRIVATE_REMOTE = @as(u32, 5);
pub const CAUSE_LOC_INTERNATIONAL_NETWORK = @as(u32, 7);
pub const CAUSE_LOC_BEYOND_INTERWORKING = @as(u32, 10);
pub const CAUSE_UNALLOCATED_NUMBER = @as(u32, 1);
pub const CAUSE_NO_ROUTE_TO_TRANSIT_NETWORK = @as(u32, 2);
pub const CAUSE_NO_ROUTE_TO_DESTINATION = @as(u32, 3);
pub const CAUSE_VPI_VCI_UNACCEPTABLE = @as(u32, 10);
pub const CAUSE_NORMAL_CALL_CLEARING = @as(u32, 16);
pub const CAUSE_USER_BUSY = @as(u32, 17);
pub const CAUSE_NO_USER_RESPONDING = @as(u32, 18);
pub const CAUSE_CALL_REJECTED = @as(u32, 21);
pub const CAUSE_NUMBER_CHANGED = @as(u32, 22);
pub const CAUSE_USER_REJECTS_CLIR = @as(u32, 23);
pub const CAUSE_DESTINATION_OUT_OF_ORDER = @as(u32, 27);
pub const CAUSE_INVALID_NUMBER_FORMAT = @as(u32, 28);
pub const CAUSE_STATUS_ENQUIRY_RESPONSE = @as(u32, 30);
pub const CAUSE_NORMAL_UNSPECIFIED = @as(u32, 31);
pub const CAUSE_VPI_VCI_UNAVAILABLE = @as(u32, 35);
pub const CAUSE_NETWORK_OUT_OF_ORDER = @as(u32, 38);
pub const CAUSE_TEMPORARY_FAILURE = @as(u32, 41);
pub const CAUSE_ACCESS_INFORMAION_DISCARDED = @as(u32, 43);
pub const CAUSE_NO_VPI_VCI_AVAILABLE = @as(u32, 45);
pub const CAUSE_RESOURCE_UNAVAILABLE = @as(u32, 47);
pub const CAUSE_QOS_UNAVAILABLE = @as(u32, 49);
pub const CAUSE_USER_CELL_RATE_UNAVAILABLE = @as(u32, 51);
pub const CAUSE_BEARER_CAPABILITY_UNAUTHORIZED = @as(u32, 57);
pub const CAUSE_BEARER_CAPABILITY_UNAVAILABLE = @as(u32, 58);
pub const CAUSE_OPTION_UNAVAILABLE = @as(u32, 63);
pub const CAUSE_BEARER_CAPABILITY_UNIMPLEMENTED = @as(u32, 65);
pub const CAUSE_UNSUPPORTED_TRAFFIC_PARAMETERS = @as(u32, 73);
pub const CAUSE_INVALID_CALL_REFERENCE = @as(u32, 81);
pub const CAUSE_CHANNEL_NONEXISTENT = @as(u32, 82);
pub const CAUSE_INCOMPATIBLE_DESTINATION = @as(u32, 88);
pub const CAUSE_INVALID_ENDPOINT_REFERENCE = @as(u32, 89);
pub const CAUSE_INVALID_TRANSIT_NETWORK_SELECTION = @as(u32, 91);
pub const CAUSE_TOO_MANY_PENDING_ADD_PARTY = @as(u32, 92);
pub const CAUSE_AAL_PARAMETERS_UNSUPPORTED = @as(u32, 93);
pub const CAUSE_MANDATORY_IE_MISSING = @as(u32, 96);
pub const CAUSE_UNIMPLEMENTED_MESSAGE_TYPE = @as(u32, 97);
pub const CAUSE_UNIMPLEMENTED_IE = @as(u32, 99);
pub const CAUSE_INVALID_IE_CONTENTS = @as(u32, 100);
pub const CAUSE_INVALID_STATE_FOR_MESSAGE = @as(u32, 101);
pub const CAUSE_RECOVERY_ON_TIMEOUT = @as(u32, 102);
pub const CAUSE_INCORRECT_MESSAGE_LENGTH = @as(u32, 104);
pub const CAUSE_PROTOCOL_ERROR = @as(u32, 111);
pub const CAUSE_COND_UNKNOWN = @as(u32, 0);
pub const CAUSE_COND_PERMANENT = @as(u32, 1);
pub const CAUSE_COND_TRANSIENT = @as(u32, 2);
pub const CAUSE_REASON_USER = @as(u32, 0);
pub const CAUSE_REASON_IE_MISSING = @as(u32, 4);
pub const CAUSE_REASON_IE_INSUFFICIENT = @as(u32, 8);
pub const CAUSE_PU_PROVIDER = @as(u32, 0);
pub const CAUSE_PU_USER = @as(u32, 8);
pub const CAUSE_NA_NORMAL = @as(u32, 0);
pub const CAUSE_NA_ABNORMAL = @as(u32, 4);
pub const QOS_CLASS0 = @as(u32, 0);
pub const QOS_CLASS1 = @as(u32, 1);
pub const QOS_CLASS2 = @as(u32, 2);
pub const QOS_CLASS3 = @as(u32, 3);
pub const QOS_CLASS4 = @as(u32, 4);
pub const TNS_TYPE_NATIONAL = @as(u32, 64);
pub const TNS_PLAN_CARRIER_ID_CODE = @as(u32, 1);
pub const SIO_GET_NUMBER_OF_ATM_DEVICES = @as(u32, 1343619073);
pub const SIO_GET_ATM_ADDRESS = @as(u32, 3491102722);
pub const SIO_ASSOCIATE_PVC = @as(u32, 2417360899);
pub const SIO_GET_ATM_CONNECTION_ID = @as(u32, 1343619076);
pub const WSPDESCRIPTION_LEN = @as(u32, 255);
pub const WSS_OPERATION_IN_PROGRESS = @as(i32, 259);
pub const LSP_SYSTEM = @as(u32, 2147483648);
pub const LSP_INSPECTOR = @as(u32, 1);
pub const LSP_REDIRECTOR = @as(u32, 2);
pub const LSP_PROXY = @as(u32, 4);
pub const LSP_FIREWALL = @as(u32, 8);
pub const LSP_INBOUND_MODIFY = @as(u32, 16);
pub const LSP_OUTBOUND_MODIFY = @as(u32, 32);
pub const LSP_CRYPTO_COMPRESS = @as(u32, 64);
pub const LSP_LOCAL_CACHE = @as(u32, 128);
pub const UDP_NOCHECKSUM = @as(u32, 1);
pub const UDP_CHECKSUM_COVERAGE = @as(u32, 20);
pub const GAI_STRERROR_BUFFER_SIZE = @as(u32, 1024);
pub const IPX_PTYPE = @as(u32, 16384);
pub const IPX_FILTERPTYPE = @as(u32, 16385);
pub const IPX_STOPFILTERPTYPE = @as(u32, 16387);
pub const IPX_DSTYPE = @as(u32, 16386);
pub const IPX_EXTENDED_ADDRESS = @as(u32, 16388);
pub const IPX_RECVHDR = @as(u32, 16389);
pub const IPX_MAXSIZE = @as(u32, 16390);
pub const IPX_ADDRESS = @as(u32, 16391);
pub const IPX_GETNETINFO = @as(u32, 16392);
pub const IPX_GETNETINFO_NORIP = @as(u32, 16393);
pub const IPX_SPXGETCONNECTIONSTATUS = @as(u32, 16395);
pub const IPX_ADDRESS_NOTIFY = @as(u32, 16396);
pub const IPX_MAX_ADAPTER_NUM = @as(u32, 16397);
pub const IPX_RERIPNETNUMBER = @as(u32, 16398);
pub const IPX_RECEIVE_BROADCAST = @as(u32, 16399);
pub const IPX_IMMEDIATESPXACK = @as(u32, 16400);
pub const IPPROTO_RM = @as(u32, 113);
pub const MAX_MCAST_TTL = @as(u32, 255);
pub const RM_OPTIONSBASE = @as(u32, 1000);
pub const RM_RATE_WINDOW_SIZE = @as(u32, 1001);
pub const RM_SET_MESSAGE_BOUNDARY = @as(u32, 1002);
pub const RM_FLUSHCACHE = @as(u32, 1003);
pub const RM_SENDER_WINDOW_ADVANCE_METHOD = @as(u32, 1004);
pub const RM_SENDER_STATISTICS = @as(u32, 1005);
pub const RM_LATEJOIN = @as(u32, 1006);
pub const RM_SET_SEND_IF = @as(u32, 1007);
pub const RM_ADD_RECEIVE_IF = @as(u32, 1008);
pub const RM_DEL_RECEIVE_IF = @as(u32, 1009);
pub const RM_SEND_WINDOW_ADV_RATE = @as(u32, 1010);
pub const RM_USE_FEC = @as(u32, 1011);
pub const RM_SET_MCAST_TTL = @as(u32, 1012);
pub const RM_RECEIVER_STATISTICS = @as(u32, 1013);
pub const RM_HIGH_SPEED_INTRANET_OPT = @as(u32, 1014);
pub const SENDER_DEFAULT_RATE_KBITS_PER_SEC = @as(u32, 56);
pub const SENDER_DEFAULT_WINDOW_ADV_PERCENTAGE = @as(u32, 15);
pub const MAX_WINDOW_INCREMENT_PERCENTAGE = @as(u32, 25);
pub const SENDER_DEFAULT_LATE_JOINER_PERCENTAGE = @as(u32, 0);
pub const SENDER_MAX_LATE_JOINER_PERCENTAGE = @as(u32, 75);
pub const BITS_PER_BYTE = @as(u32, 8);
pub const LOG2_BITS_PER_BYTE = @as(u32, 3);
pub const UNIX_PATH_MAX = @as(u32, 108);
pub const ISOPROTO_TP0 = @as(u32, 25);
pub const ISOPROTO_TP1 = @as(u32, 26);
pub const ISOPROTO_TP2 = @as(u32, 27);
pub const ISOPROTO_TP3 = @as(u32, 28);
pub const ISOPROTO_TP4 = @as(u32, 29);
pub const ISOPROTO_TP = @as(u32, 29);
pub const ISOPROTO_CLTP = @as(u32, 30);
pub const ISOPROTO_CLNP = @as(u32, 31);
pub const ISOPROTO_X25 = @as(u32, 32);
pub const ISOPROTO_INACT_NL = @as(u32, 33);
pub const ISOPROTO_ESIS = @as(u32, 34);
pub const ISOPROTO_INTRAISIS = @as(u32, 35);
pub const ISO_MAX_ADDR_LENGTH = @as(u32, 64);
pub const ISO_HIERARCHICAL = @as(u32, 0);
pub const ISO_NON_HIERARCHICAL = @as(u32, 1);
pub const ISO_EXP_DATA_USE = @as(u32, 0);
pub const ISO_EXP_DATA_NUSE = @as(u32, 1);
pub const NSPROTO_IPX = @as(u32, 1000);
pub const NSPROTO_SPX = @as(u32, 1256);
pub const NSPROTO_SPXII = @as(u32, 1257);
pub const NETBIOS_NAME_LENGTH = @as(u32, 16);
pub const NETBIOS_UNIQUE_NAME = @as(u32, 0);
pub const NETBIOS_GROUP_NAME = @as(u32, 1);
pub const NETBIOS_TYPE_QUICK_UNIQUE = @as(u32, 2);
pub const NETBIOS_TYPE_QUICK_GROUP = @as(u32, 3);
pub const VNSPROTO_IPC = @as(u32, 1);
pub const VNSPROTO_RELIABLE_IPC = @as(u32, 2);
pub const VNSPROTO_SPP = @as(u32, 3);
pub const INVALID_SOCKET = @import("../zig.zig").typedConst(SOCKET, @as(u32, 4294967295));
pub const WSA_INFINITE = @as(u32, 4294967295);
pub const IOC_INOUT = @as(u32, 3221225472);
pub const FIONREAD = @as(i32, 1074030207);
pub const FIONBIO = @as(i32, -2147195266);
pub const FIOASYNC = @as(i32, -2147195267);
pub const SIOCSHIWAT = @as(i32, -2147192064);
pub const SIOCGHIWAT = @as(i32, 1074033409);
pub const SIOCSLOWAT = @as(i32, -2147192062);
pub const SIOCGLOWAT = @as(i32, 1074033411);
pub const SIOCATMARK = @as(i32, 1074033415);
pub const LM_HB_Extension = @as(i32, 128);
pub const LM_HB1_PnP = @as(i32, 1);
pub const LM_HB1_PDA_Palmtop = @as(i32, 2);
pub const LM_HB1_Computer = @as(i32, 4);
pub const LM_HB1_Printer = @as(i32, 8);
pub const LM_HB1_Modem = @as(i32, 16);
pub const LM_HB1_Fax = @as(i32, 32);
pub const LM_HB1_LANAccess = @as(i32, 64);
pub const LM_HB2_Telephony = @as(i32, 1);
pub const LM_HB2_FileServer = @as(i32, 2);

//--------------------------------------------------------------------------------
// Section: Types (337)
//--------------------------------------------------------------------------------
pub const WSA_ERROR = enum(i32) {
    _IO_PENDING = 997,
    _IO_INCOMPLETE = 996,
    _INVALID_HANDLE = 6,
    _INVALID_PARAMETER = 87,
    _NOT_ENOUGH_MEMORY = 8,
    _OPERATION_ABORTED = 995,
    BASEERR = 10000,
    EINTR = 10004,
    EBADF = 10009,
    EACCES = 10013,
    EFAULT = 10014,
    EINVAL = 10022,
    EMFILE = 10024,
    EWOULDBLOCK = 10035,
    EINPROGRESS = 10036,
    EALREADY = 10037,
    ENOTSOCK = 10038,
    EDESTADDRREQ = 10039,
    EMSGSIZE = 10040,
    EPROTOTYPE = 10041,
    ENOPROTOOPT = 10042,
    EPROTONOSUPPORT = 10043,
    ESOCKTNOSUPPORT = 10044,
    EOPNOTSUPP = 10045,
    EPFNOSUPPORT = 10046,
    EAFNOSUPPORT = 10047,
    EADDRINUSE = 10048,
    EADDRNOTAVAIL = 10049,
    ENETDOWN = 10050,
    ENETUNREACH = 10051,
    ENETRESET = 10052,
    ECONNABORTED = 10053,
    ECONNRESET = 10054,
    ENOBUFS = 10055,
    EISCONN = 10056,
    ENOTCONN = 10057,
    ESHUTDOWN = 10058,
    ETOOMANYREFS = 10059,
    ETIMEDOUT = 10060,
    ECONNREFUSED = 10061,
    ELOOP = 10062,
    ENAMETOOLONG = 10063,
    EHOSTDOWN = 10064,
    EHOSTUNREACH = 10065,
    ENOTEMPTY = 10066,
    EPROCLIM = 10067,
    EUSERS = 10068,
    EDQUOT = 10069,
    ESTALE = 10070,
    EREMOTE = 10071,
    SYSNOTREADY = 10091,
    VERNOTSUPPORTED = 10092,
    NOTINITIALISED = 10093,
    EDISCON = 10101,
    ENOMORE = 10102,
    ECANCELLED = 10103,
    EINVALIDPROCTABLE = 10104,
    EINVALIDPROVIDER = 10105,
    EPROVIDERFAILEDINIT = 10106,
    SYSCALLFAILURE = 10107,
    SERVICE_NOT_FOUND = 10108,
    TYPE_NOT_FOUND = 10109,
    _E_NO_MORE = 10110,
    _E_CANCELLED = 10111,
    EREFUSED = 10112,
    HOST_NOT_FOUND = 11001,
    TRY_AGAIN = 11002,
    NO_RECOVERY = 11003,
    NO_DATA = 11004,
    _QOS_RECEIVERS = 11005,
    _QOS_SENDERS = 11006,
    _QOS_NO_SENDERS = 11007,
    _QOS_NO_RECEIVERS = 11008,
    _QOS_REQUEST_CONFIRMED = 11009,
    _QOS_ADMISSION_FAILURE = 11010,
    _QOS_POLICY_FAILURE = 11011,
    _QOS_BAD_STYLE = 11012,
    _QOS_BAD_OBJECT = 11013,
    _QOS_TRAFFIC_CTRL_ERROR = 11014,
    _QOS_GENERIC_ERROR = 11015,
    _QOS_ESERVICETYPE = 11016,
    _QOS_EFLOWSPEC = 11017,
    _QOS_EPROVSPECBUF = 11018,
    _QOS_EFILTERSTYLE = 11019,
    _QOS_EFILTERTYPE = 11020,
    _QOS_EFILTERCOUNT = 11021,
    _QOS_EOBJLENGTH = 11022,
    _QOS_EFLOWCOUNT = 11023,
    _QOS_EUNKOWNPSOBJ = 11024,
    _QOS_EPOLICYOBJ = 11025,
    _QOS_EFLOWDESC = 11026,
    _QOS_EPSFLOWSPEC = 11027,
    _QOS_EPSFILTERSPEC = 11028,
    _QOS_ESDMODEOBJ = 11029,
    _QOS_ESHAPERATEOBJ = 11030,
    _QOS_RESERVED_PETYPE = 11031,
    _SECURE_HOST_NOT_FOUND = 11032,
    _IPSEC_NAME_POLICY_ERROR = 11033,
};
pub const WSA_IO_PENDING = WSA_ERROR._IO_PENDING;
pub const WSA_IO_INCOMPLETE = WSA_ERROR._IO_INCOMPLETE;
pub const WSA_INVALID_HANDLE = WSA_ERROR._INVALID_HANDLE;
pub const WSA_INVALID_PARAMETER = WSA_ERROR._INVALID_PARAMETER;
pub const WSA_NOT_ENOUGH_MEMORY = WSA_ERROR._NOT_ENOUGH_MEMORY;
pub const WSA_OPERATION_ABORTED = WSA_ERROR._OPERATION_ABORTED;
pub const WSABASEERR = WSA_ERROR.BASEERR;
pub const WSAEINTR = WSA_ERROR.EINTR;
pub const WSAEBADF = WSA_ERROR.EBADF;
pub const WSAEACCES = WSA_ERROR.EACCES;
pub const WSAEFAULT = WSA_ERROR.EFAULT;
pub const WSAEINVAL = WSA_ERROR.EINVAL;
pub const WSAEMFILE = WSA_ERROR.EMFILE;
pub const WSAEWOULDBLOCK = WSA_ERROR.EWOULDBLOCK;
pub const WSAEINPROGRESS = WSA_ERROR.EINPROGRESS;
pub const WSAEALREADY = WSA_ERROR.EALREADY;
pub const WSAENOTSOCK = WSA_ERROR.ENOTSOCK;
pub const WSAEDESTADDRREQ = WSA_ERROR.EDESTADDRREQ;
pub const WSAEMSGSIZE = WSA_ERROR.EMSGSIZE;
pub const WSAEPROTOTYPE = WSA_ERROR.EPROTOTYPE;
pub const WSAENOPROTOOPT = WSA_ERROR.ENOPROTOOPT;
pub const WSAEPROTONOSUPPORT = WSA_ERROR.EPROTONOSUPPORT;
pub const WSAESOCKTNOSUPPORT = WSA_ERROR.ESOCKTNOSUPPORT;
pub const WSAEOPNOTSUPP = WSA_ERROR.EOPNOTSUPP;
pub const WSAEPFNOSUPPORT = WSA_ERROR.EPFNOSUPPORT;
pub const WSAEAFNOSUPPORT = WSA_ERROR.EAFNOSUPPORT;
pub const WSAEADDRINUSE = WSA_ERROR.EADDRINUSE;
pub const WSAEADDRNOTAVAIL = WSA_ERROR.EADDRNOTAVAIL;
pub const WSAENETDOWN = WSA_ERROR.ENETDOWN;
pub const WSAENETUNREACH = WSA_ERROR.ENETUNREACH;
pub const WSAENETRESET = WSA_ERROR.ENETRESET;
pub const WSAECONNABORTED = WSA_ERROR.ECONNABORTED;
pub const WSAECONNRESET = WSA_ERROR.ECONNRESET;
pub const WSAENOBUFS = WSA_ERROR.ENOBUFS;
pub const WSAEISCONN = WSA_ERROR.EISCONN;
pub const WSAENOTCONN = WSA_ERROR.ENOTCONN;
pub const WSAESHUTDOWN = WSA_ERROR.ESHUTDOWN;
pub const WSAETOOMANYREFS = WSA_ERROR.ETOOMANYREFS;
pub const WSAETIMEDOUT = WSA_ERROR.ETIMEDOUT;
pub const WSAECONNREFUSED = WSA_ERROR.ECONNREFUSED;
pub const WSAELOOP = WSA_ERROR.ELOOP;
pub const WSAENAMETOOLONG = WSA_ERROR.ENAMETOOLONG;
pub const WSAEHOSTDOWN = WSA_ERROR.EHOSTDOWN;
pub const WSAEHOSTUNREACH = WSA_ERROR.EHOSTUNREACH;
pub const WSAENOTEMPTY = WSA_ERROR.ENOTEMPTY;
pub const WSAEPROCLIM = WSA_ERROR.EPROCLIM;
pub const WSAEUSERS = WSA_ERROR.EUSERS;
pub const WSAEDQUOT = WSA_ERROR.EDQUOT;
pub const WSAESTALE = WSA_ERROR.ESTALE;
pub const WSAEREMOTE = WSA_ERROR.EREMOTE;
pub const WSASYSNOTREADY = WSA_ERROR.SYSNOTREADY;
pub const WSAVERNOTSUPPORTED = WSA_ERROR.VERNOTSUPPORTED;
pub const WSANOTINITIALISED = WSA_ERROR.NOTINITIALISED;
pub const WSAEDISCON = WSA_ERROR.EDISCON;
pub const WSAENOMORE = WSA_ERROR.ENOMORE;
pub const WSAECANCELLED = WSA_ERROR.ECANCELLED;
pub const WSAEINVALIDPROCTABLE = WSA_ERROR.EINVALIDPROCTABLE;
pub const WSAEINVALIDPROVIDER = WSA_ERROR.EINVALIDPROVIDER;
pub const WSAEPROVIDERFAILEDINIT = WSA_ERROR.EPROVIDERFAILEDINIT;
pub const WSASYSCALLFAILURE = WSA_ERROR.SYSCALLFAILURE;
pub const WSASERVICE_NOT_FOUND = WSA_ERROR.SERVICE_NOT_FOUND;
pub const WSATYPE_NOT_FOUND = WSA_ERROR.TYPE_NOT_FOUND;
pub const WSA_E_NO_MORE = WSA_ERROR._E_NO_MORE;
pub const WSA_E_CANCELLED = WSA_ERROR._E_CANCELLED;
pub const WSAEREFUSED = WSA_ERROR.EREFUSED;
pub const WSAHOST_NOT_FOUND = WSA_ERROR.HOST_NOT_FOUND;
pub const WSATRY_AGAIN = WSA_ERROR.TRY_AGAIN;
pub const WSANO_RECOVERY = WSA_ERROR.NO_RECOVERY;
pub const WSANO_DATA = WSA_ERROR.NO_DATA;
pub const WSA_QOS_RECEIVERS = WSA_ERROR._QOS_RECEIVERS;
pub const WSA_QOS_SENDERS = WSA_ERROR._QOS_SENDERS;
pub const WSA_QOS_NO_SENDERS = WSA_ERROR._QOS_NO_SENDERS;
pub const WSA_QOS_NO_RECEIVERS = WSA_ERROR._QOS_NO_RECEIVERS;
pub const WSA_QOS_REQUEST_CONFIRMED = WSA_ERROR._QOS_REQUEST_CONFIRMED;
pub const WSA_QOS_ADMISSION_FAILURE = WSA_ERROR._QOS_ADMISSION_FAILURE;
pub const WSA_QOS_POLICY_FAILURE = WSA_ERROR._QOS_POLICY_FAILURE;
pub const WSA_QOS_BAD_STYLE = WSA_ERROR._QOS_BAD_STYLE;
pub const WSA_QOS_BAD_OBJECT = WSA_ERROR._QOS_BAD_OBJECT;
pub const WSA_QOS_TRAFFIC_CTRL_ERROR = WSA_ERROR._QOS_TRAFFIC_CTRL_ERROR;
pub const WSA_QOS_GENERIC_ERROR = WSA_ERROR._QOS_GENERIC_ERROR;
pub const WSA_QOS_ESERVICETYPE = WSA_ERROR._QOS_ESERVICETYPE;
pub const WSA_QOS_EFLOWSPEC = WSA_ERROR._QOS_EFLOWSPEC;
pub const WSA_QOS_EPROVSPECBUF = WSA_ERROR._QOS_EPROVSPECBUF;
pub const WSA_QOS_EFILTERSTYLE = WSA_ERROR._QOS_EFILTERSTYLE;
pub const WSA_QOS_EFILTERTYPE = WSA_ERROR._QOS_EFILTERTYPE;
pub const WSA_QOS_EFILTERCOUNT = WSA_ERROR._QOS_EFILTERCOUNT;
pub const WSA_QOS_EOBJLENGTH = WSA_ERROR._QOS_EOBJLENGTH;
pub const WSA_QOS_EFLOWCOUNT = WSA_ERROR._QOS_EFLOWCOUNT;
pub const WSA_QOS_EUNKOWNPSOBJ = WSA_ERROR._QOS_EUNKOWNPSOBJ;
pub const WSA_QOS_EPOLICYOBJ = WSA_ERROR._QOS_EPOLICYOBJ;
pub const WSA_QOS_EFLOWDESC = WSA_ERROR._QOS_EFLOWDESC;
pub const WSA_QOS_EPSFLOWSPEC = WSA_ERROR._QOS_EPSFLOWSPEC;
pub const WSA_QOS_EPSFILTERSPEC = WSA_ERROR._QOS_EPSFILTERSPEC;
pub const WSA_QOS_ESDMODEOBJ = WSA_ERROR._QOS_ESDMODEOBJ;
pub const WSA_QOS_ESHAPERATEOBJ = WSA_ERROR._QOS_ESHAPERATEOBJ;
pub const WSA_QOS_RESERVED_PETYPE = WSA_ERROR._QOS_RESERVED_PETYPE;
pub const WSA_SECURE_HOST_NOT_FOUND = WSA_ERROR._SECURE_HOST_NOT_FOUND;
pub const WSA_IPSEC_NAME_POLICY_ERROR = WSA_ERROR._IPSEC_NAME_POLICY_ERROR;

pub const SET_SERVICE_OPERATION = enum(u32) {
    REGISTER = 1,
    DEREGISTER = 2,
    FLUSH = 3,
    ADD_TYPE = 4,
    DELETE_TYPE = 5,
};
pub const SERVICE_REGISTER = SET_SERVICE_OPERATION.REGISTER;
pub const SERVICE_DEREGISTER = SET_SERVICE_OPERATION.DEREGISTER;
pub const SERVICE_FLUSH = SET_SERVICE_OPERATION.FLUSH;
pub const SERVICE_ADD_TYPE = SET_SERVICE_OPERATION.ADD_TYPE;
pub const SERVICE_DELETE_TYPE = SET_SERVICE_OPERATION.DELETE_TYPE;

pub const SEND_FLAGS = enum(u32) {
    DONTROUTE = 4,
    OOB = 1,
    _,
};
pub const MSG_DONTROUTE = SEND_FLAGS.DONTROUTE;
pub const MSG_OOB = SEND_FLAGS.OOB;

pub const RESOURCE_DISPLAY_TYPE = enum(u32) {
    DOMAIN = 1,
    FILE = 4,
    GENERIC = 0,
    GROUP = 5,
    SERVER = 2,
    SHARE = 3,
    TREE = 10,
};
pub const RESOURCEDISPLAYTYPE_DOMAIN = RESOURCE_DISPLAY_TYPE.DOMAIN;
pub const RESOURCEDISPLAYTYPE_FILE = RESOURCE_DISPLAY_TYPE.FILE;
pub const RESOURCEDISPLAYTYPE_GENERIC = RESOURCE_DISPLAY_TYPE.GENERIC;
pub const RESOURCEDISPLAYTYPE_GROUP = RESOURCE_DISPLAY_TYPE.GROUP;
pub const RESOURCEDISPLAYTYPE_SERVER = RESOURCE_DISPLAY_TYPE.SERVER;
pub const RESOURCEDISPLAYTYPE_SHARE = RESOURCE_DISPLAY_TYPE.SHARE;
pub const RESOURCEDISPLAYTYPE_TREE = RESOURCE_DISPLAY_TYPE.TREE;

pub const RIO_BUFFERID_t = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const RIO_CQ_t = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const RIO_RQ_t = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

// TODO: this type has a FreeFunc 'WSACloseEvent', what can Zig do with this information?
pub const HWSAEVENT = *opaque{};

// TODO: this type has a FreeFunc 'closesocket', what can Zig do with this information?
pub const SOCKET = @import("std").os.windows.ws2_32.SOCKET;

pub const IN_ADDR = extern struct {
    S_un: extern union {
        S_un_b: extern struct {
            s_b1: u8,
            s_b2: u8,
            s_b3: u8,
            s_b4: u8,
        },
        S_un_w: extern struct {
            s_w1: u16,
            s_w2: u16,
        },
        S_addr: u32,
    },
};

pub const SOCKADDR = extern struct {
    sa_family: u16,
    sa_data: [14]CHAR,
};

pub const SOCKET_ADDRESS = extern struct {
    lpSockaddr: ?*SOCKADDR,
    iSockaddrLength: i32,
};

pub const SOCKET_ADDRESS_LIST = extern struct {
    iAddressCount: i32,
    Address: [1]SOCKET_ADDRESS,
};

pub const CSADDR_INFO = extern struct {
    LocalAddr: SOCKET_ADDRESS,
    RemoteAddr: SOCKET_ADDRESS,
    iSocketType: i32,
    iProtocol: i32,
};

pub const SOCKADDR_STORAGE = extern struct {
    ss_family: u16,
    __ss_pad1: [6]CHAR,
    __ss_align: i64,
    __ss_pad2: [112]CHAR,
};

pub const SOCKADDR_STORAGE_XP = extern struct {
    ss_family: i16,
    __ss_pad1: [6]CHAR,
    __ss_align: i64,
    __ss_pad2: [112]CHAR,
};

pub const SOCKET_PROCESSOR_AFFINITY = extern struct {
    Processor: PROCESSOR_NUMBER,
    NumaNodeId: u16,
    Reserved: u16,
};

pub const IPPROTO = enum(i32) {
    HOPOPTS = 0,
    ICMP = 1,
    IGMP = 2,
    GGP = 3,
    IPV4 = 4,
    ST = 5,
    TCP = 6,
    CBT = 7,
    EGP = 8,
    IGP = 9,
    PUP = 12,
    UDP = 17,
    IDP = 22,
    RDP = 27,
    IPV6 = 41,
    ROUTING = 43,
    FRAGMENT = 44,
    ESP = 50,
    AH = 51,
    ICMPV6 = 58,
    NONE = 59,
    DSTOPTS = 60,
    ND = 77,
    ICLFXBM = 78,
    PIM = 103,
    PGM = 113,
    L2TP = 115,
    SCTP = 132,
    RAW = 255,
    MAX = 256,
    RESERVED_RAW = 257,
    RESERVED_IPSEC = 258,
    RESERVED_IPSECOFFLOAD = 259,
    RESERVED_WNV = 260,
    RESERVED_MAX = 261,
};
pub const IPPROTO_HOPOPTS = IPPROTO.HOPOPTS;
pub const IPPROTO_ICMP = IPPROTO.ICMP;
pub const IPPROTO_IGMP = IPPROTO.IGMP;
pub const IPPROTO_GGP = IPPROTO.GGP;
pub const IPPROTO_IPV4 = IPPROTO.IPV4;
pub const IPPROTO_ST = IPPROTO.ST;
pub const IPPROTO_TCP = IPPROTO.TCP;
pub const IPPROTO_CBT = IPPROTO.CBT;
pub const IPPROTO_EGP = IPPROTO.EGP;
pub const IPPROTO_IGP = IPPROTO.IGP;
pub const IPPROTO_PUP = IPPROTO.PUP;
pub const IPPROTO_UDP = IPPROTO.UDP;
pub const IPPROTO_IDP = IPPROTO.IDP;
pub const IPPROTO_RDP = IPPROTO.RDP;
pub const IPPROTO_IPV6 = IPPROTO.IPV6;
pub const IPPROTO_ROUTING = IPPROTO.ROUTING;
pub const IPPROTO_FRAGMENT = IPPROTO.FRAGMENT;
pub const IPPROTO_ESP = IPPROTO.ESP;
pub const IPPROTO_AH = IPPROTO.AH;
pub const IPPROTO_ICMPV6 = IPPROTO.ICMPV6;
pub const IPPROTO_NONE = IPPROTO.NONE;
pub const IPPROTO_DSTOPTS = IPPROTO.DSTOPTS;
pub const IPPROTO_ND = IPPROTO.ND;
pub const IPPROTO_ICLFXBM = IPPROTO.ICLFXBM;
pub const IPPROTO_PIM = IPPROTO.PIM;
pub const IPPROTO_PGM = IPPROTO.PGM;
pub const IPPROTO_L2TP = IPPROTO.L2TP;
pub const IPPROTO_SCTP = IPPROTO.SCTP;
pub const IPPROTO_RAW = IPPROTO.RAW;
pub const IPPROTO_MAX = IPPROTO.MAX;
pub const IPPROTO_RESERVED_RAW = IPPROTO.RESERVED_RAW;
pub const IPPROTO_RESERVED_IPSEC = IPPROTO.RESERVED_IPSEC;
pub const IPPROTO_RESERVED_IPSECOFFLOAD = IPPROTO.RESERVED_IPSECOFFLOAD;
pub const IPPROTO_RESERVED_WNV = IPPROTO.RESERVED_WNV;
pub const IPPROTO_RESERVED_MAX = IPPROTO.RESERVED_MAX;

pub const SCOPE_LEVEL = enum(i32) {
    Interface = 1,
    Link = 2,
    Subnet = 3,
    Admin = 4,
    Site = 5,
    Organization = 8,
    Global = 14,
    Count = 16,
};
pub const ScopeLevelInterface = SCOPE_LEVEL.Interface;
pub const ScopeLevelLink = SCOPE_LEVEL.Link;
pub const ScopeLevelSubnet = SCOPE_LEVEL.Subnet;
pub const ScopeLevelAdmin = SCOPE_LEVEL.Admin;
pub const ScopeLevelSite = SCOPE_LEVEL.Site;
pub const ScopeLevelOrganization = SCOPE_LEVEL.Organization;
pub const ScopeLevelGlobal = SCOPE_LEVEL.Global;
pub const ScopeLevelCount = SCOPE_LEVEL.Count;

pub const SCOPE_ID = extern struct {
    Anonymous: extern union {
        Anonymous: extern struct {
            _bitfield: u32,
        },
        Value: u32,
    },
};

pub const SOCKADDR_IN = extern struct {
    sin_family: u16,
    sin_port: u16,
    sin_addr: IN_ADDR,
    sin_zero: [8]CHAR,
};

pub const SOCKADDR_DL = extern struct {
    sdl_family: u16,
    sdl_data: [8]u8,
    sdl_zero: [4]u8,
};

pub const WSABUF = extern struct {
    len: u32,
    buf: ?PSTR,
};

pub const WSAMSG = extern struct {
    name: ?*SOCKADDR,
    namelen: i32,
    lpBuffers: ?*WSABUF,
    dwBufferCount: u32,
    Control: WSABUF,
    dwFlags: u32,
};

pub const cmsghdr = extern struct {
    cmsg_len: usize,
    cmsg_level: i32,
    cmsg_type: i32,
};

pub const ADDRINFOA = extern struct {
    ai_flags: i32,
    ai_family: i32,
    ai_socktype: i32,
    ai_protocol: i32,
    ai_addrlen: usize,
    ai_canonname: ?PSTR,
    ai_addr: ?*SOCKADDR,
    ai_next: ?*ADDRINFOA,
};

pub const addrinfoW = extern struct {
    ai_flags: i32,
    ai_family: i32,
    ai_socktype: i32,
    ai_protocol: i32,
    ai_addrlen: usize,
    ai_canonname: ?PWSTR,
    ai_addr: ?*SOCKADDR,
    ai_next: ?*addrinfoW,
};

pub const addrinfoexA = extern struct {
    ai_flags: i32,
    ai_family: i32,
    ai_socktype: i32,
    ai_protocol: i32,
    ai_addrlen: usize,
    ai_canonname: ?PSTR,
    ai_addr: ?*SOCKADDR,
    ai_blob: ?*anyopaque,
    ai_bloblen: usize,
    ai_provider: ?*Guid,
    ai_next: ?*addrinfoexA,
};

pub const addrinfoexW = extern struct {
    ai_flags: i32,
    ai_family: i32,
    ai_socktype: i32,
    ai_protocol: i32,
    ai_addrlen: usize,
    ai_canonname: ?PWSTR,
    ai_addr: ?*SOCKADDR,
    ai_blob: ?*anyopaque,
    ai_bloblen: usize,
    ai_provider: ?*Guid,
    ai_next: ?*addrinfoexW,
};

pub const addrinfoex2A = extern struct {
    ai_flags: i32,
    ai_family: i32,
    ai_socktype: i32,
    ai_protocol: i32,
    ai_addrlen: usize,
    ai_canonname: ?PSTR,
    ai_addr: ?*SOCKADDR,
    ai_blob: ?*anyopaque,
    ai_bloblen: usize,
    ai_provider: ?*Guid,
    ai_next: ?*addrinfoex2A,
    ai_version: i32,
    ai_fqdn: ?PSTR,
};

pub const addrinfoex2W = extern struct {
    ai_flags: i32,
    ai_family: i32,
    ai_socktype: i32,
    ai_protocol: i32,
    ai_addrlen: usize,
    ai_canonname: ?PWSTR,
    ai_addr: ?*SOCKADDR,
    ai_blob: ?*anyopaque,
    ai_bloblen: usize,
    ai_provider: ?*Guid,
    ai_next: ?*addrinfoex2W,
    ai_version: i32,
    ai_fqdn: ?PWSTR,
};

pub const addrinfoex3 = extern struct {
    ai_flags: i32,
    ai_family: i32,
    ai_socktype: i32,
    ai_protocol: i32,
    ai_addrlen: usize,
    ai_canonname: ?PWSTR,
    ai_addr: ?*SOCKADDR,
    ai_blob: ?*anyopaque,
    ai_bloblen: usize,
    ai_provider: ?*Guid,
    ai_next: ?*addrinfoex3,
    ai_version: i32,
    ai_fqdn: ?PWSTR,
    ai_interfaceindex: i32,
};

pub const addrinfoex4 = extern struct {
    ai_flags: i32,
    ai_family: i32,
    ai_socktype: i32,
    ai_protocol: i32,
    ai_addrlen: usize,
    ai_canonname: ?PWSTR,
    ai_addr: ?*SOCKADDR,
    ai_blob: ?*anyopaque,
    ai_bloblen: usize,
    ai_provider: ?*Guid,
    ai_next: ?*addrinfoex4,
    ai_version: i32,
    ai_fqdn: ?PWSTR,
    ai_interfaceindex: i32,
    ai_resolutionhandle: ?HANDLE,
};

pub const addrinfoex5 = extern struct {
    ai_flags: i32,
    ai_family: i32,
    ai_socktype: i32,
    ai_protocol: i32,
    ai_addrlen: usize,
    ai_canonname: ?PWSTR,
    ai_addr: ?*SOCKADDR,
    ai_blob: ?*anyopaque,
    ai_bloblen: usize,
    ai_provider: ?*Guid,
    ai_next: ?*addrinfoex5,
    ai_version: i32,
    ai_fqdn: ?PWSTR,
    ai_interfaceindex: i32,
    ai_resolutionhandle: ?HANDLE,
    ai_ttl: u32,
};

pub const addrinfo_dns_server = extern struct {
    ai_servertype: u32,
    ai_flags: u64,
    ai_addrlen: u32,
    ai_addr: ?*SOCKADDR,
    Anonymous: extern union {
        ai_template: ?PWSTR,
    },
};

pub const addrinfoex6 = extern struct {
    ai_flags: i32,
    ai_family: i32,
    ai_socktype: i32,
    ai_protocol: i32,
    ai_addrlen: usize,
    ai_canonname: ?PWSTR,
    ai_addr: ?*SOCKADDR,
    ai_blob: ?*anyopaque,
    ai_bloblen: usize,
    ai_provider: ?*Guid,
    ai_next: ?*addrinfoex5,
    ai_version: i32,
    ai_fqdn: ?PWSTR,
    ai_interfaceindex: i32,
    ai_resolutionhandle: ?HANDLE,
    ai_ttl: u32,
    ai_numservers: u32,
    ai_servers: ?*addrinfo_dns_server,
    ai_responseflags: u64,
};

pub const fd_set = extern struct {
    fd_count: u32,
    fd_array: [64]?SOCKET,
};

pub const timeval = extern struct {
    tv_sec: i32,
    tv_usec: i32,
};

pub const hostent = extern struct {
    h_name: ?PSTR,
    h_aliases: ?*?*i8,
    h_addrtype: i16,
    h_length: i16,
    h_addr_list: ?*?*i8,
};

pub const netent = extern struct {
    n_name: ?PSTR,
    n_aliases: ?*?*i8,
    n_addrtype: i16,
    n_net: u32,
};


pub const protoent = extern struct {
    p_name: ?PSTR,
    p_aliases: ?*?*i8,
    p_proto: i16,
};


pub const sockproto = extern struct {
    sp_family: u16,
    sp_protocol: u16,
};

pub const linger = extern struct {
    l_onoff: u16,
    l_linger: u16,
};

pub const WSANETWORKEVENTS = extern struct {
    lNetworkEvents: i32,
    iErrorCode: [10]i32,
};

pub const WSAPROTOCOLCHAIN = extern struct {
    ChainLen: i32,
    ChainEntries: [7]u32,
};

pub const WSAPROTOCOL_INFOA = extern struct {
    dwServiceFlags1: u32,
    dwServiceFlags2: u32,
    dwServiceFlags3: u32,
    dwServiceFlags4: u32,
    dwProviderFlags: u32,
    ProviderId: Guid,
    dwCatalogEntryId: u32,
    ProtocolChain: WSAPROTOCOLCHAIN,
    iVersion: i32,
    iAddressFamily: i32,
    iMaxSockAddr: i32,
    iMinSockAddr: i32,
    iSocketType: i32,
    iProtocol: i32,
    iProtocolMaxOffset: i32,
    iNetworkByteOrder: i32,
    iSecurityScheme: i32,
    dwMessageSize: u32,
    dwProviderReserved: u32,
    szProtocol: [256]CHAR,
};

pub const WSAPROTOCOL_INFOW = extern struct {
    dwServiceFlags1: u32,
    dwServiceFlags2: u32,
    dwServiceFlags3: u32,
    dwServiceFlags4: u32,
    dwProviderFlags: u32,
    ProviderId: Guid,
    dwCatalogEntryId: u32,
    ProtocolChain: WSAPROTOCOLCHAIN,
    iVersion: i32,
    iAddressFamily: i32,
    iMaxSockAddr: i32,
    iMinSockAddr: i32,
    iSocketType: i32,
    iProtocol: i32,
    iProtocolMaxOffset: i32,
    iNetworkByteOrder: i32,
    iSecurityScheme: i32,
    dwMessageSize: u32,
    dwProviderReserved: u32,
    szProtocol: [256]u16,
};

pub const LPCONDITIONPROC = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        lpCallerId: ?*WSABUF,
        lpCallerData: ?*WSABUF,
        lpSQOS: ?*QOS,
        lpGQOS: ?*QOS,
        lpCalleeId: ?*WSABUF,
        lpCalleeData: ?*WSABUF,
        g: ?*u32,
        dwCallbackData: usize,
    ) callconv(@import("std").os.windows.WINAPI) i32,
    else => *const fn(
        lpCallerId: ?*WSABUF,
        lpCallerData: ?*WSABUF,
        lpSQOS: ?*QOS,
        lpGQOS: ?*QOS,
        lpCalleeId: ?*WSABUF,
        lpCalleeData: ?*WSABUF,
        g: ?*u32,
        dwCallbackData: usize,
    ) callconv(@import("std").os.windows.WINAPI) i32,
} ;

pub const LPWSAOVERLAPPED_COMPLETION_ROUTINE = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        dwError: u32,
        cbTransferred: u32,
        lpOverlapped: ?*OVERLAPPED,
        dwFlags: u32,
    ) callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn(
        dwError: u32,
        cbTransferred: u32,
        lpOverlapped: ?*OVERLAPPED,
        dwFlags: u32,
    ) callconv(@import("std").os.windows.WINAPI) void,
} ;

pub const WSACOMPLETIONTYPE = enum(i32) {
    IMMEDIATELY = 0,
    HWND = 1,
    EVENT = 2,
    PORT = 3,
    APC = 4,
};
pub const NSP_NOTIFY_IMMEDIATELY = WSACOMPLETIONTYPE.IMMEDIATELY;
pub const NSP_NOTIFY_HWND = WSACOMPLETIONTYPE.HWND;
pub const NSP_NOTIFY_EVENT = WSACOMPLETIONTYPE.EVENT;
pub const NSP_NOTIFY_PORT = WSACOMPLETIONTYPE.PORT;
pub const NSP_NOTIFY_APC = WSACOMPLETIONTYPE.APC;

pub const WSACOMPLETION = extern struct {
    Type: WSACOMPLETIONTYPE,
    Parameters: extern union {
        WindowMessage: extern struct {
            hWnd: ?HWND,
            uMsg: u32,
            context: WPARAM,
        },
        Event: extern struct {
            lpOverlapped: ?*OVERLAPPED,
        },
        Apc: extern struct {
            lpOverlapped: ?*OVERLAPPED,
            lpfnCompletionProc: ?LPWSAOVERLAPPED_COMPLETION_ROUTINE,
        },
        Port: extern struct {
            lpOverlapped: ?*OVERLAPPED,
            hPort: ?HANDLE,
            Key: usize,
        },
    },
};

pub const AFPROTOCOLS = extern struct {
    iAddressFamily: i32,
    iProtocol: i32,
};

pub const WSAECOMPARATOR = enum(i32) {
    EQUAL = 0,
    NOTLESS = 1,
};
pub const COMP_EQUAL = WSAECOMPARATOR.EQUAL;
pub const COMP_NOTLESS = WSAECOMPARATOR.NOTLESS;

pub const WSAVERSION = extern struct {
    dwVersion: u32,
    ecHow: WSAECOMPARATOR,
};

pub const WSAQUERYSETA = extern struct {
    dwSize: u32,
    lpszServiceInstanceName: ?PSTR,
    lpServiceClassId: ?*Guid,
    lpVersion: ?*WSAVERSION,
    lpszComment: ?PSTR,
    dwNameSpace: u32,
    lpNSProviderId: ?*Guid,
    lpszContext: ?PSTR,
    dwNumberOfProtocols: u32,
    lpafpProtocols: ?*AFPROTOCOLS,
    lpszQueryString: ?PSTR,
    dwNumberOfCsAddrs: u32,
    lpcsaBuffer: ?*CSADDR_INFO,
    dwOutputFlags: u32,
    lpBlob: ?*BLOB,
};

pub const WSAQUERYSETW = extern struct {
    dwSize: u32,
    lpszServiceInstanceName: ?PWSTR,
    lpServiceClassId: ?*Guid,
    lpVersion: ?*WSAVERSION,
    lpszComment: ?PWSTR,
    dwNameSpace: u32,
    lpNSProviderId: ?*Guid,
    lpszContext: ?PWSTR,
    dwNumberOfProtocols: u32,
    lpafpProtocols: ?*AFPROTOCOLS,
    lpszQueryString: ?PWSTR,
    dwNumberOfCsAddrs: u32,
    lpcsaBuffer: ?*CSADDR_INFO,
    dwOutputFlags: u32,
    lpBlob: ?*BLOB,
};

pub const WSAQUERYSET2A = extern struct {
    dwSize: u32,
    lpszServiceInstanceName: ?PSTR,
    lpVersion: ?*WSAVERSION,
    lpszComment: ?PSTR,
    dwNameSpace: u32,
    lpNSProviderId: ?*Guid,
    lpszContext: ?PSTR,
    dwNumberOfProtocols: u32,
    lpafpProtocols: ?*AFPROTOCOLS,
    lpszQueryString: ?PSTR,
    dwNumberOfCsAddrs: u32,
    lpcsaBuffer: ?*CSADDR_INFO,
    dwOutputFlags: u32,
    lpBlob: ?*BLOB,
};

pub const WSAQUERYSET2W = extern struct {
    dwSize: u32,
    lpszServiceInstanceName: ?PWSTR,
    lpVersion: ?*WSAVERSION,
    lpszComment: ?PWSTR,
    dwNameSpace: u32,
    lpNSProviderId: ?*Guid,
    lpszContext: ?PWSTR,
    dwNumberOfProtocols: u32,
    lpafpProtocols: ?*AFPROTOCOLS,
    lpszQueryString: ?PWSTR,
    dwNumberOfCsAddrs: u32,
    lpcsaBuffer: ?*CSADDR_INFO,
    dwOutputFlags: u32,
    lpBlob: ?*BLOB,
};

pub const WSAESETSERVICEOP = enum(i32) {
    REGISTER = 0,
    DEREGISTER = 1,
    DELETE = 2,
};
pub const RNRSERVICE_REGISTER = WSAESETSERVICEOP.REGISTER;
pub const RNRSERVICE_DEREGISTER = WSAESETSERVICEOP.DEREGISTER;
pub const RNRSERVICE_DELETE = WSAESETSERVICEOP.DELETE;

pub const WSANSCLASSINFOA = extern struct {
    lpszName: ?PSTR,
    dwNameSpace: u32,
    dwValueType: u32,
    dwValueSize: u32,
    lpValue: ?*anyopaque,
};

pub const WSANSCLASSINFOW = extern struct {
    lpszName: ?PWSTR,
    dwNameSpace: u32,
    dwValueType: u32,
    dwValueSize: u32,
    lpValue: ?*anyopaque,
};

pub const WSASERVICECLASSINFOA = extern struct {
    lpServiceClassId: ?*Guid,
    lpszServiceClassName: ?PSTR,
    dwCount: u32,
    lpClassInfos: ?*WSANSCLASSINFOA,
};

pub const WSASERVICECLASSINFOW = extern struct {
    lpServiceClassId: ?*Guid,
    lpszServiceClassName: ?PWSTR,
    dwCount: u32,
    lpClassInfos: ?*WSANSCLASSINFOW,
};

pub const WSANAMESPACE_INFOA = extern struct {
    NSProviderId: Guid,
    dwNameSpace: u32,
    fActive: BOOL,
    dwVersion: u32,
    lpszIdentifier: ?PSTR,
};

pub const WSANAMESPACE_INFOW = extern struct {
    NSProviderId: Guid,
    dwNameSpace: u32,
    fActive: BOOL,
    dwVersion: u32,
    lpszIdentifier: ?PWSTR,
};

pub const WSANAMESPACE_INFOEXA = extern struct {
    NSProviderId: Guid,
    dwNameSpace: u32,
    fActive: BOOL,
    dwVersion: u32,
    lpszIdentifier: ?PSTR,
    ProviderSpecific: BLOB,
};

pub const WSANAMESPACE_INFOEXW = extern struct {
    NSProviderId: Guid,
    dwNameSpace: u32,
    fActive: BOOL,
    dwVersion: u32,
    lpszIdentifier: ?PWSTR,
    ProviderSpecific: BLOB,
};

pub const WSAPOLLFD = extern struct {
    fd: ?SOCKET,
    events: i16,
    revents: i16,
};

pub const SOCK_NOTIFY_REGISTRATION = extern struct {
    socket: ?SOCKET,
    completionKey: ?*anyopaque,
    eventFilter: u16,
    operation: u8,
    triggerFlags: u8,
    registrationResult: u32,
};

pub const IN6_ADDR = extern struct {
    u: extern union {
        Byte: [16]u8,
        Word: [8]u16,
    },
};

pub const sockaddr_in6_old = extern struct {
    sin6_family: i16,
    sin6_port: u16,
    sin6_flowinfo: u32,
    sin6_addr: IN6_ADDR,
};

pub const sockaddr_gen = extern union {
    Address: SOCKADDR,
    AddressIn: SOCKADDR_IN,
    AddressIn6: sockaddr_in6_old,
};

pub const INTERFACE_INFO = extern struct {
    iiFlags: u32,
    iiAddress: sockaddr_gen,
    iiBroadcastAddress: sockaddr_gen,
    iiNetmask: sockaddr_gen,
};

pub const INTERFACE_INFO_EX = extern struct {
    iiFlags: u32,
    iiAddress: SOCKET_ADDRESS,
    iiBroadcastAddress: SOCKET_ADDRESS,
    iiNetmask: SOCKET_ADDRESS,
};

pub const PMTUD_STATE = enum(i32) {
    NOT_SET = 0,
    DO = 1,
    DONT = 2,
    PROBE = 3,
    MAX = 4,
};
pub const IP_PMTUDISC_NOT_SET = PMTUD_STATE.NOT_SET;
pub const IP_PMTUDISC_DO = PMTUD_STATE.DO;
pub const IP_PMTUDISC_DONT = PMTUD_STATE.DONT;
pub const IP_PMTUDISC_PROBE = PMTUD_STATE.PROBE;
pub const IP_PMTUDISC_MAX = PMTUD_STATE.MAX;

pub const SOCKADDR_IN6 = extern struct {
    sin6_family: u16,
    sin6_port: u16,
    sin6_flowinfo: u32,
    sin6_addr: IN6_ADDR,
    Anonymous: extern union {
        sin6_scope_id: u32,
        sin6_scope_struct: SCOPE_ID,
    },
};

pub const SOCKADDR_IN6_W2KSP1 = extern struct {
    sin6_family: i16,
    sin6_port: u16,
    sin6_flowinfo: u32,
    sin6_addr: IN6_ADDR,
    sin6_scope_id: u32,
};

pub const SOCKADDR_INET = extern union {
    Ipv4: SOCKADDR_IN,
    Ipv6: SOCKADDR_IN6,
    si_family: u16,
};

pub const SOCKADDR_IN6_PAIR = extern struct {
    SourceAddress: ?*SOCKADDR_IN6,
    DestinationAddress: ?*SOCKADDR_IN6,
};

pub const MULTICAST_MODE_TYPE = enum(i32) {
    INCLUDE = 0,
    EXCLUDE = 1,
};
pub const MCAST_INCLUDE = MULTICAST_MODE_TYPE.INCLUDE;
pub const MCAST_EXCLUDE = MULTICAST_MODE_TYPE.EXCLUDE;

pub const IP_MREQ = extern struct {
    imr_multiaddr: IN_ADDR,
    imr_interface: IN_ADDR,
};

pub const IP_MREQ_SOURCE = extern struct {
    imr_multiaddr: IN_ADDR,
    imr_sourceaddr: IN_ADDR,
    imr_interface: IN_ADDR,
};

pub const IP_MSFILTER = extern struct {
    imsf_multiaddr: IN_ADDR,
    imsf_interface: IN_ADDR,
    imsf_fmode: MULTICAST_MODE_TYPE,
    imsf_numsrc: u32,
    imsf_slist: [1]IN_ADDR,
};

pub const IPV6_MREQ = extern struct {
    ipv6mr_multiaddr: IN6_ADDR,
    ipv6mr_interface: u32,
};

pub const GROUP_REQ = extern struct {
    gr_interface: u32,
    gr_group: SOCKADDR_STORAGE,
};

pub const GROUP_SOURCE_REQ = extern struct {
    gsr_interface: u32,
    gsr_group: SOCKADDR_STORAGE,
    gsr_source: SOCKADDR_STORAGE,
};

pub const GROUP_FILTER = extern struct {
    gf_interface: u32,
    gf_group: SOCKADDR_STORAGE,
    gf_fmode: MULTICAST_MODE_TYPE,
    gf_numsrc: u32,
    gf_slist: [1]SOCKADDR_STORAGE,
};

pub const IN_PKTINFO = extern struct {
    ipi_addr: IN_ADDR,
    ipi_ifindex: u32,
};

pub const IN6_PKTINFO = extern struct {
    ipi6_addr: IN6_ADDR,
    ipi6_ifindex: u32,
};

pub const IN_PKTINFO_EX = extern struct {
    pkt_info: IN_PKTINFO,
    scope_id: SCOPE_ID,
};

pub const in6_pktinfo_ex = extern struct {
    pkt_info: IN6_PKTINFO,
    scope_id: SCOPE_ID,
};

pub const IN_RECVERR = extern struct {
    protocol: IPPROTO,
    info: u32,
    type: u8,
    code: u8,
};

pub const ICMP_ERROR_INFO = extern struct {
    srcaddress: SOCKADDR_INET,
    protocol: IPPROTO,
    type: u8,
    code: u8,
};

pub const eWINDOW_ADVANCE_METHOD = enum(i32) {
    ADVANCE_BY_TIME = 1,
    USE_AS_DATA_CACHE = 2,
};
pub const E_WINDOW_ADVANCE_BY_TIME = eWINDOW_ADVANCE_METHOD.ADVANCE_BY_TIME;
pub const E_WINDOW_USE_AS_DATA_CACHE = eWINDOW_ADVANCE_METHOD.USE_AS_DATA_CACHE;

pub const RM_SEND_WINDOW = extern struct {
    RateKbitsPerSec: u32,
    WindowSizeInMSecs: u32,
    WindowSizeInBytes: u32,
};

pub const RM_SENDER_STATS = extern struct {
    DataBytesSent: u64,
    TotalBytesSent: u64,
    NaksReceived: u64,
    NaksReceivedTooLate: u64,
    NumOutstandingNaks: u64,
    NumNaksAfterRData: u64,
    RepairPacketsSent: u64,
    BufferSpaceAvailable: u64,
    TrailingEdgeSeqId: u64,
    LeadingEdgeSeqId: u64,
    RateKBitsPerSecOverall: u64,
    RateKBitsPerSecLast: u64,
    TotalODataPacketsSent: u64,
};

pub const RM_RECEIVER_STATS = extern struct {
    NumODataPacketsReceived: u64,
    NumRDataPacketsReceived: u64,
    NumDuplicateDataPackets: u64,
    DataBytesReceived: u64,
    TotalBytesReceived: u64,
    RateKBitsPerSecOverall: u64,
    RateKBitsPerSecLast: u64,
    TrailingEdgeSeqId: u64,
    LeadingEdgeSeqId: u64,
    AverageSequencesInWindow: u64,
    MinSequencesInWindow: u64,
    MaxSequencesInWindow: u64,
    FirstNakSequenceNumber: u64,
    NumPendingNaks: u64,
    NumOutstandingNaks: u64,
    NumDataPacketsBuffered: u64,
    TotalSelectiveNaksSent: u64,
    TotalParityNaksSent: u64,
};

pub const RM_FEC_INFO = extern struct {
    FECBlockSize: u16,
    FECProActivePackets: u16,
    FECGroupSize: u8,
    fFECOnDemandParityEnabled: BOOLEAN,
};

pub const IPX_ADDRESS_DATA = extern struct {
    adapternum: i32,
    netnum: [4]u8,
    nodenum: [6]u8,
    wan: BOOLEAN,
    status: BOOLEAN,
    maxpkt: i32,
    linkspeed: u32,
};

pub const IPX_NETNUM_DATA = extern struct {
    netnum: [4]u8,
    hopcount: u16,
    netdelay: u16,
    cardnum: i32,
    router: [6]u8,
};

pub const IPX_SPXCONNSTATUS_DATA = extern struct {
    ConnectionState: u8,
    WatchDogActive: u8,
    LocalConnectionId: u16,
    RemoteConnectionId: u16,
    LocalSequenceNumber: u16,
    LocalAckNumber: u16,
    LocalAllocNumber: u16,
    RemoteAckNumber: u16,
    RemoteAllocNumber: u16,
    LocalSocket: u16,
    ImmediateAddress: [6]u8,
    RemoteNetwork: [4]u8,
    RemoteNode: [6]u8,
    RemoteSocket: u16,
    RetransmissionCount: u16,
    EstimatedRoundTripDelay: u16,
    RetransmittedPackets: u16,
    SuppressedPacket: u16,
};

pub const LM_IRPARMS = extern struct {
    nTXDataBytes: u32,
    nRXDataBytes: u32,
    nBaudRate: u32,
    thresholdTime: u32,
    discTime: u32,
    nMSLinkTurn: u16,
    nTXPackets: u8,
    nRXPackets: u8,
};

pub const SOCKADDR_IRDA = extern struct {
    irdaAddressFamily: u16,
    irdaDeviceID: [4]u8,
    irdaServiceName: [25]CHAR,
};

pub const WINDOWS_IRDA_DEVICE_INFO = extern struct {
    irdaDeviceID: [4]u8,
    irdaDeviceName: [22]CHAR,
    irdaDeviceHints1: u8,
    irdaDeviceHints2: u8,
    irdaCharSet: u8,
};

pub const WCE_IRDA_DEVICE_INFO = extern struct {
    irdaDeviceID: [4]u8,
    irdaDeviceName: [22]CHAR,
    Reserved: [2]u8,
};

pub const WINDOWS_DEVICELIST = extern struct {
    numDevice: u32,
    Device: [1]WINDOWS_IRDA_DEVICE_INFO,
};

pub const WCE_DEVICELIST = extern struct {
    numDevice: u32,
    Device: [1]WCE_IRDA_DEVICE_INFO,
};

pub const WINDOWS_IAS_SET = extern struct {
    irdaClassName: [64]CHAR,
    irdaAttribName: [256]CHAR,
    irdaAttribType: u32,
    irdaAttribute: extern union {
        irdaAttribInt: i32,
        irdaAttribOctetSeq: extern struct {
            Len: u16,
            OctetSeq: [1024]u8,
        },
        irdaAttribUsrStr: extern struct {
            Len: u8,
            CharSet: u8,
            UsrStr: [256]u8,
        },
    },
};

pub const WINDOWS_IAS_QUERY = extern struct {
    irdaDeviceID: [4]u8,
    irdaClassName: [64]CHAR,
    irdaAttribName: [256]CHAR,
    irdaAttribType: u32,
    irdaAttribute: extern union {
        irdaAttribInt: i32,
        irdaAttribOctetSeq: extern struct {
            Len: u32,
            OctetSeq: [1024]u8,
        },
        irdaAttribUsrStr: extern struct {
            Len: u32,
            CharSet: u32,
            UsrStr: [256]u8,
        },
    },
};

pub const NL_PREFIX_ORIGIN = enum(i32) {
    Other = 0,
    Manual = 1,
    WellKnown = 2,
    Dhcp = 3,
    RouterAdvertisement = 4,
    Unchanged = 16,
};
pub const IpPrefixOriginOther = NL_PREFIX_ORIGIN.Other;
pub const IpPrefixOriginManual = NL_PREFIX_ORIGIN.Manual;
pub const IpPrefixOriginWellKnown = NL_PREFIX_ORIGIN.WellKnown;
pub const IpPrefixOriginDhcp = NL_PREFIX_ORIGIN.Dhcp;
pub const IpPrefixOriginRouterAdvertisement = NL_PREFIX_ORIGIN.RouterAdvertisement;
pub const IpPrefixOriginUnchanged = NL_PREFIX_ORIGIN.Unchanged;

pub const NL_SUFFIX_ORIGIN = enum(i32) {
    NlsoOther = 0,
    NlsoManual = 1,
    NlsoWellKnown = 2,
    NlsoDhcp = 3,
    NlsoLinkLayerAddress = 4,
    NlsoRandom = 5,
    // IpSuffixOriginOther = 0, this enum value conflicts with NlsoOther
    // IpSuffixOriginManual = 1, this enum value conflicts with NlsoManual
    // IpSuffixOriginWellKnown = 2, this enum value conflicts with NlsoWellKnown
    // IpSuffixOriginDhcp = 3, this enum value conflicts with NlsoDhcp
    // IpSuffixOriginLinkLayerAddress = 4, this enum value conflicts with NlsoLinkLayerAddress
    // IpSuffixOriginRandom = 5, this enum value conflicts with NlsoRandom
    IpSuffixOriginUnchanged = 16,
};
pub const NlsoOther = NL_SUFFIX_ORIGIN.NlsoOther;
pub const NlsoManual = NL_SUFFIX_ORIGIN.NlsoManual;
pub const NlsoWellKnown = NL_SUFFIX_ORIGIN.NlsoWellKnown;
pub const NlsoDhcp = NL_SUFFIX_ORIGIN.NlsoDhcp;
pub const NlsoLinkLayerAddress = NL_SUFFIX_ORIGIN.NlsoLinkLayerAddress;
pub const NlsoRandom = NL_SUFFIX_ORIGIN.NlsoRandom;
pub const IpSuffixOriginOther = NL_SUFFIX_ORIGIN.NlsoOther;
pub const IpSuffixOriginManual = NL_SUFFIX_ORIGIN.NlsoManual;
pub const IpSuffixOriginWellKnown = NL_SUFFIX_ORIGIN.NlsoWellKnown;
pub const IpSuffixOriginDhcp = NL_SUFFIX_ORIGIN.NlsoDhcp;
pub const IpSuffixOriginLinkLayerAddress = NL_SUFFIX_ORIGIN.NlsoLinkLayerAddress;
pub const IpSuffixOriginRandom = NL_SUFFIX_ORIGIN.NlsoRandom;
pub const IpSuffixOriginUnchanged = NL_SUFFIX_ORIGIN.IpSuffixOriginUnchanged;

pub const NL_DAD_STATE = enum(i32) {
    NldsInvalid = 0,
    NldsTentative = 1,
    NldsDuplicate = 2,
    NldsDeprecated = 3,
    NldsPreferred = 4,
    // IpDadStateInvalid = 0, this enum value conflicts with NldsInvalid
    // IpDadStateTentative = 1, this enum value conflicts with NldsTentative
    // IpDadStateDuplicate = 2, this enum value conflicts with NldsDuplicate
    // IpDadStateDeprecated = 3, this enum value conflicts with NldsDeprecated
    // IpDadStatePreferred = 4, this enum value conflicts with NldsPreferred
};
pub const NldsInvalid = NL_DAD_STATE.NldsInvalid;
pub const NldsTentative = NL_DAD_STATE.NldsTentative;
pub const NldsDuplicate = NL_DAD_STATE.NldsDuplicate;
pub const NldsDeprecated = NL_DAD_STATE.NldsDeprecated;
pub const NldsPreferred = NL_DAD_STATE.NldsPreferred;
pub const IpDadStateInvalid = NL_DAD_STATE.NldsInvalid;
pub const IpDadStateTentative = NL_DAD_STATE.NldsTentative;
pub const IpDadStateDuplicate = NL_DAD_STATE.NldsDuplicate;
pub const IpDadStateDeprecated = NL_DAD_STATE.NldsDeprecated;
pub const IpDadStatePreferred = NL_DAD_STATE.NldsPreferred;

pub const NL_ROUTE_PROTOCOL = enum(i32) {
    RouteProtocolOther = 1,
    RouteProtocolLocal = 2,
    RouteProtocolNetMgmt = 3,
    RouteProtocolIcmp = 4,
    RouteProtocolEgp = 5,
    RouteProtocolGgp = 6,
    RouteProtocolHello = 7,
    RouteProtocolRip = 8,
    RouteProtocolIsIs = 9,
    RouteProtocolEsIs = 10,
    RouteProtocolCisco = 11,
    RouteProtocolBbn = 12,
    RouteProtocolOspf = 13,
    RouteProtocolBgp = 14,
    RouteProtocolIdpr = 15,
    RouteProtocolEigrp = 16,
    RouteProtocolDvmrp = 17,
    RouteProtocolRpl = 18,
    RouteProtocolDhcp = 19,
    // MIB_IPPROTO_OTHER = 1, this enum value conflicts with RouteProtocolOther
    // PROTO_IP_OTHER = 1, this enum value conflicts with RouteProtocolOther
    // MIB_IPPROTO_LOCAL = 2, this enum value conflicts with RouteProtocolLocal
    // PROTO_IP_LOCAL = 2, this enum value conflicts with RouteProtocolLocal
    // MIB_IPPROTO_NETMGMT = 3, this enum value conflicts with RouteProtocolNetMgmt
    // PROTO_IP_NETMGMT = 3, this enum value conflicts with RouteProtocolNetMgmt
    // MIB_IPPROTO_ICMP = 4, this enum value conflicts with RouteProtocolIcmp
    // PROTO_IP_ICMP = 4, this enum value conflicts with RouteProtocolIcmp
    // MIB_IPPROTO_EGP = 5, this enum value conflicts with RouteProtocolEgp
    // PROTO_IP_EGP = 5, this enum value conflicts with RouteProtocolEgp
    // MIB_IPPROTO_GGP = 6, this enum value conflicts with RouteProtocolGgp
    // PROTO_IP_GGP = 6, this enum value conflicts with RouteProtocolGgp
    // MIB_IPPROTO_HELLO = 7, this enum value conflicts with RouteProtocolHello
    // PROTO_IP_HELLO = 7, this enum value conflicts with RouteProtocolHello
    // MIB_IPPROTO_RIP = 8, this enum value conflicts with RouteProtocolRip
    // PROTO_IP_RIP = 8, this enum value conflicts with RouteProtocolRip
    // MIB_IPPROTO_IS_IS = 9, this enum value conflicts with RouteProtocolIsIs
    // PROTO_IP_IS_IS = 9, this enum value conflicts with RouteProtocolIsIs
    // MIB_IPPROTO_ES_IS = 10, this enum value conflicts with RouteProtocolEsIs
    // PROTO_IP_ES_IS = 10, this enum value conflicts with RouteProtocolEsIs
    // MIB_IPPROTO_CISCO = 11, this enum value conflicts with RouteProtocolCisco
    // PROTO_IP_CISCO = 11, this enum value conflicts with RouteProtocolCisco
    // MIB_IPPROTO_BBN = 12, this enum value conflicts with RouteProtocolBbn
    // PROTO_IP_BBN = 12, this enum value conflicts with RouteProtocolBbn
    // MIB_IPPROTO_OSPF = 13, this enum value conflicts with RouteProtocolOspf
    // PROTO_IP_OSPF = 13, this enum value conflicts with RouteProtocolOspf
    // MIB_IPPROTO_BGP = 14, this enum value conflicts with RouteProtocolBgp
    // PROTO_IP_BGP = 14, this enum value conflicts with RouteProtocolBgp
    // MIB_IPPROTO_IDPR = 15, this enum value conflicts with RouteProtocolIdpr
    // PROTO_IP_IDPR = 15, this enum value conflicts with RouteProtocolIdpr
    // MIB_IPPROTO_EIGRP = 16, this enum value conflicts with RouteProtocolEigrp
    // PROTO_IP_EIGRP = 16, this enum value conflicts with RouteProtocolEigrp
    // MIB_IPPROTO_DVMRP = 17, this enum value conflicts with RouteProtocolDvmrp
    // PROTO_IP_DVMRP = 17, this enum value conflicts with RouteProtocolDvmrp
    // MIB_IPPROTO_RPL = 18, this enum value conflicts with RouteProtocolRpl
    // PROTO_IP_RPL = 18, this enum value conflicts with RouteProtocolRpl
    // MIB_IPPROTO_DHCP = 19, this enum value conflicts with RouteProtocolDhcp
    // PROTO_IP_DHCP = 19, this enum value conflicts with RouteProtocolDhcp
    MIB_IPPROTO_NT_AUTOSTATIC = 10002,
    // PROTO_IP_NT_AUTOSTATIC = 10002, this enum value conflicts with MIB_IPPROTO_NT_AUTOSTATIC
    MIB_IPPROTO_NT_STATIC = 10006,
    // PROTO_IP_NT_STATIC = 10006, this enum value conflicts with MIB_IPPROTO_NT_STATIC
    MIB_IPPROTO_NT_STATIC_NON_DOD = 10007,
    // PROTO_IP_NT_STATIC_NON_DOD = 10007, this enum value conflicts with MIB_IPPROTO_NT_STATIC_NON_DOD
};
pub const RouteProtocolOther = NL_ROUTE_PROTOCOL.RouteProtocolOther;
pub const RouteProtocolLocal = NL_ROUTE_PROTOCOL.RouteProtocolLocal;
pub const RouteProtocolNetMgmt = NL_ROUTE_PROTOCOL.RouteProtocolNetMgmt;
pub const RouteProtocolIcmp = NL_ROUTE_PROTOCOL.RouteProtocolIcmp;
pub const RouteProtocolEgp = NL_ROUTE_PROTOCOL.RouteProtocolEgp;
pub const RouteProtocolGgp = NL_ROUTE_PROTOCOL.RouteProtocolGgp;
pub const RouteProtocolHello = NL_ROUTE_PROTOCOL.RouteProtocolHello;
pub const RouteProtocolRip = NL_ROUTE_PROTOCOL.RouteProtocolRip;
pub const RouteProtocolIsIs = NL_ROUTE_PROTOCOL.RouteProtocolIsIs;
pub const RouteProtocolEsIs = NL_ROUTE_PROTOCOL.RouteProtocolEsIs;
pub const RouteProtocolCisco = NL_ROUTE_PROTOCOL.RouteProtocolCisco;
pub const RouteProtocolBbn = NL_ROUTE_PROTOCOL.RouteProtocolBbn;
pub const RouteProtocolOspf = NL_ROUTE_PROTOCOL.RouteProtocolOspf;
pub const RouteProtocolBgp = NL_ROUTE_PROTOCOL.RouteProtocolBgp;
pub const RouteProtocolIdpr = NL_ROUTE_PROTOCOL.RouteProtocolIdpr;
pub const RouteProtocolEigrp = NL_ROUTE_PROTOCOL.RouteProtocolEigrp;
pub const RouteProtocolDvmrp = NL_ROUTE_PROTOCOL.RouteProtocolDvmrp;
pub const RouteProtocolRpl = NL_ROUTE_PROTOCOL.RouteProtocolRpl;
pub const RouteProtocolDhcp = NL_ROUTE_PROTOCOL.RouteProtocolDhcp;
pub const MIB_IPPROTO_OTHER = NL_ROUTE_PROTOCOL.RouteProtocolOther;
pub const PROTO_IP_OTHER = NL_ROUTE_PROTOCOL.RouteProtocolOther;
pub const MIB_IPPROTO_LOCAL = NL_ROUTE_PROTOCOL.RouteProtocolLocal;
pub const PROTO_IP_LOCAL = NL_ROUTE_PROTOCOL.RouteProtocolLocal;
pub const MIB_IPPROTO_NETMGMT = NL_ROUTE_PROTOCOL.RouteProtocolNetMgmt;
pub const PROTO_IP_NETMGMT = NL_ROUTE_PROTOCOL.RouteProtocolNetMgmt;
pub const MIB_IPPROTO_ICMP = NL_ROUTE_PROTOCOL.RouteProtocolIcmp;
pub const PROTO_IP_ICMP = NL_ROUTE_PROTOCOL.RouteProtocolIcmp;
pub const MIB_IPPROTO_EGP = NL_ROUTE_PROTOCOL.RouteProtocolEgp;
pub const PROTO_IP_EGP = NL_ROUTE_PROTOCOL.RouteProtocolEgp;
pub const MIB_IPPROTO_GGP = NL_ROUTE_PROTOCOL.RouteProtocolGgp;
pub const PROTO_IP_GGP = NL_ROUTE_PROTOCOL.RouteProtocolGgp;
pub const MIB_IPPROTO_HELLO = NL_ROUTE_PROTOCOL.RouteProtocolHello;
pub const PROTO_IP_HELLO = NL_ROUTE_PROTOCOL.RouteProtocolHello;
pub const MIB_IPPROTO_RIP = NL_ROUTE_PROTOCOL.RouteProtocolRip;
pub const PROTO_IP_RIP = NL_ROUTE_PROTOCOL.RouteProtocolRip;
pub const MIB_IPPROTO_IS_IS = NL_ROUTE_PROTOCOL.RouteProtocolIsIs;
pub const PROTO_IP_IS_IS = NL_ROUTE_PROTOCOL.RouteProtocolIsIs;
pub const MIB_IPPROTO_ES_IS = NL_ROUTE_PROTOCOL.RouteProtocolEsIs;
pub const PROTO_IP_ES_IS = NL_ROUTE_PROTOCOL.RouteProtocolEsIs;
pub const MIB_IPPROTO_CISCO = NL_ROUTE_PROTOCOL.RouteProtocolCisco;
pub const PROTO_IP_CISCO = NL_ROUTE_PROTOCOL.RouteProtocolCisco;
pub const MIB_IPPROTO_BBN = NL_ROUTE_PROTOCOL.RouteProtocolBbn;
pub const PROTO_IP_BBN = NL_ROUTE_PROTOCOL.RouteProtocolBbn;
pub const MIB_IPPROTO_OSPF = NL_ROUTE_PROTOCOL.RouteProtocolOspf;
pub const PROTO_IP_OSPF = NL_ROUTE_PROTOCOL.RouteProtocolOspf;
pub const MIB_IPPROTO_BGP = NL_ROUTE_PROTOCOL.RouteProtocolBgp;
pub const PROTO_IP_BGP = NL_ROUTE_PROTOCOL.RouteProtocolBgp;
pub const MIB_IPPROTO_IDPR = NL_ROUTE_PROTOCOL.RouteProtocolIdpr;
pub const PROTO_IP_IDPR = NL_ROUTE_PROTOCOL.RouteProtocolIdpr;
pub const MIB_IPPROTO_EIGRP = NL_ROUTE_PROTOCOL.RouteProtocolEigrp;
pub const PROTO_IP_EIGRP = NL_ROUTE_PROTOCOL.RouteProtocolEigrp;
pub const MIB_IPPROTO_DVMRP = NL_ROUTE_PROTOCOL.RouteProtocolDvmrp;
pub const PROTO_IP_DVMRP = NL_ROUTE_PROTOCOL.RouteProtocolDvmrp;
pub const MIB_IPPROTO_RPL = NL_ROUTE_PROTOCOL.RouteProtocolRpl;
pub const PROTO_IP_RPL = NL_ROUTE_PROTOCOL.RouteProtocolRpl;
pub const MIB_IPPROTO_DHCP = NL_ROUTE_PROTOCOL.RouteProtocolDhcp;
pub const PROTO_IP_DHCP = NL_ROUTE_PROTOCOL.RouteProtocolDhcp;
pub const MIB_IPPROTO_NT_AUTOSTATIC = NL_ROUTE_PROTOCOL.MIB_IPPROTO_NT_AUTOSTATIC;
pub const PROTO_IP_NT_AUTOSTATIC = NL_ROUTE_PROTOCOL.MIB_IPPROTO_NT_AUTOSTATIC;
pub const MIB_IPPROTO_NT_STATIC = NL_ROUTE_PROTOCOL.MIB_IPPROTO_NT_STATIC;
pub const PROTO_IP_NT_STATIC = NL_ROUTE_PROTOCOL.MIB_IPPROTO_NT_STATIC;
pub const MIB_IPPROTO_NT_STATIC_NON_DOD = NL_ROUTE_PROTOCOL.MIB_IPPROTO_NT_STATIC_NON_DOD;
pub const PROTO_IP_NT_STATIC_NON_DOD = NL_ROUTE_PROTOCOL.MIB_IPPROTO_NT_STATIC_NON_DOD;

pub const NL_ADDRESS_TYPE = enum(i32) {
    Unspecified = 0,
    Unicast = 1,
    Anycast = 2,
    Multicast = 3,
    Broadcast = 4,
    Invalid = 5,
};
pub const NlatUnspecified = NL_ADDRESS_TYPE.Unspecified;
pub const NlatUnicast = NL_ADDRESS_TYPE.Unicast;
pub const NlatAnycast = NL_ADDRESS_TYPE.Anycast;
pub const NlatMulticast = NL_ADDRESS_TYPE.Multicast;
pub const NlatBroadcast = NL_ADDRESS_TYPE.Broadcast;
pub const NlatInvalid = NL_ADDRESS_TYPE.Invalid;

pub const NL_ROUTE_ORIGIN = enum(i32) {
    Manual = 0,
    WellKnown = 1,
    DHCP = 2,
    RouterAdvertisement = 3,
    @"6to4" = 4,
};
pub const NlroManual = NL_ROUTE_ORIGIN.Manual;
pub const NlroWellKnown = NL_ROUTE_ORIGIN.WellKnown;
pub const NlroDHCP = NL_ROUTE_ORIGIN.DHCP;
pub const NlroRouterAdvertisement = NL_ROUTE_ORIGIN.RouterAdvertisement;
pub const Nlro6to4 = NL_ROUTE_ORIGIN.@"6to4";

pub const NL_NEIGHBOR_STATE = enum(i32) {
    Unreachable = 0,
    Incomplete = 1,
    Probe = 2,
    Delay = 3,
    Stale = 4,
    Reachable = 5,
    Permanent = 6,
    Maximum = 7,
};
pub const NlnsUnreachable = NL_NEIGHBOR_STATE.Unreachable;
pub const NlnsIncomplete = NL_NEIGHBOR_STATE.Incomplete;
pub const NlnsProbe = NL_NEIGHBOR_STATE.Probe;
pub const NlnsDelay = NL_NEIGHBOR_STATE.Delay;
pub const NlnsStale = NL_NEIGHBOR_STATE.Stale;
pub const NlnsReachable = NL_NEIGHBOR_STATE.Reachable;
pub const NlnsPermanent = NL_NEIGHBOR_STATE.Permanent;
pub const NlnsMaximum = NL_NEIGHBOR_STATE.Maximum;

pub const NL_LINK_LOCAL_ADDRESS_BEHAVIOR = enum(i32) {
    AlwaysOff = 0,
    Delayed = 1,
    AlwaysOn = 2,
    Unchanged = -1,
};
pub const LinkLocalAlwaysOff = NL_LINK_LOCAL_ADDRESS_BEHAVIOR.AlwaysOff;
pub const LinkLocalDelayed = NL_LINK_LOCAL_ADDRESS_BEHAVIOR.Delayed;
pub const LinkLocalAlwaysOn = NL_LINK_LOCAL_ADDRESS_BEHAVIOR.AlwaysOn;
pub const LinkLocalUnchanged = NL_LINK_LOCAL_ADDRESS_BEHAVIOR.Unchanged;

pub const NL_INTERFACE_OFFLOAD_ROD = extern struct {
    _bitfield: u8,
};

pub const NL_ROUTER_DISCOVERY_BEHAVIOR = enum(i32) {
    Disabled = 0,
    Enabled = 1,
    Dhcp = 2,
    Unchanged = -1,
};
pub const RouterDiscoveryDisabled = NL_ROUTER_DISCOVERY_BEHAVIOR.Disabled;
pub const RouterDiscoveryEnabled = NL_ROUTER_DISCOVERY_BEHAVIOR.Enabled;
pub const RouterDiscoveryDhcp = NL_ROUTER_DISCOVERY_BEHAVIOR.Dhcp;
pub const RouterDiscoveryUnchanged = NL_ROUTER_DISCOVERY_BEHAVIOR.Unchanged;

pub const NL_BANDWIDTH_FLAG = enum(i32) {
    Disabled = 0,
    Enabled = 1,
    Unchanged = -1,
};
pub const NlbwDisabled = NL_BANDWIDTH_FLAG.Disabled;
pub const NlbwEnabled = NL_BANDWIDTH_FLAG.Enabled;
pub const NlbwUnchanged = NL_BANDWIDTH_FLAG.Unchanged;

pub const NL_PATH_BANDWIDTH_ROD = extern struct {
    Bandwidth: u64,
    Instability: u64,
    BandwidthPeaked: BOOLEAN,
};

pub const NL_NETWORK_CATEGORY = enum(i32) {
    Public = 0,
    Private = 1,
    DomainAuthenticated = 2,
    Unchanged = -1,
    // Unknown = -1, this enum value conflicts with Unchanged
};
pub const NetworkCategoryPublic = NL_NETWORK_CATEGORY.Public;
pub const NetworkCategoryPrivate = NL_NETWORK_CATEGORY.Private;
pub const NetworkCategoryDomainAuthenticated = NL_NETWORK_CATEGORY.DomainAuthenticated;
pub const NetworkCategoryUnchanged = NL_NETWORK_CATEGORY.Unchanged;
pub const NetworkCategoryUnknown = NL_NETWORK_CATEGORY.Unchanged;

pub const NL_INTERFACE_NETWORK_CATEGORY_STATE = enum(i32) {
    CategoryUnknown = 0,
    Public = 1,
    Private = 2,
    DomainAuthenticated = 3,
    CategoryStateMax = 4,
};
pub const NlincCategoryUnknown = NL_INTERFACE_NETWORK_CATEGORY_STATE.CategoryUnknown;
pub const NlincPublic = NL_INTERFACE_NETWORK_CATEGORY_STATE.Public;
pub const NlincPrivate = NL_INTERFACE_NETWORK_CATEGORY_STATE.Private;
pub const NlincDomainAuthenticated = NL_INTERFACE_NETWORK_CATEGORY_STATE.DomainAuthenticated;
pub const NlincCategoryStateMax = NL_INTERFACE_NETWORK_CATEGORY_STATE.CategoryStateMax;

pub const NL_NETWORK_CONNECTIVITY_LEVEL_HINT = enum(i32) {
    Unknown = 0,
    None = 1,
    LocalAccess = 2,
    InternetAccess = 3,
    ConstrainedInternetAccess = 4,
    Hidden = 5,
};
pub const NetworkConnectivityLevelHintUnknown = NL_NETWORK_CONNECTIVITY_LEVEL_HINT.Unknown;
pub const NetworkConnectivityLevelHintNone = NL_NETWORK_CONNECTIVITY_LEVEL_HINT.None;
pub const NetworkConnectivityLevelHintLocalAccess = NL_NETWORK_CONNECTIVITY_LEVEL_HINT.LocalAccess;
pub const NetworkConnectivityLevelHintInternetAccess = NL_NETWORK_CONNECTIVITY_LEVEL_HINT.InternetAccess;
pub const NetworkConnectivityLevelHintConstrainedInternetAccess = NL_NETWORK_CONNECTIVITY_LEVEL_HINT.ConstrainedInternetAccess;
pub const NetworkConnectivityLevelHintHidden = NL_NETWORK_CONNECTIVITY_LEVEL_HINT.Hidden;

pub const NL_NETWORK_CONNECTIVITY_COST_HINT = enum(i32) {
    Unknown = 0,
    Unrestricted = 1,
    Fixed = 2,
    Variable = 3,
};
pub const NetworkConnectivityCostHintUnknown = NL_NETWORK_CONNECTIVITY_COST_HINT.Unknown;
pub const NetworkConnectivityCostHintUnrestricted = NL_NETWORK_CONNECTIVITY_COST_HINT.Unrestricted;
pub const NetworkConnectivityCostHintFixed = NL_NETWORK_CONNECTIVITY_COST_HINT.Fixed;
pub const NetworkConnectivityCostHintVariable = NL_NETWORK_CONNECTIVITY_COST_HINT.Variable;

pub const NL_NETWORK_CONNECTIVITY_HINT = extern struct {
    ConnectivityLevel: NL_NETWORK_CONNECTIVITY_LEVEL_HINT,
    ConnectivityCost: NL_NETWORK_CONNECTIVITY_COST_HINT,
    ApproachingDataLimit: BOOLEAN,
    OverDataLimit: BOOLEAN,
    Roaming: BOOLEAN,
};

pub const NL_BANDWIDTH_INFORMATION = extern struct {
    Bandwidth: u64,
    Instability: u64,
    BandwidthPeaked: BOOLEAN,
};

pub const TCPSTATE = enum(i32) {
    CLOSED = 0,
    LISTEN = 1,
    SYN_SENT = 2,
    SYN_RCVD = 3,
    ESTABLISHED = 4,
    FIN_WAIT_1 = 5,
    FIN_WAIT_2 = 6,
    CLOSE_WAIT = 7,
    CLOSING = 8,
    LAST_ACK = 9,
    TIME_WAIT = 10,
    MAX = 11,
};
pub const TCPSTATE_CLOSED = TCPSTATE.CLOSED;
pub const TCPSTATE_LISTEN = TCPSTATE.LISTEN;
pub const TCPSTATE_SYN_SENT = TCPSTATE.SYN_SENT;
pub const TCPSTATE_SYN_RCVD = TCPSTATE.SYN_RCVD;
pub const TCPSTATE_ESTABLISHED = TCPSTATE.ESTABLISHED;
pub const TCPSTATE_FIN_WAIT_1 = TCPSTATE.FIN_WAIT_1;
pub const TCPSTATE_FIN_WAIT_2 = TCPSTATE.FIN_WAIT_2;
pub const TCPSTATE_CLOSE_WAIT = TCPSTATE.CLOSE_WAIT;
pub const TCPSTATE_CLOSING = TCPSTATE.CLOSING;
pub const TCPSTATE_LAST_ACK = TCPSTATE.LAST_ACK;
pub const TCPSTATE_TIME_WAIT = TCPSTATE.TIME_WAIT;
pub const TCPSTATE_MAX = TCPSTATE.MAX;

pub const TRANSPORT_SETTING_ID = extern struct {
    Guid: Guid,
};

pub const tcp_keepalive = extern struct {
    onoff: u32,
    keepalivetime: u32,
    keepaliveinterval: u32,
};

pub const CONTROL_CHANNEL_TRIGGER_STATUS = enum(i32) {
    INVALID = 0,
    SOFTWARE_SLOT_ALLOCATED = 1,
    HARDWARE_SLOT_ALLOCATED = 2,
    POLICY_ERROR = 3,
    SYSTEM_ERROR = 4,
    TRANSPORT_DISCONNECTED = 5,
    SERVICE_UNAVAILABLE = 6,
};
pub const CONTROL_CHANNEL_TRIGGER_STATUS_INVALID = CONTROL_CHANNEL_TRIGGER_STATUS.INVALID;
pub const CONTROL_CHANNEL_TRIGGER_STATUS_SOFTWARE_SLOT_ALLOCATED = CONTROL_CHANNEL_TRIGGER_STATUS.SOFTWARE_SLOT_ALLOCATED;
pub const CONTROL_CHANNEL_TRIGGER_STATUS_HARDWARE_SLOT_ALLOCATED = CONTROL_CHANNEL_TRIGGER_STATUS.HARDWARE_SLOT_ALLOCATED;
pub const CONTROL_CHANNEL_TRIGGER_STATUS_POLICY_ERROR = CONTROL_CHANNEL_TRIGGER_STATUS.POLICY_ERROR;
pub const CONTROL_CHANNEL_TRIGGER_STATUS_SYSTEM_ERROR = CONTROL_CHANNEL_TRIGGER_STATUS.SYSTEM_ERROR;
pub const CONTROL_CHANNEL_TRIGGER_STATUS_TRANSPORT_DISCONNECTED = CONTROL_CHANNEL_TRIGGER_STATUS.TRANSPORT_DISCONNECTED;
pub const CONTROL_CHANNEL_TRIGGER_STATUS_SERVICE_UNAVAILABLE = CONTROL_CHANNEL_TRIGGER_STATUS.SERVICE_UNAVAILABLE;

pub const REAL_TIME_NOTIFICATION_SETTING_INPUT = extern struct {
    TransportSettingId: TRANSPORT_SETTING_ID,
    BrokerEventGuid: Guid,
};

pub const REAL_TIME_NOTIFICATION_SETTING_INPUT_EX = extern struct {
    TransportSettingId: TRANSPORT_SETTING_ID,
    BrokerEventGuid: Guid,
    Unmark: BOOLEAN,
};

pub const REAL_TIME_NOTIFICATION_SETTING_OUTPUT = extern struct {
    ChannelStatus: CONTROL_CHANNEL_TRIGGER_STATUS,
};

pub const ASSOCIATE_NAMERES_CONTEXT_INPUT = extern struct {
    TransportSettingId: TRANSPORT_SETTING_ID,
    Handle: u64,
};

pub const TIMESTAMPING_CONFIG = extern struct {
    Flags: u32,
    TxTimestampsBuffered: u16,
};

pub const SOCKET_PRIORITY_HINT = enum(i32) {
    PriorityHintVeryLow = 0,
    PriorityHintLow = 1,
    PriorityHintNormal = 2,
    MaximumPriorityHintType = 3,
};
pub const SocketPriorityHintVeryLow = SOCKET_PRIORITY_HINT.PriorityHintVeryLow;
pub const SocketPriorityHintLow = SOCKET_PRIORITY_HINT.PriorityHintLow;
pub const SocketPriorityHintNormal = SOCKET_PRIORITY_HINT.PriorityHintNormal;
pub const SocketMaximumPriorityHintType = SOCKET_PRIORITY_HINT.MaximumPriorityHintType;

pub const PRIORITY_STATUS = extern struct {
    Sender: SOCKET_PRIORITY_HINT,
    Receiver: SOCKET_PRIORITY_HINT,
};

pub const RCVALL_VALUE = enum(i32) {
    OFF = 0,
    ON = 1,
    SOCKETLEVELONLY = 2,
    IPLEVEL = 3,
};
pub const RCVALL_OFF = RCVALL_VALUE.OFF;
pub const RCVALL_ON = RCVALL_VALUE.ON;
pub const RCVALL_SOCKETLEVELONLY = RCVALL_VALUE.SOCKETLEVELONLY;
pub const RCVALL_IPLEVEL = RCVALL_VALUE.IPLEVEL;

pub const RCVALL_IF = extern struct {
    Mode: RCVALL_VALUE,
    Interface: u32,
};

pub const TCP_INITIAL_RTO_PARAMETERS = extern struct {
    Rtt: u16,
    MaxSynRetransmissions: u8,
};

pub const TCP_ICW_LEVEL = enum(i32) {
    DEFAULT = 0,
    HIGH = 1,
    VERY_HIGH = 2,
    AGGRESSIVE = 3,
    EXPERIMENTAL = 4,
    COMPAT = 254,
    MAX = 255,
};
pub const TCP_ICW_LEVEL_DEFAULT = TCP_ICW_LEVEL.DEFAULT;
pub const TCP_ICW_LEVEL_HIGH = TCP_ICW_LEVEL.HIGH;
pub const TCP_ICW_LEVEL_VERY_HIGH = TCP_ICW_LEVEL.VERY_HIGH;
pub const TCP_ICW_LEVEL_AGGRESSIVE = TCP_ICW_LEVEL.AGGRESSIVE;
pub const TCP_ICW_LEVEL_EXPERIMENTAL = TCP_ICW_LEVEL.EXPERIMENTAL;
pub const TCP_ICW_LEVEL_COMPAT = TCP_ICW_LEVEL.COMPAT;
pub const TCP_ICW_LEVEL_MAX = TCP_ICW_LEVEL.MAX;

pub const TCP_ICW_PARAMETERS = extern struct {
    Level: TCP_ICW_LEVEL,
};

pub const TCP_ACK_FREQUENCY_PARAMETERS = extern struct {
    TcpDelayedAckFrequency: u8,
};

pub const TCP_INFO_v0 = extern struct {
    State: TCPSTATE,
    Mss: u32,
    ConnectionTimeMs: u64,
    TimestampsEnabled: BOOLEAN,
    RttUs: u32,
    MinRttUs: u32,
    BytesInFlight: u32,
    Cwnd: u32,
    SndWnd: u32,
    RcvWnd: u32,
    RcvBuf: u32,
    BytesOut: u64,
    BytesIn: u64,
    BytesReordered: u32,
    BytesRetrans: u32,
    FastRetrans: u32,
    DupAcksIn: u32,
    TimeoutEpisodes: u32,
    SynRetrans: u8,
};

pub const TCP_INFO_v1 = extern struct {
    State: TCPSTATE,
    Mss: u32,
    ConnectionTimeMs: u64,
    TimestampsEnabled: BOOLEAN,
    RttUs: u32,
    MinRttUs: u32,
    BytesInFlight: u32,
    Cwnd: u32,
    SndWnd: u32,
    RcvWnd: u32,
    RcvBuf: u32,
    BytesOut: u64,
    BytesIn: u64,
    BytesReordered: u32,
    BytesRetrans: u32,
    FastRetrans: u32,
    DupAcksIn: u32,
    TimeoutEpisodes: u32,
    SynRetrans: u8,
    SndLimTransRwin: u32,
    SndLimTimeRwin: u32,
    SndLimBytesRwin: u64,
    SndLimTransCwnd: u32,
    SndLimTimeCwnd: u32,
    SndLimBytesCwnd: u64,
    SndLimTransSnd: u32,
    SndLimTimeSnd: u32,
    SndLimBytesSnd: u64,
};

pub const INET_PORT_RANGE = extern struct {
    StartPort: u16,
    NumberOfPorts: u16,
};

pub const INET_PORT_RESERVATION_TOKEN = extern struct {
    Token: u64,
};

pub const INET_PORT_RESERVATION_INSTANCE = extern struct {
    Reservation: INET_PORT_RANGE,
    Token: INET_PORT_RESERVATION_TOKEN,
};

pub const INET_PORT_RESERVATION_INFORMATION = extern struct {
    OwningPid: u32,
};

pub const SOCKET_USAGE_TYPE = enum(i32) {
    T = 1,
};
pub const SYSTEM_CRITICAL_SOCKET = SOCKET_USAGE_TYPE.T;

pub const SOCKET_SECURITY_PROTOCOL = enum(i32) {
    DEFAULT = 0,
    IPSEC = 1,
    IPSEC2 = 2,
    INVALID = 3,
};
pub const SOCKET_SECURITY_PROTOCOL_DEFAULT = SOCKET_SECURITY_PROTOCOL.DEFAULT;
pub const SOCKET_SECURITY_PROTOCOL_IPSEC = SOCKET_SECURITY_PROTOCOL.IPSEC;
pub const SOCKET_SECURITY_PROTOCOL_IPSEC2 = SOCKET_SECURITY_PROTOCOL.IPSEC2;
pub const SOCKET_SECURITY_PROTOCOL_INVALID = SOCKET_SECURITY_PROTOCOL.INVALID;

pub const SOCKET_SECURITY_SETTINGS = extern struct {
    SecurityProtocol: SOCKET_SECURITY_PROTOCOL,
    SecurityFlags: u32,
};

pub const SOCKET_SECURITY_SETTINGS_IPSEC = extern struct {
    SecurityProtocol: SOCKET_SECURITY_PROTOCOL,
    SecurityFlags: u32,
    IpsecFlags: u32,
    AuthipMMPolicyKey: Guid,
    AuthipQMPolicyKey: Guid,
    Reserved: Guid,
    Reserved2: u64,
    UserNameStringLen: u32,
    DomainNameStringLen: u32,
    PasswordStringLen: u32,
    AllStrings: [1]u16,
};

pub const SOCKET_PEER_TARGET_NAME = extern struct {
    SecurityProtocol: SOCKET_SECURITY_PROTOCOL,
    PeerAddress: SOCKADDR_STORAGE,
    PeerTargetNameStringLen: u32,
    AllStrings: [1]u16,
};

pub const SOCKET_SECURITY_QUERY_TEMPLATE = extern struct {
    SecurityProtocol: SOCKET_SECURITY_PROTOCOL,
    PeerAddress: SOCKADDR_STORAGE,
    PeerTokenAccessMask: u32,
};

pub const SOCKET_SECURITY_QUERY_TEMPLATE_IPSEC2 = extern struct {
    SecurityProtocol: SOCKET_SECURITY_PROTOCOL,
    PeerAddress: SOCKADDR_STORAGE,
    PeerTokenAccessMask: u32,
    Flags: u32,
    FieldMask: u32,
};

pub const SOCKET_SECURITY_QUERY_INFO = extern struct {
    SecurityProtocol: SOCKET_SECURITY_PROTOCOL,
    Flags: u32,
    PeerApplicationAccessTokenHandle: u64,
    PeerMachineAccessTokenHandle: u64,
};

pub const SOCKET_SECURITY_QUERY_INFO_IPSEC2 = extern struct {
    SecurityProtocol: SOCKET_SECURITY_PROTOCOL,
    Flags: u32,
    PeerApplicationAccessTokenHandle: u64,
    PeerMachineAccessTokenHandle: u64,
    MmSaId: u64,
    QmSaId: u64,
    NegotiationWinerr: u32,
    SaLookupContext: Guid,
};

pub const RSS_SCALABILITY_INFO = extern struct {
    RssEnabled: BOOLEAN,
};

pub const WSA_COMPATIBILITY_BEHAVIOR_ID = enum(i32) {
    All = 0,
    ReceiveBuffering = 1,
    AutoTuning = 2,
};
pub const WsaBehaviorAll = WSA_COMPATIBILITY_BEHAVIOR_ID.All;
pub const WsaBehaviorReceiveBuffering = WSA_COMPATIBILITY_BEHAVIOR_ID.ReceiveBuffering;
pub const WsaBehaviorAutoTuning = WSA_COMPATIBILITY_BEHAVIOR_ID.AutoTuning;

pub const WSA_COMPATIBILITY_MODE = extern struct {
    BehaviorId: WSA_COMPATIBILITY_BEHAVIOR_ID,
    TargetOsVersion: u32,
};

pub const RIORESULT = extern struct {
    Status: i32,
    BytesTransferred: u32,
    SocketContext: u64,
    RequestContext: u64,
};

pub const RIO_BUF = extern struct {
    BufferId: ?*RIO_BUFFERID_t,
    Offset: u32,
    Length: u32,
};

pub const RIO_CMSG_BUFFER = extern struct {
    TotalLength: u32,
};

pub const ATM_ADDRESS = extern struct {
    AddressType: u32,
    NumofDigits: u32,
    Addr: [20]u8,
};

pub const ATM_BLLI = extern struct {
    Layer2Protocol: u32,
    Layer2UserSpecifiedProtocol: u32,
    Layer3Protocol: u32,
    Layer3UserSpecifiedProtocol: u32,
    Layer3IPI: u32,
    SnapID: [5]u8,
};

pub const ATM_BHLI = extern struct {
    HighLayerInfoType: u32,
    HighLayerInfoLength: u32,
    HighLayerInfo: [8]u8,
};

pub const sockaddr_atm = extern struct {
    satm_family: u16,
    satm_number: ATM_ADDRESS,
    satm_blli: ATM_BLLI,
    satm_bhli: ATM_BHLI,
};

pub const Q2931_IE_TYPE = enum(i32) {
    AALParameters = 0,
    TrafficDescriptor = 1,
    BroadbandBearerCapability = 2,
    BHLI = 3,
    BLLI = 4,
    CalledPartyNumber = 5,
    CalledPartySubaddress = 6,
    CallingPartyNumber = 7,
    CallingPartySubaddress = 8,
    Cause = 9,
    QOSClass = 10,
    TransitNetworkSelection = 11,
};
pub const IE_AALParameters = Q2931_IE_TYPE.AALParameters;
pub const IE_TrafficDescriptor = Q2931_IE_TYPE.TrafficDescriptor;
pub const IE_BroadbandBearerCapability = Q2931_IE_TYPE.BroadbandBearerCapability;
pub const IE_BHLI = Q2931_IE_TYPE.BHLI;
pub const IE_BLLI = Q2931_IE_TYPE.BLLI;
pub const IE_CalledPartyNumber = Q2931_IE_TYPE.CalledPartyNumber;
pub const IE_CalledPartySubaddress = Q2931_IE_TYPE.CalledPartySubaddress;
pub const IE_CallingPartyNumber = Q2931_IE_TYPE.CallingPartyNumber;
pub const IE_CallingPartySubaddress = Q2931_IE_TYPE.CallingPartySubaddress;
pub const IE_Cause = Q2931_IE_TYPE.Cause;
pub const IE_QOSClass = Q2931_IE_TYPE.QOSClass;
pub const IE_TransitNetworkSelection = Q2931_IE_TYPE.TransitNetworkSelection;

pub const Q2931_IE = extern struct {
    IEType: Q2931_IE_TYPE,
    IELength: u32,
    IE: [1]u8,
};

pub const AAL_TYPE = enum(i32) {
    @"5" = 5,
    USER = 16,
};
pub const AALTYPE_5 = AAL_TYPE.@"5";
pub const AALTYPE_USER = AAL_TYPE.USER;

pub const AAL5_PARAMETERS = extern struct {
    ForwardMaxCPCSSDUSize: u32,
    BackwardMaxCPCSSDUSize: u32,
    Mode: u8,
    SSCSType: u8,
};

pub const AALUSER_PARAMETERS = extern struct {
    UserDefined: u32,
};

pub const AAL_PARAMETERS_IE = extern struct {
    AALType: AAL_TYPE,
    AALSpecificParameters: extern union {
        AAL5Parameters: AAL5_PARAMETERS,
        AALUserParameters: AALUSER_PARAMETERS,
    },
};

pub const ATM_TD = extern struct {
    PeakCellRate_CLP0: u32,
    PeakCellRate_CLP01: u32,
    SustainableCellRate_CLP0: u32,
    SustainableCellRate_CLP01: u32,
    MaxBurstSize_CLP0: u32,
    MaxBurstSize_CLP01: u32,
    Tagging: BOOL,
};

pub const ATM_TRAFFIC_DESCRIPTOR_IE = extern struct {
    Forward: ATM_TD,
    Backward: ATM_TD,
    BestEffort: BOOL,
};

pub const ATM_BROADBAND_BEARER_CAPABILITY_IE = extern struct {
    BearerClass: u8,
    TrafficType: u8,
    TimingRequirements: u8,
    ClippingSusceptability: u8,
    UserPlaneConnectionConfig: u8,
};

pub const ATM_BLLI_IE = extern struct {
    Layer2Protocol: u32,
    Layer2Mode: u8,
    Layer2WindowSize: u8,
    Layer2UserSpecifiedProtocol: u32,
    Layer3Protocol: u32,
    Layer3Mode: u8,
    Layer3DefaultPacketSize: u8,
    Layer3PacketWindowSize: u8,
    Layer3UserSpecifiedProtocol: u32,
    Layer3IPI: u32,
    SnapID: [5]u8,
};

pub const ATM_CALLING_PARTY_NUMBER_IE = extern struct {
    ATM_Number: ATM_ADDRESS,
    Presentation_Indication: u8,
    Screening_Indicator: u8,
};

pub const ATM_CAUSE_IE = extern struct {
    Location: u8,
    Cause: u8,
    DiagnosticsLength: u8,
    Diagnostics: [4]u8,
};

pub const ATM_QOS_CLASS_IE = extern struct {
    QOSClassForward: u8,
    QOSClassBackward: u8,
};

pub const ATM_TRANSIT_NETWORK_SELECTION_IE = extern struct {
    TypeOfNetworkId: u8,
    NetworkIdPlan: u8,
    NetworkIdLength: u8,
    NetworkId: [1]u8,
};

pub const ATM_CONNECTION_ID = extern struct {
    DeviceNumber: u32,
    VPI: u32,
    VCI: u32,
};

pub const ATM_PVC_PARAMS = extern struct {
    PvcConnectionId: ATM_CONNECTION_ID align(4),
    PvcQos: QOS align(4),
};

pub const NAPI_PROVIDER_TYPE = enum(i32) {
    Application = 1,
    Service = 2,
};
pub const ProviderType_Application = NAPI_PROVIDER_TYPE.Application;
pub const ProviderType_Service = NAPI_PROVIDER_TYPE.Service;

pub const NAPI_PROVIDER_LEVEL = enum(i32) {
    None = 0,
    Secondary = 1,
    Primary = 2,
};
pub const ProviderLevel_None = NAPI_PROVIDER_LEVEL.None;
pub const ProviderLevel_Secondary = NAPI_PROVIDER_LEVEL.Secondary;
pub const ProviderLevel_Primary = NAPI_PROVIDER_LEVEL.Primary;

pub const NAPI_DOMAIN_DESCRIPTION_BLOB = extern struct {
    AuthLevel: u32,
    cchDomainName: u32,
    OffsetNextDomainDescription: u32,
    OffsetThisDomainName: u32,
};

pub const NAPI_PROVIDER_INSTALLATION_BLOB = extern struct {
    dwVersion: u32,
    dwProviderType: u32,
    fSupportsWildCard: u32,
    cDomains: u32,
    OffsetFirstDomain: u32,
};

pub const TRANSMIT_FILE_BUFFERS = extern struct {
    Head: ?*anyopaque,
    HeadLength: u32,
    Tail: ?*anyopaque,
    TailLength: u32,
};

pub const LPFN_TRANSMITFILE = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        hSocket: ?SOCKET,
        hFile: ?HANDLE,
        nNumberOfBytesToWrite: u32,
        nNumberOfBytesPerSend: u32,
        lpOverlapped: ?*OVERLAPPED,
        lpTransmitBuffers: ?*TRANSMIT_FILE_BUFFERS,
        dwReserved: u32,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn(
        hSocket: ?SOCKET,
        hFile: ?HANDLE,
        nNumberOfBytesToWrite: u32,
        nNumberOfBytesPerSend: u32,
        lpOverlapped: ?*OVERLAPPED,
        lpTransmitBuffers: ?*TRANSMIT_FILE_BUFFERS,
        dwReserved: u32,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
} ;

pub const LPFN_ACCEPTEX = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        sListenSocket: ?SOCKET,
        sAcceptSocket: ?SOCKET,
        lpOutputBuffer: ?*anyopaque,
        dwReceiveDataLength: u32,
        dwLocalAddressLength: u32,
        dwRemoteAddressLength: u32,
        lpdwBytesReceived: ?*u32,
        lpOverlapped: ?*OVERLAPPED,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn(
        sListenSocket: ?SOCKET,
        sAcceptSocket: ?SOCKET,
        lpOutputBuffer: ?*anyopaque,
        dwReceiveDataLength: u32,
        dwLocalAddressLength: u32,
        dwRemoteAddressLength: u32,
        lpdwBytesReceived: ?*u32,
        lpOverlapped: ?*OVERLAPPED,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
} ;

pub const LPFN_GETACCEPTEXSOCKADDRS = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        lpOutputBuffer: ?*anyopaque,
        dwReceiveDataLength: u32,
        dwLocalAddressLength: u32,
        dwRemoteAddressLength: u32,
        LocalSockaddr: ?*?*SOCKADDR,
        LocalSockaddrLength: ?*i32,
        RemoteSockaddr: ?*?*SOCKADDR,
        RemoteSockaddrLength: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn(
        lpOutputBuffer: ?*anyopaque,
        dwReceiveDataLength: u32,
        dwLocalAddressLength: u32,
        dwRemoteAddressLength: u32,
        LocalSockaddr: ?*?*SOCKADDR,
        LocalSockaddrLength: ?*i32,
        RemoteSockaddr: ?*?*SOCKADDR,
        RemoteSockaddrLength: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) void,
} ;

pub const TRANSMIT_PACKETS_ELEMENT = extern struct {
    dwElFlags: u32,
    cLength: u32,
    Anonymous: extern union {
        Anonymous: extern struct {
            nFileOffset: LARGE_INTEGER,
            hFile: ?HANDLE,
        },
        pBuffer: ?*anyopaque,
    },
};

pub const LPFN_TRANSMITPACKETS = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        hSocket: ?SOCKET,
        lpPacketArray: ?*TRANSMIT_PACKETS_ELEMENT,
        nElementCount: u32,
        nSendSize: u32,
        lpOverlapped: ?*OVERLAPPED,
        dwFlags: u32,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn(
        hSocket: ?SOCKET,
        lpPacketArray: ?*TRANSMIT_PACKETS_ELEMENT,
        nElementCount: u32,
        nSendSize: u32,
        lpOverlapped: ?*OVERLAPPED,
        dwFlags: u32,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
} ;

pub const LPFN_CONNECTEX = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        s: ?SOCKET,
        // TODO: what to do with BytesParamIndex 2?
        name: ?*const SOCKADDR,
        namelen: i32,
        // TODO: what to do with BytesParamIndex 4?
        lpSendBuffer: ?*anyopaque,
        dwSendDataLength: u32,
        lpdwBytesSent: ?*u32,
        lpOverlapped: ?*OVERLAPPED,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn(
        s: ?SOCKET,
        // TODO: what to do with BytesParamIndex 2?
        name: ?*const SOCKADDR,
        namelen: i32,
        // TODO: what to do with BytesParamIndex 4?
        lpSendBuffer: ?*anyopaque,
        dwSendDataLength: u32,
        lpdwBytesSent: ?*u32,
        lpOverlapped: ?*OVERLAPPED,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
} ;

pub const LPFN_DISCONNECTEX = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        s: ?SOCKET,
        lpOverlapped: ?*OVERLAPPED,
        dwFlags: u32,
        dwReserved: u32,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn(
        s: ?SOCKET,
        lpOverlapped: ?*OVERLAPPED,
        dwFlags: u32,
        dwReserved: u32,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
} ;

pub const NLA_BLOB_DATA_TYPE = enum(i32) {
    RAW_DATA = 0,
    INTERFACE = 1,
    @"802_1X_LOCATION" = 2,
    CONNECTIVITY = 3,
    ICS = 4,
};
pub const NLA_RAW_DATA = NLA_BLOB_DATA_TYPE.RAW_DATA;
pub const NLA_INTERFACE = NLA_BLOB_DATA_TYPE.INTERFACE;
pub const NLA_802_1X_LOCATION = NLA_BLOB_DATA_TYPE.@"802_1X_LOCATION";
pub const NLA_CONNECTIVITY = NLA_BLOB_DATA_TYPE.CONNECTIVITY;
pub const NLA_ICS = NLA_BLOB_DATA_TYPE.ICS;

pub const NLA_CONNECTIVITY_TYPE = enum(i32) {
    AD_HOC = 0,
    MANAGED = 1,
    UNMANAGED = 2,
    UNKNOWN = 3,
};
pub const NLA_NETWORK_AD_HOC = NLA_CONNECTIVITY_TYPE.AD_HOC;
pub const NLA_NETWORK_MANAGED = NLA_CONNECTIVITY_TYPE.MANAGED;
pub const NLA_NETWORK_UNMANAGED = NLA_CONNECTIVITY_TYPE.UNMANAGED;
pub const NLA_NETWORK_UNKNOWN = NLA_CONNECTIVITY_TYPE.UNKNOWN;

pub const NLA_INTERNET = enum(i32) {
    UNKNOWN = 0,
    NO = 1,
    YES = 2,
};
pub const NLA_INTERNET_UNKNOWN = NLA_INTERNET.UNKNOWN;
pub const NLA_INTERNET_NO = NLA_INTERNET.NO;
pub const NLA_INTERNET_YES = NLA_INTERNET.YES;

pub const NLA_BLOB = extern struct {
    header: extern struct {
        type: NLA_BLOB_DATA_TYPE,
        dwSize: u32,
        nextOffset: u32,
    },
    data: extern union {
        rawData: [1]CHAR,
        interfaceData: extern struct {
            dwType: u32,
            dwSpeed: u32,
            adapterName: [1]CHAR,
        },
        locationData: extern struct {
            information: [1]CHAR,
        },
        connectivity: extern struct {
            type: NLA_CONNECTIVITY_TYPE,
            internet: NLA_INTERNET,
        },
        ICS: extern struct {
            remote: extern struct {
                speed: u32,
                type: u32,
                state: u32,
                machineName: [256]u16,
                sharedAdapterName: [256]u16,
            },
        },
    },
};

pub const LPFN_WSARECVMSG = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        s: ?SOCKET,
        lpMsg: ?*WSAMSG,
        lpdwNumberOfBytesRecvd: ?*u32,
        lpOverlapped: ?*OVERLAPPED,
        lpCompletionRoutine: ?LPWSAOVERLAPPED_COMPLETION_ROUTINE,
    ) callconv(@import("std").os.windows.WINAPI) i32,
    else => *const fn(
        s: ?SOCKET,
        lpMsg: ?*WSAMSG,
        lpdwNumberOfBytesRecvd: ?*u32,
        lpOverlapped: ?*OVERLAPPED,
        lpCompletionRoutine: ?LPWSAOVERLAPPED_COMPLETION_ROUTINE,
    ) callconv(@import("std").os.windows.WINAPI) i32,
} ;

pub const WSAPOLLDATA = extern struct {
    result: i32,
    fds: u32,
    timeout: i32,
    fdArray: [1]WSAPOLLFD,
};

pub const WSASENDMSG = extern struct {
    lpMsg: ?*WSAMSG,
    dwFlags: u32,
    lpNumberOfBytesSent: ?*u32,
    lpOverlapped: ?*OVERLAPPED,
    lpCompletionRoutine: ?LPWSAOVERLAPPED_COMPLETION_ROUTINE,
};

pub const LPFN_WSASENDMSG = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        s: ?SOCKET,
        lpMsg: ?*WSAMSG,
        dwFlags: u32,
        lpNumberOfBytesSent: ?*u32,
        lpOverlapped: ?*OVERLAPPED,
        lpCompletionRoutine: ?LPWSAOVERLAPPED_COMPLETION_ROUTINE,
    ) callconv(@import("std").os.windows.WINAPI) i32,
    else => *const fn(
        s: ?SOCKET,
        lpMsg: ?*WSAMSG,
        dwFlags: u32,
        lpNumberOfBytesSent: ?*u32,
        lpOverlapped: ?*OVERLAPPED,
        lpCompletionRoutine: ?LPWSAOVERLAPPED_COMPLETION_ROUTINE,
    ) callconv(@import("std").os.windows.WINAPI) i32,
} ;

pub const LPFN_WSAPOLL = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        fdarray: ?*WSAPOLLFD,
        nfds: u32,
        timeout: i32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
    else => *const fn(
        fdarray: ?*WSAPOLLFD,
        nfds: u32,
        timeout: i32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
} ;

pub const LPFN_RIORECEIVE = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        SocketQueue: ?*RIO_RQ_t,
        pData: [*]RIO_BUF,
        DataBufferCount: u32,
        Flags: u32,
        RequestContext: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn(
        SocketQueue: ?*RIO_RQ_t,
        pData: [*]RIO_BUF,
        DataBufferCount: u32,
        Flags: u32,
        RequestContext: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
} ;

pub const LPFN_RIORECEIVEEX = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        SocketQueue: ?*RIO_RQ_t,
        pData: [*]RIO_BUF,
        DataBufferCount: u32,
        pLocalAddress: ?*RIO_BUF,
        pRemoteAddress: ?*RIO_BUF,
        pControlContext: ?*RIO_BUF,
        pFlags: ?*RIO_BUF,
        Flags: u32,
        RequestContext: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) i32,
    else => *const fn(
        SocketQueue: ?*RIO_RQ_t,
        pData: [*]RIO_BUF,
        DataBufferCount: u32,
        pLocalAddress: ?*RIO_BUF,
        pRemoteAddress: ?*RIO_BUF,
        pControlContext: ?*RIO_BUF,
        pFlags: ?*RIO_BUF,
        Flags: u32,
        RequestContext: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) i32,
} ;

pub const LPFN_RIOSEND = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        SocketQueue: ?*RIO_RQ_t,
        pData: [*]RIO_BUF,
        DataBufferCount: u32,
        Flags: u32,
        RequestContext: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn(
        SocketQueue: ?*RIO_RQ_t,
        pData: [*]RIO_BUF,
        DataBufferCount: u32,
        Flags: u32,
        RequestContext: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
} ;

pub const LPFN_RIOSENDEX = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        SocketQueue: ?*RIO_RQ_t,
        pData: [*]RIO_BUF,
        DataBufferCount: u32,
        pLocalAddress: ?*RIO_BUF,
        pRemoteAddress: ?*RIO_BUF,
        pControlContext: ?*RIO_BUF,
        pFlags: ?*RIO_BUF,
        Flags: u32,
        RequestContext: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn(
        SocketQueue: ?*RIO_RQ_t,
        pData: [*]RIO_BUF,
        DataBufferCount: u32,
        pLocalAddress: ?*RIO_BUF,
        pRemoteAddress: ?*RIO_BUF,
        pControlContext: ?*RIO_BUF,
        pFlags: ?*RIO_BUF,
        Flags: u32,
        RequestContext: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
} ;

pub const LPFN_RIOCLOSECOMPLETIONQUEUE = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        CQ: ?*RIO_CQ_t,
    ) callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn(
        CQ: ?*RIO_CQ_t,
    ) callconv(@import("std").os.windows.WINAPI) void,
} ;

pub const RIO_NOTIFICATION_COMPLETION_TYPE = enum(i32) {
    EVENT_COMPLETION = 1,
    IOCP_COMPLETION = 2,
};
pub const RIO_EVENT_COMPLETION = RIO_NOTIFICATION_COMPLETION_TYPE.EVENT_COMPLETION;
pub const RIO_IOCP_COMPLETION = RIO_NOTIFICATION_COMPLETION_TYPE.IOCP_COMPLETION;

pub const RIO_NOTIFICATION_COMPLETION = extern struct {
    Type: RIO_NOTIFICATION_COMPLETION_TYPE,
    Anonymous: extern union {
        Event: extern struct {
            EventHandle: ?HANDLE,
            NotifyReset: BOOL,
        },
        Iocp: extern struct {
            IocpHandle: ?HANDLE,
            CompletionKey: ?*anyopaque,
            Overlapped: ?*anyopaque,
        },
    },
};

pub const LPFN_RIOCREATECOMPLETIONQUEUE = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        QueueSize: u32,
        NotificationCompletion: ?*RIO_NOTIFICATION_COMPLETION,
    ) callconv(@import("std").os.windows.WINAPI) ?*RIO_CQ_t,
    else => *const fn(
        QueueSize: u32,
        NotificationCompletion: ?*RIO_NOTIFICATION_COMPLETION,
    ) callconv(@import("std").os.windows.WINAPI) ?*RIO_CQ_t,
} ;

pub const LPFN_RIOCREATEREQUESTQUEUE = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        Socket: ?SOCKET,
        MaxOutstandingReceive: u32,
        MaxReceiveDataBuffers: u32,
        MaxOutstandingSend: u32,
        MaxSendDataBuffers: u32,
        ReceiveCQ: ?*RIO_CQ_t,
        SendCQ: ?*RIO_CQ_t,
        SocketContext: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) ?*RIO_RQ_t,
    else => *const fn(
        Socket: ?SOCKET,
        MaxOutstandingReceive: u32,
        MaxReceiveDataBuffers: u32,
        MaxOutstandingSend: u32,
        MaxSendDataBuffers: u32,
        ReceiveCQ: ?*RIO_CQ_t,
        SendCQ: ?*RIO_CQ_t,
        SocketContext: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) ?*RIO_RQ_t,
} ;

pub const LPFN_RIODEQUEUECOMPLETION = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        CQ: ?*RIO_CQ_t,
        Array: [*]RIORESULT,
        ArraySize: u32,
    ) callconv(@import("std").os.windows.WINAPI) u32,
    else => *const fn(
        CQ: ?*RIO_CQ_t,
        Array: [*]RIORESULT,
        ArraySize: u32,
    ) callconv(@import("std").os.windows.WINAPI) u32,
} ;

pub const LPFN_RIODEREGISTERBUFFER = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        BufferId: ?*RIO_BUFFERID_t,
    ) callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn(
        BufferId: ?*RIO_BUFFERID_t,
    ) callconv(@import("std").os.windows.WINAPI) void,
} ;

pub const LPFN_RIONOTIFY = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        CQ: ?*RIO_CQ_t,
    ) callconv(@import("std").os.windows.WINAPI) i32,
    else => *const fn(
        CQ: ?*RIO_CQ_t,
    ) callconv(@import("std").os.windows.WINAPI) i32,
} ;

pub const LPFN_RIOREGISTERBUFFER = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        DataBuffer: ?[*]u8,
        DataLength: u32,
    ) callconv(@import("std").os.windows.WINAPI) ?*RIO_BUFFERID_t,
    else => *const fn(
        DataBuffer: ?[*]u8,
        DataLength: u32,
    ) callconv(@import("std").os.windows.WINAPI) ?*RIO_BUFFERID_t,
} ;

pub const LPFN_RIORESIZECOMPLETIONQUEUE = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        CQ: ?*RIO_CQ_t,
        QueueSize: u32,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn(
        CQ: ?*RIO_CQ_t,
        QueueSize: u32,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
} ;

pub const LPFN_RIORESIZEREQUESTQUEUE = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        RQ: ?*RIO_RQ_t,
        MaxOutstandingReceive: u32,
        MaxOutstandingSend: u32,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn(
        RQ: ?*RIO_RQ_t,
        MaxOutstandingReceive: u32,
        MaxOutstandingSend: u32,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
} ;

pub const RIO_EXTENSION_FUNCTION_TABLE = extern struct {
    cbSize: u32,
    RIOReceive: ?LPFN_RIORECEIVE,
    RIOReceiveEx: ?LPFN_RIORECEIVEEX,
    RIOSend: ?LPFN_RIOSEND,
    RIOSendEx: ?LPFN_RIOSENDEX,
    RIOCloseCompletionQueue: ?LPFN_RIOCLOSECOMPLETIONQUEUE,
    RIOCreateCompletionQueue: ?LPFN_RIOCREATECOMPLETIONQUEUE,
    RIOCreateRequestQueue: ?LPFN_RIOCREATEREQUESTQUEUE,
    RIODequeueCompletion: ?LPFN_RIODEQUEUECOMPLETION,
    RIODeregisterBuffer: ?LPFN_RIODEREGISTERBUFFER,
    RIONotify: ?LPFN_RIONOTIFY,
    RIORegisterBuffer: ?LPFN_RIOREGISTERBUFFER,
    RIOResizeCompletionQueue: ?LPFN_RIORESIZECOMPLETIONQUEUE,
    RIOResizeRequestQueue: ?LPFN_RIORESIZEREQUESTQUEUE,
};

pub const WSPData = extern struct {
    wVersion: u16,
    wHighVersion: u16,
    szDescription: [256]u16,
};

pub const WSATHREADID = extern struct {
    ThreadHandle: ?HANDLE,
    Reserved: usize,
};

pub const LPBLOCKINGCALLBACK = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        dwContext: usize,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn(
        dwContext: usize,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
} ;

pub const LPWSAUSERAPC = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        dwContext: usize,
    ) callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn(
        dwContext: usize,
    ) callconv(@import("std").os.windows.WINAPI) void,
} ;

pub const LPWSPACCEPT = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        s: ?SOCKET,
        // TODO: what to do with BytesParamIndex 2?
        addr: ?*SOCKADDR,
        addrlen: ?*i32,
        lpfnCondition: ?LPCONDITIONPROC,
        dwCallbackData: usize,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) ?SOCKET,
    else => *const fn(
        s: ?SOCKET,
        // TODO: what to do with BytesParamIndex 2?
        addr: ?*SOCKADDR,
        addrlen: ?*i32,
        lpfnCondition: ?LPCONDITIONPROC,
        dwCallbackData: usize,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) ?SOCKET,
} ;

pub const LPWSPADDRESSTOSTRING = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        // TODO: what to do with BytesParamIndex 1?
        lpsaAddress: ?*SOCKADDR,
        dwAddressLength: u32,
        lpProtocolInfo: ?*WSAPROTOCOL_INFOW,
        lpszAddressString: [*:0]u16,
        lpdwAddressStringLength: ?*u32,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
    else => *const fn(
        // TODO: what to do with BytesParamIndex 1?
        lpsaAddress: ?*SOCKADDR,
        dwAddressLength: u32,
        lpProtocolInfo: ?*WSAPROTOCOL_INFOW,
        lpszAddressString: [*:0]u16,
        lpdwAddressStringLength: ?*u32,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
} ;

pub const LPWSPASYNCSELECT = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        s: ?SOCKET,
        hWnd: ?HWND,
        wMsg: u32,
        lEvent: i32,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
    else => *const fn(
        s: ?SOCKET,
        hWnd: ?HWND,
        wMsg: u32,
        lEvent: i32,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
} ;

pub const LPWSPBIND = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        s: ?SOCKET,
        // TODO: what to do with BytesParamIndex 2?
        name: ?*const SOCKADDR,
        namelen: i32,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
    else => *const fn(
        s: ?SOCKET,
        // TODO: what to do with BytesParamIndex 2?
        name: ?*const SOCKADDR,
        namelen: i32,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
} ;

pub const LPWSPCANCELBLOCKINGCALL = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
    else => *const fn(
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
} ;

pub const LPWSPCLEANUP = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
    else => *const fn(
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
} ;

pub const LPWSPCLOSESOCKET = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        s: ?SOCKET,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
    else => *const fn(
        s: ?SOCKET,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
} ;

pub const LPWSPCONNECT = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        s: ?SOCKET,
        // TODO: what to do with BytesParamIndex 2?
        name: ?*const SOCKADDR,
        namelen: i32,
        lpCallerData: ?*WSABUF,
        lpCalleeData: ?*WSABUF,
        lpSQOS: ?*QOS,
        lpGQOS: ?*QOS,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
    else => *const fn(
        s: ?SOCKET,
        // TODO: what to do with BytesParamIndex 2?
        name: ?*const SOCKADDR,
        namelen: i32,
        lpCallerData: ?*WSABUF,
        lpCalleeData: ?*WSABUF,
        lpSQOS: ?*QOS,
        lpGQOS: ?*QOS,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
} ;

pub const LPWSPDUPLICATESOCKET = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        s: ?SOCKET,
        dwProcessId: u32,
        lpProtocolInfo: ?*WSAPROTOCOL_INFOW,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
    else => *const fn(
        s: ?SOCKET,
        dwProcessId: u32,
        lpProtocolInfo: ?*WSAPROTOCOL_INFOW,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
} ;

pub const LPWSPENUMNETWORKEVENTS = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        s: ?SOCKET,
        hEventObject: ?HANDLE,
        lpNetworkEvents: ?*WSANETWORKEVENTS,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
    else => *const fn(
        s: ?SOCKET,
        hEventObject: ?HANDLE,
        lpNetworkEvents: ?*WSANETWORKEVENTS,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
} ;

pub const LPWSPEVENTSELECT = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        s: ?SOCKET,
        hEventObject: ?HANDLE,
        lNetworkEvents: i32,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
    else => *const fn(
        s: ?SOCKET,
        hEventObject: ?HANDLE,
        lNetworkEvents: i32,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
} ;

pub const LPWSPGETOVERLAPPEDRESULT = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        s: ?SOCKET,
        lpOverlapped: ?*OVERLAPPED,
        lpcbTransfer: ?*u32,
        fWait: BOOL,
        lpdwFlags: ?*u32,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn(
        s: ?SOCKET,
        lpOverlapped: ?*OVERLAPPED,
        lpcbTransfer: ?*u32,
        fWait: BOOL,
        lpdwFlags: ?*u32,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
} ;

pub const LPWSPGETPEERNAME = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        s: ?SOCKET,
        // TODO: what to do with BytesParamIndex 2?
        name: ?*SOCKADDR,
        namelen: ?*i32,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
    else => *const fn(
        s: ?SOCKET,
        // TODO: what to do with BytesParamIndex 2?
        name: ?*SOCKADDR,
        namelen: ?*i32,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
} ;

pub const LPWSPGETSOCKNAME = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        s: ?SOCKET,
        // TODO: what to do with BytesParamIndex 2?
        name: ?*SOCKADDR,
        namelen: ?*i32,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
    else => *const fn(
        s: ?SOCKET,
        // TODO: what to do with BytesParamIndex 2?
        name: ?*SOCKADDR,
        namelen: ?*i32,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
} ;

pub const LPWSPGETSOCKOPT = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        s: ?SOCKET,
        level: i32,
        optname: i32,
        // TODO: what to do with BytesParamIndex 4?
        optval: ?PSTR,
        optlen: ?*i32,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
    else => *const fn(
        s: ?SOCKET,
        level: i32,
        optname: i32,
        // TODO: what to do with BytesParamIndex 4?
        optval: ?PSTR,
        optlen: ?*i32,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
} ;

pub const LPWSPGETQOSBYNAME = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        s: ?SOCKET,
        lpQOSName: ?*WSABUF,
        lpQOS: ?*QOS,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn(
        s: ?SOCKET,
        lpQOSName: ?*WSABUF,
        lpQOS: ?*QOS,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
} ;

pub const LPWSPIOCTL = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        s: ?SOCKET,
        dwIoControlCode: u32,
        // TODO: what to do with BytesParamIndex 3?
        lpvInBuffer: ?*anyopaque,
        cbInBuffer: u32,
        // TODO: what to do with BytesParamIndex 5?
        lpvOutBuffer: ?*anyopaque,
        cbOutBuffer: u32,
        lpcbBytesReturned: ?*u32,
        lpOverlapped: ?*OVERLAPPED,
        lpCompletionRoutine: ?LPWSAOVERLAPPED_COMPLETION_ROUTINE,
        lpThreadId: ?*WSATHREADID,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
    else => *const fn(
        s: ?SOCKET,
        dwIoControlCode: u32,
        // TODO: what to do with BytesParamIndex 3?
        lpvInBuffer: ?*anyopaque,
        cbInBuffer: u32,
        // TODO: what to do with BytesParamIndex 5?
        lpvOutBuffer: ?*anyopaque,
        cbOutBuffer: u32,
        lpcbBytesReturned: ?*u32,
        lpOverlapped: ?*OVERLAPPED,
        lpCompletionRoutine: ?LPWSAOVERLAPPED_COMPLETION_ROUTINE,
        lpThreadId: ?*WSATHREADID,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
} ;

pub const LPWSPJOINLEAF = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        s: ?SOCKET,
        // TODO: what to do with BytesParamIndex 2?
        name: ?*const SOCKADDR,
        namelen: i32,
        lpCallerData: ?*WSABUF,
        lpCalleeData: ?*WSABUF,
        lpSQOS: ?*QOS,
        lpGQOS: ?*QOS,
        dwFlags: u32,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) ?SOCKET,
    else => *const fn(
        s: ?SOCKET,
        // TODO: what to do with BytesParamIndex 2?
        name: ?*const SOCKADDR,
        namelen: i32,
        lpCallerData: ?*WSABUF,
        lpCalleeData: ?*WSABUF,
        lpSQOS: ?*QOS,
        lpGQOS: ?*QOS,
        dwFlags: u32,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) ?SOCKET,
} ;

pub const LPWSPLISTEN = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        s: ?SOCKET,
        backlog: i32,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
    else => *const fn(
        s: ?SOCKET,
        backlog: i32,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
} ;

pub const LPWSPRECV = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        s: ?SOCKET,
        lpBuffers: [*]WSABUF,
        dwBufferCount: u32,
        lpNumberOfBytesRecvd: ?*u32,
        lpFlags: ?*u32,
        lpOverlapped: ?*OVERLAPPED,
        lpCompletionRoutine: ?LPWSAOVERLAPPED_COMPLETION_ROUTINE,
        lpThreadId: ?*WSATHREADID,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
    else => *const fn(
        s: ?SOCKET,
        lpBuffers: [*]WSABUF,
        dwBufferCount: u32,
        lpNumberOfBytesRecvd: ?*u32,
        lpFlags: ?*u32,
        lpOverlapped: ?*OVERLAPPED,
        lpCompletionRoutine: ?LPWSAOVERLAPPED_COMPLETION_ROUTINE,
        lpThreadId: ?*WSATHREADID,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
} ;

pub const LPWSPRECVDISCONNECT = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        s: ?SOCKET,
        lpInboundDisconnectData: ?*WSABUF,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
    else => *const fn(
        s: ?SOCKET,
        lpInboundDisconnectData: ?*WSABUF,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
} ;

pub const LPWSPRECVFROM = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        s: ?SOCKET,
        lpBuffers: [*]WSABUF,
        dwBufferCount: u32,
        lpNumberOfBytesRecvd: ?*u32,
        lpFlags: ?*u32,
        // TODO: what to do with BytesParamIndex 6?
        lpFrom: ?*SOCKADDR,
        lpFromlen: ?*i32,
        lpOverlapped: ?*OVERLAPPED,
        lpCompletionRoutine: ?LPWSAOVERLAPPED_COMPLETION_ROUTINE,
        lpThreadId: ?*WSATHREADID,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
    else => *const fn(
        s: ?SOCKET,
        lpBuffers: [*]WSABUF,
        dwBufferCount: u32,
        lpNumberOfBytesRecvd: ?*u32,
        lpFlags: ?*u32,
        // TODO: what to do with BytesParamIndex 6?
        lpFrom: ?*SOCKADDR,
        lpFromlen: ?*i32,
        lpOverlapped: ?*OVERLAPPED,
        lpCompletionRoutine: ?LPWSAOVERLAPPED_COMPLETION_ROUTINE,
        lpThreadId: ?*WSATHREADID,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
} ;

pub const LPWSPSELECT = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        nfds: i32,
        readfds: ?*fd_set,
        writefds: ?*fd_set,
        exceptfds: ?*fd_set,
        timeout: ?*const timeval,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
    else => *const fn(
        nfds: i32,
        readfds: ?*fd_set,
        writefds: ?*fd_set,
        exceptfds: ?*fd_set,
        timeout: ?*const timeval,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
} ;

pub const LPWSPSEND = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        s: ?SOCKET,
        lpBuffers: [*]WSABUF,
        dwBufferCount: u32,
        lpNumberOfBytesSent: ?*u32,
        dwFlags: u32,
        lpOverlapped: ?*OVERLAPPED,
        lpCompletionRoutine: ?LPWSAOVERLAPPED_COMPLETION_ROUTINE,
        lpThreadId: ?*WSATHREADID,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
    else => *const fn(
        s: ?SOCKET,
        lpBuffers: [*]WSABUF,
        dwBufferCount: u32,
        lpNumberOfBytesSent: ?*u32,
        dwFlags: u32,
        lpOverlapped: ?*OVERLAPPED,
        lpCompletionRoutine: ?LPWSAOVERLAPPED_COMPLETION_ROUTINE,
        lpThreadId: ?*WSATHREADID,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
} ;

pub const LPWSPSENDDISCONNECT = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        s: ?SOCKET,
        lpOutboundDisconnectData: ?*WSABUF,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
    else => *const fn(
        s: ?SOCKET,
        lpOutboundDisconnectData: ?*WSABUF,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
} ;

pub const LPWSPSENDTO = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        s: ?SOCKET,
        lpBuffers: [*]WSABUF,
        dwBufferCount: u32,
        lpNumberOfBytesSent: ?*u32,
        dwFlags: u32,
        // TODO: what to do with BytesParamIndex 6?
        lpTo: ?*const SOCKADDR,
        iTolen: i32,
        lpOverlapped: ?*OVERLAPPED,
        lpCompletionRoutine: ?LPWSAOVERLAPPED_COMPLETION_ROUTINE,
        lpThreadId: ?*WSATHREADID,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
    else => *const fn(
        s: ?SOCKET,
        lpBuffers: [*]WSABUF,
        dwBufferCount: u32,
        lpNumberOfBytesSent: ?*u32,
        dwFlags: u32,
        // TODO: what to do with BytesParamIndex 6?
        lpTo: ?*const SOCKADDR,
        iTolen: i32,
        lpOverlapped: ?*OVERLAPPED,
        lpCompletionRoutine: ?LPWSAOVERLAPPED_COMPLETION_ROUTINE,
        lpThreadId: ?*WSATHREADID,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
} ;

pub const LPWSPSETSOCKOPT = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        s: ?SOCKET,
        level: i32,
        optname: i32,
        // TODO: what to do with BytesParamIndex 4?
        optval: ?[*:0]const u8,
        optlen: i32,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
    else => *const fn(
        s: ?SOCKET,
        level: i32,
        optname: i32,
        // TODO: what to do with BytesParamIndex 4?
        optval: ?[*:0]const u8,
        optlen: i32,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
} ;

pub const LPWSPSHUTDOWN = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        s: ?SOCKET,
        how: i32,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
    else => *const fn(
        s: ?SOCKET,
        how: i32,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
} ;

pub const LPWSPSOCKET = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        af: i32,
        type: i32,
        protocol: i32,
        lpProtocolInfo: ?*WSAPROTOCOL_INFOW,
        g: u32,
        dwFlags: u32,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) ?SOCKET,
    else => *const fn(
        af: i32,
        type: i32,
        protocol: i32,
        lpProtocolInfo: ?*WSAPROTOCOL_INFOW,
        g: u32,
        dwFlags: u32,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) ?SOCKET,
} ;

pub const LPWSPSTRINGTOADDRESS = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        AddressString: ?PWSTR,
        AddressFamily: i32,
        lpProtocolInfo: ?*WSAPROTOCOL_INFOW,
        // TODO: what to do with BytesParamIndex 4?
        lpAddress: ?*SOCKADDR,
        lpAddressLength: ?*i32,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
    else => *const fn(
        AddressString: ?PWSTR,
        AddressFamily: i32,
        lpProtocolInfo: ?*WSAPROTOCOL_INFOW,
        // TODO: what to do with BytesParamIndex 4?
        lpAddress: ?*SOCKADDR,
        lpAddressLength: ?*i32,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
} ;

pub const WSPPROC_TABLE = extern struct {
    lpWSPAccept: ?LPWSPACCEPT,
    lpWSPAddressToString: ?LPWSPADDRESSTOSTRING,
    lpWSPAsyncSelect: ?LPWSPASYNCSELECT,
    lpWSPBind: ?LPWSPBIND,
    lpWSPCancelBlockingCall: ?LPWSPCANCELBLOCKINGCALL,
    lpWSPCleanup: ?LPWSPCLEANUP,
    lpWSPCloseSocket: ?LPWSPCLOSESOCKET,
    lpWSPConnect: ?LPWSPCONNECT,
    lpWSPDuplicateSocket: ?LPWSPDUPLICATESOCKET,
    lpWSPEnumNetworkEvents: ?LPWSPENUMNETWORKEVENTS,
    lpWSPEventSelect: ?LPWSPEVENTSELECT,
    lpWSPGetOverlappedResult: ?LPWSPGETOVERLAPPEDRESULT,
    lpWSPGetPeerName: ?LPWSPGETPEERNAME,
    lpWSPGetSockName: ?LPWSPGETSOCKNAME,
    lpWSPGetSockOpt: ?LPWSPGETSOCKOPT,
    lpWSPGetQOSByName: ?LPWSPGETQOSBYNAME,
    lpWSPIoctl: ?LPWSPIOCTL,
    lpWSPJoinLeaf: ?LPWSPJOINLEAF,
    lpWSPListen: ?LPWSPLISTEN,
    lpWSPRecv: ?LPWSPRECV,
    lpWSPRecvDisconnect: ?LPWSPRECVDISCONNECT,
    lpWSPRecvFrom: ?LPWSPRECVFROM,
    lpWSPSelect: ?LPWSPSELECT,
    lpWSPSend: ?LPWSPSEND,
    lpWSPSendDisconnect: ?LPWSPSENDDISCONNECT,
    lpWSPSendTo: ?LPWSPSENDTO,
    lpWSPSetSockOpt: ?LPWSPSETSOCKOPT,
    lpWSPShutdown: ?LPWSPSHUTDOWN,
    lpWSPSocket: ?LPWSPSOCKET,
    lpWSPStringToAddress: ?LPWSPSTRINGTOADDRESS,
};

pub const LPWPUCLOSEEVENT = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        hEvent: ?HANDLE,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn(
        hEvent: ?HANDLE,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
} ;

pub const LPWPUCLOSESOCKETHANDLE = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        s: ?SOCKET,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
    else => *const fn(
        s: ?SOCKET,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
} ;

pub const LPWPUCREATEEVENT = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) ?HANDLE,
    else => *const fn(
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) ?HANDLE,
} ;

pub const LPWPUCREATESOCKETHANDLE = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        dwCatalogEntryId: u32,
        dwContext: usize,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) ?SOCKET,
    else => *const fn(
        dwCatalogEntryId: u32,
        dwContext: usize,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) ?SOCKET,
} ;

pub const LPWPUFDISSET = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        s: ?SOCKET,
        fdset: ?*fd_set,
    ) callconv(@import("std").os.windows.WINAPI) i32,
    else => *const fn(
        s: ?SOCKET,
        fdset: ?*fd_set,
    ) callconv(@import("std").os.windows.WINAPI) i32,
} ;

pub const LPWPUGETPROVIDERPATH = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        lpProviderId: ?*Guid,
        lpszProviderDllPath: [*:0]u16,
        lpProviderDllPathLen: ?*i32,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
    else => *const fn(
        lpProviderId: ?*Guid,
        lpszProviderDllPath: [*:0]u16,
        lpProviderDllPathLen: ?*i32,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
} ;

pub const LPWPUMODIFYIFSHANDLE = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        dwCatalogEntryId: u32,
        ProposedHandle: ?SOCKET,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) ?SOCKET,
    else => *const fn(
        dwCatalogEntryId: u32,
        ProposedHandle: ?SOCKET,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) ?SOCKET,
} ;

pub const LPWPUPOSTMESSAGE = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        hWnd: ?HWND,
        Msg: u32,
        wParam: WPARAM,
        lParam: LPARAM,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn(
        hWnd: ?HWND,
        Msg: u32,
        wParam: WPARAM,
        lParam: LPARAM,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
} ;

pub const LPWPUQUERYBLOCKINGCALLBACK = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        dwCatalogEntryId: u32,
        lplpfnCallback: ?*?LPBLOCKINGCALLBACK,
        lpdwContext: ?*usize,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
    else => *const fn(
        dwCatalogEntryId: u32,
        lplpfnCallback: ?*?LPBLOCKINGCALLBACK,
        lpdwContext: ?*usize,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
} ;

pub const LPWPUQUERYSOCKETHANDLECONTEXT = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        s: ?SOCKET,
        lpContext: ?*usize,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
    else => *const fn(
        s: ?SOCKET,
        lpContext: ?*usize,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
} ;

pub const LPWPUQUEUEAPC = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        lpThreadId: ?*WSATHREADID,
        lpfnUserApc: ?LPWSAUSERAPC,
        dwContext: usize,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
    else => *const fn(
        lpThreadId: ?*WSATHREADID,
        lpfnUserApc: ?LPWSAUSERAPC,
        dwContext: usize,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
} ;

pub const LPWPURESETEVENT = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        hEvent: ?HANDLE,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn(
        hEvent: ?HANDLE,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
} ;

pub const LPWPUSETEVENT = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        hEvent: ?HANDLE,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn(
        hEvent: ?HANDLE,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
} ;

pub const LPWPUOPENCURRENTTHREAD = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        lpThreadId: ?*WSATHREADID,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
    else => *const fn(
        lpThreadId: ?*WSATHREADID,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
} ;

pub const LPWPUCLOSETHREAD = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        lpThreadId: ?*WSATHREADID,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
    else => *const fn(
        lpThreadId: ?*WSATHREADID,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
} ;

pub const LPWPUCOMPLETEOVERLAPPEDREQUEST = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        s: ?SOCKET,
        lpOverlapped: ?*OVERLAPPED,
        dwError: u32,
        cbTransferred: u32,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
    else => *const fn(
        s: ?SOCKET,
        lpOverlapped: ?*OVERLAPPED,
        dwError: u32,
        cbTransferred: u32,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
} ;

pub const WSPUPCALLTABLE = extern struct {
    lpWPUCloseEvent: ?LPWPUCLOSEEVENT,
    lpWPUCloseSocketHandle: ?LPWPUCLOSESOCKETHANDLE,
    lpWPUCreateEvent: ?LPWPUCREATEEVENT,
    lpWPUCreateSocketHandle: ?LPWPUCREATESOCKETHANDLE,
    lpWPUFDIsSet: ?LPWPUFDISSET,
    lpWPUGetProviderPath: ?LPWPUGETPROVIDERPATH,
    lpWPUModifyIFSHandle: ?LPWPUMODIFYIFSHANDLE,
    lpWPUPostMessage: ?LPWPUPOSTMESSAGE,
    lpWPUQueryBlockingCallback: ?LPWPUQUERYBLOCKINGCALLBACK,
    lpWPUQuerySocketHandleContext: ?LPWPUQUERYSOCKETHANDLECONTEXT,
    lpWPUQueueApc: ?LPWPUQUEUEAPC,
    lpWPUResetEvent: ?LPWPURESETEVENT,
    lpWPUSetEvent: ?LPWPUSETEVENT,
    lpWPUOpenCurrentThread: ?LPWPUOPENCURRENTTHREAD,
    lpWPUCloseThread: ?LPWPUCLOSETHREAD,
};

pub const LPWSPSTARTUP = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        wVersionRequested: u16,
        lpWSPData: ?*WSPData,
        lpProtocolInfo: ?*WSAPROTOCOL_INFOW,
        UpcallTable: WSPUPCALLTABLE,
        lpProcTable: ?*WSPPROC_TABLE,
    ) callconv(@import("std").os.windows.WINAPI) i32,
    else => *const fn(
        wVersionRequested: u16,
        lpWSPData: ?*WSPData,
        lpProtocolInfo: ?*WSAPROTOCOL_INFOW,
        UpcallTable: WSPUPCALLTABLE,
        lpProcTable: ?*WSPPROC_TABLE,
    ) callconv(@import("std").os.windows.WINAPI) i32,
} ;

pub const LPWSCENUMPROTOCOLS = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        lpiProtocols: ?*i32,
        // TODO: what to do with BytesParamIndex 2?
        lpProtocolBuffer: ?*WSAPROTOCOL_INFOW,
        lpdwBufferLength: ?*u32,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
    else => *const fn(
        lpiProtocols: ?*i32,
        // TODO: what to do with BytesParamIndex 2?
        lpProtocolBuffer: ?*WSAPROTOCOL_INFOW,
        lpdwBufferLength: ?*u32,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
} ;

pub const LPWSCDEINSTALLPROVIDER = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        lpProviderId: ?*Guid,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
    else => *const fn(
        lpProviderId: ?*Guid,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
} ;

pub const LPWSCINSTALLPROVIDER = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        lpProviderId: ?*Guid,
        lpszProviderDllPath: ?[*:0]const u16,
        lpProtocolInfoList: [*]const WSAPROTOCOL_INFOW,
        dwNumberOfEntries: u32,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
    else => *const fn(
        lpProviderId: ?*Guid,
        lpszProviderDllPath: ?[*:0]const u16,
        lpProtocolInfoList: [*]const WSAPROTOCOL_INFOW,
        dwNumberOfEntries: u32,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
} ;

pub const LPWSCGETPROVIDERPATH = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        lpProviderId: ?*Guid,
        lpszProviderDllPath: [*:0]u16,
        lpProviderDllPathLen: ?*i32,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
    else => *const fn(
        lpProviderId: ?*Guid,
        lpszProviderDllPath: [*:0]u16,
        lpProviderDllPathLen: ?*i32,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
} ;

pub const LPWSCUPDATEPROVIDER = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        lpProviderId: ?*Guid,
        lpszProviderDllPath: ?[*:0]const u16,
        lpProtocolInfoList: [*]const WSAPROTOCOL_INFOW,
        dwNumberOfEntries: u32,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
    else => *const fn(
        lpProviderId: ?*Guid,
        lpszProviderDllPath: ?[*:0]const u16,
        lpProtocolInfoList: [*]const WSAPROTOCOL_INFOW,
        dwNumberOfEntries: u32,
        lpErrno: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
} ;

pub const WSC_PROVIDER_INFO_TYPE = enum(i32) {
    LspCategories = 0,
    Audit = 1,
};
pub const ProviderInfoLspCategories = WSC_PROVIDER_INFO_TYPE.LspCategories;
pub const ProviderInfoAudit = WSC_PROVIDER_INFO_TYPE.Audit;

pub const WSC_PROVIDER_AUDIT_INFO = extern struct {
    RecordSize: u32,
    Reserved: ?*anyopaque,
};

pub const LPWSCINSTALLNAMESPACE = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        lpszIdentifier: ?PWSTR,
        lpszPathName: ?PWSTR,
        dwNameSpace: u32,
        dwVersion: u32,
        lpProviderId: ?*Guid,
    ) callconv(@import("std").os.windows.WINAPI) i32,
    else => *const fn(
        lpszIdentifier: ?PWSTR,
        lpszPathName: ?PWSTR,
        dwNameSpace: u32,
        dwVersion: u32,
        lpProviderId: ?*Guid,
    ) callconv(@import("std").os.windows.WINAPI) i32,
} ;

pub const LPWSCUNINSTALLNAMESPACE = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        lpProviderId: ?*Guid,
    ) callconv(@import("std").os.windows.WINAPI) i32,
    else => *const fn(
        lpProviderId: ?*Guid,
    ) callconv(@import("std").os.windows.WINAPI) i32,
} ;

pub const LPWSCENABLENSPROVIDER = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        lpProviderId: ?*Guid,
        fEnable: BOOL,
    ) callconv(@import("std").os.windows.WINAPI) i32,
    else => *const fn(
        lpProviderId: ?*Guid,
        fEnable: BOOL,
    ) callconv(@import("std").os.windows.WINAPI) i32,
} ;

pub const LPNSPCLEANUP = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        lpProviderId: ?*Guid,
    ) callconv(@import("std").os.windows.WINAPI) i32,
    else => *const fn(
        lpProviderId: ?*Guid,
    ) callconv(@import("std").os.windows.WINAPI) i32,
} ;

pub const LPNSPLOOKUPSERVICEBEGIN = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        lpProviderId: ?*Guid,
        lpqsRestrictions: ?*WSAQUERYSETW,
        lpServiceClassInfo: ?*WSASERVICECLASSINFOW,
        dwControlFlags: u32,
        lphLookup: ?*?HANDLE,
    ) callconv(@import("std").os.windows.WINAPI) i32,
    else => *const fn(
        lpProviderId: ?*Guid,
        lpqsRestrictions: ?*WSAQUERYSETW,
        lpServiceClassInfo: ?*WSASERVICECLASSINFOW,
        dwControlFlags: u32,
        lphLookup: ?*?HANDLE,
    ) callconv(@import("std").os.windows.WINAPI) i32,
} ;

pub const LPNSPLOOKUPSERVICENEXT = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        hLookup: ?HANDLE,
        dwControlFlags: u32,
        lpdwBufferLength: ?*u32,
        // TODO: what to do with BytesParamIndex 2?
        lpqsResults: ?*WSAQUERYSETW,
    ) callconv(@import("std").os.windows.WINAPI) i32,
    else => *const fn(
        hLookup: ?HANDLE,
        dwControlFlags: u32,
        lpdwBufferLength: ?*u32,
        // TODO: what to do with BytesParamIndex 2?
        lpqsResults: ?*WSAQUERYSETW,
    ) callconv(@import("std").os.windows.WINAPI) i32,
} ;

pub const LPNSPIOCTL = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        hLookup: ?HANDLE,
        dwControlCode: u32,
        // TODO: what to do with BytesParamIndex 3?
        lpvInBuffer: ?*anyopaque,
        cbInBuffer: u32,
        // TODO: what to do with BytesParamIndex 5?
        lpvOutBuffer: ?*anyopaque,
        cbOutBuffer: u32,
        lpcbBytesReturned: ?*u32,
        lpCompletion: ?*WSACOMPLETION,
        lpThreadId: ?*WSATHREADID,
    ) callconv(@import("std").os.windows.WINAPI) i32,
    else => *const fn(
        hLookup: ?HANDLE,
        dwControlCode: u32,
        // TODO: what to do with BytesParamIndex 3?
        lpvInBuffer: ?*anyopaque,
        cbInBuffer: u32,
        // TODO: what to do with BytesParamIndex 5?
        lpvOutBuffer: ?*anyopaque,
        cbOutBuffer: u32,
        lpcbBytesReturned: ?*u32,
        lpCompletion: ?*WSACOMPLETION,
        lpThreadId: ?*WSATHREADID,
    ) callconv(@import("std").os.windows.WINAPI) i32,
} ;

pub const LPNSPLOOKUPSERVICEEND = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        hLookup: ?HANDLE,
    ) callconv(@import("std").os.windows.WINAPI) i32,
    else => *const fn(
        hLookup: ?HANDLE,
    ) callconv(@import("std").os.windows.WINAPI) i32,
} ;

pub const LPNSPSETSERVICE = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        lpProviderId: ?*Guid,
        lpServiceClassInfo: ?*WSASERVICECLASSINFOW,
        lpqsRegInfo: ?*WSAQUERYSETW,
        essOperation: WSAESETSERVICEOP,
        dwControlFlags: u32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
    else => *const fn(
        lpProviderId: ?*Guid,
        lpServiceClassInfo: ?*WSASERVICECLASSINFOW,
        lpqsRegInfo: ?*WSAQUERYSETW,
        essOperation: WSAESETSERVICEOP,
        dwControlFlags: u32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
} ;

pub const LPNSPINSTALLSERVICECLASS = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        lpProviderId: ?*Guid,
        lpServiceClassInfo: ?*WSASERVICECLASSINFOW,
    ) callconv(@import("std").os.windows.WINAPI) i32,
    else => *const fn(
        lpProviderId: ?*Guid,
        lpServiceClassInfo: ?*WSASERVICECLASSINFOW,
    ) callconv(@import("std").os.windows.WINAPI) i32,
} ;

pub const LPNSPREMOVESERVICECLASS = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        lpProviderId: ?*Guid,
        lpServiceClassId: ?*Guid,
    ) callconv(@import("std").os.windows.WINAPI) i32,
    else => *const fn(
        lpProviderId: ?*Guid,
        lpServiceClassId: ?*Guid,
    ) callconv(@import("std").os.windows.WINAPI) i32,
} ;

pub const LPNSPGETSERVICECLASSINFO = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        lpProviderId: ?*Guid,
        lpdwBufSize: ?*u32,
        lpServiceClassInfo: ?*WSASERVICECLASSINFOW,
    ) callconv(@import("std").os.windows.WINAPI) i32,
    else => *const fn(
        lpProviderId: ?*Guid,
        lpdwBufSize: ?*u32,
        lpServiceClassInfo: ?*WSASERVICECLASSINFOW,
    ) callconv(@import("std").os.windows.WINAPI) i32,
} ;

pub const NSP_ROUTINE = extern struct {
    cbSize: u32,
    dwMajorVersion: u32,
    dwMinorVersion: u32,
    NSPCleanup: ?LPNSPCLEANUP,
    NSPLookupServiceBegin: ?LPNSPLOOKUPSERVICEBEGIN,
    NSPLookupServiceNext: ?LPNSPLOOKUPSERVICENEXT,
    NSPLookupServiceEnd: ?LPNSPLOOKUPSERVICEEND,
    NSPSetService: ?LPNSPSETSERVICE,
    NSPInstallServiceClass: ?LPNSPINSTALLSERVICECLASS,
    NSPRemoveServiceClass: ?LPNSPREMOVESERVICECLASS,
    NSPGetServiceClassInfo: ?LPNSPGETSERVICECLASSINFO,
    NSPIoctl: ?LPNSPIOCTL,
};

pub const LPNSPSTARTUP = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        lpProviderId: ?*Guid,
        lpnspRoutines: ?*NSP_ROUTINE,
    ) callconv(@import("std").os.windows.WINAPI) i32,
    else => *const fn(
        lpProviderId: ?*Guid,
        lpnspRoutines: ?*NSP_ROUTINE,
    ) callconv(@import("std").os.windows.WINAPI) i32,
} ;

pub const LPNSPV2STARTUP = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        lpProviderId: ?*Guid,
        ppvClientSessionArg: ?*?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) i32,
    else => *const fn(
        lpProviderId: ?*Guid,
        ppvClientSessionArg: ?*?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) i32,
} ;

pub const LPNSPV2CLEANUP = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        lpProviderId: ?*Guid,
        pvClientSessionArg: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) i32,
    else => *const fn(
        lpProviderId: ?*Guid,
        pvClientSessionArg: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) i32,
} ;

pub const LPNSPV2LOOKUPSERVICEBEGIN = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        lpProviderId: ?*Guid,
        lpqsRestrictions: ?*WSAQUERYSET2W,
        dwControlFlags: u32,
        lpvClientSessionArg: ?*anyopaque,
        lphLookup: ?*?HANDLE,
    ) callconv(@import("std").os.windows.WINAPI) i32,
    else => *const fn(
        lpProviderId: ?*Guid,
        lpqsRestrictions: ?*WSAQUERYSET2W,
        dwControlFlags: u32,
        lpvClientSessionArg: ?*anyopaque,
        lphLookup: ?*?HANDLE,
    ) callconv(@import("std").os.windows.WINAPI) i32,
} ;

pub const LPNSPV2LOOKUPSERVICENEXTEX = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        hAsyncCall: ?HANDLE,
        hLookup: ?HANDLE,
        dwControlFlags: u32,
        lpdwBufferLength: ?*u32,
        lpqsResults: ?*WSAQUERYSET2W,
    ) callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn(
        hAsyncCall: ?HANDLE,
        hLookup: ?HANDLE,
        dwControlFlags: u32,
        lpdwBufferLength: ?*u32,
        lpqsResults: ?*WSAQUERYSET2W,
    ) callconv(@import("std").os.windows.WINAPI) void,
} ;

pub const LPNSPV2LOOKUPSERVICEEND = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        hLookup: ?HANDLE,
    ) callconv(@import("std").os.windows.WINAPI) i32,
    else => *const fn(
        hLookup: ?HANDLE,
    ) callconv(@import("std").os.windows.WINAPI) i32,
} ;

pub const LPNSPV2SETSERVICEEX = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        hAsyncCall: ?HANDLE,
        lpProviderId: ?*Guid,
        lpqsRegInfo: ?*WSAQUERYSET2W,
        essOperation: WSAESETSERVICEOP,
        dwControlFlags: u32,
        lpvClientSessionArg: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn(
        hAsyncCall: ?HANDLE,
        lpProviderId: ?*Guid,
        lpqsRegInfo: ?*WSAQUERYSET2W,
        essOperation: WSAESETSERVICEOP,
        dwControlFlags: u32,
        lpvClientSessionArg: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) void,
} ;

pub const LPNSPV2CLIENTSESSIONRUNDOWN = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        lpProviderId: ?*Guid,
        pvClientSessionArg: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn(
        lpProviderId: ?*Guid,
        pvClientSessionArg: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) void,
} ;

pub const NSPV2_ROUTINE = extern struct {
    cbSize: u32,
    dwMajorVersion: u32,
    dwMinorVersion: u32,
    NSPv2Startup: ?LPNSPV2STARTUP,
    NSPv2Cleanup: ?LPNSPV2CLEANUP,
    NSPv2LookupServiceBegin: ?LPNSPV2LOOKUPSERVICEBEGIN,
    NSPv2LookupServiceNextEx: ?LPNSPV2LOOKUPSERVICENEXTEX,
    NSPv2LookupServiceEnd: ?LPNSPV2LOOKUPSERVICEEND,
    NSPv2SetServiceEx: ?LPNSPV2SETSERVICEEX,
    NSPv2ClientSessionRundown: ?LPNSPV2CLIENTSESSIONRUNDOWN,
};

pub const NS_INFOA = extern struct {
    dwNameSpace: u32,
    dwNameSpaceFlags: u32,
    lpNameSpace: ?PSTR,
};

pub const NS_INFOW = extern struct {
    dwNameSpace: u32,
    dwNameSpaceFlags: u32,
    lpNameSpace: ?PWSTR,
};

pub const SERVICE_TYPE_VALUE = extern struct {
    dwNameSpace: u32,
    dwValueType: u32,
    dwValueSize: u32,
    dwValueNameOffset: u32,
    dwValueOffset: u32,
};

pub const SERVICE_TYPE_VALUE_ABSA = extern struct {
    dwNameSpace: u32,
    dwValueType: u32,
    dwValueSize: u32,
    lpValueName: ?PSTR,
    lpValue: ?*anyopaque,
};

pub const SERVICE_TYPE_VALUE_ABSW = extern struct {
    dwNameSpace: u32,
    dwValueType: u32,
    dwValueSize: u32,
    lpValueName: ?PWSTR,
    lpValue: ?*anyopaque,
};

pub const SERVICE_TYPE_INFO = extern struct {
    dwTypeNameOffset: u32,
    dwValueCount: u32,
    Values: [1]SERVICE_TYPE_VALUE,
};

pub const SERVICE_TYPE_INFO_ABSA = extern struct {
    lpTypeName: ?PSTR,
    dwValueCount: u32,
    Values: [1]SERVICE_TYPE_VALUE_ABSA,
};

pub const SERVICE_TYPE_INFO_ABSW = extern struct {
    lpTypeName: ?PWSTR,
    dwValueCount: u32,
    Values: [1]SERVICE_TYPE_VALUE_ABSW,
};

pub const SERVICE_ADDRESS = extern struct {
    dwAddressType: u32,
    dwAddressFlags: u32,
    dwAddressLength: u32,
    dwPrincipalLength: u32,
    lpAddress: ?*u8,
    lpPrincipal: ?*u8,
};

pub const SERVICE_ADDRESSES = extern struct {
    dwAddressCount: u32,
    Addresses: [1]SERVICE_ADDRESS,
};

pub const SERVICE_INFOA = extern struct {
    lpServiceType: ?*Guid,
    lpServiceName: ?PSTR,
    lpComment: ?PSTR,
    lpLocale: ?PSTR,
    dwDisplayHint: RESOURCE_DISPLAY_TYPE,
    dwVersion: u32,
    dwTime: u32,
    lpMachineName: ?PSTR,
    lpServiceAddress: ?*SERVICE_ADDRESSES,
    ServiceSpecificInfo: BLOB,
};

pub const SERVICE_INFOW = extern struct {
    lpServiceType: ?*Guid,
    lpServiceName: ?PWSTR,
    lpComment: ?PWSTR,
    lpLocale: ?PWSTR,
    dwDisplayHint: RESOURCE_DISPLAY_TYPE,
    dwVersion: u32,
    dwTime: u32,
    lpMachineName: ?PWSTR,
    lpServiceAddress: ?*SERVICE_ADDRESSES,
    ServiceSpecificInfo: BLOB,
};

pub const NS_SERVICE_INFOA = extern struct {
    dwNameSpace: u32,
    ServiceInfo: SERVICE_INFOA,
};

pub const NS_SERVICE_INFOW = extern struct {
    dwNameSpace: u32,
    ServiceInfo: SERVICE_INFOW,
};

pub const PROTOCOL_INFOA = extern struct {
    dwServiceFlags: u32,
    iAddressFamily: i32,
    iMaxSockAddr: i32,
    iMinSockAddr: i32,
    iSocketType: i32,
    iProtocol: i32,
    dwMessageSize: u32,
    lpProtocol: ?PSTR,
};

pub const PROTOCOL_INFOW = extern struct {
    dwServiceFlags: u32,
    iAddressFamily: i32,
    iMaxSockAddr: i32,
    iMinSockAddr: i32,
    iSocketType: i32,
    iProtocol: i32,
    dwMessageSize: u32,
    lpProtocol: ?PWSTR,
};

pub const NETRESOURCE2A = extern struct {
    dwScope: u32,
    dwType: u32,
    dwUsage: u32,
    dwDisplayType: u32,
    lpLocalName: ?PSTR,
    lpRemoteName: ?PSTR,
    lpComment: ?PSTR,
    ns_info: NS_INFOA,
    ServiceType: Guid,
    dwProtocols: u32,
    lpiProtocols: ?*i32,
};

pub const NETRESOURCE2W = extern struct {
    dwScope: u32,
    dwType: u32,
    dwUsage: u32,
    dwDisplayType: u32,
    lpLocalName: ?PWSTR,
    lpRemoteName: ?PWSTR,
    lpComment: ?PWSTR,
    ns_info: NS_INFOA,
    ServiceType: Guid,
    dwProtocols: u32,
    lpiProtocols: ?*i32,
};

pub const LPFN_NSPAPI = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
    ) callconv(@import("std").os.windows.WINAPI) u32,
    else => *const fn(
    ) callconv(@import("std").os.windows.WINAPI) u32,
} ;

pub const LPSERVICE_CALLBACK_PROC = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        lParam: LPARAM,
        hAsyncTaskHandle: ?HANDLE,
    ) callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn(
        lParam: LPARAM,
        hAsyncTaskHandle: ?HANDLE,
    ) callconv(@import("std").os.windows.WINAPI) void,
} ;

pub const SERVICE_ASYNC_INFO = extern struct {
    lpServiceCallbackProc: ?LPSERVICE_CALLBACK_PROC,
    lParam: LPARAM,
    hAsyncTaskHandle: ?HANDLE,
};

pub const LPLOOKUPSERVICE_COMPLETION_ROUTINE = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        dwError: u32,
        dwBytes: u32,
        lpOverlapped: ?*OVERLAPPED,
    ) callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn(
        dwError: u32,
        dwBytes: u32,
        lpOverlapped: ?*OVERLAPPED,
    ) callconv(@import("std").os.windows.WINAPI) void,
} ;

pub const LPWSCWRITEPROVIDERORDER = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        lpwdCatalogEntryId: ?*u32,
        dwNumberOfEntries: u32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
    else => *const fn(
        lpwdCatalogEntryId: ?*u32,
        dwNumberOfEntries: u32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
} ;

pub const LPWSCWRITENAMESPACEORDER = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        lpProviderId: ?*Guid,
        dwNumberOfEntries: u32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
    else => *const fn(
        lpProviderId: ?*Guid,
        dwNumberOfEntries: u32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
} ;

pub const sockaddr_un = extern struct {
    sun_family: u16,
    sun_path: [108]CHAR,
};

pub const sockaddr_ipx = extern struct {
    sa_family: i16,
    sa_netnum: [4]CHAR,
    sa_nodenum: [6]CHAR,
    sa_socket: u16,
};

pub const sockaddr_tp = extern struct {
    tp_family: u16,
    tp_addr_type: u16,
    tp_taddr_len: u16,
    tp_tsel_len: u16,
    tp_addr: [64]u8,
};

pub const sockaddr_nb = extern struct {
    snb_family: i16,
    snb_type: u16,
    snb_name: [16]CHAR,
};

pub const sockaddr_vns = extern struct {
    sin_family: u16,
    net_address: [4]u8,
    subnet_addr: [2]u8,
    port: [2]u8,
    hops: u8,
    filler: [5]u8,
};



pub const servent = switch(@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        s_name: ?PSTR,
        s_aliases: ?*?*i8,
        s_proto: ?PSTR,
        s_port: i16,
    },
    .X86 => extern struct {
        s_name: ?PSTR,
        s_aliases: ?*?*i8,
        s_port: i16,
        s_proto: ?PSTR,
    },
};
pub const WSAData = switch(@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        wVersion: u16,
        wHighVersion: u16,
        iMaxSockets: u16,
        iMaxUdpDg: u16,
        lpVendorInfo: ?PSTR,
        szDescription: [257]CHAR,
        szSystemStatus: [129]CHAR,
    },
    .X86 => extern struct {
        wVersion: u16,
        wHighVersion: u16,
        szDescription: [257]CHAR,
        szSystemStatus: [129]CHAR,
        iMaxSockets: u16,
        iMaxUdpDg: u16,
        lpVendorInfo: ?PSTR,
    },
};

//--------------------------------------------------------------------------------
// Section: Functions (203)
//--------------------------------------------------------------------------------
// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn __WSAFDIsSet(
    fd: ?SOCKET,
    param1: ?*fd_set,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn accept(
    s: ?SOCKET,
    // TODO: what to do with BytesParamIndex 2?
    addr: ?*SOCKADDR,
    addrlen: ?*i32,
) callconv(@import("std").os.windows.WINAPI) SOCKET;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn bind(
    s: ?SOCKET,
    // TODO: what to do with BytesParamIndex 2?
    name: ?*const SOCKADDR,
    namelen: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn closesocket(
    s: ?SOCKET,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ws2_32" fn connect(
    s: ?SOCKET,
    // TODO: what to do with BytesParamIndex 2?
    name: ?*const SOCKADDR,
    namelen: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn ioctlsocket(
    s: ?SOCKET,
    cmd: i32,
    argp: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn getpeername(
    s: ?SOCKET,
    // TODO: what to do with BytesParamIndex 2?
    name: ?*SOCKADDR,
    namelen: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn getsockname(
    s: ?SOCKET,
    // TODO: what to do with BytesParamIndex 2?
    name: ?*SOCKADDR,
    namelen: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn getsockopt(
    s: ?SOCKET,
    level: i32,
    optname: i32,
    // TODO: what to do with BytesParamIndex 4?
    optval: ?PSTR,
    optlen: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn htonl(
    hostlong: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn htons(
    hostshort: u16,
) callconv(@import("std").os.windows.WINAPI) u16;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn inet_addr(
    cp: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn inet_ntoa(
    in: IN_ADDR,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn listen(
    s: ?SOCKET,
    backlog: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn ntohl(
    netlong: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn ntohs(
    netshort: u16,
) callconv(@import("std").os.windows.WINAPI) u16;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn recv(
    s: ?SOCKET,
    // TODO: what to do with BytesParamIndex 2?
    buf: ?PSTR,
    len: i32,
    flags: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn recvfrom(
    s: ?SOCKET,
    // TODO: what to do with BytesParamIndex 2?
    buf: ?PSTR,
    len: i32,
    flags: i32,
    // TODO: what to do with BytesParamIndex 5?
    from: ?*SOCKADDR,
    fromlen: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn select(
    nfds: i32,
    readfds: ?*fd_set,
    writefds: ?*fd_set,
    exceptfds: ?*fd_set,
    timeout: ?*const timeval,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn send(
    s: ?SOCKET,
    // TODO: what to do with BytesParamIndex 2?
    buf: ?[*:0]const u8,
    len: i32,
    flags: SEND_FLAGS,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn sendto(
    s: ?SOCKET,
    // TODO: what to do with BytesParamIndex 2?
    buf: ?[*:0]const u8,
    len: i32,
    flags: i32,
    // TODO: what to do with BytesParamIndex 5?
    to: ?*const SOCKADDR,
    tolen: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn setsockopt(
    s: ?SOCKET,
    level: i32,
    optname: i32,
    // TODO: what to do with BytesParamIndex 4?
    optval: ?[*:0]const u8,
    optlen: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn shutdown(
    s: ?SOCKET,
    how: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn socket(
    af: i32,
    type: i32,
    protocol: i32,
) callconv(@import("std").os.windows.WINAPI) SOCKET;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn gethostbyaddr(
    // TODO: what to do with BytesParamIndex 1?
    addr: ?[*:0]const u8,
    len: i32,
    type: i32,
) callconv(@import("std").os.windows.WINAPI) ?*hostent;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn gethostbyname(
    name: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) ?*hostent;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn gethostname(
    // TODO: what to do with BytesParamIndex 1?
    name: ?PSTR,
    namelen: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn GetHostNameW(
    name: [*:0]u16,
    namelen: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn getservbyport(
    port: i32,
    proto: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) ?*servent;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn getservbyname(
    name: ?[*:0]const u8,
    proto: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) ?*servent;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn getprotobynumber(
    number: i32,
) callconv(@import("std").os.windows.WINAPI) ?*protoent;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn getprotobyname(
    name: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) ?*protoent;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSAStartup(
    wVersionRequested: u16,
    lpWSAData: ?*WSAData,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSACleanup(
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSASetLastError(
    iError: i32,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSAGetLastError(
) callconv(@import("std").os.windows.WINAPI) WSA_ERROR;

pub extern "ws2_32" fn WSAIsBlocking(
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "ws2_32" fn WSAUnhookBlockingHook(
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ws2_32" fn WSASetBlockingHook(
    lpBlockFunc: ?FARPROC,
) callconv(@import("std").os.windows.WINAPI) ?FARPROC;

pub extern "ws2_32" fn WSACancelBlockingCall(
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ws2_32" fn WSAAsyncGetServByName(
    hWnd: ?HWND,
    wMsg: u32,
    name: ?[*:0]const u8,
    proto: ?[*:0]const u8,
    // TODO: what to do with BytesParamIndex 5?
    buf: ?PSTR,
    buflen: i32,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ws2_32" fn WSAAsyncGetServByPort(
    hWnd: ?HWND,
    wMsg: u32,
    port: i32,
    proto: ?[*:0]const u8,
    // TODO: what to do with BytesParamIndex 5?
    buf: ?PSTR,
    buflen: i32,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ws2_32" fn WSAAsyncGetProtoByName(
    hWnd: ?HWND,
    wMsg: u32,
    name: ?[*:0]const u8,
    // TODO: what to do with BytesParamIndex 4?
    buf: ?PSTR,
    buflen: i32,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ws2_32" fn WSAAsyncGetProtoByNumber(
    hWnd: ?HWND,
    wMsg: u32,
    number: i32,
    // TODO: what to do with BytesParamIndex 4?
    buf: ?PSTR,
    buflen: i32,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ws2_32" fn WSAAsyncGetHostByName(
    hWnd: ?HWND,
    wMsg: u32,
    name: ?[*:0]const u8,
    // TODO: what to do with BytesParamIndex 4?
    buf: ?PSTR,
    buflen: i32,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ws2_32" fn WSAAsyncGetHostByAddr(
    hWnd: ?HWND,
    wMsg: u32,
    // TODO: what to do with BytesParamIndex 3?
    addr: ?[*:0]const u8,
    len: i32,
    type: i32,
    // TODO: what to do with BytesParamIndex 6?
    buf: ?PSTR,
    buflen: i32,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ws2_32" fn WSACancelAsyncRequest(
    hAsyncTaskHandle: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ws2_32" fn WSAAsyncSelect(
    s: ?SOCKET,
    hWnd: ?HWND,
    wMsg: u32,
    lEvent: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSAAccept(
    s: ?SOCKET,
    // TODO: what to do with BytesParamIndex 2?
    addr: ?*SOCKADDR,
    addrlen: ?*i32,
    lpfnCondition: ?LPCONDITIONPROC,
    dwCallbackData: usize,
) callconv(@import("std").os.windows.WINAPI) ?SOCKET;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSACloseEvent(
    hEvent: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSAConnect(
    s: ?SOCKET,
    // TODO: what to do with BytesParamIndex 2?
    name: ?*const SOCKADDR,
    namelen: i32,
    lpCallerData: ?*WSABUF,
    lpCalleeData: ?*WSABUF,
    lpSQOS: ?*QOS,
    lpGQOS: ?*QOS,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSAConnectByNameW(
    s: ?SOCKET,
    nodename: ?PWSTR,
    servicename: ?PWSTR,
    LocalAddressLength: ?*u32,
    // TODO: what to do with BytesParamIndex 3?
    LocalAddress: ?*SOCKADDR,
    RemoteAddressLength: ?*u32,
    // TODO: what to do with BytesParamIndex 5?
    RemoteAddress: ?*SOCKADDR,
    timeout: ?*const timeval,
    Reserved: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSAConnectByNameA(
    s: ?SOCKET,
    nodename: ?[*:0]const u8,
    servicename: ?[*:0]const u8,
    LocalAddressLength: ?*u32,
    // TODO: what to do with BytesParamIndex 3?
    LocalAddress: ?*SOCKADDR,
    RemoteAddressLength: ?*u32,
    // TODO: what to do with BytesParamIndex 5?
    RemoteAddress: ?*SOCKADDR,
    timeout: ?*const timeval,
    Reserved: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSAConnectByList(
    s: ?SOCKET,
    SocketAddress: ?*SOCKET_ADDRESS_LIST,
    LocalAddressLength: ?*u32,
    // TODO: what to do with BytesParamIndex 2?
    LocalAddress: ?*SOCKADDR,
    RemoteAddressLength: ?*u32,
    // TODO: what to do with BytesParamIndex 4?
    RemoteAddress: ?*SOCKADDR,
    timeout: ?*const timeval,
    Reserved: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSACreateEvent(
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSADuplicateSocketA(
    s: ?SOCKET,
    dwProcessId: u32,
    lpProtocolInfo: ?*WSAPROTOCOL_INFOA,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSADuplicateSocketW(
    s: ?SOCKET,
    dwProcessId: u32,
    lpProtocolInfo: ?*WSAPROTOCOL_INFOW,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSAEnumNetworkEvents(
    s: ?SOCKET,
    hEventObject: ?HANDLE,
    lpNetworkEvents: ?*WSANETWORKEVENTS,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSAEnumProtocolsA(
    lpiProtocols: ?*i32,
    // TODO: what to do with BytesParamIndex 2?
    lpProtocolBuffer: ?*WSAPROTOCOL_INFOA,
    lpdwBufferLength: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSAEnumProtocolsW(
    lpiProtocols: ?*i32,
    // TODO: what to do with BytesParamIndex 2?
    lpProtocolBuffer: ?*WSAPROTOCOL_INFOW,
    lpdwBufferLength: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSAEventSelect(
    s: ?SOCKET,
    hEventObject: ?HANDLE,
    lNetworkEvents: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSAGetOverlappedResult(
    s: ?SOCKET,
    lpOverlapped: ?*OVERLAPPED,
    lpcbTransfer: ?*u32,
    fWait: BOOL,
    lpdwFlags: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ws2_32" fn WSAGetQOSByName(
    s: ?SOCKET,
    lpQOSName: ?*WSABUF,
    lpQOS: ?*QOS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSAHtonl(
    s: ?SOCKET,
    hostlong: u32,
    lpnetlong: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSAHtons(
    s: ?SOCKET,
    hostshort: u16,
    lpnetshort: ?*u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSAIoctl(
    s: ?SOCKET,
    dwIoControlCode: u32,
    // TODO: what to do with BytesParamIndex 3?
    lpvInBuffer: ?*anyopaque,
    cbInBuffer: u32,
    // TODO: what to do with BytesParamIndex 5?
    lpvOutBuffer: ?*anyopaque,
    cbOutBuffer: u32,
    lpcbBytesReturned: ?*u32,
    lpOverlapped: ?*OVERLAPPED,
    lpCompletionRoutine: ?LPWSAOVERLAPPED_COMPLETION_ROUTINE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSAJoinLeaf(
    s: ?SOCKET,
    // TODO: what to do with BytesParamIndex 2?
    name: ?*const SOCKADDR,
    namelen: i32,
    lpCallerData: ?*WSABUF,
    lpCalleeData: ?*WSABUF,
    lpSQOS: ?*QOS,
    lpGQOS: ?*QOS,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) ?SOCKET;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSANtohl(
    s: ?SOCKET,
    netlong: u32,
    lphostlong: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSANtohs(
    s: ?SOCKET,
    netshort: u16,
    lphostshort: ?*u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSARecv(
    s: ?SOCKET,
    lpBuffers: [*]WSABUF,
    dwBufferCount: u32,
    lpNumberOfBytesRecvd: ?*u32,
    lpFlags: ?*u32,
    lpOverlapped: ?*OVERLAPPED,
    lpCompletionRoutine: ?LPWSAOVERLAPPED_COMPLETION_ROUTINE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ws2_32" fn WSARecvDisconnect(
    s: ?SOCKET,
    lpInboundDisconnectData: ?*WSABUF,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSARecvFrom(
    s: ?SOCKET,
    lpBuffers: [*]WSABUF,
    dwBufferCount: u32,
    lpNumberOfBytesRecvd: ?*u32,
    lpFlags: ?*u32,
    // TODO: what to do with BytesParamIndex 6?
    lpFrom: ?*SOCKADDR,
    lpFromlen: ?*i32,
    lpOverlapped: ?*OVERLAPPED,
    lpCompletionRoutine: ?LPWSAOVERLAPPED_COMPLETION_ROUTINE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSAResetEvent(
    hEvent: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSASend(
    s: ?SOCKET,
    lpBuffers: [*]WSABUF,
    dwBufferCount: u32,
    lpNumberOfBytesSent: ?*u32,
    dwFlags: u32,
    lpOverlapped: ?*OVERLAPPED,
    lpCompletionRoutine: ?LPWSAOVERLAPPED_COMPLETION_ROUTINE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSASendMsg(
    Handle: ?SOCKET,
    lpMsg: ?*WSAMSG,
    dwFlags: u32,
    lpNumberOfBytesSent: ?*u32,
    lpOverlapped: ?*OVERLAPPED,
    lpCompletionRoutine: ?LPWSAOVERLAPPED_COMPLETION_ROUTINE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ws2_32" fn WSASendDisconnect(
    s: ?SOCKET,
    lpOutboundDisconnectData: ?*WSABUF,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSASendTo(
    s: ?SOCKET,
    lpBuffers: [*]WSABUF,
    dwBufferCount: u32,
    lpNumberOfBytesSent: ?*u32,
    dwFlags: u32,
    // TODO: what to do with BytesParamIndex 6?
    lpTo: ?*const SOCKADDR,
    iTolen: i32,
    lpOverlapped: ?*OVERLAPPED,
    lpCompletionRoutine: ?LPWSAOVERLAPPED_COMPLETION_ROUTINE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSASetEvent(
    hEvent: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSASocketA(
    af: i32,
    type: i32,
    protocol: i32,
    lpProtocolInfo: ?*WSAPROTOCOL_INFOA,
    g: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) SOCKET;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSASocketW(
    af: i32,
    type: i32,
    protocol: i32,
    lpProtocolInfo: ?*WSAPROTOCOL_INFOW,
    g: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) SOCKET;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSAWaitForMultipleEvents(
    cEvents: u32,
    lphEvents: [*]const ?HANDLE,
    fWaitAll: BOOL,
    dwTimeout: u32,
    fAlertable: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSAAddressToStringA(
    // TODO: what to do with BytesParamIndex 1?
    lpsaAddress: ?*SOCKADDR,
    dwAddressLength: u32,
    lpProtocolInfo: ?*WSAPROTOCOL_INFOA,
    lpszAddressString: [*:0]u8,
    lpdwAddressStringLength: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSAAddressToStringW(
    // TODO: what to do with BytesParamIndex 1?
    lpsaAddress: ?*SOCKADDR,
    dwAddressLength: u32,
    lpProtocolInfo: ?*WSAPROTOCOL_INFOW,
    lpszAddressString: [*:0]u16,
    lpdwAddressStringLength: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSAStringToAddressA(
    AddressString: ?PSTR,
    AddressFamily: i32,
    lpProtocolInfo: ?*WSAPROTOCOL_INFOA,
    // TODO: what to do with BytesParamIndex 4?
    lpAddress: ?*SOCKADDR,
    lpAddressLength: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSAStringToAddressW(
    AddressString: ?PWSTR,
    AddressFamily: i32,
    lpProtocolInfo: ?*WSAPROTOCOL_INFOW,
    // TODO: what to do with BytesParamIndex 4?
    lpAddress: ?*SOCKADDR,
    lpAddressLength: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSALookupServiceBeginA(
    lpqsRestrictions: ?*WSAQUERYSETA,
    dwControlFlags: u32,
    lphLookup: ?*?HANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSALookupServiceBeginW(
    lpqsRestrictions: ?*WSAQUERYSETW,
    dwControlFlags: u32,
    lphLookup: ?*?HANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSALookupServiceNextA(
    hLookup: ?HANDLE,
    dwControlFlags: u32,
    lpdwBufferLength: ?*u32,
    // TODO: what to do with BytesParamIndex 2?
    lpqsResults: ?*WSAQUERYSETA,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSALookupServiceNextW(
    hLookup: ?HANDLE,
    dwControlFlags: u32,
    lpdwBufferLength: ?*u32,
    // TODO: what to do with BytesParamIndex 2?
    lpqsResults: ?*WSAQUERYSETW,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSANSPIoctl(
    hLookup: ?HANDLE,
    dwControlCode: u32,
    // TODO: what to do with BytesParamIndex 3?
    lpvInBuffer: ?*anyopaque,
    cbInBuffer: u32,
    // TODO: what to do with BytesParamIndex 5?
    lpvOutBuffer: ?*anyopaque,
    cbOutBuffer: u32,
    lpcbBytesReturned: ?*u32,
    lpCompletion: ?*WSACOMPLETION,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSALookupServiceEnd(
    hLookup: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ws2_32" fn WSAInstallServiceClassA(
    lpServiceClassInfo: ?*WSASERVICECLASSINFOA,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ws2_32" fn WSAInstallServiceClassW(
    lpServiceClassInfo: ?*WSASERVICECLASSINFOW,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ws2_32" fn WSARemoveServiceClass(
    lpServiceClassId: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ws2_32" fn WSAGetServiceClassInfoA(
    lpProviderId: ?*Guid,
    lpServiceClassId: ?*Guid,
    lpdwBufSize: ?*u32,
    // TODO: what to do with BytesParamIndex 2?
    lpServiceClassInfo: ?*WSASERVICECLASSINFOA,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ws2_32" fn WSAGetServiceClassInfoW(
    lpProviderId: ?*Guid,
    lpServiceClassId: ?*Guid,
    lpdwBufSize: ?*u32,
    // TODO: what to do with BytesParamIndex 2?
    lpServiceClassInfo: ?*WSASERVICECLASSINFOW,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSAEnumNameSpaceProvidersA(
    lpdwBufferLength: ?*u32,
    // TODO: what to do with BytesParamIndex 0?
    lpnspBuffer: ?*WSANAMESPACE_INFOA,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSAEnumNameSpaceProvidersW(
    lpdwBufferLength: ?*u32,
    // TODO: what to do with BytesParamIndex 0?
    lpnspBuffer: ?*WSANAMESPACE_INFOW,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSAEnumNameSpaceProvidersExA(
    lpdwBufferLength: ?*u32,
    // TODO: what to do with BytesParamIndex 0?
    lpnspBuffer: ?*WSANAMESPACE_INFOEXA,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSAEnumNameSpaceProvidersExW(
    lpdwBufferLength: ?*u32,
    // TODO: what to do with BytesParamIndex 0?
    lpnspBuffer: ?*WSANAMESPACE_INFOEXW,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ws2_32" fn WSAGetServiceClassNameByClassIdA(
    lpServiceClassId: ?*Guid,
    // TODO: what to do with BytesParamIndex 2?
    lpszServiceClassName: ?PSTR,
    lpdwBufferLength: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ws2_32" fn WSAGetServiceClassNameByClassIdW(
    lpServiceClassId: ?*Guid,
    // TODO: what to do with BytesParamIndex 2?
    lpszServiceClassName: ?PWSTR,
    lpdwBufferLength: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSASetServiceA(
    lpqsRegInfo: ?*WSAQUERYSETA,
    essoperation: WSAESETSERVICEOP,
    dwControlFlags: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSASetServiceW(
    lpqsRegInfo: ?*WSAQUERYSETW,
    essoperation: WSAESETSERVICEOP,
    dwControlFlags: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSAProviderConfigChange(
    lpNotificationHandle: ?*?HANDLE,
    lpOverlapped: ?*OVERLAPPED,
    lpCompletionRoutine: ?LPWSAOVERLAPPED_COMPLETION_ROUTINE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn WSAPoll(
    fdArray: ?*WSAPOLLFD,
    fds: u32,
    timeout: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ws2_32" fn ProcessSocketNotifications(
    completionPort: ?HANDLE,
    registrationCount: u32,
    registrationInfos: ?[*]SOCK_NOTIFY_REGISTRATION,
    timeoutMs: u32,
    completionCount: u32,
    completionPortEntries: ?[*]OVERLAPPED_ENTRY,
    receivedEntryCount: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ntdll" fn RtlIpv4AddressToStringA(
    Addr: ?*const IN_ADDR,
    S: *[16]u8,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "ntdll" fn RtlIpv4AddressToStringExA(
    Address: ?*const IN_ADDR,
    Port: u16,
    AddressString: [*:0]u8,
    AddressStringLength: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ntdll" fn RtlIpv4AddressToStringW(
    Addr: ?*const IN_ADDR,
    S: *[16]u16,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ntdll" fn RtlIpv4AddressToStringExW(
    Address: ?*const IN_ADDR,
    Port: u16,
    AddressString: [*:0]u16,
    AddressStringLength: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ntdll" fn RtlIpv4StringToAddressA(
    S: ?[*:0]const u8,
    Strict: BOOLEAN,
    Terminator: ?*?PSTR,
    Addr: ?*IN_ADDR,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ntdll" fn RtlIpv4StringToAddressExA(
    AddressString: ?[*:0]const u8,
    Strict: BOOLEAN,
    Address: ?*IN_ADDR,
    Port: ?*u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ntdll" fn RtlIpv4StringToAddressW(
    S: ?[*:0]const u16,
    Strict: BOOLEAN,
    Terminator: ?*?PWSTR,
    Addr: ?*IN_ADDR,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ntdll" fn RtlIpv4StringToAddressExW(
    AddressString: ?[*:0]const u16,
    Strict: BOOLEAN,
    Address: ?*IN_ADDR,
    Port: ?*u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ntdll" fn RtlIpv6AddressToStringA(
    Addr: ?*const IN6_ADDR,
    S: *[46]u8,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "ntdll" fn RtlIpv6AddressToStringExA(
    Address: ?*const IN6_ADDR,
    ScopeId: u32,
    Port: u16,
    AddressString: [*:0]u8,
    AddressStringLength: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ntdll" fn RtlIpv6AddressToStringW(
    Addr: ?*const IN6_ADDR,
    S: *[46]u16,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ntdll" fn RtlIpv6AddressToStringExW(
    Address: ?*const IN6_ADDR,
    ScopeId: u32,
    Port: u16,
    AddressString: [*:0]u16,
    AddressStringLength: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ntdll" fn RtlIpv6StringToAddressA(
    S: ?[*:0]const u8,
    Terminator: ?*?PSTR,
    Addr: ?*IN6_ADDR,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ntdll" fn RtlIpv6StringToAddressExA(
    AddressString: ?[*:0]const u8,
    Address: ?*IN6_ADDR,
    ScopeId: ?*u32,
    Port: ?*u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ntdll" fn RtlIpv6StringToAddressW(
    S: ?[*:0]const u16,
    Terminator: ?*?PWSTR,
    Addr: ?*IN6_ADDR,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ntdll" fn RtlIpv6StringToAddressExW(
    AddressString: ?[*:0]const u16,
    Address: ?*IN6_ADDR,
    ScopeId: ?*u32,
    Port: ?*u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "ntdll" fn RtlEthernetAddressToStringA(
    Addr: ?*const DL_EUI48,
    S: *[18]u8,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

// TODO: this type is limited to platform 'windows6.1'
pub extern "ntdll" fn RtlEthernetAddressToStringW(
    Addr: ?*const DL_EUI48,
    S: *[18]u16,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

// TODO: this type is limited to platform 'windows6.1'
pub extern "ntdll" fn RtlEthernetStringToAddressA(
    S: ?[*:0]const u8,
    Terminator: ?*?PSTR,
    Addr: ?*DL_EUI48,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "ntdll" fn RtlEthernetStringToAddressW(
    S: ?[*:0]const u16,
    Terminator: ?*?PWSTR,
    Addr: ?*DL_EUI48,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "mswsock" fn WSARecvEx(
    s: ?SOCKET,
    // TODO: what to do with BytesParamIndex 2?
    buf: ?PSTR,
    len: i32,
    flags: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "mswsock" fn TransmitFile(
    hSocket: ?SOCKET,
    hFile: ?HANDLE,
    nNumberOfBytesToWrite: u32,
    nNumberOfBytesPerSend: u32,
    lpOverlapped: ?*OVERLAPPED,
    lpTransmitBuffers: ?*TRANSMIT_FILE_BUFFERS,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.1'
pub extern "mswsock" fn AcceptEx(
    sListenSocket: ?SOCKET,
    sAcceptSocket: ?SOCKET,
    lpOutputBuffer: ?*anyopaque,
    dwReceiveDataLength: u32,
    dwLocalAddressLength: u32,
    dwRemoteAddressLength: u32,
    lpdwBytesReceived: ?*u32,
    lpOverlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.1'
pub extern "mswsock" fn GetAcceptExSockaddrs(
    lpOutputBuffer: ?*anyopaque,
    dwReceiveDataLength: u32,
    dwLocalAddressLength: u32,
    dwRemoteAddressLength: u32,
    LocalSockaddr: ?*?*SOCKADDR,
    LocalSockaddrLength: ?*i32,
    RemoteSockaddr: ?*?*SOCKADDR,
    RemoteSockaddrLength: ?*i32,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ws2_32" fn WSCEnumProtocols(
    lpiProtocols: ?*i32,
    // TODO: what to do with BytesParamIndex 2?
    lpProtocolBuffer: ?*WSAPROTOCOL_INFOW,
    lpdwBufferLength: ?*u32,
    lpErrno: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ws2_32" fn WSCEnumProtocols32(
    lpiProtocols: ?*i32,
    // TODO: what to do with BytesParamIndex 2?
    lpProtocolBuffer: ?*WSAPROTOCOL_INFOW,
    lpdwBufferLength: ?*u32,
    lpErrno: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

}, else => struct { } };

// TODO: this type is limited to platform 'windows5.0'
pub extern "ws2_32" fn WSCDeinstallProvider(
    lpProviderId: ?*Guid,
    lpErrno: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ws2_32" fn WSCDeinstallProvider32(
    lpProviderId: ?*Guid,
    lpErrno: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

}, else => struct { } };

// TODO: this type is limited to platform 'windows5.0'
pub extern "ws2_32" fn WSCInstallProvider(
    lpProviderId: ?*Guid,
    lpszProviderDllPath: ?[*:0]const u16,
    lpProtocolInfoList: [*]const WSAPROTOCOL_INFOW,
    dwNumberOfEntries: u32,
    lpErrno: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ws2_32" fn WSCInstallProvider64_32(
    lpProviderId: ?*Guid,
    lpszProviderDllPath: ?[*:0]const u16,
    lpProtocolInfoList: [*]const WSAPROTOCOL_INFOW,
    dwNumberOfEntries: u32,
    lpErrno: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

}, else => struct { } };

// TODO: this type is limited to platform 'windows5.0'
pub extern "ws2_32" fn WSCGetProviderPath(
    lpProviderId: ?*Guid,
    lpszProviderDllPath: [*:0]u16,
    lpProviderDllPathLen: ?*i32,
    lpErrno: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ws2_32" fn WSCGetProviderPath32(
    lpProviderId: ?*Guid,
    lpszProviderDllPath: [*:0]u16,
    lpProviderDllPathLen: ?*i32,
    lpErrno: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

}, else => struct { } };

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ws2_32" fn WSCUpdateProvider(
    lpProviderId: ?*Guid,
    lpszProviderDllPath: ?[*:0]const u16,
    lpProtocolInfoList: [*]const WSAPROTOCOL_INFOW,
    dwNumberOfEntries: u32,
    lpErrno: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ws2_32" fn WSCUpdateProvider32(
    lpProviderId: ?*Guid,
    lpszProviderDllPath: ?[*:0]const u16,
    lpProtocolInfoList: [*]const WSAPROTOCOL_INFOW,
    dwNumberOfEntries: u32,
    lpErrno: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

}, else => struct { } };

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ws2_32" fn WSCSetProviderInfo(
    lpProviderId: ?*Guid,
    InfoType: WSC_PROVIDER_INFO_TYPE,
    // TODO: what to do with BytesParamIndex 3?
    Info: ?*u8,
    InfoSize: usize,
    Flags: u32,
    lpErrno: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ws2_32" fn WSCGetProviderInfo(
    lpProviderId: ?*Guid,
    InfoType: WSC_PROVIDER_INFO_TYPE,
    // TODO: what to do with BytesParamIndex 3?
    Info: ?*u8,
    InfoSize: ?*usize,
    Flags: u32,
    lpErrno: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ws2_32" fn WSCSetProviderInfo32(
    lpProviderId: ?*Guid,
    InfoType: WSC_PROVIDER_INFO_TYPE,
    // TODO: what to do with BytesParamIndex 3?
    Info: ?*u8,
    InfoSize: usize,
    Flags: u32,
    lpErrno: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ws2_32" fn WSCGetProviderInfo32(
    lpProviderId: ?*Guid,
    InfoType: WSC_PROVIDER_INFO_TYPE,
    // TODO: what to do with BytesParamIndex 3?
    Info: ?*u8,
    InfoSize: ?*usize,
    Flags: u32,
    lpErrno: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

}, else => struct { } };

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ws2_32" fn WSCSetApplicationCategory(
    Path: [*:0]const u16,
    PathLength: u32,
    Extra: ?[*:0]const u16,
    ExtraLength: u32,
    PermittedLspCategories: u32,
    pPrevPermLspCat: ?*u32,
    lpErrno: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ws2_32" fn WSCGetApplicationCategory(
    Path: [*:0]const u16,
    PathLength: u32,
    Extra: ?[*:0]const u16,
    ExtraLength: u32,
    pPermittedLspCategories: ?*u32,
    lpErrno: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ws2_32" fn WPUCompleteOverlappedRequest(
    s: ?SOCKET,
    lpOverlapped: ?*OVERLAPPED,
    dwError: u32,
    cbTransferred: u32,
    lpErrno: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ws2_32" fn WSCEnumNameSpaceProviders32(
    lpdwBufferLength: ?*u32,
    // TODO: what to do with BytesParamIndex 0?
    lpnspBuffer: ?*WSANAMESPACE_INFOW,
) callconv(@import("std").os.windows.WINAPI) i32;

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ws2_32" fn WSCEnumNameSpaceProvidersEx32(
    lpdwBufferLength: ?*u32,
    // TODO: what to do with BytesParamIndex 0?
    lpnspBuffer: ?*WSANAMESPACE_INFOEXW,
) callconv(@import("std").os.windows.WINAPI) i32;

}, else => struct { } };

// TODO: this type is limited to platform 'windows5.0'
pub extern "ws2_32" fn WSCInstallNameSpace(
    lpszIdentifier: ?PWSTR,
    lpszPathName: ?PWSTR,
    dwNameSpace: u32,
    dwVersion: u32,
    lpProviderId: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) i32;

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ws2_32" fn WSCInstallNameSpace32(
    lpszIdentifier: ?PWSTR,
    lpszPathName: ?PWSTR,
    dwNameSpace: u32,
    dwVersion: u32,
    lpProviderId: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) i32;

}, else => struct { } };

// TODO: this type is limited to platform 'windows5.0'
pub extern "ws2_32" fn WSCUnInstallNameSpace(
    lpProviderId: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ws2_32" fn WSCInstallNameSpaceEx(
    lpszIdentifier: ?PWSTR,
    lpszPathName: ?PWSTR,
    dwNameSpace: u32,
    dwVersion: u32,
    lpProviderId: ?*Guid,
    lpProviderSpecific: ?*BLOB,
) callconv(@import("std").os.windows.WINAPI) i32;

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ws2_32" fn WSCInstallNameSpaceEx32(
    lpszIdentifier: ?PWSTR,
    lpszPathName: ?PWSTR,
    dwNameSpace: u32,
    dwVersion: u32,
    lpProviderId: ?*Guid,
    lpProviderSpecific: ?*BLOB,
) callconv(@import("std").os.windows.WINAPI) i32;

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ws2_32" fn WSCUnInstallNameSpace32(
    lpProviderId: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) i32;

}, else => struct { } };

// TODO: this type is limited to platform 'windows5.0'
pub extern "ws2_32" fn WSCEnableNSProvider(
    lpProviderId: ?*Guid,
    fEnable: BOOL,
) callconv(@import("std").os.windows.WINAPI) i32;

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ws2_32" fn WSCEnableNSProvider32(
    lpProviderId: ?*Guid,
    fEnable: BOOL,
) callconv(@import("std").os.windows.WINAPI) i32;

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ws2_32" fn WSCInstallProviderAndChains64_32(
    lpProviderId: ?*Guid,
    lpszProviderDllPath: ?[*:0]const u16,
    lpszProviderDllPath32: ?[*:0]const u16,
    lpszLspName: ?[*:0]const u16,
    dwServiceFlags: u32,
    lpProtocolInfoList: [*]WSAPROTOCOL_INFOW,
    dwNumberOfEntries: u32,
    lpdwCatalogEntryId: ?*u32,
    lpErrno: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

}, else => struct { } };

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ws2_32" fn WSAAdvertiseProvider(
    puuidProviderId: ?*const Guid,
    pNSPv2Routine: ?*const NSPV2_ROUTINE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ws2_32" fn WSAUnadvertiseProvider(
    puuidProviderId: ?*const Guid,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ws2_32" fn WSAProviderCompleteAsyncCall(
    hAsyncCall: ?HANDLE,
    iRetCode: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "mswsock" fn EnumProtocolsA(
    lpiProtocols: ?*i32,
    // TODO: what to do with BytesParamIndex 2?
    lpProtocolBuffer: ?*anyopaque,
    lpdwBufferLength: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "mswsock" fn EnumProtocolsW(
    lpiProtocols: ?*i32,
    // TODO: what to do with BytesParamIndex 2?
    lpProtocolBuffer: ?*anyopaque,
    lpdwBufferLength: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "mswsock" fn GetAddressByNameA(
    dwNameSpace: u32,
    lpServiceType: ?*Guid,
    lpServiceName: ?PSTR,
    lpiProtocols: ?*i32,
    dwResolution: u32,
    lpServiceAsyncInfo: ?*SERVICE_ASYNC_INFO,
    // TODO: what to do with BytesParamIndex 7?
    lpCsaddrBuffer: ?*anyopaque,
    lpdwBufferLength: ?*u32,
    lpAliasBuffer: ?[*:0]u8,
    lpdwAliasBufferLength: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "mswsock" fn GetAddressByNameW(
    dwNameSpace: u32,
    lpServiceType: ?*Guid,
    lpServiceName: ?PWSTR,
    lpiProtocols: ?*i32,
    dwResolution: u32,
    lpServiceAsyncInfo: ?*SERVICE_ASYNC_INFO,
    // TODO: what to do with BytesParamIndex 7?
    lpCsaddrBuffer: ?*anyopaque,
    lpdwBufferLength: ?*u32,
    lpAliasBuffer: ?[*:0]u16,
    lpdwAliasBufferLength: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "mswsock" fn GetTypeByNameA(
    lpServiceName: ?PSTR,
    lpServiceType: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "mswsock" fn GetTypeByNameW(
    lpServiceName: ?PWSTR,
    lpServiceType: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "mswsock" fn GetNameByTypeA(
    lpServiceType: ?*Guid,
    // TODO: what to do with BytesParamIndex 2?
    lpServiceName: ?PSTR,
    dwNameLength: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "mswsock" fn GetNameByTypeW(
    lpServiceType: ?*Guid,
    // TODO: what to do with BytesParamIndex 2?
    lpServiceName: ?PWSTR,
    dwNameLength: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "mswsock" fn SetServiceA(
    dwNameSpace: u32,
    dwOperation: SET_SERVICE_OPERATION,
    dwFlags: u32,
    lpServiceInfo: ?*SERVICE_INFOA,
    lpServiceAsyncInfo: ?*SERVICE_ASYNC_INFO,
    lpdwStatusFlags: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "mswsock" fn SetServiceW(
    dwNameSpace: u32,
    dwOperation: SET_SERVICE_OPERATION,
    dwFlags: u32,
    lpServiceInfo: ?*SERVICE_INFOW,
    lpServiceAsyncInfo: ?*SERVICE_ASYNC_INFO,
    lpdwStatusFlags: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "mswsock" fn GetServiceA(
    dwNameSpace: u32,
    lpGuid: ?*Guid,
    lpServiceName: ?PSTR,
    dwProperties: u32,
    // TODO: what to do with BytesParamIndex 5?
    lpBuffer: ?*anyopaque,
    lpdwBufferSize: ?*u32,
    lpServiceAsyncInfo: ?*SERVICE_ASYNC_INFO,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "mswsock" fn GetServiceW(
    dwNameSpace: u32,
    lpGuid: ?*Guid,
    lpServiceName: ?PWSTR,
    dwProperties: u32,
    // TODO: what to do with BytesParamIndex 5?
    lpBuffer: ?*anyopaque,
    lpdwBufferSize: ?*u32,
    lpServiceAsyncInfo: ?*SERVICE_ASYNC_INFO,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn getaddrinfo(
    pNodeName: ?[*:0]const u8,
    pServiceName: ?[*:0]const u8,
    pHints: ?*const ADDRINFOA,
    ppResult: ?*?*ADDRINFOA,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn GetAddrInfoW(
    pNodeName: ?[*:0]const u16,
    pServiceName: ?[*:0]const u16,
    pHints: ?*const addrinfoW,
    ppResult: ?*?*addrinfoW,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ws2_32" fn GetAddrInfoExA(
    pName: ?[*:0]const u8,
    pServiceName: ?[*:0]const u8,
    dwNameSpace: u32,
    lpNspId: ?*Guid,
    hints: ?*const addrinfoexA,
    ppResult: ?*?*addrinfoexA,
    timeout: ?*timeval,
    lpOverlapped: ?*OVERLAPPED,
    lpCompletionRoutine: ?LPLOOKUPSERVICE_COMPLETION_ROUTINE,
    lpNameHandle: ?*?HANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ws2_32" fn GetAddrInfoExW(
    pName: ?[*:0]const u16,
    pServiceName: ?[*:0]const u16,
    dwNameSpace: u32,
    lpNspId: ?*Guid,
    hints: ?*const addrinfoexW,
    ppResult: ?*?*addrinfoexW,
    timeout: ?*timeval,
    lpOverlapped: ?*OVERLAPPED,
    lpCompletionRoutine: ?LPLOOKUPSERVICE_COMPLETION_ROUTINE,
    lpHandle: ?*?HANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn GetAddrInfoExCancel(
    lpHandle: ?*?HANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn GetAddrInfoExOverlappedResult(
    lpOverlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn SetAddrInfoExA(
    pName: ?[*:0]const u8,
    pServiceName: ?[*:0]const u8,
    pAddresses: ?*SOCKET_ADDRESS,
    dwAddressCount: u32,
    lpBlob: ?*BLOB,
    dwFlags: u32,
    dwNameSpace: u32,
    lpNspId: ?*Guid,
    timeout: ?*timeval,
    lpOverlapped: ?*OVERLAPPED,
    lpCompletionRoutine: ?LPLOOKUPSERVICE_COMPLETION_ROUTINE,
    lpNameHandle: ?*?HANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn SetAddrInfoExW(
    pName: ?[*:0]const u16,
    pServiceName: ?[*:0]const u16,
    pAddresses: ?*SOCKET_ADDRESS,
    dwAddressCount: u32,
    lpBlob: ?*BLOB,
    dwFlags: u32,
    dwNameSpace: u32,
    lpNspId: ?*Guid,
    timeout: ?*timeval,
    lpOverlapped: ?*OVERLAPPED,
    lpCompletionRoutine: ?LPLOOKUPSERVICE_COMPLETION_ROUTINE,
    lpNameHandle: ?*?HANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn freeaddrinfo(
    pAddrInfo: ?*ADDRINFOA,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn FreeAddrInfoW(
    pAddrInfo: ?*addrinfoW,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn FreeAddrInfoEx(
    pAddrInfoEx: ?*addrinfoexA,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn FreeAddrInfoExW(
    pAddrInfoEx: ?*addrinfoexW,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn getnameinfo(
    // TODO: what to do with BytesParamIndex 1?
    pSockaddr: ?*const SOCKADDR,
    SockaddrLength: i32,
    pNodeBuffer: ?[*]u8,
    NodeBufferSize: u32,
    pServiceBuffer: ?[*]u8,
    ServiceBufferSize: u32,
    Flags: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn GetNameInfoW(
    // TODO: what to do with BytesParamIndex 1?
    pSockaddr: ?*const SOCKADDR,
    SockaddrLength: i32,
    pNodeBuffer: ?[*]u16,
    NodeBufferSize: u32,
    pServiceBuffer: ?[*]u16,
    ServiceBufferSize: u32,
    Flags: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn inet_pton(
    Family: i32,
    pszAddrString: ?[*:0]const u8,
    pAddrBuf: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn InetPtonW(
    Family: i32,
    pszAddrString: ?[*:0]const u16,
    pAddrBuf: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn inet_ntop(
    Family: i32,
    pAddr: ?*const anyopaque,
    pStringBuf: [*:0]u8,
    StringBufSize: usize,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

// TODO: this type is limited to platform 'windows8.1'
pub extern "ws2_32" fn InetNtopW(
    Family: i32,
    pAddr: ?*const anyopaque,
    pStringBuf: [*:0]u16,
    StringBufSize: usize,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "fwpuclnt" fn WSASetSocketSecurity(
    Socket: ?SOCKET,
    // TODO: what to do with BytesParamIndex 2?
    SecuritySettings: ?*const SOCKET_SECURITY_SETTINGS,
    SecuritySettingsLen: u32,
    Overlapped: ?*OVERLAPPED,
    CompletionRoutine: ?LPWSAOVERLAPPED_COMPLETION_ROUTINE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "fwpuclnt" fn WSAQuerySocketSecurity(
    Socket: ?SOCKET,
    // TODO: what to do with BytesParamIndex 2?
    SecurityQueryTemplate: ?*const SOCKET_SECURITY_QUERY_TEMPLATE,
    SecurityQueryTemplateLen: u32,
    // TODO: what to do with BytesParamIndex 4?
    SecurityQueryInfo: ?*SOCKET_SECURITY_QUERY_INFO,
    SecurityQueryInfoLen: ?*u32,
    Overlapped: ?*OVERLAPPED,
    CompletionRoutine: ?LPWSAOVERLAPPED_COMPLETION_ROUTINE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "fwpuclnt" fn WSASetSocketPeerTargetName(
    Socket: ?SOCKET,
    // TODO: what to do with BytesParamIndex 2?
    PeerTargetName: ?*const SOCKET_PEER_TARGET_NAME,
    PeerTargetNameLen: u32,
    Overlapped: ?*OVERLAPPED,
    CompletionRoutine: ?LPWSAOVERLAPPED_COMPLETION_ROUTINE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "fwpuclnt" fn WSADeleteSocketPeerTargetName(
    Socket: ?SOCKET,
    // TODO: what to do with BytesParamIndex 2?
    PeerAddr: ?*const SOCKADDR,
    PeerAddrLen: u32,
    Overlapped: ?*OVERLAPPED,
    CompletionRoutine: ?LPWSAOVERLAPPED_COMPLETION_ROUTINE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "fwpuclnt" fn WSAImpersonateSocketPeer(
    Socket: ?SOCKET,
    // TODO: what to do with BytesParamIndex 2?
    PeerAddr: ?*const SOCKADDR,
    PeerAddrLen: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "fwpuclnt" fn WSARevertImpersonation(
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "windows.networking" fn SetSocketMediaStreamingMode(
    value: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ws2_32" fn WSCWriteProviderOrder(
    lpwdCatalogEntryId: ?*u32,
    dwNumberOfEntries: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ws2_32" fn WSCWriteProviderOrder32(
    lpwdCatalogEntryId: ?*u32,
    dwNumberOfEntries: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

}, else => struct { } };

// TODO: this type is limited to platform 'windows5.0'
pub extern "ws2_32" fn WSCWriteNameSpaceOrder(
    lpProviderId: ?*Guid,
    dwNumberOfEntries: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ws2_32" fn WSCWriteNameSpaceOrder32(
    lpProviderId: ?*Guid,
    dwNumberOfEntries: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

}, else => struct { } };


//--------------------------------------------------------------------------------
// Section: Unicode Aliases (48)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
        pub const addrinfoex = thismodule.addrinfoexA;
        pub const addrinfoex2 = thismodule.addrinfoex2A;
        pub const WSAPROTOCOL_INFO = thismodule.WSAPROTOCOL_INFOA;
        pub const WSAQUERYSET = thismodule.WSAQUERYSETA;
        pub const WSAQUERYSET2 = thismodule.WSAQUERYSET2A;
        pub const WSANSCLASSINFO = thismodule.WSANSCLASSINFOA;
        pub const WSASERVICECLASSINFO = thismodule.WSASERVICECLASSINFOA;
        pub const WSANAMESPACE_INFO = thismodule.WSANAMESPACE_INFOA;
        pub const WSANAMESPACE_INFOEX = thismodule.WSANAMESPACE_INFOEXA;
        pub const NS_INFO = thismodule.NS_INFOA;
        pub const SERVICE_TYPE_VALUE_ABS = thismodule.SERVICE_TYPE_VALUE_ABSA;
        pub const SERVICE_TYPE_INFO_ABS = thismodule.SERVICE_TYPE_INFO_ABSA;
        pub const SERVICE_INFO = thismodule.SERVICE_INFOA;
        pub const NS_SERVICE_INFO = thismodule.NS_SERVICE_INFOA;
        pub const PROTOCOL_INFO = thismodule.PROTOCOL_INFOA;
        pub const NETRESOURCE2 = thismodule.NETRESOURCE2A;
        pub const WSAConnectByName = thismodule.WSAConnectByNameA;
        pub const WSADuplicateSocket = thismodule.WSADuplicateSocketA;
        pub const WSAEnumProtocols = thismodule.WSAEnumProtocolsA;
        pub const WSASocket = thismodule.WSASocketA;
        pub const WSAAddressToString = thismodule.WSAAddressToStringA;
        pub const WSAStringToAddress = thismodule.WSAStringToAddressA;
        pub const WSALookupServiceBegin = thismodule.WSALookupServiceBeginA;
        pub const WSALookupServiceNext = thismodule.WSALookupServiceNextA;
        pub const WSAInstallServiceClass = thismodule.WSAInstallServiceClassA;
        pub const WSAGetServiceClassInfo = thismodule.WSAGetServiceClassInfoA;
        pub const WSAEnumNameSpaceProviders = thismodule.WSAEnumNameSpaceProvidersA;
        pub const WSAEnumNameSpaceProvidersEx = thismodule.WSAEnumNameSpaceProvidersExA;
        pub const WSAGetServiceClassNameByClassId = thismodule.WSAGetServiceClassNameByClassIdA;
        pub const WSASetService = thismodule.WSASetServiceA;
        pub const RtlIpv4AddressToString = thismodule.RtlIpv4AddressToStringA;
        pub const RtlIpv4AddressToStringEx = thismodule.RtlIpv4AddressToStringExA;
        pub const RtlIpv4StringToAddress = thismodule.RtlIpv4StringToAddressA;
        pub const RtlIpv4StringToAddressEx = thismodule.RtlIpv4StringToAddressExA;
        pub const RtlIpv6AddressToString = thismodule.RtlIpv6AddressToStringA;
        pub const RtlIpv6AddressToStringEx = thismodule.RtlIpv6AddressToStringExA;
        pub const RtlIpv6StringToAddress = thismodule.RtlIpv6StringToAddressA;
        pub const RtlIpv6StringToAddressEx = thismodule.RtlIpv6StringToAddressExA;
        pub const RtlEthernetAddressToString = thismodule.RtlEthernetAddressToStringA;
        pub const RtlEthernetStringToAddress = thismodule.RtlEthernetStringToAddressA;
        pub const EnumProtocols = thismodule.EnumProtocolsA;
        pub const GetAddressByName = thismodule.GetAddressByNameA;
        pub const GetTypeByName = thismodule.GetTypeByNameA;
        pub const GetNameByType = thismodule.GetNameByTypeA;
        pub const SetService = thismodule.SetServiceA;
        pub const GetService = thismodule.GetServiceA;
        pub const GetAddrInfoEx = thismodule.GetAddrInfoExA;
        pub const SetAddrInfoEx = thismodule.SetAddrInfoExA;
    },
    .wide => struct {
        pub const addrinfoex = thismodule.addrinfoexW;
        pub const addrinfoex2 = thismodule.addrinfoex2W;
        pub const WSAPROTOCOL_INFO = thismodule.WSAPROTOCOL_INFOW;
        pub const WSAQUERYSET = thismodule.WSAQUERYSETW;
        pub const WSAQUERYSET2 = thismodule.WSAQUERYSET2W;
        pub const WSANSCLASSINFO = thismodule.WSANSCLASSINFOW;
        pub const WSASERVICECLASSINFO = thismodule.WSASERVICECLASSINFOW;
        pub const WSANAMESPACE_INFO = thismodule.WSANAMESPACE_INFOW;
        pub const WSANAMESPACE_INFOEX = thismodule.WSANAMESPACE_INFOEXW;
        pub const NS_INFO = thismodule.NS_INFOW;
        pub const SERVICE_TYPE_VALUE_ABS = thismodule.SERVICE_TYPE_VALUE_ABSW;
        pub const SERVICE_TYPE_INFO_ABS = thismodule.SERVICE_TYPE_INFO_ABSW;
        pub const SERVICE_INFO = thismodule.SERVICE_INFOW;
        pub const NS_SERVICE_INFO = thismodule.NS_SERVICE_INFOW;
        pub const PROTOCOL_INFO = thismodule.PROTOCOL_INFOW;
        pub const NETRESOURCE2 = thismodule.NETRESOURCE2W;
        pub const WSAConnectByName = thismodule.WSAConnectByNameW;
        pub const WSADuplicateSocket = thismodule.WSADuplicateSocketW;
        pub const WSAEnumProtocols = thismodule.WSAEnumProtocolsW;
        pub const WSASocket = thismodule.WSASocketW;
        pub const WSAAddressToString = thismodule.WSAAddressToStringW;
        pub const WSAStringToAddress = thismodule.WSAStringToAddressW;
        pub const WSALookupServiceBegin = thismodule.WSALookupServiceBeginW;
        pub const WSALookupServiceNext = thismodule.WSALookupServiceNextW;
        pub const WSAInstallServiceClass = thismodule.WSAInstallServiceClassW;
        pub const WSAGetServiceClassInfo = thismodule.WSAGetServiceClassInfoW;
        pub const WSAEnumNameSpaceProviders = thismodule.WSAEnumNameSpaceProvidersW;
        pub const WSAEnumNameSpaceProvidersEx = thismodule.WSAEnumNameSpaceProvidersExW;
        pub const WSAGetServiceClassNameByClassId = thismodule.WSAGetServiceClassNameByClassIdW;
        pub const WSASetService = thismodule.WSASetServiceW;
        pub const RtlIpv4AddressToString = thismodule.RtlIpv4AddressToStringW;
        pub const RtlIpv4AddressToStringEx = thismodule.RtlIpv4AddressToStringExW;
        pub const RtlIpv4StringToAddress = thismodule.RtlIpv4StringToAddressW;
        pub const RtlIpv4StringToAddressEx = thismodule.RtlIpv4StringToAddressExW;
        pub const RtlIpv6AddressToString = thismodule.RtlIpv6AddressToStringW;
        pub const RtlIpv6AddressToStringEx = thismodule.RtlIpv6AddressToStringExW;
        pub const RtlIpv6StringToAddress = thismodule.RtlIpv6StringToAddressW;
        pub const RtlIpv6StringToAddressEx = thismodule.RtlIpv6StringToAddressExW;
        pub const RtlEthernetAddressToString = thismodule.RtlEthernetAddressToStringW;
        pub const RtlEthernetStringToAddress = thismodule.RtlEthernetStringToAddressW;
        pub const EnumProtocols = thismodule.EnumProtocolsW;
        pub const GetAddressByName = thismodule.GetAddressByNameW;
        pub const GetTypeByName = thismodule.GetTypeByNameW;
        pub const GetNameByType = thismodule.GetNameByTypeW;
        pub const SetService = thismodule.SetServiceW;
        pub const GetService = thismodule.GetServiceW;
        pub const GetAddrInfoEx = thismodule.GetAddrInfoExW;
        pub const SetAddrInfoEx = thismodule.SetAddrInfoExW;
    },
    .unspecified => if (@import("builtin").is_test) struct {
        pub const addrinfoex = *opaque{};
        pub const addrinfoex2 = *opaque{};
        pub const WSAPROTOCOL_INFO = *opaque{};
        pub const WSAQUERYSET = *opaque{};
        pub const WSAQUERYSET2 = *opaque{};
        pub const WSANSCLASSINFO = *opaque{};
        pub const WSASERVICECLASSINFO = *opaque{};
        pub const WSANAMESPACE_INFO = *opaque{};
        pub const WSANAMESPACE_INFOEX = *opaque{};
        pub const NS_INFO = *opaque{};
        pub const SERVICE_TYPE_VALUE_ABS = *opaque{};
        pub const SERVICE_TYPE_INFO_ABS = *opaque{};
        pub const SERVICE_INFO = *opaque{};
        pub const NS_SERVICE_INFO = *opaque{};
        pub const PROTOCOL_INFO = *opaque{};
        pub const NETRESOURCE2 = *opaque{};
        pub const WSAConnectByName = *opaque{};
        pub const WSADuplicateSocket = *opaque{};
        pub const WSAEnumProtocols = *opaque{};
        pub const WSASocket = *opaque{};
        pub const WSAAddressToString = *opaque{};
        pub const WSAStringToAddress = *opaque{};
        pub const WSALookupServiceBegin = *opaque{};
        pub const WSALookupServiceNext = *opaque{};
        pub const WSAInstallServiceClass = *opaque{};
        pub const WSAGetServiceClassInfo = *opaque{};
        pub const WSAEnumNameSpaceProviders = *opaque{};
        pub const WSAEnumNameSpaceProvidersEx = *opaque{};
        pub const WSAGetServiceClassNameByClassId = *opaque{};
        pub const WSASetService = *opaque{};
        pub const RtlIpv4AddressToString = *opaque{};
        pub const RtlIpv4AddressToStringEx = *opaque{};
        pub const RtlIpv4StringToAddress = *opaque{};
        pub const RtlIpv4StringToAddressEx = *opaque{};
        pub const RtlIpv6AddressToString = *opaque{};
        pub const RtlIpv6AddressToStringEx = *opaque{};
        pub const RtlIpv6StringToAddress = *opaque{};
        pub const RtlIpv6StringToAddressEx = *opaque{};
        pub const RtlEthernetAddressToString = *opaque{};
        pub const RtlEthernetStringToAddress = *opaque{};
        pub const EnumProtocols = *opaque{};
        pub const GetAddressByName = *opaque{};
        pub const GetTypeByName = *opaque{};
        pub const GetNameByType = *opaque{};
        pub const SetService = *opaque{};
        pub const GetService = *opaque{};
        pub const GetAddrInfoEx = *opaque{};
        pub const SetAddrInfoEx = *opaque{};
    } else struct {
        pub const addrinfoex = @compileError("'addrinfoex' requires that UNICODE be set to true or false in the root module");
        pub const addrinfoex2 = @compileError("'addrinfoex2' requires that UNICODE be set to true or false in the root module");
        pub const WSAPROTOCOL_INFO = @compileError("'WSAPROTOCOL_INFO' requires that UNICODE be set to true or false in the root module");
        pub const WSAQUERYSET = @compileError("'WSAQUERYSET' requires that UNICODE be set to true or false in the root module");
        pub const WSAQUERYSET2 = @compileError("'WSAQUERYSET2' requires that UNICODE be set to true or false in the root module");
        pub const WSANSCLASSINFO = @compileError("'WSANSCLASSINFO' requires that UNICODE be set to true or false in the root module");
        pub const WSASERVICECLASSINFO = @compileError("'WSASERVICECLASSINFO' requires that UNICODE be set to true or false in the root module");
        pub const WSANAMESPACE_INFO = @compileError("'WSANAMESPACE_INFO' requires that UNICODE be set to true or false in the root module");
        pub const WSANAMESPACE_INFOEX = @compileError("'WSANAMESPACE_INFOEX' requires that UNICODE be set to true or false in the root module");
        pub const NS_INFO = @compileError("'NS_INFO' requires that UNICODE be set to true or false in the root module");
        pub const SERVICE_TYPE_VALUE_ABS = @compileError("'SERVICE_TYPE_VALUE_ABS' requires that UNICODE be set to true or false in the root module");
        pub const SERVICE_TYPE_INFO_ABS = @compileError("'SERVICE_TYPE_INFO_ABS' requires that UNICODE be set to true or false in the root module");
        pub const SERVICE_INFO = @compileError("'SERVICE_INFO' requires that UNICODE be set to true or false in the root module");
        pub const NS_SERVICE_INFO = @compileError("'NS_SERVICE_INFO' requires that UNICODE be set to true or false in the root module");
        pub const PROTOCOL_INFO = @compileError("'PROTOCOL_INFO' requires that UNICODE be set to true or false in the root module");
        pub const NETRESOURCE2 = @compileError("'NETRESOURCE2' requires that UNICODE be set to true or false in the root module");
        pub const WSAConnectByName = @compileError("'WSAConnectByName' requires that UNICODE be set to true or false in the root module");
        pub const WSADuplicateSocket = @compileError("'WSADuplicateSocket' requires that UNICODE be set to true or false in the root module");
        pub const WSAEnumProtocols = @compileError("'WSAEnumProtocols' requires that UNICODE be set to true or false in the root module");
        pub const WSASocket = @compileError("'WSASocket' requires that UNICODE be set to true or false in the root module");
        pub const WSAAddressToString = @compileError("'WSAAddressToString' requires that UNICODE be set to true or false in the root module");
        pub const WSAStringToAddress = @compileError("'WSAStringToAddress' requires that UNICODE be set to true or false in the root module");
        pub const WSALookupServiceBegin = @compileError("'WSALookupServiceBegin' requires that UNICODE be set to true or false in the root module");
        pub const WSALookupServiceNext = @compileError("'WSALookupServiceNext' requires that UNICODE be set to true or false in the root module");
        pub const WSAInstallServiceClass = @compileError("'WSAInstallServiceClass' requires that UNICODE be set to true or false in the root module");
        pub const WSAGetServiceClassInfo = @compileError("'WSAGetServiceClassInfo' requires that UNICODE be set to true or false in the root module");
        pub const WSAEnumNameSpaceProviders = @compileError("'WSAEnumNameSpaceProviders' requires that UNICODE be set to true or false in the root module");
        pub const WSAEnumNameSpaceProvidersEx = @compileError("'WSAEnumNameSpaceProvidersEx' requires that UNICODE be set to true or false in the root module");
        pub const WSAGetServiceClassNameByClassId = @compileError("'WSAGetServiceClassNameByClassId' requires that UNICODE be set to true or false in the root module");
        pub const WSASetService = @compileError("'WSASetService' requires that UNICODE be set to true or false in the root module");
        pub const RtlIpv4AddressToString = @compileError("'RtlIpv4AddressToString' requires that UNICODE be set to true or false in the root module");
        pub const RtlIpv4AddressToStringEx = @compileError("'RtlIpv4AddressToStringEx' requires that UNICODE be set to true or false in the root module");
        pub const RtlIpv4StringToAddress = @compileError("'RtlIpv4StringToAddress' requires that UNICODE be set to true or false in the root module");
        pub const RtlIpv4StringToAddressEx = @compileError("'RtlIpv4StringToAddressEx' requires that UNICODE be set to true or false in the root module");
        pub const RtlIpv6AddressToString = @compileError("'RtlIpv6AddressToString' requires that UNICODE be set to true or false in the root module");
        pub const RtlIpv6AddressToStringEx = @compileError("'RtlIpv6AddressToStringEx' requires that UNICODE be set to true or false in the root module");
        pub const RtlIpv6StringToAddress = @compileError("'RtlIpv6StringToAddress' requires that UNICODE be set to true or false in the root module");
        pub const RtlIpv6StringToAddressEx = @compileError("'RtlIpv6StringToAddressEx' requires that UNICODE be set to true or false in the root module");
        pub const RtlEthernetAddressToString = @compileError("'RtlEthernetAddressToString' requires that UNICODE be set to true or false in the root module");
        pub const RtlEthernetStringToAddress = @compileError("'RtlEthernetStringToAddress' requires that UNICODE be set to true or false in the root module");
        pub const EnumProtocols = @compileError("'EnumProtocols' requires that UNICODE be set to true or false in the root module");
        pub const GetAddressByName = @compileError("'GetAddressByName' requires that UNICODE be set to true or false in the root module");
        pub const GetTypeByName = @compileError("'GetTypeByName' requires that UNICODE be set to true or false in the root module");
        pub const GetNameByType = @compileError("'GetNameByType' requires that UNICODE be set to true or false in the root module");
        pub const SetService = @compileError("'SetService' requires that UNICODE be set to true or false in the root module");
        pub const GetService = @compileError("'GetService' requires that UNICODE be set to true or false in the root module");
        pub const GetAddrInfoEx = @compileError("'GetAddrInfoEx' requires that UNICODE be set to true or false in the root module");
        pub const SetAddrInfoEx = @compileError("'SetAddrInfoEx' requires that UNICODE be set to true or false in the root module");
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (19)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const BLOB = @import("../system/com.zig").BLOB;
const BOOL = @import("../foundation.zig").BOOL;
const BOOLEAN = @import("../foundation.zig").BOOLEAN;
const CHAR = @import("../foundation.zig").CHAR;
const DL_EUI48 = @import("../network_management/windows_filtering_platform.zig").DL_EUI48;
const FARPROC = @import("../foundation.zig").FARPROC;
const HANDLE = @import("../foundation.zig").HANDLE;
const HRESULT = @import("../foundation.zig").HRESULT;
const HWND = @import("../foundation.zig").HWND;
const LARGE_INTEGER = @import("../foundation.zig").LARGE_INTEGER;
const LPARAM = @import("../foundation.zig").LPARAM;
const OVERLAPPED = @import("../system/io.zig").OVERLAPPED;
const OVERLAPPED_ENTRY = @import("../system/io.zig").OVERLAPPED_ENTRY;
const PROCESSOR_NUMBER = @import("../system/kernel.zig").PROCESSOR_NUMBER;
const PSTR = @import("../foundation.zig").PSTR;
const PWSTR = @import("../foundation.zig").PWSTR;
const QOS = @import("../network_management/qo_s.zig").QOS;
const WPARAM = @import("../foundation.zig").WPARAM;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "LPCONDITIONPROC")) { _ = LPCONDITIONPROC; }
    if (@hasDecl(@This(), "LPWSAOVERLAPPED_COMPLETION_ROUTINE")) { _ = LPWSAOVERLAPPED_COMPLETION_ROUTINE; }
    if (@hasDecl(@This(), "LPFN_TRANSMITFILE")) { _ = LPFN_TRANSMITFILE; }
    if (@hasDecl(@This(), "LPFN_ACCEPTEX")) { _ = LPFN_ACCEPTEX; }
    if (@hasDecl(@This(), "LPFN_GETACCEPTEXSOCKADDRS")) { _ = LPFN_GETACCEPTEXSOCKADDRS; }
    if (@hasDecl(@This(), "LPFN_TRANSMITPACKETS")) { _ = LPFN_TRANSMITPACKETS; }
    if (@hasDecl(@This(), "LPFN_CONNECTEX")) { _ = LPFN_CONNECTEX; }
    if (@hasDecl(@This(), "LPFN_DISCONNECTEX")) { _ = LPFN_DISCONNECTEX; }
    if (@hasDecl(@This(), "LPFN_WSARECVMSG")) { _ = LPFN_WSARECVMSG; }
    if (@hasDecl(@This(), "LPFN_WSASENDMSG")) { _ = LPFN_WSASENDMSG; }
    if (@hasDecl(@This(), "LPFN_WSAPOLL")) { _ = LPFN_WSAPOLL; }
    if (@hasDecl(@This(), "LPFN_RIORECEIVE")) { _ = LPFN_RIORECEIVE; }
    if (@hasDecl(@This(), "LPFN_RIORECEIVEEX")) { _ = LPFN_RIORECEIVEEX; }
    if (@hasDecl(@This(), "LPFN_RIOSEND")) { _ = LPFN_RIOSEND; }
    if (@hasDecl(@This(), "LPFN_RIOSENDEX")) { _ = LPFN_RIOSENDEX; }
    if (@hasDecl(@This(), "LPFN_RIOCLOSECOMPLETIONQUEUE")) { _ = LPFN_RIOCLOSECOMPLETIONQUEUE; }
    if (@hasDecl(@This(), "LPFN_RIOCREATECOMPLETIONQUEUE")) { _ = LPFN_RIOCREATECOMPLETIONQUEUE; }
    if (@hasDecl(@This(), "LPFN_RIOCREATEREQUESTQUEUE")) { _ = LPFN_RIOCREATEREQUESTQUEUE; }
    if (@hasDecl(@This(), "LPFN_RIODEQUEUECOMPLETION")) { _ = LPFN_RIODEQUEUECOMPLETION; }
    if (@hasDecl(@This(), "LPFN_RIODEREGISTERBUFFER")) { _ = LPFN_RIODEREGISTERBUFFER; }
    if (@hasDecl(@This(), "LPFN_RIONOTIFY")) { _ = LPFN_RIONOTIFY; }
    if (@hasDecl(@This(), "LPFN_RIOREGISTERBUFFER")) { _ = LPFN_RIOREGISTERBUFFER; }
    if (@hasDecl(@This(), "LPFN_RIORESIZECOMPLETIONQUEUE")) { _ = LPFN_RIORESIZECOMPLETIONQUEUE; }
    if (@hasDecl(@This(), "LPFN_RIORESIZEREQUESTQUEUE")) { _ = LPFN_RIORESIZEREQUESTQUEUE; }
    if (@hasDecl(@This(), "LPBLOCKINGCALLBACK")) { _ = LPBLOCKINGCALLBACK; }
    if (@hasDecl(@This(), "LPWSAUSERAPC")) { _ = LPWSAUSERAPC; }
    if (@hasDecl(@This(), "LPWSPACCEPT")) { _ = LPWSPACCEPT; }
    if (@hasDecl(@This(), "LPWSPADDRESSTOSTRING")) { _ = LPWSPADDRESSTOSTRING; }
    if (@hasDecl(@This(), "LPWSPASYNCSELECT")) { _ = LPWSPASYNCSELECT; }
    if (@hasDecl(@This(), "LPWSPBIND")) { _ = LPWSPBIND; }
    if (@hasDecl(@This(), "LPWSPCANCELBLOCKINGCALL")) { _ = LPWSPCANCELBLOCKINGCALL; }
    if (@hasDecl(@This(), "LPWSPCLEANUP")) { _ = LPWSPCLEANUP; }
    if (@hasDecl(@This(), "LPWSPCLOSESOCKET")) { _ = LPWSPCLOSESOCKET; }
    if (@hasDecl(@This(), "LPWSPCONNECT")) { _ = LPWSPCONNECT; }
    if (@hasDecl(@This(), "LPWSPDUPLICATESOCKET")) { _ = LPWSPDUPLICATESOCKET; }
    if (@hasDecl(@This(), "LPWSPENUMNETWORKEVENTS")) { _ = LPWSPENUMNETWORKEVENTS; }
    if (@hasDecl(@This(), "LPWSPEVENTSELECT")) { _ = LPWSPEVENTSELECT; }
    if (@hasDecl(@This(), "LPWSPGETOVERLAPPEDRESULT")) { _ = LPWSPGETOVERLAPPEDRESULT; }
    if (@hasDecl(@This(), "LPWSPGETPEERNAME")) { _ = LPWSPGETPEERNAME; }
    if (@hasDecl(@This(), "LPWSPGETSOCKNAME")) { _ = LPWSPGETSOCKNAME; }
    if (@hasDecl(@This(), "LPWSPGETSOCKOPT")) { _ = LPWSPGETSOCKOPT; }
    if (@hasDecl(@This(), "LPWSPGETQOSBYNAME")) { _ = LPWSPGETQOSBYNAME; }
    if (@hasDecl(@This(), "LPWSPIOCTL")) { _ = LPWSPIOCTL; }
    if (@hasDecl(@This(), "LPWSPJOINLEAF")) { _ = LPWSPJOINLEAF; }
    if (@hasDecl(@This(), "LPWSPLISTEN")) { _ = LPWSPLISTEN; }
    if (@hasDecl(@This(), "LPWSPRECV")) { _ = LPWSPRECV; }
    if (@hasDecl(@This(), "LPWSPRECVDISCONNECT")) { _ = LPWSPRECVDISCONNECT; }
    if (@hasDecl(@This(), "LPWSPRECVFROM")) { _ = LPWSPRECVFROM; }
    if (@hasDecl(@This(), "LPWSPSELECT")) { _ = LPWSPSELECT; }
    if (@hasDecl(@This(), "LPWSPSEND")) { _ = LPWSPSEND; }
    if (@hasDecl(@This(), "LPWSPSENDDISCONNECT")) { _ = LPWSPSENDDISCONNECT; }
    if (@hasDecl(@This(), "LPWSPSENDTO")) { _ = LPWSPSENDTO; }
    if (@hasDecl(@This(), "LPWSPSETSOCKOPT")) { _ = LPWSPSETSOCKOPT; }
    if (@hasDecl(@This(), "LPWSPSHUTDOWN")) { _ = LPWSPSHUTDOWN; }
    if (@hasDecl(@This(), "LPWSPSOCKET")) { _ = LPWSPSOCKET; }
    if (@hasDecl(@This(), "LPWSPSTRINGTOADDRESS")) { _ = LPWSPSTRINGTOADDRESS; }
    if (@hasDecl(@This(), "LPWPUCLOSEEVENT")) { _ = LPWPUCLOSEEVENT; }
    if (@hasDecl(@This(), "LPWPUCLOSESOCKETHANDLE")) { _ = LPWPUCLOSESOCKETHANDLE; }
    if (@hasDecl(@This(), "LPWPUCREATEEVENT")) { _ = LPWPUCREATEEVENT; }
    if (@hasDecl(@This(), "LPWPUCREATESOCKETHANDLE")) { _ = LPWPUCREATESOCKETHANDLE; }
    if (@hasDecl(@This(), "LPWPUFDISSET")) { _ = LPWPUFDISSET; }
    if (@hasDecl(@This(), "LPWPUGETPROVIDERPATH")) { _ = LPWPUGETPROVIDERPATH; }
    if (@hasDecl(@This(), "LPWPUMODIFYIFSHANDLE")) { _ = LPWPUMODIFYIFSHANDLE; }
    if (@hasDecl(@This(), "LPWPUPOSTMESSAGE")) { _ = LPWPUPOSTMESSAGE; }
    if (@hasDecl(@This(), "LPWPUQUERYBLOCKINGCALLBACK")) { _ = LPWPUQUERYBLOCKINGCALLBACK; }
    if (@hasDecl(@This(), "LPWPUQUERYSOCKETHANDLECONTEXT")) { _ = LPWPUQUERYSOCKETHANDLECONTEXT; }
    if (@hasDecl(@This(), "LPWPUQUEUEAPC")) { _ = LPWPUQUEUEAPC; }
    if (@hasDecl(@This(), "LPWPURESETEVENT")) { _ = LPWPURESETEVENT; }
    if (@hasDecl(@This(), "LPWPUSETEVENT")) { _ = LPWPUSETEVENT; }
    if (@hasDecl(@This(), "LPWPUOPENCURRENTTHREAD")) { _ = LPWPUOPENCURRENTTHREAD; }
    if (@hasDecl(@This(), "LPWPUCLOSETHREAD")) { _ = LPWPUCLOSETHREAD; }
    if (@hasDecl(@This(), "LPWPUCOMPLETEOVERLAPPEDREQUEST")) { _ = LPWPUCOMPLETEOVERLAPPEDREQUEST; }
    if (@hasDecl(@This(), "LPWSPSTARTUP")) { _ = LPWSPSTARTUP; }
    if (@hasDecl(@This(), "LPWSCENUMPROTOCOLS")) { _ = LPWSCENUMPROTOCOLS; }
    if (@hasDecl(@This(), "LPWSCDEINSTALLPROVIDER")) { _ = LPWSCDEINSTALLPROVIDER; }
    if (@hasDecl(@This(), "LPWSCINSTALLPROVIDER")) { _ = LPWSCINSTALLPROVIDER; }
    if (@hasDecl(@This(), "LPWSCGETPROVIDERPATH")) { _ = LPWSCGETPROVIDERPATH; }
    if (@hasDecl(@This(), "LPWSCUPDATEPROVIDER")) { _ = LPWSCUPDATEPROVIDER; }
    if (@hasDecl(@This(), "LPWSCINSTALLNAMESPACE")) { _ = LPWSCINSTALLNAMESPACE; }
    if (@hasDecl(@This(), "LPWSCUNINSTALLNAMESPACE")) { _ = LPWSCUNINSTALLNAMESPACE; }
    if (@hasDecl(@This(), "LPWSCENABLENSPROVIDER")) { _ = LPWSCENABLENSPROVIDER; }
    if (@hasDecl(@This(), "LPNSPCLEANUP")) { _ = LPNSPCLEANUP; }
    if (@hasDecl(@This(), "LPNSPLOOKUPSERVICEBEGIN")) { _ = LPNSPLOOKUPSERVICEBEGIN; }
    if (@hasDecl(@This(), "LPNSPLOOKUPSERVICENEXT")) { _ = LPNSPLOOKUPSERVICENEXT; }
    if (@hasDecl(@This(), "LPNSPIOCTL")) { _ = LPNSPIOCTL; }
    if (@hasDecl(@This(), "LPNSPLOOKUPSERVICEEND")) { _ = LPNSPLOOKUPSERVICEEND; }
    if (@hasDecl(@This(), "LPNSPSETSERVICE")) { _ = LPNSPSETSERVICE; }
    if (@hasDecl(@This(), "LPNSPINSTALLSERVICECLASS")) { _ = LPNSPINSTALLSERVICECLASS; }
    if (@hasDecl(@This(), "LPNSPREMOVESERVICECLASS")) { _ = LPNSPREMOVESERVICECLASS; }
    if (@hasDecl(@This(), "LPNSPGETSERVICECLASSINFO")) { _ = LPNSPGETSERVICECLASSINFO; }
    if (@hasDecl(@This(), "LPNSPSTARTUP")) { _ = LPNSPSTARTUP; }
    if (@hasDecl(@This(), "LPNSPV2STARTUP")) { _ = LPNSPV2STARTUP; }
    if (@hasDecl(@This(), "LPNSPV2CLEANUP")) { _ = LPNSPV2CLEANUP; }
    if (@hasDecl(@This(), "LPNSPV2LOOKUPSERVICEBEGIN")) { _ = LPNSPV2LOOKUPSERVICEBEGIN; }
    if (@hasDecl(@This(), "LPNSPV2LOOKUPSERVICENEXTEX")) { _ = LPNSPV2LOOKUPSERVICENEXTEX; }
    if (@hasDecl(@This(), "LPNSPV2LOOKUPSERVICEEND")) { _ = LPNSPV2LOOKUPSERVICEEND; }
    if (@hasDecl(@This(), "LPNSPV2SETSERVICEEX")) { _ = LPNSPV2SETSERVICEEX; }
    if (@hasDecl(@This(), "LPNSPV2CLIENTSESSIONRUNDOWN")) { _ = LPNSPV2CLIENTSESSIONRUNDOWN; }
    if (@hasDecl(@This(), "LPFN_NSPAPI")) { _ = LPFN_NSPAPI; }
    if (@hasDecl(@This(), "LPSERVICE_CALLBACK_PROC")) { _ = LPSERVICE_CALLBACK_PROC; }
    if (@hasDecl(@This(), "LPLOOKUPSERVICE_COMPLETION_ROUTINE")) { _ = LPLOOKUPSERVICE_COMPLETION_ROUTINE; }
    if (@hasDecl(@This(), "LPWSCWRITEPROVIDERORDER")) { _ = LPWSCWRITEPROVIDERORDER; }
    if (@hasDecl(@This(), "LPWSCWRITENAMESPACEORDER")) { _ = LPWSCWRITENAMESPACEORDER; }

    @setEvalBranchQuota(
        comptime @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        if (decl.is_pub) {
            _ = @field(@This(), decl.name);
        }
    }
}
