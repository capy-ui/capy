//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (342)
//--------------------------------------------------------------------------------
pub const WMT_VIDEOIMAGE_SAMPLE_INPUT_FRAME = @as(u32, 1);
pub const WMT_VIDEOIMAGE_SAMPLE_OUTPUT_FRAME = @as(u32, 2);
pub const WMT_VIDEOIMAGE_SAMPLE_USES_CURRENT_INPUT_FRAME = @as(u32, 4);
pub const WMT_VIDEOIMAGE_SAMPLE_USES_PREVIOUS_INPUT_FRAME = @as(u32, 8);
pub const WMT_VIDEOIMAGE_SAMPLE_MOTION = @as(u32, 1);
pub const WMT_VIDEOIMAGE_SAMPLE_ROTATION = @as(u32, 2);
pub const WMT_VIDEOIMAGE_SAMPLE_BLENDING = @as(u32, 4);
pub const WMT_VIDEOIMAGE_SAMPLE_ADV_BLENDING = @as(u32, 8);
pub const WMT_VIDEOIMAGE_INTEGER_DENOMINATOR = @as(i32, 65536);
pub const WMT_VIDEOIMAGE_MAGIC_NUMBER = @as(u32, 491406834);
pub const WMT_VIDEOIMAGE_MAGIC_NUMBER_2 = @as(u32, 491406835);
pub const WMT_VIDEOIMAGE_TRANSITION_BOW_TIE = @as(u32, 11);
pub const WMT_VIDEOIMAGE_TRANSITION_CIRCLE = @as(u32, 12);
pub const WMT_VIDEOIMAGE_TRANSITION_CROSS_FADE = @as(u32, 13);
pub const WMT_VIDEOIMAGE_TRANSITION_DIAGONAL = @as(u32, 14);
pub const WMT_VIDEOIMAGE_TRANSITION_DIAMOND = @as(u32, 15);
pub const WMT_VIDEOIMAGE_TRANSITION_FADE_TO_COLOR = @as(u32, 16);
pub const WMT_VIDEOIMAGE_TRANSITION_FILLED_V = @as(u32, 17);
pub const WMT_VIDEOIMAGE_TRANSITION_FLIP = @as(u32, 18);
pub const WMT_VIDEOIMAGE_TRANSITION_INSET = @as(u32, 19);
pub const WMT_VIDEOIMAGE_TRANSITION_IRIS = @as(u32, 20);
pub const WMT_VIDEOIMAGE_TRANSITION_PAGE_ROLL = @as(u32, 21);
pub const WMT_VIDEOIMAGE_TRANSITION_RECTANGLE = @as(u32, 23);
pub const WMT_VIDEOIMAGE_TRANSITION_REVEAL = @as(u32, 24);
pub const WMT_VIDEOIMAGE_TRANSITION_SLIDE = @as(u32, 27);
pub const WMT_VIDEOIMAGE_TRANSITION_SPLIT = @as(u32, 29);
pub const WMT_VIDEOIMAGE_TRANSITION_STAR = @as(u32, 30);
pub const WMT_VIDEOIMAGE_TRANSITION_WHEEL = @as(u32, 31);
pub const WM_SampleExtension_ContentType_Size = @as(u32, 1);
pub const WM_SampleExtension_PixelAspectRatio_Size = @as(u32, 2);
pub const WM_SampleExtension_Timecode_Size = @as(u32, 14);
pub const WM_SampleExtension_SampleDuration_Size = @as(u32, 2);
pub const WM_SampleExtension_ChromaLocation_Size = @as(u32, 1);
pub const WM_SampleExtension_ColorSpaceInfo_Size = @as(u32, 3);
pub const WM_CT_REPEAT_FIRST_FIELD = @as(u32, 16);
pub const WM_CT_BOTTOM_FIELD_FIRST = @as(u32, 32);
pub const WM_CT_TOP_FIELD_FIRST = @as(u32, 64);
pub const WM_CT_INTERLACED = @as(u32, 128);
pub const WM_CL_INTERLACED420 = @as(u32, 0);
pub const WM_CL_PROGRESSIVE420 = @as(u32, 1);
pub const WM_MAX_VIDEO_STREAMS = @as(u32, 63);
pub const WM_MAX_STREAMS = @as(u32, 63);
pub const WMDRM_IMPORT_INIT_STRUCT_DEFINED = @as(u32, 1);
pub const DRM_OPL_TYPES = @as(u32, 1);
pub const g_dwWMSpecialAttributes = @as(u32, 20);
pub const g_wszWMDuration = "Duration";
pub const g_wszWMBitrate = "Bitrate";
pub const g_wszWMSeekable = "Seekable";
pub const g_wszWMStridable = "Stridable";
pub const g_wszWMBroadcast = "Broadcast";
pub const g_wszWMProtected = "Is_Protected";
pub const g_wszWMTrusted = "Is_Trusted";
pub const g_wszWMSignature_Name = "Signature_Name";
pub const g_wszWMHasAudio = "HasAudio";
pub const g_wszWMHasImage = "HasImage";
pub const g_wszWMHasScript = "HasScript";
pub const g_wszWMHasVideo = "HasVideo";
pub const g_wszWMCurrentBitrate = "CurrentBitrate";
pub const g_wszWMOptimalBitrate = "OptimalBitrate";
pub const g_wszWMHasAttachedImages = "HasAttachedImages";
pub const g_wszWMSkipBackward = "Can_Skip_Backward";
pub const g_wszWMSkipForward = "Can_Skip_Forward";
pub const g_wszWMNumberOfFrames = "NumberOfFrames";
pub const g_wszWMFileSize = "FileSize";
pub const g_wszWMHasArbitraryDataStream = "HasArbitraryDataStream";
pub const g_wszWMHasFileTransferStream = "HasFileTransferStream";
pub const g_wszWMContainerFormat = "WM/ContainerFormat";
pub const g_dwWMContentAttributes = @as(u32, 5);
pub const g_wszWMTitle = "Title";
pub const g_wszWMTitleSort = "TitleSort";
pub const g_wszWMAuthor = "Author";
pub const g_wszWMAuthorSort = "AuthorSort";
pub const g_wszWMDescription = "Description";
pub const g_wszWMRating = "Rating";
pub const g_wszWMCopyright = "Copyright";
pub const g_wszWMUse_DRM = "Use_DRM";
pub const g_wszWMDRM_Flags = "DRM_Flags";
pub const g_wszWMDRM_Level = "DRM_Level";
pub const g_wszWMUse_Advanced_DRM = "Use_Advanced_DRM";
pub const g_wszWMDRM_KeySeed = "DRM_KeySeed";
pub const g_wszWMDRM_KeyID = "DRM_KeyID";
pub const g_wszWMDRM_ContentID = "DRM_ContentID";
pub const g_wszWMDRM_SourceID = "DRM_SourceID";
pub const g_wszWMDRM_IndividualizedVersion = "DRM_IndividualizedVersion";
pub const g_wszWMDRM_LicenseAcqURL = "DRM_LicenseAcqURL";
pub const g_wszWMDRM_V1LicenseAcqURL = "DRM_V1LicenseAcqURL";
pub const g_wszWMDRM_HeaderSignPrivKey = "DRM_HeaderSignPrivKey";
pub const g_wszWMDRM_LASignaturePrivKey = "DRM_LASignaturePrivKey";
pub const g_wszWMDRM_LASignatureCert = "DRM_LASignatureCert";
pub const g_wszWMDRM_LASignatureLicSrvCert = "DRM_LASignatureLicSrvCert";
pub const g_wszWMDRM_LASignatureRootCert = "DRM_LASignatureRootCert";
pub const g_wszWMAlbumTitle = "WM/AlbumTitle";
pub const g_wszWMAlbumTitleSort = "WM/AlbumTitleSort";
pub const g_wszWMTrack = "WM/Track";
pub const g_wszWMPromotionURL = "WM/PromotionURL";
pub const g_wszWMAlbumCoverURL = "WM/AlbumCoverURL";
pub const g_wszWMGenre = "WM/Genre";
pub const g_wszWMYear = "WM/Year";
pub const g_wszWMGenreID = "WM/GenreID";
pub const g_wszWMMCDI = "WM/MCDI";
pub const g_wszWMComposer = "WM/Composer";
pub const g_wszWMComposerSort = "WM/ComposerSort";
pub const g_wszWMLyrics = "WM/Lyrics";
pub const g_wszWMTrackNumber = "WM/TrackNumber";
pub const g_wszWMToolName = "WM/ToolName";
pub const g_wszWMToolVersion = "WM/ToolVersion";
pub const g_wszWMIsVBR = "IsVBR";
pub const g_wszWMAlbumArtist = "WM/AlbumArtist";
pub const g_wszWMAlbumArtistSort = "WM/AlbumArtistSort";
pub const g_wszWMBannerImageType = "BannerImageType";
pub const g_wszWMBannerImageData = "BannerImageData";
pub const g_wszWMBannerImageURL = "BannerImageURL";
pub const g_wszWMCopyrightURL = "CopyrightURL";
pub const g_wszWMAspectRatioX = "AspectRatioX";
pub const g_wszWMAspectRatioY = "AspectRatioY";
pub const g_wszASFLeakyBucketPairs = "ASFLeakyBucketPairs";
pub const g_dwWMNSCAttributes = @as(u32, 5);
pub const g_wszWMNSCName = "NSC_Name";
pub const g_wszWMNSCAddress = "NSC_Address";
pub const g_wszWMNSCPhone = "NSC_Phone";
pub const g_wszWMNSCEmail = "NSC_Email";
pub const g_wszWMNSCDescription = "NSC_Description";
pub const g_wszWMWriter = "WM/Writer";
pub const g_wszWMConductor = "WM/Conductor";
pub const g_wszWMProducer = "WM/Producer";
pub const g_wszWMDirector = "WM/Director";
pub const g_wszWMContentGroupDescription = "WM/ContentGroupDescription";
pub const g_wszWMSubTitle = "WM/SubTitle";
pub const g_wszWMPartOfSet = "WM/PartOfSet";
pub const g_wszWMProtectionType = "WM/ProtectionType";
pub const g_wszWMVideoHeight = "WM/VideoHeight";
pub const g_wszWMVideoWidth = "WM/VideoWidth";
pub const g_wszWMVideoFrameRate = "WM/VideoFrameRate";
pub const g_wszWMMediaClassPrimaryID = "WM/MediaClassPrimaryID";
pub const g_wszWMMediaClassSecondaryID = "WM/MediaClassSecondaryID";
pub const g_wszWMPeriod = "WM/Period";
pub const g_wszWMCategory = "WM/Category";
pub const g_wszWMPicture = "WM/Picture";
pub const g_wszWMLyrics_Synchronised = "WM/Lyrics_Synchronised";
pub const g_wszWMOriginalLyricist = "WM/OriginalLyricist";
pub const g_wszWMOriginalArtist = "WM/OriginalArtist";
pub const g_wszWMOriginalAlbumTitle = "WM/OriginalAlbumTitle";
pub const g_wszWMOriginalReleaseYear = "WM/OriginalReleaseYear";
pub const g_wszWMOriginalFilename = "WM/OriginalFilename";
pub const g_wszWMPublisher = "WM/Publisher";
pub const g_wszWMEncodedBy = "WM/EncodedBy";
pub const g_wszWMEncodingSettings = "WM/EncodingSettings";
pub const g_wszWMEncodingTime = "WM/EncodingTime";
pub const g_wszWMAuthorURL = "WM/AuthorURL";
pub const g_wszWMUserWebURL = "WM/UserWebURL";
pub const g_wszWMAudioFileURL = "WM/AudioFileURL";
pub const g_wszWMAudioSourceURL = "WM/AudioSourceURL";
pub const g_wszWMLanguage = "WM/Language";
pub const g_wszWMParentalRating = "WM/ParentalRating";
pub const g_wszWMBeatsPerMinute = "WM/BeatsPerMinute";
pub const g_wszWMInitialKey = "WM/InitialKey";
pub const g_wszWMMood = "WM/Mood";
pub const g_wszWMText = "WM/Text";
pub const g_wszWMDVDID = "WM/DVDID";
pub const g_wszWMWMContentID = "WM/WMContentID";
pub const g_wszWMWMCollectionID = "WM/WMCollectionID";
pub const g_wszWMWMCollectionGroupID = "WM/WMCollectionGroupID";
pub const g_wszWMUniqueFileIdentifier = "WM/UniqueFileIdentifier";
pub const g_wszWMModifiedBy = "WM/ModifiedBy";
pub const g_wszWMRadioStationName = "WM/RadioStationName";
pub const g_wszWMRadioStationOwner = "WM/RadioStationOwner";
pub const g_wszWMPlaylistDelay = "WM/PlaylistDelay";
pub const g_wszWMCodec = "WM/Codec";
pub const g_wszWMDRM = "WM/DRM";
pub const g_wszWMISRC = "WM/ISRC";
pub const g_wszWMProvider = "WM/Provider";
pub const g_wszWMProviderRating = "WM/ProviderRating";
pub const g_wszWMProviderStyle = "WM/ProviderStyle";
pub const g_wszWMContentDistributor = "WM/ContentDistributor";
pub const g_wszWMSubscriptionContentID = "WM/SubscriptionContentID";
pub const g_wszWMWMADRCPeakReference = "WM/WMADRCPeakReference";
pub const g_wszWMWMADRCPeakTarget = "WM/WMADRCPeakTarget";
pub const g_wszWMWMADRCAverageReference = "WM/WMADRCAverageReference";
pub const g_wszWMWMADRCAverageTarget = "WM/WMADRCAverageTarget";
pub const g_wszWMStreamTypeInfo = "WM/StreamTypeInfo";
pub const g_wszWMPeakBitrate = "WM/PeakBitrate";
pub const g_wszWMASFPacketCount = "WM/ASFPacketCount";
pub const g_wszWMASFSecurityObjectsSize = "WM/ASFSecurityObjectsSize";
pub const g_wszWMSharedUserRating = "WM/SharedUserRating";
pub const g_wszWMSubTitleDescription = "WM/SubTitleDescription";
pub const g_wszWMMediaCredits = "WM/MediaCredits";
pub const g_wszWMParentalRatingReason = "WM/ParentalRatingReason";
pub const g_wszWMOriginalReleaseTime = "WM/OriginalReleaseTime";
pub const g_wszWMMediaStationCallSign = "WM/MediaStationCallSign";
pub const g_wszWMMediaStationName = "WM/MediaStationName";
pub const g_wszWMMediaNetworkAffiliation = "WM/MediaNetworkAffiliation";
pub const g_wszWMMediaOriginalChannel = "WM/MediaOriginalChannel";
pub const g_wszWMMediaOriginalBroadcastDateTime = "WM/MediaOriginalBroadcastDateTime";
pub const g_wszWMMediaIsStereo = "WM/MediaIsStereo";
pub const g_wszWMVideoClosedCaptioning = "WM/VideoClosedCaptioning";
pub const g_wszWMMediaIsRepeat = "WM/MediaIsRepeat";
pub const g_wszWMMediaIsLive = "WM/MediaIsLive";
pub const g_wszWMMediaIsTape = "WM/MediaIsTape";
pub const g_wszWMMediaIsDelay = "WM/MediaIsDelay";
pub const g_wszWMMediaIsSubtitled = "WM/MediaIsSubtitled";
pub const g_wszWMMediaIsPremiere = "WM/MediaIsPremiere";
pub const g_wszWMMediaIsFinale = "WM/MediaIsFinale";
pub const g_wszWMMediaIsSAP = "WM/MediaIsSAP";
pub const g_wszWMProviderCopyright = "WM/ProviderCopyright";
pub const g_wszWMISAN = "WM/ISAN";
pub const g_wszWMADID = "WM/ADID";
pub const g_wszWMWMShadowFileSourceFileType = "WM/WMShadowFileSourceFileType";
pub const g_wszWMWMShadowFileSourceDRMType = "WM/WMShadowFileSourceDRMType";
pub const g_wszWMWMCPDistributor = "WM/WMCPDistributor";
pub const g_wszWMWMCPDistributorID = "WM/WMCPDistributorID";
pub const g_wszWMSeasonNumber = "WM/SeasonNumber";
pub const g_wszWMEpisodeNumber = "WM/EpisodeNumber";
pub const g_wszEarlyDataDelivery = "EarlyDataDelivery";
pub const g_wszJustInTimeDecode = "JustInTimeDecode";
pub const g_wszSingleOutputBuffer = "SingleOutputBuffer";
pub const g_wszSoftwareScaling = "SoftwareScaling";
pub const g_wszDeliverOnReceive = "DeliverOnReceive";
pub const g_wszScrambledAudio = "ScrambledAudio";
pub const g_wszDedicatedDeliveryThread = "DedicatedDeliveryThread";
pub const g_wszEnableDiscreteOutput = "EnableDiscreteOutput";
pub const g_wszSpeakerConfig = "SpeakerConfig";
pub const g_wszDynamicRangeControl = "DynamicRangeControl";
pub const g_wszAllowInterlacedOutput = "AllowInterlacedOutput";
pub const g_wszVideoSampleDurations = "VideoSampleDurations";
pub const g_wszStreamLanguage = "StreamLanguage";
pub const g_wszEnableWMAProSPDIFOutput = "EnableWMAProSPDIFOutput";
pub const g_wszDeinterlaceMode = "DeinterlaceMode";
pub const g_wszInitialPatternForInverseTelecine = "InitialPatternForInverseTelecine";
pub const g_wszJPEGCompressionQuality = "JPEGCompressionQuality";
pub const g_wszWatermarkCLSID = "WatermarkCLSID";
pub const g_wszWatermarkConfig = "WatermarkConfig";
pub const g_wszInterlacedCoding = "InterlacedCoding";
pub const g_wszFixedFrameRate = "FixedFrameRate";
pub const g_wszOriginalSourceFormatTag = "_SOURCEFORMATTAG";
pub const g_wszOriginalWaveFormat = "_ORIGINALWAVEFORMAT";
pub const g_wszEDL = "_EDL";
pub const g_wszComplexity = "_COMPLEXITYEX";
pub const g_wszDecoderComplexityRequested = "_DECODERCOMPLEXITYPROFILE";
pub const g_wszReloadIndexOnSeek = "ReloadIndexOnSeek";
pub const g_wszStreamNumIndexObjects = "StreamNumIndexObjects";
pub const g_wszFailSeekOnError = "FailSeekOnError";
pub const g_wszPermitSeeksBeyondEndOfStream = "PermitSeeksBeyondEndOfStream";
pub const g_wszUsePacketAtSeekPoint = "UsePacketAtSeekPoint";
pub const g_wszSourceBufferTime = "SourceBufferTime";
pub const g_wszSourceMaxBytesAtOnce = "SourceMaxBytesAtOnce";
pub const g_wszVBREnabled = "_VBRENABLED";
pub const g_wszVBRQuality = "_VBRQUALITY";
pub const g_wszVBRBitrateMax = "_RMAX";
pub const g_wszVBRBufferWindowMax = "_BMAX";
pub const g_wszVBRPeak = "VBR Peak";
pub const g_wszBufferAverage = "Buffer Average";
pub const g_wszComplexityMax = "_COMPLEXITYEXMAX";
pub const g_wszComplexityOffline = "_COMPLEXITYEXOFFLINE";
pub const g_wszComplexityLive = "_COMPLEXITYEXLIVE";
pub const g_wszIsVBRSupported = "_ISVBRSUPPORTED";
pub const g_wszNumPasses = "_PASSESUSED";
pub const g_wszMusicSpeechClassMode = "MusicSpeechClassMode";
pub const g_wszMusicClassMode = "MusicClassMode";
pub const g_wszSpeechClassMode = "SpeechClassMode";
pub const g_wszMixedClassMode = "MixedClassMode";
pub const g_wszSpeechCaps = "SpeechFormatCap";
pub const g_wszPeakValue = "PeakValue";
pub const g_wszAverageLevel = "AverageLevel";
pub const g_wszFold6To2Channels3 = "Fold6To2Channels3";
pub const g_wszFoldToChannelsTemplate = "Fold%luTo%luChannels%lu";
pub const g_wszDeviceConformanceTemplate = "DeviceConformanceTemplate";
pub const g_wszEnableFrameInterpolation = "EnableFrameInterpolation";
pub const g_wszNeedsPreviousSample = "NeedsPreviousSample";
pub const g_wszWMIsCompilation = "WM/IsCompilation";
pub const WMMEDIASUBTYPE_Base = Guid.initString("00000000-0000-0010-8000-00aa00389b71");
pub const WMMEDIATYPE_Video = Guid.initString("73646976-0000-0010-8000-00aa00389b71");
pub const WMMEDIASUBTYPE_RGB1 = Guid.initString("e436eb78-524f-11ce-9f53-0020af0ba770");
pub const WMMEDIASUBTYPE_RGB4 = Guid.initString("e436eb79-524f-11ce-9f53-0020af0ba770");
pub const WMMEDIASUBTYPE_RGB8 = Guid.initString("e436eb7a-524f-11ce-9f53-0020af0ba770");
pub const WMMEDIASUBTYPE_RGB565 = Guid.initString("e436eb7b-524f-11ce-9f53-0020af0ba770");
pub const WMMEDIASUBTYPE_RGB555 = Guid.initString("e436eb7c-524f-11ce-9f53-0020af0ba770");
pub const WMMEDIASUBTYPE_RGB24 = Guid.initString("e436eb7d-524f-11ce-9f53-0020af0ba770");
pub const WMMEDIASUBTYPE_RGB32 = Guid.initString("e436eb7e-524f-11ce-9f53-0020af0ba770");
pub const WMMEDIASUBTYPE_I420 = Guid.initString("30323449-0000-0010-8000-00aa00389b71");
pub const WMMEDIASUBTYPE_IYUV = Guid.initString("56555949-0000-0010-8000-00aa00389b71");
pub const WMMEDIASUBTYPE_YV12 = Guid.initString("32315659-0000-0010-8000-00aa00389b71");
pub const WMMEDIASUBTYPE_YUY2 = Guid.initString("32595559-0000-0010-8000-00aa00389b71");
pub const WMMEDIASUBTYPE_P422 = Guid.initString("32323450-0000-0010-8000-00aa00389b71");
pub const WMMEDIASUBTYPE_UYVY = Guid.initString("59565955-0000-0010-8000-00aa00389b71");
pub const WMMEDIASUBTYPE_YVYU = Guid.initString("55595659-0000-0010-8000-00aa00389b71");
pub const WMMEDIASUBTYPE_YVU9 = Guid.initString("39555659-0000-0010-8000-00aa00389b71");
pub const WMMEDIASUBTYPE_VIDEOIMAGE = Guid.initString("1d4a45f2-e5f6-4b44-8388-f0ae5c0e0c37");
pub const WMMEDIASUBTYPE_MP43 = Guid.initString("3334504d-0000-0010-8000-00aa00389b71");
pub const WMMEDIASUBTYPE_MP4S = Guid.initString("5334504d-0000-0010-8000-00aa00389b71");
pub const WMMEDIASUBTYPE_M4S2 = Guid.initString("3253344d-0000-0010-8000-00aa00389b71");
pub const WMMEDIASUBTYPE_WMV1 = Guid.initString("31564d57-0000-0010-8000-00aa00389b71");
pub const WMMEDIASUBTYPE_WMV2 = Guid.initString("32564d57-0000-0010-8000-00aa00389b71");
pub const WMMEDIASUBTYPE_MSS1 = Guid.initString("3153534d-0000-0010-8000-00aa00389b71");
pub const WMMEDIASUBTYPE_MPEG2_VIDEO = Guid.initString("e06d8026-db46-11cf-b4d1-00805f6cbbea");
pub const WMMEDIATYPE_Audio = Guid.initString("73647561-0000-0010-8000-00aa00389b71");
pub const WMMEDIASUBTYPE_PCM = Guid.initString("00000001-0000-0010-8000-00aa00389b71");
pub const WMMEDIASUBTYPE_DRM = Guid.initString("00000009-0000-0010-8000-00aa00389b71");
pub const WMMEDIASUBTYPE_WMAudioV9 = Guid.initString("00000162-0000-0010-8000-00aa00389b71");
pub const WMMEDIASUBTYPE_WMAudio_Lossless = Guid.initString("00000163-0000-0010-8000-00aa00389b71");
pub const WMMEDIASUBTYPE_MSS2 = Guid.initString("3253534d-0000-0010-8000-00aa00389b71");
pub const WMMEDIASUBTYPE_WMSP1 = Guid.initString("0000000a-0000-0010-8000-00aa00389b71");
pub const WMMEDIASUBTYPE_WMSP2 = Guid.initString("0000000b-0000-0010-8000-00aa00389b71");
pub const WMMEDIASUBTYPE_WMV3 = Guid.initString("33564d57-0000-0010-8000-00aa00389b71");
pub const WMMEDIASUBTYPE_WMVP = Guid.initString("50564d57-0000-0010-8000-00aa00389b71");
pub const WMMEDIASUBTYPE_WVP2 = Guid.initString("32505657-0000-0010-8000-00aa00389b71");
pub const WMMEDIASUBTYPE_WMVA = Guid.initString("41564d57-0000-0010-8000-00aa00389b71");
pub const WMMEDIASUBTYPE_WVC1 = Guid.initString("31435657-0000-0010-8000-00aa00389b71");
pub const WMMEDIASUBTYPE_WMAudioV8 = Guid.initString("00000161-0000-0010-8000-00aa00389b71");
pub const WMMEDIASUBTYPE_WMAudioV7 = Guid.initString("00000161-0000-0010-8000-00aa00389b71");
pub const WMMEDIASUBTYPE_WMAudioV2 = Guid.initString("00000161-0000-0010-8000-00aa00389b71");
pub const WMMEDIASUBTYPE_ACELPnet = Guid.initString("00000130-0000-0010-8000-00aa00389b71");
pub const WMMEDIASUBTYPE_MP3 = Guid.initString("00000055-0000-0010-8000-00aa00389b71");
pub const WMMEDIASUBTYPE_WebStream = Guid.initString("776257d4-c627-41cb-8f81-7ac7ff1c40cc");
pub const WMMEDIATYPE_Script = Guid.initString("73636d64-0000-0010-8000-00aa00389b71");
pub const WMMEDIATYPE_Image = Guid.initString("34a50fd8-8aa5-4386-81fe-a0efe0488e31");
pub const WMMEDIATYPE_FileTransfer = Guid.initString("d9e47579-930e-4427-adfc-ad80f290e470");
pub const WMMEDIATYPE_Text = Guid.initString("9bba1ea7-5ab2-4829-ba57-0940209bcf3e");
pub const WMFORMAT_VideoInfo = Guid.initString("05589f80-c356-11ce-bf01-00aa0055595a");
pub const WMFORMAT_MPEG2Video = Guid.initString("e06d80e3-db46-11cf-b4d1-00805f6cbbea");
pub const WMFORMAT_WaveFormatEx = Guid.initString("05589f81-c356-11ce-bf01-00aa0055595a");
pub const WMFORMAT_Script = Guid.initString("5c8510f2-debe-4ca7-bba5-f07a104f8dff");
pub const WMFORMAT_WebStream = Guid.initString("da1e6b13-8359-4050-b398-388e965bf00c");
pub const WMSCRIPTTYPE_TwoStrings = Guid.initString("82f38a70-c29f-11d1-97ad-00a0c95ea850");
pub const WM_SampleExtensionGUID_OutputCleanPoint = Guid.initString("f72a3c6f-6eb4-4ebc-b192-09ad9759e828");
pub const WM_SampleExtensionGUID_Timecode = Guid.initString("399595ec-8667-4e2d-8fdb-98814ce76c1e");
pub const WM_SampleExtensionGUID_ChromaLocation = Guid.initString("4c5acca0-9276-4b2c-9e4c-a0edefdd217e");
pub const WM_SampleExtensionGUID_ColorSpaceInfo = Guid.initString("f79ada56-30eb-4f2b-9f7a-f24b139a1157");
pub const WM_SampleExtensionGUID_UserDataInfo = Guid.initString("732bb4fa-78be-4549-99bd-02db1a55b7a8");
pub const WM_SampleExtensionGUID_FileName = Guid.initString("e165ec0e-19ed-45d7-b4a7-25cbd1e28e9b");
pub const WM_SampleExtensionGUID_ContentType = Guid.initString("d590dc20-07bc-436c-9cf7-f3bbfbf1a4dc");
pub const WM_SampleExtensionGUID_PixelAspectRatio = Guid.initString("1b1ee554-f9ea-4bc8-821a-376b74e4c4b8");
pub const WM_SampleExtensionGUID_SampleDuration = Guid.initString("c6bd9450-867f-4907-83a3-c77921b733ad");
pub const WM_SampleExtensionGUID_SampleProtectionSalt = Guid.initString("5403deee-b9ee-438f-aa83-3804997e569d");
pub const CLSID_WMMUTEX_Language = Guid.initString("d6e22a00-35da-11d1-9034-00a0c90349be");
pub const CLSID_WMMUTEX_Bitrate = Guid.initString("d6e22a01-35da-11d1-9034-00a0c90349be");
pub const CLSID_WMMUTEX_Presentation = Guid.initString("d6e22a02-35da-11d1-9034-00a0c90349be");
pub const CLSID_WMMUTEX_Unknown = Guid.initString("d6e22a03-35da-11d1-9034-00a0c90349be");
pub const CLSID_WMBandwidthSharing_Exclusive = Guid.initString("af6060aa-5197-11d2-b6af-00c04fd908e9");
pub const CLSID_WMBandwidthSharing_Partial = Guid.initString("af6060ab-5197-11d2-b6af-00c04fd908e9");
pub const WMT_DMOCATEGORY_AUDIO_WATERMARK = Guid.initString("65221c5a-fa75-4b39-b50c-06c336b6a3ef");
pub const WMT_DMOCATEGORY_VIDEO_WATERMARK = Guid.initString("187cc922-8efc-4404-9daf-63f4830df1bc");
pub const CLSID_ClientNetManager = Guid.initString("cd12a3ce-9c42-11d2-beed-0060082f2054");

//--------------------------------------------------------------------------------
// Section: Types (180)
//--------------------------------------------------------------------------------
const IID_IAMWMBufferPass_Value = Guid.initString("6dd816d7-e740-4123-9e24-2444412644d8");
pub const IID_IAMWMBufferPass = &IID_IAMWMBufferPass_Value;
pub const IAMWMBufferPass = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetNotify: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAMWMBufferPass,
                pCallback: ?*IAMWMBufferPassCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAMWMBufferPass,
                pCallback: ?*IAMWMBufferPassCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAMWMBufferPass_SetNotify(self: *const T, pCallback: ?*IAMWMBufferPassCallback) HRESULT {
                return @as(*const IAMWMBufferPass.VTable, @ptrCast(self.vtable)).SetNotify(@as(*const IAMWMBufferPass, @ptrCast(self)), pCallback);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IAMWMBufferPassCallback_Value = Guid.initString("b25b8372-d2d2-44b2-8653-1b8dae332489");
pub const IID_IAMWMBufferPassCallback = &IID_IAMWMBufferPassCallback_Value;
pub const IAMWMBufferPassCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Notify: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAMWMBufferPassCallback,
                pNSSBuffer3: ?*INSSBuffer3,
                pPin: ?*IPin,
                prtStart: ?*i64,
                prtEnd: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAMWMBufferPassCallback,
                pNSSBuffer3: ?*INSSBuffer3,
                pPin: ?*IPin,
                prtStart: ?*i64,
                prtEnd: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAMWMBufferPassCallback_Notify(self: *const T, pNSSBuffer3: ?*INSSBuffer3, pPin: ?*IPin, prtStart: ?*i64, prtEnd: ?*i64) HRESULT {
                return @as(*const IAMWMBufferPassCallback.VTable, @ptrCast(self.vtable)).Notify(@as(*const IAMWMBufferPassCallback, @ptrCast(self)), pNSSBuffer3, pPin, prtStart, prtEnd);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const _AM_ASFWRITERCONFIG_PARAM = enum(i32) {
    AUTOINDEX = 1,
    MULTIPASS = 2,
    DONTCOMPRESS = 3,
};
pub const AM_CONFIGASFWRITER_PARAM_AUTOINDEX = _AM_ASFWRITERCONFIG_PARAM.AUTOINDEX;
pub const AM_CONFIGASFWRITER_PARAM_MULTIPASS = _AM_ASFWRITERCONFIG_PARAM.MULTIPASS;
pub const AM_CONFIGASFWRITER_PARAM_DONTCOMPRESS = _AM_ASFWRITERCONFIG_PARAM.DONTCOMPRESS;

pub const AM_WMT_EVENT_DATA = extern struct {
    hrStatus: HRESULT,
    pData: ?*anyopaque,
};

const IID_INSSBuffer_Value = Guid.initString("e1cd3524-03d7-11d2-9eed-006097d2d7cf");
pub const IID_INSSBuffer = &IID_INSSBuffer_Value;
pub const INSSBuffer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INSSBuffer,
                pdwLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INSSBuffer,
                pdwLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INSSBuffer,
                dwLength: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INSSBuffer,
                dwLength: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMaxLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INSSBuffer,
                pdwLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INSSBuffer,
                pdwLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBuffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INSSBuffer,
                ppdwBuffer: ?*?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INSSBuffer,
                ppdwBuffer: ?*?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBufferAndLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INSSBuffer,
                ppdwBuffer: ?*?*u8,
                pdwLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INSSBuffer,
                ppdwBuffer: ?*?*u8,
                pdwLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INSSBuffer_GetLength(self: *const T, pdwLength: ?*u32) HRESULT {
                return @as(*const INSSBuffer.VTable, @ptrCast(self.vtable)).GetLength(@as(*const INSSBuffer, @ptrCast(self)), pdwLength);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INSSBuffer_SetLength(self: *const T, dwLength: u32) HRESULT {
                return @as(*const INSSBuffer.VTable, @ptrCast(self.vtable)).SetLength(@as(*const INSSBuffer, @ptrCast(self)), dwLength);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INSSBuffer_GetMaxLength(self: *const T, pdwLength: ?*u32) HRESULT {
                return @as(*const INSSBuffer.VTable, @ptrCast(self.vtable)).GetMaxLength(@as(*const INSSBuffer, @ptrCast(self)), pdwLength);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INSSBuffer_GetBuffer(self: *const T, ppdwBuffer: ?*?*u8) HRESULT {
                return @as(*const INSSBuffer.VTable, @ptrCast(self.vtable)).GetBuffer(@as(*const INSSBuffer, @ptrCast(self)), ppdwBuffer);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INSSBuffer_GetBufferAndLength(self: *const T, ppdwBuffer: ?*?*u8, pdwLength: ?*u32) HRESULT {
                return @as(*const INSSBuffer.VTable, @ptrCast(self.vtable)).GetBufferAndLength(@as(*const INSSBuffer, @ptrCast(self)), ppdwBuffer, pdwLength);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_INSSBuffer2_Value = Guid.initString("4f528693-1035-43fe-b428-757561ad3a68");
pub const IID_INSSBuffer2 = &IID_INSSBuffer2_Value;
pub const INSSBuffer2 = extern struct {
    pub const VTable = extern struct {
        base: INSSBuffer.VTable,
        GetSampleProperties: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INSSBuffer2,
                cbProperties: u32,
                pbProperties: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INSSBuffer2,
                cbProperties: u32,
                pbProperties: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSampleProperties: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INSSBuffer2,
                cbProperties: u32,
                pbProperties: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INSSBuffer2,
                cbProperties: u32,
                pbProperties: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace INSSBuffer.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INSSBuffer2_GetSampleProperties(self: *const T, cbProperties: u32, pbProperties: ?*u8) HRESULT {
                return @as(*const INSSBuffer2.VTable, @ptrCast(self.vtable)).GetSampleProperties(@as(*const INSSBuffer2, @ptrCast(self)), cbProperties, pbProperties);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INSSBuffer2_SetSampleProperties(self: *const T, cbProperties: u32, pbProperties: ?*u8) HRESULT {
                return @as(*const INSSBuffer2.VTable, @ptrCast(self.vtable)).SetSampleProperties(@as(*const INSSBuffer2, @ptrCast(self)), cbProperties, pbProperties);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_INSSBuffer3_Value = Guid.initString("c87ceaaf-75be-4bc4-84eb-ac2798507672");
pub const IID_INSSBuffer3 = &IID_INSSBuffer3_Value;
pub const INSSBuffer3 = extern struct {
    pub const VTable = extern struct {
        base: INSSBuffer2.VTable,
        SetProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INSSBuffer3,
                guidBufferProperty: Guid,
                pvBufferProperty: ?*anyopaque,
                dwBufferPropertySize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INSSBuffer3,
                guidBufferProperty: Guid,
                pvBufferProperty: ?*anyopaque,
                dwBufferPropertySize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INSSBuffer3,
                guidBufferProperty: Guid,
                pvBufferProperty: ?*anyopaque,
                pdwBufferPropertySize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INSSBuffer3,
                guidBufferProperty: Guid,
                pvBufferProperty: ?*anyopaque,
                pdwBufferPropertySize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace INSSBuffer2.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INSSBuffer3_SetProperty(self: *const T, guidBufferProperty: Guid, pvBufferProperty: ?*anyopaque, dwBufferPropertySize: u32) HRESULT {
                return @as(*const INSSBuffer3.VTable, @ptrCast(self.vtable)).SetProperty(@as(*const INSSBuffer3, @ptrCast(self)), guidBufferProperty, pvBufferProperty, dwBufferPropertySize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INSSBuffer3_GetProperty(self: *const T, guidBufferProperty: Guid, pvBufferProperty: ?*anyopaque, pdwBufferPropertySize: ?*u32) HRESULT {
                return @as(*const INSSBuffer3.VTable, @ptrCast(self.vtable)).GetProperty(@as(*const INSSBuffer3, @ptrCast(self)), guidBufferProperty, pvBufferProperty, pdwBufferPropertySize);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_INSSBuffer4_Value = Guid.initString("b6b8fd5a-32e2-49d4-a910-c26cc85465ed");
pub const IID_INSSBuffer4 = &IID_INSSBuffer4_Value;
pub const INSSBuffer4 = extern struct {
    pub const VTable = extern struct {
        base: INSSBuffer3.VTable,
        GetPropertyCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INSSBuffer4,
                pcBufferProperties: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INSSBuffer4,
                pcBufferProperties: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPropertyByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INSSBuffer4,
                dwBufferPropertyIndex: u32,
                pguidBufferProperty: ?*Guid,
                pvBufferProperty: ?*anyopaque,
                pdwBufferPropertySize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INSSBuffer4,
                dwBufferPropertyIndex: u32,
                pguidBufferProperty: ?*Guid,
                pvBufferProperty: ?*anyopaque,
                pdwBufferPropertySize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace INSSBuffer3.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INSSBuffer4_GetPropertyCount(self: *const T, pcBufferProperties: ?*u32) HRESULT {
                return @as(*const INSSBuffer4.VTable, @ptrCast(self.vtable)).GetPropertyCount(@as(*const INSSBuffer4, @ptrCast(self)), pcBufferProperties);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INSSBuffer4_GetPropertyByIndex(self: *const T, dwBufferPropertyIndex: u32, pguidBufferProperty: ?*Guid, pvBufferProperty: ?*anyopaque, pdwBufferPropertySize: ?*u32) HRESULT {
                return @as(*const INSSBuffer4.VTable, @ptrCast(self.vtable)).GetPropertyByIndex(@as(*const INSSBuffer4, @ptrCast(self)), dwBufferPropertyIndex, pguidBufferProperty, pvBufferProperty, pdwBufferPropertySize);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMSBufferAllocator_Value = Guid.initString("61103ca4-2033-11d2-9ef1-006097d2d7cf");
pub const IID_IWMSBufferAllocator = &IID_IWMSBufferAllocator_Value;
pub const IWMSBufferAllocator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AllocateBuffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMSBufferAllocator,
                dwMaxBufferSize: u32,
                ppBuffer: ?*?*INSSBuffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMSBufferAllocator,
                dwMaxBufferSize: u32,
                ppBuffer: ?*?*INSSBuffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AllocatePageSizeBuffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMSBufferAllocator,
                dwMaxBufferSize: u32,
                ppBuffer: ?*?*INSSBuffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMSBufferAllocator,
                dwMaxBufferSize: u32,
                ppBuffer: ?*?*INSSBuffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMSBufferAllocator_AllocateBuffer(self: *const T, dwMaxBufferSize: u32, ppBuffer: ?*?*INSSBuffer) HRESULT {
                return @as(*const IWMSBufferAllocator.VTable, @ptrCast(self.vtable)).AllocateBuffer(@as(*const IWMSBufferAllocator, @ptrCast(self)), dwMaxBufferSize, ppBuffer);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMSBufferAllocator_AllocatePageSizeBuffer(self: *const T, dwMaxBufferSize: u32, ppBuffer: ?*?*INSSBuffer) HRESULT {
                return @as(*const IWMSBufferAllocator.VTable, @ptrCast(self.vtable)).AllocatePageSizeBuffer(@as(*const IWMSBufferAllocator, @ptrCast(self)), dwMaxBufferSize, ppBuffer);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const WEBSTREAM_SAMPLE_TYPE = enum(i32) {
    FILE = 1,
    RENDER = 2,
};
pub const WEBSTREAM_SAMPLE_TYPE_FILE = WEBSTREAM_SAMPLE_TYPE.FILE;
pub const WEBSTREAM_SAMPLE_TYPE_RENDER = WEBSTREAM_SAMPLE_TYPE.RENDER;

pub const WM_SF_TYPE = enum(i32) {
    CLEANPOINT = 1,
    DISCONTINUITY = 2,
    DATALOSS = 4,
};
pub const WM_SF_CLEANPOINT = WM_SF_TYPE.CLEANPOINT;
pub const WM_SF_DISCONTINUITY = WM_SF_TYPE.DISCONTINUITY;
pub const WM_SF_DATALOSS = WM_SF_TYPE.DATALOSS;

pub const WM_SFEX_TYPE = enum(i32) {
    NOTASYNCPOINT = 2,
    DATALOSS = 4,
};
pub const WM_SFEX_NOTASYNCPOINT = WM_SFEX_TYPE.NOTASYNCPOINT;
pub const WM_SFEX_DATALOSS = WM_SFEX_TYPE.DATALOSS;

pub const WMT_STATUS = enum(i32) {
    ERROR = 0,
    OPENED = 1,
    BUFFERING_START = 2,
    BUFFERING_STOP = 3,
    EOF = 4,
    // END_OF_FILE = 4, this enum value conflicts with EOF
    END_OF_SEGMENT = 5,
    END_OF_STREAMING = 6,
    LOCATING = 7,
    CONNECTING = 8,
    NO_RIGHTS = 9,
    MISSING_CODEC = 10,
    STARTED = 11,
    STOPPED = 12,
    CLOSED = 13,
    STRIDING = 14,
    TIMER = 15,
    INDEX_PROGRESS = 16,
    SAVEAS_START = 17,
    SAVEAS_STOP = 18,
    NEW_SOURCEFLAGS = 19,
    NEW_METADATA = 20,
    BACKUPRESTORE_BEGIN = 21,
    SOURCE_SWITCH = 22,
    ACQUIRE_LICENSE = 23,
    INDIVIDUALIZE = 24,
    NEEDS_INDIVIDUALIZATION = 25,
    NO_RIGHTS_EX = 26,
    BACKUPRESTORE_END = 27,
    BACKUPRESTORE_CONNECTING = 28,
    BACKUPRESTORE_DISCONNECTING = 29,
    ERROR_WITHURL = 30,
    RESTRICTED_LICENSE = 31,
    CLIENT_CONNECT = 32,
    CLIENT_DISCONNECT = 33,
    NATIVE_OUTPUT_PROPS_CHANGED = 34,
    RECONNECT_START = 35,
    RECONNECT_END = 36,
    CLIENT_CONNECT_EX = 37,
    CLIENT_DISCONNECT_EX = 38,
    SET_FEC_SPAN = 39,
    PREROLL_READY = 40,
    PREROLL_COMPLETE = 41,
    CLIENT_PROPERTIES = 42,
    LICENSEURL_SIGNATURE_STATE = 43,
    INIT_PLAYLIST_BURN = 44,
    TRANSCRYPTOR_INIT = 45,
    TRANSCRYPTOR_SEEKED = 46,
    TRANSCRYPTOR_READ = 47,
    TRANSCRYPTOR_CLOSED = 48,
    PROXIMITY_RESULT = 49,
    PROXIMITY_COMPLETED = 50,
    CONTENT_ENABLER = 51,
};
pub const WMT_ERROR = WMT_STATUS.ERROR;
pub const WMT_OPENED = WMT_STATUS.OPENED;
pub const WMT_BUFFERING_START = WMT_STATUS.BUFFERING_START;
pub const WMT_BUFFERING_STOP = WMT_STATUS.BUFFERING_STOP;
pub const WMT_EOF = WMT_STATUS.EOF;
pub const WMT_END_OF_FILE = WMT_STATUS.EOF;
pub const WMT_END_OF_SEGMENT = WMT_STATUS.END_OF_SEGMENT;
pub const WMT_END_OF_STREAMING = WMT_STATUS.END_OF_STREAMING;
pub const WMT_LOCATING = WMT_STATUS.LOCATING;
pub const WMT_CONNECTING = WMT_STATUS.CONNECTING;
pub const WMT_NO_RIGHTS = WMT_STATUS.NO_RIGHTS;
pub const WMT_MISSING_CODEC = WMT_STATUS.MISSING_CODEC;
pub const WMT_STARTED = WMT_STATUS.STARTED;
pub const WMT_STOPPED = WMT_STATUS.STOPPED;
pub const WMT_CLOSED = WMT_STATUS.CLOSED;
pub const WMT_STRIDING = WMT_STATUS.STRIDING;
pub const WMT_TIMER = WMT_STATUS.TIMER;
pub const WMT_INDEX_PROGRESS = WMT_STATUS.INDEX_PROGRESS;
pub const WMT_SAVEAS_START = WMT_STATUS.SAVEAS_START;
pub const WMT_SAVEAS_STOP = WMT_STATUS.SAVEAS_STOP;
pub const WMT_NEW_SOURCEFLAGS = WMT_STATUS.NEW_SOURCEFLAGS;
pub const WMT_NEW_METADATA = WMT_STATUS.NEW_METADATA;
pub const WMT_BACKUPRESTORE_BEGIN = WMT_STATUS.BACKUPRESTORE_BEGIN;
pub const WMT_SOURCE_SWITCH = WMT_STATUS.SOURCE_SWITCH;
pub const WMT_ACQUIRE_LICENSE = WMT_STATUS.ACQUIRE_LICENSE;
pub const WMT_INDIVIDUALIZE = WMT_STATUS.INDIVIDUALIZE;
pub const WMT_NEEDS_INDIVIDUALIZATION = WMT_STATUS.NEEDS_INDIVIDUALIZATION;
pub const WMT_NO_RIGHTS_EX = WMT_STATUS.NO_RIGHTS_EX;
pub const WMT_BACKUPRESTORE_END = WMT_STATUS.BACKUPRESTORE_END;
pub const WMT_BACKUPRESTORE_CONNECTING = WMT_STATUS.BACKUPRESTORE_CONNECTING;
pub const WMT_BACKUPRESTORE_DISCONNECTING = WMT_STATUS.BACKUPRESTORE_DISCONNECTING;
pub const WMT_ERROR_WITHURL = WMT_STATUS.ERROR_WITHURL;
pub const WMT_RESTRICTED_LICENSE = WMT_STATUS.RESTRICTED_LICENSE;
pub const WMT_CLIENT_CONNECT = WMT_STATUS.CLIENT_CONNECT;
pub const WMT_CLIENT_DISCONNECT = WMT_STATUS.CLIENT_DISCONNECT;
pub const WMT_NATIVE_OUTPUT_PROPS_CHANGED = WMT_STATUS.NATIVE_OUTPUT_PROPS_CHANGED;
pub const WMT_RECONNECT_START = WMT_STATUS.RECONNECT_START;
pub const WMT_RECONNECT_END = WMT_STATUS.RECONNECT_END;
pub const WMT_CLIENT_CONNECT_EX = WMT_STATUS.CLIENT_CONNECT_EX;
pub const WMT_CLIENT_DISCONNECT_EX = WMT_STATUS.CLIENT_DISCONNECT_EX;
pub const WMT_SET_FEC_SPAN = WMT_STATUS.SET_FEC_SPAN;
pub const WMT_PREROLL_READY = WMT_STATUS.PREROLL_READY;
pub const WMT_PREROLL_COMPLETE = WMT_STATUS.PREROLL_COMPLETE;
pub const WMT_CLIENT_PROPERTIES = WMT_STATUS.CLIENT_PROPERTIES;
pub const WMT_LICENSEURL_SIGNATURE_STATE = WMT_STATUS.LICENSEURL_SIGNATURE_STATE;
pub const WMT_INIT_PLAYLIST_BURN = WMT_STATUS.INIT_PLAYLIST_BURN;
pub const WMT_TRANSCRYPTOR_INIT = WMT_STATUS.TRANSCRYPTOR_INIT;
pub const WMT_TRANSCRYPTOR_SEEKED = WMT_STATUS.TRANSCRYPTOR_SEEKED;
pub const WMT_TRANSCRYPTOR_READ = WMT_STATUS.TRANSCRYPTOR_READ;
pub const WMT_TRANSCRYPTOR_CLOSED = WMT_STATUS.TRANSCRYPTOR_CLOSED;
pub const WMT_PROXIMITY_RESULT = WMT_STATUS.PROXIMITY_RESULT;
pub const WMT_PROXIMITY_COMPLETED = WMT_STATUS.PROXIMITY_COMPLETED;
pub const WMT_CONTENT_ENABLER = WMT_STATUS.CONTENT_ENABLER;

pub const WMT_STREAM_SELECTION = enum(i32) {
    OFF = 0,
    CLEANPOINT_ONLY = 1,
    ON = 2,
};
pub const WMT_OFF = WMT_STREAM_SELECTION.OFF;
pub const WMT_CLEANPOINT_ONLY = WMT_STREAM_SELECTION.CLEANPOINT_ONLY;
pub const WMT_ON = WMT_STREAM_SELECTION.ON;

pub const WMT_IMAGE_TYPE = enum(i32) {
    NONE = 0,
    BITMAP = 1,
    JPEG = 2,
    GIF = 3,
};
pub const WMT_IT_NONE = WMT_IMAGE_TYPE.NONE;
pub const WMT_IT_BITMAP = WMT_IMAGE_TYPE.BITMAP;
pub const WMT_IT_JPEG = WMT_IMAGE_TYPE.JPEG;
pub const WMT_IT_GIF = WMT_IMAGE_TYPE.GIF;

pub const WMT_ATTR_DATATYPE = enum(i32) {
    DWORD = 0,
    STRING = 1,
    BINARY = 2,
    BOOL = 3,
    QWORD = 4,
    WORD = 5,
    GUID = 6,
};
pub const WMT_TYPE_DWORD = WMT_ATTR_DATATYPE.DWORD;
pub const WMT_TYPE_STRING = WMT_ATTR_DATATYPE.STRING;
pub const WMT_TYPE_BINARY = WMT_ATTR_DATATYPE.BINARY;
pub const WMT_TYPE_BOOL = WMT_ATTR_DATATYPE.BOOL;
pub const WMT_TYPE_QWORD = WMT_ATTR_DATATYPE.QWORD;
pub const WMT_TYPE_WORD = WMT_ATTR_DATATYPE.WORD;
pub const WMT_TYPE_GUID = WMT_ATTR_DATATYPE.GUID;

pub const WMT_ATTR_IMAGETYPE = enum(i32) {
    BITMAP = 1,
    JPEG = 2,
    GIF = 3,
};
pub const WMT_IMAGETYPE_BITMAP = WMT_ATTR_IMAGETYPE.BITMAP;
pub const WMT_IMAGETYPE_JPEG = WMT_ATTR_IMAGETYPE.JPEG;
pub const WMT_IMAGETYPE_GIF = WMT_ATTR_IMAGETYPE.GIF;

pub const WMT_VERSION = enum(i32) {
    @"4_0" = 262144,
    @"7_0" = 458752,
    @"8_0" = 524288,
    @"9_0" = 589824,
};
pub const WMT_VER_4_0 = WMT_VERSION.@"4_0";
pub const WMT_VER_7_0 = WMT_VERSION.@"7_0";
pub const WMT_VER_8_0 = WMT_VERSION.@"8_0";
pub const WMT_VER_9_0 = WMT_VERSION.@"9_0";

pub const WMT_STORAGE_FORMAT = enum(i32) {
    MP3 = 0,
    V1 = 1,
};
pub const WMT_Storage_Format_MP3 = WMT_STORAGE_FORMAT.MP3;
pub const WMT_Storage_Format_V1 = WMT_STORAGE_FORMAT.V1;

pub const WMT_DRMLA_TRUST = enum(i32) {
    UNTRUSTED = 0,
    TRUSTED = 1,
    TAMPERED = 2,
};
pub const WMT_DRMLA_UNTRUSTED = WMT_DRMLA_TRUST.UNTRUSTED;
pub const WMT_DRMLA_TRUSTED = WMT_DRMLA_TRUST.TRUSTED;
pub const WMT_DRMLA_TAMPERED = WMT_DRMLA_TRUST.TAMPERED;

pub const WMT_TRANSPORT_TYPE = enum(i32) {
    Unreliable = 0,
    Reliable = 1,
};
pub const WMT_Transport_Type_Unreliable = WMT_TRANSPORT_TYPE.Unreliable;
pub const WMT_Transport_Type_Reliable = WMT_TRANSPORT_TYPE.Reliable;

pub const WMT_NET_PROTOCOL = enum(i32) {
    P = 0,
};
pub const WMT_PROTOCOL_HTTP = WMT_NET_PROTOCOL.P;

pub const WMT_PLAY_MODE = enum(i32) {
    AUTOSELECT = 0,
    LOCAL = 1,
    DOWNLOAD = 2,
    STREAMING = 3,
};
pub const WMT_PLAY_MODE_AUTOSELECT = WMT_PLAY_MODE.AUTOSELECT;
pub const WMT_PLAY_MODE_LOCAL = WMT_PLAY_MODE.LOCAL;
pub const WMT_PLAY_MODE_DOWNLOAD = WMT_PLAY_MODE.DOWNLOAD;
pub const WMT_PLAY_MODE_STREAMING = WMT_PLAY_MODE.STREAMING;

pub const WMT_PROXY_SETTINGS = enum(i32) {
    NONE = 0,
    MANUAL = 1,
    AUTO = 2,
    BROWSER = 3,
    MAX = 4,
};
pub const WMT_PROXY_SETTING_NONE = WMT_PROXY_SETTINGS.NONE;
pub const WMT_PROXY_SETTING_MANUAL = WMT_PROXY_SETTINGS.MANUAL;
pub const WMT_PROXY_SETTING_AUTO = WMT_PROXY_SETTINGS.AUTO;
pub const WMT_PROXY_SETTING_BROWSER = WMT_PROXY_SETTINGS.BROWSER;
pub const WMT_PROXY_SETTING_MAX = WMT_PROXY_SETTINGS.MAX;

pub const WMT_CODEC_INFO_TYPE = enum(i32) {
    AUDIO = 0,
    VIDEO = 1,
    UNKNOWN = -1,
};
pub const WMT_CODECINFO_AUDIO = WMT_CODEC_INFO_TYPE.AUDIO;
pub const WMT_CODECINFO_VIDEO = WMT_CODEC_INFO_TYPE.VIDEO;
pub const WMT_CODECINFO_UNKNOWN = WMT_CODEC_INFO_TYPE.UNKNOWN;

pub const WM_DM_INTERLACED_TYPE = enum(i32) {
    NOTINTERLACED = 0,
    DEINTERLACE_NORMAL = 1,
    DEINTERLACE_HALFSIZE = 2,
    DEINTERLACE_HALFSIZEDOUBLERATE = 3,
    DEINTERLACE_INVERSETELECINE = 4,
    DEINTERLACE_VERTICALHALFSIZEDOUBLERATE = 5,
};
pub const WM_DM_NOTINTERLACED = WM_DM_INTERLACED_TYPE.NOTINTERLACED;
pub const WM_DM_DEINTERLACE_NORMAL = WM_DM_INTERLACED_TYPE.DEINTERLACE_NORMAL;
pub const WM_DM_DEINTERLACE_HALFSIZE = WM_DM_INTERLACED_TYPE.DEINTERLACE_HALFSIZE;
pub const WM_DM_DEINTERLACE_HALFSIZEDOUBLERATE = WM_DM_INTERLACED_TYPE.DEINTERLACE_HALFSIZEDOUBLERATE;
pub const WM_DM_DEINTERLACE_INVERSETELECINE = WM_DM_INTERLACED_TYPE.DEINTERLACE_INVERSETELECINE;
pub const WM_DM_DEINTERLACE_VERTICALHALFSIZEDOUBLERATE = WM_DM_INTERLACED_TYPE.DEINTERLACE_VERTICALHALFSIZEDOUBLERATE;

pub const WM_DM_IT_FIRST_FRAME_COHERENCY = enum(i32) {
    DISABLE_COHERENT_MODE = 0,
    FIRST_FRAME_IN_CLIP_IS_AA_TOP = 1,
    FIRST_FRAME_IN_CLIP_IS_BB_TOP = 2,
    FIRST_FRAME_IN_CLIP_IS_BC_TOP = 3,
    FIRST_FRAME_IN_CLIP_IS_CD_TOP = 4,
    FIRST_FRAME_IN_CLIP_IS_DD_TOP = 5,
    FIRST_FRAME_IN_CLIP_IS_AA_BOTTOM = 6,
    FIRST_FRAME_IN_CLIP_IS_BB_BOTTOM = 7,
    FIRST_FRAME_IN_CLIP_IS_BC_BOTTOM = 8,
    FIRST_FRAME_IN_CLIP_IS_CD_BOTTOM = 9,
    FIRST_FRAME_IN_CLIP_IS_DD_BOTTOM = 10,
};
pub const WM_DM_IT_DISABLE_COHERENT_MODE = WM_DM_IT_FIRST_FRAME_COHERENCY.DISABLE_COHERENT_MODE;
pub const WM_DM_IT_FIRST_FRAME_IN_CLIP_IS_AA_TOP = WM_DM_IT_FIRST_FRAME_COHERENCY.FIRST_FRAME_IN_CLIP_IS_AA_TOP;
pub const WM_DM_IT_FIRST_FRAME_IN_CLIP_IS_BB_TOP = WM_DM_IT_FIRST_FRAME_COHERENCY.FIRST_FRAME_IN_CLIP_IS_BB_TOP;
pub const WM_DM_IT_FIRST_FRAME_IN_CLIP_IS_BC_TOP = WM_DM_IT_FIRST_FRAME_COHERENCY.FIRST_FRAME_IN_CLIP_IS_BC_TOP;
pub const WM_DM_IT_FIRST_FRAME_IN_CLIP_IS_CD_TOP = WM_DM_IT_FIRST_FRAME_COHERENCY.FIRST_FRAME_IN_CLIP_IS_CD_TOP;
pub const WM_DM_IT_FIRST_FRAME_IN_CLIP_IS_DD_TOP = WM_DM_IT_FIRST_FRAME_COHERENCY.FIRST_FRAME_IN_CLIP_IS_DD_TOP;
pub const WM_DM_IT_FIRST_FRAME_IN_CLIP_IS_AA_BOTTOM = WM_DM_IT_FIRST_FRAME_COHERENCY.FIRST_FRAME_IN_CLIP_IS_AA_BOTTOM;
pub const WM_DM_IT_FIRST_FRAME_IN_CLIP_IS_BB_BOTTOM = WM_DM_IT_FIRST_FRAME_COHERENCY.FIRST_FRAME_IN_CLIP_IS_BB_BOTTOM;
pub const WM_DM_IT_FIRST_FRAME_IN_CLIP_IS_BC_BOTTOM = WM_DM_IT_FIRST_FRAME_COHERENCY.FIRST_FRAME_IN_CLIP_IS_BC_BOTTOM;
pub const WM_DM_IT_FIRST_FRAME_IN_CLIP_IS_CD_BOTTOM = WM_DM_IT_FIRST_FRAME_COHERENCY.FIRST_FRAME_IN_CLIP_IS_CD_BOTTOM;
pub const WM_DM_IT_FIRST_FRAME_IN_CLIP_IS_DD_BOTTOM = WM_DM_IT_FIRST_FRAME_COHERENCY.FIRST_FRAME_IN_CLIP_IS_DD_BOTTOM;

pub const WMT_OFFSET_FORMAT = enum(i32) {
    @"100NS" = 0,
    FRAME_NUMBERS = 1,
    PLAYLIST_OFFSET = 2,
    TIMECODE = 3,
    @"100NS_APPROXIMATE" = 4,
};
pub const WMT_OFFSET_FORMAT_100NS = WMT_OFFSET_FORMAT.@"100NS";
pub const WMT_OFFSET_FORMAT_FRAME_NUMBERS = WMT_OFFSET_FORMAT.FRAME_NUMBERS;
pub const WMT_OFFSET_FORMAT_PLAYLIST_OFFSET = WMT_OFFSET_FORMAT.PLAYLIST_OFFSET;
pub const WMT_OFFSET_FORMAT_TIMECODE = WMT_OFFSET_FORMAT.TIMECODE;
pub const WMT_OFFSET_FORMAT_100NS_APPROXIMATE = WMT_OFFSET_FORMAT.@"100NS_APPROXIMATE";

pub const WMT_INDEXER_TYPE = enum(i32) {
    PRESENTATION_TIME = 0,
    FRAME_NUMBERS = 1,
    TIMECODE = 2,
};
pub const WMT_IT_PRESENTATION_TIME = WMT_INDEXER_TYPE.PRESENTATION_TIME;
pub const WMT_IT_FRAME_NUMBERS = WMT_INDEXER_TYPE.FRAME_NUMBERS;
pub const WMT_IT_TIMECODE = WMT_INDEXER_TYPE.TIMECODE;

pub const WMT_INDEX_TYPE = enum(i32) {
    DATA_UNIT = 1,
    OBJECT = 2,
    CLEAN_POINT = 3,
};
pub const WMT_IT_NEAREST_DATA_UNIT = WMT_INDEX_TYPE.DATA_UNIT;
pub const WMT_IT_NEAREST_OBJECT = WMT_INDEX_TYPE.OBJECT;
pub const WMT_IT_NEAREST_CLEAN_POINT = WMT_INDEX_TYPE.CLEAN_POINT;

pub const WMT_FILESINK_MODE = enum(i32) {
    SINGLE_BUFFERS = 1,
    FILESINK_DATA_UNITS = 2,
    FILESINK_UNBUFFERED = 4,
};
pub const WMT_FM_SINGLE_BUFFERS = WMT_FILESINK_MODE.SINGLE_BUFFERS;
pub const WMT_FM_FILESINK_DATA_UNITS = WMT_FILESINK_MODE.FILESINK_DATA_UNITS;
pub const WMT_FM_FILESINK_UNBUFFERED = WMT_FILESINK_MODE.FILESINK_UNBUFFERED;

pub const WMT_MUSICSPEECH_CLASS_MODE = enum(i32) {
    MUSIC = 0,
    SPEECH = 1,
    MIXED = 2,
};
pub const WMT_MS_CLASS_MUSIC = WMT_MUSICSPEECH_CLASS_MODE.MUSIC;
pub const WMT_MS_CLASS_SPEECH = WMT_MUSICSPEECH_CLASS_MODE.SPEECH;
pub const WMT_MS_CLASS_MIXED = WMT_MUSICSPEECH_CLASS_MODE.MIXED;

pub const WMT_WATERMARK_ENTRY_TYPE = enum(i32) {
    AUDIO = 1,
    VIDEO = 2,
};
pub const WMT_WMETYPE_AUDIO = WMT_WATERMARK_ENTRY_TYPE.AUDIO;
pub const WMT_WMETYPE_VIDEO = WMT_WATERMARK_ENTRY_TYPE.VIDEO;

pub const WM_PLAYBACK_DRC_LEVEL = enum(i32) {
    HIGH = 0,
    MEDIUM = 1,
    LOW = 2,
};
pub const WM_PLAYBACK_DRC_HIGH = WM_PLAYBACK_DRC_LEVEL.HIGH;
pub const WM_PLAYBACK_DRC_MEDIUM = WM_PLAYBACK_DRC_LEVEL.MEDIUM;
pub const WM_PLAYBACK_DRC_LOW = WM_PLAYBACK_DRC_LEVEL.LOW;

pub const WMT_TIMECODE_FRAMERATE = enum(i32) {
    @"30" = 0,
    @"30DROP" = 1,
    @"25" = 2,
    @"24" = 3,
};
pub const WMT_TIMECODE_FRAMERATE_30 = WMT_TIMECODE_FRAMERATE.@"30";
pub const WMT_TIMECODE_FRAMERATE_30DROP = WMT_TIMECODE_FRAMERATE.@"30DROP";
pub const WMT_TIMECODE_FRAMERATE_25 = WMT_TIMECODE_FRAMERATE.@"25";
pub const WMT_TIMECODE_FRAMERATE_24 = WMT_TIMECODE_FRAMERATE.@"24";

pub const WMT_CREDENTIAL_FLAGS = enum(i32) {
    SAVE = 1,
    DONT_CACHE = 2,
    CLEAR_TEXT = 4,
    PROXY = 8,
    ENCRYPT = 16,
};
pub const WMT_CREDENTIAL_SAVE = WMT_CREDENTIAL_FLAGS.SAVE;
pub const WMT_CREDENTIAL_DONT_CACHE = WMT_CREDENTIAL_FLAGS.DONT_CACHE;
pub const WMT_CREDENTIAL_CLEAR_TEXT = WMT_CREDENTIAL_FLAGS.CLEAR_TEXT;
pub const WMT_CREDENTIAL_PROXY = WMT_CREDENTIAL_FLAGS.PROXY;
pub const WMT_CREDENTIAL_ENCRYPT = WMT_CREDENTIAL_FLAGS.ENCRYPT;

pub const WM_AETYPE = enum(i32) {
    INCLUDE = 105,
    EXCLUDE = 101,
};
pub const WM_AETYPE_INCLUDE = WM_AETYPE.INCLUDE;
pub const WM_AETYPE_EXCLUDE = WM_AETYPE.EXCLUDE;

pub const WMT_RIGHTS = enum(i32) {
    PLAYBACK = 1,
    COPY_TO_NON_SDMI_DEVICE = 2,
    COPY_TO_CD = 8,
    COPY_TO_SDMI_DEVICE = 16,
    ONE_TIME = 32,
    SAVE_STREAM_PROTECTED = 64,
    COPY = 128,
    COLLABORATIVE_PLAY = 256,
    SDMI_TRIGGER = 65536,
    SDMI_NOMORECOPIES = 131072,
};
pub const WMT_RIGHT_PLAYBACK = WMT_RIGHTS.PLAYBACK;
pub const WMT_RIGHT_COPY_TO_NON_SDMI_DEVICE = WMT_RIGHTS.COPY_TO_NON_SDMI_DEVICE;
pub const WMT_RIGHT_COPY_TO_CD = WMT_RIGHTS.COPY_TO_CD;
pub const WMT_RIGHT_COPY_TO_SDMI_DEVICE = WMT_RIGHTS.COPY_TO_SDMI_DEVICE;
pub const WMT_RIGHT_ONE_TIME = WMT_RIGHTS.ONE_TIME;
pub const WMT_RIGHT_SAVE_STREAM_PROTECTED = WMT_RIGHTS.SAVE_STREAM_PROTECTED;
pub const WMT_RIGHT_COPY = WMT_RIGHTS.COPY;
pub const WMT_RIGHT_COLLABORATIVE_PLAY = WMT_RIGHTS.COLLABORATIVE_PLAY;
pub const WMT_RIGHT_SDMI_TRIGGER = WMT_RIGHTS.SDMI_TRIGGER;
pub const WMT_RIGHT_SDMI_NOMORECOPIES = WMT_RIGHTS.SDMI_NOMORECOPIES;

pub const WM_STREAM_PRIORITY_RECORD = extern struct {
    wStreamNumber: u16 align(2),
    fMandatory: BOOL align(2),
};

pub const WM_WRITER_STATISTICS = extern struct {
    qwSampleCount: u64,
    qwByteCount: u64,
    qwDroppedSampleCount: u64,
    qwDroppedByteCount: u64,
    dwCurrentBitrate: u32,
    dwAverageBitrate: u32,
    dwExpectedBitrate: u32,
    dwCurrentSampleRate: u32,
    dwAverageSampleRate: u32,
    dwExpectedSampleRate: u32,
};

pub const WM_WRITER_STATISTICS_EX = extern struct {
    dwBitratePlusOverhead: u32,
    dwCurrentSampleDropRateInQueue: u32,
    dwCurrentSampleDropRateInCodec: u32,
    dwCurrentSampleDropRateInMultiplexer: u32,
    dwTotalSampleDropsInQueue: u32,
    dwTotalSampleDropsInCodec: u32,
    dwTotalSampleDropsInMultiplexer: u32,
};

pub const WM_READER_STATISTICS = extern struct {
    cbSize: u32,
    dwBandwidth: u32,
    cPacketsReceived: u32,
    cPacketsRecovered: u32,
    cPacketsLost: u32,
    wQuality: u16,
};

pub const WM_READER_CLIENTINFO = extern struct {
    cbSize: u32,
    wszLang: ?PWSTR,
    wszBrowserUserAgent: ?PWSTR,
    wszBrowserWebPage: ?PWSTR,
    qwReserved: u64,
    pReserved: ?*LPARAM,
    wszHostExe: ?PWSTR,
    qwHostVersion: u64,
    wszPlayerUserAgent: ?PWSTR,
};

pub const WM_CLIENT_PROPERTIES = extern struct {
    dwIPAddress: u32,
    dwPort: u32,
};

pub const WM_CLIENT_PROPERTIES_EX = extern struct {
    cbSize: u32,
    pwszIPAddress: ?[*:0]const u16,
    pwszPort: ?[*:0]const u16,
    pwszDNSName: ?[*:0]const u16,
};

pub const WM_PORT_NUMBER_RANGE = extern struct {
    wPortBegin: u16,
    wPortEnd: u16,
};

pub const WMT_BUFFER_SEGMENT = extern struct {
    pBuffer: ?*INSSBuffer,
    cbOffset: u32,
    cbLength: u32,
};

pub const WMT_PAYLOAD_FRAGMENT = extern struct {
    dwPayloadIndex: u32,
    segmentData: WMT_BUFFER_SEGMENT,
};

pub const WMT_FILESINK_DATA_UNIT = extern struct {
    packetHeaderBuffer: WMT_BUFFER_SEGMENT,
    cPayloads: u32,
    pPayloadHeaderBuffers: ?*WMT_BUFFER_SEGMENT,
    cPayloadDataFragments: u32,
    pPayloadDataFragments: ?*WMT_PAYLOAD_FRAGMENT,
};

pub const WMT_WEBSTREAM_FORMAT = extern struct {
    cbSize: u16,
    cbSampleHeaderFixedData: u16,
    wVersion: u16,
    wReserved: u16,
};

pub const WMT_WEBSTREAM_SAMPLE_HEADER = extern struct {
    cbLength: u16,
    wPart: u16,
    cTotalParts: u16,
    wSampleType: u16,
    wszURL: [1]u16,
};

pub const WM_ADDRESS_ACCESSENTRY = extern struct {
    dwIPAddress: u32,
    dwMask: u32,
};

pub const WM_PICTURE = extern struct {
    pwszMIMEType: ?PWSTR align(1),
    bPictureType: u8 align(1),
    pwszDescription: ?PWSTR align(1),
    dwDataLen: u32 align(1),
    pbData: ?*u8 align(1),
};

pub const WM_SYNCHRONISED_LYRICS = extern struct {
    bTimeStampFormat: u8 align(1),
    bContentType: u8 align(1),
    pwszContentDescriptor: ?PWSTR align(1),
    dwLyricsLen: u32 align(1),
    pbLyrics: ?*u8 align(1),
};

pub const WM_USER_WEB_URL = extern struct {
    pwszDescription: ?PWSTR align(1),
    pwszURL: ?PWSTR align(1),
};

pub const WM_USER_TEXT = extern struct {
    pwszDescription: ?PWSTR align(1),
    pwszText: ?PWSTR align(1),
};

pub const WM_LEAKY_BUCKET_PAIR = extern struct {
    dwBitrate: u32 align(1),
    msBufferWindow: u32 align(1),
};

pub const WM_STREAM_TYPE_INFO = extern struct {
    guidMajorType: Guid align(1),
    cbFormat: u32 align(1),
};

pub const WMT_WATERMARK_ENTRY = extern struct {
    wmetType: WMT_WATERMARK_ENTRY_TYPE,
    clsid: Guid,
    cbDisplayName: u32,
    pwszDisplayName: ?PWSTR,
};

pub const WMT_VIDEOIMAGE_SAMPLE = extern struct {
    dwMagic: u32,
    cbStruct: u32,
    dwControlFlags: u32,
    dwInputFlagsCur: u32,
    lCurMotionXtoX: i32,
    lCurMotionYtoX: i32,
    lCurMotionXoffset: i32,
    lCurMotionXtoY: i32,
    lCurMotionYtoY: i32,
    lCurMotionYoffset: i32,
    lCurBlendCoef1: i32,
    lCurBlendCoef2: i32,
    dwInputFlagsPrev: u32,
    lPrevMotionXtoX: i32,
    lPrevMotionYtoX: i32,
    lPrevMotionXoffset: i32,
    lPrevMotionXtoY: i32,
    lPrevMotionYtoY: i32,
    lPrevMotionYoffset: i32,
    lPrevBlendCoef1: i32,
    lPrevBlendCoef2: i32,
};

pub const WMT_VIDEOIMAGE_SAMPLE2 = extern struct {
    dwMagic: u32,
    dwStructSize: u32,
    dwControlFlags: u32,
    dwViewportWidth: u32,
    dwViewportHeight: u32,
    dwCurrImageWidth: u32,
    dwCurrImageHeight: u32,
    fCurrRegionX0: f32,
    fCurrRegionY0: f32,
    fCurrRegionWidth: f32,
    fCurrRegionHeight: f32,
    fCurrBlendCoef: f32,
    dwPrevImageWidth: u32,
    dwPrevImageHeight: u32,
    fPrevRegionX0: f32,
    fPrevRegionY0: f32,
    fPrevRegionWidth: f32,
    fPrevRegionHeight: f32,
    fPrevBlendCoef: f32,
    dwEffectType: u32,
    dwNumEffectParas: u32,
    fEffectPara0: f32,
    fEffectPara1: f32,
    fEffectPara2: f32,
    fEffectPara3: f32,
    fEffectPara4: f32,
    bKeepPrevImage: BOOL,
};

pub const WM_MEDIA_TYPE = extern struct {
    majortype: Guid,
    subtype: Guid,
    bFixedSizeSamples: BOOL,
    bTemporalCompression: BOOL,
    lSampleSize: u32,
    formattype: Guid,
    pUnk: ?*IUnknown,
    cbFormat: u32,
    pbFormat: ?*u8,
};

pub const WMVIDEOINFOHEADER = extern struct {
    rcSource: RECT,
    rcTarget: RECT,
    dwBitRate: u32,
    dwBitErrorRate: u32,
    AvgTimePerFrame: i64,
    bmiHeader: BITMAPINFOHEADER,
};

pub const WMVIDEOINFOHEADER2 = extern struct {
    rcSource: RECT,
    rcTarget: RECT,
    dwBitRate: u32,
    dwBitErrorRate: u32,
    AvgTimePerFrame: i64,
    dwInterlaceFlags: u32,
    dwCopyProtectFlags: u32,
    dwPictAspectRatioX: u32,
    dwPictAspectRatioY: u32,
    dwReserved1: u32,
    dwReserved2: u32,
    bmiHeader: BITMAPINFOHEADER,
};

pub const WMMPEG2VIDEOINFO = extern struct {
    hdr: WMVIDEOINFOHEADER2,
    dwStartTimeCode: u32,
    cbSequenceHeader: u32,
    dwProfile: u32,
    dwLevel: u32,
    dwFlags: u32,
    dwSequenceHeader: [1]u32,
};

pub const WMSCRIPTFORMAT = extern struct {
    scriptType: Guid,
};

pub const WMT_COLORSPACEINFO_EXTENSION_DATA = extern struct {
    ucColorPrimaries: u8,
    ucColorTransferChar: u8,
    ucColorMatrixCoef: u8,
};

pub const WMT_TIMECODE_EXTENSION_DATA = extern struct {
    wRange: u16 align(2),
    dwTimecode: u32 align(2),
    dwUserbits: u32 align(2),
    dwAmFlags: u32 align(2),
};

pub const DRM_VAL16 = extern struct {
    val: [16]u8,
};

const IID_IWMMediaProps_Value = Guid.initString("96406bce-2b2b-11d3-b36b-00c04f6108ff");
pub const IID_IWMMediaProps = &IID_IWMMediaProps_Value;
pub const IWMMediaProps = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMMediaProps,
                pguidType: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMMediaProps,
                pguidType: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMediaType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMMediaProps,
                pType: ?*WM_MEDIA_TYPE,
                pcbType: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMMediaProps,
                pType: ?*WM_MEDIA_TYPE,
                pcbType: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetMediaType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMMediaProps,
                pType: ?*WM_MEDIA_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMMediaProps,
                pType: ?*WM_MEDIA_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMMediaProps_GetType(self: *const T, pguidType: ?*Guid) HRESULT {
                return @as(*const IWMMediaProps.VTable, @ptrCast(self.vtable)).GetType(@as(*const IWMMediaProps, @ptrCast(self)), pguidType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMMediaProps_GetMediaType(self: *const T, pType: ?*WM_MEDIA_TYPE, pcbType: ?*u32) HRESULT {
                return @as(*const IWMMediaProps.VTable, @ptrCast(self.vtable)).GetMediaType(@as(*const IWMMediaProps, @ptrCast(self)), pType, pcbType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMMediaProps_SetMediaType(self: *const T, pType: ?*WM_MEDIA_TYPE) HRESULT {
                return @as(*const IWMMediaProps.VTable, @ptrCast(self.vtable)).SetMediaType(@as(*const IWMMediaProps, @ptrCast(self)), pType);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMVideoMediaProps_Value = Guid.initString("96406bcf-2b2b-11d3-b36b-00c04f6108ff");
pub const IID_IWMVideoMediaProps = &IID_IWMVideoMediaProps_Value;
pub const IWMVideoMediaProps = extern struct {
    pub const VTable = extern struct {
        base: IWMMediaProps.VTable,
        GetMaxKeyFrameSpacing: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMVideoMediaProps,
                pllTime: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMVideoMediaProps,
                pllTime: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetMaxKeyFrameSpacing: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMVideoMediaProps,
                llTime: i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMVideoMediaProps,
                llTime: i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetQuality: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMVideoMediaProps,
                pdwQuality: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMVideoMediaProps,
                pdwQuality: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetQuality: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMVideoMediaProps,
                dwQuality: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMVideoMediaProps,
                dwQuality: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWMMediaProps.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMVideoMediaProps_GetMaxKeyFrameSpacing(self: *const T, pllTime: ?*i64) HRESULT {
                return @as(*const IWMVideoMediaProps.VTable, @ptrCast(self.vtable)).GetMaxKeyFrameSpacing(@as(*const IWMVideoMediaProps, @ptrCast(self)), pllTime);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMVideoMediaProps_SetMaxKeyFrameSpacing(self: *const T, llTime: i64) HRESULT {
                return @as(*const IWMVideoMediaProps.VTable, @ptrCast(self.vtable)).SetMaxKeyFrameSpacing(@as(*const IWMVideoMediaProps, @ptrCast(self)), llTime);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMVideoMediaProps_GetQuality(self: *const T, pdwQuality: ?*u32) HRESULT {
                return @as(*const IWMVideoMediaProps.VTable, @ptrCast(self.vtable)).GetQuality(@as(*const IWMVideoMediaProps, @ptrCast(self)), pdwQuality);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMVideoMediaProps_SetQuality(self: *const T, dwQuality: u32) HRESULT {
                return @as(*const IWMVideoMediaProps.VTable, @ptrCast(self.vtable)).SetQuality(@as(*const IWMVideoMediaProps, @ptrCast(self)), dwQuality);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMWriter_Value = Guid.initString("96406bd4-2b2b-11d3-b36b-00c04f6108ff");
pub const IID_IWMWriter = &IID_IWMWriter_Value;
pub const IWMWriter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetProfileByID: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMWriter,
                guidProfile: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMWriter,
                guidProfile: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetProfile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMWriter,
                pProfile: ?*IWMProfile,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMWriter,
                pProfile: ?*IWMProfile,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputFilename: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMWriter,
                pwszFilename: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMWriter,
                pwszFilename: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInputCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMWriter,
                pcInputs: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMWriter,
                pcInputs: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInputProps: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMWriter,
                dwInputNum: u32,
                ppInput: ?*?*IWMInputMediaProps,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMWriter,
                dwInputNum: u32,
                ppInput: ?*?*IWMInputMediaProps,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetInputProps: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMWriter,
                dwInputNum: u32,
                pInput: ?*IWMInputMediaProps,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMWriter,
                dwInputNum: u32,
                pInput: ?*IWMInputMediaProps,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInputFormatCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMWriter,
                dwInputNumber: u32,
                pcFormats: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMWriter,
                dwInputNumber: u32,
                pcFormats: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInputFormat: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMWriter,
                dwInputNumber: u32,
                dwFormatNumber: u32,
                pProps: ?*?*IWMInputMediaProps,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMWriter,
                dwInputNumber: u32,
                dwFormatNumber: u32,
                pProps: ?*?*IWMInputMediaProps,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BeginWriting: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMWriter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMWriter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndWriting: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMWriter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMWriter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AllocateSample: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMWriter,
                dwSampleSize: u32,
                ppSample: ?*?*INSSBuffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMWriter,
                dwSampleSize: u32,
                ppSample: ?*?*INSSBuffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteSample: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMWriter,
                dwInputNum: u32,
                cnsSampleTime: u64,
                dwFlags: u32,
                pSample: ?*INSSBuffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMWriter,
                dwInputNum: u32,
                cnsSampleTime: u64,
                dwFlags: u32,
                pSample: ?*INSSBuffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Flush: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMWriter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMWriter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMWriter_SetProfileByID(self: *const T, guidProfile: ?*const Guid) HRESULT {
                return @as(*const IWMWriter.VTable, @ptrCast(self.vtable)).SetProfileByID(@as(*const IWMWriter, @ptrCast(self)), guidProfile);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMWriter_SetProfile(self: *const T, pProfile: ?*IWMProfile) HRESULT {
                return @as(*const IWMWriter.VTable, @ptrCast(self.vtable)).SetProfile(@as(*const IWMWriter, @ptrCast(self)), pProfile);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMWriter_SetOutputFilename(self: *const T, pwszFilename: ?[*:0]const u16) HRESULT {
                return @as(*const IWMWriter.VTable, @ptrCast(self.vtable)).SetOutputFilename(@as(*const IWMWriter, @ptrCast(self)), pwszFilename);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMWriter_GetInputCount(self: *const T, pcInputs: ?*u32) HRESULT {
                return @as(*const IWMWriter.VTable, @ptrCast(self.vtable)).GetInputCount(@as(*const IWMWriter, @ptrCast(self)), pcInputs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMWriter_GetInputProps(self: *const T, dwInputNum: u32, ppInput: ?*?*IWMInputMediaProps) HRESULT {
                return @as(*const IWMWriter.VTable, @ptrCast(self.vtable)).GetInputProps(@as(*const IWMWriter, @ptrCast(self)), dwInputNum, ppInput);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMWriter_SetInputProps(self: *const T, dwInputNum: u32, pInput: ?*IWMInputMediaProps) HRESULT {
                return @as(*const IWMWriter.VTable, @ptrCast(self.vtable)).SetInputProps(@as(*const IWMWriter, @ptrCast(self)), dwInputNum, pInput);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMWriter_GetInputFormatCount(self: *const T, dwInputNumber: u32, pcFormats: ?*u32) HRESULT {
                return @as(*const IWMWriter.VTable, @ptrCast(self.vtable)).GetInputFormatCount(@as(*const IWMWriter, @ptrCast(self)), dwInputNumber, pcFormats);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMWriter_GetInputFormat(self: *const T, dwInputNumber: u32, dwFormatNumber: u32, pProps: ?*?*IWMInputMediaProps) HRESULT {
                return @as(*const IWMWriter.VTable, @ptrCast(self.vtable)).GetInputFormat(@as(*const IWMWriter, @ptrCast(self)), dwInputNumber, dwFormatNumber, pProps);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMWriter_BeginWriting(self: *const T) HRESULT {
                return @as(*const IWMWriter.VTable, @ptrCast(self.vtable)).BeginWriting(@as(*const IWMWriter, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMWriter_EndWriting(self: *const T) HRESULT {
                return @as(*const IWMWriter.VTable, @ptrCast(self.vtable)).EndWriting(@as(*const IWMWriter, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMWriter_AllocateSample(self: *const T, dwSampleSize: u32, ppSample: ?*?*INSSBuffer) HRESULT {
                return @as(*const IWMWriter.VTable, @ptrCast(self.vtable)).AllocateSample(@as(*const IWMWriter, @ptrCast(self)), dwSampleSize, ppSample);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMWriter_WriteSample(self: *const T, dwInputNum: u32, cnsSampleTime: u64, dwFlags: u32, pSample: ?*INSSBuffer) HRESULT {
                return @as(*const IWMWriter.VTable, @ptrCast(self.vtable)).WriteSample(@as(*const IWMWriter, @ptrCast(self)), dwInputNum, cnsSampleTime, dwFlags, pSample);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMWriter_Flush(self: *const T) HRESULT {
                return @as(*const IWMWriter.VTable, @ptrCast(self.vtable)).Flush(@as(*const IWMWriter, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IWMDRMWriter_Value = Guid.initString("d6ea5dd0-12a0-43f4-90ab-a3fd451e6a07");
pub const IID_IWMDRMWriter = &IID_IWMDRMWriter_Value;
pub const IWMDRMWriter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GenerateKeySeed: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDRMWriter,
                pwszKeySeed: [*:0]u16,
                pcwchLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDRMWriter,
                pwszKeySeed: [*:0]u16,
                pcwchLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GenerateKeyID: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDRMWriter,
                pwszKeyID: [*:0]u16,
                pcwchLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDRMWriter,
                pwszKeyID: [*:0]u16,
                pcwchLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GenerateSigningKeyPair: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDRMWriter,
                pwszPrivKey: [*:0]u16,
                pcwchPrivKeyLength: ?*u32,
                pwszPubKey: [*:0]u16,
                pcwchPubKeyLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDRMWriter,
                pwszPrivKey: [*:0]u16,
                pcwchPrivKeyLength: ?*u32,
                pwszPubKey: [*:0]u16,
                pcwchPubKeyLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDRMAttribute: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDRMWriter,
                wStreamNum: u16,
                pszName: ?[*:0]const u16,
                Type: WMT_ATTR_DATATYPE,
                pValue: [*:0]const u8,
                cbLength: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDRMWriter,
                wStreamNum: u16,
                pszName: ?[*:0]const u16,
                Type: WMT_ATTR_DATATYPE,
                pValue: [*:0]const u8,
                cbLength: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDRMWriter_GenerateKeySeed(self: *const T, pwszKeySeed: [*:0]u16, pcwchLength: ?*u32) HRESULT {
                return @as(*const IWMDRMWriter.VTable, @ptrCast(self.vtable)).GenerateKeySeed(@as(*const IWMDRMWriter, @ptrCast(self)), pwszKeySeed, pcwchLength);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDRMWriter_GenerateKeyID(self: *const T, pwszKeyID: [*:0]u16, pcwchLength: ?*u32) HRESULT {
                return @as(*const IWMDRMWriter.VTable, @ptrCast(self.vtable)).GenerateKeyID(@as(*const IWMDRMWriter, @ptrCast(self)), pwszKeyID, pcwchLength);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDRMWriter_GenerateSigningKeyPair(self: *const T, pwszPrivKey: [*:0]u16, pcwchPrivKeyLength: ?*u32, pwszPubKey: [*:0]u16, pcwchPubKeyLength: ?*u32) HRESULT {
                return @as(*const IWMDRMWriter.VTable, @ptrCast(self.vtable)).GenerateSigningKeyPair(@as(*const IWMDRMWriter, @ptrCast(self)), pwszPrivKey, pcwchPrivKeyLength, pwszPubKey, pcwchPubKeyLength);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDRMWriter_SetDRMAttribute(self: *const T, wStreamNum: u16, pszName: ?[*:0]const u16, Type: WMT_ATTR_DATATYPE, pValue: [*:0]const u8, cbLength: u16) HRESULT {
                return @as(*const IWMDRMWriter.VTable, @ptrCast(self.vtable)).SetDRMAttribute(@as(*const IWMDRMWriter, @ptrCast(self)), wStreamNum, pszName, Type, pValue, cbLength);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const WMDRM_IMPORT_INIT_STRUCT = extern struct {
    dwVersion: u32,
    cbEncryptedSessionKeyMessage: u32,
    pbEncryptedSessionKeyMessage: ?*u8,
    cbEncryptedKeyMessage: u32,
    pbEncryptedKeyMessage: ?*u8,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IWMDRMWriter2_Value = Guid.initString("38ee7a94-40e2-4e10-aa3f-33fd3210ed5b");
pub const IID_IWMDRMWriter2 = &IID_IWMDRMWriter2_Value;
pub const IWMDRMWriter2 = extern struct {
    pub const VTable = extern struct {
        base: IWMDRMWriter.VTable,
        SetWMDRMNetEncryption: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDRMWriter2,
                fSamplesEncrypted: BOOL,
                pbKeyID: ?*u8,
                cbKeyID: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDRMWriter2,
                fSamplesEncrypted: BOOL,
                pbKeyID: ?*u8,
                cbKeyID: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWMDRMWriter.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDRMWriter2_SetWMDRMNetEncryption(self: *const T, fSamplesEncrypted: BOOL, pbKeyID: ?*u8, cbKeyID: u32) HRESULT {
                return @as(*const IWMDRMWriter2.VTable, @ptrCast(self.vtable)).SetWMDRMNetEncryption(@as(*const IWMDRMWriter2, @ptrCast(self)), fSamplesEncrypted, pbKeyID, cbKeyID);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IWMDRMWriter3_Value = Guid.initString("a7184082-a4aa-4dde-ac9c-e75dbd1117ce");
pub const IID_IWMDRMWriter3 = &IID_IWMDRMWriter3_Value;
pub const IWMDRMWriter3 = extern struct {
    pub const VTable = extern struct {
        base: IWMDRMWriter2.VTable,
        SetProtectStreamSamples: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDRMWriter3,
                pImportInitStruct: ?*WMDRM_IMPORT_INIT_STRUCT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDRMWriter3,
                pImportInitStruct: ?*WMDRM_IMPORT_INIT_STRUCT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWMDRMWriter2.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDRMWriter3_SetProtectStreamSamples(self: *const T, pImportInitStruct: ?*WMDRM_IMPORT_INIT_STRUCT) HRESULT {
                return @as(*const IWMDRMWriter3.VTable, @ptrCast(self.vtable)).SetProtectStreamSamples(@as(*const IWMDRMWriter3, @ptrCast(self)), pImportInitStruct);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMInputMediaProps_Value = Guid.initString("96406bd5-2b2b-11d3-b36b-00c04f6108ff");
pub const IID_IWMInputMediaProps = &IID_IWMInputMediaProps_Value;
pub const IWMInputMediaProps = extern struct {
    pub const VTable = extern struct {
        base: IWMMediaProps.VTable,
        GetConnectionName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMInputMediaProps,
                pwszName: [*:0]u16,
                pcchName: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMInputMediaProps,
                pwszName: [*:0]u16,
                pcchName: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetGroupName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMInputMediaProps,
                pwszName: [*:0]u16,
                pcchName: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMInputMediaProps,
                pwszName: [*:0]u16,
                pcchName: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWMMediaProps.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMInputMediaProps_GetConnectionName(self: *const T, pwszName: [*:0]u16, pcchName: ?*u16) HRESULT {
                return @as(*const IWMInputMediaProps.VTable, @ptrCast(self.vtable)).GetConnectionName(@as(*const IWMInputMediaProps, @ptrCast(self)), pwszName, pcchName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMInputMediaProps_GetGroupName(self: *const T, pwszName: [*:0]u16, pcchName: ?*u16) HRESULT {
                return @as(*const IWMInputMediaProps.VTable, @ptrCast(self.vtable)).GetGroupName(@as(*const IWMInputMediaProps, @ptrCast(self)), pwszName, pcchName);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMPropertyVault_Value = Guid.initString("72995a79-5090-42a4-9c8c-d9d0b6d34be5");
pub const IID_IWMPropertyVault = &IID_IWMPropertyVault_Value;
pub const IWMPropertyVault = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPropertyCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPropertyVault,
                pdwCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPropertyVault,
                pdwCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPropertyByName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPropertyVault,
                pszName: ?[*:0]const u16,
                pType: ?*WMT_ATTR_DATATYPE,
                pValue: [*:0]u8,
                pdwSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPropertyVault,
                pszName: ?[*:0]const u16,
                pType: ?*WMT_ATTR_DATATYPE,
                pValue: [*:0]u8,
                pdwSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPropertyVault,
                pszName: ?[*:0]const u16,
                pType: WMT_ATTR_DATATYPE,
                pValue: ?*u8,
                dwSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPropertyVault,
                pszName: ?[*:0]const u16,
                pType: WMT_ATTR_DATATYPE,
                pValue: ?*u8,
                dwSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPropertyByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPropertyVault,
                dwIndex: u32,
                pszName: [*:0]u16,
                pdwNameLen: ?*u32,
                pType: ?*WMT_ATTR_DATATYPE,
                pValue: [*:0]u8,
                pdwSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPropertyVault,
                dwIndex: u32,
                pszName: [*:0]u16,
                pdwNameLen: ?*u32,
                pType: ?*WMT_ATTR_DATATYPE,
                pValue: [*:0]u8,
                pdwSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CopyPropertiesFrom: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPropertyVault,
                pIWMPropertyVault: ?*IWMPropertyVault,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPropertyVault,
                pIWMPropertyVault: ?*IWMPropertyVault,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clear: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPropertyVault,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPropertyVault,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPropertyVault_GetPropertyCount(self: *const T, pdwCount: ?*u32) HRESULT {
                return @as(*const IWMPropertyVault.VTable, @ptrCast(self.vtable)).GetPropertyCount(@as(*const IWMPropertyVault, @ptrCast(self)), pdwCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPropertyVault_GetPropertyByName(self: *const T, pszName: ?[*:0]const u16, pType: ?*WMT_ATTR_DATATYPE, pValue: [*:0]u8, pdwSize: ?*u32) HRESULT {
                return @as(*const IWMPropertyVault.VTable, @ptrCast(self.vtable)).GetPropertyByName(@as(*const IWMPropertyVault, @ptrCast(self)), pszName, pType, pValue, pdwSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPropertyVault_SetProperty(self: *const T, pszName: ?[*:0]const u16, pType: WMT_ATTR_DATATYPE, pValue: ?*u8, dwSize: u32) HRESULT {
                return @as(*const IWMPropertyVault.VTable, @ptrCast(self.vtable)).SetProperty(@as(*const IWMPropertyVault, @ptrCast(self)), pszName, pType, pValue, dwSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPropertyVault_GetPropertyByIndex(self: *const T, dwIndex: u32, pszName: [*:0]u16, pdwNameLen: ?*u32, pType: ?*WMT_ATTR_DATATYPE, pValue: [*:0]u8, pdwSize: ?*u32) HRESULT {
                return @as(*const IWMPropertyVault.VTable, @ptrCast(self.vtable)).GetPropertyByIndex(@as(*const IWMPropertyVault, @ptrCast(self)), dwIndex, pszName, pdwNameLen, pType, pValue, pdwSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPropertyVault_CopyPropertiesFrom(self: *const T, pIWMPropertyVault: ?*IWMPropertyVault) HRESULT {
                return @as(*const IWMPropertyVault.VTable, @ptrCast(self.vtable)).CopyPropertiesFrom(@as(*const IWMPropertyVault, @ptrCast(self)), pIWMPropertyVault);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPropertyVault_Clear(self: *const T) HRESULT {
                return @as(*const IWMPropertyVault.VTable, @ptrCast(self.vtable)).Clear(@as(*const IWMPropertyVault, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMIStreamProps_Value = Guid.initString("6816dad3-2b4b-4c8e-8149-874c3483a753");
pub const IID_IWMIStreamProps = &IID_IWMIStreamProps_Value;
pub const IWMIStreamProps = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMIStreamProps,
                pszName: ?[*:0]const u16,
                pType: ?*WMT_ATTR_DATATYPE,
                pValue: [*:0]u8,
                pdwSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMIStreamProps,
                pszName: ?[*:0]const u16,
                pType: ?*WMT_ATTR_DATATYPE,
                pValue: [*:0]u8,
                pdwSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMIStreamProps_GetProperty(self: *const T, pszName: ?[*:0]const u16, pType: ?*WMT_ATTR_DATATYPE, pValue: [*:0]u8, pdwSize: ?*u32) HRESULT {
                return @as(*const IWMIStreamProps.VTable, @ptrCast(self.vtable)).GetProperty(@as(*const IWMIStreamProps, @ptrCast(self)), pszName, pType, pValue, pdwSize);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMReader_Value = Guid.initString("96406bd6-2b2b-11d3-b36b-00c04f6108ff");
pub const IID_IWMReader = &IID_IWMReader_Value;
pub const IWMReader = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Open: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReader,
                pwszURL: ?[*:0]const u16,
                pCallback: ?*IWMReaderCallback,
                pvContext: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReader,
                pwszURL: ?[*:0]const u16,
                pCallback: ?*IWMReaderCallback,
                pvContext: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Close: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReader,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReader,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReader,
                pcOutputs: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReader,
                pcOutputs: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputProps: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReader,
                dwOutputNum: u32,
                ppOutput: ?*?*IWMOutputMediaProps,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReader,
                dwOutputNum: u32,
                ppOutput: ?*?*IWMOutputMediaProps,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputProps: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReader,
                dwOutputNum: u32,
                pOutput: ?*IWMOutputMediaProps,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReader,
                dwOutputNum: u32,
                pOutput: ?*IWMOutputMediaProps,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputFormatCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReader,
                dwOutputNumber: u32,
                pcFormats: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReader,
                dwOutputNumber: u32,
                pcFormats: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputFormat: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReader,
                dwOutputNumber: u32,
                dwFormatNumber: u32,
                ppProps: ?*?*IWMOutputMediaProps,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReader,
                dwOutputNumber: u32,
                dwFormatNumber: u32,
                ppProps: ?*?*IWMOutputMediaProps,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Start: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReader,
                cnsStart: u64,
                cnsDuration: u64,
                fRate: f32,
                pvContext: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReader,
                cnsStart: u64,
                cnsDuration: u64,
                fRate: f32,
                pvContext: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Stop: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReader,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReader,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Pause: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReader,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReader,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Resume: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReader,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReader,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReader_Open(self: *const T, pwszURL: ?[*:0]const u16, pCallback: ?*IWMReaderCallback, pvContext: ?*anyopaque) HRESULT {
                return @as(*const IWMReader.VTable, @ptrCast(self.vtable)).Open(@as(*const IWMReader, @ptrCast(self)), pwszURL, pCallback, pvContext);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReader_Close(self: *const T) HRESULT {
                return @as(*const IWMReader.VTable, @ptrCast(self.vtable)).Close(@as(*const IWMReader, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReader_GetOutputCount(self: *const T, pcOutputs: ?*u32) HRESULT {
                return @as(*const IWMReader.VTable, @ptrCast(self.vtable)).GetOutputCount(@as(*const IWMReader, @ptrCast(self)), pcOutputs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReader_GetOutputProps(self: *const T, dwOutputNum: u32, ppOutput: ?*?*IWMOutputMediaProps) HRESULT {
                return @as(*const IWMReader.VTable, @ptrCast(self.vtable)).GetOutputProps(@as(*const IWMReader, @ptrCast(self)), dwOutputNum, ppOutput);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReader_SetOutputProps(self: *const T, dwOutputNum: u32, pOutput: ?*IWMOutputMediaProps) HRESULT {
                return @as(*const IWMReader.VTable, @ptrCast(self.vtable)).SetOutputProps(@as(*const IWMReader, @ptrCast(self)), dwOutputNum, pOutput);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReader_GetOutputFormatCount(self: *const T, dwOutputNumber: u32, pcFormats: ?*u32) HRESULT {
                return @as(*const IWMReader.VTable, @ptrCast(self.vtable)).GetOutputFormatCount(@as(*const IWMReader, @ptrCast(self)), dwOutputNumber, pcFormats);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReader_GetOutputFormat(self: *const T, dwOutputNumber: u32, dwFormatNumber: u32, ppProps: ?*?*IWMOutputMediaProps) HRESULT {
                return @as(*const IWMReader.VTable, @ptrCast(self.vtable)).GetOutputFormat(@as(*const IWMReader, @ptrCast(self)), dwOutputNumber, dwFormatNumber, ppProps);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReader_Start(self: *const T, cnsStart: u64, cnsDuration: u64, fRate: f32, pvContext: ?*anyopaque) HRESULT {
                return @as(*const IWMReader.VTable, @ptrCast(self.vtable)).Start(@as(*const IWMReader, @ptrCast(self)), cnsStart, cnsDuration, fRate, pvContext);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReader_Stop(self: *const T) HRESULT {
                return @as(*const IWMReader.VTable, @ptrCast(self.vtable)).Stop(@as(*const IWMReader, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReader_Pause(self: *const T) HRESULT {
                return @as(*const IWMReader.VTable, @ptrCast(self.vtable)).Pause(@as(*const IWMReader, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReader_Resume(self: *const T) HRESULT {
                return @as(*const IWMReader.VTable, @ptrCast(self.vtable)).Resume(@as(*const IWMReader, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMSyncReader_Value = Guid.initString("9397f121-7705-4dc9-b049-98b698188414");
pub const IID_IWMSyncReader = &IID_IWMSyncReader_Value;
pub const IWMSyncReader = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Open: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMSyncReader,
                pwszFilename: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMSyncReader,
                pwszFilename: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Close: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMSyncReader,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMSyncReader,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetRange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMSyncReader,
                cnsStartTime: u64,
                cnsDuration: i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMSyncReader,
                cnsStartTime: u64,
                cnsDuration: i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetRangeByFrame: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMSyncReader,
                wStreamNum: u16,
                qwFrameNumber: u64,
                cFramesToRead: i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMSyncReader,
                wStreamNum: u16,
                qwFrameNumber: u64,
                cFramesToRead: i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNextSample: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMSyncReader,
                wStreamNum: u16,
                ppSample: ?*?*INSSBuffer,
                pcnsSampleTime: ?*u64,
                pcnsDuration: ?*u64,
                pdwFlags: ?*u32,
                pdwOutputNum: ?*u32,
                pwStreamNum: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMSyncReader,
                wStreamNum: u16,
                ppSample: ?*?*INSSBuffer,
                pcnsSampleTime: ?*u64,
                pcnsDuration: ?*u64,
                pdwFlags: ?*u32,
                pdwOutputNum: ?*u32,
                pwStreamNum: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetStreamsSelected: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMSyncReader,
                cStreamCount: u16,
                pwStreamNumbers: ?*u16,
                pSelections: ?*WMT_STREAM_SELECTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMSyncReader,
                cStreamCount: u16,
                pwStreamNumbers: ?*u16,
                pSelections: ?*WMT_STREAM_SELECTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStreamSelected: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMSyncReader,
                wStreamNum: u16,
                pSelection: ?*WMT_STREAM_SELECTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMSyncReader,
                wStreamNum: u16,
                pSelection: ?*WMT_STREAM_SELECTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetReadStreamSamples: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMSyncReader,
                wStreamNum: u16,
                fCompressed: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMSyncReader,
                wStreamNum: u16,
                fCompressed: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetReadStreamSamples: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMSyncReader,
                wStreamNum: u16,
                pfCompressed: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMSyncReader,
                wStreamNum: u16,
                pfCompressed: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputSetting: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMSyncReader,
                dwOutputNum: u32,
                pszName: ?[*:0]const u16,
                pType: ?*WMT_ATTR_DATATYPE,
                pValue: [*:0]u8,
                pcbLength: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMSyncReader,
                dwOutputNum: u32,
                pszName: ?[*:0]const u16,
                pType: ?*WMT_ATTR_DATATYPE,
                pValue: [*:0]u8,
                pcbLength: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputSetting: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMSyncReader,
                dwOutputNum: u32,
                pszName: ?[*:0]const u16,
                Type: WMT_ATTR_DATATYPE,
                pValue: [*:0]const u8,
                cbLength: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMSyncReader,
                dwOutputNum: u32,
                pszName: ?[*:0]const u16,
                Type: WMT_ATTR_DATATYPE,
                pValue: [*:0]const u8,
                cbLength: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMSyncReader,
                pcOutputs: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMSyncReader,
                pcOutputs: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputProps: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMSyncReader,
                dwOutputNum: u32,
                ppOutput: ?*?*IWMOutputMediaProps,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMSyncReader,
                dwOutputNum: u32,
                ppOutput: ?*?*IWMOutputMediaProps,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputProps: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMSyncReader,
                dwOutputNum: u32,
                pOutput: ?*IWMOutputMediaProps,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMSyncReader,
                dwOutputNum: u32,
                pOutput: ?*IWMOutputMediaProps,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputFormatCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMSyncReader,
                dwOutputNum: u32,
                pcFormats: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMSyncReader,
                dwOutputNum: u32,
                pcFormats: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputFormat: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMSyncReader,
                dwOutputNum: u32,
                dwFormatNum: u32,
                ppProps: ?*?*IWMOutputMediaProps,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMSyncReader,
                dwOutputNum: u32,
                dwFormatNum: u32,
                ppProps: ?*?*IWMOutputMediaProps,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputNumberForStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMSyncReader,
                wStreamNum: u16,
                pdwOutputNum: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMSyncReader,
                wStreamNum: u16,
                pdwOutputNum: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStreamNumberForOutput: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMSyncReader,
                dwOutputNum: u32,
                pwStreamNum: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMSyncReader,
                dwOutputNum: u32,
                pwStreamNum: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMaxOutputSampleSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMSyncReader,
                dwOutput: u32,
                pcbMax: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMSyncReader,
                dwOutput: u32,
                pcbMax: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMaxStreamSampleSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMSyncReader,
                wStream: u16,
                pcbMax: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMSyncReader,
                wStream: u16,
                pcbMax: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMSyncReader,
                pStream: ?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMSyncReader,
                pStream: ?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMSyncReader_Open(self: *const T, pwszFilename: ?[*:0]const u16) HRESULT {
                return @as(*const IWMSyncReader.VTable, @ptrCast(self.vtable)).Open(@as(*const IWMSyncReader, @ptrCast(self)), pwszFilename);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMSyncReader_Close(self: *const T) HRESULT {
                return @as(*const IWMSyncReader.VTable, @ptrCast(self.vtable)).Close(@as(*const IWMSyncReader, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMSyncReader_SetRange(self: *const T, cnsStartTime: u64, cnsDuration: i64) HRESULT {
                return @as(*const IWMSyncReader.VTable, @ptrCast(self.vtable)).SetRange(@as(*const IWMSyncReader, @ptrCast(self)), cnsStartTime, cnsDuration);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMSyncReader_SetRangeByFrame(self: *const T, wStreamNum: u16, qwFrameNumber: u64, cFramesToRead: i64) HRESULT {
                return @as(*const IWMSyncReader.VTable, @ptrCast(self.vtable)).SetRangeByFrame(@as(*const IWMSyncReader, @ptrCast(self)), wStreamNum, qwFrameNumber, cFramesToRead);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMSyncReader_GetNextSample(self: *const T, wStreamNum: u16, ppSample: ?*?*INSSBuffer, pcnsSampleTime: ?*u64, pcnsDuration: ?*u64, pdwFlags: ?*u32, pdwOutputNum: ?*u32, pwStreamNum: ?*u16) HRESULT {
                return @as(*const IWMSyncReader.VTable, @ptrCast(self.vtable)).GetNextSample(@as(*const IWMSyncReader, @ptrCast(self)), wStreamNum, ppSample, pcnsSampleTime, pcnsDuration, pdwFlags, pdwOutputNum, pwStreamNum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMSyncReader_SetStreamsSelected(self: *const T, cStreamCount: u16, pwStreamNumbers: ?*u16, pSelections: ?*WMT_STREAM_SELECTION) HRESULT {
                return @as(*const IWMSyncReader.VTable, @ptrCast(self.vtable)).SetStreamsSelected(@as(*const IWMSyncReader, @ptrCast(self)), cStreamCount, pwStreamNumbers, pSelections);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMSyncReader_GetStreamSelected(self: *const T, wStreamNum: u16, pSelection: ?*WMT_STREAM_SELECTION) HRESULT {
                return @as(*const IWMSyncReader.VTable, @ptrCast(self.vtable)).GetStreamSelected(@as(*const IWMSyncReader, @ptrCast(self)), wStreamNum, pSelection);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMSyncReader_SetReadStreamSamples(self: *const T, wStreamNum: u16, fCompressed: BOOL) HRESULT {
                return @as(*const IWMSyncReader.VTable, @ptrCast(self.vtable)).SetReadStreamSamples(@as(*const IWMSyncReader, @ptrCast(self)), wStreamNum, fCompressed);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMSyncReader_GetReadStreamSamples(self: *const T, wStreamNum: u16, pfCompressed: ?*BOOL) HRESULT {
                return @as(*const IWMSyncReader.VTable, @ptrCast(self.vtable)).GetReadStreamSamples(@as(*const IWMSyncReader, @ptrCast(self)), wStreamNum, pfCompressed);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMSyncReader_GetOutputSetting(self: *const T, dwOutputNum: u32, pszName: ?[*:0]const u16, pType: ?*WMT_ATTR_DATATYPE, pValue: [*:0]u8, pcbLength: ?*u16) HRESULT {
                return @as(*const IWMSyncReader.VTable, @ptrCast(self.vtable)).GetOutputSetting(@as(*const IWMSyncReader, @ptrCast(self)), dwOutputNum, pszName, pType, pValue, pcbLength);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMSyncReader_SetOutputSetting(self: *const T, dwOutputNum: u32, pszName: ?[*:0]const u16, Type: WMT_ATTR_DATATYPE, pValue: [*:0]const u8, cbLength: u16) HRESULT {
                return @as(*const IWMSyncReader.VTable, @ptrCast(self.vtable)).SetOutputSetting(@as(*const IWMSyncReader, @ptrCast(self)), dwOutputNum, pszName, Type, pValue, cbLength);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMSyncReader_GetOutputCount(self: *const T, pcOutputs: ?*u32) HRESULT {
                return @as(*const IWMSyncReader.VTable, @ptrCast(self.vtable)).GetOutputCount(@as(*const IWMSyncReader, @ptrCast(self)), pcOutputs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMSyncReader_GetOutputProps(self: *const T, dwOutputNum: u32, ppOutput: ?*?*IWMOutputMediaProps) HRESULT {
                return @as(*const IWMSyncReader.VTable, @ptrCast(self.vtable)).GetOutputProps(@as(*const IWMSyncReader, @ptrCast(self)), dwOutputNum, ppOutput);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMSyncReader_SetOutputProps(self: *const T, dwOutputNum: u32, pOutput: ?*IWMOutputMediaProps) HRESULT {
                return @as(*const IWMSyncReader.VTable, @ptrCast(self.vtable)).SetOutputProps(@as(*const IWMSyncReader, @ptrCast(self)), dwOutputNum, pOutput);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMSyncReader_GetOutputFormatCount(self: *const T, dwOutputNum: u32, pcFormats: ?*u32) HRESULT {
                return @as(*const IWMSyncReader.VTable, @ptrCast(self.vtable)).GetOutputFormatCount(@as(*const IWMSyncReader, @ptrCast(self)), dwOutputNum, pcFormats);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMSyncReader_GetOutputFormat(self: *const T, dwOutputNum: u32, dwFormatNum: u32, ppProps: ?*?*IWMOutputMediaProps) HRESULT {
                return @as(*const IWMSyncReader.VTable, @ptrCast(self.vtable)).GetOutputFormat(@as(*const IWMSyncReader, @ptrCast(self)), dwOutputNum, dwFormatNum, ppProps);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMSyncReader_GetOutputNumberForStream(self: *const T, wStreamNum: u16, pdwOutputNum: ?*u32) HRESULT {
                return @as(*const IWMSyncReader.VTable, @ptrCast(self.vtable)).GetOutputNumberForStream(@as(*const IWMSyncReader, @ptrCast(self)), wStreamNum, pdwOutputNum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMSyncReader_GetStreamNumberForOutput(self: *const T, dwOutputNum: u32, pwStreamNum: ?*u16) HRESULT {
                return @as(*const IWMSyncReader.VTable, @ptrCast(self.vtable)).GetStreamNumberForOutput(@as(*const IWMSyncReader, @ptrCast(self)), dwOutputNum, pwStreamNum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMSyncReader_GetMaxOutputSampleSize(self: *const T, dwOutput: u32, pcbMax: ?*u32) HRESULT {
                return @as(*const IWMSyncReader.VTable, @ptrCast(self.vtable)).GetMaxOutputSampleSize(@as(*const IWMSyncReader, @ptrCast(self)), dwOutput, pcbMax);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMSyncReader_GetMaxStreamSampleSize(self: *const T, wStream: u16, pcbMax: ?*u32) HRESULT {
                return @as(*const IWMSyncReader.VTable, @ptrCast(self.vtable)).GetMaxStreamSampleSize(@as(*const IWMSyncReader, @ptrCast(self)), wStream, pcbMax);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMSyncReader_OpenStream(self: *const T, pStream: ?*IStream) HRESULT {
                return @as(*const IWMSyncReader.VTable, @ptrCast(self.vtable)).OpenStream(@as(*const IWMSyncReader, @ptrCast(self)), pStream);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMSyncReader2_Value = Guid.initString("faed3d21-1b6b-4af7-8cb6-3e189bbc187b");
pub const IID_IWMSyncReader2 = &IID_IWMSyncReader2_Value;
pub const IWMSyncReader2 = extern struct {
    pub const VTable = extern struct {
        base: IWMSyncReader.VTable,
        SetRangeByTimecode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMSyncReader2,
                wStreamNum: u16,
                pStart: ?*WMT_TIMECODE_EXTENSION_DATA,
                pEnd: ?*WMT_TIMECODE_EXTENSION_DATA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMSyncReader2,
                wStreamNum: u16,
                pStart: ?*WMT_TIMECODE_EXTENSION_DATA,
                pEnd: ?*WMT_TIMECODE_EXTENSION_DATA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetRangeByFrameEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMSyncReader2,
                wStreamNum: u16,
                qwFrameNumber: u64,
                cFramesToRead: i64,
                pcnsStartTime: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMSyncReader2,
                wStreamNum: u16,
                qwFrameNumber: u64,
                cFramesToRead: i64,
                pcnsStartTime: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetAllocateForOutput: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMSyncReader2,
                dwOutputNum: u32,
                pAllocator: ?*IWMReaderAllocatorEx,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMSyncReader2,
                dwOutputNum: u32,
                pAllocator: ?*IWMReaderAllocatorEx,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAllocateForOutput: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMSyncReader2,
                dwOutputNum: u32,
                ppAllocator: ?*?*IWMReaderAllocatorEx,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMSyncReader2,
                dwOutputNum: u32,
                ppAllocator: ?*?*IWMReaderAllocatorEx,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetAllocateForStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMSyncReader2,
                wStreamNum: u16,
                pAllocator: ?*IWMReaderAllocatorEx,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMSyncReader2,
                wStreamNum: u16,
                pAllocator: ?*IWMReaderAllocatorEx,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAllocateForStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMSyncReader2,
                dwSreamNum: u16,
                ppAllocator: ?*?*IWMReaderAllocatorEx,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMSyncReader2,
                dwSreamNum: u16,
                ppAllocator: ?*?*IWMReaderAllocatorEx,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWMSyncReader.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMSyncReader2_SetRangeByTimecode(self: *const T, wStreamNum: u16, pStart: ?*WMT_TIMECODE_EXTENSION_DATA, pEnd: ?*WMT_TIMECODE_EXTENSION_DATA) HRESULT {
                return @as(*const IWMSyncReader2.VTable, @ptrCast(self.vtable)).SetRangeByTimecode(@as(*const IWMSyncReader2, @ptrCast(self)), wStreamNum, pStart, pEnd);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMSyncReader2_SetRangeByFrameEx(self: *const T, wStreamNum: u16, qwFrameNumber: u64, cFramesToRead: i64, pcnsStartTime: ?*u64) HRESULT {
                return @as(*const IWMSyncReader2.VTable, @ptrCast(self.vtable)).SetRangeByFrameEx(@as(*const IWMSyncReader2, @ptrCast(self)), wStreamNum, qwFrameNumber, cFramesToRead, pcnsStartTime);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMSyncReader2_SetAllocateForOutput(self: *const T, dwOutputNum: u32, pAllocator: ?*IWMReaderAllocatorEx) HRESULT {
                return @as(*const IWMSyncReader2.VTable, @ptrCast(self.vtable)).SetAllocateForOutput(@as(*const IWMSyncReader2, @ptrCast(self)), dwOutputNum, pAllocator);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMSyncReader2_GetAllocateForOutput(self: *const T, dwOutputNum: u32, ppAllocator: ?*?*IWMReaderAllocatorEx) HRESULT {
                return @as(*const IWMSyncReader2.VTable, @ptrCast(self.vtable)).GetAllocateForOutput(@as(*const IWMSyncReader2, @ptrCast(self)), dwOutputNum, ppAllocator);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMSyncReader2_SetAllocateForStream(self: *const T, wStreamNum: u16, pAllocator: ?*IWMReaderAllocatorEx) HRESULT {
                return @as(*const IWMSyncReader2.VTable, @ptrCast(self.vtable)).SetAllocateForStream(@as(*const IWMSyncReader2, @ptrCast(self)), wStreamNum, pAllocator);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMSyncReader2_GetAllocateForStream(self: *const T, dwSreamNum: u16, ppAllocator: ?*?*IWMReaderAllocatorEx) HRESULT {
                return @as(*const IWMSyncReader2.VTable, @ptrCast(self.vtable)).GetAllocateForStream(@as(*const IWMSyncReader2, @ptrCast(self)), dwSreamNum, ppAllocator);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMOutputMediaProps_Value = Guid.initString("96406bd7-2b2b-11d3-b36b-00c04f6108ff");
pub const IID_IWMOutputMediaProps = &IID_IWMOutputMediaProps_Value;
pub const IWMOutputMediaProps = extern struct {
    pub const VTable = extern struct {
        base: IWMMediaProps.VTable,
        GetStreamGroupName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMOutputMediaProps,
                pwszName: [*:0]u16,
                pcchName: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMOutputMediaProps,
                pwszName: [*:0]u16,
                pcchName: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetConnectionName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMOutputMediaProps,
                pwszName: [*:0]u16,
                pcchName: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMOutputMediaProps,
                pwszName: [*:0]u16,
                pcchName: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWMMediaProps.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMOutputMediaProps_GetStreamGroupName(self: *const T, pwszName: [*:0]u16, pcchName: ?*u16) HRESULT {
                return @as(*const IWMOutputMediaProps.VTable, @ptrCast(self.vtable)).GetStreamGroupName(@as(*const IWMOutputMediaProps, @ptrCast(self)), pwszName, pcchName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMOutputMediaProps_GetConnectionName(self: *const T, pwszName: [*:0]u16, pcchName: ?*u16) HRESULT {
                return @as(*const IWMOutputMediaProps.VTable, @ptrCast(self.vtable)).GetConnectionName(@as(*const IWMOutputMediaProps, @ptrCast(self)), pwszName, pcchName);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMStatusCallback_Value = Guid.initString("6d7cdc70-9888-11d3-8edc-00c04f6109cf");
pub const IID_IWMStatusCallback = &IID_IWMStatusCallback_Value;
pub const IWMStatusCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMStatusCallback,
                Status: WMT_STATUS,
                hr: HRESULT,
                dwType: WMT_ATTR_DATATYPE,
                pValue: ?*u8,
                pvContext: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMStatusCallback,
                Status: WMT_STATUS,
                hr: HRESULT,
                dwType: WMT_ATTR_DATATYPE,
                pValue: ?*u8,
                pvContext: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMStatusCallback_OnStatus(self: *const T, Status: WMT_STATUS, hr: HRESULT, dwType: WMT_ATTR_DATATYPE, pValue: ?*u8, pvContext: ?*anyopaque) HRESULT {
                return @as(*const IWMStatusCallback.VTable, @ptrCast(self.vtable)).OnStatus(@as(*const IWMStatusCallback, @ptrCast(self)), Status, hr, dwType, pValue, pvContext);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMReaderCallback_Value = Guid.initString("96406bd8-2b2b-11d3-b36b-00c04f6108ff");
pub const IID_IWMReaderCallback = &IID_IWMReaderCallback_Value;
pub const IWMReaderCallback = extern struct {
    pub const VTable = extern struct {
        base: IWMStatusCallback.VTable,
        OnSample: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderCallback,
                dwOutputNum: u32,
                cnsSampleTime: u64,
                cnsSampleDuration: u64,
                dwFlags: u32,
                pSample: ?*INSSBuffer,
                pvContext: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderCallback,
                dwOutputNum: u32,
                cnsSampleTime: u64,
                cnsSampleDuration: u64,
                dwFlags: u32,
                pSample: ?*INSSBuffer,
                pvContext: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWMStatusCallback.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderCallback_OnSample(self: *const T, dwOutputNum: u32, cnsSampleTime: u64, cnsSampleDuration: u64, dwFlags: u32, pSample: ?*INSSBuffer, pvContext: ?*anyopaque) HRESULT {
                return @as(*const IWMReaderCallback.VTable, @ptrCast(self.vtable)).OnSample(@as(*const IWMReaderCallback, @ptrCast(self)), dwOutputNum, cnsSampleTime, cnsSampleDuration, dwFlags, pSample, pvContext);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMCredentialCallback_Value = Guid.initString("342e0eb7-e651-450c-975b-2ace2c90c48e");
pub const IID_IWMCredentialCallback = &IID_IWMCredentialCallback_Value;
pub const IWMCredentialCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AcquireCredentials: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMCredentialCallback,
                pwszRealm: ?PWSTR,
                pwszSite: ?PWSTR,
                pwszUser: [*:0]u16,
                cchUser: u32,
                pwszPassword: [*:0]u16,
                cchPassword: u32,
                hrStatus: HRESULT,
                pdwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMCredentialCallback,
                pwszRealm: ?PWSTR,
                pwszSite: ?PWSTR,
                pwszUser: [*:0]u16,
                cchUser: u32,
                pwszPassword: [*:0]u16,
                cchPassword: u32,
                hrStatus: HRESULT,
                pdwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMCredentialCallback_AcquireCredentials(self: *const T, pwszRealm: ?PWSTR, pwszSite: ?PWSTR, pwszUser: [*:0]u16, cchUser: u32, pwszPassword: [*:0]u16, cchPassword: u32, hrStatus: HRESULT, pdwFlags: ?*u32) HRESULT {
                return @as(*const IWMCredentialCallback.VTable, @ptrCast(self.vtable)).AcquireCredentials(@as(*const IWMCredentialCallback, @ptrCast(self)), pwszRealm, pwszSite, pwszUser, cchUser, pwszPassword, cchPassword, hrStatus, pdwFlags);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMMetadataEditor_Value = Guid.initString("96406bd9-2b2b-11d3-b36b-00c04f6108ff");
pub const IID_IWMMetadataEditor = &IID_IWMMetadataEditor_Value;
pub const IWMMetadataEditor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Open: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMMetadataEditor,
                pwszFilename: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMMetadataEditor,
                pwszFilename: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Close: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMMetadataEditor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMMetadataEditor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Flush: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMMetadataEditor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMMetadataEditor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMMetadataEditor_Open(self: *const T, pwszFilename: ?[*:0]const u16) HRESULT {
                return @as(*const IWMMetadataEditor.VTable, @ptrCast(self.vtable)).Open(@as(*const IWMMetadataEditor, @ptrCast(self)), pwszFilename);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMMetadataEditor_Close(self: *const T) HRESULT {
                return @as(*const IWMMetadataEditor.VTable, @ptrCast(self.vtable)).Close(@as(*const IWMMetadataEditor, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMMetadataEditor_Flush(self: *const T) HRESULT {
                return @as(*const IWMMetadataEditor.VTable, @ptrCast(self.vtable)).Flush(@as(*const IWMMetadataEditor, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMMetadataEditor2_Value = Guid.initString("203cffe3-2e18-4fdf-b59d-6e71530534cf");
pub const IID_IWMMetadataEditor2 = &IID_IWMMetadataEditor2_Value;
pub const IWMMetadataEditor2 = extern struct {
    pub const VTable = extern struct {
        base: IWMMetadataEditor.VTable,
        OpenEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMMetadataEditor2,
                pwszFilename: ?[*:0]const u16,
                dwDesiredAccess: u32,
                dwShareMode: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMMetadataEditor2,
                pwszFilename: ?[*:0]const u16,
                dwDesiredAccess: u32,
                dwShareMode: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWMMetadataEditor.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMMetadataEditor2_OpenEx(self: *const T, pwszFilename: ?[*:0]const u16, dwDesiredAccess: u32, dwShareMode: u32) HRESULT {
                return @as(*const IWMMetadataEditor2.VTable, @ptrCast(self.vtable)).OpenEx(@as(*const IWMMetadataEditor2, @ptrCast(self)), pwszFilename, dwDesiredAccess, dwShareMode);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IWMDRMEditor_Value = Guid.initString("ff130ebc-a6c3-42a6-b401-c3382c3e08b3");
pub const IID_IWMDRMEditor = &IID_IWMDRMEditor_Value;
pub const IWMDRMEditor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDRMProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDRMEditor,
                pwstrName: ?[*:0]const u16,
                pdwType: ?*WMT_ATTR_DATATYPE,
                pValue: [*:0]u8,
                pcbLength: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDRMEditor,
                pwstrName: ?[*:0]const u16,
                pdwType: ?*WMT_ATTR_DATATYPE,
                pValue: [*:0]u8,
                pcbLength: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDRMEditor_GetDRMProperty(self: *const T, pwstrName: ?[*:0]const u16, pdwType: ?*WMT_ATTR_DATATYPE, pValue: [*:0]u8, pcbLength: ?*u16) HRESULT {
                return @as(*const IWMDRMEditor.VTable, @ptrCast(self.vtable)).GetDRMProperty(@as(*const IWMDRMEditor, @ptrCast(self)), pwstrName, pdwType, pValue, pcbLength);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMHeaderInfo_Value = Guid.initString("96406bda-2b2b-11d3-b36b-00c04f6108ff");
pub const IID_IWMHeaderInfo = &IID_IWMHeaderInfo_Value;
pub const IWMHeaderInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetAttributeCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMHeaderInfo,
                wStreamNum: u16,
                pcAttributes: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMHeaderInfo,
                wStreamNum: u16,
                pcAttributes: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAttributeByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMHeaderInfo,
                wIndex: u16,
                pwStreamNum: ?*u16,
                pwszName: [*:0]u16,
                pcchNameLen: ?*u16,
                pType: ?*WMT_ATTR_DATATYPE,
                pValue: [*:0]u8,
                pcbLength: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMHeaderInfo,
                wIndex: u16,
                pwStreamNum: ?*u16,
                pwszName: [*:0]u16,
                pcchNameLen: ?*u16,
                pType: ?*WMT_ATTR_DATATYPE,
                pValue: [*:0]u8,
                pcbLength: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAttributeByName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMHeaderInfo,
                pwStreamNum: ?*u16,
                pszName: ?[*:0]const u16,
                pType: ?*WMT_ATTR_DATATYPE,
                pValue: [*:0]u8,
                pcbLength: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMHeaderInfo,
                pwStreamNum: ?*u16,
                pszName: ?[*:0]const u16,
                pType: ?*WMT_ATTR_DATATYPE,
                pValue: [*:0]u8,
                pcbLength: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetAttribute: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMHeaderInfo,
                wStreamNum: u16,
                pszName: ?[*:0]const u16,
                Type: WMT_ATTR_DATATYPE,
                pValue: [*:0]const u8,
                cbLength: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMHeaderInfo,
                wStreamNum: u16,
                pszName: ?[*:0]const u16,
                Type: WMT_ATTR_DATATYPE,
                pValue: [*:0]const u8,
                cbLength: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMarkerCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMHeaderInfo,
                pcMarkers: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMHeaderInfo,
                pcMarkers: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMarker: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMHeaderInfo,
                wIndex: u16,
                pwszMarkerName: [*:0]u16,
                pcchMarkerNameLen: ?*u16,
                pcnsMarkerTime: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMHeaderInfo,
                wIndex: u16,
                pwszMarkerName: [*:0]u16,
                pcchMarkerNameLen: ?*u16,
                pcnsMarkerTime: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddMarker: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMHeaderInfo,
                pwszMarkerName: ?PWSTR,
                cnsMarkerTime: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMHeaderInfo,
                pwszMarkerName: ?PWSTR,
                cnsMarkerTime: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveMarker: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMHeaderInfo,
                wIndex: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMHeaderInfo,
                wIndex: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetScriptCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMHeaderInfo,
                pcScripts: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMHeaderInfo,
                pcScripts: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetScript: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMHeaderInfo,
                wIndex: u16,
                pwszType: [*:0]u16,
                pcchTypeLen: ?*u16,
                pwszCommand: [*:0]u16,
                pcchCommandLen: ?*u16,
                pcnsScriptTime: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMHeaderInfo,
                wIndex: u16,
                pwszType: [*:0]u16,
                pcchTypeLen: ?*u16,
                pwszCommand: [*:0]u16,
                pcchCommandLen: ?*u16,
                pcnsScriptTime: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddScript: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMHeaderInfo,
                pwszType: ?PWSTR,
                pwszCommand: ?PWSTR,
                cnsScriptTime: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMHeaderInfo,
                pwszType: ?PWSTR,
                pwszCommand: ?PWSTR,
                cnsScriptTime: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveScript: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMHeaderInfo,
                wIndex: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMHeaderInfo,
                wIndex: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMHeaderInfo_GetAttributeCount(self: *const T, wStreamNum: u16, pcAttributes: ?*u16) HRESULT {
                return @as(*const IWMHeaderInfo.VTable, @ptrCast(self.vtable)).GetAttributeCount(@as(*const IWMHeaderInfo, @ptrCast(self)), wStreamNum, pcAttributes);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMHeaderInfo_GetAttributeByIndex(self: *const T, wIndex: u16, pwStreamNum: ?*u16, pwszName: [*:0]u16, pcchNameLen: ?*u16, pType: ?*WMT_ATTR_DATATYPE, pValue: [*:0]u8, pcbLength: ?*u16) HRESULT {
                return @as(*const IWMHeaderInfo.VTable, @ptrCast(self.vtable)).GetAttributeByIndex(@as(*const IWMHeaderInfo, @ptrCast(self)), wIndex, pwStreamNum, pwszName, pcchNameLen, pType, pValue, pcbLength);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMHeaderInfo_GetAttributeByName(self: *const T, pwStreamNum: ?*u16, pszName: ?[*:0]const u16, pType: ?*WMT_ATTR_DATATYPE, pValue: [*:0]u8, pcbLength: ?*u16) HRESULT {
                return @as(*const IWMHeaderInfo.VTable, @ptrCast(self.vtable)).GetAttributeByName(@as(*const IWMHeaderInfo, @ptrCast(self)), pwStreamNum, pszName, pType, pValue, pcbLength);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMHeaderInfo_SetAttribute(self: *const T, wStreamNum: u16, pszName: ?[*:0]const u16, Type: WMT_ATTR_DATATYPE, pValue: [*:0]const u8, cbLength: u16) HRESULT {
                return @as(*const IWMHeaderInfo.VTable, @ptrCast(self.vtable)).SetAttribute(@as(*const IWMHeaderInfo, @ptrCast(self)), wStreamNum, pszName, Type, pValue, cbLength);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMHeaderInfo_GetMarkerCount(self: *const T, pcMarkers: ?*u16) HRESULT {
                return @as(*const IWMHeaderInfo.VTable, @ptrCast(self.vtable)).GetMarkerCount(@as(*const IWMHeaderInfo, @ptrCast(self)), pcMarkers);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMHeaderInfo_GetMarker(self: *const T, wIndex: u16, pwszMarkerName: [*:0]u16, pcchMarkerNameLen: ?*u16, pcnsMarkerTime: ?*u64) HRESULT {
                return @as(*const IWMHeaderInfo.VTable, @ptrCast(self.vtable)).GetMarker(@as(*const IWMHeaderInfo, @ptrCast(self)), wIndex, pwszMarkerName, pcchMarkerNameLen, pcnsMarkerTime);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMHeaderInfo_AddMarker(self: *const T, pwszMarkerName: ?PWSTR, cnsMarkerTime: u64) HRESULT {
                return @as(*const IWMHeaderInfo.VTable, @ptrCast(self.vtable)).AddMarker(@as(*const IWMHeaderInfo, @ptrCast(self)), pwszMarkerName, cnsMarkerTime);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMHeaderInfo_RemoveMarker(self: *const T, wIndex: u16) HRESULT {
                return @as(*const IWMHeaderInfo.VTable, @ptrCast(self.vtable)).RemoveMarker(@as(*const IWMHeaderInfo, @ptrCast(self)), wIndex);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMHeaderInfo_GetScriptCount(self: *const T, pcScripts: ?*u16) HRESULT {
                return @as(*const IWMHeaderInfo.VTable, @ptrCast(self.vtable)).GetScriptCount(@as(*const IWMHeaderInfo, @ptrCast(self)), pcScripts);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMHeaderInfo_GetScript(self: *const T, wIndex: u16, pwszType: [*:0]u16, pcchTypeLen: ?*u16, pwszCommand: [*:0]u16, pcchCommandLen: ?*u16, pcnsScriptTime: ?*u64) HRESULT {
                return @as(*const IWMHeaderInfo.VTable, @ptrCast(self.vtable)).GetScript(@as(*const IWMHeaderInfo, @ptrCast(self)), wIndex, pwszType, pcchTypeLen, pwszCommand, pcchCommandLen, pcnsScriptTime);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMHeaderInfo_AddScript(self: *const T, pwszType: ?PWSTR, pwszCommand: ?PWSTR, cnsScriptTime: u64) HRESULT {
                return @as(*const IWMHeaderInfo.VTable, @ptrCast(self.vtable)).AddScript(@as(*const IWMHeaderInfo, @ptrCast(self)), pwszType, pwszCommand, cnsScriptTime);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMHeaderInfo_RemoveScript(self: *const T, wIndex: u16) HRESULT {
                return @as(*const IWMHeaderInfo.VTable, @ptrCast(self.vtable)).RemoveScript(@as(*const IWMHeaderInfo, @ptrCast(self)), wIndex);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMHeaderInfo2_Value = Guid.initString("15cf9781-454e-482e-b393-85fae487a810");
pub const IID_IWMHeaderInfo2 = &IID_IWMHeaderInfo2_Value;
pub const IWMHeaderInfo2 = extern struct {
    pub const VTable = extern struct {
        base: IWMHeaderInfo.VTable,
        GetCodecInfoCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMHeaderInfo2,
                pcCodecInfos: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMHeaderInfo2,
                pcCodecInfos: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCodecInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMHeaderInfo2,
                wIndex: u32,
                pcchName: ?*u16,
                pwszName: [*:0]u16,
                pcchDescription: ?*u16,
                pwszDescription: [*:0]u16,
                pCodecType: ?*WMT_CODEC_INFO_TYPE,
                pcbCodecInfo: ?*u16,
                pbCodecInfo: [*:0]u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMHeaderInfo2,
                wIndex: u32,
                pcchName: ?*u16,
                pwszName: [*:0]u16,
                pcchDescription: ?*u16,
                pwszDescription: [*:0]u16,
                pCodecType: ?*WMT_CODEC_INFO_TYPE,
                pcbCodecInfo: ?*u16,
                pbCodecInfo: [*:0]u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWMHeaderInfo.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMHeaderInfo2_GetCodecInfoCount(self: *const T, pcCodecInfos: ?*u32) HRESULT {
                return @as(*const IWMHeaderInfo2.VTable, @ptrCast(self.vtable)).GetCodecInfoCount(@as(*const IWMHeaderInfo2, @ptrCast(self)), pcCodecInfos);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMHeaderInfo2_GetCodecInfo(self: *const T, wIndex: u32, pcchName: ?*u16, pwszName: [*:0]u16, pcchDescription: ?*u16, pwszDescription: [*:0]u16, pCodecType: ?*WMT_CODEC_INFO_TYPE, pcbCodecInfo: ?*u16, pbCodecInfo: [*:0]u8) HRESULT {
                return @as(*const IWMHeaderInfo2.VTable, @ptrCast(self.vtable)).GetCodecInfo(@as(*const IWMHeaderInfo2, @ptrCast(self)), wIndex, pcchName, pwszName, pcchDescription, pwszDescription, pCodecType, pcbCodecInfo, pbCodecInfo);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMHeaderInfo3_Value = Guid.initString("15cc68e3-27cc-4ecd-b222-3f5d02d80bd5");
pub const IID_IWMHeaderInfo3 = &IID_IWMHeaderInfo3_Value;
pub const IWMHeaderInfo3 = extern struct {
    pub const VTable = extern struct {
        base: IWMHeaderInfo2.VTable,
        GetAttributeCountEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMHeaderInfo3,
                wStreamNum: u16,
                pcAttributes: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMHeaderInfo3,
                wStreamNum: u16,
                pcAttributes: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAttributeIndices: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMHeaderInfo3,
                wStreamNum: u16,
                pwszName: ?[*:0]const u16,
                pwLangIndex: ?*u16,
                pwIndices: [*:0]u16,
                pwCount: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMHeaderInfo3,
                wStreamNum: u16,
                pwszName: ?[*:0]const u16,
                pwLangIndex: ?*u16,
                pwIndices: [*:0]u16,
                pwCount: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAttributeByIndexEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMHeaderInfo3,
                wStreamNum: u16,
                wIndex: u16,
                pwszName: [*:0]u16,
                pwNameLen: ?*u16,
                pType: ?*WMT_ATTR_DATATYPE,
                pwLangIndex: ?*u16,
                pValue: [*:0]u8,
                pdwDataLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMHeaderInfo3,
                wStreamNum: u16,
                wIndex: u16,
                pwszName: [*:0]u16,
                pwNameLen: ?*u16,
                pType: ?*WMT_ATTR_DATATYPE,
                pwLangIndex: ?*u16,
                pValue: [*:0]u8,
                pdwDataLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ModifyAttribute: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMHeaderInfo3,
                wStreamNum: u16,
                wIndex: u16,
                Type: WMT_ATTR_DATATYPE,
                wLangIndex: u16,
                pValue: [*:0]const u8,
                dwLength: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMHeaderInfo3,
                wStreamNum: u16,
                wIndex: u16,
                Type: WMT_ATTR_DATATYPE,
                wLangIndex: u16,
                pValue: [*:0]const u8,
                dwLength: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddAttribute: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMHeaderInfo3,
                wStreamNum: u16,
                pszName: ?[*:0]const u16,
                pwIndex: ?*u16,
                Type: WMT_ATTR_DATATYPE,
                wLangIndex: u16,
                pValue: [*:0]const u8,
                dwLength: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMHeaderInfo3,
                wStreamNum: u16,
                pszName: ?[*:0]const u16,
                pwIndex: ?*u16,
                Type: WMT_ATTR_DATATYPE,
                wLangIndex: u16,
                pValue: [*:0]const u8,
                dwLength: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeleteAttribute: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMHeaderInfo3,
                wStreamNum: u16,
                wIndex: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMHeaderInfo3,
                wStreamNum: u16,
                wIndex: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddCodecInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMHeaderInfo3,
                pwszName: ?PWSTR,
                pwszDescription: ?PWSTR,
                codecType: WMT_CODEC_INFO_TYPE,
                cbCodecInfo: u16,
                pbCodecInfo: [*:0]u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMHeaderInfo3,
                pwszName: ?PWSTR,
                pwszDescription: ?PWSTR,
                codecType: WMT_CODEC_INFO_TYPE,
                cbCodecInfo: u16,
                pbCodecInfo: [*:0]u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWMHeaderInfo2.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMHeaderInfo3_GetAttributeCountEx(self: *const T, wStreamNum: u16, pcAttributes: ?*u16) HRESULT {
                return @as(*const IWMHeaderInfo3.VTable, @ptrCast(self.vtable)).GetAttributeCountEx(@as(*const IWMHeaderInfo3, @ptrCast(self)), wStreamNum, pcAttributes);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMHeaderInfo3_GetAttributeIndices(self: *const T, wStreamNum: u16, pwszName: ?[*:0]const u16, pwLangIndex: ?*u16, pwIndices: [*:0]u16, pwCount: ?*u16) HRESULT {
                return @as(*const IWMHeaderInfo3.VTable, @ptrCast(self.vtable)).GetAttributeIndices(@as(*const IWMHeaderInfo3, @ptrCast(self)), wStreamNum, pwszName, pwLangIndex, pwIndices, pwCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMHeaderInfo3_GetAttributeByIndexEx(self: *const T, wStreamNum: u16, wIndex: u16, pwszName: [*:0]u16, pwNameLen: ?*u16, pType: ?*WMT_ATTR_DATATYPE, pwLangIndex: ?*u16, pValue: [*:0]u8, pdwDataLength: ?*u32) HRESULT {
                return @as(*const IWMHeaderInfo3.VTable, @ptrCast(self.vtable)).GetAttributeByIndexEx(@as(*const IWMHeaderInfo3, @ptrCast(self)), wStreamNum, wIndex, pwszName, pwNameLen, pType, pwLangIndex, pValue, pdwDataLength);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMHeaderInfo3_ModifyAttribute(self: *const T, wStreamNum: u16, wIndex: u16, Type: WMT_ATTR_DATATYPE, wLangIndex: u16, pValue: [*:0]const u8, dwLength: u32) HRESULT {
                return @as(*const IWMHeaderInfo3.VTable, @ptrCast(self.vtable)).ModifyAttribute(@as(*const IWMHeaderInfo3, @ptrCast(self)), wStreamNum, wIndex, Type, wLangIndex, pValue, dwLength);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMHeaderInfo3_AddAttribute(self: *const T, wStreamNum: u16, pszName: ?[*:0]const u16, pwIndex: ?*u16, Type: WMT_ATTR_DATATYPE, wLangIndex: u16, pValue: [*:0]const u8, dwLength: u32) HRESULT {
                return @as(*const IWMHeaderInfo3.VTable, @ptrCast(self.vtable)).AddAttribute(@as(*const IWMHeaderInfo3, @ptrCast(self)), wStreamNum, pszName, pwIndex, Type, wLangIndex, pValue, dwLength);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMHeaderInfo3_DeleteAttribute(self: *const T, wStreamNum: u16, wIndex: u16) HRESULT {
                return @as(*const IWMHeaderInfo3.VTable, @ptrCast(self.vtable)).DeleteAttribute(@as(*const IWMHeaderInfo3, @ptrCast(self)), wStreamNum, wIndex);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMHeaderInfo3_AddCodecInfo(self: *const T, pwszName: ?PWSTR, pwszDescription: ?PWSTR, codecType: WMT_CODEC_INFO_TYPE, cbCodecInfo: u16, pbCodecInfo: [*:0]u8) HRESULT {
                return @as(*const IWMHeaderInfo3.VTable, @ptrCast(self.vtable)).AddCodecInfo(@as(*const IWMHeaderInfo3, @ptrCast(self)), pwszName, pwszDescription, codecType, cbCodecInfo, pbCodecInfo);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMProfileManager_Value = Guid.initString("d16679f2-6ca0-472d-8d31-2f5d55aee155");
pub const IID_IWMProfileManager = &IID_IWMProfileManager_Value;
pub const IWMProfileManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateEmptyProfile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMProfileManager,
                dwVersion: WMT_VERSION,
                ppProfile: ?*?*IWMProfile,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMProfileManager,
                dwVersion: WMT_VERSION,
                ppProfile: ?*?*IWMProfile,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LoadProfileByID: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMProfileManager,
                guidProfile: ?*const Guid,
                ppProfile: ?*?*IWMProfile,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMProfileManager,
                guidProfile: ?*const Guid,
                ppProfile: ?*?*IWMProfile,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LoadProfileByData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMProfileManager,
                pwszProfile: ?[*:0]const u16,
                ppProfile: ?*?*IWMProfile,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMProfileManager,
                pwszProfile: ?[*:0]const u16,
                ppProfile: ?*?*IWMProfile,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SaveProfile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMProfileManager,
                pIWMProfile: ?*IWMProfile,
                pwszProfile: ?PWSTR,
                pdwLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMProfileManager,
                pIWMProfile: ?*IWMProfile,
                pwszProfile: ?PWSTR,
                pdwLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSystemProfileCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMProfileManager,
                pcProfiles: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMProfileManager,
                pcProfiles: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LoadSystemProfile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMProfileManager,
                dwProfileIndex: u32,
                ppProfile: ?*?*IWMProfile,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMProfileManager,
                dwProfileIndex: u32,
                ppProfile: ?*?*IWMProfile,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMProfileManager_CreateEmptyProfile(self: *const T, dwVersion: WMT_VERSION, ppProfile: ?*?*IWMProfile) HRESULT {
                return @as(*const IWMProfileManager.VTable, @ptrCast(self.vtable)).CreateEmptyProfile(@as(*const IWMProfileManager, @ptrCast(self)), dwVersion, ppProfile);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMProfileManager_LoadProfileByID(self: *const T, guidProfile: ?*const Guid, ppProfile: ?*?*IWMProfile) HRESULT {
                return @as(*const IWMProfileManager.VTable, @ptrCast(self.vtable)).LoadProfileByID(@as(*const IWMProfileManager, @ptrCast(self)), guidProfile, ppProfile);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMProfileManager_LoadProfileByData(self: *const T, pwszProfile: ?[*:0]const u16, ppProfile: ?*?*IWMProfile) HRESULT {
                return @as(*const IWMProfileManager.VTable, @ptrCast(self.vtable)).LoadProfileByData(@as(*const IWMProfileManager, @ptrCast(self)), pwszProfile, ppProfile);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMProfileManager_SaveProfile(self: *const T, pIWMProfile: ?*IWMProfile, pwszProfile: ?PWSTR, pdwLength: ?*u32) HRESULT {
                return @as(*const IWMProfileManager.VTable, @ptrCast(self.vtable)).SaveProfile(@as(*const IWMProfileManager, @ptrCast(self)), pIWMProfile, pwszProfile, pdwLength);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMProfileManager_GetSystemProfileCount(self: *const T, pcProfiles: ?*u32) HRESULT {
                return @as(*const IWMProfileManager.VTable, @ptrCast(self.vtable)).GetSystemProfileCount(@as(*const IWMProfileManager, @ptrCast(self)), pcProfiles);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMProfileManager_LoadSystemProfile(self: *const T, dwProfileIndex: u32, ppProfile: ?*?*IWMProfile) HRESULT {
                return @as(*const IWMProfileManager.VTable, @ptrCast(self.vtable)).LoadSystemProfile(@as(*const IWMProfileManager, @ptrCast(self)), dwProfileIndex, ppProfile);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMProfileManager2_Value = Guid.initString("7a924e51-73c1-494d-8019-23d37ed9b89a");
pub const IID_IWMProfileManager2 = &IID_IWMProfileManager2_Value;
pub const IWMProfileManager2 = extern struct {
    pub const VTable = extern struct {
        base: IWMProfileManager.VTable,
        GetSystemProfileVersion: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMProfileManager2,
                pdwVersion: ?*WMT_VERSION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMProfileManager2,
                pdwVersion: ?*WMT_VERSION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSystemProfileVersion: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMProfileManager2,
                dwVersion: WMT_VERSION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMProfileManager2,
                dwVersion: WMT_VERSION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWMProfileManager.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMProfileManager2_GetSystemProfileVersion(self: *const T, pdwVersion: ?*WMT_VERSION) HRESULT {
                return @as(*const IWMProfileManager2.VTable, @ptrCast(self.vtable)).GetSystemProfileVersion(@as(*const IWMProfileManager2, @ptrCast(self)), pdwVersion);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMProfileManager2_SetSystemProfileVersion(self: *const T, dwVersion: WMT_VERSION) HRESULT {
                return @as(*const IWMProfileManager2.VTable, @ptrCast(self.vtable)).SetSystemProfileVersion(@as(*const IWMProfileManager2, @ptrCast(self)), dwVersion);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMProfileManagerLanguage_Value = Guid.initString("ba4dcc78-7ee0-4ab8-b27a-dbce8bc51454");
pub const IID_IWMProfileManagerLanguage = &IID_IWMProfileManagerLanguage_Value;
pub const IWMProfileManagerLanguage = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetUserLanguageID: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMProfileManagerLanguage,
                wLangID: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMProfileManagerLanguage,
                wLangID: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetUserLanguageID: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMProfileManagerLanguage,
                wLangID: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMProfileManagerLanguage,
                wLangID: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMProfileManagerLanguage_GetUserLanguageID(self: *const T, wLangID: ?*u16) HRESULT {
                return @as(*const IWMProfileManagerLanguage.VTable, @ptrCast(self.vtable)).GetUserLanguageID(@as(*const IWMProfileManagerLanguage, @ptrCast(self)), wLangID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMProfileManagerLanguage_SetUserLanguageID(self: *const T, wLangID: u16) HRESULT {
                return @as(*const IWMProfileManagerLanguage.VTable, @ptrCast(self.vtable)).SetUserLanguageID(@as(*const IWMProfileManagerLanguage, @ptrCast(self)), wLangID);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMProfile_Value = Guid.initString("96406bdb-2b2b-11d3-b36b-00c04f6108ff");
pub const IID_IWMProfile = &IID_IWMProfile_Value;
pub const IWMProfile = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetVersion: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMProfile,
                pdwVersion: ?*WMT_VERSION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMProfile,
                pdwVersion: ?*WMT_VERSION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMProfile,
                pwszName: [*:0]u16,
                pcchName: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMProfile,
                pwszName: [*:0]u16,
                pcchName: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMProfile,
                pwszName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMProfile,
                pwszName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMProfile,
                pwszDescription: [*:0]u16,
                pcchDescription: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMProfile,
                pwszDescription: [*:0]u16,
                pcchDescription: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMProfile,
                pwszDescription: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMProfile,
                pwszDescription: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStreamCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMProfile,
                pcStreams: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMProfile,
                pcStreams: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMProfile,
                dwStreamIndex: u32,
                ppConfig: ?*?*IWMStreamConfig,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMProfile,
                dwStreamIndex: u32,
                ppConfig: ?*?*IWMStreamConfig,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStreamByNumber: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMProfile,
                wStreamNum: u16,
                ppConfig: ?*?*IWMStreamConfig,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMProfile,
                wStreamNum: u16,
                ppConfig: ?*?*IWMStreamConfig,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMProfile,
                pConfig: ?*IWMStreamConfig,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMProfile,
                pConfig: ?*IWMStreamConfig,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveStreamByNumber: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMProfile,
                wStreamNum: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMProfile,
                wStreamNum: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMProfile,
                pConfig: ?*IWMStreamConfig,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMProfile,
                pConfig: ?*IWMStreamConfig,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReconfigStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMProfile,
                pConfig: ?*IWMStreamConfig,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMProfile,
                pConfig: ?*IWMStreamConfig,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateNewStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMProfile,
                guidStreamType: ?*const Guid,
                ppConfig: ?*?*IWMStreamConfig,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMProfile,
                guidStreamType: ?*const Guid,
                ppConfig: ?*?*IWMStreamConfig,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMutualExclusionCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMProfile,
                pcME: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMProfile,
                pcME: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMutualExclusion: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMProfile,
                dwMEIndex: u32,
                ppME: ?*?*IWMMutualExclusion,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMProfile,
                dwMEIndex: u32,
                ppME: ?*?*IWMMutualExclusion,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveMutualExclusion: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMProfile,
                pME: ?*IWMMutualExclusion,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMProfile,
                pME: ?*IWMMutualExclusion,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddMutualExclusion: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMProfile,
                pME: ?*IWMMutualExclusion,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMProfile,
                pME: ?*IWMMutualExclusion,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateNewMutualExclusion: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMProfile,
                ppME: ?*?*IWMMutualExclusion,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMProfile,
                ppME: ?*?*IWMMutualExclusion,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMProfile_GetVersion(self: *const T, pdwVersion: ?*WMT_VERSION) HRESULT {
                return @as(*const IWMProfile.VTable, @ptrCast(self.vtable)).GetVersion(@as(*const IWMProfile, @ptrCast(self)), pdwVersion);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMProfile_GetName(self: *const T, pwszName: [*:0]u16, pcchName: ?*u32) HRESULT {
                return @as(*const IWMProfile.VTable, @ptrCast(self.vtable)).GetName(@as(*const IWMProfile, @ptrCast(self)), pwszName, pcchName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMProfile_SetName(self: *const T, pwszName: ?[*:0]const u16) HRESULT {
                return @as(*const IWMProfile.VTable, @ptrCast(self.vtable)).SetName(@as(*const IWMProfile, @ptrCast(self)), pwszName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMProfile_GetDescription(self: *const T, pwszDescription: [*:0]u16, pcchDescription: ?*u32) HRESULT {
                return @as(*const IWMProfile.VTable, @ptrCast(self.vtable)).GetDescription(@as(*const IWMProfile, @ptrCast(self)), pwszDescription, pcchDescription);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMProfile_SetDescription(self: *const T, pwszDescription: ?[*:0]const u16) HRESULT {
                return @as(*const IWMProfile.VTable, @ptrCast(self.vtable)).SetDescription(@as(*const IWMProfile, @ptrCast(self)), pwszDescription);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMProfile_GetStreamCount(self: *const T, pcStreams: ?*u32) HRESULT {
                return @as(*const IWMProfile.VTable, @ptrCast(self.vtable)).GetStreamCount(@as(*const IWMProfile, @ptrCast(self)), pcStreams);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMProfile_GetStream(self: *const T, dwStreamIndex: u32, ppConfig: ?*?*IWMStreamConfig) HRESULT {
                return @as(*const IWMProfile.VTable, @ptrCast(self.vtable)).GetStream(@as(*const IWMProfile, @ptrCast(self)), dwStreamIndex, ppConfig);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMProfile_GetStreamByNumber(self: *const T, wStreamNum: u16, ppConfig: ?*?*IWMStreamConfig) HRESULT {
                return @as(*const IWMProfile.VTable, @ptrCast(self.vtable)).GetStreamByNumber(@as(*const IWMProfile, @ptrCast(self)), wStreamNum, ppConfig);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMProfile_RemoveStream(self: *const T, pConfig: ?*IWMStreamConfig) HRESULT {
                return @as(*const IWMProfile.VTable, @ptrCast(self.vtable)).RemoveStream(@as(*const IWMProfile, @ptrCast(self)), pConfig);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMProfile_RemoveStreamByNumber(self: *const T, wStreamNum: u16) HRESULT {
                return @as(*const IWMProfile.VTable, @ptrCast(self.vtable)).RemoveStreamByNumber(@as(*const IWMProfile, @ptrCast(self)), wStreamNum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMProfile_AddStream(self: *const T, pConfig: ?*IWMStreamConfig) HRESULT {
                return @as(*const IWMProfile.VTable, @ptrCast(self.vtable)).AddStream(@as(*const IWMProfile, @ptrCast(self)), pConfig);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMProfile_ReconfigStream(self: *const T, pConfig: ?*IWMStreamConfig) HRESULT {
                return @as(*const IWMProfile.VTable, @ptrCast(self.vtable)).ReconfigStream(@as(*const IWMProfile, @ptrCast(self)), pConfig);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMProfile_CreateNewStream(self: *const T, guidStreamType: ?*const Guid, ppConfig: ?*?*IWMStreamConfig) HRESULT {
                return @as(*const IWMProfile.VTable, @ptrCast(self.vtable)).CreateNewStream(@as(*const IWMProfile, @ptrCast(self)), guidStreamType, ppConfig);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMProfile_GetMutualExclusionCount(self: *const T, pcME: ?*u32) HRESULT {
                return @as(*const IWMProfile.VTable, @ptrCast(self.vtable)).GetMutualExclusionCount(@as(*const IWMProfile, @ptrCast(self)), pcME);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMProfile_GetMutualExclusion(self: *const T, dwMEIndex: u32, ppME: ?*?*IWMMutualExclusion) HRESULT {
                return @as(*const IWMProfile.VTable, @ptrCast(self.vtable)).GetMutualExclusion(@as(*const IWMProfile, @ptrCast(self)), dwMEIndex, ppME);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMProfile_RemoveMutualExclusion(self: *const T, pME: ?*IWMMutualExclusion) HRESULT {
                return @as(*const IWMProfile.VTable, @ptrCast(self.vtable)).RemoveMutualExclusion(@as(*const IWMProfile, @ptrCast(self)), pME);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMProfile_AddMutualExclusion(self: *const T, pME: ?*IWMMutualExclusion) HRESULT {
                return @as(*const IWMProfile.VTable, @ptrCast(self.vtable)).AddMutualExclusion(@as(*const IWMProfile, @ptrCast(self)), pME);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMProfile_CreateNewMutualExclusion(self: *const T, ppME: ?*?*IWMMutualExclusion) HRESULT {
                return @as(*const IWMProfile.VTable, @ptrCast(self.vtable)).CreateNewMutualExclusion(@as(*const IWMProfile, @ptrCast(self)), ppME);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMProfile2_Value = Guid.initString("07e72d33-d94e-4be7-8843-60ae5ff7e5f5");
pub const IID_IWMProfile2 = &IID_IWMProfile2_Value;
pub const IWMProfile2 = extern struct {
    pub const VTable = extern struct {
        base: IWMProfile.VTable,
        GetProfileID: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMProfile2,
                pguidID: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMProfile2,
                pguidID: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWMProfile.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMProfile2_GetProfileID(self: *const T, pguidID: ?*Guid) HRESULT {
                return @as(*const IWMProfile2.VTable, @ptrCast(self.vtable)).GetProfileID(@as(*const IWMProfile2, @ptrCast(self)), pguidID);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMProfile3_Value = Guid.initString("00ef96cc-a461-4546-8bcd-c9a28f0e06f5");
pub const IID_IWMProfile3 = &IID_IWMProfile3_Value;
pub const IWMProfile3 = extern struct {
    pub const VTable = extern struct {
        base: IWMProfile2.VTable,
        GetStorageFormat: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMProfile3,
                pnStorageFormat: ?*WMT_STORAGE_FORMAT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMProfile3,
                pnStorageFormat: ?*WMT_STORAGE_FORMAT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetStorageFormat: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMProfile3,
                nStorageFormat: WMT_STORAGE_FORMAT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMProfile3,
                nStorageFormat: WMT_STORAGE_FORMAT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBandwidthSharingCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMProfile3,
                pcBS: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMProfile3,
                pcBS: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBandwidthSharing: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMProfile3,
                dwBSIndex: u32,
                ppBS: ?*?*IWMBandwidthSharing,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMProfile3,
                dwBSIndex: u32,
                ppBS: ?*?*IWMBandwidthSharing,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveBandwidthSharing: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMProfile3,
                pBS: ?*IWMBandwidthSharing,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMProfile3,
                pBS: ?*IWMBandwidthSharing,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddBandwidthSharing: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMProfile3,
                pBS: ?*IWMBandwidthSharing,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMProfile3,
                pBS: ?*IWMBandwidthSharing,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateNewBandwidthSharing: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMProfile3,
                ppBS: ?*?*IWMBandwidthSharing,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMProfile3,
                ppBS: ?*?*IWMBandwidthSharing,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStreamPrioritization: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMProfile3,
                ppSP: ?*?*IWMStreamPrioritization,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMProfile3,
                ppSP: ?*?*IWMStreamPrioritization,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetStreamPrioritization: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMProfile3,
                pSP: ?*IWMStreamPrioritization,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMProfile3,
                pSP: ?*IWMStreamPrioritization,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveStreamPrioritization: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMProfile3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMProfile3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateNewStreamPrioritization: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMProfile3,
                ppSP: ?*?*IWMStreamPrioritization,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMProfile3,
                ppSP: ?*?*IWMStreamPrioritization,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExpectedPacketCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMProfile3,
                msDuration: u64,
                pcPackets: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMProfile3,
                msDuration: u64,
                pcPackets: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWMProfile2.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMProfile3_GetStorageFormat(self: *const T, pnStorageFormat: ?*WMT_STORAGE_FORMAT) HRESULT {
                return @as(*const IWMProfile3.VTable, @ptrCast(self.vtable)).GetStorageFormat(@as(*const IWMProfile3, @ptrCast(self)), pnStorageFormat);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMProfile3_SetStorageFormat(self: *const T, nStorageFormat: WMT_STORAGE_FORMAT) HRESULT {
                return @as(*const IWMProfile3.VTable, @ptrCast(self.vtable)).SetStorageFormat(@as(*const IWMProfile3, @ptrCast(self)), nStorageFormat);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMProfile3_GetBandwidthSharingCount(self: *const T, pcBS: ?*u32) HRESULT {
                return @as(*const IWMProfile3.VTable, @ptrCast(self.vtable)).GetBandwidthSharingCount(@as(*const IWMProfile3, @ptrCast(self)), pcBS);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMProfile3_GetBandwidthSharing(self: *const T, dwBSIndex: u32, ppBS: ?*?*IWMBandwidthSharing) HRESULT {
                return @as(*const IWMProfile3.VTable, @ptrCast(self.vtable)).GetBandwidthSharing(@as(*const IWMProfile3, @ptrCast(self)), dwBSIndex, ppBS);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMProfile3_RemoveBandwidthSharing(self: *const T, pBS: ?*IWMBandwidthSharing) HRESULT {
                return @as(*const IWMProfile3.VTable, @ptrCast(self.vtable)).RemoveBandwidthSharing(@as(*const IWMProfile3, @ptrCast(self)), pBS);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMProfile3_AddBandwidthSharing(self: *const T, pBS: ?*IWMBandwidthSharing) HRESULT {
                return @as(*const IWMProfile3.VTable, @ptrCast(self.vtable)).AddBandwidthSharing(@as(*const IWMProfile3, @ptrCast(self)), pBS);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMProfile3_CreateNewBandwidthSharing(self: *const T, ppBS: ?*?*IWMBandwidthSharing) HRESULT {
                return @as(*const IWMProfile3.VTable, @ptrCast(self.vtable)).CreateNewBandwidthSharing(@as(*const IWMProfile3, @ptrCast(self)), ppBS);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMProfile3_GetStreamPrioritization(self: *const T, ppSP: ?*?*IWMStreamPrioritization) HRESULT {
                return @as(*const IWMProfile3.VTable, @ptrCast(self.vtable)).GetStreamPrioritization(@as(*const IWMProfile3, @ptrCast(self)), ppSP);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMProfile3_SetStreamPrioritization(self: *const T, pSP: ?*IWMStreamPrioritization) HRESULT {
                return @as(*const IWMProfile3.VTable, @ptrCast(self.vtable)).SetStreamPrioritization(@as(*const IWMProfile3, @ptrCast(self)), pSP);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMProfile3_RemoveStreamPrioritization(self: *const T) HRESULT {
                return @as(*const IWMProfile3.VTable, @ptrCast(self.vtable)).RemoveStreamPrioritization(@as(*const IWMProfile3, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMProfile3_CreateNewStreamPrioritization(self: *const T, ppSP: ?*?*IWMStreamPrioritization) HRESULT {
                return @as(*const IWMProfile3.VTable, @ptrCast(self.vtable)).CreateNewStreamPrioritization(@as(*const IWMProfile3, @ptrCast(self)), ppSP);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMProfile3_GetExpectedPacketCount(self: *const T, msDuration: u64, pcPackets: ?*u64) HRESULT {
                return @as(*const IWMProfile3.VTable, @ptrCast(self.vtable)).GetExpectedPacketCount(@as(*const IWMProfile3, @ptrCast(self)), msDuration, pcPackets);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMStreamConfig_Value = Guid.initString("96406bdc-2b2b-11d3-b36b-00c04f6108ff");
pub const IID_IWMStreamConfig = &IID_IWMStreamConfig_Value;
pub const IWMStreamConfig = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetStreamType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMStreamConfig,
                pguidStreamType: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMStreamConfig,
                pguidStreamType: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStreamNumber: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMStreamConfig,
                pwStreamNum: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMStreamConfig,
                pwStreamNum: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetStreamNumber: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMStreamConfig,
                wStreamNum: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMStreamConfig,
                wStreamNum: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStreamName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMStreamConfig,
                pwszStreamName: [*:0]u16,
                pcchStreamName: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMStreamConfig,
                pwszStreamName: [*:0]u16,
                pcchStreamName: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetStreamName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMStreamConfig,
                pwszStreamName: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMStreamConfig,
                pwszStreamName: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetConnectionName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMStreamConfig,
                pwszInputName: [*:0]u16,
                pcchInputName: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMStreamConfig,
                pwszInputName: [*:0]u16,
                pcchInputName: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetConnectionName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMStreamConfig,
                pwszInputName: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMStreamConfig,
                pwszInputName: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBitrate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMStreamConfig,
                pdwBitrate: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMStreamConfig,
                pdwBitrate: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetBitrate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMStreamConfig,
                pdwBitrate: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMStreamConfig,
                pdwBitrate: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBufferWindow: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMStreamConfig,
                pmsBufferWindow: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMStreamConfig,
                pmsBufferWindow: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetBufferWindow: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMStreamConfig,
                msBufferWindow: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMStreamConfig,
                msBufferWindow: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMStreamConfig_GetStreamType(self: *const T, pguidStreamType: ?*Guid) HRESULT {
                return @as(*const IWMStreamConfig.VTable, @ptrCast(self.vtable)).GetStreamType(@as(*const IWMStreamConfig, @ptrCast(self)), pguidStreamType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMStreamConfig_GetStreamNumber(self: *const T, pwStreamNum: ?*u16) HRESULT {
                return @as(*const IWMStreamConfig.VTable, @ptrCast(self.vtable)).GetStreamNumber(@as(*const IWMStreamConfig, @ptrCast(self)), pwStreamNum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMStreamConfig_SetStreamNumber(self: *const T, wStreamNum: u16) HRESULT {
                return @as(*const IWMStreamConfig.VTable, @ptrCast(self.vtable)).SetStreamNumber(@as(*const IWMStreamConfig, @ptrCast(self)), wStreamNum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMStreamConfig_GetStreamName(self: *const T, pwszStreamName: [*:0]u16, pcchStreamName: ?*u16) HRESULT {
                return @as(*const IWMStreamConfig.VTable, @ptrCast(self.vtable)).GetStreamName(@as(*const IWMStreamConfig, @ptrCast(self)), pwszStreamName, pcchStreamName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMStreamConfig_SetStreamName(self: *const T, pwszStreamName: ?PWSTR) HRESULT {
                return @as(*const IWMStreamConfig.VTable, @ptrCast(self.vtable)).SetStreamName(@as(*const IWMStreamConfig, @ptrCast(self)), pwszStreamName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMStreamConfig_GetConnectionName(self: *const T, pwszInputName: [*:0]u16, pcchInputName: ?*u16) HRESULT {
                return @as(*const IWMStreamConfig.VTable, @ptrCast(self.vtable)).GetConnectionName(@as(*const IWMStreamConfig, @ptrCast(self)), pwszInputName, pcchInputName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMStreamConfig_SetConnectionName(self: *const T, pwszInputName: ?PWSTR) HRESULT {
                return @as(*const IWMStreamConfig.VTable, @ptrCast(self.vtable)).SetConnectionName(@as(*const IWMStreamConfig, @ptrCast(self)), pwszInputName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMStreamConfig_GetBitrate(self: *const T, pdwBitrate: ?*u32) HRESULT {
                return @as(*const IWMStreamConfig.VTable, @ptrCast(self.vtable)).GetBitrate(@as(*const IWMStreamConfig, @ptrCast(self)), pdwBitrate);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMStreamConfig_SetBitrate(self: *const T, pdwBitrate: u32) HRESULT {
                return @as(*const IWMStreamConfig.VTable, @ptrCast(self.vtable)).SetBitrate(@as(*const IWMStreamConfig, @ptrCast(self)), pdwBitrate);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMStreamConfig_GetBufferWindow(self: *const T, pmsBufferWindow: ?*u32) HRESULT {
                return @as(*const IWMStreamConfig.VTable, @ptrCast(self.vtable)).GetBufferWindow(@as(*const IWMStreamConfig, @ptrCast(self)), pmsBufferWindow);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMStreamConfig_SetBufferWindow(self: *const T, msBufferWindow: u32) HRESULT {
                return @as(*const IWMStreamConfig.VTable, @ptrCast(self.vtable)).SetBufferWindow(@as(*const IWMStreamConfig, @ptrCast(self)), msBufferWindow);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMStreamConfig2_Value = Guid.initString("7688d8cb-fc0d-43bd-9459-5a8dec200cfa");
pub const IID_IWMStreamConfig2 = &IID_IWMStreamConfig2_Value;
pub const IWMStreamConfig2 = extern struct {
    pub const VTable = extern struct {
        base: IWMStreamConfig.VTable,
        GetTransportType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMStreamConfig2,
                pnTransportType: ?*WMT_TRANSPORT_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMStreamConfig2,
                pnTransportType: ?*WMT_TRANSPORT_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTransportType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMStreamConfig2,
                nTransportType: WMT_TRANSPORT_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMStreamConfig2,
                nTransportType: WMT_TRANSPORT_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddDataUnitExtension: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMStreamConfig2,
                guidExtensionSystemID: Guid,
                cbExtensionDataSize: u16,
                pbExtensionSystemInfo: [*:0]u8,
                cbExtensionSystemInfo: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMStreamConfig2,
                guidExtensionSystemID: Guid,
                cbExtensionDataSize: u16,
                pbExtensionSystemInfo: [*:0]u8,
                cbExtensionSystemInfo: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDataUnitExtensionCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMStreamConfig2,
                pcDataUnitExtensions: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMStreamConfig2,
                pcDataUnitExtensions: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDataUnitExtension: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMStreamConfig2,
                wDataUnitExtensionNumber: u16,
                pguidExtensionSystemID: ?*Guid,
                pcbExtensionDataSize: ?*u16,
                pbExtensionSystemInfo: [*:0]u8,
                pcbExtensionSystemInfo: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMStreamConfig2,
                wDataUnitExtensionNumber: u16,
                pguidExtensionSystemID: ?*Guid,
                pcbExtensionDataSize: ?*u16,
                pbExtensionSystemInfo: [*:0]u8,
                pcbExtensionSystemInfo: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveAllDataUnitExtensions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMStreamConfig2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMStreamConfig2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWMStreamConfig.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMStreamConfig2_GetTransportType(self: *const T, pnTransportType: ?*WMT_TRANSPORT_TYPE) HRESULT {
                return @as(*const IWMStreamConfig2.VTable, @ptrCast(self.vtable)).GetTransportType(@as(*const IWMStreamConfig2, @ptrCast(self)), pnTransportType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMStreamConfig2_SetTransportType(self: *const T, nTransportType: WMT_TRANSPORT_TYPE) HRESULT {
                return @as(*const IWMStreamConfig2.VTable, @ptrCast(self.vtable)).SetTransportType(@as(*const IWMStreamConfig2, @ptrCast(self)), nTransportType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMStreamConfig2_AddDataUnitExtension(self: *const T, guidExtensionSystemID: Guid, cbExtensionDataSize: u16, pbExtensionSystemInfo: [*:0]u8, cbExtensionSystemInfo: u32) HRESULT {
                return @as(*const IWMStreamConfig2.VTable, @ptrCast(self.vtable)).AddDataUnitExtension(@as(*const IWMStreamConfig2, @ptrCast(self)), guidExtensionSystemID, cbExtensionDataSize, pbExtensionSystemInfo, cbExtensionSystemInfo);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMStreamConfig2_GetDataUnitExtensionCount(self: *const T, pcDataUnitExtensions: ?*u16) HRESULT {
                return @as(*const IWMStreamConfig2.VTable, @ptrCast(self.vtable)).GetDataUnitExtensionCount(@as(*const IWMStreamConfig2, @ptrCast(self)), pcDataUnitExtensions);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMStreamConfig2_GetDataUnitExtension(self: *const T, wDataUnitExtensionNumber: u16, pguidExtensionSystemID: ?*Guid, pcbExtensionDataSize: ?*u16, pbExtensionSystemInfo: [*:0]u8, pcbExtensionSystemInfo: ?*u32) HRESULT {
                return @as(*const IWMStreamConfig2.VTable, @ptrCast(self.vtable)).GetDataUnitExtension(@as(*const IWMStreamConfig2, @ptrCast(self)), wDataUnitExtensionNumber, pguidExtensionSystemID, pcbExtensionDataSize, pbExtensionSystemInfo, pcbExtensionSystemInfo);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMStreamConfig2_RemoveAllDataUnitExtensions(self: *const T) HRESULT {
                return @as(*const IWMStreamConfig2.VTable, @ptrCast(self.vtable)).RemoveAllDataUnitExtensions(@as(*const IWMStreamConfig2, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMStreamConfig3_Value = Guid.initString("cb164104-3aa9-45a7-9ac9-4daee131d6e1");
pub const IID_IWMStreamConfig3 = &IID_IWMStreamConfig3_Value;
pub const IWMStreamConfig3 = extern struct {
    pub const VTable = extern struct {
        base: IWMStreamConfig2.VTable,
        GetLanguage: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMStreamConfig3,
                pwszLanguageString: [*:0]u16,
                pcchLanguageStringLength: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMStreamConfig3,
                pwszLanguageString: [*:0]u16,
                pcchLanguageStringLength: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetLanguage: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMStreamConfig3,
                pwszLanguageString: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMStreamConfig3,
                pwszLanguageString: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWMStreamConfig2.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMStreamConfig3_GetLanguage(self: *const T, pwszLanguageString: [*:0]u16, pcchLanguageStringLength: ?*u16) HRESULT {
                return @as(*const IWMStreamConfig3.VTable, @ptrCast(self.vtable)).GetLanguage(@as(*const IWMStreamConfig3, @ptrCast(self)), pwszLanguageString, pcchLanguageStringLength);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMStreamConfig3_SetLanguage(self: *const T, pwszLanguageString: ?PWSTR) HRESULT {
                return @as(*const IWMStreamConfig3.VTable, @ptrCast(self.vtable)).SetLanguage(@as(*const IWMStreamConfig3, @ptrCast(self)), pwszLanguageString);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMPacketSize_Value = Guid.initString("cdfb97ab-188f-40b3-b643-5b7903975c59");
pub const IID_IWMPacketSize = &IID_IWMPacketSize_Value;
pub const IWMPacketSize = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetMaxPacketSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPacketSize,
                pdwMaxPacketSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPacketSize,
                pdwMaxPacketSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetMaxPacketSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPacketSize,
                dwMaxPacketSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPacketSize,
                dwMaxPacketSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPacketSize_GetMaxPacketSize(self: *const T, pdwMaxPacketSize: ?*u32) HRESULT {
                return @as(*const IWMPacketSize.VTable, @ptrCast(self.vtable)).GetMaxPacketSize(@as(*const IWMPacketSize, @ptrCast(self)), pdwMaxPacketSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPacketSize_SetMaxPacketSize(self: *const T, dwMaxPacketSize: u32) HRESULT {
                return @as(*const IWMPacketSize.VTable, @ptrCast(self.vtable)).SetMaxPacketSize(@as(*const IWMPacketSize, @ptrCast(self)), dwMaxPacketSize);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMPacketSize2_Value = Guid.initString("8bfc2b9e-b646-4233-a877-1c6a079669dc");
pub const IID_IWMPacketSize2 = &IID_IWMPacketSize2_Value;
pub const IWMPacketSize2 = extern struct {
    pub const VTable = extern struct {
        base: IWMPacketSize.VTable,
        GetMinPacketSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPacketSize2,
                pdwMinPacketSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPacketSize2,
                pdwMinPacketSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetMinPacketSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPacketSize2,
                dwMinPacketSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPacketSize2,
                dwMinPacketSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWMPacketSize.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPacketSize2_GetMinPacketSize(self: *const T, pdwMinPacketSize: ?*u32) HRESULT {
                return @as(*const IWMPacketSize2.VTable, @ptrCast(self.vtable)).GetMinPacketSize(@as(*const IWMPacketSize2, @ptrCast(self)), pdwMinPacketSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPacketSize2_SetMinPacketSize(self: *const T, dwMinPacketSize: u32) HRESULT {
                return @as(*const IWMPacketSize2.VTable, @ptrCast(self.vtable)).SetMinPacketSize(@as(*const IWMPacketSize2, @ptrCast(self)), dwMinPacketSize);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMStreamList_Value = Guid.initString("96406bdd-2b2b-11d3-b36b-00c04f6108ff");
pub const IID_IWMStreamList = &IID_IWMStreamList_Value;
pub const IWMStreamList = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetStreams: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMStreamList,
                pwStreamNumArray: [*:0]u16,
                pcStreams: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMStreamList,
                pwStreamNumArray: [*:0]u16,
                pcStreams: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMStreamList,
                wStreamNum: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMStreamList,
                wStreamNum: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMStreamList,
                wStreamNum: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMStreamList,
                wStreamNum: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMStreamList_GetStreams(self: *const T, pwStreamNumArray: [*:0]u16, pcStreams: ?*u16) HRESULT {
                return @as(*const IWMStreamList.VTable, @ptrCast(self.vtable)).GetStreams(@as(*const IWMStreamList, @ptrCast(self)), pwStreamNumArray, pcStreams);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMStreamList_AddStream(self: *const T, wStreamNum: u16) HRESULT {
                return @as(*const IWMStreamList.VTable, @ptrCast(self.vtable)).AddStream(@as(*const IWMStreamList, @ptrCast(self)), wStreamNum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMStreamList_RemoveStream(self: *const T, wStreamNum: u16) HRESULT {
                return @as(*const IWMStreamList.VTable, @ptrCast(self.vtable)).RemoveStream(@as(*const IWMStreamList, @ptrCast(self)), wStreamNum);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMMutualExclusion_Value = Guid.initString("96406bde-2b2b-11d3-b36b-00c04f6108ff");
pub const IID_IWMMutualExclusion = &IID_IWMMutualExclusion_Value;
pub const IWMMutualExclusion = extern struct {
    pub const VTable = extern struct {
        base: IWMStreamList.VTable,
        GetType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMMutualExclusion,
                pguidType: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMMutualExclusion,
                pguidType: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMMutualExclusion,
                guidType: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMMutualExclusion,
                guidType: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWMStreamList.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMMutualExclusion_GetType(self: *const T, pguidType: ?*Guid) HRESULT {
                return @as(*const IWMMutualExclusion.VTable, @ptrCast(self.vtable)).GetType(@as(*const IWMMutualExclusion, @ptrCast(self)), pguidType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMMutualExclusion_SetType(self: *const T, guidType: ?*const Guid) HRESULT {
                return @as(*const IWMMutualExclusion.VTable, @ptrCast(self.vtable)).SetType(@as(*const IWMMutualExclusion, @ptrCast(self)), guidType);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMMutualExclusion2_Value = Guid.initString("0302b57d-89d1-4ba2-85c9-166f2c53eb91");
pub const IID_IWMMutualExclusion2 = &IID_IWMMutualExclusion2_Value;
pub const IWMMutualExclusion2 = extern struct {
    pub const VTable = extern struct {
        base: IWMMutualExclusion.VTable,
        GetName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMMutualExclusion2,
                pwszName: [*:0]u16,
                pcchName: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMMutualExclusion2,
                pwszName: [*:0]u16,
                pcchName: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMMutualExclusion2,
                pwszName: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMMutualExclusion2,
                pwszName: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMMutualExclusion2,
                pwRecordCount: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMMutualExclusion2,
                pwRecordCount: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddRecord: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMMutualExclusion2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMMutualExclusion2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveRecord: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMMutualExclusion2,
                wRecordNumber: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMMutualExclusion2,
                wRecordNumber: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMMutualExclusion2,
                wRecordNumber: u16,
                pwszRecordName: [*:0]u16,
                pcchRecordName: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMMutualExclusion2,
                wRecordNumber: u16,
                pwszRecordName: [*:0]u16,
                pcchRecordName: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetRecordName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMMutualExclusion2,
                wRecordNumber: u16,
                pwszRecordName: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMMutualExclusion2,
                wRecordNumber: u16,
                pwszRecordName: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStreamsForRecord: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMMutualExclusion2,
                wRecordNumber: u16,
                pwStreamNumArray: [*:0]u16,
                pcStreams: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMMutualExclusion2,
                wRecordNumber: u16,
                pwStreamNumArray: [*:0]u16,
                pcStreams: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddStreamForRecord: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMMutualExclusion2,
                wRecordNumber: u16,
                wStreamNumber: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMMutualExclusion2,
                wRecordNumber: u16,
                wStreamNumber: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveStreamForRecord: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMMutualExclusion2,
                wRecordNumber: u16,
                wStreamNumber: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMMutualExclusion2,
                wRecordNumber: u16,
                wStreamNumber: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWMMutualExclusion.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMMutualExclusion2_GetName(self: *const T, pwszName: [*:0]u16, pcchName: ?*u16) HRESULT {
                return @as(*const IWMMutualExclusion2.VTable, @ptrCast(self.vtable)).GetName(@as(*const IWMMutualExclusion2, @ptrCast(self)), pwszName, pcchName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMMutualExclusion2_SetName(self: *const T, pwszName: ?PWSTR) HRESULT {
                return @as(*const IWMMutualExclusion2.VTable, @ptrCast(self.vtable)).SetName(@as(*const IWMMutualExclusion2, @ptrCast(self)), pwszName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMMutualExclusion2_GetRecordCount(self: *const T, pwRecordCount: ?*u16) HRESULT {
                return @as(*const IWMMutualExclusion2.VTable, @ptrCast(self.vtable)).GetRecordCount(@as(*const IWMMutualExclusion2, @ptrCast(self)), pwRecordCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMMutualExclusion2_AddRecord(self: *const T) HRESULT {
                return @as(*const IWMMutualExclusion2.VTable, @ptrCast(self.vtable)).AddRecord(@as(*const IWMMutualExclusion2, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMMutualExclusion2_RemoveRecord(self: *const T, wRecordNumber: u16) HRESULT {
                return @as(*const IWMMutualExclusion2.VTable, @ptrCast(self.vtable)).RemoveRecord(@as(*const IWMMutualExclusion2, @ptrCast(self)), wRecordNumber);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMMutualExclusion2_GetRecordName(self: *const T, wRecordNumber: u16, pwszRecordName: [*:0]u16, pcchRecordName: ?*u16) HRESULT {
                return @as(*const IWMMutualExclusion2.VTable, @ptrCast(self.vtable)).GetRecordName(@as(*const IWMMutualExclusion2, @ptrCast(self)), wRecordNumber, pwszRecordName, pcchRecordName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMMutualExclusion2_SetRecordName(self: *const T, wRecordNumber: u16, pwszRecordName: ?PWSTR) HRESULT {
                return @as(*const IWMMutualExclusion2.VTable, @ptrCast(self.vtable)).SetRecordName(@as(*const IWMMutualExclusion2, @ptrCast(self)), wRecordNumber, pwszRecordName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMMutualExclusion2_GetStreamsForRecord(self: *const T, wRecordNumber: u16, pwStreamNumArray: [*:0]u16, pcStreams: ?*u16) HRESULT {
                return @as(*const IWMMutualExclusion2.VTable, @ptrCast(self.vtable)).GetStreamsForRecord(@as(*const IWMMutualExclusion2, @ptrCast(self)), wRecordNumber, pwStreamNumArray, pcStreams);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMMutualExclusion2_AddStreamForRecord(self: *const T, wRecordNumber: u16, wStreamNumber: u16) HRESULT {
                return @as(*const IWMMutualExclusion2.VTable, @ptrCast(self.vtable)).AddStreamForRecord(@as(*const IWMMutualExclusion2, @ptrCast(self)), wRecordNumber, wStreamNumber);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMMutualExclusion2_RemoveStreamForRecord(self: *const T, wRecordNumber: u16, wStreamNumber: u16) HRESULT {
                return @as(*const IWMMutualExclusion2.VTable, @ptrCast(self.vtable)).RemoveStreamForRecord(@as(*const IWMMutualExclusion2, @ptrCast(self)), wRecordNumber, wStreamNumber);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMBandwidthSharing_Value = Guid.initString("ad694af1-f8d9-42f8-bc47-70311b0c4f9e");
pub const IID_IWMBandwidthSharing = &IID_IWMBandwidthSharing_Value;
pub const IWMBandwidthSharing = extern struct {
    pub const VTable = extern struct {
        base: IWMStreamList.VTable,
        GetType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMBandwidthSharing,
                pguidType: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMBandwidthSharing,
                pguidType: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMBandwidthSharing,
                guidType: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMBandwidthSharing,
                guidType: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBandwidth: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMBandwidthSharing,
                pdwBitrate: ?*u32,
                pmsBufferWindow: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMBandwidthSharing,
                pdwBitrate: ?*u32,
                pmsBufferWindow: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetBandwidth: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMBandwidthSharing,
                dwBitrate: u32,
                msBufferWindow: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMBandwidthSharing,
                dwBitrate: u32,
                msBufferWindow: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWMStreamList.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMBandwidthSharing_GetType(self: *const T, pguidType: ?*Guid) HRESULT {
                return @as(*const IWMBandwidthSharing.VTable, @ptrCast(self.vtable)).GetType(@as(*const IWMBandwidthSharing, @ptrCast(self)), pguidType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMBandwidthSharing_SetType(self: *const T, guidType: ?*const Guid) HRESULT {
                return @as(*const IWMBandwidthSharing.VTable, @ptrCast(self.vtable)).SetType(@as(*const IWMBandwidthSharing, @ptrCast(self)), guidType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMBandwidthSharing_GetBandwidth(self: *const T, pdwBitrate: ?*u32, pmsBufferWindow: ?*u32) HRESULT {
                return @as(*const IWMBandwidthSharing.VTable, @ptrCast(self.vtable)).GetBandwidth(@as(*const IWMBandwidthSharing, @ptrCast(self)), pdwBitrate, pmsBufferWindow);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMBandwidthSharing_SetBandwidth(self: *const T, dwBitrate: u32, msBufferWindow: u32) HRESULT {
                return @as(*const IWMBandwidthSharing.VTable, @ptrCast(self.vtable)).SetBandwidth(@as(*const IWMBandwidthSharing, @ptrCast(self)), dwBitrate, msBufferWindow);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMStreamPrioritization_Value = Guid.initString("8c1c6090-f9a8-4748-8ec3-dd1108ba1e77");
pub const IID_IWMStreamPrioritization = &IID_IWMStreamPrioritization_Value;
pub const IWMStreamPrioritization = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPriorityRecords: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMStreamPrioritization,
                pRecordArray: [*]WM_STREAM_PRIORITY_RECORD,
                pcRecords: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMStreamPrioritization,
                pRecordArray: [*]WM_STREAM_PRIORITY_RECORD,
                pcRecords: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPriorityRecords: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMStreamPrioritization,
                pRecordArray: ?*WM_STREAM_PRIORITY_RECORD,
                cRecords: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMStreamPrioritization,
                pRecordArray: ?*WM_STREAM_PRIORITY_RECORD,
                cRecords: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMStreamPrioritization_GetPriorityRecords(self: *const T, pRecordArray: [*]WM_STREAM_PRIORITY_RECORD, pcRecords: ?*u16) HRESULT {
                return @as(*const IWMStreamPrioritization.VTable, @ptrCast(self.vtable)).GetPriorityRecords(@as(*const IWMStreamPrioritization, @ptrCast(self)), pRecordArray, pcRecords);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMStreamPrioritization_SetPriorityRecords(self: *const T, pRecordArray: ?*WM_STREAM_PRIORITY_RECORD, cRecords: u16) HRESULT {
                return @as(*const IWMStreamPrioritization.VTable, @ptrCast(self.vtable)).SetPriorityRecords(@as(*const IWMStreamPrioritization, @ptrCast(self)), pRecordArray, cRecords);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMWriterAdvanced_Value = Guid.initString("96406be3-2b2b-11d3-b36b-00c04f6108ff");
pub const IID_IWMWriterAdvanced = &IID_IWMWriterAdvanced_Value;
pub const IWMWriterAdvanced = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSinkCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMWriterAdvanced,
                pcSinks: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMWriterAdvanced,
                pcSinks: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSink: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMWriterAdvanced,
                dwSinkNum: u32,
                ppSink: ?*?*IWMWriterSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMWriterAdvanced,
                dwSinkNum: u32,
                ppSink: ?*?*IWMWriterSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddSink: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMWriterAdvanced,
                pSink: ?*IWMWriterSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMWriterAdvanced,
                pSink: ?*IWMWriterSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveSink: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMWriterAdvanced,
                pSink: ?*IWMWriterSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMWriterAdvanced,
                pSink: ?*IWMWriterSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteStreamSample: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMWriterAdvanced,
                wStreamNum: u16,
                cnsSampleTime: u64,
                msSampleSendTime: u32,
                cnsSampleDuration: u64,
                dwFlags: u32,
                pSample: ?*INSSBuffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMWriterAdvanced,
                wStreamNum: u16,
                cnsSampleTime: u64,
                msSampleSendTime: u32,
                cnsSampleDuration: u64,
                dwFlags: u32,
                pSample: ?*INSSBuffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetLiveSource: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMWriterAdvanced,
                fIsLiveSource: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMWriterAdvanced,
                fIsLiveSource: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsRealTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMWriterAdvanced,
                pfRealTime: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMWriterAdvanced,
                pfRealTime: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetWriterTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMWriterAdvanced,
                pcnsCurrentTime: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMWriterAdvanced,
                pcnsCurrentTime: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStatistics: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMWriterAdvanced,
                wStreamNum: u16,
                pStats: ?*WM_WRITER_STATISTICS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMWriterAdvanced,
                wStreamNum: u16,
                pStats: ?*WM_WRITER_STATISTICS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSyncTolerance: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMWriterAdvanced,
                msWindow: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMWriterAdvanced,
                msWindow: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSyncTolerance: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMWriterAdvanced,
                pmsWindow: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMWriterAdvanced,
                pmsWindow: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMWriterAdvanced_GetSinkCount(self: *const T, pcSinks: ?*u32) HRESULT {
                return @as(*const IWMWriterAdvanced.VTable, @ptrCast(self.vtable)).GetSinkCount(@as(*const IWMWriterAdvanced, @ptrCast(self)), pcSinks);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMWriterAdvanced_GetSink(self: *const T, dwSinkNum: u32, ppSink: ?*?*IWMWriterSink) HRESULT {
                return @as(*const IWMWriterAdvanced.VTable, @ptrCast(self.vtable)).GetSink(@as(*const IWMWriterAdvanced, @ptrCast(self)), dwSinkNum, ppSink);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMWriterAdvanced_AddSink(self: *const T, pSink: ?*IWMWriterSink) HRESULT {
                return @as(*const IWMWriterAdvanced.VTable, @ptrCast(self.vtable)).AddSink(@as(*const IWMWriterAdvanced, @ptrCast(self)), pSink);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMWriterAdvanced_RemoveSink(self: *const T, pSink: ?*IWMWriterSink) HRESULT {
                return @as(*const IWMWriterAdvanced.VTable, @ptrCast(self.vtable)).RemoveSink(@as(*const IWMWriterAdvanced, @ptrCast(self)), pSink);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMWriterAdvanced_WriteStreamSample(self: *const T, wStreamNum: u16, cnsSampleTime: u64, msSampleSendTime: u32, cnsSampleDuration: u64, dwFlags: u32, pSample: ?*INSSBuffer) HRESULT {
                return @as(*const IWMWriterAdvanced.VTable, @ptrCast(self.vtable)).WriteStreamSample(@as(*const IWMWriterAdvanced, @ptrCast(self)), wStreamNum, cnsSampleTime, msSampleSendTime, cnsSampleDuration, dwFlags, pSample);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMWriterAdvanced_SetLiveSource(self: *const T, fIsLiveSource: BOOL) HRESULT {
                return @as(*const IWMWriterAdvanced.VTable, @ptrCast(self.vtable)).SetLiveSource(@as(*const IWMWriterAdvanced, @ptrCast(self)), fIsLiveSource);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMWriterAdvanced_IsRealTime(self: *const T, pfRealTime: ?*BOOL) HRESULT {
                return @as(*const IWMWriterAdvanced.VTable, @ptrCast(self.vtable)).IsRealTime(@as(*const IWMWriterAdvanced, @ptrCast(self)), pfRealTime);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMWriterAdvanced_GetWriterTime(self: *const T, pcnsCurrentTime: ?*u64) HRESULT {
                return @as(*const IWMWriterAdvanced.VTable, @ptrCast(self.vtable)).GetWriterTime(@as(*const IWMWriterAdvanced, @ptrCast(self)), pcnsCurrentTime);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMWriterAdvanced_GetStatistics(self: *const T, wStreamNum: u16, pStats: ?*WM_WRITER_STATISTICS) HRESULT {
                return @as(*const IWMWriterAdvanced.VTable, @ptrCast(self.vtable)).GetStatistics(@as(*const IWMWriterAdvanced, @ptrCast(self)), wStreamNum, pStats);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMWriterAdvanced_SetSyncTolerance(self: *const T, msWindow: u32) HRESULT {
                return @as(*const IWMWriterAdvanced.VTable, @ptrCast(self.vtable)).SetSyncTolerance(@as(*const IWMWriterAdvanced, @ptrCast(self)), msWindow);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMWriterAdvanced_GetSyncTolerance(self: *const T, pmsWindow: ?*u32) HRESULT {
                return @as(*const IWMWriterAdvanced.VTable, @ptrCast(self.vtable)).GetSyncTolerance(@as(*const IWMWriterAdvanced, @ptrCast(self)), pmsWindow);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMWriterAdvanced2_Value = Guid.initString("962dc1ec-c046-4db8-9cc7-26ceae500817");
pub const IID_IWMWriterAdvanced2 = &IID_IWMWriterAdvanced2_Value;
pub const IWMWriterAdvanced2 = extern struct {
    pub const VTable = extern struct {
        base: IWMWriterAdvanced.VTable,
        GetInputSetting: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMWriterAdvanced2,
                dwInputNum: u32,
                pszName: ?[*:0]const u16,
                pType: ?*WMT_ATTR_DATATYPE,
                pValue: [*:0]u8,
                pcbLength: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMWriterAdvanced2,
                dwInputNum: u32,
                pszName: ?[*:0]const u16,
                pType: ?*WMT_ATTR_DATATYPE,
                pValue: [*:0]u8,
                pcbLength: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetInputSetting: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMWriterAdvanced2,
                dwInputNum: u32,
                pszName: ?[*:0]const u16,
                Type: WMT_ATTR_DATATYPE,
                pValue: [*:0]const u8,
                cbLength: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMWriterAdvanced2,
                dwInputNum: u32,
                pszName: ?[*:0]const u16,
                Type: WMT_ATTR_DATATYPE,
                pValue: [*:0]const u8,
                cbLength: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWMWriterAdvanced.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMWriterAdvanced2_GetInputSetting(self: *const T, dwInputNum: u32, pszName: ?[*:0]const u16, pType: ?*WMT_ATTR_DATATYPE, pValue: [*:0]u8, pcbLength: ?*u16) HRESULT {
                return @as(*const IWMWriterAdvanced2.VTable, @ptrCast(self.vtable)).GetInputSetting(@as(*const IWMWriterAdvanced2, @ptrCast(self)), dwInputNum, pszName, pType, pValue, pcbLength);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMWriterAdvanced2_SetInputSetting(self: *const T, dwInputNum: u32, pszName: ?[*:0]const u16, Type: WMT_ATTR_DATATYPE, pValue: [*:0]const u8, cbLength: u16) HRESULT {
                return @as(*const IWMWriterAdvanced2.VTable, @ptrCast(self.vtable)).SetInputSetting(@as(*const IWMWriterAdvanced2, @ptrCast(self)), dwInputNum, pszName, Type, pValue, cbLength);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMWriterAdvanced3_Value = Guid.initString("2cd6492d-7c37-4e76-9d3b-59261183a22e");
pub const IID_IWMWriterAdvanced3 = &IID_IWMWriterAdvanced3_Value;
pub const IWMWriterAdvanced3 = extern struct {
    pub const VTable = extern struct {
        base: IWMWriterAdvanced2.VTable,
        GetStatisticsEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMWriterAdvanced3,
                wStreamNum: u16,
                pStats: ?*WM_WRITER_STATISTICS_EX,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMWriterAdvanced3,
                wStreamNum: u16,
                pStats: ?*WM_WRITER_STATISTICS_EX,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetNonBlocking: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMWriterAdvanced3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMWriterAdvanced3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWMWriterAdvanced2.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMWriterAdvanced3_GetStatisticsEx(self: *const T, wStreamNum: u16, pStats: ?*WM_WRITER_STATISTICS_EX) HRESULT {
                return @as(*const IWMWriterAdvanced3.VTable, @ptrCast(self.vtable)).GetStatisticsEx(@as(*const IWMWriterAdvanced3, @ptrCast(self)), wStreamNum, pStats);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMWriterAdvanced3_SetNonBlocking(self: *const T) HRESULT {
                return @as(*const IWMWriterAdvanced3.VTable, @ptrCast(self.vtable)).SetNonBlocking(@as(*const IWMWriterAdvanced3, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMWriterPreprocess_Value = Guid.initString("fc54a285-38c4-45b5-aa23-85b9f7cb424b");
pub const IID_IWMWriterPreprocess = &IID_IWMWriterPreprocess_Value;
pub const IWMWriterPreprocess = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetMaxPreprocessingPasses: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMWriterPreprocess,
                dwInputNum: u32,
                dwFlags: u32,
                pdwMaxNumPasses: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMWriterPreprocess,
                dwInputNum: u32,
                dwFlags: u32,
                pdwMaxNumPasses: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetNumPreprocessingPasses: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMWriterPreprocess,
                dwInputNum: u32,
                dwFlags: u32,
                dwNumPasses: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMWriterPreprocess,
                dwInputNum: u32,
                dwFlags: u32,
                dwNumPasses: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BeginPreprocessingPass: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMWriterPreprocess,
                dwInputNum: u32,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMWriterPreprocess,
                dwInputNum: u32,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PreprocessSample: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMWriterPreprocess,
                dwInputNum: u32,
                cnsSampleTime: u64,
                dwFlags: u32,
                pSample: ?*INSSBuffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMWriterPreprocess,
                dwInputNum: u32,
                cnsSampleTime: u64,
                dwFlags: u32,
                pSample: ?*INSSBuffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndPreprocessingPass: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMWriterPreprocess,
                dwInputNum: u32,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMWriterPreprocess,
                dwInputNum: u32,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMWriterPreprocess_GetMaxPreprocessingPasses(self: *const T, dwInputNum: u32, dwFlags: u32, pdwMaxNumPasses: ?*u32) HRESULT {
                return @as(*const IWMWriterPreprocess.VTable, @ptrCast(self.vtable)).GetMaxPreprocessingPasses(@as(*const IWMWriterPreprocess, @ptrCast(self)), dwInputNum, dwFlags, pdwMaxNumPasses);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMWriterPreprocess_SetNumPreprocessingPasses(self: *const T, dwInputNum: u32, dwFlags: u32, dwNumPasses: u32) HRESULT {
                return @as(*const IWMWriterPreprocess.VTable, @ptrCast(self.vtable)).SetNumPreprocessingPasses(@as(*const IWMWriterPreprocess, @ptrCast(self)), dwInputNum, dwFlags, dwNumPasses);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMWriterPreprocess_BeginPreprocessingPass(self: *const T, dwInputNum: u32, dwFlags: u32) HRESULT {
                return @as(*const IWMWriterPreprocess.VTable, @ptrCast(self.vtable)).BeginPreprocessingPass(@as(*const IWMWriterPreprocess, @ptrCast(self)), dwInputNum, dwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMWriterPreprocess_PreprocessSample(self: *const T, dwInputNum: u32, cnsSampleTime: u64, dwFlags: u32, pSample: ?*INSSBuffer) HRESULT {
                return @as(*const IWMWriterPreprocess.VTable, @ptrCast(self.vtable)).PreprocessSample(@as(*const IWMWriterPreprocess, @ptrCast(self)), dwInputNum, cnsSampleTime, dwFlags, pSample);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMWriterPreprocess_EndPreprocessingPass(self: *const T, dwInputNum: u32, dwFlags: u32) HRESULT {
                return @as(*const IWMWriterPreprocess.VTable, @ptrCast(self.vtable)).EndPreprocessingPass(@as(*const IWMWriterPreprocess, @ptrCast(self)), dwInputNum, dwFlags);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMWriterPostViewCallback_Value = Guid.initString("d9d6549d-a193-4f24-b308-03123d9b7f8d");
pub const IID_IWMWriterPostViewCallback = &IID_IWMWriterPostViewCallback_Value;
pub const IWMWriterPostViewCallback = extern struct {
    pub const VTable = extern struct {
        base: IWMStatusCallback.VTable,
        OnPostViewSample: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMWriterPostViewCallback,
                wStreamNumber: u16,
                cnsSampleTime: u64,
                cnsSampleDuration: u64,
                dwFlags: u32,
                pSample: ?*INSSBuffer,
                pvContext: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMWriterPostViewCallback,
                wStreamNumber: u16,
                cnsSampleTime: u64,
                cnsSampleDuration: u64,
                dwFlags: u32,
                pSample: ?*INSSBuffer,
                pvContext: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AllocateForPostView: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMWriterPostViewCallback,
                wStreamNum: u16,
                cbBuffer: u32,
                ppBuffer: ?*?*INSSBuffer,
                pvContext: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMWriterPostViewCallback,
                wStreamNum: u16,
                cbBuffer: u32,
                ppBuffer: ?*?*INSSBuffer,
                pvContext: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWMStatusCallback.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMWriterPostViewCallback_OnPostViewSample(self: *const T, wStreamNumber: u16, cnsSampleTime: u64, cnsSampleDuration: u64, dwFlags: u32, pSample: ?*INSSBuffer, pvContext: ?*anyopaque) HRESULT {
                return @as(*const IWMWriterPostViewCallback.VTable, @ptrCast(self.vtable)).OnPostViewSample(@as(*const IWMWriterPostViewCallback, @ptrCast(self)), wStreamNumber, cnsSampleTime, cnsSampleDuration, dwFlags, pSample, pvContext);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMWriterPostViewCallback_AllocateForPostView(self: *const T, wStreamNum: u16, cbBuffer: u32, ppBuffer: ?*?*INSSBuffer, pvContext: ?*anyopaque) HRESULT {
                return @as(*const IWMWriterPostViewCallback.VTable, @ptrCast(self.vtable)).AllocateForPostView(@as(*const IWMWriterPostViewCallback, @ptrCast(self)), wStreamNum, cbBuffer, ppBuffer, pvContext);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMWriterPostView_Value = Guid.initString("81e20ce4-75ef-491a-8004-fc53c45bdc3e");
pub const IID_IWMWriterPostView = &IID_IWMWriterPostView_Value;
pub const IWMWriterPostView = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetPostViewCallback: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMWriterPostView,
                pCallback: ?*IWMWriterPostViewCallback,
                pvContext: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMWriterPostView,
                pCallback: ?*IWMWriterPostViewCallback,
                pvContext: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetReceivePostViewSamples: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMWriterPostView,
                wStreamNum: u16,
                fReceivePostViewSamples: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMWriterPostView,
                wStreamNum: u16,
                fReceivePostViewSamples: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetReceivePostViewSamples: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMWriterPostView,
                wStreamNum: u16,
                pfReceivePostViewSamples: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMWriterPostView,
                wStreamNum: u16,
                pfReceivePostViewSamples: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPostViewProps: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMWriterPostView,
                wStreamNumber: u16,
                ppOutput: ?*?*IWMMediaProps,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMWriterPostView,
                wStreamNumber: u16,
                ppOutput: ?*?*IWMMediaProps,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPostViewProps: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMWriterPostView,
                wStreamNumber: u16,
                pOutput: ?*IWMMediaProps,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMWriterPostView,
                wStreamNumber: u16,
                pOutput: ?*IWMMediaProps,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPostViewFormatCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMWriterPostView,
                wStreamNumber: u16,
                pcFormats: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMWriterPostView,
                wStreamNumber: u16,
                pcFormats: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPostViewFormat: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMWriterPostView,
                wStreamNumber: u16,
                dwFormatNumber: u32,
                ppProps: ?*?*IWMMediaProps,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMWriterPostView,
                wStreamNumber: u16,
                dwFormatNumber: u32,
                ppProps: ?*?*IWMMediaProps,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetAllocateForPostView: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMWriterPostView,
                wStreamNumber: u16,
                fAllocate: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMWriterPostView,
                wStreamNumber: u16,
                fAllocate: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAllocateForPostView: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMWriterPostView,
                wStreamNumber: u16,
                pfAllocate: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMWriterPostView,
                wStreamNumber: u16,
                pfAllocate: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMWriterPostView_SetPostViewCallback(self: *const T, pCallback: ?*IWMWriterPostViewCallback, pvContext: ?*anyopaque) HRESULT {
                return @as(*const IWMWriterPostView.VTable, @ptrCast(self.vtable)).SetPostViewCallback(@as(*const IWMWriterPostView, @ptrCast(self)), pCallback, pvContext);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMWriterPostView_SetReceivePostViewSamples(self: *const T, wStreamNum: u16, fReceivePostViewSamples: BOOL) HRESULT {
                return @as(*const IWMWriterPostView.VTable, @ptrCast(self.vtable)).SetReceivePostViewSamples(@as(*const IWMWriterPostView, @ptrCast(self)), wStreamNum, fReceivePostViewSamples);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMWriterPostView_GetReceivePostViewSamples(self: *const T, wStreamNum: u16, pfReceivePostViewSamples: ?*BOOL) HRESULT {
                return @as(*const IWMWriterPostView.VTable, @ptrCast(self.vtable)).GetReceivePostViewSamples(@as(*const IWMWriterPostView, @ptrCast(self)), wStreamNum, pfReceivePostViewSamples);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMWriterPostView_GetPostViewProps(self: *const T, wStreamNumber: u16, ppOutput: ?*?*IWMMediaProps) HRESULT {
                return @as(*const IWMWriterPostView.VTable, @ptrCast(self.vtable)).GetPostViewProps(@as(*const IWMWriterPostView, @ptrCast(self)), wStreamNumber, ppOutput);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMWriterPostView_SetPostViewProps(self: *const T, wStreamNumber: u16, pOutput: ?*IWMMediaProps) HRESULT {
                return @as(*const IWMWriterPostView.VTable, @ptrCast(self.vtable)).SetPostViewProps(@as(*const IWMWriterPostView, @ptrCast(self)), wStreamNumber, pOutput);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMWriterPostView_GetPostViewFormatCount(self: *const T, wStreamNumber: u16, pcFormats: ?*u32) HRESULT {
                return @as(*const IWMWriterPostView.VTable, @ptrCast(self.vtable)).GetPostViewFormatCount(@as(*const IWMWriterPostView, @ptrCast(self)), wStreamNumber, pcFormats);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMWriterPostView_GetPostViewFormat(self: *const T, wStreamNumber: u16, dwFormatNumber: u32, ppProps: ?*?*IWMMediaProps) HRESULT {
                return @as(*const IWMWriterPostView.VTable, @ptrCast(self.vtable)).GetPostViewFormat(@as(*const IWMWriterPostView, @ptrCast(self)), wStreamNumber, dwFormatNumber, ppProps);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMWriterPostView_SetAllocateForPostView(self: *const T, wStreamNumber: u16, fAllocate: BOOL) HRESULT {
                return @as(*const IWMWriterPostView.VTable, @ptrCast(self.vtable)).SetAllocateForPostView(@as(*const IWMWriterPostView, @ptrCast(self)), wStreamNumber, fAllocate);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMWriterPostView_GetAllocateForPostView(self: *const T, wStreamNumber: u16, pfAllocate: ?*BOOL) HRESULT {
                return @as(*const IWMWriterPostView.VTable, @ptrCast(self.vtable)).GetAllocateForPostView(@as(*const IWMWriterPostView, @ptrCast(self)), wStreamNumber, pfAllocate);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMWriterSink_Value = Guid.initString("96406be4-2b2b-11d3-b36b-00c04f6108ff");
pub const IID_IWMWriterSink = &IID_IWMWriterSink_Value;
pub const IWMWriterSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnHeader: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMWriterSink,
                pHeader: ?*INSSBuffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMWriterSink,
                pHeader: ?*INSSBuffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsRealTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMWriterSink,
                pfRealTime: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMWriterSink,
                pfRealTime: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AllocateDataUnit: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMWriterSink,
                cbDataUnit: u32,
                ppDataUnit: ?*?*INSSBuffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMWriterSink,
                cbDataUnit: u32,
                ppDataUnit: ?*?*INSSBuffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnDataUnit: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMWriterSink,
                pDataUnit: ?*INSSBuffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMWriterSink,
                pDataUnit: ?*INSSBuffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnEndWriting: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMWriterSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMWriterSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMWriterSink_OnHeader(self: *const T, pHeader: ?*INSSBuffer) HRESULT {
                return @as(*const IWMWriterSink.VTable, @ptrCast(self.vtable)).OnHeader(@as(*const IWMWriterSink, @ptrCast(self)), pHeader);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMWriterSink_IsRealTime(self: *const T, pfRealTime: ?*BOOL) HRESULT {
                return @as(*const IWMWriterSink.VTable, @ptrCast(self.vtable)).IsRealTime(@as(*const IWMWriterSink, @ptrCast(self)), pfRealTime);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMWriterSink_AllocateDataUnit(self: *const T, cbDataUnit: u32, ppDataUnit: ?*?*INSSBuffer) HRESULT {
                return @as(*const IWMWriterSink.VTable, @ptrCast(self.vtable)).AllocateDataUnit(@as(*const IWMWriterSink, @ptrCast(self)), cbDataUnit, ppDataUnit);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMWriterSink_OnDataUnit(self: *const T, pDataUnit: ?*INSSBuffer) HRESULT {
                return @as(*const IWMWriterSink.VTable, @ptrCast(self.vtable)).OnDataUnit(@as(*const IWMWriterSink, @ptrCast(self)), pDataUnit);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMWriterSink_OnEndWriting(self: *const T) HRESULT {
                return @as(*const IWMWriterSink.VTable, @ptrCast(self.vtable)).OnEndWriting(@as(*const IWMWriterSink, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMRegisterCallback_Value = Guid.initString("cf4b1f99-4de2-4e49-a363-252740d99bc1");
pub const IID_IWMRegisterCallback = &IID_IWMRegisterCallback_Value;
pub const IWMRegisterCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Advise: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMRegisterCallback,
                pCallback: ?*IWMStatusCallback,
                pvContext: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMRegisterCallback,
                pCallback: ?*IWMStatusCallback,
                pvContext: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Unadvise: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMRegisterCallback,
                pCallback: ?*IWMStatusCallback,
                pvContext: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMRegisterCallback,
                pCallback: ?*IWMStatusCallback,
                pvContext: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMRegisterCallback_Advise(self: *const T, pCallback: ?*IWMStatusCallback, pvContext: ?*anyopaque) HRESULT {
                return @as(*const IWMRegisterCallback.VTable, @ptrCast(self.vtable)).Advise(@as(*const IWMRegisterCallback, @ptrCast(self)), pCallback, pvContext);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMRegisterCallback_Unadvise(self: *const T, pCallback: ?*IWMStatusCallback, pvContext: ?*anyopaque) HRESULT {
                return @as(*const IWMRegisterCallback.VTable, @ptrCast(self.vtable)).Unadvise(@as(*const IWMRegisterCallback, @ptrCast(self)), pCallback, pvContext);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMWriterFileSink_Value = Guid.initString("96406be5-2b2b-11d3-b36b-00c04f6108ff");
pub const IID_IWMWriterFileSink = &IID_IWMWriterFileSink_Value;
pub const IWMWriterFileSink = extern struct {
    pub const VTable = extern struct {
        base: IWMWriterSink.VTable,
        Open: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMWriterFileSink,
                pwszFilename: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMWriterFileSink,
                pwszFilename: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWMWriterSink.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMWriterFileSink_Open(self: *const T, pwszFilename: ?[*:0]const u16) HRESULT {
                return @as(*const IWMWriterFileSink.VTable, @ptrCast(self.vtable)).Open(@as(*const IWMWriterFileSink, @ptrCast(self)), pwszFilename);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMWriterFileSink2_Value = Guid.initString("14282ba7-4aef-4205-8ce5-c229035a05bc");
pub const IID_IWMWriterFileSink2 = &IID_IWMWriterFileSink2_Value;
pub const IWMWriterFileSink2 = extern struct {
    pub const VTable = extern struct {
        base: IWMWriterFileSink.VTable,
        Start: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMWriterFileSink2,
                cnsStartTime: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMWriterFileSink2,
                cnsStartTime: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Stop: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMWriterFileSink2,
                cnsStopTime: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMWriterFileSink2,
                cnsStopTime: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsStopped: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMWriterFileSink2,
                pfStopped: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMWriterFileSink2,
                pfStopped: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFileDuration: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMWriterFileSink2,
                pcnsDuration: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMWriterFileSink2,
                pcnsDuration: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFileSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMWriterFileSink2,
                pcbFile: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMWriterFileSink2,
                pcbFile: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Close: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMWriterFileSink2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMWriterFileSink2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsClosed: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMWriterFileSink2,
                pfClosed: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMWriterFileSink2,
                pfClosed: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWMWriterFileSink.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMWriterFileSink2_Start(self: *const T, cnsStartTime: u64) HRESULT {
                return @as(*const IWMWriterFileSink2.VTable, @ptrCast(self.vtable)).Start(@as(*const IWMWriterFileSink2, @ptrCast(self)), cnsStartTime);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMWriterFileSink2_Stop(self: *const T, cnsStopTime: u64) HRESULT {
                return @as(*const IWMWriterFileSink2.VTable, @ptrCast(self.vtable)).Stop(@as(*const IWMWriterFileSink2, @ptrCast(self)), cnsStopTime);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMWriterFileSink2_IsStopped(self: *const T, pfStopped: ?*BOOL) HRESULT {
                return @as(*const IWMWriterFileSink2.VTable, @ptrCast(self.vtable)).IsStopped(@as(*const IWMWriterFileSink2, @ptrCast(self)), pfStopped);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMWriterFileSink2_GetFileDuration(self: *const T, pcnsDuration: ?*u64) HRESULT {
                return @as(*const IWMWriterFileSink2.VTable, @ptrCast(self.vtable)).GetFileDuration(@as(*const IWMWriterFileSink2, @ptrCast(self)), pcnsDuration);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMWriterFileSink2_GetFileSize(self: *const T, pcbFile: ?*u64) HRESULT {
                return @as(*const IWMWriterFileSink2.VTable, @ptrCast(self.vtable)).GetFileSize(@as(*const IWMWriterFileSink2, @ptrCast(self)), pcbFile);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMWriterFileSink2_Close(self: *const T) HRESULT {
                return @as(*const IWMWriterFileSink2.VTable, @ptrCast(self.vtable)).Close(@as(*const IWMWriterFileSink2, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMWriterFileSink2_IsClosed(self: *const T, pfClosed: ?*BOOL) HRESULT {
                return @as(*const IWMWriterFileSink2.VTable, @ptrCast(self.vtable)).IsClosed(@as(*const IWMWriterFileSink2, @ptrCast(self)), pfClosed);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMWriterFileSink3_Value = Guid.initString("3fea4feb-2945-47a7-a1dd-c53a8fc4c45c");
pub const IID_IWMWriterFileSink3 = &IID_IWMWriterFileSink3_Value;
pub const IWMWriterFileSink3 = extern struct {
    pub const VTable = extern struct {
        base: IWMWriterFileSink2.VTable,
        SetAutoIndexing: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMWriterFileSink3,
                fDoAutoIndexing: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMWriterFileSink3,
                fDoAutoIndexing: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAutoIndexing: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMWriterFileSink3,
                pfAutoIndexing: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMWriterFileSink3,
                pfAutoIndexing: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetControlStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMWriterFileSink3,
                wStreamNumber: u16,
                fShouldControlStartAndStop: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMWriterFileSink3,
                wStreamNumber: u16,
                fShouldControlStartAndStop: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMWriterFileSink3,
                pdwFileSinkMode: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMWriterFileSink3,
                pdwFileSinkMode: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnDataUnitEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMWriterFileSink3,
                pFileSinkDataUnit: ?*WMT_FILESINK_DATA_UNIT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMWriterFileSink3,
                pFileSinkDataUnit: ?*WMT_FILESINK_DATA_UNIT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetUnbufferedIO: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMWriterFileSink3,
                fUnbufferedIO: BOOL,
                fRestrictMemUsage: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMWriterFileSink3,
                fUnbufferedIO: BOOL,
                fRestrictMemUsage: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetUnbufferedIO: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMWriterFileSink3,
                pfUnbufferedIO: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMWriterFileSink3,
                pfUnbufferedIO: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CompleteOperations: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMWriterFileSink3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMWriterFileSink3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWMWriterFileSink2.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMWriterFileSink3_SetAutoIndexing(self: *const T, fDoAutoIndexing: BOOL) HRESULT {
                return @as(*const IWMWriterFileSink3.VTable, @ptrCast(self.vtable)).SetAutoIndexing(@as(*const IWMWriterFileSink3, @ptrCast(self)), fDoAutoIndexing);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMWriterFileSink3_GetAutoIndexing(self: *const T, pfAutoIndexing: ?*BOOL) HRESULT {
                return @as(*const IWMWriterFileSink3.VTable, @ptrCast(self.vtable)).GetAutoIndexing(@as(*const IWMWriterFileSink3, @ptrCast(self)), pfAutoIndexing);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMWriterFileSink3_SetControlStream(self: *const T, wStreamNumber: u16, fShouldControlStartAndStop: BOOL) HRESULT {
                return @as(*const IWMWriterFileSink3.VTable, @ptrCast(self.vtable)).SetControlStream(@as(*const IWMWriterFileSink3, @ptrCast(self)), wStreamNumber, fShouldControlStartAndStop);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMWriterFileSink3_GetMode(self: *const T, pdwFileSinkMode: ?*u32) HRESULT {
                return @as(*const IWMWriterFileSink3.VTable, @ptrCast(self.vtable)).GetMode(@as(*const IWMWriterFileSink3, @ptrCast(self)), pdwFileSinkMode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMWriterFileSink3_OnDataUnitEx(self: *const T, pFileSinkDataUnit: ?*WMT_FILESINK_DATA_UNIT) HRESULT {
                return @as(*const IWMWriterFileSink3.VTable, @ptrCast(self.vtable)).OnDataUnitEx(@as(*const IWMWriterFileSink3, @ptrCast(self)), pFileSinkDataUnit);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMWriterFileSink3_SetUnbufferedIO(self: *const T, fUnbufferedIO: BOOL, fRestrictMemUsage: BOOL) HRESULT {
                return @as(*const IWMWriterFileSink3.VTable, @ptrCast(self.vtable)).SetUnbufferedIO(@as(*const IWMWriterFileSink3, @ptrCast(self)), fUnbufferedIO, fRestrictMemUsage);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMWriterFileSink3_GetUnbufferedIO(self: *const T, pfUnbufferedIO: ?*BOOL) HRESULT {
                return @as(*const IWMWriterFileSink3.VTable, @ptrCast(self.vtable)).GetUnbufferedIO(@as(*const IWMWriterFileSink3, @ptrCast(self)), pfUnbufferedIO);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMWriterFileSink3_CompleteOperations(self: *const T) HRESULT {
                return @as(*const IWMWriterFileSink3.VTable, @ptrCast(self.vtable)).CompleteOperations(@as(*const IWMWriterFileSink3, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMWriterNetworkSink_Value = Guid.initString("96406be7-2b2b-11d3-b36b-00c04f6108ff");
pub const IID_IWMWriterNetworkSink = &IID_IWMWriterNetworkSink_Value;
pub const IWMWriterNetworkSink = extern struct {
    pub const VTable = extern struct {
        base: IWMWriterSink.VTable,
        SetMaximumClients: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMWriterNetworkSink,
                dwMaxClients: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMWriterNetworkSink,
                dwMaxClients: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMaximumClients: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMWriterNetworkSink,
                pdwMaxClients: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMWriterNetworkSink,
                pdwMaxClients: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetNetworkProtocol: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMWriterNetworkSink,
                protocol: WMT_NET_PROTOCOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMWriterNetworkSink,
                protocol: WMT_NET_PROTOCOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNetworkProtocol: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMWriterNetworkSink,
                pProtocol: ?*WMT_NET_PROTOCOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMWriterNetworkSink,
                pProtocol: ?*WMT_NET_PROTOCOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetHostURL: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMWriterNetworkSink,
                pwszURL: ?PWSTR,
                pcchURL: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMWriterNetworkSink,
                pwszURL: ?PWSTR,
                pcchURL: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Open: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMWriterNetworkSink,
                pdwPortNum: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMWriterNetworkSink,
                pdwPortNum: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Disconnect: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMWriterNetworkSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMWriterNetworkSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Close: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMWriterNetworkSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMWriterNetworkSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWMWriterSink.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMWriterNetworkSink_SetMaximumClients(self: *const T, dwMaxClients: u32) HRESULT {
                return @as(*const IWMWriterNetworkSink.VTable, @ptrCast(self.vtable)).SetMaximumClients(@as(*const IWMWriterNetworkSink, @ptrCast(self)), dwMaxClients);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMWriterNetworkSink_GetMaximumClients(self: *const T, pdwMaxClients: ?*u32) HRESULT {
                return @as(*const IWMWriterNetworkSink.VTable, @ptrCast(self.vtable)).GetMaximumClients(@as(*const IWMWriterNetworkSink, @ptrCast(self)), pdwMaxClients);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMWriterNetworkSink_SetNetworkProtocol(self: *const T, protocol: WMT_NET_PROTOCOL) HRESULT {
                return @as(*const IWMWriterNetworkSink.VTable, @ptrCast(self.vtable)).SetNetworkProtocol(@as(*const IWMWriterNetworkSink, @ptrCast(self)), protocol);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMWriterNetworkSink_GetNetworkProtocol(self: *const T, pProtocol: ?*WMT_NET_PROTOCOL) HRESULT {
                return @as(*const IWMWriterNetworkSink.VTable, @ptrCast(self.vtable)).GetNetworkProtocol(@as(*const IWMWriterNetworkSink, @ptrCast(self)), pProtocol);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMWriterNetworkSink_GetHostURL(self: *const T, pwszURL: ?PWSTR, pcchURL: ?*u32) HRESULT {
                return @as(*const IWMWriterNetworkSink.VTable, @ptrCast(self.vtable)).GetHostURL(@as(*const IWMWriterNetworkSink, @ptrCast(self)), pwszURL, pcchURL);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMWriterNetworkSink_Open(self: *const T, pdwPortNum: ?*u32) HRESULT {
                return @as(*const IWMWriterNetworkSink.VTable, @ptrCast(self.vtable)).Open(@as(*const IWMWriterNetworkSink, @ptrCast(self)), pdwPortNum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMWriterNetworkSink_Disconnect(self: *const T) HRESULT {
                return @as(*const IWMWriterNetworkSink.VTable, @ptrCast(self.vtable)).Disconnect(@as(*const IWMWriterNetworkSink, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMWriterNetworkSink_Close(self: *const T) HRESULT {
                return @as(*const IWMWriterNetworkSink.VTable, @ptrCast(self.vtable)).Close(@as(*const IWMWriterNetworkSink, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMClientConnections_Value = Guid.initString("73c66010-a299-41df-b1f0-ccf03b09c1c6");
pub const IID_IWMClientConnections = &IID_IWMClientConnections_Value;
pub const IWMClientConnections = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetClientCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMClientConnections,
                pcClients: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMClientConnections,
                pcClients: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetClientProperties: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMClientConnections,
                dwClientNum: u32,
                pClientProperties: ?*WM_CLIENT_PROPERTIES,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMClientConnections,
                dwClientNum: u32,
                pClientProperties: ?*WM_CLIENT_PROPERTIES,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMClientConnections_GetClientCount(self: *const T, pcClients: ?*u32) HRESULT {
                return @as(*const IWMClientConnections.VTable, @ptrCast(self.vtable)).GetClientCount(@as(*const IWMClientConnections, @ptrCast(self)), pcClients);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMClientConnections_GetClientProperties(self: *const T, dwClientNum: u32, pClientProperties: ?*WM_CLIENT_PROPERTIES) HRESULT {
                return @as(*const IWMClientConnections.VTable, @ptrCast(self.vtable)).GetClientProperties(@as(*const IWMClientConnections, @ptrCast(self)), dwClientNum, pClientProperties);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMClientConnections2_Value = Guid.initString("4091571e-4701-4593-bb3d-d5f5f0c74246");
pub const IID_IWMClientConnections2 = &IID_IWMClientConnections2_Value;
pub const IWMClientConnections2 = extern struct {
    pub const VTable = extern struct {
        base: IWMClientConnections.VTable,
        GetClientInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMClientConnections2,
                dwClientNum: u32,
                pwszNetworkAddress: [*:0]u16,
                pcchNetworkAddress: ?*u32,
                pwszPort: [*:0]u16,
                pcchPort: ?*u32,
                pwszDNSName: [*:0]u16,
                pcchDNSName: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMClientConnections2,
                dwClientNum: u32,
                pwszNetworkAddress: [*:0]u16,
                pcchNetworkAddress: ?*u32,
                pwszPort: [*:0]u16,
                pcchPort: ?*u32,
                pwszDNSName: [*:0]u16,
                pcchDNSName: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWMClientConnections.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMClientConnections2_GetClientInfo(self: *const T, dwClientNum: u32, pwszNetworkAddress: [*:0]u16, pcchNetworkAddress: ?*u32, pwszPort: [*:0]u16, pcchPort: ?*u32, pwszDNSName: [*:0]u16, pcchDNSName: ?*u32) HRESULT {
                return @as(*const IWMClientConnections2.VTable, @ptrCast(self.vtable)).GetClientInfo(@as(*const IWMClientConnections2, @ptrCast(self)), dwClientNum, pwszNetworkAddress, pcchNetworkAddress, pwszPort, pcchPort, pwszDNSName, pcchDNSName);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMReaderAdvanced_Value = Guid.initString("96406bea-2b2b-11d3-b36b-00c04f6108ff");
pub const IID_IWMReaderAdvanced = &IID_IWMReaderAdvanced_Value;
pub const IWMReaderAdvanced = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetUserProvidedClock: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderAdvanced,
                fUserClock: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderAdvanced,
                fUserClock: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetUserProvidedClock: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderAdvanced,
                pfUserClock: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderAdvanced,
                pfUserClock: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeliverTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderAdvanced,
                cnsTime: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderAdvanced,
                cnsTime: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetManualStreamSelection: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderAdvanced,
                fSelection: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderAdvanced,
                fSelection: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetManualStreamSelection: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderAdvanced,
                pfSelection: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderAdvanced,
                pfSelection: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetStreamsSelected: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderAdvanced,
                cStreamCount: u16,
                pwStreamNumbers: ?*u16,
                pSelections: ?*WMT_STREAM_SELECTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderAdvanced,
                cStreamCount: u16,
                pwStreamNumbers: ?*u16,
                pSelections: ?*WMT_STREAM_SELECTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStreamSelected: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderAdvanced,
                wStreamNum: u16,
                pSelection: ?*WMT_STREAM_SELECTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderAdvanced,
                wStreamNum: u16,
                pSelection: ?*WMT_STREAM_SELECTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetReceiveSelectionCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderAdvanced,
                fGetCallbacks: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderAdvanced,
                fGetCallbacks: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetReceiveSelectionCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderAdvanced,
                pfGetCallbacks: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderAdvanced,
                pfGetCallbacks: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetReceiveStreamSamples: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderAdvanced,
                wStreamNum: u16,
                fReceiveStreamSamples: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderAdvanced,
                wStreamNum: u16,
                fReceiveStreamSamples: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetReceiveStreamSamples: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderAdvanced,
                wStreamNum: u16,
                pfReceiveStreamSamples: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderAdvanced,
                wStreamNum: u16,
                pfReceiveStreamSamples: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetAllocateForOutput: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderAdvanced,
                dwOutputNum: u32,
                fAllocate: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderAdvanced,
                dwOutputNum: u32,
                fAllocate: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAllocateForOutput: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderAdvanced,
                dwOutputNum: u32,
                pfAllocate: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderAdvanced,
                dwOutputNum: u32,
                pfAllocate: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetAllocateForStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderAdvanced,
                wStreamNum: u16,
                fAllocate: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderAdvanced,
                wStreamNum: u16,
                fAllocate: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAllocateForStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderAdvanced,
                dwSreamNum: u16,
                pfAllocate: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderAdvanced,
                dwSreamNum: u16,
                pfAllocate: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStatistics: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderAdvanced,
                pStatistics: ?*WM_READER_STATISTICS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderAdvanced,
                pStatistics: ?*WM_READER_STATISTICS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetClientInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderAdvanced,
                pClientInfo: ?*WM_READER_CLIENTINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderAdvanced,
                pClientInfo: ?*WM_READER_CLIENTINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMaxOutputSampleSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderAdvanced,
                dwOutput: u32,
                pcbMax: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderAdvanced,
                dwOutput: u32,
                pcbMax: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMaxStreamSampleSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderAdvanced,
                wStream: u16,
                pcbMax: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderAdvanced,
                wStream: u16,
                pcbMax: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NotifyLateDelivery: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderAdvanced,
                cnsLateness: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderAdvanced,
                cnsLateness: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderAdvanced_SetUserProvidedClock(self: *const T, fUserClock: BOOL) HRESULT {
                return @as(*const IWMReaderAdvanced.VTable, @ptrCast(self.vtable)).SetUserProvidedClock(@as(*const IWMReaderAdvanced, @ptrCast(self)), fUserClock);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderAdvanced_GetUserProvidedClock(self: *const T, pfUserClock: ?*BOOL) HRESULT {
                return @as(*const IWMReaderAdvanced.VTable, @ptrCast(self.vtable)).GetUserProvidedClock(@as(*const IWMReaderAdvanced, @ptrCast(self)), pfUserClock);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderAdvanced_DeliverTime(self: *const T, cnsTime: u64) HRESULT {
                return @as(*const IWMReaderAdvanced.VTable, @ptrCast(self.vtable)).DeliverTime(@as(*const IWMReaderAdvanced, @ptrCast(self)), cnsTime);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderAdvanced_SetManualStreamSelection(self: *const T, fSelection: BOOL) HRESULT {
                return @as(*const IWMReaderAdvanced.VTable, @ptrCast(self.vtable)).SetManualStreamSelection(@as(*const IWMReaderAdvanced, @ptrCast(self)), fSelection);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderAdvanced_GetManualStreamSelection(self: *const T, pfSelection: ?*BOOL) HRESULT {
                return @as(*const IWMReaderAdvanced.VTable, @ptrCast(self.vtable)).GetManualStreamSelection(@as(*const IWMReaderAdvanced, @ptrCast(self)), pfSelection);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderAdvanced_SetStreamsSelected(self: *const T, cStreamCount: u16, pwStreamNumbers: ?*u16, pSelections: ?*WMT_STREAM_SELECTION) HRESULT {
                return @as(*const IWMReaderAdvanced.VTable, @ptrCast(self.vtable)).SetStreamsSelected(@as(*const IWMReaderAdvanced, @ptrCast(self)), cStreamCount, pwStreamNumbers, pSelections);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderAdvanced_GetStreamSelected(self: *const T, wStreamNum: u16, pSelection: ?*WMT_STREAM_SELECTION) HRESULT {
                return @as(*const IWMReaderAdvanced.VTable, @ptrCast(self.vtable)).GetStreamSelected(@as(*const IWMReaderAdvanced, @ptrCast(self)), wStreamNum, pSelection);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderAdvanced_SetReceiveSelectionCallbacks(self: *const T, fGetCallbacks: BOOL) HRESULT {
                return @as(*const IWMReaderAdvanced.VTable, @ptrCast(self.vtable)).SetReceiveSelectionCallbacks(@as(*const IWMReaderAdvanced, @ptrCast(self)), fGetCallbacks);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderAdvanced_GetReceiveSelectionCallbacks(self: *const T, pfGetCallbacks: ?*BOOL) HRESULT {
                return @as(*const IWMReaderAdvanced.VTable, @ptrCast(self.vtable)).GetReceiveSelectionCallbacks(@as(*const IWMReaderAdvanced, @ptrCast(self)), pfGetCallbacks);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderAdvanced_SetReceiveStreamSamples(self: *const T, wStreamNum: u16, fReceiveStreamSamples: BOOL) HRESULT {
                return @as(*const IWMReaderAdvanced.VTable, @ptrCast(self.vtable)).SetReceiveStreamSamples(@as(*const IWMReaderAdvanced, @ptrCast(self)), wStreamNum, fReceiveStreamSamples);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderAdvanced_GetReceiveStreamSamples(self: *const T, wStreamNum: u16, pfReceiveStreamSamples: ?*BOOL) HRESULT {
                return @as(*const IWMReaderAdvanced.VTable, @ptrCast(self.vtable)).GetReceiveStreamSamples(@as(*const IWMReaderAdvanced, @ptrCast(self)), wStreamNum, pfReceiveStreamSamples);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderAdvanced_SetAllocateForOutput(self: *const T, dwOutputNum: u32, fAllocate: BOOL) HRESULT {
                return @as(*const IWMReaderAdvanced.VTable, @ptrCast(self.vtable)).SetAllocateForOutput(@as(*const IWMReaderAdvanced, @ptrCast(self)), dwOutputNum, fAllocate);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderAdvanced_GetAllocateForOutput(self: *const T, dwOutputNum: u32, pfAllocate: ?*BOOL) HRESULT {
                return @as(*const IWMReaderAdvanced.VTable, @ptrCast(self.vtable)).GetAllocateForOutput(@as(*const IWMReaderAdvanced, @ptrCast(self)), dwOutputNum, pfAllocate);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderAdvanced_SetAllocateForStream(self: *const T, wStreamNum: u16, fAllocate: BOOL) HRESULT {
                return @as(*const IWMReaderAdvanced.VTable, @ptrCast(self.vtable)).SetAllocateForStream(@as(*const IWMReaderAdvanced, @ptrCast(self)), wStreamNum, fAllocate);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderAdvanced_GetAllocateForStream(self: *const T, dwSreamNum: u16, pfAllocate: ?*BOOL) HRESULT {
                return @as(*const IWMReaderAdvanced.VTable, @ptrCast(self.vtable)).GetAllocateForStream(@as(*const IWMReaderAdvanced, @ptrCast(self)), dwSreamNum, pfAllocate);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderAdvanced_GetStatistics(self: *const T, pStatistics: ?*WM_READER_STATISTICS) HRESULT {
                return @as(*const IWMReaderAdvanced.VTable, @ptrCast(self.vtable)).GetStatistics(@as(*const IWMReaderAdvanced, @ptrCast(self)), pStatistics);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderAdvanced_SetClientInfo(self: *const T, pClientInfo: ?*WM_READER_CLIENTINFO) HRESULT {
                return @as(*const IWMReaderAdvanced.VTable, @ptrCast(self.vtable)).SetClientInfo(@as(*const IWMReaderAdvanced, @ptrCast(self)), pClientInfo);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderAdvanced_GetMaxOutputSampleSize(self: *const T, dwOutput: u32, pcbMax: ?*u32) HRESULT {
                return @as(*const IWMReaderAdvanced.VTable, @ptrCast(self.vtable)).GetMaxOutputSampleSize(@as(*const IWMReaderAdvanced, @ptrCast(self)), dwOutput, pcbMax);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderAdvanced_GetMaxStreamSampleSize(self: *const T, wStream: u16, pcbMax: ?*u32) HRESULT {
                return @as(*const IWMReaderAdvanced.VTable, @ptrCast(self.vtable)).GetMaxStreamSampleSize(@as(*const IWMReaderAdvanced, @ptrCast(self)), wStream, pcbMax);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderAdvanced_NotifyLateDelivery(self: *const T, cnsLateness: u64) HRESULT {
                return @as(*const IWMReaderAdvanced.VTable, @ptrCast(self.vtable)).NotifyLateDelivery(@as(*const IWMReaderAdvanced, @ptrCast(self)), cnsLateness);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMReaderAdvanced2_Value = Guid.initString("ae14a945-b90c-4d0d-9127-80d665f7d73e");
pub const IID_IWMReaderAdvanced2 = &IID_IWMReaderAdvanced2_Value;
pub const IWMReaderAdvanced2 = extern struct {
    pub const VTable = extern struct {
        base: IWMReaderAdvanced.VTable,
        SetPlayMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderAdvanced2,
                Mode: WMT_PLAY_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderAdvanced2,
                Mode: WMT_PLAY_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPlayMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderAdvanced2,
                pMode: ?*WMT_PLAY_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderAdvanced2,
                pMode: ?*WMT_PLAY_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBufferProgress: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderAdvanced2,
                pdwPercent: ?*u32,
                pcnsBuffering: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderAdvanced2,
                pdwPercent: ?*u32,
                pcnsBuffering: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDownloadProgress: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderAdvanced2,
                pdwPercent: ?*u32,
                pqwBytesDownloaded: ?*u64,
                pcnsDownload: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderAdvanced2,
                pdwPercent: ?*u32,
                pqwBytesDownloaded: ?*u64,
                pcnsDownload: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSaveAsProgress: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderAdvanced2,
                pdwPercent: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderAdvanced2,
                pdwPercent: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SaveFileAs: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderAdvanced2,
                pwszFilename: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderAdvanced2,
                pwszFilename: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProtocolName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderAdvanced2,
                pwszProtocol: [*:0]u16,
                pcchProtocol: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderAdvanced2,
                pwszProtocol: [*:0]u16,
                pcchProtocol: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartAtMarker: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderAdvanced2,
                wMarkerIndex: u16,
                cnsDuration: u64,
                fRate: f32,
                pvContext: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderAdvanced2,
                wMarkerIndex: u16,
                cnsDuration: u64,
                fRate: f32,
                pvContext: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputSetting: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderAdvanced2,
                dwOutputNum: u32,
                pszName: ?[*:0]const u16,
                pType: ?*WMT_ATTR_DATATYPE,
                pValue: [*:0]u8,
                pcbLength: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderAdvanced2,
                dwOutputNum: u32,
                pszName: ?[*:0]const u16,
                pType: ?*WMT_ATTR_DATATYPE,
                pValue: [*:0]u8,
                pcbLength: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputSetting: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderAdvanced2,
                dwOutputNum: u32,
                pszName: ?[*:0]const u16,
                Type: WMT_ATTR_DATATYPE,
                pValue: [*:0]const u8,
                cbLength: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderAdvanced2,
                dwOutputNum: u32,
                pszName: ?[*:0]const u16,
                Type: WMT_ATTR_DATATYPE,
                pValue: [*:0]const u8,
                cbLength: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Preroll: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderAdvanced2,
                cnsStart: u64,
                cnsDuration: u64,
                fRate: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderAdvanced2,
                cnsStart: u64,
                cnsDuration: u64,
                fRate: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetLogClientID: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderAdvanced2,
                fLogClientID: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderAdvanced2,
                fLogClientID: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLogClientID: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderAdvanced2,
                pfLogClientID: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderAdvanced2,
                pfLogClientID: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StopBuffering: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderAdvanced2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderAdvanced2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderAdvanced2,
                pStream: ?*IStream,
                pCallback: ?*IWMReaderCallback,
                pvContext: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderAdvanced2,
                pStream: ?*IStream,
                pCallback: ?*IWMReaderCallback,
                pvContext: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWMReaderAdvanced.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderAdvanced2_SetPlayMode(self: *const T, Mode: WMT_PLAY_MODE) HRESULT {
                return @as(*const IWMReaderAdvanced2.VTable, @ptrCast(self.vtable)).SetPlayMode(@as(*const IWMReaderAdvanced2, @ptrCast(self)), Mode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderAdvanced2_GetPlayMode(self: *const T, pMode: ?*WMT_PLAY_MODE) HRESULT {
                return @as(*const IWMReaderAdvanced2.VTable, @ptrCast(self.vtable)).GetPlayMode(@as(*const IWMReaderAdvanced2, @ptrCast(self)), pMode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderAdvanced2_GetBufferProgress(self: *const T, pdwPercent: ?*u32, pcnsBuffering: ?*u64) HRESULT {
                return @as(*const IWMReaderAdvanced2.VTable, @ptrCast(self.vtable)).GetBufferProgress(@as(*const IWMReaderAdvanced2, @ptrCast(self)), pdwPercent, pcnsBuffering);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderAdvanced2_GetDownloadProgress(self: *const T, pdwPercent: ?*u32, pqwBytesDownloaded: ?*u64, pcnsDownload: ?*u64) HRESULT {
                return @as(*const IWMReaderAdvanced2.VTable, @ptrCast(self.vtable)).GetDownloadProgress(@as(*const IWMReaderAdvanced2, @ptrCast(self)), pdwPercent, pqwBytesDownloaded, pcnsDownload);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderAdvanced2_GetSaveAsProgress(self: *const T, pdwPercent: ?*u32) HRESULT {
                return @as(*const IWMReaderAdvanced2.VTable, @ptrCast(self.vtable)).GetSaveAsProgress(@as(*const IWMReaderAdvanced2, @ptrCast(self)), pdwPercent);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderAdvanced2_SaveFileAs(self: *const T, pwszFilename: ?[*:0]const u16) HRESULT {
                return @as(*const IWMReaderAdvanced2.VTable, @ptrCast(self.vtable)).SaveFileAs(@as(*const IWMReaderAdvanced2, @ptrCast(self)), pwszFilename);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderAdvanced2_GetProtocolName(self: *const T, pwszProtocol: [*:0]u16, pcchProtocol: ?*u32) HRESULT {
                return @as(*const IWMReaderAdvanced2.VTable, @ptrCast(self.vtable)).GetProtocolName(@as(*const IWMReaderAdvanced2, @ptrCast(self)), pwszProtocol, pcchProtocol);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderAdvanced2_StartAtMarker(self: *const T, wMarkerIndex: u16, cnsDuration: u64, fRate: f32, pvContext: ?*anyopaque) HRESULT {
                return @as(*const IWMReaderAdvanced2.VTable, @ptrCast(self.vtable)).StartAtMarker(@as(*const IWMReaderAdvanced2, @ptrCast(self)), wMarkerIndex, cnsDuration, fRate, pvContext);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderAdvanced2_GetOutputSetting(self: *const T, dwOutputNum: u32, pszName: ?[*:0]const u16, pType: ?*WMT_ATTR_DATATYPE, pValue: [*:0]u8, pcbLength: ?*u16) HRESULT {
                return @as(*const IWMReaderAdvanced2.VTable, @ptrCast(self.vtable)).GetOutputSetting(@as(*const IWMReaderAdvanced2, @ptrCast(self)), dwOutputNum, pszName, pType, pValue, pcbLength);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderAdvanced2_SetOutputSetting(self: *const T, dwOutputNum: u32, pszName: ?[*:0]const u16, Type: WMT_ATTR_DATATYPE, pValue: [*:0]const u8, cbLength: u16) HRESULT {
                return @as(*const IWMReaderAdvanced2.VTable, @ptrCast(self.vtable)).SetOutputSetting(@as(*const IWMReaderAdvanced2, @ptrCast(self)), dwOutputNum, pszName, Type, pValue, cbLength);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderAdvanced2_Preroll(self: *const T, cnsStart: u64, cnsDuration: u64, fRate: f32) HRESULT {
                return @as(*const IWMReaderAdvanced2.VTable, @ptrCast(self.vtable)).Preroll(@as(*const IWMReaderAdvanced2, @ptrCast(self)), cnsStart, cnsDuration, fRate);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderAdvanced2_SetLogClientID(self: *const T, fLogClientID: BOOL) HRESULT {
                return @as(*const IWMReaderAdvanced2.VTable, @ptrCast(self.vtable)).SetLogClientID(@as(*const IWMReaderAdvanced2, @ptrCast(self)), fLogClientID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderAdvanced2_GetLogClientID(self: *const T, pfLogClientID: ?*BOOL) HRESULT {
                return @as(*const IWMReaderAdvanced2.VTable, @ptrCast(self.vtable)).GetLogClientID(@as(*const IWMReaderAdvanced2, @ptrCast(self)), pfLogClientID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderAdvanced2_StopBuffering(self: *const T) HRESULT {
                return @as(*const IWMReaderAdvanced2.VTable, @ptrCast(self.vtable)).StopBuffering(@as(*const IWMReaderAdvanced2, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderAdvanced2_OpenStream(self: *const T, pStream: ?*IStream, pCallback: ?*IWMReaderCallback, pvContext: ?*anyopaque) HRESULT {
                return @as(*const IWMReaderAdvanced2.VTable, @ptrCast(self.vtable)).OpenStream(@as(*const IWMReaderAdvanced2, @ptrCast(self)), pStream, pCallback, pvContext);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMReaderAdvanced3_Value = Guid.initString("5dc0674b-f04b-4a4e-9f2a-b1afde2c8100");
pub const IID_IWMReaderAdvanced3 = &IID_IWMReaderAdvanced3_Value;
pub const IWMReaderAdvanced3 = extern struct {
    pub const VTable = extern struct {
        base: IWMReaderAdvanced2.VTable,
        StopNetStreaming: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderAdvanced3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderAdvanced3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartAtPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderAdvanced3,
                wStreamNum: u16,
                pvOffsetStart: ?*anyopaque,
                pvDuration: ?*anyopaque,
                dwOffsetFormat: WMT_OFFSET_FORMAT,
                fRate: f32,
                pvContext: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderAdvanced3,
                wStreamNum: u16,
                pvOffsetStart: ?*anyopaque,
                pvDuration: ?*anyopaque,
                dwOffsetFormat: WMT_OFFSET_FORMAT,
                fRate: f32,
                pvContext: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWMReaderAdvanced2.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderAdvanced3_StopNetStreaming(self: *const T) HRESULT {
                return @as(*const IWMReaderAdvanced3.VTable, @ptrCast(self.vtable)).StopNetStreaming(@as(*const IWMReaderAdvanced3, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderAdvanced3_StartAtPosition(self: *const T, wStreamNum: u16, pvOffsetStart: ?*anyopaque, pvDuration: ?*anyopaque, dwOffsetFormat: WMT_OFFSET_FORMAT, fRate: f32, pvContext: ?*anyopaque) HRESULT {
                return @as(*const IWMReaderAdvanced3.VTable, @ptrCast(self.vtable)).StartAtPosition(@as(*const IWMReaderAdvanced3, @ptrCast(self)), wStreamNum, pvOffsetStart, pvDuration, dwOffsetFormat, fRate, pvContext);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMReaderAdvanced4_Value = Guid.initString("945a76a2-12ae-4d48-bd3c-cd1d90399b85");
pub const IID_IWMReaderAdvanced4 = &IID_IWMReaderAdvanced4_Value;
pub const IWMReaderAdvanced4 = extern struct {
    pub const VTable = extern struct {
        base: IWMReaderAdvanced3.VTable,
        GetLanguageCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderAdvanced4,
                dwOutputNum: u32,
                pwLanguageCount: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderAdvanced4,
                dwOutputNum: u32,
                pwLanguageCount: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLanguage: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderAdvanced4,
                dwOutputNum: u32,
                wLanguage: u16,
                pwszLanguageString: [*:0]u16,
                pcchLanguageStringLength: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderAdvanced4,
                dwOutputNum: u32,
                wLanguage: u16,
                pwszLanguageString: [*:0]u16,
                pcchLanguageStringLength: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMaxSpeedFactor: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderAdvanced4,
                pdblFactor: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderAdvanced4,
                pdblFactor: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsUsingFastCache: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderAdvanced4,
                pfUsingFastCache: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderAdvanced4,
                pfUsingFastCache: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddLogParam: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderAdvanced4,
                wszNameSpace: ?[*:0]const u16,
                wszName: ?[*:0]const u16,
                wszValue: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderAdvanced4,
                wszNameSpace: ?[*:0]const u16,
                wszName: ?[*:0]const u16,
                wszValue: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SendLogParams: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderAdvanced4,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderAdvanced4,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CanSaveFileAs: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderAdvanced4,
                pfCanSave: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderAdvanced4,
                pfCanSave: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CancelSaveFileAs: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderAdvanced4,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderAdvanced4,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetURL: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderAdvanced4,
                pwszURL: [*:0]u16,
                pcchURL: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderAdvanced4,
                pwszURL: [*:0]u16,
                pcchURL: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWMReaderAdvanced3.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderAdvanced4_GetLanguageCount(self: *const T, dwOutputNum: u32, pwLanguageCount: ?*u16) HRESULT {
                return @as(*const IWMReaderAdvanced4.VTable, @ptrCast(self.vtable)).GetLanguageCount(@as(*const IWMReaderAdvanced4, @ptrCast(self)), dwOutputNum, pwLanguageCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderAdvanced4_GetLanguage(self: *const T, dwOutputNum: u32, wLanguage: u16, pwszLanguageString: [*:0]u16, pcchLanguageStringLength: ?*u16) HRESULT {
                return @as(*const IWMReaderAdvanced4.VTable, @ptrCast(self.vtable)).GetLanguage(@as(*const IWMReaderAdvanced4, @ptrCast(self)), dwOutputNum, wLanguage, pwszLanguageString, pcchLanguageStringLength);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderAdvanced4_GetMaxSpeedFactor(self: *const T, pdblFactor: ?*f64) HRESULT {
                return @as(*const IWMReaderAdvanced4.VTable, @ptrCast(self.vtable)).GetMaxSpeedFactor(@as(*const IWMReaderAdvanced4, @ptrCast(self)), pdblFactor);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderAdvanced4_IsUsingFastCache(self: *const T, pfUsingFastCache: ?*BOOL) HRESULT {
                return @as(*const IWMReaderAdvanced4.VTable, @ptrCast(self.vtable)).IsUsingFastCache(@as(*const IWMReaderAdvanced4, @ptrCast(self)), pfUsingFastCache);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderAdvanced4_AddLogParam(self: *const T, wszNameSpace: ?[*:0]const u16, wszName: ?[*:0]const u16, wszValue: ?[*:0]const u16) HRESULT {
                return @as(*const IWMReaderAdvanced4.VTable, @ptrCast(self.vtable)).AddLogParam(@as(*const IWMReaderAdvanced4, @ptrCast(self)), wszNameSpace, wszName, wszValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderAdvanced4_SendLogParams(self: *const T) HRESULT {
                return @as(*const IWMReaderAdvanced4.VTable, @ptrCast(self.vtable)).SendLogParams(@as(*const IWMReaderAdvanced4, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderAdvanced4_CanSaveFileAs(self: *const T, pfCanSave: ?*BOOL) HRESULT {
                return @as(*const IWMReaderAdvanced4.VTable, @ptrCast(self.vtable)).CanSaveFileAs(@as(*const IWMReaderAdvanced4, @ptrCast(self)), pfCanSave);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderAdvanced4_CancelSaveFileAs(self: *const T) HRESULT {
                return @as(*const IWMReaderAdvanced4.VTable, @ptrCast(self.vtable)).CancelSaveFileAs(@as(*const IWMReaderAdvanced4, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderAdvanced4_GetURL(self: *const T, pwszURL: [*:0]u16, pcchURL: ?*u32) HRESULT {
                return @as(*const IWMReaderAdvanced4.VTable, @ptrCast(self.vtable)).GetURL(@as(*const IWMReaderAdvanced4, @ptrCast(self)), pwszURL, pcchURL);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMReaderAdvanced5_Value = Guid.initString("24c44db0-55d1-49ae-a5cc-f13815e36363");
pub const IID_IWMReaderAdvanced5 = &IID_IWMReaderAdvanced5_Value;
pub const IWMReaderAdvanced5 = extern struct {
    pub const VTable = extern struct {
        base: IWMReaderAdvanced4.VTable,
        SetPlayerHook: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderAdvanced5,
                dwOutputNum: u32,
                pHook: ?*IWMPlayerHook,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderAdvanced5,
                dwOutputNum: u32,
                pHook: ?*IWMPlayerHook,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWMReaderAdvanced4.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderAdvanced5_SetPlayerHook(self: *const T, dwOutputNum: u32, pHook: ?*IWMPlayerHook) HRESULT {
                return @as(*const IWMReaderAdvanced5.VTable, @ptrCast(self.vtable)).SetPlayerHook(@as(*const IWMReaderAdvanced5, @ptrCast(self)), dwOutputNum, pHook);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMReaderAdvanced6_Value = Guid.initString("18a2e7f8-428f-4acd-8a00-e64639bc93de");
pub const IID_IWMReaderAdvanced6 = &IID_IWMReaderAdvanced6_Value;
pub const IWMReaderAdvanced6 = extern struct {
    pub const VTable = extern struct {
        base: IWMReaderAdvanced5.VTable,
        SetProtectStreamSamples: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderAdvanced6,
                pbCertificate: [*:0]u8,
                cbCertificate: u32,
                dwCertificateType: u32,
                dwFlags: u32,
                pbInitializationVector: [*:0]u8,
                pcbInitializationVector: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderAdvanced6,
                pbCertificate: [*:0]u8,
                cbCertificate: u32,
                dwCertificateType: u32,
                dwFlags: u32,
                pbInitializationVector: [*:0]u8,
                pcbInitializationVector: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWMReaderAdvanced5.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderAdvanced6_SetProtectStreamSamples(self: *const T, pbCertificate: [*:0]u8, cbCertificate: u32, dwCertificateType: u32, dwFlags: u32, pbInitializationVector: [*:0]u8, pcbInitializationVector: ?*u32) HRESULT {
                return @as(*const IWMReaderAdvanced6.VTable, @ptrCast(self.vtable)).SetProtectStreamSamples(@as(*const IWMReaderAdvanced6, @ptrCast(self)), pbCertificate, cbCertificate, dwCertificateType, dwFlags, pbInitializationVector, pcbInitializationVector);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMPlayerHook_Value = Guid.initString("e5b7ca9a-0f1c-4f66-9002-74ec50d8b304");
pub const IID_IWMPlayerHook = &IID_IWMPlayerHook_Value;
pub const IWMPlayerHook = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        PreDecode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPlayerHook,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPlayerHook,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPlayerHook_PreDecode(self: *const T) HRESULT {
                return @as(*const IWMPlayerHook.VTable, @ptrCast(self.vtable)).PreDecode(@as(*const IWMPlayerHook, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMReaderAllocatorEx_Value = Guid.initString("9f762fa7-a22e-428d-93c9-ac82f3aafe5a");
pub const IID_IWMReaderAllocatorEx = &IID_IWMReaderAllocatorEx_Value;
pub const IWMReaderAllocatorEx = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AllocateForStreamEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderAllocatorEx,
                wStreamNum: u16,
                cbBuffer: u32,
                ppBuffer: ?*?*INSSBuffer,
                dwFlags: u32,
                cnsSampleTime: u64,
                cnsSampleDuration: u64,
                pvContext: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderAllocatorEx,
                wStreamNum: u16,
                cbBuffer: u32,
                ppBuffer: ?*?*INSSBuffer,
                dwFlags: u32,
                cnsSampleTime: u64,
                cnsSampleDuration: u64,
                pvContext: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AllocateForOutputEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderAllocatorEx,
                dwOutputNum: u32,
                cbBuffer: u32,
                ppBuffer: ?*?*INSSBuffer,
                dwFlags: u32,
                cnsSampleTime: u64,
                cnsSampleDuration: u64,
                pvContext: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderAllocatorEx,
                dwOutputNum: u32,
                cbBuffer: u32,
                ppBuffer: ?*?*INSSBuffer,
                dwFlags: u32,
                cnsSampleTime: u64,
                cnsSampleDuration: u64,
                pvContext: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderAllocatorEx_AllocateForStreamEx(self: *const T, wStreamNum: u16, cbBuffer: u32, ppBuffer: ?*?*INSSBuffer, dwFlags: u32, cnsSampleTime: u64, cnsSampleDuration: u64, pvContext: ?*anyopaque) HRESULT {
                return @as(*const IWMReaderAllocatorEx.VTable, @ptrCast(self.vtable)).AllocateForStreamEx(@as(*const IWMReaderAllocatorEx, @ptrCast(self)), wStreamNum, cbBuffer, ppBuffer, dwFlags, cnsSampleTime, cnsSampleDuration, pvContext);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderAllocatorEx_AllocateForOutputEx(self: *const T, dwOutputNum: u32, cbBuffer: u32, ppBuffer: ?*?*INSSBuffer, dwFlags: u32, cnsSampleTime: u64, cnsSampleDuration: u64, pvContext: ?*anyopaque) HRESULT {
                return @as(*const IWMReaderAllocatorEx.VTable, @ptrCast(self.vtable)).AllocateForOutputEx(@as(*const IWMReaderAllocatorEx, @ptrCast(self)), dwOutputNum, cbBuffer, ppBuffer, dwFlags, cnsSampleTime, cnsSampleDuration, pvContext);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMReaderTypeNegotiation_Value = Guid.initString("fdbe5592-81a1-41ea-93bd-735cad1adc05");
pub const IID_IWMReaderTypeNegotiation = &IID_IWMReaderTypeNegotiation_Value;
pub const IWMReaderTypeNegotiation = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        TryOutputProps: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderTypeNegotiation,
                dwOutputNum: u32,
                pOutput: ?*IWMOutputMediaProps,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderTypeNegotiation,
                dwOutputNum: u32,
                pOutput: ?*IWMOutputMediaProps,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderTypeNegotiation_TryOutputProps(self: *const T, dwOutputNum: u32, pOutput: ?*IWMOutputMediaProps) HRESULT {
                return @as(*const IWMReaderTypeNegotiation.VTable, @ptrCast(self.vtable)).TryOutputProps(@as(*const IWMReaderTypeNegotiation, @ptrCast(self)), dwOutputNum, pOutput);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMReaderCallbackAdvanced_Value = Guid.initString("96406beb-2b2b-11d3-b36b-00c04f6108ff");
pub const IID_IWMReaderCallbackAdvanced = &IID_IWMReaderCallbackAdvanced_Value;
pub const IWMReaderCallbackAdvanced = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnStreamSample: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderCallbackAdvanced,
                wStreamNum: u16,
                cnsSampleTime: u64,
                cnsSampleDuration: u64,
                dwFlags: u32,
                pSample: ?*INSSBuffer,
                pvContext: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderCallbackAdvanced,
                wStreamNum: u16,
                cnsSampleTime: u64,
                cnsSampleDuration: u64,
                dwFlags: u32,
                pSample: ?*INSSBuffer,
                pvContext: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderCallbackAdvanced,
                cnsCurrentTime: u64,
                pvContext: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderCallbackAdvanced,
                cnsCurrentTime: u64,
                pvContext: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnStreamSelection: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderCallbackAdvanced,
                wStreamCount: u16,
                pStreamNumbers: ?*u16,
                pSelections: ?*WMT_STREAM_SELECTION,
                pvContext: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderCallbackAdvanced,
                wStreamCount: u16,
                pStreamNumbers: ?*u16,
                pSelections: ?*WMT_STREAM_SELECTION,
                pvContext: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnOutputPropsChanged: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderCallbackAdvanced,
                dwOutputNum: u32,
                pMediaType: ?*WM_MEDIA_TYPE,
                pvContext: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderCallbackAdvanced,
                dwOutputNum: u32,
                pMediaType: ?*WM_MEDIA_TYPE,
                pvContext: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AllocateForStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderCallbackAdvanced,
                wStreamNum: u16,
                cbBuffer: u32,
                ppBuffer: ?*?*INSSBuffer,
                pvContext: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderCallbackAdvanced,
                wStreamNum: u16,
                cbBuffer: u32,
                ppBuffer: ?*?*INSSBuffer,
                pvContext: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AllocateForOutput: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderCallbackAdvanced,
                dwOutputNum: u32,
                cbBuffer: u32,
                ppBuffer: ?*?*INSSBuffer,
                pvContext: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderCallbackAdvanced,
                dwOutputNum: u32,
                cbBuffer: u32,
                ppBuffer: ?*?*INSSBuffer,
                pvContext: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderCallbackAdvanced_OnStreamSample(self: *const T, wStreamNum: u16, cnsSampleTime: u64, cnsSampleDuration: u64, dwFlags: u32, pSample: ?*INSSBuffer, pvContext: ?*anyopaque) HRESULT {
                return @as(*const IWMReaderCallbackAdvanced.VTable, @ptrCast(self.vtable)).OnStreamSample(@as(*const IWMReaderCallbackAdvanced, @ptrCast(self)), wStreamNum, cnsSampleTime, cnsSampleDuration, dwFlags, pSample, pvContext);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderCallbackAdvanced_OnTime(self: *const T, cnsCurrentTime: u64, pvContext: ?*anyopaque) HRESULT {
                return @as(*const IWMReaderCallbackAdvanced.VTable, @ptrCast(self.vtable)).OnTime(@as(*const IWMReaderCallbackAdvanced, @ptrCast(self)), cnsCurrentTime, pvContext);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderCallbackAdvanced_OnStreamSelection(self: *const T, wStreamCount: u16, pStreamNumbers: ?*u16, pSelections: ?*WMT_STREAM_SELECTION, pvContext: ?*anyopaque) HRESULT {
                return @as(*const IWMReaderCallbackAdvanced.VTable, @ptrCast(self.vtable)).OnStreamSelection(@as(*const IWMReaderCallbackAdvanced, @ptrCast(self)), wStreamCount, pStreamNumbers, pSelections, pvContext);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderCallbackAdvanced_OnOutputPropsChanged(self: *const T, dwOutputNum: u32, pMediaType: ?*WM_MEDIA_TYPE, pvContext: ?*anyopaque) HRESULT {
                return @as(*const IWMReaderCallbackAdvanced.VTable, @ptrCast(self.vtable)).OnOutputPropsChanged(@as(*const IWMReaderCallbackAdvanced, @ptrCast(self)), dwOutputNum, pMediaType, pvContext);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderCallbackAdvanced_AllocateForStream(self: *const T, wStreamNum: u16, cbBuffer: u32, ppBuffer: ?*?*INSSBuffer, pvContext: ?*anyopaque) HRESULT {
                return @as(*const IWMReaderCallbackAdvanced.VTable, @ptrCast(self.vtable)).AllocateForStream(@as(*const IWMReaderCallbackAdvanced, @ptrCast(self)), wStreamNum, cbBuffer, ppBuffer, pvContext);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderCallbackAdvanced_AllocateForOutput(self: *const T, dwOutputNum: u32, cbBuffer: u32, ppBuffer: ?*?*INSSBuffer, pvContext: ?*anyopaque) HRESULT {
                return @as(*const IWMReaderCallbackAdvanced.VTable, @ptrCast(self.vtable)).AllocateForOutput(@as(*const IWMReaderCallbackAdvanced, @ptrCast(self)), dwOutputNum, cbBuffer, ppBuffer, pvContext);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IWMDRMReader_Value = Guid.initString("d2827540-3ee7-432c-b14c-dc17f085d3b3");
pub const IID_IWMDRMReader = &IID_IWMDRMReader_Value;
pub const IWMDRMReader = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AcquireLicense: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDRMReader,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDRMReader,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CancelLicenseAcquisition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDRMReader,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDRMReader,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Individualize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDRMReader,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDRMReader,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CancelIndividualization: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDRMReader,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDRMReader,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        MonitorLicenseAcquisition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDRMReader,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDRMReader,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CancelMonitorLicenseAcquisition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDRMReader,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDRMReader,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDRMProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDRMReader,
                pwstrName: ?[*:0]const u16,
                dwType: WMT_ATTR_DATATYPE,
                pValue: [*:0]const u8,
                cbLength: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDRMReader,
                pwstrName: ?[*:0]const u16,
                dwType: WMT_ATTR_DATATYPE,
                pValue: [*:0]const u8,
                cbLength: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDRMProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDRMReader,
                pwstrName: ?[*:0]const u16,
                pdwType: ?*WMT_ATTR_DATATYPE,
                pValue: [*:0]u8,
                pcbLength: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDRMReader,
                pwstrName: ?[*:0]const u16,
                pdwType: ?*WMT_ATTR_DATATYPE,
                pValue: [*:0]u8,
                pcbLength: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDRMReader_AcquireLicense(self: *const T, dwFlags: u32) HRESULT {
                return @as(*const IWMDRMReader.VTable, @ptrCast(self.vtable)).AcquireLicense(@as(*const IWMDRMReader, @ptrCast(self)), dwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDRMReader_CancelLicenseAcquisition(self: *const T) HRESULT {
                return @as(*const IWMDRMReader.VTable, @ptrCast(self.vtable)).CancelLicenseAcquisition(@as(*const IWMDRMReader, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDRMReader_Individualize(self: *const T, dwFlags: u32) HRESULT {
                return @as(*const IWMDRMReader.VTable, @ptrCast(self.vtable)).Individualize(@as(*const IWMDRMReader, @ptrCast(self)), dwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDRMReader_CancelIndividualization(self: *const T) HRESULT {
                return @as(*const IWMDRMReader.VTable, @ptrCast(self.vtable)).CancelIndividualization(@as(*const IWMDRMReader, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDRMReader_MonitorLicenseAcquisition(self: *const T) HRESULT {
                return @as(*const IWMDRMReader.VTable, @ptrCast(self.vtable)).MonitorLicenseAcquisition(@as(*const IWMDRMReader, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDRMReader_CancelMonitorLicenseAcquisition(self: *const T) HRESULT {
                return @as(*const IWMDRMReader.VTable, @ptrCast(self.vtable)).CancelMonitorLicenseAcquisition(@as(*const IWMDRMReader, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDRMReader_SetDRMProperty(self: *const T, pwstrName: ?[*:0]const u16, dwType: WMT_ATTR_DATATYPE, pValue: [*:0]const u8, cbLength: u16) HRESULT {
                return @as(*const IWMDRMReader.VTable, @ptrCast(self.vtable)).SetDRMProperty(@as(*const IWMDRMReader, @ptrCast(self)), pwstrName, dwType, pValue, cbLength);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDRMReader_GetDRMProperty(self: *const T, pwstrName: ?[*:0]const u16, pdwType: ?*WMT_ATTR_DATATYPE, pValue: [*:0]u8, pcbLength: ?*u16) HRESULT {
                return @as(*const IWMDRMReader.VTable, @ptrCast(self.vtable)).GetDRMProperty(@as(*const IWMDRMReader, @ptrCast(self)), pwstrName, pdwType, pValue, pcbLength);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DRM_MINIMUM_OUTPUT_PROTECTION_LEVELS = extern struct {
    wCompressedDigitalVideo: u16,
    wUncompressedDigitalVideo: u16,
    wAnalogVideo: u16,
    wCompressedDigitalAudio: u16,
    wUncompressedDigitalAudio: u16,
};

pub const DRM_OPL_OUTPUT_IDS = extern struct {
    cIds: u16,
    rgIds: ?*Guid,
};

pub const DRM_OUTPUT_PROTECTION = extern struct {
    guidId: Guid,
    bConfigData: u8,
};

pub const DRM_VIDEO_OUTPUT_PROTECTION_IDS = extern struct {
    cEntries: u16,
    rgVop: ?*DRM_OUTPUT_PROTECTION,
};

pub const DRM_PLAY_OPL = extern struct {
    minOPL: DRM_MINIMUM_OUTPUT_PROTECTION_LEVELS,
    oplIdReserved: DRM_OPL_OUTPUT_IDS,
    vopi: DRM_VIDEO_OUTPUT_PROTECTION_IDS,
};

pub const DRM_COPY_OPL = extern struct {
    wMinimumCopyLevel: u16,
    oplIdIncludes: DRM_OPL_OUTPUT_IDS,
    oplIdExcludes: DRM_OPL_OUTPUT_IDS,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IWMDRMReader2_Value = Guid.initString("befe7a75-9f1d-4075-b9d9-a3c37bda49a0");
pub const IID_IWMDRMReader2 = &IID_IWMDRMReader2_Value;
pub const IWMDRMReader2 = extern struct {
    pub const VTable = extern struct {
        base: IWMDRMReader.VTable,
        SetEvaluateOutputLevelLicenses: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDRMReader2,
                fEvaluate: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDRMReader2,
                fEvaluate: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPlayOutputLevels: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDRMReader2,
                pPlayOPL: [*]DRM_PLAY_OPL,
                pcbLength: ?*u32,
                pdwMinAppComplianceLevel: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDRMReader2,
                pPlayOPL: [*]DRM_PLAY_OPL,
                pcbLength: ?*u32,
                pdwMinAppComplianceLevel: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCopyOutputLevels: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDRMReader2,
                pCopyOPL: [*]DRM_COPY_OPL,
                pcbLength: ?*u32,
                pdwMinAppComplianceLevel: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDRMReader2,
                pCopyOPL: [*]DRM_COPY_OPL,
                pcbLength: ?*u32,
                pdwMinAppComplianceLevel: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TryNextLicense: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDRMReader2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDRMReader2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWMDRMReader.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDRMReader2_SetEvaluateOutputLevelLicenses(self: *const T, fEvaluate: BOOL) HRESULT {
                return @as(*const IWMDRMReader2.VTable, @ptrCast(self.vtable)).SetEvaluateOutputLevelLicenses(@as(*const IWMDRMReader2, @ptrCast(self)), fEvaluate);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDRMReader2_GetPlayOutputLevels(self: *const T, pPlayOPL: [*]DRM_PLAY_OPL, pcbLength: ?*u32, pdwMinAppComplianceLevel: ?*u32) HRESULT {
                return @as(*const IWMDRMReader2.VTable, @ptrCast(self.vtable)).GetPlayOutputLevels(@as(*const IWMDRMReader2, @ptrCast(self)), pPlayOPL, pcbLength, pdwMinAppComplianceLevel);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDRMReader2_GetCopyOutputLevels(self: *const T, pCopyOPL: [*]DRM_COPY_OPL, pcbLength: ?*u32, pdwMinAppComplianceLevel: ?*u32) HRESULT {
                return @as(*const IWMDRMReader2.VTable, @ptrCast(self.vtable)).GetCopyOutputLevels(@as(*const IWMDRMReader2, @ptrCast(self)), pCopyOPL, pcbLength, pdwMinAppComplianceLevel);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDRMReader2_TryNextLicense(self: *const T) HRESULT {
                return @as(*const IWMDRMReader2.VTable, @ptrCast(self.vtable)).TryNextLicense(@as(*const IWMDRMReader2, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IWMDRMReader3_Value = Guid.initString("e08672de-f1e7-4ff4-a0a3-fc4b08e4caf8");
pub const IID_IWMDRMReader3 = &IID_IWMDRMReader3_Value;
pub const IWMDRMReader3 = extern struct {
    pub const VTable = extern struct {
        base: IWMDRMReader2.VTable,
        GetInclusionList: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDRMReader3,
                ppGuids: ?*?*Guid,
                pcGuids: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDRMReader3,
                ppGuids: ?*?*Guid,
                pcGuids: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWMDRMReader2.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDRMReader3_GetInclusionList(self: *const T, ppGuids: ?*?*Guid, pcGuids: ?*u32) HRESULT {
                return @as(*const IWMDRMReader3.VTable, @ptrCast(self.vtable)).GetInclusionList(@as(*const IWMDRMReader3, @ptrCast(self)), ppGuids, pcGuids);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMReaderPlaylistBurn_Value = Guid.initString("f28c0300-9baa-4477-a846-1744d9cbf533");
pub const IID_IWMReaderPlaylistBurn = &IID_IWMReaderPlaylistBurn_Value;
pub const IWMReaderPlaylistBurn = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        InitPlaylistBurn: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderPlaylistBurn,
                cFiles: u32,
                ppwszFilenames: ?*?PWSTR,
                pCallback: ?*IWMStatusCallback,
                pvContext: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderPlaylistBurn,
                cFiles: u32,
                ppwszFilenames: ?*?PWSTR,
                pCallback: ?*IWMStatusCallback,
                pvContext: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInitResults: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderPlaylistBurn,
                cFiles: u32,
                phrStati: ?*HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderPlaylistBurn,
                cFiles: u32,
                phrStati: ?*HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Cancel: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderPlaylistBurn,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderPlaylistBurn,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndPlaylistBurn: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderPlaylistBurn,
                hrBurnResult: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderPlaylistBurn,
                hrBurnResult: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderPlaylistBurn_InitPlaylistBurn(self: *const T, cFiles: u32, ppwszFilenames: ?*?PWSTR, pCallback: ?*IWMStatusCallback, pvContext: ?*anyopaque) HRESULT {
                return @as(*const IWMReaderPlaylistBurn.VTable, @ptrCast(self.vtable)).InitPlaylistBurn(@as(*const IWMReaderPlaylistBurn, @ptrCast(self)), cFiles, ppwszFilenames, pCallback, pvContext);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderPlaylistBurn_GetInitResults(self: *const T, cFiles: u32, phrStati: ?*HRESULT) HRESULT {
                return @as(*const IWMReaderPlaylistBurn.VTable, @ptrCast(self.vtable)).GetInitResults(@as(*const IWMReaderPlaylistBurn, @ptrCast(self)), cFiles, phrStati);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderPlaylistBurn_Cancel(self: *const T) HRESULT {
                return @as(*const IWMReaderPlaylistBurn.VTable, @ptrCast(self.vtable)).Cancel(@as(*const IWMReaderPlaylistBurn, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderPlaylistBurn_EndPlaylistBurn(self: *const T, hrBurnResult: HRESULT) HRESULT {
                return @as(*const IWMReaderPlaylistBurn.VTable, @ptrCast(self.vtable)).EndPlaylistBurn(@as(*const IWMReaderPlaylistBurn, @ptrCast(self)), hrBurnResult);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMReaderNetworkConfig_Value = Guid.initString("96406bec-2b2b-11d3-b36b-00c04f6108ff");
pub const IID_IWMReaderNetworkConfig = &IID_IWMReaderNetworkConfig_Value;
pub const IWMReaderNetworkConfig = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetBufferingTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderNetworkConfig,
                pcnsBufferingTime: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderNetworkConfig,
                pcnsBufferingTime: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetBufferingTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderNetworkConfig,
                cnsBufferingTime: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderNetworkConfig,
                cnsBufferingTime: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetUDPPortRanges: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderNetworkConfig,
                pRangeArray: [*]WM_PORT_NUMBER_RANGE,
                pcRanges: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderNetworkConfig,
                pRangeArray: [*]WM_PORT_NUMBER_RANGE,
                pcRanges: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetUDPPortRanges: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderNetworkConfig,
                pRangeArray: [*]WM_PORT_NUMBER_RANGE,
                cRanges: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderNetworkConfig,
                pRangeArray: [*]WM_PORT_NUMBER_RANGE,
                cRanges: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProxySettings: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderNetworkConfig,
                pwszProtocol: ?[*:0]const u16,
                pProxySetting: ?*WMT_PROXY_SETTINGS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderNetworkConfig,
                pwszProtocol: ?[*:0]const u16,
                pProxySetting: ?*WMT_PROXY_SETTINGS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetProxySettings: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderNetworkConfig,
                pwszProtocol: ?[*:0]const u16,
                ProxySetting: WMT_PROXY_SETTINGS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderNetworkConfig,
                pwszProtocol: ?[*:0]const u16,
                ProxySetting: WMT_PROXY_SETTINGS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProxyHostName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderNetworkConfig,
                pwszProtocol: ?[*:0]const u16,
                pwszHostName: [*:0]u16,
                pcchHostName: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderNetworkConfig,
                pwszProtocol: ?[*:0]const u16,
                pwszHostName: [*:0]u16,
                pcchHostName: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetProxyHostName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderNetworkConfig,
                pwszProtocol: ?[*:0]const u16,
                pwszHostName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderNetworkConfig,
                pwszProtocol: ?[*:0]const u16,
                pwszHostName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProxyPort: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderNetworkConfig,
                pwszProtocol: ?[*:0]const u16,
                pdwPort: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderNetworkConfig,
                pwszProtocol: ?[*:0]const u16,
                pdwPort: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetProxyPort: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderNetworkConfig,
                pwszProtocol: ?[*:0]const u16,
                dwPort: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderNetworkConfig,
                pwszProtocol: ?[*:0]const u16,
                dwPort: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProxyExceptionList: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderNetworkConfig,
                pwszProtocol: ?[*:0]const u16,
                pwszExceptionList: [*:0]u16,
                pcchExceptionList: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderNetworkConfig,
                pwszProtocol: ?[*:0]const u16,
                pwszExceptionList: [*:0]u16,
                pcchExceptionList: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetProxyExceptionList: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderNetworkConfig,
                pwszProtocol: ?[*:0]const u16,
                pwszExceptionList: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderNetworkConfig,
                pwszProtocol: ?[*:0]const u16,
                pwszExceptionList: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProxyBypassForLocal: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderNetworkConfig,
                pwszProtocol: ?[*:0]const u16,
                pfBypassForLocal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderNetworkConfig,
                pwszProtocol: ?[*:0]const u16,
                pfBypassForLocal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetProxyBypassForLocal: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderNetworkConfig,
                pwszProtocol: ?[*:0]const u16,
                fBypassForLocal: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderNetworkConfig,
                pwszProtocol: ?[*:0]const u16,
                fBypassForLocal: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetForceRerunAutoProxyDetection: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderNetworkConfig,
                pfForceRerunDetection: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderNetworkConfig,
                pfForceRerunDetection: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetForceRerunAutoProxyDetection: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderNetworkConfig,
                fForceRerunDetection: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderNetworkConfig,
                fForceRerunDetection: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEnableMulticast: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderNetworkConfig,
                pfEnableMulticast: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderNetworkConfig,
                pfEnableMulticast: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEnableMulticast: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderNetworkConfig,
                fEnableMulticast: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderNetworkConfig,
                fEnableMulticast: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEnableHTTP: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderNetworkConfig,
                pfEnableHTTP: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderNetworkConfig,
                pfEnableHTTP: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEnableHTTP: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderNetworkConfig,
                fEnableHTTP: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderNetworkConfig,
                fEnableHTTP: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEnableUDP: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderNetworkConfig,
                pfEnableUDP: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderNetworkConfig,
                pfEnableUDP: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEnableUDP: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderNetworkConfig,
                fEnableUDP: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderNetworkConfig,
                fEnableUDP: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEnableTCP: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderNetworkConfig,
                pfEnableTCP: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderNetworkConfig,
                pfEnableTCP: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEnableTCP: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderNetworkConfig,
                fEnableTCP: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderNetworkConfig,
                fEnableTCP: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ResetProtocolRollover: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderNetworkConfig,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderNetworkConfig,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetConnectionBandwidth: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderNetworkConfig,
                pdwConnectionBandwidth: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderNetworkConfig,
                pdwConnectionBandwidth: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetConnectionBandwidth: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderNetworkConfig,
                dwConnectionBandwidth: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderNetworkConfig,
                dwConnectionBandwidth: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumProtocolsSupported: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderNetworkConfig,
                pcProtocols: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderNetworkConfig,
                pcProtocols: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSupportedProtocolName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderNetworkConfig,
                dwProtocolNum: u32,
                pwszProtocolName: [*:0]u16,
                pcchProtocolName: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderNetworkConfig,
                dwProtocolNum: u32,
                pwszProtocolName: [*:0]u16,
                pcchProtocolName: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddLoggingUrl: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderNetworkConfig,
                pwszUrl: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderNetworkConfig,
                pwszUrl: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLoggingUrl: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderNetworkConfig,
                dwIndex: u32,
                pwszUrl: [*:0]u16,
                pcchUrl: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderNetworkConfig,
                dwIndex: u32,
                pwszUrl: [*:0]u16,
                pcchUrl: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLoggingUrlCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderNetworkConfig,
                pdwUrlCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderNetworkConfig,
                pdwUrlCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ResetLoggingUrlList: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderNetworkConfig,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderNetworkConfig,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderNetworkConfig_GetBufferingTime(self: *const T, pcnsBufferingTime: ?*u64) HRESULT {
                return @as(*const IWMReaderNetworkConfig.VTable, @ptrCast(self.vtable)).GetBufferingTime(@as(*const IWMReaderNetworkConfig, @ptrCast(self)), pcnsBufferingTime);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderNetworkConfig_SetBufferingTime(self: *const T, cnsBufferingTime: u64) HRESULT {
                return @as(*const IWMReaderNetworkConfig.VTable, @ptrCast(self.vtable)).SetBufferingTime(@as(*const IWMReaderNetworkConfig, @ptrCast(self)), cnsBufferingTime);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderNetworkConfig_GetUDPPortRanges(self: *const T, pRangeArray: [*]WM_PORT_NUMBER_RANGE, pcRanges: ?*u32) HRESULT {
                return @as(*const IWMReaderNetworkConfig.VTable, @ptrCast(self.vtable)).GetUDPPortRanges(@as(*const IWMReaderNetworkConfig, @ptrCast(self)), pRangeArray, pcRanges);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderNetworkConfig_SetUDPPortRanges(self: *const T, pRangeArray: [*]WM_PORT_NUMBER_RANGE, cRanges: u32) HRESULT {
                return @as(*const IWMReaderNetworkConfig.VTable, @ptrCast(self.vtable)).SetUDPPortRanges(@as(*const IWMReaderNetworkConfig, @ptrCast(self)), pRangeArray, cRanges);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderNetworkConfig_GetProxySettings(self: *const T, pwszProtocol: ?[*:0]const u16, pProxySetting: ?*WMT_PROXY_SETTINGS) HRESULT {
                return @as(*const IWMReaderNetworkConfig.VTable, @ptrCast(self.vtable)).GetProxySettings(@as(*const IWMReaderNetworkConfig, @ptrCast(self)), pwszProtocol, pProxySetting);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderNetworkConfig_SetProxySettings(self: *const T, pwszProtocol: ?[*:0]const u16, ProxySetting: WMT_PROXY_SETTINGS) HRESULT {
                return @as(*const IWMReaderNetworkConfig.VTable, @ptrCast(self.vtable)).SetProxySettings(@as(*const IWMReaderNetworkConfig, @ptrCast(self)), pwszProtocol, ProxySetting);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderNetworkConfig_GetProxyHostName(self: *const T, pwszProtocol: ?[*:0]const u16, pwszHostName: [*:0]u16, pcchHostName: ?*u32) HRESULT {
                return @as(*const IWMReaderNetworkConfig.VTable, @ptrCast(self.vtable)).GetProxyHostName(@as(*const IWMReaderNetworkConfig, @ptrCast(self)), pwszProtocol, pwszHostName, pcchHostName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderNetworkConfig_SetProxyHostName(self: *const T, pwszProtocol: ?[*:0]const u16, pwszHostName: ?[*:0]const u16) HRESULT {
                return @as(*const IWMReaderNetworkConfig.VTable, @ptrCast(self.vtable)).SetProxyHostName(@as(*const IWMReaderNetworkConfig, @ptrCast(self)), pwszProtocol, pwszHostName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderNetworkConfig_GetProxyPort(self: *const T, pwszProtocol: ?[*:0]const u16, pdwPort: ?*u32) HRESULT {
                return @as(*const IWMReaderNetworkConfig.VTable, @ptrCast(self.vtable)).GetProxyPort(@as(*const IWMReaderNetworkConfig, @ptrCast(self)), pwszProtocol, pdwPort);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderNetworkConfig_SetProxyPort(self: *const T, pwszProtocol: ?[*:0]const u16, dwPort: u32) HRESULT {
                return @as(*const IWMReaderNetworkConfig.VTable, @ptrCast(self.vtable)).SetProxyPort(@as(*const IWMReaderNetworkConfig, @ptrCast(self)), pwszProtocol, dwPort);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderNetworkConfig_GetProxyExceptionList(self: *const T, pwszProtocol: ?[*:0]const u16, pwszExceptionList: [*:0]u16, pcchExceptionList: ?*u32) HRESULT {
                return @as(*const IWMReaderNetworkConfig.VTable, @ptrCast(self.vtable)).GetProxyExceptionList(@as(*const IWMReaderNetworkConfig, @ptrCast(self)), pwszProtocol, pwszExceptionList, pcchExceptionList);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderNetworkConfig_SetProxyExceptionList(self: *const T, pwszProtocol: ?[*:0]const u16, pwszExceptionList: ?[*:0]const u16) HRESULT {
                return @as(*const IWMReaderNetworkConfig.VTable, @ptrCast(self.vtable)).SetProxyExceptionList(@as(*const IWMReaderNetworkConfig, @ptrCast(self)), pwszProtocol, pwszExceptionList);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderNetworkConfig_GetProxyBypassForLocal(self: *const T, pwszProtocol: ?[*:0]const u16, pfBypassForLocal: ?*BOOL) HRESULT {
                return @as(*const IWMReaderNetworkConfig.VTable, @ptrCast(self.vtable)).GetProxyBypassForLocal(@as(*const IWMReaderNetworkConfig, @ptrCast(self)), pwszProtocol, pfBypassForLocal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderNetworkConfig_SetProxyBypassForLocal(self: *const T, pwszProtocol: ?[*:0]const u16, fBypassForLocal: BOOL) HRESULT {
                return @as(*const IWMReaderNetworkConfig.VTable, @ptrCast(self.vtable)).SetProxyBypassForLocal(@as(*const IWMReaderNetworkConfig, @ptrCast(self)), pwszProtocol, fBypassForLocal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderNetworkConfig_GetForceRerunAutoProxyDetection(self: *const T, pfForceRerunDetection: ?*BOOL) HRESULT {
                return @as(*const IWMReaderNetworkConfig.VTable, @ptrCast(self.vtable)).GetForceRerunAutoProxyDetection(@as(*const IWMReaderNetworkConfig, @ptrCast(self)), pfForceRerunDetection);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderNetworkConfig_SetForceRerunAutoProxyDetection(self: *const T, fForceRerunDetection: BOOL) HRESULT {
                return @as(*const IWMReaderNetworkConfig.VTable, @ptrCast(self.vtable)).SetForceRerunAutoProxyDetection(@as(*const IWMReaderNetworkConfig, @ptrCast(self)), fForceRerunDetection);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderNetworkConfig_GetEnableMulticast(self: *const T, pfEnableMulticast: ?*BOOL) HRESULT {
                return @as(*const IWMReaderNetworkConfig.VTable, @ptrCast(self.vtable)).GetEnableMulticast(@as(*const IWMReaderNetworkConfig, @ptrCast(self)), pfEnableMulticast);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderNetworkConfig_SetEnableMulticast(self: *const T, fEnableMulticast: BOOL) HRESULT {
                return @as(*const IWMReaderNetworkConfig.VTable, @ptrCast(self.vtable)).SetEnableMulticast(@as(*const IWMReaderNetworkConfig, @ptrCast(self)), fEnableMulticast);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderNetworkConfig_GetEnableHTTP(self: *const T, pfEnableHTTP: ?*BOOL) HRESULT {
                return @as(*const IWMReaderNetworkConfig.VTable, @ptrCast(self.vtable)).GetEnableHTTP(@as(*const IWMReaderNetworkConfig, @ptrCast(self)), pfEnableHTTP);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderNetworkConfig_SetEnableHTTP(self: *const T, fEnableHTTP: BOOL) HRESULT {
                return @as(*const IWMReaderNetworkConfig.VTable, @ptrCast(self.vtable)).SetEnableHTTP(@as(*const IWMReaderNetworkConfig, @ptrCast(self)), fEnableHTTP);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderNetworkConfig_GetEnableUDP(self: *const T, pfEnableUDP: ?*BOOL) HRESULT {
                return @as(*const IWMReaderNetworkConfig.VTable, @ptrCast(self.vtable)).GetEnableUDP(@as(*const IWMReaderNetworkConfig, @ptrCast(self)), pfEnableUDP);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderNetworkConfig_SetEnableUDP(self: *const T, fEnableUDP: BOOL) HRESULT {
                return @as(*const IWMReaderNetworkConfig.VTable, @ptrCast(self.vtable)).SetEnableUDP(@as(*const IWMReaderNetworkConfig, @ptrCast(self)), fEnableUDP);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderNetworkConfig_GetEnableTCP(self: *const T, pfEnableTCP: ?*BOOL) HRESULT {
                return @as(*const IWMReaderNetworkConfig.VTable, @ptrCast(self.vtable)).GetEnableTCP(@as(*const IWMReaderNetworkConfig, @ptrCast(self)), pfEnableTCP);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderNetworkConfig_SetEnableTCP(self: *const T, fEnableTCP: BOOL) HRESULT {
                return @as(*const IWMReaderNetworkConfig.VTable, @ptrCast(self.vtable)).SetEnableTCP(@as(*const IWMReaderNetworkConfig, @ptrCast(self)), fEnableTCP);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderNetworkConfig_ResetProtocolRollover(self: *const T) HRESULT {
                return @as(*const IWMReaderNetworkConfig.VTable, @ptrCast(self.vtable)).ResetProtocolRollover(@as(*const IWMReaderNetworkConfig, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderNetworkConfig_GetConnectionBandwidth(self: *const T, pdwConnectionBandwidth: ?*u32) HRESULT {
                return @as(*const IWMReaderNetworkConfig.VTable, @ptrCast(self.vtable)).GetConnectionBandwidth(@as(*const IWMReaderNetworkConfig, @ptrCast(self)), pdwConnectionBandwidth);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderNetworkConfig_SetConnectionBandwidth(self: *const T, dwConnectionBandwidth: u32) HRESULT {
                return @as(*const IWMReaderNetworkConfig.VTable, @ptrCast(self.vtable)).SetConnectionBandwidth(@as(*const IWMReaderNetworkConfig, @ptrCast(self)), dwConnectionBandwidth);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderNetworkConfig_GetNumProtocolsSupported(self: *const T, pcProtocols: ?*u32) HRESULT {
                return @as(*const IWMReaderNetworkConfig.VTable, @ptrCast(self.vtable)).GetNumProtocolsSupported(@as(*const IWMReaderNetworkConfig, @ptrCast(self)), pcProtocols);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderNetworkConfig_GetSupportedProtocolName(self: *const T, dwProtocolNum: u32, pwszProtocolName: [*:0]u16, pcchProtocolName: ?*u32) HRESULT {
                return @as(*const IWMReaderNetworkConfig.VTable, @ptrCast(self.vtable)).GetSupportedProtocolName(@as(*const IWMReaderNetworkConfig, @ptrCast(self)), dwProtocolNum, pwszProtocolName, pcchProtocolName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderNetworkConfig_AddLoggingUrl(self: *const T, pwszUrl: ?[*:0]const u16) HRESULT {
                return @as(*const IWMReaderNetworkConfig.VTable, @ptrCast(self.vtable)).AddLoggingUrl(@as(*const IWMReaderNetworkConfig, @ptrCast(self)), pwszUrl);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderNetworkConfig_GetLoggingUrl(self: *const T, dwIndex: u32, pwszUrl: [*:0]u16, pcchUrl: ?*u32) HRESULT {
                return @as(*const IWMReaderNetworkConfig.VTable, @ptrCast(self.vtable)).GetLoggingUrl(@as(*const IWMReaderNetworkConfig, @ptrCast(self)), dwIndex, pwszUrl, pcchUrl);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderNetworkConfig_GetLoggingUrlCount(self: *const T, pdwUrlCount: ?*u32) HRESULT {
                return @as(*const IWMReaderNetworkConfig.VTable, @ptrCast(self.vtable)).GetLoggingUrlCount(@as(*const IWMReaderNetworkConfig, @ptrCast(self)), pdwUrlCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderNetworkConfig_ResetLoggingUrlList(self: *const T) HRESULT {
                return @as(*const IWMReaderNetworkConfig.VTable, @ptrCast(self.vtable)).ResetLoggingUrlList(@as(*const IWMReaderNetworkConfig, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMReaderNetworkConfig2_Value = Guid.initString("d979a853-042b-4050-8387-c939db22013f");
pub const IID_IWMReaderNetworkConfig2 = &IID_IWMReaderNetworkConfig2_Value;
pub const IWMReaderNetworkConfig2 = extern struct {
    pub const VTable = extern struct {
        base: IWMReaderNetworkConfig.VTable,
        GetEnableContentCaching: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderNetworkConfig2,
                pfEnableContentCaching: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderNetworkConfig2,
                pfEnableContentCaching: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEnableContentCaching: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderNetworkConfig2,
                fEnableContentCaching: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderNetworkConfig2,
                fEnableContentCaching: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEnableFastCache: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderNetworkConfig2,
                pfEnableFastCache: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderNetworkConfig2,
                pfEnableFastCache: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEnableFastCache: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderNetworkConfig2,
                fEnableFastCache: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderNetworkConfig2,
                fEnableFastCache: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAcceleratedStreamingDuration: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderNetworkConfig2,
                pcnsAccelDuration: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderNetworkConfig2,
                pcnsAccelDuration: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetAcceleratedStreamingDuration: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderNetworkConfig2,
                cnsAccelDuration: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderNetworkConfig2,
                cnsAccelDuration: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAutoReconnectLimit: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderNetworkConfig2,
                pdwAutoReconnectLimit: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderNetworkConfig2,
                pdwAutoReconnectLimit: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetAutoReconnectLimit: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderNetworkConfig2,
                dwAutoReconnectLimit: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderNetworkConfig2,
                dwAutoReconnectLimit: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEnableResends: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderNetworkConfig2,
                pfEnableResends: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderNetworkConfig2,
                pfEnableResends: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEnableResends: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderNetworkConfig2,
                fEnableResends: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderNetworkConfig2,
                fEnableResends: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEnableThinning: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderNetworkConfig2,
                pfEnableThinning: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderNetworkConfig2,
                pfEnableThinning: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEnableThinning: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderNetworkConfig2,
                fEnableThinning: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderNetworkConfig2,
                fEnableThinning: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMaxNetPacketSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderNetworkConfig2,
                pdwMaxNetPacketSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderNetworkConfig2,
                pdwMaxNetPacketSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWMReaderNetworkConfig.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderNetworkConfig2_GetEnableContentCaching(self: *const T, pfEnableContentCaching: ?*BOOL) HRESULT {
                return @as(*const IWMReaderNetworkConfig2.VTable, @ptrCast(self.vtable)).GetEnableContentCaching(@as(*const IWMReaderNetworkConfig2, @ptrCast(self)), pfEnableContentCaching);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderNetworkConfig2_SetEnableContentCaching(self: *const T, fEnableContentCaching: BOOL) HRESULT {
                return @as(*const IWMReaderNetworkConfig2.VTable, @ptrCast(self.vtable)).SetEnableContentCaching(@as(*const IWMReaderNetworkConfig2, @ptrCast(self)), fEnableContentCaching);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderNetworkConfig2_GetEnableFastCache(self: *const T, pfEnableFastCache: ?*BOOL) HRESULT {
                return @as(*const IWMReaderNetworkConfig2.VTable, @ptrCast(self.vtable)).GetEnableFastCache(@as(*const IWMReaderNetworkConfig2, @ptrCast(self)), pfEnableFastCache);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderNetworkConfig2_SetEnableFastCache(self: *const T, fEnableFastCache: BOOL) HRESULT {
                return @as(*const IWMReaderNetworkConfig2.VTable, @ptrCast(self.vtable)).SetEnableFastCache(@as(*const IWMReaderNetworkConfig2, @ptrCast(self)), fEnableFastCache);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderNetworkConfig2_GetAcceleratedStreamingDuration(self: *const T, pcnsAccelDuration: ?*u64) HRESULT {
                return @as(*const IWMReaderNetworkConfig2.VTable, @ptrCast(self.vtable)).GetAcceleratedStreamingDuration(@as(*const IWMReaderNetworkConfig2, @ptrCast(self)), pcnsAccelDuration);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderNetworkConfig2_SetAcceleratedStreamingDuration(self: *const T, cnsAccelDuration: u64) HRESULT {
                return @as(*const IWMReaderNetworkConfig2.VTable, @ptrCast(self.vtable)).SetAcceleratedStreamingDuration(@as(*const IWMReaderNetworkConfig2, @ptrCast(self)), cnsAccelDuration);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderNetworkConfig2_GetAutoReconnectLimit(self: *const T, pdwAutoReconnectLimit: ?*u32) HRESULT {
                return @as(*const IWMReaderNetworkConfig2.VTable, @ptrCast(self.vtable)).GetAutoReconnectLimit(@as(*const IWMReaderNetworkConfig2, @ptrCast(self)), pdwAutoReconnectLimit);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderNetworkConfig2_SetAutoReconnectLimit(self: *const T, dwAutoReconnectLimit: u32) HRESULT {
                return @as(*const IWMReaderNetworkConfig2.VTable, @ptrCast(self.vtable)).SetAutoReconnectLimit(@as(*const IWMReaderNetworkConfig2, @ptrCast(self)), dwAutoReconnectLimit);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderNetworkConfig2_GetEnableResends(self: *const T, pfEnableResends: ?*BOOL) HRESULT {
                return @as(*const IWMReaderNetworkConfig2.VTable, @ptrCast(self.vtable)).GetEnableResends(@as(*const IWMReaderNetworkConfig2, @ptrCast(self)), pfEnableResends);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderNetworkConfig2_SetEnableResends(self: *const T, fEnableResends: BOOL) HRESULT {
                return @as(*const IWMReaderNetworkConfig2.VTable, @ptrCast(self.vtable)).SetEnableResends(@as(*const IWMReaderNetworkConfig2, @ptrCast(self)), fEnableResends);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderNetworkConfig2_GetEnableThinning(self: *const T, pfEnableThinning: ?*BOOL) HRESULT {
                return @as(*const IWMReaderNetworkConfig2.VTable, @ptrCast(self.vtable)).GetEnableThinning(@as(*const IWMReaderNetworkConfig2, @ptrCast(self)), pfEnableThinning);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderNetworkConfig2_SetEnableThinning(self: *const T, fEnableThinning: BOOL) HRESULT {
                return @as(*const IWMReaderNetworkConfig2.VTable, @ptrCast(self.vtable)).SetEnableThinning(@as(*const IWMReaderNetworkConfig2, @ptrCast(self)), fEnableThinning);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderNetworkConfig2_GetMaxNetPacketSize(self: *const T, pdwMaxNetPacketSize: ?*u32) HRESULT {
                return @as(*const IWMReaderNetworkConfig2.VTable, @ptrCast(self.vtable)).GetMaxNetPacketSize(@as(*const IWMReaderNetworkConfig2, @ptrCast(self)), pdwMaxNetPacketSize);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMReaderStreamClock_Value = Guid.initString("96406bed-2b2b-11d3-b36b-00c04f6108ff");
pub const IID_IWMReaderStreamClock = &IID_IWMReaderStreamClock_Value;
pub const IWMReaderStreamClock = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderStreamClock,
                pcnsNow: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderStreamClock,
                pcnsNow: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTimer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderStreamClock,
                cnsWhen: u64,
                pvParam: ?*anyopaque,
                pdwTimerId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderStreamClock,
                cnsWhen: u64,
                pvParam: ?*anyopaque,
                pdwTimerId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        KillTimer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderStreamClock,
                dwTimerId: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderStreamClock,
                dwTimerId: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderStreamClock_GetTime(self: *const T, pcnsNow: ?*u64) HRESULT {
                return @as(*const IWMReaderStreamClock.VTable, @ptrCast(self.vtable)).GetTime(@as(*const IWMReaderStreamClock, @ptrCast(self)), pcnsNow);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderStreamClock_SetTimer(self: *const T, cnsWhen: u64, pvParam: ?*anyopaque, pdwTimerId: ?*u32) HRESULT {
                return @as(*const IWMReaderStreamClock.VTable, @ptrCast(self.vtable)).SetTimer(@as(*const IWMReaderStreamClock, @ptrCast(self)), cnsWhen, pvParam, pdwTimerId);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderStreamClock_KillTimer(self: *const T, dwTimerId: u32) HRESULT {
                return @as(*const IWMReaderStreamClock.VTable, @ptrCast(self.vtable)).KillTimer(@as(*const IWMReaderStreamClock, @ptrCast(self)), dwTimerId);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMIndexer_Value = Guid.initString("6d7cdc71-9888-11d3-8edc-00c04f6109cf");
pub const IID_IWMIndexer = &IID_IWMIndexer_Value;
pub const IWMIndexer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        StartIndexing: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMIndexer,
                pwszURL: ?[*:0]const u16,
                pCallback: ?*IWMStatusCallback,
                pvContext: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMIndexer,
                pwszURL: ?[*:0]const u16,
                pCallback: ?*IWMStatusCallback,
                pvContext: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Cancel: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMIndexer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMIndexer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMIndexer_StartIndexing(self: *const T, pwszURL: ?[*:0]const u16, pCallback: ?*IWMStatusCallback, pvContext: ?*anyopaque) HRESULT {
                return @as(*const IWMIndexer.VTable, @ptrCast(self.vtable)).StartIndexing(@as(*const IWMIndexer, @ptrCast(self)), pwszURL, pCallback, pvContext);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMIndexer_Cancel(self: *const T) HRESULT {
                return @as(*const IWMIndexer.VTable, @ptrCast(self.vtable)).Cancel(@as(*const IWMIndexer, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMIndexer2_Value = Guid.initString("b70f1e42-6255-4df0-a6b9-02b212d9e2bb");
pub const IID_IWMIndexer2 = &IID_IWMIndexer2_Value;
pub const IWMIndexer2 = extern struct {
    pub const VTable = extern struct {
        base: IWMIndexer.VTable,
        Configure: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMIndexer2,
                wStreamNum: u16,
                nIndexerType: WMT_INDEXER_TYPE,
                pvInterval: ?*anyopaque,
                pvIndexType: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMIndexer2,
                wStreamNum: u16,
                nIndexerType: WMT_INDEXER_TYPE,
                pvInterval: ?*anyopaque,
                pvIndexType: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWMIndexer.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMIndexer2_Configure(self: *const T, wStreamNum: u16, nIndexerType: WMT_INDEXER_TYPE, pvInterval: ?*anyopaque, pvIndexType: ?*anyopaque) HRESULT {
                return @as(*const IWMIndexer2.VTable, @ptrCast(self.vtable)).Configure(@as(*const IWMIndexer2, @ptrCast(self)), wStreamNum, nIndexerType, pvInterval, pvIndexType);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IWMLicenseBackup_Value = Guid.initString("05e5ac9f-3fb6-4508-bb43-a4067ba1ebe8");
pub const IID_IWMLicenseBackup = &IID_IWMLicenseBackup_Value;
pub const IWMLicenseBackup = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        BackupLicenses: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMLicenseBackup,
                dwFlags: u32,
                pCallback: ?*IWMStatusCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMLicenseBackup,
                dwFlags: u32,
                pCallback: ?*IWMStatusCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CancelLicenseBackup: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMLicenseBackup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMLicenseBackup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMLicenseBackup_BackupLicenses(self: *const T, dwFlags: u32, pCallback: ?*IWMStatusCallback) HRESULT {
                return @as(*const IWMLicenseBackup.VTable, @ptrCast(self.vtable)).BackupLicenses(@as(*const IWMLicenseBackup, @ptrCast(self)), dwFlags, pCallback);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMLicenseBackup_CancelLicenseBackup(self: *const T) HRESULT {
                return @as(*const IWMLicenseBackup.VTable, @ptrCast(self.vtable)).CancelLicenseBackup(@as(*const IWMLicenseBackup, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IWMLicenseRestore_Value = Guid.initString("c70b6334-a22e-4efb-a245-15e65a004a13");
pub const IID_IWMLicenseRestore = &IID_IWMLicenseRestore_Value;
pub const IWMLicenseRestore = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RestoreLicenses: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMLicenseRestore,
                dwFlags: u32,
                pCallback: ?*IWMStatusCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMLicenseRestore,
                dwFlags: u32,
                pCallback: ?*IWMStatusCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CancelLicenseRestore: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMLicenseRestore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMLicenseRestore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMLicenseRestore_RestoreLicenses(self: *const T, dwFlags: u32, pCallback: ?*IWMStatusCallback) HRESULT {
                return @as(*const IWMLicenseRestore.VTable, @ptrCast(self.vtable)).RestoreLicenses(@as(*const IWMLicenseRestore, @ptrCast(self)), dwFlags, pCallback);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMLicenseRestore_CancelLicenseRestore(self: *const T) HRESULT {
                return @as(*const IWMLicenseRestore.VTable, @ptrCast(self.vtable)).CancelLicenseRestore(@as(*const IWMLicenseRestore, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IWMBackupRestoreProps_Value = Guid.initString("3c8e0da6-996f-4ff3-a1af-4838f9377e2e");
pub const IID_IWMBackupRestoreProps = &IID_IWMBackupRestoreProps_Value;
pub const IWMBackupRestoreProps = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPropCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMBackupRestoreProps,
                pcProps: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMBackupRestoreProps,
                pcProps: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPropByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMBackupRestoreProps,
                wIndex: u16,
                pwszName: [*:0]u16,
                pcchNameLen: ?*u16,
                pType: ?*WMT_ATTR_DATATYPE,
                pValue: [*:0]u8,
                pcbLength: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMBackupRestoreProps,
                wIndex: u16,
                pwszName: [*:0]u16,
                pcchNameLen: ?*u16,
                pType: ?*WMT_ATTR_DATATYPE,
                pValue: [*:0]u8,
                pcbLength: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPropByName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMBackupRestoreProps,
                pszName: ?[*:0]const u16,
                pType: ?*WMT_ATTR_DATATYPE,
                pValue: [*:0]u8,
                pcbLength: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMBackupRestoreProps,
                pszName: ?[*:0]const u16,
                pType: ?*WMT_ATTR_DATATYPE,
                pValue: [*:0]u8,
                pcbLength: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetProp: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMBackupRestoreProps,
                pszName: ?[*:0]const u16,
                Type: WMT_ATTR_DATATYPE,
                pValue: [*:0]const u8,
                cbLength: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMBackupRestoreProps,
                pszName: ?[*:0]const u16,
                Type: WMT_ATTR_DATATYPE,
                pValue: [*:0]const u8,
                cbLength: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveProp: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMBackupRestoreProps,
                pcwszName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMBackupRestoreProps,
                pcwszName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveAllProps: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMBackupRestoreProps,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMBackupRestoreProps,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMBackupRestoreProps_GetPropCount(self: *const T, pcProps: ?*u16) HRESULT {
                return @as(*const IWMBackupRestoreProps.VTable, @ptrCast(self.vtable)).GetPropCount(@as(*const IWMBackupRestoreProps, @ptrCast(self)), pcProps);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMBackupRestoreProps_GetPropByIndex(self: *const T, wIndex: u16, pwszName: [*:0]u16, pcchNameLen: ?*u16, pType: ?*WMT_ATTR_DATATYPE, pValue: [*:0]u8, pcbLength: ?*u16) HRESULT {
                return @as(*const IWMBackupRestoreProps.VTable, @ptrCast(self.vtable)).GetPropByIndex(@as(*const IWMBackupRestoreProps, @ptrCast(self)), wIndex, pwszName, pcchNameLen, pType, pValue, pcbLength);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMBackupRestoreProps_GetPropByName(self: *const T, pszName: ?[*:0]const u16, pType: ?*WMT_ATTR_DATATYPE, pValue: [*:0]u8, pcbLength: ?*u16) HRESULT {
                return @as(*const IWMBackupRestoreProps.VTable, @ptrCast(self.vtable)).GetPropByName(@as(*const IWMBackupRestoreProps, @ptrCast(self)), pszName, pType, pValue, pcbLength);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMBackupRestoreProps_SetProp(self: *const T, pszName: ?[*:0]const u16, Type: WMT_ATTR_DATATYPE, pValue: [*:0]const u8, cbLength: u16) HRESULT {
                return @as(*const IWMBackupRestoreProps.VTable, @ptrCast(self.vtable)).SetProp(@as(*const IWMBackupRestoreProps, @ptrCast(self)), pszName, Type, pValue, cbLength);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMBackupRestoreProps_RemoveProp(self: *const T, pcwszName: ?[*:0]const u16) HRESULT {
                return @as(*const IWMBackupRestoreProps.VTable, @ptrCast(self.vtable)).RemoveProp(@as(*const IWMBackupRestoreProps, @ptrCast(self)), pcwszName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMBackupRestoreProps_RemoveAllProps(self: *const T) HRESULT {
                return @as(*const IWMBackupRestoreProps.VTable, @ptrCast(self.vtable)).RemoveAllProps(@as(*const IWMBackupRestoreProps, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMCodecInfo_Value = Guid.initString("a970f41e-34de-4a98-b3ba-e4b3ca7528f0");
pub const IID_IWMCodecInfo = &IID_IWMCodecInfo_Value;
pub const IWMCodecInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCodecInfoCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMCodecInfo,
                guidType: ?*const Guid,
                pcCodecs: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMCodecInfo,
                guidType: ?*const Guid,
                pcCodecs: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCodecFormatCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMCodecInfo,
                guidType: ?*const Guid,
                dwCodecIndex: u32,
                pcFormat: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMCodecInfo,
                guidType: ?*const Guid,
                dwCodecIndex: u32,
                pcFormat: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCodecFormat: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMCodecInfo,
                guidType: ?*const Guid,
                dwCodecIndex: u32,
                dwFormatIndex: u32,
                ppIStreamConfig: ?*?*IWMStreamConfig,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMCodecInfo,
                guidType: ?*const Guid,
                dwCodecIndex: u32,
                dwFormatIndex: u32,
                ppIStreamConfig: ?*?*IWMStreamConfig,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMCodecInfo_GetCodecInfoCount(self: *const T, guidType: ?*const Guid, pcCodecs: ?*u32) HRESULT {
                return @as(*const IWMCodecInfo.VTable, @ptrCast(self.vtable)).GetCodecInfoCount(@as(*const IWMCodecInfo, @ptrCast(self)), guidType, pcCodecs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMCodecInfo_GetCodecFormatCount(self: *const T, guidType: ?*const Guid, dwCodecIndex: u32, pcFormat: ?*u32) HRESULT {
                return @as(*const IWMCodecInfo.VTable, @ptrCast(self.vtable)).GetCodecFormatCount(@as(*const IWMCodecInfo, @ptrCast(self)), guidType, dwCodecIndex, pcFormat);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMCodecInfo_GetCodecFormat(self: *const T, guidType: ?*const Guid, dwCodecIndex: u32, dwFormatIndex: u32, ppIStreamConfig: ?*?*IWMStreamConfig) HRESULT {
                return @as(*const IWMCodecInfo.VTable, @ptrCast(self.vtable)).GetCodecFormat(@as(*const IWMCodecInfo, @ptrCast(self)), guidType, dwCodecIndex, dwFormatIndex, ppIStreamConfig);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMCodecInfo2_Value = Guid.initString("aa65e273-b686-4056-91ec-dd768d4df710");
pub const IID_IWMCodecInfo2 = &IID_IWMCodecInfo2_Value;
pub const IWMCodecInfo2 = extern struct {
    pub const VTable = extern struct {
        base: IWMCodecInfo.VTable,
        GetCodecName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMCodecInfo2,
                guidType: ?*const Guid,
                dwCodecIndex: u32,
                wszName: [*:0]u16,
                pcchName: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMCodecInfo2,
                guidType: ?*const Guid,
                dwCodecIndex: u32,
                wszName: [*:0]u16,
                pcchName: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCodecFormatDesc: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMCodecInfo2,
                guidType: ?*const Guid,
                dwCodecIndex: u32,
                dwFormatIndex: u32,
                ppIStreamConfig: ?*?*IWMStreamConfig,
                wszDesc: [*:0]u16,
                pcchDesc: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMCodecInfo2,
                guidType: ?*const Guid,
                dwCodecIndex: u32,
                dwFormatIndex: u32,
                ppIStreamConfig: ?*?*IWMStreamConfig,
                wszDesc: [*:0]u16,
                pcchDesc: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWMCodecInfo.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMCodecInfo2_GetCodecName(self: *const T, guidType: ?*const Guid, dwCodecIndex: u32, wszName: [*:0]u16, pcchName: ?*u32) HRESULT {
                return @as(*const IWMCodecInfo2.VTable, @ptrCast(self.vtable)).GetCodecName(@as(*const IWMCodecInfo2, @ptrCast(self)), guidType, dwCodecIndex, wszName, pcchName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMCodecInfo2_GetCodecFormatDesc(self: *const T, guidType: ?*const Guid, dwCodecIndex: u32, dwFormatIndex: u32, ppIStreamConfig: ?*?*IWMStreamConfig, wszDesc: [*:0]u16, pcchDesc: ?*u32) HRESULT {
                return @as(*const IWMCodecInfo2.VTable, @ptrCast(self.vtable)).GetCodecFormatDesc(@as(*const IWMCodecInfo2, @ptrCast(self)), guidType, dwCodecIndex, dwFormatIndex, ppIStreamConfig, wszDesc, pcchDesc);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMCodecInfo3_Value = Guid.initString("7e51f487-4d93-4f98-8ab4-27d0565adc51");
pub const IID_IWMCodecInfo3 = &IID_IWMCodecInfo3_Value;
pub const IWMCodecInfo3 = extern struct {
    pub const VTable = extern struct {
        base: IWMCodecInfo2.VTable,
        GetCodecFormatProp: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMCodecInfo3,
                guidType: ?*const Guid,
                dwCodecIndex: u32,
                dwFormatIndex: u32,
                pszName: ?[*:0]const u16,
                pType: ?*WMT_ATTR_DATATYPE,
                pValue: [*:0]u8,
                pdwSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMCodecInfo3,
                guidType: ?*const Guid,
                dwCodecIndex: u32,
                dwFormatIndex: u32,
                pszName: ?[*:0]const u16,
                pType: ?*WMT_ATTR_DATATYPE,
                pValue: [*:0]u8,
                pdwSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCodecProp: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMCodecInfo3,
                guidType: ?*const Guid,
                dwCodecIndex: u32,
                pszName: ?[*:0]const u16,
                pType: ?*WMT_ATTR_DATATYPE,
                pValue: [*:0]u8,
                pdwSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMCodecInfo3,
                guidType: ?*const Guid,
                dwCodecIndex: u32,
                pszName: ?[*:0]const u16,
                pType: ?*WMT_ATTR_DATATYPE,
                pValue: [*:0]u8,
                pdwSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCodecEnumerationSetting: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMCodecInfo3,
                guidType: ?*const Guid,
                dwCodecIndex: u32,
                pszName: ?[*:0]const u16,
                Type: WMT_ATTR_DATATYPE,
                pValue: [*:0]const u8,
                dwSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMCodecInfo3,
                guidType: ?*const Guid,
                dwCodecIndex: u32,
                pszName: ?[*:0]const u16,
                Type: WMT_ATTR_DATATYPE,
                pValue: [*:0]const u8,
                dwSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCodecEnumerationSetting: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMCodecInfo3,
                guidType: ?*const Guid,
                dwCodecIndex: u32,
                pszName: ?[*:0]const u16,
                pType: ?*WMT_ATTR_DATATYPE,
                pValue: [*:0]u8,
                pdwSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMCodecInfo3,
                guidType: ?*const Guid,
                dwCodecIndex: u32,
                pszName: ?[*:0]const u16,
                pType: ?*WMT_ATTR_DATATYPE,
                pValue: [*:0]u8,
                pdwSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWMCodecInfo2.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMCodecInfo3_GetCodecFormatProp(self: *const T, guidType: ?*const Guid, dwCodecIndex: u32, dwFormatIndex: u32, pszName: ?[*:0]const u16, pType: ?*WMT_ATTR_DATATYPE, pValue: [*:0]u8, pdwSize: ?*u32) HRESULT {
                return @as(*const IWMCodecInfo3.VTable, @ptrCast(self.vtable)).GetCodecFormatProp(@as(*const IWMCodecInfo3, @ptrCast(self)), guidType, dwCodecIndex, dwFormatIndex, pszName, pType, pValue, pdwSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMCodecInfo3_GetCodecProp(self: *const T, guidType: ?*const Guid, dwCodecIndex: u32, pszName: ?[*:0]const u16, pType: ?*WMT_ATTR_DATATYPE, pValue: [*:0]u8, pdwSize: ?*u32) HRESULT {
                return @as(*const IWMCodecInfo3.VTable, @ptrCast(self.vtable)).GetCodecProp(@as(*const IWMCodecInfo3, @ptrCast(self)), guidType, dwCodecIndex, pszName, pType, pValue, pdwSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMCodecInfo3_SetCodecEnumerationSetting(self: *const T, guidType: ?*const Guid, dwCodecIndex: u32, pszName: ?[*:0]const u16, Type: WMT_ATTR_DATATYPE, pValue: [*:0]const u8, dwSize: u32) HRESULT {
                return @as(*const IWMCodecInfo3.VTable, @ptrCast(self.vtable)).SetCodecEnumerationSetting(@as(*const IWMCodecInfo3, @ptrCast(self)), guidType, dwCodecIndex, pszName, Type, pValue, dwSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMCodecInfo3_GetCodecEnumerationSetting(self: *const T, guidType: ?*const Guid, dwCodecIndex: u32, pszName: ?[*:0]const u16, pType: ?*WMT_ATTR_DATATYPE, pValue: [*:0]u8, pdwSize: ?*u32) HRESULT {
                return @as(*const IWMCodecInfo3.VTable, @ptrCast(self.vtable)).GetCodecEnumerationSetting(@as(*const IWMCodecInfo3, @ptrCast(self)), guidType, dwCodecIndex, pszName, pType, pValue, pdwSize);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMLanguageList_Value = Guid.initString("df683f00-2d49-4d8e-92b7-fb19f6a0dc57");
pub const IID_IWMLanguageList = &IID_IWMLanguageList_Value;
pub const IWMLanguageList = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetLanguageCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMLanguageList,
                pwCount: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMLanguageList,
                pwCount: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLanguageDetails: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMLanguageList,
                wIndex: u16,
                pwszLanguageString: [*:0]u16,
                pcchLanguageStringLength: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMLanguageList,
                wIndex: u16,
                pwszLanguageString: [*:0]u16,
                pcchLanguageStringLength: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddLanguageByRFC1766String: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMLanguageList,
                pwszLanguageString: ?PWSTR,
                pwIndex: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMLanguageList,
                pwszLanguageString: ?PWSTR,
                pwIndex: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMLanguageList_GetLanguageCount(self: *const T, pwCount: ?*u16) HRESULT {
                return @as(*const IWMLanguageList.VTable, @ptrCast(self.vtable)).GetLanguageCount(@as(*const IWMLanguageList, @ptrCast(self)), pwCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMLanguageList_GetLanguageDetails(self: *const T, wIndex: u16, pwszLanguageString: [*:0]u16, pcchLanguageStringLength: ?*u16) HRESULT {
                return @as(*const IWMLanguageList.VTable, @ptrCast(self.vtable)).GetLanguageDetails(@as(*const IWMLanguageList, @ptrCast(self)), wIndex, pwszLanguageString, pcchLanguageStringLength);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMLanguageList_AddLanguageByRFC1766String(self: *const T, pwszLanguageString: ?PWSTR, pwIndex: ?*u16) HRESULT {
                return @as(*const IWMLanguageList.VTable, @ptrCast(self.vtable)).AddLanguageByRFC1766String(@as(*const IWMLanguageList, @ptrCast(self)), pwszLanguageString, pwIndex);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMWriterPushSink_Value = Guid.initString("dc10e6a5-072c-467d-bf57-6330a9dde12a");
pub const IID_IWMWriterPushSink = &IID_IWMWriterPushSink_Value;
pub const IWMWriterPushSink = extern struct {
    pub const VTable = extern struct {
        base: IWMWriterSink.VTable,
        Connect: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMWriterPushSink,
                pwszURL: ?[*:0]const u16,
                pwszTemplateURL: ?[*:0]const u16,
                fAutoDestroy: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMWriterPushSink,
                pwszURL: ?[*:0]const u16,
                pwszTemplateURL: ?[*:0]const u16,
                fAutoDestroy: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Disconnect: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMWriterPushSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMWriterPushSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndSession: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMWriterPushSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMWriterPushSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWMWriterSink.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMWriterPushSink_Connect(self: *const T, pwszURL: ?[*:0]const u16, pwszTemplateURL: ?[*:0]const u16, fAutoDestroy: BOOL) HRESULT {
                return @as(*const IWMWriterPushSink.VTable, @ptrCast(self.vtable)).Connect(@as(*const IWMWriterPushSink, @ptrCast(self)), pwszURL, pwszTemplateURL, fAutoDestroy);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMWriterPushSink_Disconnect(self: *const T) HRESULT {
                return @as(*const IWMWriterPushSink.VTable, @ptrCast(self.vtable)).Disconnect(@as(*const IWMWriterPushSink, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMWriterPushSink_EndSession(self: *const T) HRESULT {
                return @as(*const IWMWriterPushSink.VTable, @ptrCast(self.vtable)).EndSession(@as(*const IWMWriterPushSink, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IWMDeviceRegistration_Value = Guid.initString("f6211f03-8d21-4e94-93e6-8510805f2d99");
pub const IID_IWMDeviceRegistration = &IID_IWMDeviceRegistration_Value;
pub const IWMDeviceRegistration = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RegisterDevice: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDeviceRegistration,
                dwRegisterType: u32,
                pbCertificate: [*:0]u8,
                cbCertificate: u32,
                SerialNumber: DRM_VAL16,
                ppDevice: ?*?*IWMRegisteredDevice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDeviceRegistration,
                dwRegisterType: u32,
                pbCertificate: [*:0]u8,
                cbCertificate: u32,
                SerialNumber: DRM_VAL16,
                ppDevice: ?*?*IWMRegisteredDevice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnregisterDevice: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDeviceRegistration,
                dwRegisterType: u32,
                pbCertificate: [*:0]u8,
                cbCertificate: u32,
                SerialNumber: DRM_VAL16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDeviceRegistration,
                dwRegisterType: u32,
                pbCertificate: [*:0]u8,
                cbCertificate: u32,
                SerialNumber: DRM_VAL16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRegistrationStats: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDeviceRegistration,
                dwRegisterType: u32,
                pcRegisteredDevices: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDeviceRegistration,
                dwRegisterType: u32,
                pcRegisteredDevices: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFirstRegisteredDevice: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDeviceRegistration,
                dwRegisterType: u32,
                ppDevice: ?*?*IWMRegisteredDevice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDeviceRegistration,
                dwRegisterType: u32,
                ppDevice: ?*?*IWMRegisteredDevice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNextRegisteredDevice: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDeviceRegistration,
                ppDevice: ?*?*IWMRegisteredDevice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDeviceRegistration,
                ppDevice: ?*?*IWMRegisteredDevice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRegisteredDeviceByID: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDeviceRegistration,
                dwRegisterType: u32,
                pbCertificate: [*:0]u8,
                cbCertificate: u32,
                SerialNumber: DRM_VAL16,
                ppDevice: ?*?*IWMRegisteredDevice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDeviceRegistration,
                dwRegisterType: u32,
                pbCertificate: [*:0]u8,
                cbCertificate: u32,
                SerialNumber: DRM_VAL16,
                ppDevice: ?*?*IWMRegisteredDevice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDeviceRegistration_RegisterDevice(self: *const T, dwRegisterType: u32, pbCertificate: [*:0]u8, cbCertificate: u32, SerialNumber: DRM_VAL16, ppDevice: ?*?*IWMRegisteredDevice) HRESULT {
                return @as(*const IWMDeviceRegistration.VTable, @ptrCast(self.vtable)).RegisterDevice(@as(*const IWMDeviceRegistration, @ptrCast(self)), dwRegisterType, pbCertificate, cbCertificate, SerialNumber, ppDevice);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDeviceRegistration_UnregisterDevice(self: *const T, dwRegisterType: u32, pbCertificate: [*:0]u8, cbCertificate: u32, SerialNumber: DRM_VAL16) HRESULT {
                return @as(*const IWMDeviceRegistration.VTable, @ptrCast(self.vtable)).UnregisterDevice(@as(*const IWMDeviceRegistration, @ptrCast(self)), dwRegisterType, pbCertificate, cbCertificate, SerialNumber);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDeviceRegistration_GetRegistrationStats(self: *const T, dwRegisterType: u32, pcRegisteredDevices: ?*u32) HRESULT {
                return @as(*const IWMDeviceRegistration.VTable, @ptrCast(self.vtable)).GetRegistrationStats(@as(*const IWMDeviceRegistration, @ptrCast(self)), dwRegisterType, pcRegisteredDevices);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDeviceRegistration_GetFirstRegisteredDevice(self: *const T, dwRegisterType: u32, ppDevice: ?*?*IWMRegisteredDevice) HRESULT {
                return @as(*const IWMDeviceRegistration.VTable, @ptrCast(self.vtable)).GetFirstRegisteredDevice(@as(*const IWMDeviceRegistration, @ptrCast(self)), dwRegisterType, ppDevice);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDeviceRegistration_GetNextRegisteredDevice(self: *const T, ppDevice: ?*?*IWMRegisteredDevice) HRESULT {
                return @as(*const IWMDeviceRegistration.VTable, @ptrCast(self.vtable)).GetNextRegisteredDevice(@as(*const IWMDeviceRegistration, @ptrCast(self)), ppDevice);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDeviceRegistration_GetRegisteredDeviceByID(self: *const T, dwRegisterType: u32, pbCertificate: [*:0]u8, cbCertificate: u32, SerialNumber: DRM_VAL16, ppDevice: ?*?*IWMRegisteredDevice) HRESULT {
                return @as(*const IWMDeviceRegistration.VTable, @ptrCast(self.vtable)).GetRegisteredDeviceByID(@as(*const IWMDeviceRegistration, @ptrCast(self)), dwRegisterType, pbCertificate, cbCertificate, SerialNumber, ppDevice);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMRegisteredDevice_Value = Guid.initString("a4503bec-5508-4148-97ac-bfa75760a70d");
pub const IID_IWMRegisteredDevice = &IID_IWMRegisteredDevice_Value;
pub const IWMRegisteredDevice = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDeviceSerialNumber: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMRegisteredDevice,
                pSerialNumber: ?*DRM_VAL16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMRegisteredDevice,
                pSerialNumber: ?*DRM_VAL16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDeviceCertificate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMRegisteredDevice,
                ppCertificate: ?*?*INSSBuffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMRegisteredDevice,
                ppCertificate: ?*?*INSSBuffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDeviceType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMRegisteredDevice,
                pdwType: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMRegisteredDevice,
                pdwType: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAttributeCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMRegisteredDevice,
                pcAttributes: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMRegisteredDevice,
                pcAttributes: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAttributeByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMRegisteredDevice,
                dwIndex: u32,
                pbstrName: ?*?BSTR,
                pbstrValue: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMRegisteredDevice,
                dwIndex: u32,
                pbstrName: ?*?BSTR,
                pbstrValue: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAttributeByName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMRegisteredDevice,
                bstrName: ?BSTR,
                pbstrValue: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMRegisteredDevice,
                bstrName: ?BSTR,
                pbstrValue: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetAttributeByName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMRegisteredDevice,
                bstrName: ?BSTR,
                bstrValue: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMRegisteredDevice,
                bstrName: ?BSTR,
                bstrValue: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Approve: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMRegisteredDevice,
                fApprove: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMRegisteredDevice,
                fApprove: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsValid: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMRegisteredDevice,
                pfValid: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMRegisteredDevice,
                pfValid: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsApproved: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMRegisteredDevice,
                pfApproved: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMRegisteredDevice,
                pfApproved: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsWmdrmCompliant: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMRegisteredDevice,
                pfCompliant: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMRegisteredDevice,
                pfCompliant: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsOpened: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMRegisteredDevice,
                pfOpened: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMRegisteredDevice,
                pfOpened: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Open: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMRegisteredDevice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMRegisteredDevice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Close: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMRegisteredDevice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMRegisteredDevice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMRegisteredDevice_GetDeviceSerialNumber(self: *const T, pSerialNumber: ?*DRM_VAL16) HRESULT {
                return @as(*const IWMRegisteredDevice.VTable, @ptrCast(self.vtable)).GetDeviceSerialNumber(@as(*const IWMRegisteredDevice, @ptrCast(self)), pSerialNumber);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMRegisteredDevice_GetDeviceCertificate(self: *const T, ppCertificate: ?*?*INSSBuffer) HRESULT {
                return @as(*const IWMRegisteredDevice.VTable, @ptrCast(self.vtable)).GetDeviceCertificate(@as(*const IWMRegisteredDevice, @ptrCast(self)), ppCertificate);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMRegisteredDevice_GetDeviceType(self: *const T, pdwType: ?*u32) HRESULT {
                return @as(*const IWMRegisteredDevice.VTable, @ptrCast(self.vtable)).GetDeviceType(@as(*const IWMRegisteredDevice, @ptrCast(self)), pdwType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMRegisteredDevice_GetAttributeCount(self: *const T, pcAttributes: ?*u32) HRESULT {
                return @as(*const IWMRegisteredDevice.VTable, @ptrCast(self.vtable)).GetAttributeCount(@as(*const IWMRegisteredDevice, @ptrCast(self)), pcAttributes);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMRegisteredDevice_GetAttributeByIndex(self: *const T, dwIndex: u32, pbstrName: ?*?BSTR, pbstrValue: ?*?BSTR) HRESULT {
                return @as(*const IWMRegisteredDevice.VTable, @ptrCast(self.vtable)).GetAttributeByIndex(@as(*const IWMRegisteredDevice, @ptrCast(self)), dwIndex, pbstrName, pbstrValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMRegisteredDevice_GetAttributeByName(self: *const T, bstrName: ?BSTR, pbstrValue: ?*?BSTR) HRESULT {
                return @as(*const IWMRegisteredDevice.VTable, @ptrCast(self.vtable)).GetAttributeByName(@as(*const IWMRegisteredDevice, @ptrCast(self)), bstrName, pbstrValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMRegisteredDevice_SetAttributeByName(self: *const T, bstrName: ?BSTR, bstrValue: ?BSTR) HRESULT {
                return @as(*const IWMRegisteredDevice.VTable, @ptrCast(self.vtable)).SetAttributeByName(@as(*const IWMRegisteredDevice, @ptrCast(self)), bstrName, bstrValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMRegisteredDevice_Approve(self: *const T, fApprove: BOOL) HRESULT {
                return @as(*const IWMRegisteredDevice.VTable, @ptrCast(self.vtable)).Approve(@as(*const IWMRegisteredDevice, @ptrCast(self)), fApprove);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMRegisteredDevice_IsValid(self: *const T, pfValid: ?*BOOL) HRESULT {
                return @as(*const IWMRegisteredDevice.VTable, @ptrCast(self.vtable)).IsValid(@as(*const IWMRegisteredDevice, @ptrCast(self)), pfValid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMRegisteredDevice_IsApproved(self: *const T, pfApproved: ?*BOOL) HRESULT {
                return @as(*const IWMRegisteredDevice.VTable, @ptrCast(self.vtable)).IsApproved(@as(*const IWMRegisteredDevice, @ptrCast(self)), pfApproved);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMRegisteredDevice_IsWmdrmCompliant(self: *const T, pfCompliant: ?*BOOL) HRESULT {
                return @as(*const IWMRegisteredDevice.VTable, @ptrCast(self.vtable)).IsWmdrmCompliant(@as(*const IWMRegisteredDevice, @ptrCast(self)), pfCompliant);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMRegisteredDevice_IsOpened(self: *const T, pfOpened: ?*BOOL) HRESULT {
                return @as(*const IWMRegisteredDevice.VTable, @ptrCast(self.vtable)).IsOpened(@as(*const IWMRegisteredDevice, @ptrCast(self)), pfOpened);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMRegisteredDevice_Open(self: *const T) HRESULT {
                return @as(*const IWMRegisteredDevice.VTable, @ptrCast(self.vtable)).Open(@as(*const IWMRegisteredDevice, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMRegisteredDevice_Close(self: *const T) HRESULT {
                return @as(*const IWMRegisteredDevice.VTable, @ptrCast(self.vtable)).Close(@as(*const IWMRegisteredDevice, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IWMProximityDetection_Value = Guid.initString("6a9fd8ee-b651-4bf0-b849-7d4ece79a2b1");
pub const IID_IWMProximityDetection = &IID_IWMProximityDetection_Value;
pub const IWMProximityDetection = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        StartDetection: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMProximityDetection,
                pbRegistrationMsg: [*:0]u8,
                cbRegistrationMsg: u32,
                pbLocalAddress: [*:0]u8,
                cbLocalAddress: u32,
                dwExtraPortsAllowed: u32,
                ppRegistrationResponseMsg: ?*?*INSSBuffer,
                pCallback: ?*IWMStatusCallback,
                pvContext: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMProximityDetection,
                pbRegistrationMsg: [*:0]u8,
                cbRegistrationMsg: u32,
                pbLocalAddress: [*:0]u8,
                cbLocalAddress: u32,
                dwExtraPortsAllowed: u32,
                ppRegistrationResponseMsg: ?*?*INSSBuffer,
                pCallback: ?*IWMStatusCallback,
                pvContext: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMProximityDetection_StartDetection(self: *const T, pbRegistrationMsg: [*:0]u8, cbRegistrationMsg: u32, pbLocalAddress: [*:0]u8, cbLocalAddress: u32, dwExtraPortsAllowed: u32, ppRegistrationResponseMsg: ?*?*INSSBuffer, pCallback: ?*IWMStatusCallback, pvContext: ?*anyopaque) HRESULT {
                return @as(*const IWMProximityDetection.VTable, @ptrCast(self.vtable)).StartDetection(@as(*const IWMProximityDetection, @ptrCast(self)), pbRegistrationMsg, cbRegistrationMsg, pbLocalAddress, cbLocalAddress, dwExtraPortsAllowed, ppRegistrationResponseMsg, pCallback, pvContext);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IWMDRMMessageParser_Value = Guid.initString("a73a0072-25a0-4c99-b4a5-ede8101a6c39");
pub const IID_IWMDRMMessageParser = &IID_IWMDRMMessageParser_Value;
pub const IWMDRMMessageParser = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ParseRegistrationReqMsg: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDRMMessageParser,
                pbRegistrationReqMsg: [*:0]u8,
                cbRegistrationReqMsg: u32,
                ppDeviceCert: ?*?*INSSBuffer,
                pDeviceSerialNumber: ?*DRM_VAL16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDRMMessageParser,
                pbRegistrationReqMsg: [*:0]u8,
                cbRegistrationReqMsg: u32,
                ppDeviceCert: ?*?*INSSBuffer,
                pDeviceSerialNumber: ?*DRM_VAL16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ParseLicenseRequestMsg: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDRMMessageParser,
                pbLicenseRequestMsg: [*:0]u8,
                cbLicenseRequestMsg: u32,
                ppDeviceCert: ?*?*INSSBuffer,
                pDeviceSerialNumber: ?*DRM_VAL16,
                pbstrAction: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDRMMessageParser,
                pbLicenseRequestMsg: [*:0]u8,
                cbLicenseRequestMsg: u32,
                ppDeviceCert: ?*?*INSSBuffer,
                pDeviceSerialNumber: ?*DRM_VAL16,
                pbstrAction: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDRMMessageParser_ParseRegistrationReqMsg(self: *const T, pbRegistrationReqMsg: [*:0]u8, cbRegistrationReqMsg: u32, ppDeviceCert: ?*?*INSSBuffer, pDeviceSerialNumber: ?*DRM_VAL16) HRESULT {
                return @as(*const IWMDRMMessageParser.VTable, @ptrCast(self.vtable)).ParseRegistrationReqMsg(@as(*const IWMDRMMessageParser, @ptrCast(self)), pbRegistrationReqMsg, cbRegistrationReqMsg, ppDeviceCert, pDeviceSerialNumber);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDRMMessageParser_ParseLicenseRequestMsg(self: *const T, pbLicenseRequestMsg: [*:0]u8, cbLicenseRequestMsg: u32, ppDeviceCert: ?*?*INSSBuffer, pDeviceSerialNumber: ?*DRM_VAL16, pbstrAction: ?*?BSTR) HRESULT {
                return @as(*const IWMDRMMessageParser.VTable, @ptrCast(self.vtable)).ParseLicenseRequestMsg(@as(*const IWMDRMMessageParser, @ptrCast(self)), pbLicenseRequestMsg, cbLicenseRequestMsg, ppDeviceCert, pDeviceSerialNumber, pbstrAction);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IWMDRMTranscryptor_Value = Guid.initString("69059850-6e6f-4bb2-806f-71863ddfc471");
pub const IID_IWMDRMTranscryptor = &IID_IWMDRMTranscryptor_Value;
pub const IWMDRMTranscryptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDRMTranscryptor,
                bstrFileName: ?BSTR,
                pbLicenseRequestMsg: ?*u8,
                cbLicenseRequestMsg: u32,
                ppLicenseResponseMsg: ?*?*INSSBuffer,
                pCallback: ?*IWMStatusCallback,
                pvContext: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDRMTranscryptor,
                bstrFileName: ?BSTR,
                pbLicenseRequestMsg: ?*u8,
                cbLicenseRequestMsg: u32,
                ppLicenseResponseMsg: ?*?*INSSBuffer,
                pCallback: ?*IWMStatusCallback,
                pvContext: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Seek: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDRMTranscryptor,
                hnsTime: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDRMTranscryptor,
                hnsTime: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Read: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDRMTranscryptor,
                pbData: ?*u8,
                pcbData: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDRMTranscryptor,
                pbData: ?*u8,
                pcbData: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Close: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDRMTranscryptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDRMTranscryptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDRMTranscryptor_Initialize(self: *const T, bstrFileName: ?BSTR, pbLicenseRequestMsg: ?*u8, cbLicenseRequestMsg: u32, ppLicenseResponseMsg: ?*?*INSSBuffer, pCallback: ?*IWMStatusCallback, pvContext: ?*anyopaque) HRESULT {
                return @as(*const IWMDRMTranscryptor.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IWMDRMTranscryptor, @ptrCast(self)), bstrFileName, pbLicenseRequestMsg, cbLicenseRequestMsg, ppLicenseResponseMsg, pCallback, pvContext);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDRMTranscryptor_Seek(self: *const T, hnsTime: u64) HRESULT {
                return @as(*const IWMDRMTranscryptor.VTable, @ptrCast(self.vtable)).Seek(@as(*const IWMDRMTranscryptor, @ptrCast(self)), hnsTime);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDRMTranscryptor_Read(self: *const T, pbData: ?*u8, pcbData: ?*u32) HRESULT {
                return @as(*const IWMDRMTranscryptor.VTable, @ptrCast(self.vtable)).Read(@as(*const IWMDRMTranscryptor, @ptrCast(self)), pbData, pcbData);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDRMTranscryptor_Close(self: *const T) HRESULT {
                return @as(*const IWMDRMTranscryptor.VTable, @ptrCast(self.vtable)).Close(@as(*const IWMDRMTranscryptor, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMDRMTranscryptor2_Value = Guid.initString("e0da439f-d331-496a-bece-18e5bac5dd23");
pub const IID_IWMDRMTranscryptor2 = &IID_IWMDRMTranscryptor2_Value;
pub const IWMDRMTranscryptor2 = extern struct {
    pub const VTable = extern struct {
        base: IWMDRMTranscryptor.VTable,
        SeekEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDRMTranscryptor2,
                cnsStartTime: u64,
                cnsDuration: u64,
                flRate: f32,
                fIncludeFileHeader: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDRMTranscryptor2,
                cnsStartTime: u64,
                cnsDuration: u64,
                flRate: f32,
                fIncludeFileHeader: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ZeroAdjustTimestamps: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDRMTranscryptor2,
                fEnable: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDRMTranscryptor2,
                fEnable: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSeekStartTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDRMTranscryptor2,
                pcnsTime: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDRMTranscryptor2,
                pcnsTime: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDuration: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDRMTranscryptor2,
                pcnsDuration: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDRMTranscryptor2,
                pcnsDuration: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWMDRMTranscryptor.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDRMTranscryptor2_SeekEx(self: *const T, cnsStartTime: u64, cnsDuration: u64, flRate: f32, fIncludeFileHeader: BOOL) HRESULT {
                return @as(*const IWMDRMTranscryptor2.VTable, @ptrCast(self.vtable)).SeekEx(@as(*const IWMDRMTranscryptor2, @ptrCast(self)), cnsStartTime, cnsDuration, flRate, fIncludeFileHeader);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDRMTranscryptor2_ZeroAdjustTimestamps(self: *const T, fEnable: BOOL) HRESULT {
                return @as(*const IWMDRMTranscryptor2.VTable, @ptrCast(self.vtable)).ZeroAdjustTimestamps(@as(*const IWMDRMTranscryptor2, @ptrCast(self)), fEnable);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDRMTranscryptor2_GetSeekStartTime(self: *const T, pcnsTime: ?*u64) HRESULT {
                return @as(*const IWMDRMTranscryptor2.VTable, @ptrCast(self.vtable)).GetSeekStartTime(@as(*const IWMDRMTranscryptor2, @ptrCast(self)), pcnsTime);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDRMTranscryptor2_GetDuration(self: *const T, pcnsDuration: ?*u64) HRESULT {
                return @as(*const IWMDRMTranscryptor2.VTable, @ptrCast(self.vtable)).GetDuration(@as(*const IWMDRMTranscryptor2, @ptrCast(self)), pcnsDuration);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMDRMTranscryptionManager_Value = Guid.initString("b1a887b2-a4f0-407a-b02e-efbd23bbecdf");
pub const IID_IWMDRMTranscryptionManager = &IID_IWMDRMTranscryptionManager_Value;
pub const IWMDRMTranscryptionManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateTranscryptor: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDRMTranscryptionManager,
                ppTranscryptor: ?*?*IWMDRMTranscryptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDRMTranscryptionManager,
                ppTranscryptor: ?*?*IWMDRMTranscryptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDRMTranscryptionManager_CreateTranscryptor(self: *const T, ppTranscryptor: ?*?*IWMDRMTranscryptor) HRESULT {
                return @as(*const IWMDRMTranscryptionManager.VTable, @ptrCast(self.vtable)).CreateTranscryptor(@as(*const IWMDRMTranscryptionManager, @ptrCast(self)), ppTranscryptor);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMWatermarkInfo_Value = Guid.initString("6f497062-f2e2-4624-8ea7-9dd40d81fc8d");
pub const IID_IWMWatermarkInfo = &IID_IWMWatermarkInfo_Value;
pub const IWMWatermarkInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetWatermarkEntryCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMWatermarkInfo,
                wmetType: WMT_WATERMARK_ENTRY_TYPE,
                pdwCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMWatermarkInfo,
                wmetType: WMT_WATERMARK_ENTRY_TYPE,
                pdwCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetWatermarkEntry: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMWatermarkInfo,
                wmetType: WMT_WATERMARK_ENTRY_TYPE,
                dwEntryNum: u32,
                pEntry: ?*WMT_WATERMARK_ENTRY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMWatermarkInfo,
                wmetType: WMT_WATERMARK_ENTRY_TYPE,
                dwEntryNum: u32,
                pEntry: ?*WMT_WATERMARK_ENTRY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMWatermarkInfo_GetWatermarkEntryCount(self: *const T, wmetType: WMT_WATERMARK_ENTRY_TYPE, pdwCount: ?*u32) HRESULT {
                return @as(*const IWMWatermarkInfo.VTable, @ptrCast(self.vtable)).GetWatermarkEntryCount(@as(*const IWMWatermarkInfo, @ptrCast(self)), wmetType, pdwCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMWatermarkInfo_GetWatermarkEntry(self: *const T, wmetType: WMT_WATERMARK_ENTRY_TYPE, dwEntryNum: u32, pEntry: ?*WMT_WATERMARK_ENTRY) HRESULT {
                return @as(*const IWMWatermarkInfo.VTable, @ptrCast(self.vtable)).GetWatermarkEntry(@as(*const IWMWatermarkInfo, @ptrCast(self)), wmetType, dwEntryNum, pEntry);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMReaderAccelerator_Value = Guid.initString("bddc4d08-944d-4d52-a612-46c3fda07dd4");
pub const IID_IWMReaderAccelerator = &IID_IWMReaderAccelerator_Value;
pub const IWMReaderAccelerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCodecInterface: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderAccelerator,
                dwOutputNum: u32,
                riid: ?*const Guid,
                ppvCodecInterface: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderAccelerator,
                dwOutputNum: u32,
                riid: ?*const Guid,
                ppvCodecInterface: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Notify: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderAccelerator,
                dwOutputNum: u32,
                pSubtype: ?*WM_MEDIA_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderAccelerator,
                dwOutputNum: u32,
                pSubtype: ?*WM_MEDIA_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderAccelerator_GetCodecInterface(self: *const T, dwOutputNum: u32, riid: ?*const Guid, ppvCodecInterface: ?*?*anyopaque) HRESULT {
                return @as(*const IWMReaderAccelerator.VTable, @ptrCast(self.vtable)).GetCodecInterface(@as(*const IWMReaderAccelerator, @ptrCast(self)), dwOutputNum, riid, ppvCodecInterface);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderAccelerator_Notify(self: *const T, dwOutputNum: u32, pSubtype: ?*WM_MEDIA_TYPE) HRESULT {
                return @as(*const IWMReaderAccelerator.VTable, @ptrCast(self.vtable)).Notify(@as(*const IWMReaderAccelerator, @ptrCast(self)), dwOutputNum, pSubtype);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMReaderTimecode_Value = Guid.initString("f369e2f0-e081-4fe6-8450-b810b2f410d1");
pub const IID_IWMReaderTimecode = &IID_IWMReaderTimecode_Value;
pub const IWMReaderTimecode = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTimecodeRangeCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderTimecode,
                wStreamNum: u16,
                pwRangeCount: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderTimecode,
                wStreamNum: u16,
                pwRangeCount: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTimecodeRangeBounds: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMReaderTimecode,
                wStreamNum: u16,
                wRangeNum: u16,
                pStartTimecode: ?*u32,
                pEndTimecode: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMReaderTimecode,
                wStreamNum: u16,
                wRangeNum: u16,
                pStartTimecode: ?*u32,
                pEndTimecode: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderTimecode_GetTimecodeRangeCount(self: *const T, wStreamNum: u16, pwRangeCount: ?*u16) HRESULT {
                return @as(*const IWMReaderTimecode.VTable, @ptrCast(self.vtable)).GetTimecodeRangeCount(@as(*const IWMReaderTimecode, @ptrCast(self)), wStreamNum, pwRangeCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMReaderTimecode_GetTimecodeRangeBounds(self: *const T, wStreamNum: u16, wRangeNum: u16, pStartTimecode: ?*u32, pEndTimecode: ?*u32) HRESULT {
                return @as(*const IWMReaderTimecode.VTable, @ptrCast(self.vtable)).GetTimecodeRangeBounds(@as(*const IWMReaderTimecode, @ptrCast(self)), wStreamNum, wRangeNum, pStartTimecode, pEndTimecode);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMAddressAccess_Value = Guid.initString("bb3c6389-1633-4e92-af14-9f3173ba39d0");
pub const IID_IWMAddressAccess = &IID_IWMAddressAccess_Value;
pub const IWMAddressAccess = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetAccessEntryCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMAddressAccess,
                aeType: WM_AETYPE,
                pcEntries: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMAddressAccess,
                aeType: WM_AETYPE,
                pcEntries: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAccessEntry: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMAddressAccess,
                aeType: WM_AETYPE,
                dwEntryNum: u32,
                pAddrAccessEntry: ?*WM_ADDRESS_ACCESSENTRY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMAddressAccess,
                aeType: WM_AETYPE,
                dwEntryNum: u32,
                pAddrAccessEntry: ?*WM_ADDRESS_ACCESSENTRY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddAccessEntry: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMAddressAccess,
                aeType: WM_AETYPE,
                pAddrAccessEntry: ?*WM_ADDRESS_ACCESSENTRY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMAddressAccess,
                aeType: WM_AETYPE,
                pAddrAccessEntry: ?*WM_ADDRESS_ACCESSENTRY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveAccessEntry: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMAddressAccess,
                aeType: WM_AETYPE,
                dwEntryNum: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMAddressAccess,
                aeType: WM_AETYPE,
                dwEntryNum: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMAddressAccess_GetAccessEntryCount(self: *const T, aeType: WM_AETYPE, pcEntries: ?*u32) HRESULT {
                return @as(*const IWMAddressAccess.VTable, @ptrCast(self.vtable)).GetAccessEntryCount(@as(*const IWMAddressAccess, @ptrCast(self)), aeType, pcEntries);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMAddressAccess_GetAccessEntry(self: *const T, aeType: WM_AETYPE, dwEntryNum: u32, pAddrAccessEntry: ?*WM_ADDRESS_ACCESSENTRY) HRESULT {
                return @as(*const IWMAddressAccess.VTable, @ptrCast(self.vtable)).GetAccessEntry(@as(*const IWMAddressAccess, @ptrCast(self)), aeType, dwEntryNum, pAddrAccessEntry);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMAddressAccess_AddAccessEntry(self: *const T, aeType: WM_AETYPE, pAddrAccessEntry: ?*WM_ADDRESS_ACCESSENTRY) HRESULT {
                return @as(*const IWMAddressAccess.VTable, @ptrCast(self.vtable)).AddAccessEntry(@as(*const IWMAddressAccess, @ptrCast(self)), aeType, pAddrAccessEntry);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMAddressAccess_RemoveAccessEntry(self: *const T, aeType: WM_AETYPE, dwEntryNum: u32) HRESULT {
                return @as(*const IWMAddressAccess.VTable, @ptrCast(self.vtable)).RemoveAccessEntry(@as(*const IWMAddressAccess, @ptrCast(self)), aeType, dwEntryNum);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMAddressAccess2_Value = Guid.initString("65a83fc2-3e98-4d4d-81b5-2a742886b33d");
pub const IID_IWMAddressAccess2 = &IID_IWMAddressAccess2_Value;
pub const IWMAddressAccess2 = extern struct {
    pub const VTable = extern struct {
        base: IWMAddressAccess.VTable,
        GetAccessEntryEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMAddressAccess2,
                aeType: WM_AETYPE,
                dwEntryNum: u32,
                pbstrAddress: ?*?BSTR,
                pbstrMask: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMAddressAccess2,
                aeType: WM_AETYPE,
                dwEntryNum: u32,
                pbstrAddress: ?*?BSTR,
                pbstrMask: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddAccessEntryEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMAddressAccess2,
                aeType: WM_AETYPE,
                bstrAddress: ?BSTR,
                bstrMask: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMAddressAccess2,
                aeType: WM_AETYPE,
                bstrAddress: ?BSTR,
                bstrMask: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWMAddressAccess.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMAddressAccess2_GetAccessEntryEx(self: *const T, aeType: WM_AETYPE, dwEntryNum: u32, pbstrAddress: ?*?BSTR, pbstrMask: ?*?BSTR) HRESULT {
                return @as(*const IWMAddressAccess2.VTable, @ptrCast(self.vtable)).GetAccessEntryEx(@as(*const IWMAddressAccess2, @ptrCast(self)), aeType, dwEntryNum, pbstrAddress, pbstrMask);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMAddressAccess2_AddAccessEntryEx(self: *const T, aeType: WM_AETYPE, bstrAddress: ?BSTR, bstrMask: ?BSTR) HRESULT {
                return @as(*const IWMAddressAccess2.VTable, @ptrCast(self.vtable)).AddAccessEntryEx(@as(*const IWMAddressAccess2, @ptrCast(self)), aeType, bstrAddress, bstrMask);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMImageInfo_Value = Guid.initString("9f0aa3b6-7267-4d89-88f2-ba915aa5c4c6");
pub const IID_IWMImageInfo = &IID_IWMImageInfo_Value;
pub const IWMImageInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetImageCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMImageInfo,
                pcImages: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMImageInfo,
                pcImages: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetImage: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMImageInfo,
                wIndex: u32,
                pcchMIMEType: ?*u16,
                pwszMIMEType: [*:0]u16,
                pcchDescription: ?*u16,
                pwszDescription: [*:0]u16,
                pImageType: ?*u16,
                pcbImageData: ?*u32,
                pbImageData: [*:0]u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMImageInfo,
                wIndex: u32,
                pcchMIMEType: ?*u16,
                pwszMIMEType: [*:0]u16,
                pcchDescription: ?*u16,
                pwszDescription: [*:0]u16,
                pImageType: ?*u16,
                pcbImageData: ?*u32,
                pbImageData: [*:0]u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMImageInfo_GetImageCount(self: *const T, pcImages: ?*u32) HRESULT {
                return @as(*const IWMImageInfo.VTable, @ptrCast(self.vtable)).GetImageCount(@as(*const IWMImageInfo, @ptrCast(self)), pcImages);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMImageInfo_GetImage(self: *const T, wIndex: u32, pcchMIMEType: ?*u16, pwszMIMEType: [*:0]u16, pcchDescription: ?*u16, pwszDescription: [*:0]u16, pImageType: ?*u16, pcbImageData: ?*u32, pbImageData: [*:0]u8) HRESULT {
                return @as(*const IWMImageInfo.VTable, @ptrCast(self.vtable)).GetImage(@as(*const IWMImageInfo, @ptrCast(self)), wIndex, pcchMIMEType, pwszMIMEType, pcchDescription, pwszDescription, pImageType, pcbImageData, pbImageData);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMLicenseRevocationAgent_Value = Guid.initString("6967f2c9-4e26-4b57-8894-799880f7ac7b");
pub const IID_IWMLicenseRevocationAgent = &IID_IWMLicenseRevocationAgent_Value;
pub const IWMLicenseRevocationAgent = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetLRBChallenge: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMLicenseRevocationAgent,
                pMachineID: ?*u8,
                dwMachineIDLength: u32,
                pChallenge: ?*u8,
                dwChallengeLength: u32,
                pChallengeOutput: ?*u8,
                pdwChallengeOutputLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMLicenseRevocationAgent,
                pMachineID: ?*u8,
                dwMachineIDLength: u32,
                pChallenge: ?*u8,
                dwChallengeLength: u32,
                pChallengeOutput: ?*u8,
                pdwChallengeOutputLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ProcessLRB: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMLicenseRevocationAgent,
                pSignedLRB: ?*u8,
                dwSignedLRBLength: u32,
                pSignedACK: ?*u8,
                pdwSignedACKLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMLicenseRevocationAgent,
                pSignedLRB: ?*u8,
                dwSignedLRBLength: u32,
                pSignedACK: ?*u8,
                pdwSignedACKLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMLicenseRevocationAgent_GetLRBChallenge(self: *const T, pMachineID: ?*u8, dwMachineIDLength: u32, pChallenge: ?*u8, dwChallengeLength: u32, pChallengeOutput: ?*u8, pdwChallengeOutputLength: ?*u32) HRESULT {
                return @as(*const IWMLicenseRevocationAgent.VTable, @ptrCast(self.vtable)).GetLRBChallenge(@as(*const IWMLicenseRevocationAgent, @ptrCast(self)), pMachineID, dwMachineIDLength, pChallenge, dwChallengeLength, pChallengeOutput, pdwChallengeOutputLength);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMLicenseRevocationAgent_ProcessLRB(self: *const T, pSignedLRB: ?*u8, dwSignedLRBLength: u32, pSignedACK: ?*u8, pdwSignedACKLength: ?*u32) HRESULT {
                return @as(*const IWMLicenseRevocationAgent.VTable, @ptrCast(self.vtable)).ProcessLRB(@as(*const IWMLicenseRevocationAgent, @ptrCast(self)), pSignedLRB, dwSignedLRBLength, pSignedACK, pdwSignedACKLength);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IWMAuthorizer_Value = Guid.initString("d9b67d36-a9ad-4eb4-baef-db284ef5504c");
pub const IID_IWMAuthorizer = &IID_IWMAuthorizer_Value;
pub const IWMAuthorizer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCertCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMAuthorizer,
                pcCerts: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMAuthorizer,
                pcCerts: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCert: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMAuthorizer,
                dwIndex: u32,
                ppbCertData: ?*?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMAuthorizer,
                dwIndex: u32,
                ppbCertData: ?*?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSharedData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMAuthorizer,
                dwCertIndex: u32,
                pbSharedData: ?*const u8,
                pbCert: ?*u8,
                ppbSharedData: ?*?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMAuthorizer,
                dwCertIndex: u32,
                pbSharedData: ?*const u8,
                pbCert: ?*u8,
                ppbSharedData: ?*?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMAuthorizer_GetCertCount(self: *const T, pcCerts: ?*u32) HRESULT {
                return @as(*const IWMAuthorizer.VTable, @ptrCast(self.vtable)).GetCertCount(@as(*const IWMAuthorizer, @ptrCast(self)), pcCerts);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMAuthorizer_GetCert(self: *const T, dwIndex: u32, ppbCertData: ?*?*u8) HRESULT {
                return @as(*const IWMAuthorizer.VTable, @ptrCast(self.vtable)).GetCert(@as(*const IWMAuthorizer, @ptrCast(self)), dwIndex, ppbCertData);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMAuthorizer_GetSharedData(self: *const T, dwCertIndex: u32, pbSharedData: ?*const u8, pbCert: ?*u8, ppbSharedData: ?*?*u8) HRESULT {
                return @as(*const IWMAuthorizer.VTable, @ptrCast(self.vtable)).GetSharedData(@as(*const IWMAuthorizer, @ptrCast(self)), dwCertIndex, pbSharedData, pbCert, ppbSharedData);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IWMSecureChannel_Value = Guid.initString("2720598a-d0f2-4189-bd10-91c46ef0936f");
pub const IID_IWMSecureChannel = &IID_IWMSecureChannel_Value;
pub const IWMSecureChannel = extern struct {
    pub const VTable = extern struct {
        base: IWMAuthorizer.VTable,
        WMSC_AddCertificate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMSecureChannel,
                pCert: ?*IWMAuthorizer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMSecureChannel,
                pCert: ?*IWMAuthorizer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WMSC_AddSignature: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMSecureChannel,
                pbCertSig: ?*u8,
                cbCertSig: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMSecureChannel,
                pbCertSig: ?*u8,
                cbCertSig: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WMSC_Connect: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMSecureChannel,
                pOtherSide: ?*IWMSecureChannel,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMSecureChannel,
                pOtherSide: ?*IWMSecureChannel,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WMSC_IsConnected: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMSecureChannel,
                pfIsConnected: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMSecureChannel,
                pfIsConnected: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WMSC_Disconnect: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMSecureChannel,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMSecureChannel,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WMSC_GetValidCertificate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMSecureChannel,
                ppbCertificate: ?*?*u8,
                pdwSignature: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMSecureChannel,
                ppbCertificate: ?*?*u8,
                pdwSignature: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WMSC_Encrypt: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMSecureChannel,
                pbData: ?*u8,
                cbData: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMSecureChannel,
                pbData: ?*u8,
                cbData: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WMSC_Decrypt: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMSecureChannel,
                pbData: ?*u8,
                cbData: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMSecureChannel,
                pbData: ?*u8,
                cbData: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WMSC_Lock: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMSecureChannel,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMSecureChannel,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WMSC_Unlock: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMSecureChannel,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMSecureChannel,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WMSC_SetSharedData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMSecureChannel,
                dwCertIndex: u32,
                pbSharedData: ?*const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMSecureChannel,
                dwCertIndex: u32,
                pbSharedData: ?*const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWMAuthorizer.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMSecureChannel_WMSC_AddCertificate(self: *const T, pCert: ?*IWMAuthorizer) HRESULT {
                return @as(*const IWMSecureChannel.VTable, @ptrCast(self.vtable)).WMSC_AddCertificate(@as(*const IWMSecureChannel, @ptrCast(self)), pCert);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMSecureChannel_WMSC_AddSignature(self: *const T, pbCertSig: ?*u8, cbCertSig: u32) HRESULT {
                return @as(*const IWMSecureChannel.VTable, @ptrCast(self.vtable)).WMSC_AddSignature(@as(*const IWMSecureChannel, @ptrCast(self)), pbCertSig, cbCertSig);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMSecureChannel_WMSC_Connect(self: *const T, pOtherSide: ?*IWMSecureChannel) HRESULT {
                return @as(*const IWMSecureChannel.VTable, @ptrCast(self.vtable)).WMSC_Connect(@as(*const IWMSecureChannel, @ptrCast(self)), pOtherSide);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMSecureChannel_WMSC_IsConnected(self: *const T, pfIsConnected: ?*BOOL) HRESULT {
                return @as(*const IWMSecureChannel.VTable, @ptrCast(self.vtable)).WMSC_IsConnected(@as(*const IWMSecureChannel, @ptrCast(self)), pfIsConnected);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMSecureChannel_WMSC_Disconnect(self: *const T) HRESULT {
                return @as(*const IWMSecureChannel.VTable, @ptrCast(self.vtable)).WMSC_Disconnect(@as(*const IWMSecureChannel, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMSecureChannel_WMSC_GetValidCertificate(self: *const T, ppbCertificate: ?*?*u8, pdwSignature: ?*u32) HRESULT {
                return @as(*const IWMSecureChannel.VTable, @ptrCast(self.vtable)).WMSC_GetValidCertificate(@as(*const IWMSecureChannel, @ptrCast(self)), ppbCertificate, pdwSignature);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMSecureChannel_WMSC_Encrypt(self: *const T, pbData: ?*u8, cbData: u32) HRESULT {
                return @as(*const IWMSecureChannel.VTable, @ptrCast(self.vtable)).WMSC_Encrypt(@as(*const IWMSecureChannel, @ptrCast(self)), pbData, cbData);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMSecureChannel_WMSC_Decrypt(self: *const T, pbData: ?*u8, cbData: u32) HRESULT {
                return @as(*const IWMSecureChannel.VTable, @ptrCast(self.vtable)).WMSC_Decrypt(@as(*const IWMSecureChannel, @ptrCast(self)), pbData, cbData);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMSecureChannel_WMSC_Lock(self: *const T) HRESULT {
                return @as(*const IWMSecureChannel.VTable, @ptrCast(self.vtable)).WMSC_Lock(@as(*const IWMSecureChannel, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMSecureChannel_WMSC_Unlock(self: *const T) HRESULT {
                return @as(*const IWMSecureChannel.VTable, @ptrCast(self.vtable)).WMSC_Unlock(@as(*const IWMSecureChannel, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMSecureChannel_WMSC_SetSharedData(self: *const T, dwCertIndex: u32, pbSharedData: ?*const u8) HRESULT {
                return @as(*const IWMSecureChannel.VTable, @ptrCast(self.vtable)).WMSC_SetSharedData(@as(*const IWMSecureChannel, @ptrCast(self)), dwCertIndex, pbSharedData);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IWMGetSecureChannel_Value = Guid.initString("94bc0598-c3d2-11d3-bedf-00c04f612986");
pub const IID_IWMGetSecureChannel = &IID_IWMGetSecureChannel_Value;
pub const IWMGetSecureChannel = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPeerSecureChannelInterface: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMGetSecureChannel,
                ppPeer: ?*?*IWMSecureChannel,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMGetSecureChannel,
                ppPeer: ?*?*IWMSecureChannel,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMGetSecureChannel_GetPeerSecureChannelInterface(self: *const T, ppPeer: ?*?*IWMSecureChannel) HRESULT {
                return @as(*const IWMGetSecureChannel.VTable, @ptrCast(self.vtable)).GetPeerSecureChannelInterface(@as(*const IWMGetSecureChannel, @ptrCast(self)), ppPeer);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_INSNetSourceCreator_Value = Guid.initString("0c0e4080-9081-11d2-beec-0060082f2054");
pub const IID_INSNetSourceCreator = &IID_INSNetSourceCreator_Value;
pub const INSNetSourceCreator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INSNetSourceCreator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INSNetSourceCreator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateNetSource: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INSNetSourceCreator,
                pszStreamName: ?[*:0]const u16,
                pMonitor: ?*IUnknown,
                pData: ?*u8,
                pUserContext: ?*IUnknown,
                pCallback: ?*IUnknown,
                qwContext: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INSNetSourceCreator,
                pszStreamName: ?[*:0]const u16,
                pMonitor: ?*IUnknown,
                pData: ?*u8,
                pUserContext: ?*IUnknown,
                pCallback: ?*IUnknown,
                qwContext: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNetSourceProperties: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INSNetSourceCreator,
                pszStreamName: ?[*:0]const u16,
                ppPropertiesNode: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INSNetSourceCreator,
                pszStreamName: ?[*:0]const u16,
                ppPropertiesNode: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNetSourceSharedNamespace: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INSNetSourceCreator,
                ppSharedNamespace: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INSNetSourceCreator,
                ppSharedNamespace: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNetSourceAdminInterface: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INSNetSourceCreator,
                pszStreamName: ?[*:0]const u16,
                pVal: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INSNetSourceCreator,
                pszStreamName: ?[*:0]const u16,
                pVal: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumProtocolsSupported: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INSNetSourceCreator,
                pcProtocols: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INSNetSourceCreator,
                pcProtocols: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProtocolName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INSNetSourceCreator,
                dwProtocolNum: u32,
                pwszProtocolName: ?PWSTR,
                pcchProtocolName: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INSNetSourceCreator,
                dwProtocolNum: u32,
                pwszProtocolName: ?PWSTR,
                pcchProtocolName: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Shutdown: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const INSNetSourceCreator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const INSNetSourceCreator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INSNetSourceCreator_Initialize(self: *const T) HRESULT {
                return @as(*const INSNetSourceCreator.VTable, @ptrCast(self.vtable)).Initialize(@as(*const INSNetSourceCreator, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INSNetSourceCreator_CreateNetSource(self: *const T, pszStreamName: ?[*:0]const u16, pMonitor: ?*IUnknown, pData: ?*u8, pUserContext: ?*IUnknown, pCallback: ?*IUnknown, qwContext: u64) HRESULT {
                return @as(*const INSNetSourceCreator.VTable, @ptrCast(self.vtable)).CreateNetSource(@as(*const INSNetSourceCreator, @ptrCast(self)), pszStreamName, pMonitor, pData, pUserContext, pCallback, qwContext);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INSNetSourceCreator_GetNetSourceProperties(self: *const T, pszStreamName: ?[*:0]const u16, ppPropertiesNode: ?*?*IUnknown) HRESULT {
                return @as(*const INSNetSourceCreator.VTable, @ptrCast(self.vtable)).GetNetSourceProperties(@as(*const INSNetSourceCreator, @ptrCast(self)), pszStreamName, ppPropertiesNode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INSNetSourceCreator_GetNetSourceSharedNamespace(self: *const T, ppSharedNamespace: ?*?*IUnknown) HRESULT {
                return @as(*const INSNetSourceCreator.VTable, @ptrCast(self.vtable)).GetNetSourceSharedNamespace(@as(*const INSNetSourceCreator, @ptrCast(self)), ppSharedNamespace);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INSNetSourceCreator_GetNetSourceAdminInterface(self: *const T, pszStreamName: ?[*:0]const u16, pVal: ?*VARIANT) HRESULT {
                return @as(*const INSNetSourceCreator.VTable, @ptrCast(self.vtable)).GetNetSourceAdminInterface(@as(*const INSNetSourceCreator, @ptrCast(self)), pszStreamName, pVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INSNetSourceCreator_GetNumProtocolsSupported(self: *const T, pcProtocols: ?*u32) HRESULT {
                return @as(*const INSNetSourceCreator.VTable, @ptrCast(self.vtable)).GetNumProtocolsSupported(@as(*const INSNetSourceCreator, @ptrCast(self)), pcProtocols);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INSNetSourceCreator_GetProtocolName(self: *const T, dwProtocolNum: u32, pwszProtocolName: ?PWSTR, pcchProtocolName: ?*u16) HRESULT {
                return @as(*const INSNetSourceCreator.VTable, @ptrCast(self.vtable)).GetProtocolName(@as(*const INSNetSourceCreator, @ptrCast(self)), dwProtocolNum, pwszProtocolName, pcchProtocolName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn INSNetSourceCreator_Shutdown(self: *const T) HRESULT {
                return @as(*const INSNetSourceCreator.VTable, @ptrCast(self.vtable)).Shutdown(@as(*const INSNetSourceCreator, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMPlayerTimestampHook_Value = Guid.initString("28580dda-d98e-48d0-b7ae-69e473a02825");
pub const IID_IWMPlayerTimestampHook = &IID_IWMPlayerTimestampHook_Value;
pub const IWMPlayerTimestampHook = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        MapTimestamp: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPlayerTimestampHook,
                rtIn: i64,
                prtOut: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPlayerTimestampHook,
                rtIn: i64,
                prtOut: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPlayerTimestampHook_MapTimestamp(self: *const T, rtIn: i64, prtOut: ?*i64) HRESULT {
                return @as(*const IWMPlayerTimestampHook.VTable, @ptrCast(self.vtable)).MapTimestamp(@as(*const IWMPlayerTimestampHook, @ptrCast(self)), rtIn, prtOut);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMCodecAMVideoAccelerator_Value = Guid.initString("d98ee251-34e0-4a2d-9312-9b4c788d9fa1");
pub const IID_IWMCodecAMVideoAccelerator = &IID_IWMCodecAMVideoAccelerator_Value;
pub const IWMCodecAMVideoAccelerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetAcceleratorInterface: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMCodecAMVideoAccelerator,
                pIAMVA: ?*IAMVideoAccelerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMCodecAMVideoAccelerator,
                pIAMVA: ?*IAMVideoAccelerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NegotiateConnection: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMCodecAMVideoAccelerator,
                pMediaType: ?*AM_MEDIA_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMCodecAMVideoAccelerator,
                pMediaType: ?*AM_MEDIA_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPlayerNotify: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMCodecAMVideoAccelerator,
                pHook: ?*IWMPlayerTimestampHook,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMCodecAMVideoAccelerator,
                pHook: ?*IWMPlayerTimestampHook,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMCodecAMVideoAccelerator_SetAcceleratorInterface(self: *const T, pIAMVA: ?*IAMVideoAccelerator) HRESULT {
                return @as(*const IWMCodecAMVideoAccelerator.VTable, @ptrCast(self.vtable)).SetAcceleratorInterface(@as(*const IWMCodecAMVideoAccelerator, @ptrCast(self)), pIAMVA);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMCodecAMVideoAccelerator_NegotiateConnection(self: *const T, pMediaType: ?*AM_MEDIA_TYPE) HRESULT {
                return @as(*const IWMCodecAMVideoAccelerator.VTable, @ptrCast(self.vtable)).NegotiateConnection(@as(*const IWMCodecAMVideoAccelerator, @ptrCast(self)), pMediaType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMCodecAMVideoAccelerator_SetPlayerNotify(self: *const T, pHook: ?*IWMPlayerTimestampHook) HRESULT {
                return @as(*const IWMCodecAMVideoAccelerator.VTable, @ptrCast(self.vtable)).SetPlayerNotify(@as(*const IWMCodecAMVideoAccelerator, @ptrCast(self)), pHook);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMCodecVideoAccelerator_Value = Guid.initString("990641b0-739f-4e94-a808-9888da8f75af");
pub const IID_IWMCodecVideoAccelerator = &IID_IWMCodecVideoAccelerator_Value;
pub const IWMCodecVideoAccelerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        NegotiateConnection: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMCodecVideoAccelerator,
                pIAMVA: ?*IAMVideoAccelerator,
                pMediaType: ?*AM_MEDIA_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMCodecVideoAccelerator,
                pIAMVA: ?*IAMVideoAccelerator,
                pMediaType: ?*AM_MEDIA_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPlayerNotify: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMCodecVideoAccelerator,
                pHook: ?*IWMPlayerTimestampHook,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMCodecVideoAccelerator,
                pHook: ?*IWMPlayerTimestampHook,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMCodecVideoAccelerator_NegotiateConnection(self: *const T, pIAMVA: ?*IAMVideoAccelerator, pMediaType: ?*AM_MEDIA_TYPE) HRESULT {
                return @as(*const IWMCodecVideoAccelerator.VTable, @ptrCast(self.vtable)).NegotiateConnection(@as(*const IWMCodecVideoAccelerator, @ptrCast(self)), pIAMVA, pMediaType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMCodecVideoAccelerator_SetPlayerNotify(self: *const T, pHook: ?*IWMPlayerTimestampHook) HRESULT {
                return @as(*const IWMCodecVideoAccelerator.VTable, @ptrCast(self.vtable)).SetPlayerNotify(@as(*const IWMCodecVideoAccelerator, @ptrCast(self)), pHook);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const NETSOURCE_URLCREDPOLICY_SETTINGS = enum(i32) {
    SILENTLOGONOK = 0,
    MUSTPROMPTUSER = 1,
    ANONYMOUSONLY = 2,
};
pub const NETSOURCE_URLCREDPOLICY_SETTING_SILENTLOGONOK = NETSOURCE_URLCREDPOLICY_SETTINGS.SILENTLOGONOK;
pub const NETSOURCE_URLCREDPOLICY_SETTING_MUSTPROMPTUSER = NETSOURCE_URLCREDPOLICY_SETTINGS.MUSTPROMPTUSER;
pub const NETSOURCE_URLCREDPOLICY_SETTING_ANONYMOUSONLY = NETSOURCE_URLCREDPOLICY_SETTINGS.ANONYMOUSONLY;

const IID_IWMSInternalAdminNetSource_Value = Guid.initString("8bb23e5f-d127-4afb-8d02-ae5b66d54c78");
pub const IID_IWMSInternalAdminNetSource = &IID_IWMSInternalAdminNetSource_Value;
pub const IWMSInternalAdminNetSource = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMSInternalAdminNetSource,
                pSharedNamespace: ?*IUnknown,
                pNamespaceNode: ?*IUnknown,
                pNetSourceCreator: ?*INSNetSourceCreator,
                fEmbeddedInServer: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMSInternalAdminNetSource,
                pSharedNamespace: ?*IUnknown,
                pNamespaceNode: ?*IUnknown,
                pNetSourceCreator: ?*INSNetSourceCreator,
                fEmbeddedInServer: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNetSourceCreator: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMSInternalAdminNetSource,
                ppNetSourceCreator: ?*?*INSNetSourceCreator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMSInternalAdminNetSource,
                ppNetSourceCreator: ?*?*INSNetSourceCreator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCredentials: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMSInternalAdminNetSource,
                bstrRealm: ?BSTR,
                bstrName: ?BSTR,
                bstrPassword: ?BSTR,
                fPersist: BOOL,
                fConfirmedGood: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMSInternalAdminNetSource,
                bstrRealm: ?BSTR,
                bstrName: ?BSTR,
                bstrPassword: ?BSTR,
                fPersist: BOOL,
                fConfirmedGood: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCredentials: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMSInternalAdminNetSource,
                bstrRealm: ?BSTR,
                pbstrName: ?*?BSTR,
                pbstrPassword: ?*?BSTR,
                pfConfirmedGood: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMSInternalAdminNetSource,
                bstrRealm: ?BSTR,
                pbstrName: ?*?BSTR,
                pbstrPassword: ?*?BSTR,
                pfConfirmedGood: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeleteCredentials: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMSInternalAdminNetSource,
                bstrRealm: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMSInternalAdminNetSource,
                bstrRealm: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCredentialFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMSInternalAdminNetSource,
                lpdwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMSInternalAdminNetSource,
                lpdwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCredentialFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMSInternalAdminNetSource,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMSInternalAdminNetSource,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindProxyForURL: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMSInternalAdminNetSource,
                bstrProtocol: ?BSTR,
                bstrHost: ?BSTR,
                pfProxyEnabled: ?*BOOL,
                pbstrProxyServer: ?*?BSTR,
                pdwProxyPort: ?*u32,
                pdwProxyContext: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMSInternalAdminNetSource,
                bstrProtocol: ?BSTR,
                bstrHost: ?BSTR,
                pfProxyEnabled: ?*BOOL,
                pbstrProxyServer: ?*?BSTR,
                pdwProxyPort: ?*u32,
                pdwProxyContext: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RegisterProxyFailure: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMSInternalAdminNetSource,
                hrParam: HRESULT,
                dwProxyContext: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMSInternalAdminNetSource,
                hrParam: HRESULT,
                dwProxyContext: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ShutdownProxyContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMSInternalAdminNetSource,
                dwProxyContext: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMSInternalAdminNetSource,
                dwProxyContext: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsUsingIE: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMSInternalAdminNetSource,
                dwProxyContext: u32,
                pfIsUsingIE: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMSInternalAdminNetSource,
                dwProxyContext: u32,
                pfIsUsingIE: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMSInternalAdminNetSource_Initialize(self: *const T, pSharedNamespace: ?*IUnknown, pNamespaceNode: ?*IUnknown, pNetSourceCreator: ?*INSNetSourceCreator, fEmbeddedInServer: BOOL) HRESULT {
                return @as(*const IWMSInternalAdminNetSource.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IWMSInternalAdminNetSource, @ptrCast(self)), pSharedNamespace, pNamespaceNode, pNetSourceCreator, fEmbeddedInServer);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMSInternalAdminNetSource_GetNetSourceCreator(self: *const T, ppNetSourceCreator: ?*?*INSNetSourceCreator) HRESULT {
                return @as(*const IWMSInternalAdminNetSource.VTable, @ptrCast(self.vtable)).GetNetSourceCreator(@as(*const IWMSInternalAdminNetSource, @ptrCast(self)), ppNetSourceCreator);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMSInternalAdminNetSource_SetCredentials(self: *const T, bstrRealm: ?BSTR, bstrName: ?BSTR, bstrPassword: ?BSTR, fPersist: BOOL, fConfirmedGood: BOOL) HRESULT {
                return @as(*const IWMSInternalAdminNetSource.VTable, @ptrCast(self.vtable)).SetCredentials(@as(*const IWMSInternalAdminNetSource, @ptrCast(self)), bstrRealm, bstrName, bstrPassword, fPersist, fConfirmedGood);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMSInternalAdminNetSource_GetCredentials(self: *const T, bstrRealm: ?BSTR, pbstrName: ?*?BSTR, pbstrPassword: ?*?BSTR, pfConfirmedGood: ?*BOOL) HRESULT {
                return @as(*const IWMSInternalAdminNetSource.VTable, @ptrCast(self.vtable)).GetCredentials(@as(*const IWMSInternalAdminNetSource, @ptrCast(self)), bstrRealm, pbstrName, pbstrPassword, pfConfirmedGood);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMSInternalAdminNetSource_DeleteCredentials(self: *const T, bstrRealm: ?BSTR) HRESULT {
                return @as(*const IWMSInternalAdminNetSource.VTable, @ptrCast(self.vtable)).DeleteCredentials(@as(*const IWMSInternalAdminNetSource, @ptrCast(self)), bstrRealm);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMSInternalAdminNetSource_GetCredentialFlags(self: *const T, lpdwFlags: ?*u32) HRESULT {
                return @as(*const IWMSInternalAdminNetSource.VTable, @ptrCast(self.vtable)).GetCredentialFlags(@as(*const IWMSInternalAdminNetSource, @ptrCast(self)), lpdwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMSInternalAdminNetSource_SetCredentialFlags(self: *const T, dwFlags: u32) HRESULT {
                return @as(*const IWMSInternalAdminNetSource.VTable, @ptrCast(self.vtable)).SetCredentialFlags(@as(*const IWMSInternalAdminNetSource, @ptrCast(self)), dwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMSInternalAdminNetSource_FindProxyForURL(self: *const T, bstrProtocol: ?BSTR, bstrHost: ?BSTR, pfProxyEnabled: ?*BOOL, pbstrProxyServer: ?*?BSTR, pdwProxyPort: ?*u32, pdwProxyContext: ?*u32) HRESULT {
                return @as(*const IWMSInternalAdminNetSource.VTable, @ptrCast(self.vtable)).FindProxyForURL(@as(*const IWMSInternalAdminNetSource, @ptrCast(self)), bstrProtocol, bstrHost, pfProxyEnabled, pbstrProxyServer, pdwProxyPort, pdwProxyContext);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMSInternalAdminNetSource_RegisterProxyFailure(self: *const T, hrParam: HRESULT, dwProxyContext: u32) HRESULT {
                return @as(*const IWMSInternalAdminNetSource.VTable, @ptrCast(self.vtable)).RegisterProxyFailure(@as(*const IWMSInternalAdminNetSource, @ptrCast(self)), hrParam, dwProxyContext);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMSInternalAdminNetSource_ShutdownProxyContext(self: *const T, dwProxyContext: u32) HRESULT {
                return @as(*const IWMSInternalAdminNetSource.VTable, @ptrCast(self.vtable)).ShutdownProxyContext(@as(*const IWMSInternalAdminNetSource, @ptrCast(self)), dwProxyContext);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMSInternalAdminNetSource_IsUsingIE(self: *const T, dwProxyContext: u32, pfIsUsingIE: ?*BOOL) HRESULT {
                return @as(*const IWMSInternalAdminNetSource.VTable, @ptrCast(self.vtable)).IsUsingIE(@as(*const IWMSInternalAdminNetSource, @ptrCast(self)), dwProxyContext, pfIsUsingIE);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMSInternalAdminNetSource2_Value = Guid.initString("e74d58c3-cf77-4b51-af17-744687c43eae");
pub const IID_IWMSInternalAdminNetSource2 = &IID_IWMSInternalAdminNetSource2_Value;
pub const IWMSInternalAdminNetSource2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetCredentialsEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMSInternalAdminNetSource2,
                bstrRealm: ?BSTR,
                bstrUrl: ?BSTR,
                fProxy: BOOL,
                bstrName: ?BSTR,
                bstrPassword: ?BSTR,
                fPersist: BOOL,
                fConfirmedGood: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMSInternalAdminNetSource2,
                bstrRealm: ?BSTR,
                bstrUrl: ?BSTR,
                fProxy: BOOL,
                bstrName: ?BSTR,
                bstrPassword: ?BSTR,
                fPersist: BOOL,
                fConfirmedGood: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCredentialsEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMSInternalAdminNetSource2,
                bstrRealm: ?BSTR,
                bstrUrl: ?BSTR,
                fProxy: BOOL,
                pdwUrlPolicy: ?*NETSOURCE_URLCREDPOLICY_SETTINGS,
                pbstrName: ?*?BSTR,
                pbstrPassword: ?*?BSTR,
                pfConfirmedGood: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMSInternalAdminNetSource2,
                bstrRealm: ?BSTR,
                bstrUrl: ?BSTR,
                fProxy: BOOL,
                pdwUrlPolicy: ?*NETSOURCE_URLCREDPOLICY_SETTINGS,
                pbstrName: ?*?BSTR,
                pbstrPassword: ?*?BSTR,
                pfConfirmedGood: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeleteCredentialsEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMSInternalAdminNetSource2,
                bstrRealm: ?BSTR,
                bstrUrl: ?BSTR,
                fProxy: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMSInternalAdminNetSource2,
                bstrRealm: ?BSTR,
                bstrUrl: ?BSTR,
                fProxy: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindProxyForURLEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMSInternalAdminNetSource2,
                bstrProtocol: ?BSTR,
                bstrHost: ?BSTR,
                bstrUrl: ?BSTR,
                pfProxyEnabled: ?*BOOL,
                pbstrProxyServer: ?*?BSTR,
                pdwProxyPort: ?*u32,
                pdwProxyContext: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMSInternalAdminNetSource2,
                bstrProtocol: ?BSTR,
                bstrHost: ?BSTR,
                bstrUrl: ?BSTR,
                pfProxyEnabled: ?*BOOL,
                pbstrProxyServer: ?*?BSTR,
                pdwProxyPort: ?*u32,
                pdwProxyContext: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMSInternalAdminNetSource2_SetCredentialsEx(self: *const T, bstrRealm: ?BSTR, bstrUrl: ?BSTR, fProxy: BOOL, bstrName: ?BSTR, bstrPassword: ?BSTR, fPersist: BOOL, fConfirmedGood: BOOL) HRESULT {
                return @as(*const IWMSInternalAdminNetSource2.VTable, @ptrCast(self.vtable)).SetCredentialsEx(@as(*const IWMSInternalAdminNetSource2, @ptrCast(self)), bstrRealm, bstrUrl, fProxy, bstrName, bstrPassword, fPersist, fConfirmedGood);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMSInternalAdminNetSource2_GetCredentialsEx(self: *const T, bstrRealm: ?BSTR, bstrUrl: ?BSTR, fProxy: BOOL, pdwUrlPolicy: ?*NETSOURCE_URLCREDPOLICY_SETTINGS, pbstrName: ?*?BSTR, pbstrPassword: ?*?BSTR, pfConfirmedGood: ?*BOOL) HRESULT {
                return @as(*const IWMSInternalAdminNetSource2.VTable, @ptrCast(self.vtable)).GetCredentialsEx(@as(*const IWMSInternalAdminNetSource2, @ptrCast(self)), bstrRealm, bstrUrl, fProxy, pdwUrlPolicy, pbstrName, pbstrPassword, pfConfirmedGood);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMSInternalAdminNetSource2_DeleteCredentialsEx(self: *const T, bstrRealm: ?BSTR, bstrUrl: ?BSTR, fProxy: BOOL) HRESULT {
                return @as(*const IWMSInternalAdminNetSource2.VTable, @ptrCast(self.vtable)).DeleteCredentialsEx(@as(*const IWMSInternalAdminNetSource2, @ptrCast(self)), bstrRealm, bstrUrl, fProxy);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMSInternalAdminNetSource2_FindProxyForURLEx(self: *const T, bstrProtocol: ?BSTR, bstrHost: ?BSTR, bstrUrl: ?BSTR, pfProxyEnabled: ?*BOOL, pbstrProxyServer: ?*?BSTR, pdwProxyPort: ?*u32, pdwProxyContext: ?*u32) HRESULT {
                return @as(*const IWMSInternalAdminNetSource2.VTable, @ptrCast(self.vtable)).FindProxyForURLEx(@as(*const IWMSInternalAdminNetSource2, @ptrCast(self)), bstrProtocol, bstrHost, bstrUrl, pfProxyEnabled, pbstrProxyServer, pdwProxyPort, pdwProxyContext);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMSInternalAdminNetSource3_Value = Guid.initString("6b63d08e-4590-44af-9eb3-57ff1e73bf80");
pub const IID_IWMSInternalAdminNetSource3 = &IID_IWMSInternalAdminNetSource3_Value;
pub const IWMSInternalAdminNetSource3 = extern struct {
    pub const VTable = extern struct {
        base: IWMSInternalAdminNetSource2.VTable,
        GetNetSourceCreator2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMSInternalAdminNetSource3,
                ppNetSourceCreator: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMSInternalAdminNetSource3,
                ppNetSourceCreator: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindProxyForURLEx2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMSInternalAdminNetSource3,
                bstrProtocol: ?BSTR,
                bstrHost: ?BSTR,
                bstrUrl: ?BSTR,
                pfProxyEnabled: ?*BOOL,
                pbstrProxyServer: ?*?BSTR,
                pdwProxyPort: ?*u32,
                pqwProxyContext: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMSInternalAdminNetSource3,
                bstrProtocol: ?BSTR,
                bstrHost: ?BSTR,
                bstrUrl: ?BSTR,
                pfProxyEnabled: ?*BOOL,
                pbstrProxyServer: ?*?BSTR,
                pdwProxyPort: ?*u32,
                pqwProxyContext: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RegisterProxyFailure2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMSInternalAdminNetSource3,
                hrParam: HRESULT,
                qwProxyContext: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMSInternalAdminNetSource3,
                hrParam: HRESULT,
                qwProxyContext: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ShutdownProxyContext2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMSInternalAdminNetSource3,
                qwProxyContext: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMSInternalAdminNetSource3,
                qwProxyContext: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsUsingIE2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMSInternalAdminNetSource3,
                qwProxyContext: u64,
                pfIsUsingIE: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMSInternalAdminNetSource3,
                qwProxyContext: u64,
                pfIsUsingIE: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCredentialsEx2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMSInternalAdminNetSource3,
                bstrRealm: ?BSTR,
                bstrUrl: ?BSTR,
                fProxy: BOOL,
                bstrName: ?BSTR,
                bstrPassword: ?BSTR,
                fPersist: BOOL,
                fConfirmedGood: BOOL,
                fClearTextAuthentication: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMSInternalAdminNetSource3,
                bstrRealm: ?BSTR,
                bstrUrl: ?BSTR,
                fProxy: BOOL,
                bstrName: ?BSTR,
                bstrPassword: ?BSTR,
                fPersist: BOOL,
                fConfirmedGood: BOOL,
                fClearTextAuthentication: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCredentialsEx2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMSInternalAdminNetSource3,
                bstrRealm: ?BSTR,
                bstrUrl: ?BSTR,
                fProxy: BOOL,
                fClearTextAuthentication: BOOL,
                pdwUrlPolicy: ?*NETSOURCE_URLCREDPOLICY_SETTINGS,
                pbstrName: ?*?BSTR,
                pbstrPassword: ?*?BSTR,
                pfConfirmedGood: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMSInternalAdminNetSource3,
                bstrRealm: ?BSTR,
                bstrUrl: ?BSTR,
                fProxy: BOOL,
                fClearTextAuthentication: BOOL,
                pdwUrlPolicy: ?*NETSOURCE_URLCREDPOLICY_SETTINGS,
                pbstrName: ?*?BSTR,
                pbstrPassword: ?*?BSTR,
                pfConfirmedGood: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWMSInternalAdminNetSource2.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMSInternalAdminNetSource3_GetNetSourceCreator2(self: *const T, ppNetSourceCreator: ?*?*IUnknown) HRESULT {
                return @as(*const IWMSInternalAdminNetSource3.VTable, @ptrCast(self.vtable)).GetNetSourceCreator2(@as(*const IWMSInternalAdminNetSource3, @ptrCast(self)), ppNetSourceCreator);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMSInternalAdminNetSource3_FindProxyForURLEx2(self: *const T, bstrProtocol: ?BSTR, bstrHost: ?BSTR, bstrUrl: ?BSTR, pfProxyEnabled: ?*BOOL, pbstrProxyServer: ?*?BSTR, pdwProxyPort: ?*u32, pqwProxyContext: ?*u64) HRESULT {
                return @as(*const IWMSInternalAdminNetSource3.VTable, @ptrCast(self.vtable)).FindProxyForURLEx2(@as(*const IWMSInternalAdminNetSource3, @ptrCast(self)), bstrProtocol, bstrHost, bstrUrl, pfProxyEnabled, pbstrProxyServer, pdwProxyPort, pqwProxyContext);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMSInternalAdminNetSource3_RegisterProxyFailure2(self: *const T, hrParam: HRESULT, qwProxyContext: u64) HRESULT {
                return @as(*const IWMSInternalAdminNetSource3.VTable, @ptrCast(self.vtable)).RegisterProxyFailure2(@as(*const IWMSInternalAdminNetSource3, @ptrCast(self)), hrParam, qwProxyContext);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMSInternalAdminNetSource3_ShutdownProxyContext2(self: *const T, qwProxyContext: u64) HRESULT {
                return @as(*const IWMSInternalAdminNetSource3.VTable, @ptrCast(self.vtable)).ShutdownProxyContext2(@as(*const IWMSInternalAdminNetSource3, @ptrCast(self)), qwProxyContext);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMSInternalAdminNetSource3_IsUsingIE2(self: *const T, qwProxyContext: u64, pfIsUsingIE: ?*BOOL) HRESULT {
                return @as(*const IWMSInternalAdminNetSource3.VTable, @ptrCast(self.vtable)).IsUsingIE2(@as(*const IWMSInternalAdminNetSource3, @ptrCast(self)), qwProxyContext, pfIsUsingIE);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMSInternalAdminNetSource3_SetCredentialsEx2(self: *const T, bstrRealm: ?BSTR, bstrUrl: ?BSTR, fProxy: BOOL, bstrName: ?BSTR, bstrPassword: ?BSTR, fPersist: BOOL, fConfirmedGood: BOOL, fClearTextAuthentication: BOOL) HRESULT {
                return @as(*const IWMSInternalAdminNetSource3.VTable, @ptrCast(self.vtable)).SetCredentialsEx2(@as(*const IWMSInternalAdminNetSource3, @ptrCast(self)), bstrRealm, bstrUrl, fProxy, bstrName, bstrPassword, fPersist, fConfirmedGood, fClearTextAuthentication);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMSInternalAdminNetSource3_GetCredentialsEx2(self: *const T, bstrRealm: ?BSTR, bstrUrl: ?BSTR, fProxy: BOOL, fClearTextAuthentication: BOOL, pdwUrlPolicy: ?*NETSOURCE_URLCREDPOLICY_SETTINGS, pbstrName: ?*?BSTR, pbstrPassword: ?*?BSTR, pfConfirmedGood: ?*BOOL) HRESULT {
                return @as(*const IWMSInternalAdminNetSource3.VTable, @ptrCast(self.vtable)).GetCredentialsEx2(@as(*const IWMSInternalAdminNetSource3, @ptrCast(self)), bstrRealm, bstrUrl, fProxy, fClearTextAuthentication, pdwUrlPolicy, pbstrName, pbstrPassword, pfConfirmedGood);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

//--------------------------------------------------------------------------------
// Section: Functions (11)
//--------------------------------------------------------------------------------
// TODO: this type is limited to platform 'windows5.0'
pub extern "wmvcore" fn WMIsContentProtected(
    pwszFileName: ?[*:0]const u16,
    pfIsProtected: ?*BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wmvcore" fn WMCreateWriter(
    pUnkCert: ?*IUnknown,
    ppWriter: ?*?*IWMWriter,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wmvcore" fn WMCreateReader(
    pUnkCert: ?*IUnknown,
    dwRights: u32,
    ppReader: ?*?*IWMReader,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wmvcore" fn WMCreateSyncReader(
    pUnkCert: ?*IUnknown,
    dwRights: u32,
    ppSyncReader: ?*?*IWMSyncReader,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wmvcore" fn WMCreateEditor(
    ppEditor: ?*?*IWMMetadataEditor,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wmvcore" fn WMCreateIndexer(
    ppIndexer: ?*?*IWMIndexer,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wmvcore" fn WMCreateBackupRestorer(
    pCallback: ?*IUnknown,
    ppBackup: ?*?*IWMLicenseBackup,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wmvcore" fn WMCreateProfileManager(
    ppProfileManager: ?*?*IWMProfileManager,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wmvcore" fn WMCreateWriterFileSink(
    ppSink: ?*?*IWMWriterFileSink,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wmvcore" fn WMCreateWriterNetworkSink(
    ppSink: ?*?*IWMWriterNetworkSink,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "wmvcore" fn WMCreateWriterPushSink(
    ppSink: ?*?*IWMWriterPushSink,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {},
    .wide => struct {},
    .unspecified => if (@import("builtin").is_test) struct {} else struct {},
};
//--------------------------------------------------------------------------------
// Section: Imports (14)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const AM_MEDIA_TYPE = @import("../media/direct_show.zig").AM_MEDIA_TYPE;
const BITMAPINFOHEADER = @import("../graphics/gdi.zig").BITMAPINFOHEADER;
const BOOL = @import("../foundation.zig").BOOL;
const BSTR = @import("../foundation.zig").BSTR;
const HRESULT = @import("../foundation.zig").HRESULT;
const IAMVideoAccelerator = @import("../media/direct_show.zig").IAMVideoAccelerator;
const IPin = @import("../media/direct_show.zig").IPin;
const IStream = @import("../system/com.zig").IStream;
const IUnknown = @import("../system/com.zig").IUnknown;
const LPARAM = @import("../foundation.zig").LPARAM;
const PWSTR = @import("../foundation.zig").PWSTR;
const RECT = @import("../foundation.zig").RECT;
const VARIANT = @import("../system/com.zig").VARIANT;

test {
    @setEvalBranchQuota(comptime @import("std").meta.declarations(@This()).len * 3);

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        if (decl.is_pub) {
            _ = @field(@This(), decl.name);
        }
    }
}
