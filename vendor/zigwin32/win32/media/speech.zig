//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (17)
//--------------------------------------------------------------------------------
pub const SP_LOW_CONFIDENCE = @as(i32, -1);
pub const SP_NORMAL_CONFIDENCE = @as(u32, 0);
pub const DEFAULT_WEIGHT = @as(u32, 1);
pub const SP_MAX_WORD_LENGTH = @as(u32, 128);
pub const SP_MAX_PRON_LENGTH = @as(u32, 384);
pub const SP_EMULATE_RESULT = @as(u32, 1073741824);
pub const SP_STREAMPOS_ASAP = @as(u32, 0);
pub const SP_STREAMPOS_REALTIME = @as(i32, -1);
pub const SPRP_NORMAL = @as(u32, 0);
pub const SP_MAX_LANGIDS = @as(u32, 20);
pub const SAPI_ERROR_BASE = @as(u32, 20480);
pub const Speech_Default_Weight = @as(f32, 1);
pub const Speech_Max_Word_Length = @as(i32, 128);
pub const Speech_Max_Pron_Length = @as(i32, 384);
pub const Speech_StreamPos_Asap = @as(i32, 0);
pub const Speech_StreamPos_RealTime = @as(i32, -1);
pub const SpeechAllElements = @as(i32, -1);

//--------------------------------------------------------------------------------
// Section: Types (294)
//--------------------------------------------------------------------------------
const CLSID_SpNotifyTranslator_Value = Guid.initString("e2ae5372-5d40-11d2-960e-00c04f8ee628");
pub const CLSID_SpNotifyTranslator = &CLSID_SpNotifyTranslator_Value;

const CLSID_SpObjectTokenCategory_Value = Guid.initString("a910187f-0c7a-45ac-92cc-59edafb77b53");
pub const CLSID_SpObjectTokenCategory = &CLSID_SpObjectTokenCategory_Value;

const CLSID_SpObjectToken_Value = Guid.initString("ef411752-3736-4cb4-9c8c-8ef4ccb58efe");
pub const CLSID_SpObjectToken = &CLSID_SpObjectToken_Value;

const CLSID_SpResourceManager_Value = Guid.initString("96749373-3391-11d2-9ee3-00c04f797396");
pub const CLSID_SpResourceManager = &CLSID_SpResourceManager_Value;

const CLSID_SpStreamFormatConverter_Value = Guid.initString("7013943a-e2ec-11d2-a086-00c04f8ef9b5");
pub const CLSID_SpStreamFormatConverter = &CLSID_SpStreamFormatConverter_Value;

const CLSID_SpMMAudioEnum_Value = Guid.initString("ab1890a0-e91f-11d2-bb91-00c04f8ee6c0");
pub const CLSID_SpMMAudioEnum = &CLSID_SpMMAudioEnum_Value;

const CLSID_SpMMAudioIn_Value = Guid.initString("cf3d2e50-53f2-11d2-960c-00c04f8ee628");
pub const CLSID_SpMMAudioIn = &CLSID_SpMMAudioIn_Value;

const CLSID_SpMMAudioOut_Value = Guid.initString("a8c680eb-3d32-11d2-9ee7-00c04f797396");
pub const CLSID_SpMMAudioOut = &CLSID_SpMMAudioOut_Value;

const CLSID_SpStream_Value = Guid.initString("715d9c59-4442-11d2-9605-00c04f8ee628");
pub const CLSID_SpStream = &CLSID_SpStream_Value;

const CLSID_SpVoice_Value = Guid.initString("96749377-3391-11d2-9ee3-00c04f797396");
pub const CLSID_SpVoice = &CLSID_SpVoice_Value;

const CLSID_SpSharedRecoContext_Value = Guid.initString("47206204-5eca-11d2-960f-00c04f8ee628");
pub const CLSID_SpSharedRecoContext = &CLSID_SpSharedRecoContext_Value;

const CLSID_SpInprocRecognizer_Value = Guid.initString("41b89b6b-9399-11d2-9623-00c04f8ee628");
pub const CLSID_SpInprocRecognizer = &CLSID_SpInprocRecognizer_Value;

const CLSID_SpSharedRecognizer_Value = Guid.initString("3bee4890-4fe9-4a37-8c1e-5e7e12791c1f");
pub const CLSID_SpSharedRecognizer = &CLSID_SpSharedRecognizer_Value;

const CLSID_SpLexicon_Value = Guid.initString("0655e396-25d0-11d3-9c26-00c04f8ef87c");
pub const CLSID_SpLexicon = &CLSID_SpLexicon_Value;

const CLSID_SpUnCompressedLexicon_Value = Guid.initString("c9e37c15-df92-4727-85d6-72e5eeb6995a");
pub const CLSID_SpUnCompressedLexicon = &CLSID_SpUnCompressedLexicon_Value;

const CLSID_SpCompressedLexicon_Value = Guid.initString("90903716-2f42-11d3-9c26-00c04f8ef87c");
pub const CLSID_SpCompressedLexicon = &CLSID_SpCompressedLexicon_Value;

const CLSID_SpShortcut_Value = Guid.initString("0d722f1a-9fcf-4e62-96d8-6df8f01a26aa");
pub const CLSID_SpShortcut = &CLSID_SpShortcut_Value;

const CLSID_SpPhoneConverter_Value = Guid.initString("9185f743-1143-4c28-86b5-bff14f20e5c8");
pub const CLSID_SpPhoneConverter = &CLSID_SpPhoneConverter_Value;

const CLSID_SpPhoneticAlphabetConverter_Value = Guid.initString("4f414126-dfe3-4629-99ee-797978317ead");
pub const CLSID_SpPhoneticAlphabetConverter = &CLSID_SpPhoneticAlphabetConverter_Value;

const CLSID_SpNullPhoneConverter_Value = Guid.initString("455f24e9-7396-4a16-9715-7c0fdbe3efe3");
pub const CLSID_SpNullPhoneConverter = &CLSID_SpNullPhoneConverter_Value;

const CLSID_SpTextSelectionInformation_Value = Guid.initString("0f92030a-cbfd-4ab8-a164-ff5985547ff6");
pub const CLSID_SpTextSelectionInformation = &CLSID_SpTextSelectionInformation_Value;

const CLSID_SpPhraseInfoBuilder_Value = Guid.initString("c23fc28d-c55f-4720-8b32-91f73c2bd5d1");
pub const CLSID_SpPhraseInfoBuilder = &CLSID_SpPhraseInfoBuilder_Value;

const CLSID_SpAudioFormat_Value = Guid.initString("9ef96870-e160-4792-820d-48cf0649e4ec");
pub const CLSID_SpAudioFormat = &CLSID_SpAudioFormat_Value;

const CLSID_SpWaveFormatEx_Value = Guid.initString("c79a574c-63be-44b9-801f-283f87f898be");
pub const CLSID_SpWaveFormatEx = &CLSID_SpWaveFormatEx_Value;

const CLSID_SpInProcRecoContext_Value = Guid.initString("73ad6842-ace0-45e8-a4dd-8795881a2c2a");
pub const CLSID_SpInProcRecoContext = &CLSID_SpInProcRecoContext_Value;

const CLSID_SpCustomStream_Value = Guid.initString("8dbef13f-1948-4aa8-8cf0-048eebed95d8");
pub const CLSID_SpCustomStream = &CLSID_SpCustomStream_Value;

const CLSID_SpFileStream_Value = Guid.initString("947812b3-2ae1-4644-ba86-9e90ded7ec91");
pub const CLSID_SpFileStream = &CLSID_SpFileStream_Value;

const CLSID_SpMemoryStream_Value = Guid.initString("5fb7ef7d-dff4-468a-b6b7-2fcbd188f994");
pub const CLSID_SpMemoryStream = &CLSID_SpMemoryStream_Value;

pub const SPDATAKEYLOCATION = enum(i32) {
    DefaultLocation = 0,
    CurrentUser = 1,
    LocalMachine = 2,
    CurrentConfig = 5,
};
pub const SPDKL_DefaultLocation = SPDATAKEYLOCATION.DefaultLocation;
pub const SPDKL_CurrentUser = SPDATAKEYLOCATION.CurrentUser;
pub const SPDKL_LocalMachine = SPDATAKEYLOCATION.LocalMachine;
pub const SPDKL_CurrentConfig = SPDATAKEYLOCATION.CurrentConfig;

pub const SPSTREAMFORMAT = enum(i32) {
    Default = -1,
    NoAssignedFormat = 0,
    Text = 1,
    NonStandardFormat = 2,
    ExtendedAudioFormat = 3,
    @"8kHz8BitMono" = 4,
    @"8kHz8BitStereo" = 5,
    @"8kHz16BitMono" = 6,
    @"8kHz16BitStereo" = 7,
    @"11kHz8BitMono" = 8,
    @"11kHz8BitStereo" = 9,
    @"11kHz16BitMono" = 10,
    @"11kHz16BitStereo" = 11,
    @"12kHz8BitMono" = 12,
    @"12kHz8BitStereo" = 13,
    @"12kHz16BitMono" = 14,
    @"12kHz16BitStereo" = 15,
    @"16kHz8BitMono" = 16,
    @"16kHz8BitStereo" = 17,
    @"16kHz16BitMono" = 18,
    @"16kHz16BitStereo" = 19,
    @"22kHz8BitMono" = 20,
    @"22kHz8BitStereo" = 21,
    @"22kHz16BitMono" = 22,
    @"22kHz16BitStereo" = 23,
    @"24kHz8BitMono" = 24,
    @"24kHz8BitStereo" = 25,
    @"24kHz16BitMono" = 26,
    @"24kHz16BitStereo" = 27,
    @"32kHz8BitMono" = 28,
    @"32kHz8BitStereo" = 29,
    @"32kHz16BitMono" = 30,
    @"32kHz16BitStereo" = 31,
    @"44kHz8BitMono" = 32,
    @"44kHz8BitStereo" = 33,
    @"44kHz16BitMono" = 34,
    @"44kHz16BitStereo" = 35,
    @"48kHz8BitMono" = 36,
    @"48kHz8BitStereo" = 37,
    @"48kHz16BitMono" = 38,
    @"48kHz16BitStereo" = 39,
    TrueSpeech_8kHz1BitMono = 40,
    CCITT_ALaw_8kHzMono = 41,
    CCITT_ALaw_8kHzStereo = 42,
    CCITT_ALaw_11kHzMono = 43,
    CCITT_ALaw_11kHzStereo = 44,
    CCITT_ALaw_22kHzMono = 45,
    CCITT_ALaw_22kHzStereo = 46,
    CCITT_ALaw_44kHzMono = 47,
    CCITT_ALaw_44kHzStereo = 48,
    CCITT_uLaw_8kHzMono = 49,
    CCITT_uLaw_8kHzStereo = 50,
    CCITT_uLaw_11kHzMono = 51,
    CCITT_uLaw_11kHzStereo = 52,
    CCITT_uLaw_22kHzMono = 53,
    CCITT_uLaw_22kHzStereo = 54,
    CCITT_uLaw_44kHzMono = 55,
    CCITT_uLaw_44kHzStereo = 56,
    ADPCM_8kHzMono = 57,
    ADPCM_8kHzStereo = 58,
    ADPCM_11kHzMono = 59,
    ADPCM_11kHzStereo = 60,
    ADPCM_22kHzMono = 61,
    ADPCM_22kHzStereo = 62,
    ADPCM_44kHzMono = 63,
    ADPCM_44kHzStereo = 64,
    GSM610_8kHzMono = 65,
    GSM610_11kHzMono = 66,
    GSM610_22kHzMono = 67,
    GSM610_44kHzMono = 68,
    NUM_FORMATS = 69,
};
pub const SPSF_Default = SPSTREAMFORMAT.Default;
pub const SPSF_NoAssignedFormat = SPSTREAMFORMAT.NoAssignedFormat;
pub const SPSF_Text = SPSTREAMFORMAT.Text;
pub const SPSF_NonStandardFormat = SPSTREAMFORMAT.NonStandardFormat;
pub const SPSF_ExtendedAudioFormat = SPSTREAMFORMAT.ExtendedAudioFormat;
pub const SPSF_8kHz8BitMono = SPSTREAMFORMAT.@"8kHz8BitMono";
pub const SPSF_8kHz8BitStereo = SPSTREAMFORMAT.@"8kHz8BitStereo";
pub const SPSF_8kHz16BitMono = SPSTREAMFORMAT.@"8kHz16BitMono";
pub const SPSF_8kHz16BitStereo = SPSTREAMFORMAT.@"8kHz16BitStereo";
pub const SPSF_11kHz8BitMono = SPSTREAMFORMAT.@"11kHz8BitMono";
pub const SPSF_11kHz8BitStereo = SPSTREAMFORMAT.@"11kHz8BitStereo";
pub const SPSF_11kHz16BitMono = SPSTREAMFORMAT.@"11kHz16BitMono";
pub const SPSF_11kHz16BitStereo = SPSTREAMFORMAT.@"11kHz16BitStereo";
pub const SPSF_12kHz8BitMono = SPSTREAMFORMAT.@"12kHz8BitMono";
pub const SPSF_12kHz8BitStereo = SPSTREAMFORMAT.@"12kHz8BitStereo";
pub const SPSF_12kHz16BitMono = SPSTREAMFORMAT.@"12kHz16BitMono";
pub const SPSF_12kHz16BitStereo = SPSTREAMFORMAT.@"12kHz16BitStereo";
pub const SPSF_16kHz8BitMono = SPSTREAMFORMAT.@"16kHz8BitMono";
pub const SPSF_16kHz8BitStereo = SPSTREAMFORMAT.@"16kHz8BitStereo";
pub const SPSF_16kHz16BitMono = SPSTREAMFORMAT.@"16kHz16BitMono";
pub const SPSF_16kHz16BitStereo = SPSTREAMFORMAT.@"16kHz16BitStereo";
pub const SPSF_22kHz8BitMono = SPSTREAMFORMAT.@"22kHz8BitMono";
pub const SPSF_22kHz8BitStereo = SPSTREAMFORMAT.@"22kHz8BitStereo";
pub const SPSF_22kHz16BitMono = SPSTREAMFORMAT.@"22kHz16BitMono";
pub const SPSF_22kHz16BitStereo = SPSTREAMFORMAT.@"22kHz16BitStereo";
pub const SPSF_24kHz8BitMono = SPSTREAMFORMAT.@"24kHz8BitMono";
pub const SPSF_24kHz8BitStereo = SPSTREAMFORMAT.@"24kHz8BitStereo";
pub const SPSF_24kHz16BitMono = SPSTREAMFORMAT.@"24kHz16BitMono";
pub const SPSF_24kHz16BitStereo = SPSTREAMFORMAT.@"24kHz16BitStereo";
pub const SPSF_32kHz8BitMono = SPSTREAMFORMAT.@"32kHz8BitMono";
pub const SPSF_32kHz8BitStereo = SPSTREAMFORMAT.@"32kHz8BitStereo";
pub const SPSF_32kHz16BitMono = SPSTREAMFORMAT.@"32kHz16BitMono";
pub const SPSF_32kHz16BitStereo = SPSTREAMFORMAT.@"32kHz16BitStereo";
pub const SPSF_44kHz8BitMono = SPSTREAMFORMAT.@"44kHz8BitMono";
pub const SPSF_44kHz8BitStereo = SPSTREAMFORMAT.@"44kHz8BitStereo";
pub const SPSF_44kHz16BitMono = SPSTREAMFORMAT.@"44kHz16BitMono";
pub const SPSF_44kHz16BitStereo = SPSTREAMFORMAT.@"44kHz16BitStereo";
pub const SPSF_48kHz8BitMono = SPSTREAMFORMAT.@"48kHz8BitMono";
pub const SPSF_48kHz8BitStereo = SPSTREAMFORMAT.@"48kHz8BitStereo";
pub const SPSF_48kHz16BitMono = SPSTREAMFORMAT.@"48kHz16BitMono";
pub const SPSF_48kHz16BitStereo = SPSTREAMFORMAT.@"48kHz16BitStereo";
pub const SPSF_TrueSpeech_8kHz1BitMono = SPSTREAMFORMAT.TrueSpeech_8kHz1BitMono;
pub const SPSF_CCITT_ALaw_8kHzMono = SPSTREAMFORMAT.CCITT_ALaw_8kHzMono;
pub const SPSF_CCITT_ALaw_8kHzStereo = SPSTREAMFORMAT.CCITT_ALaw_8kHzStereo;
pub const SPSF_CCITT_ALaw_11kHzMono = SPSTREAMFORMAT.CCITT_ALaw_11kHzMono;
pub const SPSF_CCITT_ALaw_11kHzStereo = SPSTREAMFORMAT.CCITT_ALaw_11kHzStereo;
pub const SPSF_CCITT_ALaw_22kHzMono = SPSTREAMFORMAT.CCITT_ALaw_22kHzMono;
pub const SPSF_CCITT_ALaw_22kHzStereo = SPSTREAMFORMAT.CCITT_ALaw_22kHzStereo;
pub const SPSF_CCITT_ALaw_44kHzMono = SPSTREAMFORMAT.CCITT_ALaw_44kHzMono;
pub const SPSF_CCITT_ALaw_44kHzStereo = SPSTREAMFORMAT.CCITT_ALaw_44kHzStereo;
pub const SPSF_CCITT_uLaw_8kHzMono = SPSTREAMFORMAT.CCITT_uLaw_8kHzMono;
pub const SPSF_CCITT_uLaw_8kHzStereo = SPSTREAMFORMAT.CCITT_uLaw_8kHzStereo;
pub const SPSF_CCITT_uLaw_11kHzMono = SPSTREAMFORMAT.CCITT_uLaw_11kHzMono;
pub const SPSF_CCITT_uLaw_11kHzStereo = SPSTREAMFORMAT.CCITT_uLaw_11kHzStereo;
pub const SPSF_CCITT_uLaw_22kHzMono = SPSTREAMFORMAT.CCITT_uLaw_22kHzMono;
pub const SPSF_CCITT_uLaw_22kHzStereo = SPSTREAMFORMAT.CCITT_uLaw_22kHzStereo;
pub const SPSF_CCITT_uLaw_44kHzMono = SPSTREAMFORMAT.CCITT_uLaw_44kHzMono;
pub const SPSF_CCITT_uLaw_44kHzStereo = SPSTREAMFORMAT.CCITT_uLaw_44kHzStereo;
pub const SPSF_ADPCM_8kHzMono = SPSTREAMFORMAT.ADPCM_8kHzMono;
pub const SPSF_ADPCM_8kHzStereo = SPSTREAMFORMAT.ADPCM_8kHzStereo;
pub const SPSF_ADPCM_11kHzMono = SPSTREAMFORMAT.ADPCM_11kHzMono;
pub const SPSF_ADPCM_11kHzStereo = SPSTREAMFORMAT.ADPCM_11kHzStereo;
pub const SPSF_ADPCM_22kHzMono = SPSTREAMFORMAT.ADPCM_22kHzMono;
pub const SPSF_ADPCM_22kHzStereo = SPSTREAMFORMAT.ADPCM_22kHzStereo;
pub const SPSF_ADPCM_44kHzMono = SPSTREAMFORMAT.ADPCM_44kHzMono;
pub const SPSF_ADPCM_44kHzStereo = SPSTREAMFORMAT.ADPCM_44kHzStereo;
pub const SPSF_GSM610_8kHzMono = SPSTREAMFORMAT.GSM610_8kHzMono;
pub const SPSF_GSM610_11kHzMono = SPSTREAMFORMAT.GSM610_11kHzMono;
pub const SPSF_GSM610_22kHzMono = SPSTREAMFORMAT.GSM610_22kHzMono;
pub const SPSF_GSM610_44kHzMono = SPSTREAMFORMAT.GSM610_44kHzMono;
pub const SPSF_NUM_FORMATS = SPSTREAMFORMAT.NUM_FORMATS;

pub const ISpNotifyCallback = extern struct {
    pub const VTable = extern struct {
        NotifyCallback: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpNotifyCallback,
                wParam: WPARAM,
                lParam: LPARAM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpNotifyCallback,
                wParam: WPARAM,
                lParam: LPARAM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpNotifyCallback_NotifyCallback(self: *const T, wParam: WPARAM, lParam: LPARAM) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpNotifyCallback.VTable, self.vtable).NotifyCallback(@ptrCast(*const ISpNotifyCallback, self), wParam, lParam);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SPNOTIFYCALLBACK = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        wParam: WPARAM,
        lParam: LPARAM,
    ) callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn(
        wParam: WPARAM,
        lParam: LPARAM,
    ) callconv(@import("std").os.windows.WINAPI) void,
} ;

const IID_ISpNotifySource_Value = Guid.initString("5eff4aef-8487-11d2-961c-00c04f8ee628");
pub const IID_ISpNotifySource = &IID_ISpNotifySource_Value;
pub const ISpNotifySource = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetNotifySink: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpNotifySource,
                pNotifySink: ?*ISpNotifySink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpNotifySource,
                pNotifySink: ?*ISpNotifySink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetNotifyWindowMessage: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpNotifySource,
                hWnd: ?HWND,
                Msg: u32,
                wParam: WPARAM,
                lParam: LPARAM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpNotifySource,
                hWnd: ?HWND,
                Msg: u32,
                wParam: WPARAM,
                lParam: LPARAM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetNotifyCallbackFunction: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpNotifySource,
                pfnCallback: ?*?SPNOTIFYCALLBACK,
                wParam: WPARAM,
                lParam: LPARAM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpNotifySource,
                pfnCallback: ?*?SPNOTIFYCALLBACK,
                wParam: WPARAM,
                lParam: LPARAM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetNotifyCallbackInterface: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpNotifySource,
                pSpCallback: ?*ISpNotifyCallback,
                wParam: WPARAM,
                lParam: LPARAM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpNotifySource,
                pSpCallback: ?*ISpNotifyCallback,
                wParam: WPARAM,
                lParam: LPARAM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetNotifyWin32Event: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpNotifySource,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpNotifySource,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WaitForNotifyEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpNotifySource,
                dwMilliseconds: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpNotifySource,
                dwMilliseconds: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNotifyEventHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpNotifySource,
            ) callconv(@import("std").os.windows.WINAPI) ?HANDLE,
            else => *const fn(
                self: *const ISpNotifySource,
            ) callconv(@import("std").os.windows.WINAPI) ?HANDLE,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpNotifySource_SetNotifySink(self: *const T, pNotifySink: ?*ISpNotifySink) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpNotifySource.VTable, self.vtable).SetNotifySink(@ptrCast(*const ISpNotifySource, self), pNotifySink);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpNotifySource_SetNotifyWindowMessage(self: *const T, hWnd: ?HWND, Msg: u32, wParam: WPARAM, lParam: LPARAM) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpNotifySource.VTable, self.vtable).SetNotifyWindowMessage(@ptrCast(*const ISpNotifySource, self), hWnd, Msg, wParam, lParam);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpNotifySource_SetNotifyCallbackFunction(self: *const T, pfnCallback: ?*?SPNOTIFYCALLBACK, wParam: WPARAM, lParam: LPARAM) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpNotifySource.VTable, self.vtable).SetNotifyCallbackFunction(@ptrCast(*const ISpNotifySource, self), pfnCallback, wParam, lParam);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpNotifySource_SetNotifyCallbackInterface(self: *const T, pSpCallback: ?*ISpNotifyCallback, wParam: WPARAM, lParam: LPARAM) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpNotifySource.VTable, self.vtable).SetNotifyCallbackInterface(@ptrCast(*const ISpNotifySource, self), pSpCallback, wParam, lParam);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpNotifySource_SetNotifyWin32Event(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpNotifySource.VTable, self.vtable).SetNotifyWin32Event(@ptrCast(*const ISpNotifySource, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpNotifySource_WaitForNotifyEvent(self: *const T, dwMilliseconds: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpNotifySource.VTable, self.vtable).WaitForNotifyEvent(@ptrCast(*const ISpNotifySource, self), dwMilliseconds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpNotifySource_GetNotifyEventHandle(self: *const T) callconv(.Inline) ?HANDLE {
            return @ptrCast(*const ISpNotifySource.VTable, self.vtable).GetNotifyEventHandle(@ptrCast(*const ISpNotifySource, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpNotifySink_Value = Guid.initString("259684dc-37c3-11d2-9603-00c04f8ee628");
pub const IID_ISpNotifySink = &IID_ISpNotifySink_Value;
pub const ISpNotifySink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Notify: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpNotifySink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpNotifySink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpNotifySink_Notify(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpNotifySink.VTable, self.vtable).Notify(@ptrCast(*const ISpNotifySink, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpNotifyTranslator_Value = Guid.initString("aca16614-5d3d-11d2-960e-00c04f8ee628");
pub const IID_ISpNotifyTranslator = &IID_ISpNotifyTranslator_Value;
pub const ISpNotifyTranslator = extern struct {
    pub const VTable = extern struct {
        base: ISpNotifySink.VTable,
        InitWindowMessage: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpNotifyTranslator,
                hWnd: ?HWND,
                Msg: u32,
                wParam: WPARAM,
                lParam: LPARAM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpNotifyTranslator,
                hWnd: ?HWND,
                Msg: u32,
                wParam: WPARAM,
                lParam: LPARAM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InitCallback: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpNotifyTranslator,
                pfnCallback: ?*?SPNOTIFYCALLBACK,
                wParam: WPARAM,
                lParam: LPARAM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpNotifyTranslator,
                pfnCallback: ?*?SPNOTIFYCALLBACK,
                wParam: WPARAM,
                lParam: LPARAM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InitSpNotifyCallback: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpNotifyTranslator,
                pSpCallback: ?*ISpNotifyCallback,
                wParam: WPARAM,
                lParam: LPARAM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpNotifyTranslator,
                pSpCallback: ?*ISpNotifyCallback,
                wParam: WPARAM,
                lParam: LPARAM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InitWin32Event: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpNotifyTranslator,
                hEvent: ?HANDLE,
                fCloseHandleOnRelease: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpNotifyTranslator,
                hEvent: ?HANDLE,
                fCloseHandleOnRelease: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Wait: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpNotifyTranslator,
                dwMilliseconds: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpNotifyTranslator,
                dwMilliseconds: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpNotifyTranslator,
            ) callconv(@import("std").os.windows.WINAPI) ?HANDLE,
            else => *const fn(
                self: *const ISpNotifyTranslator,
            ) callconv(@import("std").os.windows.WINAPI) ?HANDLE,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISpNotifySink.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpNotifyTranslator_InitWindowMessage(self: *const T, hWnd: ?HWND, Msg: u32, wParam: WPARAM, lParam: LPARAM) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpNotifyTranslator.VTable, self.vtable).InitWindowMessage(@ptrCast(*const ISpNotifyTranslator, self), hWnd, Msg, wParam, lParam);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpNotifyTranslator_InitCallback(self: *const T, pfnCallback: ?*?SPNOTIFYCALLBACK, wParam: WPARAM, lParam: LPARAM) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpNotifyTranslator.VTable, self.vtable).InitCallback(@ptrCast(*const ISpNotifyTranslator, self), pfnCallback, wParam, lParam);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpNotifyTranslator_InitSpNotifyCallback(self: *const T, pSpCallback: ?*ISpNotifyCallback, wParam: WPARAM, lParam: LPARAM) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpNotifyTranslator.VTable, self.vtable).InitSpNotifyCallback(@ptrCast(*const ISpNotifyTranslator, self), pSpCallback, wParam, lParam);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpNotifyTranslator_InitWin32Event(self: *const T, hEvent: ?HANDLE, fCloseHandleOnRelease: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpNotifyTranslator.VTable, self.vtable).InitWin32Event(@ptrCast(*const ISpNotifyTranslator, self), hEvent, fCloseHandleOnRelease);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpNotifyTranslator_Wait(self: *const T, dwMilliseconds: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpNotifyTranslator.VTable, self.vtable).Wait(@ptrCast(*const ISpNotifyTranslator, self), dwMilliseconds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpNotifyTranslator_GetEventHandle(self: *const T) callconv(.Inline) ?HANDLE {
            return @ptrCast(*const ISpNotifyTranslator.VTable, self.vtable).GetEventHandle(@ptrCast(*const ISpNotifyTranslator, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpDataKey_Value = Guid.initString("14056581-e16c-11d2-bb90-00c04f8ee6c0");
pub const IID_ISpDataKey = &IID_ISpDataKey_Value;
pub const ISpDataKey = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpDataKey,
                pszValueName: ?[*:0]const u16,
                cbData: u32,
                pData: ?*const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpDataKey,
                pszValueName: ?[*:0]const u16,
                cbData: u32,
                pData: ?*const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpDataKey,
                pszValueName: ?[*:0]const u16,
                pcbData: ?*u32,
                pData: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpDataKey,
                pszValueName: ?[*:0]const u16,
                pcbData: ?*u32,
                pData: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetStringValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpDataKey,
                pszValueName: ?[*:0]const u16,
                pszValue: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpDataKey,
                pszValueName: ?[*:0]const u16,
                pszValue: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStringValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpDataKey,
                pszValueName: ?[*:0]const u16,
                ppszValue: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpDataKey,
                pszValueName: ?[*:0]const u16,
                ppszValue: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDWORD: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpDataKey,
                pszValueName: ?[*:0]const u16,
                dwValue: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpDataKey,
                pszValueName: ?[*:0]const u16,
                dwValue: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDWORD: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpDataKey,
                pszValueName: ?[*:0]const u16,
                pdwValue: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpDataKey,
                pszValueName: ?[*:0]const u16,
                pdwValue: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenKey: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpDataKey,
                pszSubKeyName: ?[*:0]const u16,
                ppSubKey: ?*?*ISpDataKey,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpDataKey,
                pszSubKeyName: ?[*:0]const u16,
                ppSubKey: ?*?*ISpDataKey,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateKey: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpDataKey,
                pszSubKey: ?[*:0]const u16,
                ppSubKey: ?*?*ISpDataKey,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpDataKey,
                pszSubKey: ?[*:0]const u16,
                ppSubKey: ?*?*ISpDataKey,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeleteKey: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpDataKey,
                pszSubKey: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpDataKey,
                pszSubKey: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeleteValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpDataKey,
                pszValueName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpDataKey,
                pszValueName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumKeys: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpDataKey,
                Index: u32,
                ppszSubKeyName: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpDataKey,
                Index: u32,
                ppszSubKeyName: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumValues: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpDataKey,
                Index: u32,
                ppszValueName: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpDataKey,
                Index: u32,
                ppszValueName: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpDataKey_SetData(self: *const T, pszValueName: ?[*:0]const u16, cbData: u32, pData: ?*const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpDataKey.VTable, self.vtable).SetData(@ptrCast(*const ISpDataKey, self), pszValueName, cbData, pData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpDataKey_GetData(self: *const T, pszValueName: ?[*:0]const u16, pcbData: ?*u32, pData: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpDataKey.VTable, self.vtable).GetData(@ptrCast(*const ISpDataKey, self), pszValueName, pcbData, pData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpDataKey_SetStringValue(self: *const T, pszValueName: ?[*:0]const u16, pszValue: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpDataKey.VTable, self.vtable).SetStringValue(@ptrCast(*const ISpDataKey, self), pszValueName, pszValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpDataKey_GetStringValue(self: *const T, pszValueName: ?[*:0]const u16, ppszValue: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpDataKey.VTable, self.vtable).GetStringValue(@ptrCast(*const ISpDataKey, self), pszValueName, ppszValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpDataKey_SetDWORD(self: *const T, pszValueName: ?[*:0]const u16, dwValue: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpDataKey.VTable, self.vtable).SetDWORD(@ptrCast(*const ISpDataKey, self), pszValueName, dwValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpDataKey_GetDWORD(self: *const T, pszValueName: ?[*:0]const u16, pdwValue: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpDataKey.VTable, self.vtable).GetDWORD(@ptrCast(*const ISpDataKey, self), pszValueName, pdwValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpDataKey_OpenKey(self: *const T, pszSubKeyName: ?[*:0]const u16, ppSubKey: ?*?*ISpDataKey) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpDataKey.VTable, self.vtable).OpenKey(@ptrCast(*const ISpDataKey, self), pszSubKeyName, ppSubKey);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpDataKey_CreateKey(self: *const T, pszSubKey: ?[*:0]const u16, ppSubKey: ?*?*ISpDataKey) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpDataKey.VTable, self.vtable).CreateKey(@ptrCast(*const ISpDataKey, self), pszSubKey, ppSubKey);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpDataKey_DeleteKey(self: *const T, pszSubKey: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpDataKey.VTable, self.vtable).DeleteKey(@ptrCast(*const ISpDataKey, self), pszSubKey);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpDataKey_DeleteValue(self: *const T, pszValueName: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpDataKey.VTable, self.vtable).DeleteValue(@ptrCast(*const ISpDataKey, self), pszValueName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpDataKey_EnumKeys(self: *const T, Index: u32, ppszSubKeyName: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpDataKey.VTable, self.vtable).EnumKeys(@ptrCast(*const ISpDataKey, self), Index, ppszSubKeyName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpDataKey_EnumValues(self: *const T, Index: u32, ppszValueName: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpDataKey.VTable, self.vtable).EnumValues(@ptrCast(*const ISpDataKey, self), Index, ppszValueName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpRegDataKey_Value = Guid.initString("92a66e2b-c830-4149-83df-6fc2ba1e7a5b");
pub const IID_ISpRegDataKey = &IID_ISpRegDataKey_Value;
pub const ISpRegDataKey = extern struct {
    pub const VTable = extern struct {
        base: ISpDataKey.VTable,
        SetKey: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpRegDataKey,
                hkey: ?HKEY,
                fReadOnly: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpRegDataKey,
                hkey: ?HKEY,
                fReadOnly: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISpDataKey.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpRegDataKey_SetKey(self: *const T, hkey: ?HKEY, fReadOnly: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpRegDataKey.VTable, self.vtable).SetKey(@ptrCast(*const ISpRegDataKey, self), hkey, fReadOnly);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpObjectTokenCategory_Value = Guid.initString("2d3d3845-39af-4850-bbf9-40b49780011d");
pub const IID_ISpObjectTokenCategory = &IID_ISpObjectTokenCategory_Value;
pub const ISpObjectTokenCategory = extern struct {
    pub const VTable = extern struct {
        base: ISpDataKey.VTable,
        SetId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpObjectTokenCategory,
                pszCategoryId: ?[*:0]const u16,
                fCreateIfNotExist: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpObjectTokenCategory,
                pszCategoryId: ?[*:0]const u16,
                fCreateIfNotExist: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpObjectTokenCategory,
                ppszCoMemCategoryId: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpObjectTokenCategory,
                ppszCoMemCategoryId: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDataKey: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpObjectTokenCategory,
                spdkl: SPDATAKEYLOCATION,
                ppDataKey: ?*?*ISpDataKey,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpObjectTokenCategory,
                spdkl: SPDATAKEYLOCATION,
                ppDataKey: ?*?*ISpDataKey,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumTokens: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpObjectTokenCategory,
                pzsReqAttribs: ?[*:0]const u16,
                pszOptAttribs: ?[*:0]const u16,
                ppEnum: ?*?*IEnumSpObjectTokens,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpObjectTokenCategory,
                pzsReqAttribs: ?[*:0]const u16,
                pszOptAttribs: ?[*:0]const u16,
                ppEnum: ?*?*IEnumSpObjectTokens,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDefaultTokenId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpObjectTokenCategory,
                pszTokenId: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpObjectTokenCategory,
                pszTokenId: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDefaultTokenId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpObjectTokenCategory,
                ppszCoMemTokenId: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpObjectTokenCategory,
                ppszCoMemTokenId: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISpDataKey.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpObjectTokenCategory_SetId(self: *const T, pszCategoryId: ?[*:0]const u16, fCreateIfNotExist: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpObjectTokenCategory.VTable, self.vtable).SetId(@ptrCast(*const ISpObjectTokenCategory, self), pszCategoryId, fCreateIfNotExist);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpObjectTokenCategory_GetId(self: *const T, ppszCoMemCategoryId: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpObjectTokenCategory.VTable, self.vtable).GetId(@ptrCast(*const ISpObjectTokenCategory, self), ppszCoMemCategoryId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpObjectTokenCategory_GetDataKey(self: *const T, spdkl: SPDATAKEYLOCATION, ppDataKey: ?*?*ISpDataKey) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpObjectTokenCategory.VTable, self.vtable).GetDataKey(@ptrCast(*const ISpObjectTokenCategory, self), spdkl, ppDataKey);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpObjectTokenCategory_EnumTokens(self: *const T, pzsReqAttribs: ?[*:0]const u16, pszOptAttribs: ?[*:0]const u16, ppEnum: ?*?*IEnumSpObjectTokens) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpObjectTokenCategory.VTable, self.vtable).EnumTokens(@ptrCast(*const ISpObjectTokenCategory, self), pzsReqAttribs, pszOptAttribs, ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpObjectTokenCategory_SetDefaultTokenId(self: *const T, pszTokenId: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpObjectTokenCategory.VTable, self.vtable).SetDefaultTokenId(@ptrCast(*const ISpObjectTokenCategory, self), pszTokenId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpObjectTokenCategory_GetDefaultTokenId(self: *const T, ppszCoMemTokenId: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpObjectTokenCategory.VTable, self.vtable).GetDefaultTokenId(@ptrCast(*const ISpObjectTokenCategory, self), ppszCoMemTokenId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpObjectToken_Value = Guid.initString("14056589-e16c-11d2-bb90-00c04f8ee6c0");
pub const IID_ISpObjectToken = &IID_ISpObjectToken_Value;
pub const ISpObjectToken = extern struct {
    pub const VTable = extern struct {
        base: ISpDataKey.VTable,
        SetId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpObjectToken,
                pszCategoryId: ?[*:0]const u16,
                pszTokenId: ?[*:0]const u16,
                fCreateIfNotExist: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpObjectToken,
                pszCategoryId: ?[*:0]const u16,
                pszTokenId: ?[*:0]const u16,
                fCreateIfNotExist: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpObjectToken,
                ppszCoMemTokenId: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpObjectToken,
                ppszCoMemTokenId: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCategory: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpObjectToken,
                ppTokenCategory: ?*?*ISpObjectTokenCategory,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpObjectToken,
                ppTokenCategory: ?*?*ISpObjectTokenCategory,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateInstance: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpObjectToken,
                pUnkOuter: ?*IUnknown,
                dwClsContext: u32,
                riid: ?*const Guid,
                ppvObject: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpObjectToken,
                pUnkOuter: ?*IUnknown,
                dwClsContext: u32,
                riid: ?*const Guid,
                ppvObject: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStorageFileName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpObjectToken,
                clsidCaller: ?*const Guid,
                pszValueName: ?[*:0]const u16,
                pszFileNameSpecifier: ?[*:0]const u16,
                nFolder: u32,
                ppszFilePath: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpObjectToken,
                clsidCaller: ?*const Guid,
                pszValueName: ?[*:0]const u16,
                pszFileNameSpecifier: ?[*:0]const u16,
                nFolder: u32,
                ppszFilePath: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveStorageFileName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpObjectToken,
                clsidCaller: ?*const Guid,
                pszKeyName: ?[*:0]const u16,
                fDeleteFile: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpObjectToken,
                clsidCaller: ?*const Guid,
                pszKeyName: ?[*:0]const u16,
                fDeleteFile: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Remove: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpObjectToken,
                pclsidCaller: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpObjectToken,
                pclsidCaller: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsUISupported: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpObjectToken,
                pszTypeOfUI: ?[*:0]const u16,
                pvExtraData: ?*anyopaque,
                cbExtraData: u32,
                punkObject: ?*IUnknown,
                pfSupported: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpObjectToken,
                pszTypeOfUI: ?[*:0]const u16,
                pvExtraData: ?*anyopaque,
                cbExtraData: u32,
                punkObject: ?*IUnknown,
                pfSupported: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DisplayUI: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpObjectToken,
                hwndParent: ?HWND,
                pszTitle: ?[*:0]const u16,
                pszTypeOfUI: ?[*:0]const u16,
                pvExtraData: ?*anyopaque,
                cbExtraData: u32,
                punkObject: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpObjectToken,
                hwndParent: ?HWND,
                pszTitle: ?[*:0]const u16,
                pszTypeOfUI: ?[*:0]const u16,
                pvExtraData: ?*anyopaque,
                cbExtraData: u32,
                punkObject: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        MatchesAttributes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpObjectToken,
                pszAttributes: ?[*:0]const u16,
                pfMatches: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpObjectToken,
                pszAttributes: ?[*:0]const u16,
                pfMatches: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISpDataKey.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpObjectToken_SetId(self: *const T, pszCategoryId: ?[*:0]const u16, pszTokenId: ?[*:0]const u16, fCreateIfNotExist: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpObjectToken.VTable, self.vtable).SetId(@ptrCast(*const ISpObjectToken, self), pszCategoryId, pszTokenId, fCreateIfNotExist);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpObjectToken_GetId(self: *const T, ppszCoMemTokenId: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpObjectToken.VTable, self.vtable).GetId(@ptrCast(*const ISpObjectToken, self), ppszCoMemTokenId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpObjectToken_GetCategory(self: *const T, ppTokenCategory: ?*?*ISpObjectTokenCategory) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpObjectToken.VTable, self.vtable).GetCategory(@ptrCast(*const ISpObjectToken, self), ppTokenCategory);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpObjectToken_CreateInstance(self: *const T, pUnkOuter: ?*IUnknown, dwClsContext: u32, riid: ?*const Guid, ppvObject: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpObjectToken.VTable, self.vtable).CreateInstance(@ptrCast(*const ISpObjectToken, self), pUnkOuter, dwClsContext, riid, ppvObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpObjectToken_GetStorageFileName(self: *const T, clsidCaller: ?*const Guid, pszValueName: ?[*:0]const u16, pszFileNameSpecifier: ?[*:0]const u16, nFolder: u32, ppszFilePath: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpObjectToken.VTable, self.vtable).GetStorageFileName(@ptrCast(*const ISpObjectToken, self), clsidCaller, pszValueName, pszFileNameSpecifier, nFolder, ppszFilePath);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpObjectToken_RemoveStorageFileName(self: *const T, clsidCaller: ?*const Guid, pszKeyName: ?[*:0]const u16, fDeleteFile: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpObjectToken.VTable, self.vtable).RemoveStorageFileName(@ptrCast(*const ISpObjectToken, self), clsidCaller, pszKeyName, fDeleteFile);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpObjectToken_Remove(self: *const T, pclsidCaller: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpObjectToken.VTable, self.vtable).Remove(@ptrCast(*const ISpObjectToken, self), pclsidCaller);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpObjectToken_IsUISupported(self: *const T, pszTypeOfUI: ?[*:0]const u16, pvExtraData: ?*anyopaque, cbExtraData: u32, punkObject: ?*IUnknown, pfSupported: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpObjectToken.VTable, self.vtable).IsUISupported(@ptrCast(*const ISpObjectToken, self), pszTypeOfUI, pvExtraData, cbExtraData, punkObject, pfSupported);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpObjectToken_DisplayUI(self: *const T, hwndParent: ?HWND, pszTitle: ?[*:0]const u16, pszTypeOfUI: ?[*:0]const u16, pvExtraData: ?*anyopaque, cbExtraData: u32, punkObject: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpObjectToken.VTable, self.vtable).DisplayUI(@ptrCast(*const ISpObjectToken, self), hwndParent, pszTitle, pszTypeOfUI, pvExtraData, cbExtraData, punkObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpObjectToken_MatchesAttributes(self: *const T, pszAttributes: ?[*:0]const u16, pfMatches: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpObjectToken.VTable, self.vtable).MatchesAttributes(@ptrCast(*const ISpObjectToken, self), pszAttributes, pfMatches);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpObjectTokenInit_Value = Guid.initString("b8aab0cf-346f-49d8-9499-c8b03f161d51");
pub const IID_ISpObjectTokenInit = &IID_ISpObjectTokenInit_Value;
pub const ISpObjectTokenInit = extern struct {
    pub const VTable = extern struct {
        base: ISpObjectToken.VTable,
        InitFromDataKey: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpObjectTokenInit,
                pszCategoryId: ?[*:0]const u16,
                pszTokenId: ?[*:0]const u16,
                pDataKey: ?*ISpDataKey,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpObjectTokenInit,
                pszCategoryId: ?[*:0]const u16,
                pszTokenId: ?[*:0]const u16,
                pDataKey: ?*ISpDataKey,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISpObjectToken.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpObjectTokenInit_InitFromDataKey(self: *const T, pszCategoryId: ?[*:0]const u16, pszTokenId: ?[*:0]const u16, pDataKey: ?*ISpDataKey) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpObjectTokenInit.VTable, self.vtable).InitFromDataKey(@ptrCast(*const ISpObjectTokenInit, self), pszCategoryId, pszTokenId, pDataKey);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumSpObjectTokens_Value = Guid.initString("06b64f9e-7fda-11d2-b4f2-00c04f797396");
pub const IID_IEnumSpObjectTokens = &IID_IEnumSpObjectTokens_Value;
pub const IEnumSpObjectTokens = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumSpObjectTokens,
                celt: u32,
                pelt: ?*?*ISpObjectToken,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumSpObjectTokens,
                celt: u32,
                pelt: ?*?*ISpObjectToken,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumSpObjectTokens,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumSpObjectTokens,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumSpObjectTokens,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumSpObjectTokens,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumSpObjectTokens,
                ppEnum: ?*?*IEnumSpObjectTokens,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumSpObjectTokens,
                ppEnum: ?*?*IEnumSpObjectTokens,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Item: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumSpObjectTokens,
                Index: u32,
                ppToken: ?*?*ISpObjectToken,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumSpObjectTokens,
                Index: u32,
                ppToken: ?*?*ISpObjectToken,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumSpObjectTokens,
                pCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumSpObjectTokens,
                pCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSpObjectTokens_Next(self: *const T, celt: u32, pelt: ?*?*ISpObjectToken, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumSpObjectTokens.VTable, self.vtable).Next(@ptrCast(*const IEnumSpObjectTokens, self), celt, pelt, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSpObjectTokens_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumSpObjectTokens.VTable, self.vtable).Skip(@ptrCast(*const IEnumSpObjectTokens, self), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSpObjectTokens_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumSpObjectTokens.VTable, self.vtable).Reset(@ptrCast(*const IEnumSpObjectTokens, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSpObjectTokens_Clone(self: *const T, ppEnum: ?*?*IEnumSpObjectTokens) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumSpObjectTokens.VTable, self.vtable).Clone(@ptrCast(*const IEnumSpObjectTokens, self), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSpObjectTokens_Item(self: *const T, Index: u32, ppToken: ?*?*ISpObjectToken) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumSpObjectTokens.VTable, self.vtable).Item(@ptrCast(*const IEnumSpObjectTokens, self), Index, ppToken);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSpObjectTokens_GetCount(self: *const T, pCount: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumSpObjectTokens.VTable, self.vtable).GetCount(@ptrCast(*const IEnumSpObjectTokens, self), pCount);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpObjectWithToken_Value = Guid.initString("5b559f40-e952-11d2-bb91-00c04f8ee6c0");
pub const IID_ISpObjectWithToken = &IID_ISpObjectWithToken_Value;
pub const ISpObjectWithToken = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetObjectToken: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpObjectWithToken,
                pToken: ?*ISpObjectToken,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpObjectWithToken,
                pToken: ?*ISpObjectToken,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetObjectToken: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpObjectWithToken,
                ppToken: ?*?*ISpObjectToken,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpObjectWithToken,
                ppToken: ?*?*ISpObjectToken,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpObjectWithToken_SetObjectToken(self: *const T, pToken: ?*ISpObjectToken) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpObjectWithToken.VTable, self.vtable).SetObjectToken(@ptrCast(*const ISpObjectWithToken, self), pToken);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpObjectWithToken_GetObjectToken(self: *const T, ppToken: ?*?*ISpObjectToken) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpObjectWithToken.VTable, self.vtable).GetObjectToken(@ptrCast(*const ISpObjectWithToken, self), ppToken);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpResourceManager_Value = Guid.initString("93384e18-5014-43d5-adbb-a78e055926bd");
pub const IID_ISpResourceManager = &IID_ISpResourceManager_Value;
pub const ISpResourceManager = extern struct {
    pub const VTable = extern struct {
        base: IServiceProvider.VTable,
        SetObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpResourceManager,
                guidServiceId: ?*const Guid,
                pUnkObject: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpResourceManager,
                guidServiceId: ?*const Guid,
                pUnkObject: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpResourceManager,
                guidServiceId: ?*const Guid,
                ObjectCLSID: ?*const Guid,
                ObjectIID: ?*const Guid,
                fReleaseWhenLastExternalRefReleased: BOOL,
                ppObject: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpResourceManager,
                guidServiceId: ?*const Guid,
                ObjectCLSID: ?*const Guid,
                ObjectIID: ?*const Guid,
                fReleaseWhenLastExternalRefReleased: BOOL,
                ppObject: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IServiceProvider.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpResourceManager_SetObject(self: *const T, guidServiceId: ?*const Guid, pUnkObject: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpResourceManager.VTable, self.vtable).SetObject(@ptrCast(*const ISpResourceManager, self), guidServiceId, pUnkObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpResourceManager_GetObject(self: *const T, guidServiceId: ?*const Guid, ObjectCLSID: ?*const Guid, ObjectIID: ?*const Guid, fReleaseWhenLastExternalRefReleased: BOOL, ppObject: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpResourceManager.VTable, self.vtable).GetObject(@ptrCast(*const ISpResourceManager, self), guidServiceId, ObjectCLSID, ObjectIID, fReleaseWhenLastExternalRefReleased, ppObject);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SPEVENTLPARAMTYPE = enum(i32) {
    UNDEFINED = 0,
    TOKEN = 1,
    OBJECT = 2,
    POINTER = 3,
    STRING = 4,
};
pub const SPET_LPARAM_IS_UNDEFINED = SPEVENTLPARAMTYPE.UNDEFINED;
pub const SPET_LPARAM_IS_TOKEN = SPEVENTLPARAMTYPE.TOKEN;
pub const SPET_LPARAM_IS_OBJECT = SPEVENTLPARAMTYPE.OBJECT;
pub const SPET_LPARAM_IS_POINTER = SPEVENTLPARAMTYPE.POINTER;
pub const SPET_LPARAM_IS_STRING = SPEVENTLPARAMTYPE.STRING;

pub const SPEVENTENUM = enum(i32) {
    UNDEFINED = 0,
    START_INPUT_STREAM = 1,
    END_INPUT_STREAM = 2,
    VOICE_CHANGE = 3,
    TTS_BOOKMARK = 4,
    WORD_BOUNDARY = 5,
    PHONEME = 6,
    SENTENCE_BOUNDARY = 7,
    VISEME = 8,
    TTS_AUDIO_LEVEL = 9,
    TTS_PRIVATE = 15,
    // MIN_TTS = 1, this enum value conflicts with START_INPUT_STREAM
    // MAX_TTS = 15, this enum value conflicts with TTS_PRIVATE
    END_SR_STREAM = 34,
    SOUND_START = 35,
    SOUND_END = 36,
    PHRASE_START = 37,
    RECOGNITION = 38,
    HYPOTHESIS = 39,
    SR_BOOKMARK = 40,
    PROPERTY_NUM_CHANGE = 41,
    PROPERTY_STRING_CHANGE = 42,
    FALSE_RECOGNITION = 43,
    INTERFERENCE = 44,
    REQUEST_UI = 45,
    RECO_STATE_CHANGE = 46,
    ADAPTATION = 47,
    START_SR_STREAM = 48,
    RECO_OTHER_CONTEXT = 49,
    SR_AUDIO_LEVEL = 50,
    SR_RETAINEDAUDIO = 51,
    SR_PRIVATE = 52,
    RESERVED4 = 53,
    RESERVED5 = 54,
    RESERVED6 = 55,
    // MIN_SR = 34, this enum value conflicts with END_SR_STREAM
    // MAX_SR = 55, this enum value conflicts with RESERVED6
    RESERVED1 = 30,
    RESERVED2 = 33,
    RESERVED3 = 63,
};
pub const SPEI_UNDEFINED = SPEVENTENUM.UNDEFINED;
pub const SPEI_START_INPUT_STREAM = SPEVENTENUM.START_INPUT_STREAM;
pub const SPEI_END_INPUT_STREAM = SPEVENTENUM.END_INPUT_STREAM;
pub const SPEI_VOICE_CHANGE = SPEVENTENUM.VOICE_CHANGE;
pub const SPEI_TTS_BOOKMARK = SPEVENTENUM.TTS_BOOKMARK;
pub const SPEI_WORD_BOUNDARY = SPEVENTENUM.WORD_BOUNDARY;
pub const SPEI_PHONEME = SPEVENTENUM.PHONEME;
pub const SPEI_SENTENCE_BOUNDARY = SPEVENTENUM.SENTENCE_BOUNDARY;
pub const SPEI_VISEME = SPEVENTENUM.VISEME;
pub const SPEI_TTS_AUDIO_LEVEL = SPEVENTENUM.TTS_AUDIO_LEVEL;
pub const SPEI_TTS_PRIVATE = SPEVENTENUM.TTS_PRIVATE;
pub const SPEI_MIN_TTS = SPEVENTENUM.START_INPUT_STREAM;
pub const SPEI_MAX_TTS = SPEVENTENUM.TTS_PRIVATE;
pub const SPEI_END_SR_STREAM = SPEVENTENUM.END_SR_STREAM;
pub const SPEI_SOUND_START = SPEVENTENUM.SOUND_START;
pub const SPEI_SOUND_END = SPEVENTENUM.SOUND_END;
pub const SPEI_PHRASE_START = SPEVENTENUM.PHRASE_START;
pub const SPEI_RECOGNITION = SPEVENTENUM.RECOGNITION;
pub const SPEI_HYPOTHESIS = SPEVENTENUM.HYPOTHESIS;
pub const SPEI_SR_BOOKMARK = SPEVENTENUM.SR_BOOKMARK;
pub const SPEI_PROPERTY_NUM_CHANGE = SPEVENTENUM.PROPERTY_NUM_CHANGE;
pub const SPEI_PROPERTY_STRING_CHANGE = SPEVENTENUM.PROPERTY_STRING_CHANGE;
pub const SPEI_FALSE_RECOGNITION = SPEVENTENUM.FALSE_RECOGNITION;
pub const SPEI_INTERFERENCE = SPEVENTENUM.INTERFERENCE;
pub const SPEI_REQUEST_UI = SPEVENTENUM.REQUEST_UI;
pub const SPEI_RECO_STATE_CHANGE = SPEVENTENUM.RECO_STATE_CHANGE;
pub const SPEI_ADAPTATION = SPEVENTENUM.ADAPTATION;
pub const SPEI_START_SR_STREAM = SPEVENTENUM.START_SR_STREAM;
pub const SPEI_RECO_OTHER_CONTEXT = SPEVENTENUM.RECO_OTHER_CONTEXT;
pub const SPEI_SR_AUDIO_LEVEL = SPEVENTENUM.SR_AUDIO_LEVEL;
pub const SPEI_SR_RETAINEDAUDIO = SPEVENTENUM.SR_RETAINEDAUDIO;
pub const SPEI_SR_PRIVATE = SPEVENTENUM.SR_PRIVATE;
pub const SPEI_RESERVED4 = SPEVENTENUM.RESERVED4;
pub const SPEI_RESERVED5 = SPEVENTENUM.RESERVED5;
pub const SPEI_RESERVED6 = SPEVENTENUM.RESERVED6;
pub const SPEI_MIN_SR = SPEVENTENUM.END_SR_STREAM;
pub const SPEI_MAX_SR = SPEVENTENUM.RESERVED6;
pub const SPEI_RESERVED1 = SPEVENTENUM.RESERVED1;
pub const SPEI_RESERVED2 = SPEVENTENUM.RESERVED2;
pub const SPEI_RESERVED3 = SPEVENTENUM.RESERVED3;

pub const SPEVENT = extern struct {
    _bitfield: i32,
    ulStreamNum: u32,
    ullAudioStreamOffset: u64,
    wParam: WPARAM,
    lParam: LPARAM,
};

pub const SPSERIALIZEDEVENT = extern struct {
    _bitfield: i32,
    ulStreamNum: u32,
    ullAudioStreamOffset: u64,
    SerializedwParam: u32,
    SerializedlParam: i32,
};

pub const SPSERIALIZEDEVENT64 = extern struct {
    _bitfield: i32,
    ulStreamNum: u32,
    ullAudioStreamOffset: u64,
    SerializedwParam: u64,
    SerializedlParam: i64,
};

pub const SPEVENTEX = extern struct {
    _bitfield: i32,
    ulStreamNum: u32,
    ullAudioStreamOffset: u64,
    wParam: WPARAM,
    lParam: LPARAM,
    ullAudioTimeOffset: u64,
};

pub const SPINTERFERENCE = enum(i32) {
    NONE = 0,
    NOISE = 1,
    NOSIGNAL = 2,
    TOOLOUD = 3,
    TOOQUIET = 4,
    TOOFAST = 5,
    TOOSLOW = 6,
    LATENCY_WARNING = 7,
    LATENCY_TRUNCATE_BEGIN = 8,
    LATENCY_TRUNCATE_END = 9,
};
pub const SPINTERFERENCE_NONE = SPINTERFERENCE.NONE;
pub const SPINTERFERENCE_NOISE = SPINTERFERENCE.NOISE;
pub const SPINTERFERENCE_NOSIGNAL = SPINTERFERENCE.NOSIGNAL;
pub const SPINTERFERENCE_TOOLOUD = SPINTERFERENCE.TOOLOUD;
pub const SPINTERFERENCE_TOOQUIET = SPINTERFERENCE.TOOQUIET;
pub const SPINTERFERENCE_TOOFAST = SPINTERFERENCE.TOOFAST;
pub const SPINTERFERENCE_TOOSLOW = SPINTERFERENCE.TOOSLOW;
pub const SPINTERFERENCE_LATENCY_WARNING = SPINTERFERENCE.LATENCY_WARNING;
pub const SPINTERFERENCE_LATENCY_TRUNCATE_BEGIN = SPINTERFERENCE.LATENCY_TRUNCATE_BEGIN;
pub const SPINTERFERENCE_LATENCY_TRUNCATE_END = SPINTERFERENCE.LATENCY_TRUNCATE_END;

pub const SPENDSRSTREAMFLAGS = enum(i32) {
    NONE = 0,
    STREAM_RELEASED = 1,
    EMULATED = 2,
};
pub const SPESF_NONE = SPENDSRSTREAMFLAGS.NONE;
pub const SPESF_STREAM_RELEASED = SPENDSRSTREAMFLAGS.STREAM_RELEASED;
pub const SPESF_EMULATED = SPENDSRSTREAMFLAGS.EMULATED;

pub const SPVFEATURE = enum(i32) {
    STRESSED = 1,
    EMPHASIS = 2,
};
pub const SPVFEATURE_STRESSED = SPVFEATURE.STRESSED;
pub const SPVFEATURE_EMPHASIS = SPVFEATURE.EMPHASIS;

pub const SPVISEMES = enum(i32) {
    @"0" = 0,
    @"1" = 1,
    @"2" = 2,
    @"3" = 3,
    @"4" = 4,
    @"5" = 5,
    @"6" = 6,
    @"7" = 7,
    @"8" = 8,
    @"9" = 9,
    @"10" = 10,
    @"11" = 11,
    @"12" = 12,
    @"13" = 13,
    @"14" = 14,
    @"15" = 15,
    @"16" = 16,
    @"17" = 17,
    @"18" = 18,
    @"19" = 19,
    @"20" = 20,
    @"21" = 21,
};
pub const SP_VISEME_0 = SPVISEMES.@"0";
pub const SP_VISEME_1 = SPVISEMES.@"1";
pub const SP_VISEME_2 = SPVISEMES.@"2";
pub const SP_VISEME_3 = SPVISEMES.@"3";
pub const SP_VISEME_4 = SPVISEMES.@"4";
pub const SP_VISEME_5 = SPVISEMES.@"5";
pub const SP_VISEME_6 = SPVISEMES.@"6";
pub const SP_VISEME_7 = SPVISEMES.@"7";
pub const SP_VISEME_8 = SPVISEMES.@"8";
pub const SP_VISEME_9 = SPVISEMES.@"9";
pub const SP_VISEME_10 = SPVISEMES.@"10";
pub const SP_VISEME_11 = SPVISEMES.@"11";
pub const SP_VISEME_12 = SPVISEMES.@"12";
pub const SP_VISEME_13 = SPVISEMES.@"13";
pub const SP_VISEME_14 = SPVISEMES.@"14";
pub const SP_VISEME_15 = SPVISEMES.@"15";
pub const SP_VISEME_16 = SPVISEMES.@"16";
pub const SP_VISEME_17 = SPVISEMES.@"17";
pub const SP_VISEME_18 = SPVISEMES.@"18";
pub const SP_VISEME_19 = SPVISEMES.@"19";
pub const SP_VISEME_20 = SPVISEMES.@"20";
pub const SP_VISEME_21 = SPVISEMES.@"21";

pub const SPEVENTSOURCEINFO = extern struct {
    ullEventInterest: u64,
    ullQueuedInterest: u64,
    ulCount: u32,
};

const IID_ISpEventSource_Value = Guid.initString("be7a9cce-5f9e-11d2-960f-00c04f8ee628");
pub const IID_ISpEventSource = &IID_ISpEventSource_Value;
pub const ISpEventSource = extern struct {
    pub const VTable = extern struct {
        base: ISpNotifySource.VTable,
        SetInterest: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpEventSource,
                ullEventInterest: u64,
                ullQueuedInterest: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpEventSource,
                ullEventInterest: u64,
                ullQueuedInterest: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEvents: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpEventSource,
                ulCount: u32,
                pEventArray: ?*SPEVENT,
                pulFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpEventSource,
                ulCount: u32,
                pEventArray: ?*SPEVENT,
                pulFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpEventSource,
                pInfo: ?*SPEVENTSOURCEINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpEventSource,
                pInfo: ?*SPEVENTSOURCEINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISpNotifySource.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpEventSource_SetInterest(self: *const T, ullEventInterest: u64, ullQueuedInterest: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpEventSource.VTable, self.vtable).SetInterest(@ptrCast(*const ISpEventSource, self), ullEventInterest, ullQueuedInterest);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpEventSource_GetEvents(self: *const T, ulCount: u32, pEventArray: ?*SPEVENT, pulFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpEventSource.VTable, self.vtable).GetEvents(@ptrCast(*const ISpEventSource, self), ulCount, pEventArray, pulFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpEventSource_GetInfo(self: *const T, pInfo: ?*SPEVENTSOURCEINFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpEventSource.VTable, self.vtable).GetInfo(@ptrCast(*const ISpEventSource, self), pInfo);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpEventSource2_Value = Guid.initString("2373a435-6a4b-429e-a6ac-d4231a61975b");
pub const IID_ISpEventSource2 = &IID_ISpEventSource2_Value;
pub const ISpEventSource2 = extern struct {
    pub const VTable = extern struct {
        base: ISpEventSource.VTable,
        GetEventsEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpEventSource2,
                ulCount: u32,
                pEventArray: ?*SPEVENTEX,
                pulFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpEventSource2,
                ulCount: u32,
                pEventArray: ?*SPEVENTEX,
                pulFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISpEventSource.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpEventSource2_GetEventsEx(self: *const T, ulCount: u32, pEventArray: ?*SPEVENTEX, pulFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpEventSource2.VTable, self.vtable).GetEventsEx(@ptrCast(*const ISpEventSource2, self), ulCount, pEventArray, pulFetched);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpEventSink_Value = Guid.initString("be7a9cc9-5f9e-11d2-960f-00c04f8ee628");
pub const IID_ISpEventSink = &IID_ISpEventSink_Value;
pub const ISpEventSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddEvents: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpEventSink,
                pEventArray: ?*const SPEVENT,
                ulCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpEventSink,
                pEventArray: ?*const SPEVENT,
                ulCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventInterest: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpEventSink,
                pullEventInterest: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpEventSink,
                pullEventInterest: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpEventSink_AddEvents(self: *const T, pEventArray: ?*const SPEVENT, ulCount: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpEventSink.VTable, self.vtable).AddEvents(@ptrCast(*const ISpEventSink, self), pEventArray, ulCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpEventSink_GetEventInterest(self: *const T, pullEventInterest: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpEventSink.VTable, self.vtable).GetEventInterest(@ptrCast(*const ISpEventSink, self), pullEventInterest);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpStreamFormat_Value = Guid.initString("bed530be-2606-4f4d-a1c0-54c5cda5566f");
pub const IID_ISpStreamFormat = &IID_ISpStreamFormat_Value;
pub const ISpStreamFormat = extern struct {
    pub const VTable = extern struct {
        base: IStream.VTable,
        GetFormat: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpStreamFormat,
                pguidFormatId: ?*Guid,
                ppCoMemWaveFormatEx: ?*?*WAVEFORMATEX,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpStreamFormat,
                pguidFormatId: ?*Guid,
                ppCoMemWaveFormatEx: ?*?*WAVEFORMATEX,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IStream.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpStreamFormat_GetFormat(self: *const T, pguidFormatId: ?*Guid, ppCoMemWaveFormatEx: ?*?*WAVEFORMATEX) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpStreamFormat.VTable, self.vtable).GetFormat(@ptrCast(*const ISpStreamFormat, self), pguidFormatId, ppCoMemWaveFormatEx);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SPFILEMODE = enum(i32) {
    OPEN_READONLY = 0,
    OPEN_READWRITE = 1,
    CREATE = 2,
    CREATE_ALWAYS = 3,
    NUM_MODES = 4,
};
pub const SPFM_OPEN_READONLY = SPFILEMODE.OPEN_READONLY;
pub const SPFM_OPEN_READWRITE = SPFILEMODE.OPEN_READWRITE;
pub const SPFM_CREATE = SPFILEMODE.CREATE;
pub const SPFM_CREATE_ALWAYS = SPFILEMODE.CREATE_ALWAYS;
pub const SPFM_NUM_MODES = SPFILEMODE.NUM_MODES;

const IID_ISpStream_Value = Guid.initString("12e3cca9-7518-44c5-a5e7-ba5a79cb929e");
pub const IID_ISpStream = &IID_ISpStream_Value;
pub const ISpStream = extern struct {
    pub const VTable = extern struct {
        base: ISpStreamFormat.VTable,
        SetBaseStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpStream,
                pStream: ?*IStream,
                rguidFormat: ?*const Guid,
                pWaveFormatEx: ?*const WAVEFORMATEX,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpStream,
                pStream: ?*IStream,
                rguidFormat: ?*const Guid,
                pWaveFormatEx: ?*const WAVEFORMATEX,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBaseStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpStream,
                ppStream: ?*?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpStream,
                ppStream: ?*?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BindToFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpStream,
                pszFileName: ?[*:0]const u16,
                eMode: SPFILEMODE,
                pFormatId: ?*const Guid,
                pWaveFormatEx: ?*const WAVEFORMATEX,
                ullEventInterest: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpStream,
                pszFileName: ?[*:0]const u16,
                eMode: SPFILEMODE,
                pFormatId: ?*const Guid,
                pWaveFormatEx: ?*const WAVEFORMATEX,
                ullEventInterest: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Close: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISpStreamFormat.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpStream_SetBaseStream(self: *const T, pStream: ?*IStream, rguidFormat: ?*const Guid, pWaveFormatEx: ?*const WAVEFORMATEX) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpStream.VTable, self.vtable).SetBaseStream(@ptrCast(*const ISpStream, self), pStream, rguidFormat, pWaveFormatEx);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpStream_GetBaseStream(self: *const T, ppStream: ?*?*IStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpStream.VTable, self.vtable).GetBaseStream(@ptrCast(*const ISpStream, self), ppStream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpStream_BindToFile(self: *const T, pszFileName: ?[*:0]const u16, eMode: SPFILEMODE, pFormatId: ?*const Guid, pWaveFormatEx: ?*const WAVEFORMATEX, ullEventInterest: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpStream.VTable, self.vtable).BindToFile(@ptrCast(*const ISpStream, self), pszFileName, eMode, pFormatId, pWaveFormatEx, ullEventInterest);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpStream_Close(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpStream.VTable, self.vtable).Close(@ptrCast(*const ISpStream, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpStreamFormatConverter_Value = Guid.initString("678a932c-ea71-4446-9b41-78fda6280a29");
pub const IID_ISpStreamFormatConverter = &IID_ISpStreamFormatConverter_Value;
pub const ISpStreamFormatConverter = extern struct {
    pub const VTable = extern struct {
        base: ISpStreamFormat.VTable,
        SetBaseStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpStreamFormatConverter,
                pStream: ?*ISpStreamFormat,
                fSetFormatToBaseStreamFormat: BOOL,
                fWriteToBaseStream: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpStreamFormatConverter,
                pStream: ?*ISpStreamFormat,
                fSetFormatToBaseStreamFormat: BOOL,
                fWriteToBaseStream: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBaseStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpStreamFormatConverter,
                ppStream: ?*?*ISpStreamFormat,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpStreamFormatConverter,
                ppStream: ?*?*ISpStreamFormat,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFormat: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpStreamFormatConverter,
                rguidFormatIdOfConvertedStream: ?*const Guid,
                pWaveFormatExOfConvertedStream: ?*const WAVEFORMATEX,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpStreamFormatConverter,
                rguidFormatIdOfConvertedStream: ?*const Guid,
                pWaveFormatExOfConvertedStream: ?*const WAVEFORMATEX,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ResetSeekPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpStreamFormatConverter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpStreamFormatConverter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ScaleConvertedToBaseOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpStreamFormatConverter,
                ullOffsetConvertedStream: u64,
                pullOffsetBaseStream: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpStreamFormatConverter,
                ullOffsetConvertedStream: u64,
                pullOffsetBaseStream: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ScaleBaseToConvertedOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpStreamFormatConverter,
                ullOffsetBaseStream: u64,
                pullOffsetConvertedStream: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpStreamFormatConverter,
                ullOffsetBaseStream: u64,
                pullOffsetConvertedStream: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISpStreamFormat.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpStreamFormatConverter_SetBaseStream(self: *const T, pStream: ?*ISpStreamFormat, fSetFormatToBaseStreamFormat: BOOL, fWriteToBaseStream: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpStreamFormatConverter.VTable, self.vtable).SetBaseStream(@ptrCast(*const ISpStreamFormatConverter, self), pStream, fSetFormatToBaseStreamFormat, fWriteToBaseStream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpStreamFormatConverter_GetBaseStream(self: *const T, ppStream: ?*?*ISpStreamFormat) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpStreamFormatConverter.VTable, self.vtable).GetBaseStream(@ptrCast(*const ISpStreamFormatConverter, self), ppStream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpStreamFormatConverter_SetFormat(self: *const T, rguidFormatIdOfConvertedStream: ?*const Guid, pWaveFormatExOfConvertedStream: ?*const WAVEFORMATEX) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpStreamFormatConverter.VTable, self.vtable).SetFormat(@ptrCast(*const ISpStreamFormatConverter, self), rguidFormatIdOfConvertedStream, pWaveFormatExOfConvertedStream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpStreamFormatConverter_ResetSeekPosition(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpStreamFormatConverter.VTable, self.vtable).ResetSeekPosition(@ptrCast(*const ISpStreamFormatConverter, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpStreamFormatConverter_ScaleConvertedToBaseOffset(self: *const T, ullOffsetConvertedStream: u64, pullOffsetBaseStream: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpStreamFormatConverter.VTable, self.vtable).ScaleConvertedToBaseOffset(@ptrCast(*const ISpStreamFormatConverter, self), ullOffsetConvertedStream, pullOffsetBaseStream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpStreamFormatConverter_ScaleBaseToConvertedOffset(self: *const T, ullOffsetBaseStream: u64, pullOffsetConvertedStream: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpStreamFormatConverter.VTable, self.vtable).ScaleBaseToConvertedOffset(@ptrCast(*const ISpStreamFormatConverter, self), ullOffsetBaseStream, pullOffsetConvertedStream);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SPAUDIOSTATE = enum(i32) {
    CLOSED = 0,
    STOP = 1,
    PAUSE = 2,
    RUN = 3,
};
pub const SPAS_CLOSED = SPAUDIOSTATE.CLOSED;
pub const SPAS_STOP = SPAUDIOSTATE.STOP;
pub const SPAS_PAUSE = SPAUDIOSTATE.PAUSE;
pub const SPAS_RUN = SPAUDIOSTATE.RUN;

pub const SPAUDIOSTATUS = extern struct {
    cbFreeBuffSpace: i32,
    cbNonBlockingIO: u32,
    State: SPAUDIOSTATE,
    CurSeekPos: u64,
    CurDevicePos: u64,
    dwAudioLevel: u32,
    dwReserved2: u32,
};

pub const SPAUDIOBUFFERINFO = extern struct {
    ulMsMinNotification: u32,
    ulMsBufferSize: u32,
    ulMsEventBias: u32,
};

const IID_ISpAudio_Value = Guid.initString("c05c768f-fae8-4ec2-8e07-338321c12452");
pub const IID_ISpAudio = &IID_ISpAudio_Value;
pub const ISpAudio = extern struct {
    pub const VTable = extern struct {
        base: ISpStreamFormat.VTable,
        SetState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpAudio,
                NewState: SPAUDIOSTATE,
                ullReserved: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpAudio,
                NewState: SPAUDIOSTATE,
                ullReserved: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFormat: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpAudio,
                rguidFmtId: ?*const Guid,
                pWaveFormatEx: ?*const WAVEFORMATEX,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpAudio,
                rguidFmtId: ?*const Guid,
                pWaveFormatEx: ?*const WAVEFORMATEX,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpAudio,
                pStatus: ?*SPAUDIOSTATUS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpAudio,
                pStatus: ?*SPAUDIOSTATUS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetBufferInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpAudio,
                pBuffInfo: ?*const SPAUDIOBUFFERINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpAudio,
                pBuffInfo: ?*const SPAUDIOBUFFERINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBufferInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpAudio,
                pBuffInfo: ?*SPAUDIOBUFFERINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpAudio,
                pBuffInfo: ?*SPAUDIOBUFFERINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDefaultFormat: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpAudio,
                pFormatId: ?*Guid,
                ppCoMemWaveFormatEx: ?*?*WAVEFORMATEX,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpAudio,
                pFormatId: ?*Guid,
                ppCoMemWaveFormatEx: ?*?*WAVEFORMATEX,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EventHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpAudio,
            ) callconv(@import("std").os.windows.WINAPI) ?HANDLE,
            else => *const fn(
                self: *const ISpAudio,
            ) callconv(@import("std").os.windows.WINAPI) ?HANDLE,
        },
        GetVolumeLevel: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpAudio,
                pLevel: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpAudio,
                pLevel: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetVolumeLevel: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpAudio,
                Level: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpAudio,
                Level: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBufferNotifySize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpAudio,
                pcbSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpAudio,
                pcbSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetBufferNotifySize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpAudio,
                cbSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpAudio,
                cbSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISpStreamFormat.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpAudio_SetState(self: *const T, NewState: SPAUDIOSTATE, ullReserved: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpAudio.VTable, self.vtable).SetState(@ptrCast(*const ISpAudio, self), NewState, ullReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpAudio_SetFormat(self: *const T, rguidFmtId: ?*const Guid, pWaveFormatEx: ?*const WAVEFORMATEX) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpAudio.VTable, self.vtable).SetFormat(@ptrCast(*const ISpAudio, self), rguidFmtId, pWaveFormatEx);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpAudio_GetStatus(self: *const T, pStatus: ?*SPAUDIOSTATUS) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpAudio.VTable, self.vtable).GetStatus(@ptrCast(*const ISpAudio, self), pStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpAudio_SetBufferInfo(self: *const T, pBuffInfo: ?*const SPAUDIOBUFFERINFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpAudio.VTable, self.vtable).SetBufferInfo(@ptrCast(*const ISpAudio, self), pBuffInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpAudio_GetBufferInfo(self: *const T, pBuffInfo: ?*SPAUDIOBUFFERINFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpAudio.VTable, self.vtable).GetBufferInfo(@ptrCast(*const ISpAudio, self), pBuffInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpAudio_GetDefaultFormat(self: *const T, pFormatId: ?*Guid, ppCoMemWaveFormatEx: ?*?*WAVEFORMATEX) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpAudio.VTable, self.vtable).GetDefaultFormat(@ptrCast(*const ISpAudio, self), pFormatId, ppCoMemWaveFormatEx);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpAudio_EventHandle(self: *const T) callconv(.Inline) ?HANDLE {
            return @ptrCast(*const ISpAudio.VTable, self.vtable).EventHandle(@ptrCast(*const ISpAudio, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpAudio_GetVolumeLevel(self: *const T, pLevel: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpAudio.VTable, self.vtable).GetVolumeLevel(@ptrCast(*const ISpAudio, self), pLevel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpAudio_SetVolumeLevel(self: *const T, Level: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpAudio.VTable, self.vtable).SetVolumeLevel(@ptrCast(*const ISpAudio, self), Level);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpAudio_GetBufferNotifySize(self: *const T, pcbSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpAudio.VTable, self.vtable).GetBufferNotifySize(@ptrCast(*const ISpAudio, self), pcbSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpAudio_SetBufferNotifySize(self: *const T, cbSize: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpAudio.VTable, self.vtable).SetBufferNotifySize(@ptrCast(*const ISpAudio, self), cbSize);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpMMSysAudio_Value = Guid.initString("15806f6e-1d70-4b48-98e6-3b1a007509ab");
pub const IID_ISpMMSysAudio = &IID_ISpMMSysAudio_Value;
pub const ISpMMSysAudio = extern struct {
    pub const VTable = extern struct {
        base: ISpAudio.VTable,
        GetDeviceId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpMMSysAudio,
                puDeviceId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpMMSysAudio,
                puDeviceId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDeviceId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpMMSysAudio,
                uDeviceId: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpMMSysAudio,
                uDeviceId: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMMHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpMMSysAudio,
                pHandle: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpMMSysAudio,
                pHandle: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLineId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpMMSysAudio,
                puLineId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpMMSysAudio,
                puLineId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetLineId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpMMSysAudio,
                uLineId: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpMMSysAudio,
                uLineId: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISpAudio.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpMMSysAudio_GetDeviceId(self: *const T, puDeviceId: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpMMSysAudio.VTable, self.vtable).GetDeviceId(@ptrCast(*const ISpMMSysAudio, self), puDeviceId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpMMSysAudio_SetDeviceId(self: *const T, uDeviceId: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpMMSysAudio.VTable, self.vtable).SetDeviceId(@ptrCast(*const ISpMMSysAudio, self), uDeviceId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpMMSysAudio_GetMMHandle(self: *const T, pHandle: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpMMSysAudio.VTable, self.vtable).GetMMHandle(@ptrCast(*const ISpMMSysAudio, self), pHandle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpMMSysAudio_GetLineId(self: *const T, puLineId: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpMMSysAudio.VTable, self.vtable).GetLineId(@ptrCast(*const ISpMMSysAudio, self), puLineId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpMMSysAudio_SetLineId(self: *const T, uLineId: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpMMSysAudio.VTable, self.vtable).SetLineId(@ptrCast(*const ISpMMSysAudio, self), uLineId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpTranscript_Value = Guid.initString("10f63bce-201a-11d3-ac70-00c04f8ee6c0");
pub const IID_ISpTranscript = &IID_ISpTranscript_Value;
pub const ISpTranscript = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTranscript: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpTranscript,
                ppszTranscript: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpTranscript,
                ppszTranscript: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AppendTranscript: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpTranscript,
                pszTranscript: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpTranscript,
                pszTranscript: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpTranscript_GetTranscript(self: *const T, ppszTranscript: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpTranscript.VTable, self.vtable).GetTranscript(@ptrCast(*const ISpTranscript, self), ppszTranscript);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpTranscript_AppendTranscript(self: *const T, pszTranscript: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpTranscript.VTable, self.vtable).AppendTranscript(@ptrCast(*const ISpTranscript, self), pszTranscript);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SPDISPLYATTRIBUTES = enum(i32) {
    ONE_TRAILING_SPACE = 2,
    TWO_TRAILING_SPACES = 4,
    CONSUME_LEADING_SPACES = 8,
    BUFFER_POSITION = 16,
    ALL = 31,
    USER_SPECIFIED = 128,
};
pub const SPAF_ONE_TRAILING_SPACE = SPDISPLYATTRIBUTES.ONE_TRAILING_SPACE;
pub const SPAF_TWO_TRAILING_SPACES = SPDISPLYATTRIBUTES.TWO_TRAILING_SPACES;
pub const SPAF_CONSUME_LEADING_SPACES = SPDISPLYATTRIBUTES.CONSUME_LEADING_SPACES;
pub const SPAF_BUFFER_POSITION = SPDISPLYATTRIBUTES.BUFFER_POSITION;
pub const SPAF_ALL = SPDISPLYATTRIBUTES.ALL;
pub const SPAF_USER_SPECIFIED = SPDISPLYATTRIBUTES.USER_SPECIFIED;

pub const SPPHRASEELEMENT = extern struct {
    ulAudioTimeOffset: u32,
    ulAudioSizeTime: u32,
    ulAudioStreamOffset: u32,
    ulAudioSizeBytes: u32,
    ulRetainedStreamOffset: u32,
    ulRetainedSizeBytes: u32,
    pszDisplayText: ?[*:0]const u16,
    pszLexicalForm: ?[*:0]const u16,
    pszPronunciation: ?*const u16,
    bDisplayAttributes: u8,
    RequiredConfidence: i8,
    ActualConfidence: i8,
    Reserved: u8,
    SREngineConfidence: f32,
};

pub const SPPHRASERULE = extern struct {
    pszName: ?[*:0]const u16,
    ulId: u32,
    ulFirstElement: u32,
    ulCountOfElements: u32,
    pNextSibling: ?*const SPPHRASERULE,
    pFirstChild: ?*const SPPHRASERULE,
    SREngineConfidence: f32,
    Confidence: i8,
};

pub const SPPHRASEPROPERTYUNIONTYPE = enum(i32) {
    UNUSED = 0,
    ARRAY_INDEX = 1,
};
pub const SPPPUT_UNUSED = SPPHRASEPROPERTYUNIONTYPE.UNUSED;
pub const SPPPUT_ARRAY_INDEX = SPPHRASEPROPERTYUNIONTYPE.ARRAY_INDEX;

pub const SPPHRASEPROPERTY = extern struct {
    pszName: ?[*:0]const u16,
    Anonymous: extern union {
        ulId: u32,
        Anonymous: extern struct {
            bType: u8,
            bReserved: u8,
            usArrayIndex: u16,
        },
    },
    pszValue: ?[*:0]const u16,
    vValue: VARIANT,
    ulFirstElement: u32,
    ulCountOfElements: u32,
    pNextSibling: ?*const SPPHRASEPROPERTY,
    pFirstChild: ?*const SPPHRASEPROPERTY,
    SREngineConfidence: f32,
    Confidence: i8,
};

pub const SPPHRASEREPLACEMENT = extern struct {
    bDisplayAttributes: u8,
    pszReplacementText: ?[*:0]const u16,
    ulFirstElement: u32,
    ulCountOfElements: u32,
};

pub const SPSEMANTICERRORINFO = extern struct {
    ulLineNumber: u32,
    pszScriptLine: ?PWSTR,
    pszSource: ?PWSTR,
    pszDescription: ?PWSTR,
    hrResultCode: HRESULT,
};

pub const SPSEMANTICFORMAT = enum(i32) {
    SAPI_PROPERTIES = 0,
    SRGS_SEMANTICINTERPRETATION_MS = 1,
    SRGS_SAPIPROPERTIES = 2,
    UPS = 4,
    SRGS_SEMANTICINTERPRETATION_W3C = 8,
};
pub const SPSMF_SAPI_PROPERTIES = SPSEMANTICFORMAT.SAPI_PROPERTIES;
pub const SPSMF_SRGS_SEMANTICINTERPRETATION_MS = SPSEMANTICFORMAT.SRGS_SEMANTICINTERPRETATION_MS;
pub const SPSMF_SRGS_SAPIPROPERTIES = SPSEMANTICFORMAT.SRGS_SAPIPROPERTIES;
pub const SPSMF_UPS = SPSEMANTICFORMAT.UPS;
pub const SPSMF_SRGS_SEMANTICINTERPRETATION_W3C = SPSEMANTICFORMAT.SRGS_SEMANTICINTERPRETATION_W3C;

pub const SPPHRASE_50 = extern struct {
    cbSize: u32,
    LangID: u16,
    wHomophoneGroupId: u16,
    ullGrammarID: u64,
    ftStartTime: u64,
    ullAudioStreamPosition: u64,
    ulAudioSizeBytes: u32,
    ulRetainedSizeBytes: u32,
    ulAudioSizeTime: u32,
    Rule: SPPHRASERULE,
    pProperties: ?*const SPPHRASEPROPERTY,
    pElements: ?*const SPPHRASEELEMENT,
    cReplacements: u32,
    pReplacements: ?*const SPPHRASEREPLACEMENT,
    SREngineID: Guid,
    ulSREnginePrivateDataSize: u32,
    pSREnginePrivateData: ?*const u8,
};

pub const SPPHRASE = extern struct {
    __AnonymousBase_sapi53_L5821_C34: SPPHRASE_50,
    pSML: ?PWSTR,
    pSemanticErrorInfo: ?*SPSEMANTICERRORINFO,
};

pub const SPSERIALIZEDPHRASE = extern struct {
    ulSerializedSize: u32,
};

pub const SPRULE = extern struct {
    pszRuleName: ?[*:0]const u16,
    ulRuleId: u32,
    dwAttributes: u32,
};

pub const SPVALUETYPE = enum(i32) {
    PROPERTY = 1,
    REPLACEMENT = 2,
    RULE = 4,
    DISPLAYTEXT = 8,
    LEXICALFORM = 16,
    PRONUNCIATION = 32,
    AUDIO = 64,
    ALTERNATES = 128,
    ALL = 255,
};
pub const SPDF_PROPERTY = SPVALUETYPE.PROPERTY;
pub const SPDF_REPLACEMENT = SPVALUETYPE.REPLACEMENT;
pub const SPDF_RULE = SPVALUETYPE.RULE;
pub const SPDF_DISPLAYTEXT = SPVALUETYPE.DISPLAYTEXT;
pub const SPDF_LEXICALFORM = SPVALUETYPE.LEXICALFORM;
pub const SPDF_PRONUNCIATION = SPVALUETYPE.PRONUNCIATION;
pub const SPDF_AUDIO = SPVALUETYPE.AUDIO;
pub const SPDF_ALTERNATES = SPVALUETYPE.ALTERNATES;
pub const SPDF_ALL = SPVALUETYPE.ALL;

pub const SPBINARYGRAMMAR = extern struct {
    ulTotalSerializedSize: u32,
};

pub const SPPHRASERNG = enum(i32) {
    S = -1,
};
pub const SPPR_ALL_ELEMENTS = SPPHRASERNG.S;

pub const SPSTATEHANDLE__ = extern struct {
    unused: i32,
};

pub const SPRECOEVENTFLAGS = enum(i32) {
    AutoPause = 1,
    Emulated = 2,
    SMLTimeout = 4,
    ExtendableParse = 8,
    ReSent = 16,
    Hypothesis = 32,
    FalseRecognition = 64,
};
pub const SPREF_AutoPause = SPRECOEVENTFLAGS.AutoPause;
pub const SPREF_Emulated = SPRECOEVENTFLAGS.Emulated;
pub const SPREF_SMLTimeout = SPRECOEVENTFLAGS.SMLTimeout;
pub const SPREF_ExtendableParse = SPRECOEVENTFLAGS.ExtendableParse;
pub const SPREF_ReSent = SPRECOEVENTFLAGS.ReSent;
pub const SPREF_Hypothesis = SPRECOEVENTFLAGS.Hypothesis;
pub const SPREF_FalseRecognition = SPRECOEVENTFLAGS.FalseRecognition;

pub const SPPARTOFSPEECH = enum(i32) {
    NotOverriden = -1,
    Unknown = 0,
    Noun = 4096,
    Verb = 8192,
    Modifier = 12288,
    Function = 16384,
    Interjection = 20480,
    Noncontent = 24576,
    LMA = 28672,
    SuppressWord = 61440,
};
pub const SPPS_NotOverriden = SPPARTOFSPEECH.NotOverriden;
pub const SPPS_Unknown = SPPARTOFSPEECH.Unknown;
pub const SPPS_Noun = SPPARTOFSPEECH.Noun;
pub const SPPS_Verb = SPPARTOFSPEECH.Verb;
pub const SPPS_Modifier = SPPARTOFSPEECH.Modifier;
pub const SPPS_Function = SPPARTOFSPEECH.Function;
pub const SPPS_Interjection = SPPARTOFSPEECH.Interjection;
pub const SPPS_Noncontent = SPPARTOFSPEECH.Noncontent;
pub const SPPS_LMA = SPPARTOFSPEECH.LMA;
pub const SPPS_SuppressWord = SPPARTOFSPEECH.SuppressWord;

pub const SPLEXICONTYPE = enum(i32) {
    USER = 1,
    APP = 2,
    VENDORLEXICON = 4,
    LETTERTOSOUND = 8,
    MORPHOLOGY = 16,
    RESERVED4 = 32,
    USER_SHORTCUT = 64,
    RESERVED6 = 128,
    RESERVED7 = 256,
    RESERVED8 = 512,
    RESERVED9 = 1024,
    RESERVED10 = 2048,
    PRIVATE1 = 4096,
    PRIVATE2 = 8192,
    PRIVATE3 = 16384,
    PRIVATE4 = 32768,
    PRIVATE5 = 65536,
    PRIVATE6 = 131072,
    PRIVATE7 = 262144,
    PRIVATE8 = 524288,
    PRIVATE9 = 1048576,
    PRIVATE10 = 2097152,
    PRIVATE11 = 4194304,
    PRIVATE12 = 8388608,
    PRIVATE13 = 16777216,
    PRIVATE14 = 33554432,
    PRIVATE15 = 67108864,
    PRIVATE16 = 134217728,
    PRIVATE17 = 268435456,
    PRIVATE18 = 536870912,
    PRIVATE19 = 1073741824,
    PRIVATE20 = -2147483648,
};
pub const eLEXTYPE_USER = SPLEXICONTYPE.USER;
pub const eLEXTYPE_APP = SPLEXICONTYPE.APP;
pub const eLEXTYPE_VENDORLEXICON = SPLEXICONTYPE.VENDORLEXICON;
pub const eLEXTYPE_LETTERTOSOUND = SPLEXICONTYPE.LETTERTOSOUND;
pub const eLEXTYPE_MORPHOLOGY = SPLEXICONTYPE.MORPHOLOGY;
pub const eLEXTYPE_RESERVED4 = SPLEXICONTYPE.RESERVED4;
pub const eLEXTYPE_USER_SHORTCUT = SPLEXICONTYPE.USER_SHORTCUT;
pub const eLEXTYPE_RESERVED6 = SPLEXICONTYPE.RESERVED6;
pub const eLEXTYPE_RESERVED7 = SPLEXICONTYPE.RESERVED7;
pub const eLEXTYPE_RESERVED8 = SPLEXICONTYPE.RESERVED8;
pub const eLEXTYPE_RESERVED9 = SPLEXICONTYPE.RESERVED9;
pub const eLEXTYPE_RESERVED10 = SPLEXICONTYPE.RESERVED10;
pub const eLEXTYPE_PRIVATE1 = SPLEXICONTYPE.PRIVATE1;
pub const eLEXTYPE_PRIVATE2 = SPLEXICONTYPE.PRIVATE2;
pub const eLEXTYPE_PRIVATE3 = SPLEXICONTYPE.PRIVATE3;
pub const eLEXTYPE_PRIVATE4 = SPLEXICONTYPE.PRIVATE4;
pub const eLEXTYPE_PRIVATE5 = SPLEXICONTYPE.PRIVATE5;
pub const eLEXTYPE_PRIVATE6 = SPLEXICONTYPE.PRIVATE6;
pub const eLEXTYPE_PRIVATE7 = SPLEXICONTYPE.PRIVATE7;
pub const eLEXTYPE_PRIVATE8 = SPLEXICONTYPE.PRIVATE8;
pub const eLEXTYPE_PRIVATE9 = SPLEXICONTYPE.PRIVATE9;
pub const eLEXTYPE_PRIVATE10 = SPLEXICONTYPE.PRIVATE10;
pub const eLEXTYPE_PRIVATE11 = SPLEXICONTYPE.PRIVATE11;
pub const eLEXTYPE_PRIVATE12 = SPLEXICONTYPE.PRIVATE12;
pub const eLEXTYPE_PRIVATE13 = SPLEXICONTYPE.PRIVATE13;
pub const eLEXTYPE_PRIVATE14 = SPLEXICONTYPE.PRIVATE14;
pub const eLEXTYPE_PRIVATE15 = SPLEXICONTYPE.PRIVATE15;
pub const eLEXTYPE_PRIVATE16 = SPLEXICONTYPE.PRIVATE16;
pub const eLEXTYPE_PRIVATE17 = SPLEXICONTYPE.PRIVATE17;
pub const eLEXTYPE_PRIVATE18 = SPLEXICONTYPE.PRIVATE18;
pub const eLEXTYPE_PRIVATE19 = SPLEXICONTYPE.PRIVATE19;
pub const eLEXTYPE_PRIVATE20 = SPLEXICONTYPE.PRIVATE20;

pub const SPWORDTYPE = enum(i32) {
    ADDED = 1,
    DELETED = 2,
};
pub const eWORDTYPE_ADDED = SPWORDTYPE.ADDED;
pub const eWORDTYPE_DELETED = SPWORDTYPE.DELETED;

pub const SPPRONUNCIATIONFLAGS = enum(i32) {
    D = 1,
};
pub const ePRONFLAG_USED = SPPRONUNCIATIONFLAGS.D;

pub const SPWORDPRONUNCIATION = extern struct {
    pNextWordPronunciation: ?*SPWORDPRONUNCIATION,
    eLexiconType: SPLEXICONTYPE,
    LangID: u16,
    wPronunciationFlags: u16,
    ePartOfSpeech: SPPARTOFSPEECH,
    szPronunciation: [1]u16,
};

pub const SPWORDPRONUNCIATIONLIST = extern struct {
    ulSize: u32,
    pvBuffer: ?*u8,
    pFirstWordPronunciation: ?*SPWORDPRONUNCIATION,
};

pub const SPWORD = extern struct {
    pNextWord: ?*SPWORD,
    LangID: u16,
    wReserved: u16,
    eWordType: SPWORDTYPE,
    pszWord: ?PWSTR,
    pFirstWordPronunciation: ?*SPWORDPRONUNCIATION,
};

pub const SPWORDLIST = extern struct {
    ulSize: u32,
    pvBuffer: ?*u8,
    pFirstWord: ?*SPWORD,
};

const IID_ISpLexicon_Value = Guid.initString("da41a7c2-5383-4db2-916b-6c1719e3db58");
pub const IID_ISpLexicon = &IID_ISpLexicon_Value;
pub const ISpLexicon = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPronunciations: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpLexicon,
                pszWord: ?[*:0]const u16,
                LangID: u16,
                dwFlags: u32,
                pWordPronunciationList: ?*SPWORDPRONUNCIATIONLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpLexicon,
                pszWord: ?[*:0]const u16,
                LangID: u16,
                dwFlags: u32,
                pWordPronunciationList: ?*SPWORDPRONUNCIATIONLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddPronunciation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpLexicon,
                pszWord: ?[*:0]const u16,
                LangID: u16,
                ePartOfSpeech: SPPARTOFSPEECH,
                pszPronunciation: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpLexicon,
                pszWord: ?[*:0]const u16,
                LangID: u16,
                ePartOfSpeech: SPPARTOFSPEECH,
                pszPronunciation: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemovePronunciation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpLexicon,
                pszWord: ?[*:0]const u16,
                LangID: u16,
                ePartOfSpeech: SPPARTOFSPEECH,
                pszPronunciation: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpLexicon,
                pszWord: ?[*:0]const u16,
                LangID: u16,
                ePartOfSpeech: SPPARTOFSPEECH,
                pszPronunciation: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetGeneration: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpLexicon,
                pdwGeneration: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpLexicon,
                pdwGeneration: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetGenerationChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpLexicon,
                dwFlags: u32,
                pdwGeneration: ?*u32,
                pWordList: ?*SPWORDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpLexicon,
                dwFlags: u32,
                pdwGeneration: ?*u32,
                pWordList: ?*SPWORDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetWords: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpLexicon,
                dwFlags: u32,
                pdwGeneration: ?*u32,
                pdwCookie: ?*u32,
                pWordList: ?*SPWORDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpLexicon,
                dwFlags: u32,
                pdwGeneration: ?*u32,
                pdwCookie: ?*u32,
                pWordList: ?*SPWORDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpLexicon_GetPronunciations(self: *const T, pszWord: ?[*:0]const u16, LangID: u16, dwFlags: u32, pWordPronunciationList: ?*SPWORDPRONUNCIATIONLIST) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpLexicon.VTable, self.vtable).GetPronunciations(@ptrCast(*const ISpLexicon, self), pszWord, LangID, dwFlags, pWordPronunciationList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpLexicon_AddPronunciation(self: *const T, pszWord: ?[*:0]const u16, LangID: u16, ePartOfSpeech: SPPARTOFSPEECH, pszPronunciation: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpLexicon.VTable, self.vtable).AddPronunciation(@ptrCast(*const ISpLexicon, self), pszWord, LangID, ePartOfSpeech, pszPronunciation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpLexicon_RemovePronunciation(self: *const T, pszWord: ?[*:0]const u16, LangID: u16, ePartOfSpeech: SPPARTOFSPEECH, pszPronunciation: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpLexicon.VTable, self.vtable).RemovePronunciation(@ptrCast(*const ISpLexicon, self), pszWord, LangID, ePartOfSpeech, pszPronunciation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpLexicon_GetGeneration(self: *const T, pdwGeneration: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpLexicon.VTable, self.vtable).GetGeneration(@ptrCast(*const ISpLexicon, self), pdwGeneration);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpLexicon_GetGenerationChange(self: *const T, dwFlags: u32, pdwGeneration: ?*u32, pWordList: ?*SPWORDLIST) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpLexicon.VTable, self.vtable).GetGenerationChange(@ptrCast(*const ISpLexicon, self), dwFlags, pdwGeneration, pWordList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpLexicon_GetWords(self: *const T, dwFlags: u32, pdwGeneration: ?*u32, pdwCookie: ?*u32, pWordList: ?*SPWORDLIST) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpLexicon.VTable, self.vtable).GetWords(@ptrCast(*const ISpLexicon, self), dwFlags, pdwGeneration, pdwCookie, pWordList);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpContainerLexicon_Value = Guid.initString("8565572f-c094-41cc-b56e-10bd9c3ff044");
pub const IID_ISpContainerLexicon = &IID_ISpContainerLexicon_Value;
pub const ISpContainerLexicon = extern struct {
    pub const VTable = extern struct {
        base: ISpLexicon.VTable,
        AddLexicon: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpContainerLexicon,
                pAddLexicon: ?*ISpLexicon,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpContainerLexicon,
                pAddLexicon: ?*ISpLexicon,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISpLexicon.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpContainerLexicon_AddLexicon(self: *const T, pAddLexicon: ?*ISpLexicon, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpContainerLexicon.VTable, self.vtable).AddLexicon(@ptrCast(*const ISpContainerLexicon, self), pAddLexicon, dwFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SPSHORTCUTTYPE = enum(i32) {
    SHT_NotOverriden = -1,
    SHT_Unknown = 0,
    SHT_EMAIL = 4096,
    SHT_OTHER = 8192,
    PS_RESERVED1 = 12288,
    PS_RESERVED2 = 16384,
    PS_RESERVED3 = 20480,
    PS_RESERVED4 = 61440,
};
pub const SPSHT_NotOverriden = SPSHORTCUTTYPE.SHT_NotOverriden;
pub const SPSHT_Unknown = SPSHORTCUTTYPE.SHT_Unknown;
pub const SPSHT_EMAIL = SPSHORTCUTTYPE.SHT_EMAIL;
pub const SPSHT_OTHER = SPSHORTCUTTYPE.SHT_OTHER;
pub const SPPS_RESERVED1 = SPSHORTCUTTYPE.PS_RESERVED1;
pub const SPPS_RESERVED2 = SPSHORTCUTTYPE.PS_RESERVED2;
pub const SPPS_RESERVED3 = SPSHORTCUTTYPE.PS_RESERVED3;
pub const SPPS_RESERVED4 = SPSHORTCUTTYPE.PS_RESERVED4;

pub const SPSHORTCUTPAIR = extern struct {
    pNextSHORTCUTPAIR: ?*SPSHORTCUTPAIR,
    LangID: u16,
    shType: SPSHORTCUTTYPE,
    pszDisplay: ?PWSTR,
    pszSpoken: ?PWSTR,
};

pub const SPSHORTCUTPAIRLIST = extern struct {
    ulSize: u32,
    pvBuffer: ?*u8,
    pFirstShortcutPair: ?*SPSHORTCUTPAIR,
};

const IID_ISpShortcut_Value = Guid.initString("3df681e2-ea56-11d9-8bde-f66bad1e3f3a");
pub const IID_ISpShortcut = &IID_ISpShortcut_Value;
pub const ISpShortcut = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddShortcut: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpShortcut,
                pszDisplay: ?[*:0]const u16,
                LangID: u16,
                pszSpoken: ?[*:0]const u16,
                shType: SPSHORTCUTTYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpShortcut,
                pszDisplay: ?[*:0]const u16,
                LangID: u16,
                pszSpoken: ?[*:0]const u16,
                shType: SPSHORTCUTTYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveShortcut: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpShortcut,
                pszDisplay: ?[*:0]const u16,
                LangID: u16,
                pszSpoken: ?[*:0]const u16,
                shType: SPSHORTCUTTYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpShortcut,
                pszDisplay: ?[*:0]const u16,
                LangID: u16,
                pszSpoken: ?[*:0]const u16,
                shType: SPSHORTCUTTYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetShortcuts: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpShortcut,
                LangID: u16,
                pShortcutpairList: ?*SPSHORTCUTPAIRLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpShortcut,
                LangID: u16,
                pShortcutpairList: ?*SPSHORTCUTPAIRLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetGeneration: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpShortcut,
                pdwGeneration: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpShortcut,
                pdwGeneration: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetWordsFromGenerationChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpShortcut,
                pdwGeneration: ?*u32,
                pWordList: ?*SPWORDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpShortcut,
                pdwGeneration: ?*u32,
                pWordList: ?*SPWORDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetWords: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpShortcut,
                pdwGeneration: ?*u32,
                pdwCookie: ?*u32,
                pWordList: ?*SPWORDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpShortcut,
                pdwGeneration: ?*u32,
                pdwCookie: ?*u32,
                pWordList: ?*SPWORDLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetShortcutsForGeneration: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpShortcut,
                pdwGeneration: ?*u32,
                pdwCookie: ?*u32,
                pShortcutpairList: ?*SPSHORTCUTPAIRLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpShortcut,
                pdwGeneration: ?*u32,
                pdwCookie: ?*u32,
                pShortcutpairList: ?*SPSHORTCUTPAIRLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetGenerationChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpShortcut,
                pdwGeneration: ?*u32,
                pShortcutpairList: ?*SPSHORTCUTPAIRLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpShortcut,
                pdwGeneration: ?*u32,
                pShortcutpairList: ?*SPSHORTCUTPAIRLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpShortcut_AddShortcut(self: *const T, pszDisplay: ?[*:0]const u16, LangID: u16, pszSpoken: ?[*:0]const u16, shType: SPSHORTCUTTYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpShortcut.VTable, self.vtable).AddShortcut(@ptrCast(*const ISpShortcut, self), pszDisplay, LangID, pszSpoken, shType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpShortcut_RemoveShortcut(self: *const T, pszDisplay: ?[*:0]const u16, LangID: u16, pszSpoken: ?[*:0]const u16, shType: SPSHORTCUTTYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpShortcut.VTable, self.vtable).RemoveShortcut(@ptrCast(*const ISpShortcut, self), pszDisplay, LangID, pszSpoken, shType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpShortcut_GetShortcuts(self: *const T, LangID: u16, pShortcutpairList: ?*SPSHORTCUTPAIRLIST) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpShortcut.VTable, self.vtable).GetShortcuts(@ptrCast(*const ISpShortcut, self), LangID, pShortcutpairList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpShortcut_GetGeneration(self: *const T, pdwGeneration: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpShortcut.VTable, self.vtable).GetGeneration(@ptrCast(*const ISpShortcut, self), pdwGeneration);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpShortcut_GetWordsFromGenerationChange(self: *const T, pdwGeneration: ?*u32, pWordList: ?*SPWORDLIST) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpShortcut.VTable, self.vtable).GetWordsFromGenerationChange(@ptrCast(*const ISpShortcut, self), pdwGeneration, pWordList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpShortcut_GetWords(self: *const T, pdwGeneration: ?*u32, pdwCookie: ?*u32, pWordList: ?*SPWORDLIST) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpShortcut.VTable, self.vtable).GetWords(@ptrCast(*const ISpShortcut, self), pdwGeneration, pdwCookie, pWordList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpShortcut_GetShortcutsForGeneration(self: *const T, pdwGeneration: ?*u32, pdwCookie: ?*u32, pShortcutpairList: ?*SPSHORTCUTPAIRLIST) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpShortcut.VTable, self.vtable).GetShortcutsForGeneration(@ptrCast(*const ISpShortcut, self), pdwGeneration, pdwCookie, pShortcutpairList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpShortcut_GetGenerationChange(self: *const T, pdwGeneration: ?*u32, pShortcutpairList: ?*SPSHORTCUTPAIRLIST) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpShortcut.VTable, self.vtable).GetGenerationChange(@ptrCast(*const ISpShortcut, self), pdwGeneration, pShortcutpairList);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpPhoneConverter_Value = Guid.initString("8445c581-0cac-4a38-abfe-9b2ce2826455");
pub const IID_ISpPhoneConverter = &IID_ISpPhoneConverter_Value;
pub const ISpPhoneConverter = extern struct {
    pub const VTable = extern struct {
        base: ISpObjectWithToken.VTable,
        PhoneToId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpPhoneConverter,
                pszPhone: ?[*:0]const u16,
                pId: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpPhoneConverter,
                pszPhone: ?[*:0]const u16,
                pId: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IdToPhone: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpPhoneConverter,
                pId: ?*u16,
                pszPhone: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpPhoneConverter,
                pId: ?*u16,
                pszPhone: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISpObjectWithToken.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpPhoneConverter_PhoneToId(self: *const T, pszPhone: ?[*:0]const u16, pId: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpPhoneConverter.VTable, self.vtable).PhoneToId(@ptrCast(*const ISpPhoneConverter, self), pszPhone, pId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpPhoneConverter_IdToPhone(self: *const T, pId: ?*u16, pszPhone: ?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpPhoneConverter.VTable, self.vtable).IdToPhone(@ptrCast(*const ISpPhoneConverter, self), pId, pszPhone);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpPhoneticAlphabetConverter_Value = Guid.initString("133adcd4-19b4-4020-9fdc-842e78253b17");
pub const IID_ISpPhoneticAlphabetConverter = &IID_ISpPhoneticAlphabetConverter_Value;
pub const ISpPhoneticAlphabetConverter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetLangId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpPhoneticAlphabetConverter,
                pLangID: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpPhoneticAlphabetConverter,
                pLangID: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetLangId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpPhoneticAlphabetConverter,
                LangID: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpPhoneticAlphabetConverter,
                LangID: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SAPI2UPS: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpPhoneticAlphabetConverter,
                pszSAPIId: ?*const u16,
                pszUPSId: [*:0]u16,
                cMaxLength: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpPhoneticAlphabetConverter,
                pszSAPIId: ?*const u16,
                pszUPSId: [*:0]u16,
                cMaxLength: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UPS2SAPI: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpPhoneticAlphabetConverter,
                pszUPSId: ?*const u16,
                pszSAPIId: [*:0]u16,
                cMaxLength: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpPhoneticAlphabetConverter,
                pszUPSId: ?*const u16,
                pszSAPIId: [*:0]u16,
                cMaxLength: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMaxConvertLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpPhoneticAlphabetConverter,
                cSrcLength: u32,
                bSAPI2UPS: BOOL,
                pcMaxDestLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpPhoneticAlphabetConverter,
                cSrcLength: u32,
                bSAPI2UPS: BOOL,
                pcMaxDestLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpPhoneticAlphabetConverter_GetLangId(self: *const T, pLangID: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpPhoneticAlphabetConverter.VTable, self.vtable).GetLangId(@ptrCast(*const ISpPhoneticAlphabetConverter, self), pLangID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpPhoneticAlphabetConverter_SetLangId(self: *const T, LangID: u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpPhoneticAlphabetConverter.VTable, self.vtable).SetLangId(@ptrCast(*const ISpPhoneticAlphabetConverter, self), LangID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpPhoneticAlphabetConverter_SAPI2UPS(self: *const T, pszSAPIId: ?*const u16, pszUPSId: [*:0]u16, cMaxLength: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpPhoneticAlphabetConverter.VTable, self.vtable).SAPI2UPS(@ptrCast(*const ISpPhoneticAlphabetConverter, self), pszSAPIId, pszUPSId, cMaxLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpPhoneticAlphabetConverter_UPS2SAPI(self: *const T, pszUPSId: ?*const u16, pszSAPIId: [*:0]u16, cMaxLength: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpPhoneticAlphabetConverter.VTable, self.vtable).UPS2SAPI(@ptrCast(*const ISpPhoneticAlphabetConverter, self), pszUPSId, pszSAPIId, cMaxLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpPhoneticAlphabetConverter_GetMaxConvertLength(self: *const T, cSrcLength: u32, bSAPI2UPS: BOOL, pcMaxDestLength: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpPhoneticAlphabetConverter.VTable, self.vtable).GetMaxConvertLength(@ptrCast(*const ISpPhoneticAlphabetConverter, self), cSrcLength, bSAPI2UPS, pcMaxDestLength);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpPhoneticAlphabetSelection_Value = Guid.initString("b2745efd-42ce-48ca-81f1-a96e02538a90");
pub const IID_ISpPhoneticAlphabetSelection = &IID_ISpPhoneticAlphabetSelection_Value;
pub const ISpPhoneticAlphabetSelection = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IsAlphabetUPS: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpPhoneticAlphabetSelection,
                pfIsUPS: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpPhoneticAlphabetSelection,
                pfIsUPS: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetAlphabetToUPS: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpPhoneticAlphabetSelection,
                fForceUPS: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpPhoneticAlphabetSelection,
                fForceUPS: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpPhoneticAlphabetSelection_IsAlphabetUPS(self: *const T, pfIsUPS: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpPhoneticAlphabetSelection.VTable, self.vtable).IsAlphabetUPS(@ptrCast(*const ISpPhoneticAlphabetSelection, self), pfIsUPS);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpPhoneticAlphabetSelection_SetAlphabetToUPS(self: *const T, fForceUPS: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpPhoneticAlphabetSelection.VTable, self.vtable).SetAlphabetToUPS(@ptrCast(*const ISpPhoneticAlphabetSelection, self), fForceUPS);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SPVPITCH = extern struct {
    MiddleAdj: i32,
    RangeAdj: i32,
};

pub const SPVACTIONS = enum(i32) {
    Speak = 0,
    Silence = 1,
    Pronounce = 2,
    Bookmark = 3,
    SpellOut = 4,
    Section = 5,
    ParseUnknownTag = 6,
};
pub const SPVA_Speak = SPVACTIONS.Speak;
pub const SPVA_Silence = SPVACTIONS.Silence;
pub const SPVA_Pronounce = SPVACTIONS.Pronounce;
pub const SPVA_Bookmark = SPVACTIONS.Bookmark;
pub const SPVA_SpellOut = SPVACTIONS.SpellOut;
pub const SPVA_Section = SPVACTIONS.Section;
pub const SPVA_ParseUnknownTag = SPVACTIONS.ParseUnknownTag;

pub const SPVCONTEXT = extern struct {
    pCategory: ?[*:0]const u16,
    pBefore: ?[*:0]const u16,
    pAfter: ?[*:0]const u16,
};

pub const SPVSTATE = extern struct {
    eAction: SPVACTIONS,
    LangID: u16,
    wReserved: u16,
    EmphAdj: i32,
    RateAdj: i32,
    Volume: u32,
    PitchAdj: SPVPITCH,
    SilenceMSecs: u32,
    pPhoneIds: ?*u16,
    ePartOfSpeech: SPPARTOFSPEECH,
    Context: SPVCONTEXT,
};

pub const SPRUNSTATE = enum(i32) {
    DONE = 1,
    IS_SPEAKING = 2,
};
pub const SPRS_DONE = SPRUNSTATE.DONE;
pub const SPRS_IS_SPEAKING = SPRUNSTATE.IS_SPEAKING;

pub const SPVLIMITS = enum(i32) {
    IN_VOLUME = 0,
    AX_VOLUME = 100,
    IN_RATE = -10,
    AX_RATE = 10,
};
pub const SPMIN_VOLUME = SPVLIMITS.IN_VOLUME;
pub const SPMAX_VOLUME = SPVLIMITS.AX_VOLUME;
pub const SPMIN_RATE = SPVLIMITS.IN_RATE;
pub const SPMAX_RATE = SPVLIMITS.AX_RATE;

pub const SPVPRIORITY = enum(i32) {
    NORMAL = 0,
    ALERT = 1,
    OVER = 2,
};
pub const SPVPRI_NORMAL = SPVPRIORITY.NORMAL;
pub const SPVPRI_ALERT = SPVPRIORITY.ALERT;
pub const SPVPRI_OVER = SPVPRIORITY.OVER;

pub const SPVOICESTATUS = extern struct {
    ulCurrentStream: u32,
    ulLastStreamQueued: u32,
    hrLastResult: HRESULT,
    dwRunningState: u32,
    ulInputWordPos: u32,
    ulInputWordLen: u32,
    ulInputSentPos: u32,
    ulInputSentLen: u32,
    lBookmarkId: i32,
    PhonemeId: u16,
    VisemeId: SPVISEMES,
    dwReserved1: u32,
    dwReserved2: u32,
};

pub const SPEAKFLAGS = enum(i32) {
    DEFAULT = 0,
    ASYNC = 1,
    PURGEBEFORESPEAK = 2,
    IS_FILENAME = 4,
    IS_XML = 8,
    IS_NOT_XML = 16,
    PERSIST_XML = 32,
    NLP_SPEAK_PUNC = 64,
    PARSE_SAPI = 128,
    PARSE_SSML = 256,
    // PARSE_AUTODETECT = 0, this enum value conflicts with DEFAULT
    // NLP_MASK = 64, this enum value conflicts with NLP_SPEAK_PUNC
    PARSE_MASK = 384,
    VOICE_MASK = 511,
    UNUSED_FLAGS = -512,
};
pub const SPF_DEFAULT = SPEAKFLAGS.DEFAULT;
pub const SPF_ASYNC = SPEAKFLAGS.ASYNC;
pub const SPF_PURGEBEFORESPEAK = SPEAKFLAGS.PURGEBEFORESPEAK;
pub const SPF_IS_FILENAME = SPEAKFLAGS.IS_FILENAME;
pub const SPF_IS_XML = SPEAKFLAGS.IS_XML;
pub const SPF_IS_NOT_XML = SPEAKFLAGS.IS_NOT_XML;
pub const SPF_PERSIST_XML = SPEAKFLAGS.PERSIST_XML;
pub const SPF_NLP_SPEAK_PUNC = SPEAKFLAGS.NLP_SPEAK_PUNC;
pub const SPF_PARSE_SAPI = SPEAKFLAGS.PARSE_SAPI;
pub const SPF_PARSE_SSML = SPEAKFLAGS.PARSE_SSML;
pub const SPF_PARSE_AUTODETECT = SPEAKFLAGS.DEFAULT;
pub const SPF_NLP_MASK = SPEAKFLAGS.NLP_SPEAK_PUNC;
pub const SPF_PARSE_MASK = SPEAKFLAGS.PARSE_MASK;
pub const SPF_VOICE_MASK = SPEAKFLAGS.VOICE_MASK;
pub const SPF_UNUSED_FLAGS = SPEAKFLAGS.UNUSED_FLAGS;

const IID_ISpVoice_Value = Guid.initString("6c44df74-72b9-4992-a1ec-ef996e0422d4");
pub const IID_ISpVoice = &IID_ISpVoice_Value;
pub const ISpVoice = extern struct {
    pub const VTable = extern struct {
        base: ISpEventSource.VTable,
        SetOutput: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpVoice,
                pUnkOutput: ?*IUnknown,
                fAllowFormatChanges: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpVoice,
                pUnkOutput: ?*IUnknown,
                fAllowFormatChanges: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputObjectToken: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpVoice,
                ppObjectToken: ?*?*ISpObjectToken,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpVoice,
                ppObjectToken: ?*?*ISpObjectToken,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpVoice,
                ppStream: ?*?*ISpStreamFormat,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpVoice,
                ppStream: ?*?*ISpStreamFormat,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Pause: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpVoice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpVoice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Resume: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpVoice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpVoice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetVoice: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpVoice,
                pToken: ?*ISpObjectToken,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpVoice,
                pToken: ?*ISpObjectToken,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVoice: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpVoice,
                ppToken: ?*?*ISpObjectToken,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpVoice,
                ppToken: ?*?*ISpObjectToken,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Speak: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpVoice,
                pwcs: ?[*:0]const u16,
                dwFlags: u32,
                pulStreamNumber: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpVoice,
                pwcs: ?[*:0]const u16,
                dwFlags: u32,
                pulStreamNumber: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SpeakStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpVoice,
                pStream: ?*IStream,
                dwFlags: u32,
                pulStreamNumber: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpVoice,
                pStream: ?*IStream,
                dwFlags: u32,
                pulStreamNumber: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpVoice,
                pStatus: ?*SPVOICESTATUS,
                ppszLastBookmark: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpVoice,
                pStatus: ?*SPVOICESTATUS,
                ppszLastBookmark: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpVoice,
                pItemType: ?[*:0]const u16,
                lNumItems: i32,
                pulNumSkipped: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpVoice,
                pItemType: ?[*:0]const u16,
                lNumItems: i32,
                pulNumSkipped: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPriority: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpVoice,
                ePriority: SPVPRIORITY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpVoice,
                ePriority: SPVPRIORITY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPriority: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpVoice,
                pePriority: ?*SPVPRIORITY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpVoice,
                pePriority: ?*SPVPRIORITY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetAlertBoundary: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpVoice,
                eBoundary: SPEVENTENUM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpVoice,
                eBoundary: SPEVENTENUM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAlertBoundary: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpVoice,
                peBoundary: ?*SPEVENTENUM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpVoice,
                peBoundary: ?*SPEVENTENUM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetRate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpVoice,
                RateAdjust: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpVoice,
                RateAdjust: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpVoice,
                pRateAdjust: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpVoice,
                pRateAdjust: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetVolume: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpVoice,
                usVolume: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpVoice,
                usVolume: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVolume: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpVoice,
                pusVolume: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpVoice,
                pusVolume: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WaitUntilDone: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpVoice,
                msTimeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpVoice,
                msTimeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSyncSpeakTimeout: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpVoice,
                msTimeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpVoice,
                msTimeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSyncSpeakTimeout: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpVoice,
                pmsTimeout: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpVoice,
                pmsTimeout: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SpeakCompleteEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpVoice,
            ) callconv(@import("std").os.windows.WINAPI) ?HANDLE,
            else => *const fn(
                self: *const ISpVoice,
            ) callconv(@import("std").os.windows.WINAPI) ?HANDLE,
        },
        IsUISupported: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpVoice,
                pszTypeOfUI: ?[*:0]const u16,
                pvExtraData: ?*anyopaque,
                cbExtraData: u32,
                pfSupported: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpVoice,
                pszTypeOfUI: ?[*:0]const u16,
                pvExtraData: ?*anyopaque,
                cbExtraData: u32,
                pfSupported: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DisplayUI: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpVoice,
                hwndParent: ?HWND,
                pszTitle: ?[*:0]const u16,
                pszTypeOfUI: ?[*:0]const u16,
                pvExtraData: ?*anyopaque,
                cbExtraData: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpVoice,
                hwndParent: ?HWND,
                pszTitle: ?[*:0]const u16,
                pszTypeOfUI: ?[*:0]const u16,
                pvExtraData: ?*anyopaque,
                cbExtraData: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISpEventSource.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpVoice_SetOutput(self: *const T, pUnkOutput: ?*IUnknown, fAllowFormatChanges: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpVoice.VTable, self.vtable).SetOutput(@ptrCast(*const ISpVoice, self), pUnkOutput, fAllowFormatChanges);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpVoice_GetOutputObjectToken(self: *const T, ppObjectToken: ?*?*ISpObjectToken) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpVoice.VTable, self.vtable).GetOutputObjectToken(@ptrCast(*const ISpVoice, self), ppObjectToken);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpVoice_GetOutputStream(self: *const T, ppStream: ?*?*ISpStreamFormat) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpVoice.VTable, self.vtable).GetOutputStream(@ptrCast(*const ISpVoice, self), ppStream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpVoice_Pause(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpVoice.VTable, self.vtable).Pause(@ptrCast(*const ISpVoice, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpVoice_Resume(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpVoice.VTable, self.vtable).Resume(@ptrCast(*const ISpVoice, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpVoice_SetVoice(self: *const T, pToken: ?*ISpObjectToken) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpVoice.VTable, self.vtable).SetVoice(@ptrCast(*const ISpVoice, self), pToken);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpVoice_GetVoice(self: *const T, ppToken: ?*?*ISpObjectToken) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpVoice.VTable, self.vtable).GetVoice(@ptrCast(*const ISpVoice, self), ppToken);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpVoice_Speak(self: *const T, pwcs: ?[*:0]const u16, dwFlags: u32, pulStreamNumber: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpVoice.VTable, self.vtable).Speak(@ptrCast(*const ISpVoice, self), pwcs, dwFlags, pulStreamNumber);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpVoice_SpeakStream(self: *const T, pStream: ?*IStream, dwFlags: u32, pulStreamNumber: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpVoice.VTable, self.vtable).SpeakStream(@ptrCast(*const ISpVoice, self), pStream, dwFlags, pulStreamNumber);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpVoice_GetStatus(self: *const T, pStatus: ?*SPVOICESTATUS, ppszLastBookmark: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpVoice.VTable, self.vtable).GetStatus(@ptrCast(*const ISpVoice, self), pStatus, ppszLastBookmark);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpVoice_Skip(self: *const T, pItemType: ?[*:0]const u16, lNumItems: i32, pulNumSkipped: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpVoice.VTable, self.vtable).Skip(@ptrCast(*const ISpVoice, self), pItemType, lNumItems, pulNumSkipped);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpVoice_SetPriority(self: *const T, ePriority: SPVPRIORITY) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpVoice.VTable, self.vtable).SetPriority(@ptrCast(*const ISpVoice, self), ePriority);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpVoice_GetPriority(self: *const T, pePriority: ?*SPVPRIORITY) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpVoice.VTable, self.vtable).GetPriority(@ptrCast(*const ISpVoice, self), pePriority);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpVoice_SetAlertBoundary(self: *const T, eBoundary: SPEVENTENUM) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpVoice.VTable, self.vtable).SetAlertBoundary(@ptrCast(*const ISpVoice, self), eBoundary);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpVoice_GetAlertBoundary(self: *const T, peBoundary: ?*SPEVENTENUM) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpVoice.VTable, self.vtable).GetAlertBoundary(@ptrCast(*const ISpVoice, self), peBoundary);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpVoice_SetRate(self: *const T, RateAdjust: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpVoice.VTable, self.vtable).SetRate(@ptrCast(*const ISpVoice, self), RateAdjust);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpVoice_GetRate(self: *const T, pRateAdjust: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpVoice.VTable, self.vtable).GetRate(@ptrCast(*const ISpVoice, self), pRateAdjust);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpVoice_SetVolume(self: *const T, usVolume: u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpVoice.VTable, self.vtable).SetVolume(@ptrCast(*const ISpVoice, self), usVolume);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpVoice_GetVolume(self: *const T, pusVolume: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpVoice.VTable, self.vtable).GetVolume(@ptrCast(*const ISpVoice, self), pusVolume);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpVoice_WaitUntilDone(self: *const T, msTimeout: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpVoice.VTable, self.vtable).WaitUntilDone(@ptrCast(*const ISpVoice, self), msTimeout);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpVoice_SetSyncSpeakTimeout(self: *const T, msTimeout: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpVoice.VTable, self.vtable).SetSyncSpeakTimeout(@ptrCast(*const ISpVoice, self), msTimeout);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpVoice_GetSyncSpeakTimeout(self: *const T, pmsTimeout: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpVoice.VTable, self.vtable).GetSyncSpeakTimeout(@ptrCast(*const ISpVoice, self), pmsTimeout);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpVoice_SpeakCompleteEvent(self: *const T) callconv(.Inline) ?HANDLE {
            return @ptrCast(*const ISpVoice.VTable, self.vtable).SpeakCompleteEvent(@ptrCast(*const ISpVoice, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpVoice_IsUISupported(self: *const T, pszTypeOfUI: ?[*:0]const u16, pvExtraData: ?*anyopaque, cbExtraData: u32, pfSupported: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpVoice.VTable, self.vtable).IsUISupported(@ptrCast(*const ISpVoice, self), pszTypeOfUI, pvExtraData, cbExtraData, pfSupported);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpVoice_DisplayUI(self: *const T, hwndParent: ?HWND, pszTitle: ?[*:0]const u16, pszTypeOfUI: ?[*:0]const u16, pvExtraData: ?*anyopaque, cbExtraData: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpVoice.VTable, self.vtable).DisplayUI(@ptrCast(*const ISpVoice, self), hwndParent, pszTitle, pszTypeOfUI, pvExtraData, cbExtraData);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpPhrase_Value = Guid.initString("1a5c0354-b621-4b5a-8791-d306ed379e53");
pub const IID_ISpPhrase = &IID_ISpPhrase_Value;
pub const ISpPhrase = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPhrase: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpPhrase,
                ppCoMemPhrase: ?*?*SPPHRASE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpPhrase,
                ppCoMemPhrase: ?*?*SPPHRASE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSerializedPhrase: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpPhrase,
                ppCoMemPhrase: ?*?*SPSERIALIZEDPHRASE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpPhrase,
                ppCoMemPhrase: ?*?*SPSERIALIZEDPHRASE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetText: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpPhrase,
                ulStart: u32,
                ulCount: u32,
                fUseTextReplacements: BOOL,
                ppszCoMemText: ?*?PWSTR,
                pbDisplayAttributes: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpPhrase,
                ulStart: u32,
                ulCount: u32,
                fUseTextReplacements: BOOL,
                ppszCoMemText: ?*?PWSTR,
                pbDisplayAttributes: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Discard: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpPhrase,
                dwValueTypes: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpPhrase,
                dwValueTypes: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpPhrase_GetPhrase(self: *const T, ppCoMemPhrase: ?*?*SPPHRASE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpPhrase.VTable, self.vtable).GetPhrase(@ptrCast(*const ISpPhrase, self), ppCoMemPhrase);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpPhrase_GetSerializedPhrase(self: *const T, ppCoMemPhrase: ?*?*SPSERIALIZEDPHRASE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpPhrase.VTable, self.vtable).GetSerializedPhrase(@ptrCast(*const ISpPhrase, self), ppCoMemPhrase);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpPhrase_GetText(self: *const T, ulStart: u32, ulCount: u32, fUseTextReplacements: BOOL, ppszCoMemText: ?*?PWSTR, pbDisplayAttributes: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpPhrase.VTable, self.vtable).GetText(@ptrCast(*const ISpPhrase, self), ulStart, ulCount, fUseTextReplacements, ppszCoMemText, pbDisplayAttributes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpPhrase_Discard(self: *const T, dwValueTypes: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpPhrase.VTable, self.vtable).Discard(@ptrCast(*const ISpPhrase, self), dwValueTypes);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpPhraseAlt_Value = Guid.initString("8fcebc98-4e49-4067-9c6c-d86a0e092e3d");
pub const IID_ISpPhraseAlt = &IID_ISpPhraseAlt_Value;
pub const ISpPhraseAlt = extern struct {
    pub const VTable = extern struct {
        base: ISpPhrase.VTable,
        GetAltInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpPhraseAlt,
                ppParent: ?*?*ISpPhrase,
                pulStartElementInParent: ?*u32,
                pcElementsInParent: ?*u32,
                pcElementsInAlt: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpPhraseAlt,
                ppParent: ?*?*ISpPhrase,
                pulStartElementInParent: ?*u32,
                pcElementsInParent: ?*u32,
                pcElementsInAlt: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Commit: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpPhraseAlt,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpPhraseAlt,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISpPhrase.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpPhraseAlt_GetAltInfo(self: *const T, ppParent: ?*?*ISpPhrase, pulStartElementInParent: ?*u32, pcElementsInParent: ?*u32, pcElementsInAlt: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpPhraseAlt.VTable, self.vtable).GetAltInfo(@ptrCast(*const ISpPhraseAlt, self), ppParent, pulStartElementInParent, pcElementsInParent, pcElementsInAlt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpPhraseAlt_Commit(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpPhraseAlt.VTable, self.vtable).Commit(@ptrCast(*const ISpPhraseAlt, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SPXMLRESULTOPTIONS = enum(i32) {
    SML = 0,
    Alternates_SML = 1,
};
pub const SPXRO_SML = SPXMLRESULTOPTIONS.SML;
pub const SPXRO_Alternates_SML = SPXMLRESULTOPTIONS.Alternates_SML;

const IID_ISpPhrase2_Value = Guid.initString("f264da52-e457-4696-b856-a737b717af79");
pub const IID_ISpPhrase2 = &IID_ISpPhrase2_Value;
pub const ISpPhrase2 = extern struct {
    pub const VTable = extern struct {
        base: ISpPhrase.VTable,
        GetXMLResult: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpPhrase2,
                ppszCoMemXMLResult: ?*?PWSTR,
                Options: SPXMLRESULTOPTIONS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpPhrase2,
                ppszCoMemXMLResult: ?*?PWSTR,
                Options: SPXMLRESULTOPTIONS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetXMLErrorInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpPhrase2,
                pSemanticErrorInfo: ?*SPSEMANTICERRORINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpPhrase2,
                pSemanticErrorInfo: ?*SPSEMANTICERRORINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAudio: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpPhrase2,
                ulStartElement: u32,
                cElements: u32,
                ppStream: ?*?*ISpStreamFormat,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpPhrase2,
                ulStartElement: u32,
                cElements: u32,
                ppStream: ?*?*ISpStreamFormat,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISpPhrase.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpPhrase2_GetXMLResult(self: *const T, ppszCoMemXMLResult: ?*?PWSTR, Options: SPXMLRESULTOPTIONS) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpPhrase2.VTable, self.vtable).GetXMLResult(@ptrCast(*const ISpPhrase2, self), ppszCoMemXMLResult, Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpPhrase2_GetXMLErrorInfo(self: *const T, pSemanticErrorInfo: ?*SPSEMANTICERRORINFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpPhrase2.VTable, self.vtable).GetXMLErrorInfo(@ptrCast(*const ISpPhrase2, self), pSemanticErrorInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpPhrase2_GetAudio(self: *const T, ulStartElement: u32, cElements: u32, ppStream: ?*?*ISpStreamFormat) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpPhrase2.VTable, self.vtable).GetAudio(@ptrCast(*const ISpPhrase2, self), ulStartElement, cElements, ppStream);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SPRECORESULTTIMES = extern struct {
    ftStreamTime: FILETIME,
    ullLength: u64,
    dwTickCount: u32,
    ullStart: u64,
};

pub const SPSERIALIZEDRESULT = extern struct {
    ulSerializedSize: u32,
};

const IID_ISpRecoResult_Value = Guid.initString("20b053be-e235-43cd-9a2a-8d17a48b7842");
pub const IID_ISpRecoResult = &IID_ISpRecoResult_Value;
pub const ISpRecoResult = extern struct {
    pub const VTable = extern struct {
        base: ISpPhrase.VTable,
        GetResultTimes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpRecoResult,
                pTimes: ?*SPRECORESULTTIMES,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpRecoResult,
                pTimes: ?*SPRECORESULTTIMES,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAlternates: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpRecoResult,
                ulStartElement: u32,
                cElements: u32,
                ulRequestCount: u32,
                ppPhrases: [*]?*ISpPhraseAlt,
                pcPhrasesReturned: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpRecoResult,
                ulStartElement: u32,
                cElements: u32,
                ulRequestCount: u32,
                ppPhrases: [*]?*ISpPhraseAlt,
                pcPhrasesReturned: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAudio: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpRecoResult,
                ulStartElement: u32,
                cElements: u32,
                ppStream: ?*?*ISpStreamFormat,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpRecoResult,
                ulStartElement: u32,
                cElements: u32,
                ppStream: ?*?*ISpStreamFormat,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SpeakAudio: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpRecoResult,
                ulStartElement: u32,
                cElements: u32,
                dwFlags: u32,
                pulStreamNumber: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpRecoResult,
                ulStartElement: u32,
                cElements: u32,
                dwFlags: u32,
                pulStreamNumber: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Serialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpRecoResult,
                ppCoMemSerializedResult: ?*?*SPSERIALIZEDRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpRecoResult,
                ppCoMemSerializedResult: ?*?*SPSERIALIZEDRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ScaleAudio: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpRecoResult,
                pAudioFormatId: ?*const Guid,
                pWaveFormatEx: ?*const WAVEFORMATEX,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpRecoResult,
                pAudioFormatId: ?*const Guid,
                pWaveFormatEx: ?*const WAVEFORMATEX,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecoContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpRecoResult,
                ppRecoContext: ?*?*ISpRecoContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpRecoResult,
                ppRecoContext: ?*?*ISpRecoContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISpPhrase.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpRecoResult_GetResultTimes(self: *const T, pTimes: ?*SPRECORESULTTIMES) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpRecoResult.VTable, self.vtable).GetResultTimes(@ptrCast(*const ISpRecoResult, self), pTimes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpRecoResult_GetAlternates(self: *const T, ulStartElement: u32, cElements: u32, ulRequestCount: u32, ppPhrases: [*]?*ISpPhraseAlt, pcPhrasesReturned: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpRecoResult.VTable, self.vtable).GetAlternates(@ptrCast(*const ISpRecoResult, self), ulStartElement, cElements, ulRequestCount, ppPhrases, pcPhrasesReturned);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpRecoResult_GetAudio(self: *const T, ulStartElement: u32, cElements: u32, ppStream: ?*?*ISpStreamFormat) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpRecoResult.VTable, self.vtable).GetAudio(@ptrCast(*const ISpRecoResult, self), ulStartElement, cElements, ppStream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpRecoResult_SpeakAudio(self: *const T, ulStartElement: u32, cElements: u32, dwFlags: u32, pulStreamNumber: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpRecoResult.VTable, self.vtable).SpeakAudio(@ptrCast(*const ISpRecoResult, self), ulStartElement, cElements, dwFlags, pulStreamNumber);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpRecoResult_Serialize(self: *const T, ppCoMemSerializedResult: ?*?*SPSERIALIZEDRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpRecoResult.VTable, self.vtable).Serialize(@ptrCast(*const ISpRecoResult, self), ppCoMemSerializedResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpRecoResult_ScaleAudio(self: *const T, pAudioFormatId: ?*const Guid, pWaveFormatEx: ?*const WAVEFORMATEX) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpRecoResult.VTable, self.vtable).ScaleAudio(@ptrCast(*const ISpRecoResult, self), pAudioFormatId, pWaveFormatEx);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpRecoResult_GetRecoContext(self: *const T, ppRecoContext: ?*?*ISpRecoContext) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpRecoResult.VTable, self.vtable).GetRecoContext(@ptrCast(*const ISpRecoResult, self), ppRecoContext);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SPCOMMITFLAGS = enum(i32) {
    NONE = 0,
    ADD_TO_USER_LEXICON = 1,
    DEFINITE_CORRECTION = 2,
};
pub const SPCF_NONE = SPCOMMITFLAGS.NONE;
pub const SPCF_ADD_TO_USER_LEXICON = SPCOMMITFLAGS.ADD_TO_USER_LEXICON;
pub const SPCF_DEFINITE_CORRECTION = SPCOMMITFLAGS.DEFINITE_CORRECTION;

const IID_ISpRecoResult2_Value = Guid.initString("27cac6c4-88f2-41f2-8817-0c95e59f1e6e");
pub const IID_ISpRecoResult2 = &IID_ISpRecoResult2_Value;
pub const ISpRecoResult2 = extern struct {
    pub const VTable = extern struct {
        base: ISpRecoResult.VTable,
        CommitAlternate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpRecoResult2,
                pPhraseAlt: ?*ISpPhraseAlt,
                ppNewResult: ?*?*ISpRecoResult,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpRecoResult2,
                pPhraseAlt: ?*ISpPhraseAlt,
                ppNewResult: ?*?*ISpRecoResult,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CommitText: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpRecoResult2,
                ulStartElement: u32,
                cElements: u32,
                pszCorrectedData: ?[*:0]const u16,
                eCommitFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpRecoResult2,
                ulStartElement: u32,
                cElements: u32,
                pszCorrectedData: ?[*:0]const u16,
                eCommitFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTextFeedback: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpRecoResult2,
                pszFeedback: ?[*:0]const u16,
                fSuccessful: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpRecoResult2,
                pszFeedback: ?[*:0]const u16,
                fSuccessful: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISpRecoResult.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpRecoResult2_CommitAlternate(self: *const T, pPhraseAlt: ?*ISpPhraseAlt, ppNewResult: ?*?*ISpRecoResult) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpRecoResult2.VTable, self.vtable).CommitAlternate(@ptrCast(*const ISpRecoResult2, self), pPhraseAlt, ppNewResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpRecoResult2_CommitText(self: *const T, ulStartElement: u32, cElements: u32, pszCorrectedData: ?[*:0]const u16, eCommitFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpRecoResult2.VTable, self.vtable).CommitText(@ptrCast(*const ISpRecoResult2, self), ulStartElement, cElements, pszCorrectedData, eCommitFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpRecoResult2_SetTextFeedback(self: *const T, pszFeedback: ?[*:0]const u16, fSuccessful: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpRecoResult2.VTable, self.vtable).SetTextFeedback(@ptrCast(*const ISpRecoResult2, self), pszFeedback, fSuccessful);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpXMLRecoResult_Value = Guid.initString("ae39362b-45a8-4074-9b9e-ccf49aa2d0b6");
pub const IID_ISpXMLRecoResult = &IID_ISpXMLRecoResult_Value;
pub const ISpXMLRecoResult = extern struct {
    pub const VTable = extern struct {
        base: ISpRecoResult.VTable,
        GetXMLResult: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpXMLRecoResult,
                ppszCoMemXMLResult: ?*?PWSTR,
                Options: SPXMLRESULTOPTIONS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpXMLRecoResult,
                ppszCoMemXMLResult: ?*?PWSTR,
                Options: SPXMLRESULTOPTIONS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetXMLErrorInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpXMLRecoResult,
                pSemanticErrorInfo: ?*SPSEMANTICERRORINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpXMLRecoResult,
                pSemanticErrorInfo: ?*SPSEMANTICERRORINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISpRecoResult.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpXMLRecoResult_GetXMLResult(self: *const T, ppszCoMemXMLResult: ?*?PWSTR, Options: SPXMLRESULTOPTIONS) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpXMLRecoResult.VTable, self.vtable).GetXMLResult(@ptrCast(*const ISpXMLRecoResult, self), ppszCoMemXMLResult, Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpXMLRecoResult_GetXMLErrorInfo(self: *const T, pSemanticErrorInfo: ?*SPSEMANTICERRORINFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpXMLRecoResult.VTable, self.vtable).GetXMLErrorInfo(@ptrCast(*const ISpXMLRecoResult, self), pSemanticErrorInfo);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SPTEXTSELECTIONINFO = extern struct {
    ulStartActiveOffset: u32,
    cchActiveChars: u32,
    ulStartSelection: u32,
    cchSelection: u32,
};

pub const SPWORDPRONOUNCEABLE = enum(i32) {
    UNKNOWN_WORD_UNPRONOUNCEABLE = 0,
    UNKNOWN_WORD_PRONOUNCEABLE = 1,
    KNOWN_WORD_PRONOUNCEABLE = 2,
};
pub const SPWP_UNKNOWN_WORD_UNPRONOUNCEABLE = SPWORDPRONOUNCEABLE.UNKNOWN_WORD_UNPRONOUNCEABLE;
pub const SPWP_UNKNOWN_WORD_PRONOUNCEABLE = SPWORDPRONOUNCEABLE.UNKNOWN_WORD_PRONOUNCEABLE;
pub const SPWP_KNOWN_WORD_PRONOUNCEABLE = SPWORDPRONOUNCEABLE.KNOWN_WORD_PRONOUNCEABLE;

pub const SPGRAMMARSTATE = enum(i32) {
    DISABLED = 0,
    ENABLED = 1,
    EXCLUSIVE = 3,
};
pub const SPGS_DISABLED = SPGRAMMARSTATE.DISABLED;
pub const SPGS_ENABLED = SPGRAMMARSTATE.ENABLED;
pub const SPGS_EXCLUSIVE = SPGRAMMARSTATE.EXCLUSIVE;

pub const SPCONTEXTSTATE = enum(i32) {
    DISABLED = 0,
    ENABLED = 1,
};
pub const SPCS_DISABLED = SPCONTEXTSTATE.DISABLED;
pub const SPCS_ENABLED = SPCONTEXTSTATE.ENABLED;

pub const SPRULESTATE = enum(i32) {
    INACTIVE = 0,
    ACTIVE = 1,
    ACTIVE_WITH_AUTO_PAUSE = 3,
    ACTIVE_USER_DELIMITED = 4,
};
pub const SPRS_INACTIVE = SPRULESTATE.INACTIVE;
pub const SPRS_ACTIVE = SPRULESTATE.ACTIVE;
pub const SPRS_ACTIVE_WITH_AUTO_PAUSE = SPRULESTATE.ACTIVE_WITH_AUTO_PAUSE;
pub const SPRS_ACTIVE_USER_DELIMITED = SPRULESTATE.ACTIVE_USER_DELIMITED;

pub const SPGRAMMARWORDTYPE = enum(i32) {
    DISPLAY = 0,
    LEXICAL = 1,
    PRONUNCIATION = 2,
    LEXICAL_NO_SPECIAL_CHARS = 3,
};
pub const SPWT_DISPLAY = SPGRAMMARWORDTYPE.DISPLAY;
pub const SPWT_LEXICAL = SPGRAMMARWORDTYPE.LEXICAL;
pub const SPWT_PRONUNCIATION = SPGRAMMARWORDTYPE.PRONUNCIATION;
pub const SPWT_LEXICAL_NO_SPECIAL_CHARS = SPGRAMMARWORDTYPE.LEXICAL_NO_SPECIAL_CHARS;

pub const SPPROPERTYINFO = extern struct {
    pszName: ?[*:0]const u16,
    ulId: u32,
    pszValue: ?[*:0]const u16,
    vValue: VARIANT,
};

pub const SPCFGRULEATTRIBUTES = enum(i32) {
    TopLevel = 1,
    Active = 2,
    Export = 4,
    Import = 8,
    Interpreter = 16,
    Dynamic = 32,
    Root = 64,
    AutoPause = 65536,
    UserDelimited = 131072,
};
pub const SPRAF_TopLevel = SPCFGRULEATTRIBUTES.TopLevel;
pub const SPRAF_Active = SPCFGRULEATTRIBUTES.Active;
pub const SPRAF_Export = SPCFGRULEATTRIBUTES.Export;
pub const SPRAF_Import = SPCFGRULEATTRIBUTES.Import;
pub const SPRAF_Interpreter = SPCFGRULEATTRIBUTES.Interpreter;
pub const SPRAF_Dynamic = SPCFGRULEATTRIBUTES.Dynamic;
pub const SPRAF_Root = SPCFGRULEATTRIBUTES.Root;
pub const SPRAF_AutoPause = SPCFGRULEATTRIBUTES.AutoPause;
pub const SPRAF_UserDelimited = SPCFGRULEATTRIBUTES.UserDelimited;

const IID_ISpGrammarBuilder_Value = Guid.initString("8137828f-591a-4a42-be58-49ea7ebaac68");
pub const IID_ISpGrammarBuilder = &IID_ISpGrammarBuilder_Value;
pub const ISpGrammarBuilder = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ResetGrammar: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpGrammarBuilder,
                NewLanguage: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpGrammarBuilder,
                NewLanguage: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRule: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpGrammarBuilder,
                pszRuleName: ?[*:0]const u16,
                dwRuleId: u32,
                dwAttributes: u32,
                fCreateIfNotExist: BOOL,
                phInitialState: ?*?*SPSTATEHANDLE__,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpGrammarBuilder,
                pszRuleName: ?[*:0]const u16,
                dwRuleId: u32,
                dwAttributes: u32,
                fCreateIfNotExist: BOOL,
                phInitialState: ?*?*SPSTATEHANDLE__,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ClearRule: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpGrammarBuilder,
                hState: ?*SPSTATEHANDLE__,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpGrammarBuilder,
                hState: ?*SPSTATEHANDLE__,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateNewState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpGrammarBuilder,
                hState: ?*SPSTATEHANDLE__,
                phState: ?*?*SPSTATEHANDLE__,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpGrammarBuilder,
                hState: ?*SPSTATEHANDLE__,
                phState: ?*?*SPSTATEHANDLE__,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddWordTransition: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpGrammarBuilder,
                hFromState: ?*SPSTATEHANDLE__,
                hToState: ?*SPSTATEHANDLE__,
                psz: ?[*:0]const u16,
                pszSeparators: ?[*:0]const u16,
                eWordType: SPGRAMMARWORDTYPE,
                Weight: f32,
                pPropInfo: ?*const SPPROPERTYINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpGrammarBuilder,
                hFromState: ?*SPSTATEHANDLE__,
                hToState: ?*SPSTATEHANDLE__,
                psz: ?[*:0]const u16,
                pszSeparators: ?[*:0]const u16,
                eWordType: SPGRAMMARWORDTYPE,
                Weight: f32,
                pPropInfo: ?*const SPPROPERTYINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddRuleTransition: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpGrammarBuilder,
                hFromState: ?*SPSTATEHANDLE__,
                hToState: ?*SPSTATEHANDLE__,
                hRule: ?*SPSTATEHANDLE__,
                Weight: f32,
                pPropInfo: ?*const SPPROPERTYINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpGrammarBuilder,
                hFromState: ?*SPSTATEHANDLE__,
                hToState: ?*SPSTATEHANDLE__,
                hRule: ?*SPSTATEHANDLE__,
                Weight: f32,
                pPropInfo: ?*const SPPROPERTYINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddResource: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpGrammarBuilder,
                hRuleState: ?*SPSTATEHANDLE__,
                pszResourceName: ?[*:0]const u16,
                pszResourceValue: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpGrammarBuilder,
                hRuleState: ?*SPSTATEHANDLE__,
                pszResourceName: ?[*:0]const u16,
                pszResourceValue: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Commit: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpGrammarBuilder,
                dwReserved: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpGrammarBuilder,
                dwReserved: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpGrammarBuilder_ResetGrammar(self: *const T, NewLanguage: u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpGrammarBuilder.VTable, self.vtable).ResetGrammar(@ptrCast(*const ISpGrammarBuilder, self), NewLanguage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpGrammarBuilder_GetRule(self: *const T, pszRuleName: ?[*:0]const u16, dwRuleId: u32, dwAttributes: u32, fCreateIfNotExist: BOOL, phInitialState: ?*?*SPSTATEHANDLE__) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpGrammarBuilder.VTable, self.vtable).GetRule(@ptrCast(*const ISpGrammarBuilder, self), pszRuleName, dwRuleId, dwAttributes, fCreateIfNotExist, phInitialState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpGrammarBuilder_ClearRule(self: *const T, hState: ?*SPSTATEHANDLE__) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpGrammarBuilder.VTable, self.vtable).ClearRule(@ptrCast(*const ISpGrammarBuilder, self), hState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpGrammarBuilder_CreateNewState(self: *const T, hState: ?*SPSTATEHANDLE__, phState: ?*?*SPSTATEHANDLE__) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpGrammarBuilder.VTable, self.vtable).CreateNewState(@ptrCast(*const ISpGrammarBuilder, self), hState, phState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpGrammarBuilder_AddWordTransition(self: *const T, hFromState: ?*SPSTATEHANDLE__, hToState: ?*SPSTATEHANDLE__, psz: ?[*:0]const u16, pszSeparators: ?[*:0]const u16, eWordType: SPGRAMMARWORDTYPE, Weight: f32, pPropInfo: ?*const SPPROPERTYINFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpGrammarBuilder.VTable, self.vtable).AddWordTransition(@ptrCast(*const ISpGrammarBuilder, self), hFromState, hToState, psz, pszSeparators, eWordType, Weight, pPropInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpGrammarBuilder_AddRuleTransition(self: *const T, hFromState: ?*SPSTATEHANDLE__, hToState: ?*SPSTATEHANDLE__, hRule: ?*SPSTATEHANDLE__, Weight: f32, pPropInfo: ?*const SPPROPERTYINFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpGrammarBuilder.VTable, self.vtable).AddRuleTransition(@ptrCast(*const ISpGrammarBuilder, self), hFromState, hToState, hRule, Weight, pPropInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpGrammarBuilder_AddResource(self: *const T, hRuleState: ?*SPSTATEHANDLE__, pszResourceName: ?[*:0]const u16, pszResourceValue: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpGrammarBuilder.VTable, self.vtable).AddResource(@ptrCast(*const ISpGrammarBuilder, self), hRuleState, pszResourceName, pszResourceValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpGrammarBuilder_Commit(self: *const T, dwReserved: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpGrammarBuilder.VTable, self.vtable).Commit(@ptrCast(*const ISpGrammarBuilder, self), dwReserved);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SPLOADOPTIONS = enum(i32) {
    STATIC = 0,
    DYNAMIC = 1,
};
pub const SPLO_STATIC = SPLOADOPTIONS.STATIC;
pub const SPLO_DYNAMIC = SPLOADOPTIONS.DYNAMIC;

const IID_ISpRecoGrammar_Value = Guid.initString("2177db29-7f45-47d0-8554-067e91c80502");
pub const IID_ISpRecoGrammar = &IID_ISpRecoGrammar_Value;
pub const ISpRecoGrammar = extern struct {
    pub const VTable = extern struct {
        base: ISpGrammarBuilder.VTable,
        GetGrammarId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpRecoGrammar,
                pullGrammarId: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpRecoGrammar,
                pullGrammarId: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecoContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpRecoGrammar,
                ppRecoCtxt: ?*?*ISpRecoContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpRecoGrammar,
                ppRecoCtxt: ?*?*ISpRecoContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LoadCmdFromFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpRecoGrammar,
                pszFileName: ?[*:0]const u16,
                Options: SPLOADOPTIONS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpRecoGrammar,
                pszFileName: ?[*:0]const u16,
                Options: SPLOADOPTIONS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LoadCmdFromObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpRecoGrammar,
                rcid: ?*const Guid,
                pszGrammarName: ?[*:0]const u16,
                Options: SPLOADOPTIONS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpRecoGrammar,
                rcid: ?*const Guid,
                pszGrammarName: ?[*:0]const u16,
                Options: SPLOADOPTIONS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LoadCmdFromResource: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpRecoGrammar,
                hModule: ?HINSTANCE,
                pszResourceName: ?[*:0]const u16,
                pszResourceType: ?[*:0]const u16,
                wLanguage: u16,
                Options: SPLOADOPTIONS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpRecoGrammar,
                hModule: ?HINSTANCE,
                pszResourceName: ?[*:0]const u16,
                pszResourceType: ?[*:0]const u16,
                wLanguage: u16,
                Options: SPLOADOPTIONS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LoadCmdFromMemory: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpRecoGrammar,
                pGrammar: ?*const SPBINARYGRAMMAR,
                Options: SPLOADOPTIONS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpRecoGrammar,
                pGrammar: ?*const SPBINARYGRAMMAR,
                Options: SPLOADOPTIONS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LoadCmdFromProprietaryGrammar: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpRecoGrammar,
                rguidParam: ?*const Guid,
                pszStringParam: ?[*:0]const u16,
                pvDataPrarm: ?*const anyopaque,
                cbDataSize: u32,
                Options: SPLOADOPTIONS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpRecoGrammar,
                rguidParam: ?*const Guid,
                pszStringParam: ?[*:0]const u16,
                pvDataPrarm: ?*const anyopaque,
                cbDataSize: u32,
                Options: SPLOADOPTIONS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetRuleState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpRecoGrammar,
                pszName: ?[*:0]const u16,
                pReserved: ?*anyopaque,
                NewState: SPRULESTATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpRecoGrammar,
                pszName: ?[*:0]const u16,
                pReserved: ?*anyopaque,
                NewState: SPRULESTATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetRuleIdState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpRecoGrammar,
                ulRuleId: u32,
                NewState: SPRULESTATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpRecoGrammar,
                ulRuleId: u32,
                NewState: SPRULESTATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LoadDictation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpRecoGrammar,
                pszTopicName: ?[*:0]const u16,
                Options: SPLOADOPTIONS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpRecoGrammar,
                pszTopicName: ?[*:0]const u16,
                Options: SPLOADOPTIONS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnloadDictation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpRecoGrammar,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpRecoGrammar,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDictationState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpRecoGrammar,
                NewState: SPRULESTATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpRecoGrammar,
                NewState: SPRULESTATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetWordSequenceData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpRecoGrammar,
                pText: ?[*:0]const u16,
                cchText: u32,
                pInfo: ?*const SPTEXTSELECTIONINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpRecoGrammar,
                pText: ?[*:0]const u16,
                cchText: u32,
                pInfo: ?*const SPTEXTSELECTIONINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTextSelection: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpRecoGrammar,
                pInfo: ?*const SPTEXTSELECTIONINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpRecoGrammar,
                pInfo: ?*const SPTEXTSELECTIONINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsPronounceable: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpRecoGrammar,
                pszWord: ?[*:0]const u16,
                pWordPronounceable: ?*SPWORDPRONOUNCEABLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpRecoGrammar,
                pszWord: ?[*:0]const u16,
                pWordPronounceable: ?*SPWORDPRONOUNCEABLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetGrammarState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpRecoGrammar,
                eGrammarState: SPGRAMMARSTATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpRecoGrammar,
                eGrammarState: SPGRAMMARSTATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SaveCmd: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpRecoGrammar,
                pStream: ?*IStream,
                ppszCoMemErrorText: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpRecoGrammar,
                pStream: ?*IStream,
                ppszCoMemErrorText: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetGrammarState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpRecoGrammar,
                peGrammarState: ?*SPGRAMMARSTATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpRecoGrammar,
                peGrammarState: ?*SPGRAMMARSTATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISpGrammarBuilder.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpRecoGrammar_GetGrammarId(self: *const T, pullGrammarId: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpRecoGrammar.VTable, self.vtable).GetGrammarId(@ptrCast(*const ISpRecoGrammar, self), pullGrammarId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpRecoGrammar_GetRecoContext(self: *const T, ppRecoCtxt: ?*?*ISpRecoContext) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpRecoGrammar.VTable, self.vtable).GetRecoContext(@ptrCast(*const ISpRecoGrammar, self), ppRecoCtxt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpRecoGrammar_LoadCmdFromFile(self: *const T, pszFileName: ?[*:0]const u16, Options: SPLOADOPTIONS) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpRecoGrammar.VTable, self.vtable).LoadCmdFromFile(@ptrCast(*const ISpRecoGrammar, self), pszFileName, Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpRecoGrammar_LoadCmdFromObject(self: *const T, rcid: ?*const Guid, pszGrammarName: ?[*:0]const u16, Options: SPLOADOPTIONS) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpRecoGrammar.VTable, self.vtable).LoadCmdFromObject(@ptrCast(*const ISpRecoGrammar, self), rcid, pszGrammarName, Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpRecoGrammar_LoadCmdFromResource(self: *const T, hModule: ?HINSTANCE, pszResourceName: ?[*:0]const u16, pszResourceType: ?[*:0]const u16, wLanguage: u16, Options: SPLOADOPTIONS) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpRecoGrammar.VTable, self.vtable).LoadCmdFromResource(@ptrCast(*const ISpRecoGrammar, self), hModule, pszResourceName, pszResourceType, wLanguage, Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpRecoGrammar_LoadCmdFromMemory(self: *const T, pGrammar: ?*const SPBINARYGRAMMAR, Options: SPLOADOPTIONS) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpRecoGrammar.VTable, self.vtable).LoadCmdFromMemory(@ptrCast(*const ISpRecoGrammar, self), pGrammar, Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpRecoGrammar_LoadCmdFromProprietaryGrammar(self: *const T, rguidParam: ?*const Guid, pszStringParam: ?[*:0]const u16, pvDataPrarm: ?*const anyopaque, cbDataSize: u32, Options: SPLOADOPTIONS) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpRecoGrammar.VTable, self.vtable).LoadCmdFromProprietaryGrammar(@ptrCast(*const ISpRecoGrammar, self), rguidParam, pszStringParam, pvDataPrarm, cbDataSize, Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpRecoGrammar_SetRuleState(self: *const T, pszName: ?[*:0]const u16, pReserved: ?*anyopaque, NewState: SPRULESTATE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpRecoGrammar.VTable, self.vtable).SetRuleState(@ptrCast(*const ISpRecoGrammar, self), pszName, pReserved, NewState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpRecoGrammar_SetRuleIdState(self: *const T, ulRuleId: u32, NewState: SPRULESTATE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpRecoGrammar.VTable, self.vtable).SetRuleIdState(@ptrCast(*const ISpRecoGrammar, self), ulRuleId, NewState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpRecoGrammar_LoadDictation(self: *const T, pszTopicName: ?[*:0]const u16, Options: SPLOADOPTIONS) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpRecoGrammar.VTable, self.vtable).LoadDictation(@ptrCast(*const ISpRecoGrammar, self), pszTopicName, Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpRecoGrammar_UnloadDictation(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpRecoGrammar.VTable, self.vtable).UnloadDictation(@ptrCast(*const ISpRecoGrammar, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpRecoGrammar_SetDictationState(self: *const T, NewState: SPRULESTATE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpRecoGrammar.VTable, self.vtable).SetDictationState(@ptrCast(*const ISpRecoGrammar, self), NewState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpRecoGrammar_SetWordSequenceData(self: *const T, pText: ?[*:0]const u16, cchText: u32, pInfo: ?*const SPTEXTSELECTIONINFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpRecoGrammar.VTable, self.vtable).SetWordSequenceData(@ptrCast(*const ISpRecoGrammar, self), pText, cchText, pInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpRecoGrammar_SetTextSelection(self: *const T, pInfo: ?*const SPTEXTSELECTIONINFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpRecoGrammar.VTable, self.vtable).SetTextSelection(@ptrCast(*const ISpRecoGrammar, self), pInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpRecoGrammar_IsPronounceable(self: *const T, pszWord: ?[*:0]const u16, pWordPronounceable: ?*SPWORDPRONOUNCEABLE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpRecoGrammar.VTable, self.vtable).IsPronounceable(@ptrCast(*const ISpRecoGrammar, self), pszWord, pWordPronounceable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpRecoGrammar_SetGrammarState(self: *const T, eGrammarState: SPGRAMMARSTATE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpRecoGrammar.VTable, self.vtable).SetGrammarState(@ptrCast(*const ISpRecoGrammar, self), eGrammarState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpRecoGrammar_SaveCmd(self: *const T, pStream: ?*IStream, ppszCoMemErrorText: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpRecoGrammar.VTable, self.vtable).SaveCmd(@ptrCast(*const ISpRecoGrammar, self), pStream, ppszCoMemErrorText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpRecoGrammar_GetGrammarState(self: *const T, peGrammarState: ?*SPGRAMMARSTATE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpRecoGrammar.VTable, self.vtable).GetGrammarState(@ptrCast(*const ISpRecoGrammar, self), peGrammarState);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SPMATCHINGMODE = enum(i32) {
    AllWords = 0,
    Subsequence = 1,
    OrderedSubset = 3,
    SubsequenceContentRequired = 5,
    OrderedSubsetContentRequired = 7,
};
pub const AllWords = SPMATCHINGMODE.AllWords;
pub const Subsequence = SPMATCHINGMODE.Subsequence;
pub const OrderedSubset = SPMATCHINGMODE.OrderedSubset;
pub const SubsequenceContentRequired = SPMATCHINGMODE.SubsequenceContentRequired;
pub const OrderedSubsetContentRequired = SPMATCHINGMODE.OrderedSubsetContentRequired;

pub const PHONETICALPHABET = enum(i32) {
    Ipa = 0,
    Ups = 1,
    Sapi = 2,
};
pub const PA_Ipa = PHONETICALPHABET.Ipa;
pub const PA_Ups = PHONETICALPHABET.Ups;
pub const PA_Sapi = PHONETICALPHABET.Sapi;

const IID_ISpGrammarBuilder2_Value = Guid.initString("8ab10026-20cc-4b20-8c22-a49c9ba78f60");
pub const IID_ISpGrammarBuilder2 = &IID_ISpGrammarBuilder2_Value;
pub const ISpGrammarBuilder2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddTextSubset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpGrammarBuilder2,
                hFromState: ?*SPSTATEHANDLE__,
                hToState: ?*SPSTATEHANDLE__,
                psz: ?[*:0]const u16,
                eMatchMode: SPMATCHINGMODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpGrammarBuilder2,
                hFromState: ?*SPSTATEHANDLE__,
                hToState: ?*SPSTATEHANDLE__,
                psz: ?[*:0]const u16,
                eMatchMode: SPMATCHINGMODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPhoneticAlphabet: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpGrammarBuilder2,
                phoneticALphabet: PHONETICALPHABET,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpGrammarBuilder2,
                phoneticALphabet: PHONETICALPHABET,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpGrammarBuilder2_AddTextSubset(self: *const T, hFromState: ?*SPSTATEHANDLE__, hToState: ?*SPSTATEHANDLE__, psz: ?[*:0]const u16, eMatchMode: SPMATCHINGMODE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpGrammarBuilder2.VTable, self.vtable).AddTextSubset(@ptrCast(*const ISpGrammarBuilder2, self), hFromState, hToState, psz, eMatchMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpGrammarBuilder2_SetPhoneticAlphabet(self: *const T, phoneticALphabet: PHONETICALPHABET) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpGrammarBuilder2.VTable, self.vtable).SetPhoneticAlphabet(@ptrCast(*const ISpGrammarBuilder2, self), phoneticALphabet);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpRecoGrammar2_Value = Guid.initString("4b37bc9e-9ed6-44a3-93d3-18f022b79ec3");
pub const IID_ISpRecoGrammar2 = &IID_ISpRecoGrammar2_Value;
pub const ISpRecoGrammar2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetRules: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpRecoGrammar2,
                ppCoMemRules: ?*?*SPRULE,
                puNumRules: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpRecoGrammar2,
                ppCoMemRules: ?*?*SPRULE,
                puNumRules: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LoadCmdFromFile2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpRecoGrammar2,
                pszFileName: ?[*:0]const u16,
                Options: SPLOADOPTIONS,
                pszSharingUri: ?[*:0]const u16,
                pszBaseUri: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpRecoGrammar2,
                pszFileName: ?[*:0]const u16,
                Options: SPLOADOPTIONS,
                pszSharingUri: ?[*:0]const u16,
                pszBaseUri: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LoadCmdFromMemory2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpRecoGrammar2,
                pGrammar: ?*const SPBINARYGRAMMAR,
                Options: SPLOADOPTIONS,
                pszSharingUri: ?[*:0]const u16,
                pszBaseUri: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpRecoGrammar2,
                pGrammar: ?*const SPBINARYGRAMMAR,
                Options: SPLOADOPTIONS,
                pszSharingUri: ?[*:0]const u16,
                pszBaseUri: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetRulePriority: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpRecoGrammar2,
                pszRuleName: ?[*:0]const u16,
                ulRuleId: u32,
                nRulePriority: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpRecoGrammar2,
                pszRuleName: ?[*:0]const u16,
                ulRuleId: u32,
                nRulePriority: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetRuleWeight: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpRecoGrammar2,
                pszRuleName: ?[*:0]const u16,
                ulRuleId: u32,
                flWeight: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpRecoGrammar2,
                pszRuleName: ?[*:0]const u16,
                ulRuleId: u32,
                flWeight: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDictationWeight: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpRecoGrammar2,
                flWeight: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpRecoGrammar2,
                flWeight: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetGrammarLoader: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpRecoGrammar2,
                pLoader: ?*ISpeechResourceLoader,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpRecoGrammar2,
                pLoader: ?*ISpeechResourceLoader,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSMLSecurityManager: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpRecoGrammar2,
                pSMLSecurityManager: ?*IInternetSecurityManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpRecoGrammar2,
                pSMLSecurityManager: ?*IInternetSecurityManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpRecoGrammar2_GetRules(self: *const T, ppCoMemRules: ?*?*SPRULE, puNumRules: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpRecoGrammar2.VTable, self.vtable).GetRules(@ptrCast(*const ISpRecoGrammar2, self), ppCoMemRules, puNumRules);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpRecoGrammar2_LoadCmdFromFile2(self: *const T, pszFileName: ?[*:0]const u16, Options: SPLOADOPTIONS, pszSharingUri: ?[*:0]const u16, pszBaseUri: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpRecoGrammar2.VTable, self.vtable).LoadCmdFromFile2(@ptrCast(*const ISpRecoGrammar2, self), pszFileName, Options, pszSharingUri, pszBaseUri);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpRecoGrammar2_LoadCmdFromMemory2(self: *const T, pGrammar: ?*const SPBINARYGRAMMAR, Options: SPLOADOPTIONS, pszSharingUri: ?[*:0]const u16, pszBaseUri: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpRecoGrammar2.VTable, self.vtable).LoadCmdFromMemory2(@ptrCast(*const ISpRecoGrammar2, self), pGrammar, Options, pszSharingUri, pszBaseUri);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpRecoGrammar2_SetRulePriority(self: *const T, pszRuleName: ?[*:0]const u16, ulRuleId: u32, nRulePriority: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpRecoGrammar2.VTable, self.vtable).SetRulePriority(@ptrCast(*const ISpRecoGrammar2, self), pszRuleName, ulRuleId, nRulePriority);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpRecoGrammar2_SetRuleWeight(self: *const T, pszRuleName: ?[*:0]const u16, ulRuleId: u32, flWeight: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpRecoGrammar2.VTable, self.vtable).SetRuleWeight(@ptrCast(*const ISpRecoGrammar2, self), pszRuleName, ulRuleId, flWeight);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpRecoGrammar2_SetDictationWeight(self: *const T, flWeight: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpRecoGrammar2.VTable, self.vtable).SetDictationWeight(@ptrCast(*const ISpRecoGrammar2, self), flWeight);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpRecoGrammar2_SetGrammarLoader(self: *const T, pLoader: ?*ISpeechResourceLoader) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpRecoGrammar2.VTable, self.vtable).SetGrammarLoader(@ptrCast(*const ISpRecoGrammar2, self), pLoader);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpRecoGrammar2_SetSMLSecurityManager(self: *const T, pSMLSecurityManager: ?*IInternetSecurityManager) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpRecoGrammar2.VTable, self.vtable).SetSMLSecurityManager(@ptrCast(*const ISpRecoGrammar2, self), pSMLSecurityManager);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechResourceLoader_Value = Guid.initString("b9ac5783-fcd0-4b21-b119-b4f8da8fd2c3");
pub const IID_ISpeechResourceLoader = &IID_ISpeechResourceLoader_Value;
pub const ISpeechResourceLoader = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        LoadResource: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechResourceLoader,
                bstrResourceUri: ?BSTR,
                fAlwaysReload: i16,
                pStream: ?*?*IUnknown,
                pbstrMIMEType: ?*?BSTR,
                pfModified: ?*i16,
                pbstrRedirectUrl: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechResourceLoader,
                bstrResourceUri: ?BSTR,
                fAlwaysReload: i16,
                pStream: ?*?*IUnknown,
                pbstrMIMEType: ?*?BSTR,
                pfModified: ?*i16,
                pbstrRedirectUrl: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLocalCopy: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechResourceLoader,
                bstrResourceUri: ?BSTR,
                pbstrLocalPath: ?*?BSTR,
                pbstrMIMEType: ?*?BSTR,
                pbstrRedirectUrl: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechResourceLoader,
                bstrResourceUri: ?BSTR,
                pbstrLocalPath: ?*?BSTR,
                pbstrMIMEType: ?*?BSTR,
                pbstrRedirectUrl: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReleaseLocalCopy: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechResourceLoader,
                pbstrLocalPath: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechResourceLoader,
                pbstrLocalPath: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechResourceLoader_LoadResource(self: *const T, bstrResourceUri: ?BSTR, fAlwaysReload: i16, pStream: ?*?*IUnknown, pbstrMIMEType: ?*?BSTR, pfModified: ?*i16, pbstrRedirectUrl: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechResourceLoader.VTable, self.vtable).LoadResource(@ptrCast(*const ISpeechResourceLoader, self), bstrResourceUri, fAlwaysReload, pStream, pbstrMIMEType, pfModified, pbstrRedirectUrl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechResourceLoader_GetLocalCopy(self: *const T, bstrResourceUri: ?BSTR, pbstrLocalPath: ?*?BSTR, pbstrMIMEType: ?*?BSTR, pbstrRedirectUrl: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechResourceLoader.VTable, self.vtable).GetLocalCopy(@ptrCast(*const ISpeechResourceLoader, self), bstrResourceUri, pbstrLocalPath, pbstrMIMEType, pbstrRedirectUrl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechResourceLoader_ReleaseLocalCopy(self: *const T, pbstrLocalPath: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechResourceLoader.VTable, self.vtable).ReleaseLocalCopy(@ptrCast(*const ISpeechResourceLoader, self), pbstrLocalPath);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SPRECOCONTEXTSTATUS = extern struct {
    eInterference: SPINTERFERENCE,
    szRequestTypeOfUI: [255]u16,
    dwReserved1: u32,
    dwReserved2: u32,
};

pub const SPBOOKMARKOPTIONS = enum(i32) {
    NONE = 0,
    PAUSE = 1,
    AHEAD = 2,
    TIME_UNITS = 4,
};
pub const SPBO_NONE = SPBOOKMARKOPTIONS.NONE;
pub const SPBO_PAUSE = SPBOOKMARKOPTIONS.PAUSE;
pub const SPBO_AHEAD = SPBOOKMARKOPTIONS.AHEAD;
pub const SPBO_TIME_UNITS = SPBOOKMARKOPTIONS.TIME_UNITS;

pub const SPAUDIOOPTIONS = enum(i32) {
    NONE = 0,
    RETAIN_AUDIO = 1,
};
pub const SPAO_NONE = SPAUDIOOPTIONS.NONE;
pub const SPAO_RETAIN_AUDIO = SPAUDIOOPTIONS.RETAIN_AUDIO;

const IID_ISpRecoContext_Value = Guid.initString("f740a62f-7c15-489e-8234-940a33d9272d");
pub const IID_ISpRecoContext = &IID_ISpRecoContext_Value;
pub const ISpRecoContext = extern struct {
    pub const VTable = extern struct {
        base: ISpEventSource.VTable,
        GetRecognizer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpRecoContext,
                ppRecognizer: ?*?*ISpRecognizer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpRecoContext,
                ppRecognizer: ?*?*ISpRecognizer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateGrammar: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpRecoContext,
                ullGrammarId: u64,
                ppGrammar: ?*?*ISpRecoGrammar,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpRecoContext,
                ullGrammarId: u64,
                ppGrammar: ?*?*ISpRecoGrammar,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpRecoContext,
                pStatus: ?*SPRECOCONTEXTSTATUS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpRecoContext,
                pStatus: ?*SPRECOCONTEXTSTATUS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMaxAlternates: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpRecoContext,
                pcAlternates: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpRecoContext,
                pcAlternates: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetMaxAlternates: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpRecoContext,
                cAlternates: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpRecoContext,
                cAlternates: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetAudioOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpRecoContext,
                Options: SPAUDIOOPTIONS,
                pAudioFormatId: ?*const Guid,
                pWaveFormatEx: ?*const WAVEFORMATEX,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpRecoContext,
                Options: SPAUDIOOPTIONS,
                pAudioFormatId: ?*const Guid,
                pWaveFormatEx: ?*const WAVEFORMATEX,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAudioOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpRecoContext,
                pOptions: ?*SPAUDIOOPTIONS,
                pAudioFormatId: ?*Guid,
                ppCoMemWFEX: ?*?*WAVEFORMATEX,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpRecoContext,
                pOptions: ?*SPAUDIOOPTIONS,
                pAudioFormatId: ?*Guid,
                ppCoMemWFEX: ?*?*WAVEFORMATEX,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeserializeResult: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpRecoContext,
                pSerializedResult: ?*const SPSERIALIZEDRESULT,
                ppResult: ?*?*ISpRecoResult,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpRecoContext,
                pSerializedResult: ?*const SPSERIALIZEDRESULT,
                ppResult: ?*?*ISpRecoResult,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Bookmark: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpRecoContext,
                Options: SPBOOKMARKOPTIONS,
                ullStreamPosition: u64,
                lparamEvent: LPARAM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpRecoContext,
                Options: SPBOOKMARKOPTIONS,
                ullStreamPosition: u64,
                lparamEvent: LPARAM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetAdaptationData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpRecoContext,
                pAdaptationData: ?[*:0]const u16,
                cch: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpRecoContext,
                pAdaptationData: ?[*:0]const u16,
                cch: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Pause: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpRecoContext,
                dwReserved: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpRecoContext,
                dwReserved: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Resume: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpRecoContext,
                dwReserved: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpRecoContext,
                dwReserved: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetVoice: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpRecoContext,
                pVoice: ?*ISpVoice,
                fAllowFormatChanges: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpRecoContext,
                pVoice: ?*ISpVoice,
                fAllowFormatChanges: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVoice: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpRecoContext,
                ppVoice: ?*?*ISpVoice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpRecoContext,
                ppVoice: ?*?*ISpVoice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetVoicePurgeEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpRecoContext,
                ullEventInterest: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpRecoContext,
                ullEventInterest: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVoicePurgeEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpRecoContext,
                pullEventInterest: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpRecoContext,
                pullEventInterest: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetContextState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpRecoContext,
                eContextState: SPCONTEXTSTATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpRecoContext,
                eContextState: SPCONTEXTSTATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetContextState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpRecoContext,
                peContextState: ?*SPCONTEXTSTATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpRecoContext,
                peContextState: ?*SPCONTEXTSTATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISpEventSource.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpRecoContext_GetRecognizer(self: *const T, ppRecognizer: ?*?*ISpRecognizer) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpRecoContext.VTable, self.vtable).GetRecognizer(@ptrCast(*const ISpRecoContext, self), ppRecognizer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpRecoContext_CreateGrammar(self: *const T, ullGrammarId: u64, ppGrammar: ?*?*ISpRecoGrammar) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpRecoContext.VTable, self.vtable).CreateGrammar(@ptrCast(*const ISpRecoContext, self), ullGrammarId, ppGrammar);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpRecoContext_GetStatus(self: *const T, pStatus: ?*SPRECOCONTEXTSTATUS) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpRecoContext.VTable, self.vtable).GetStatus(@ptrCast(*const ISpRecoContext, self), pStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpRecoContext_GetMaxAlternates(self: *const T, pcAlternates: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpRecoContext.VTable, self.vtable).GetMaxAlternates(@ptrCast(*const ISpRecoContext, self), pcAlternates);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpRecoContext_SetMaxAlternates(self: *const T, cAlternates: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpRecoContext.VTable, self.vtable).SetMaxAlternates(@ptrCast(*const ISpRecoContext, self), cAlternates);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpRecoContext_SetAudioOptions(self: *const T, Options: SPAUDIOOPTIONS, pAudioFormatId: ?*const Guid, pWaveFormatEx: ?*const WAVEFORMATEX) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpRecoContext.VTable, self.vtable).SetAudioOptions(@ptrCast(*const ISpRecoContext, self), Options, pAudioFormatId, pWaveFormatEx);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpRecoContext_GetAudioOptions(self: *const T, pOptions: ?*SPAUDIOOPTIONS, pAudioFormatId: ?*Guid, ppCoMemWFEX: ?*?*WAVEFORMATEX) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpRecoContext.VTable, self.vtable).GetAudioOptions(@ptrCast(*const ISpRecoContext, self), pOptions, pAudioFormatId, ppCoMemWFEX);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpRecoContext_DeserializeResult(self: *const T, pSerializedResult: ?*const SPSERIALIZEDRESULT, ppResult: ?*?*ISpRecoResult) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpRecoContext.VTable, self.vtable).DeserializeResult(@ptrCast(*const ISpRecoContext, self), pSerializedResult, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpRecoContext_Bookmark(self: *const T, Options: SPBOOKMARKOPTIONS, ullStreamPosition: u64, lparamEvent: LPARAM) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpRecoContext.VTable, self.vtable).Bookmark(@ptrCast(*const ISpRecoContext, self), Options, ullStreamPosition, lparamEvent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpRecoContext_SetAdaptationData(self: *const T, pAdaptationData: ?[*:0]const u16, cch: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpRecoContext.VTable, self.vtable).SetAdaptationData(@ptrCast(*const ISpRecoContext, self), pAdaptationData, cch);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpRecoContext_Pause(self: *const T, dwReserved: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpRecoContext.VTable, self.vtable).Pause(@ptrCast(*const ISpRecoContext, self), dwReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpRecoContext_Resume(self: *const T, dwReserved: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpRecoContext.VTable, self.vtable).Resume(@ptrCast(*const ISpRecoContext, self), dwReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpRecoContext_SetVoice(self: *const T, pVoice: ?*ISpVoice, fAllowFormatChanges: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpRecoContext.VTable, self.vtable).SetVoice(@ptrCast(*const ISpRecoContext, self), pVoice, fAllowFormatChanges);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpRecoContext_GetVoice(self: *const T, ppVoice: ?*?*ISpVoice) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpRecoContext.VTable, self.vtable).GetVoice(@ptrCast(*const ISpRecoContext, self), ppVoice);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpRecoContext_SetVoicePurgeEvent(self: *const T, ullEventInterest: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpRecoContext.VTable, self.vtable).SetVoicePurgeEvent(@ptrCast(*const ISpRecoContext, self), ullEventInterest);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpRecoContext_GetVoicePurgeEvent(self: *const T, pullEventInterest: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpRecoContext.VTable, self.vtable).GetVoicePurgeEvent(@ptrCast(*const ISpRecoContext, self), pullEventInterest);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpRecoContext_SetContextState(self: *const T, eContextState: SPCONTEXTSTATE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpRecoContext.VTable, self.vtable).SetContextState(@ptrCast(*const ISpRecoContext, self), eContextState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpRecoContext_GetContextState(self: *const T, peContextState: ?*SPCONTEXTSTATE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpRecoContext.VTable, self.vtable).GetContextState(@ptrCast(*const ISpRecoContext, self), peContextState);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SPGRAMMAROPTIONS = enum(i32) {
    SAPI = 1,
    SRGS = 2,
    UPS = 4,
    SRGS_MS_SCRIPT = 8,
    SRGS_W3C_SCRIPT = 256,
    SRGS_STG_SCRIPT = 512,
    SRGS_SCRIPT = 778,
    FILE = 16,
    HTTP = 32,
    RES = 64,
    OBJECT = 128,
    DEFAULT = 1019,
    ALL = 1023,
};
pub const SPGO_SAPI = SPGRAMMAROPTIONS.SAPI;
pub const SPGO_SRGS = SPGRAMMAROPTIONS.SRGS;
pub const SPGO_UPS = SPGRAMMAROPTIONS.UPS;
pub const SPGO_SRGS_MS_SCRIPT = SPGRAMMAROPTIONS.SRGS_MS_SCRIPT;
pub const SPGO_SRGS_W3C_SCRIPT = SPGRAMMAROPTIONS.SRGS_W3C_SCRIPT;
pub const SPGO_SRGS_STG_SCRIPT = SPGRAMMAROPTIONS.SRGS_STG_SCRIPT;
pub const SPGO_SRGS_SCRIPT = SPGRAMMAROPTIONS.SRGS_SCRIPT;
pub const SPGO_FILE = SPGRAMMAROPTIONS.FILE;
pub const SPGO_HTTP = SPGRAMMAROPTIONS.HTTP;
pub const SPGO_RES = SPGRAMMAROPTIONS.RES;
pub const SPGO_OBJECT = SPGRAMMAROPTIONS.OBJECT;
pub const SPGO_DEFAULT = SPGRAMMAROPTIONS.DEFAULT;
pub const SPGO_ALL = SPGRAMMAROPTIONS.ALL;

pub const SPADAPTATIONSETTINGS = enum(i32) {
    Default = 0,
    CurrentRecognizer = 1,
    RecoProfile = 2,
    Immediate = 4,
    Reset = 8,
    HighVolumeDataSource = 16,
};
pub const SPADS_Default = SPADAPTATIONSETTINGS.Default;
pub const SPADS_CurrentRecognizer = SPADAPTATIONSETTINGS.CurrentRecognizer;
pub const SPADS_RecoProfile = SPADAPTATIONSETTINGS.RecoProfile;
pub const SPADS_Immediate = SPADAPTATIONSETTINGS.Immediate;
pub const SPADS_Reset = SPADAPTATIONSETTINGS.Reset;
pub const SPADS_HighVolumeDataSource = SPADAPTATIONSETTINGS.HighVolumeDataSource;

pub const SPADAPTATIONRELEVANCE = enum(i32) {
    Unknown = 0,
    Low = 1,
    Medium = 2,
    High = 3,
};
pub const SPAR_Unknown = SPADAPTATIONRELEVANCE.Unknown;
pub const SPAR_Low = SPADAPTATIONRELEVANCE.Low;
pub const SPAR_Medium = SPADAPTATIONRELEVANCE.Medium;
pub const SPAR_High = SPADAPTATIONRELEVANCE.High;

const IID_ISpRecoContext2_Value = Guid.initString("bead311c-52ff-437f-9464-6b21054ca73d");
pub const IID_ISpRecoContext2 = &IID_ISpRecoContext2_Value;
pub const ISpRecoContext2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetGrammarOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpRecoContext2,
                eGrammarOptions: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpRecoContext2,
                eGrammarOptions: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetGrammarOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpRecoContext2,
                peGrammarOptions: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpRecoContext2,
                peGrammarOptions: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetAdaptationData2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpRecoContext2,
                pAdaptationData: ?[*:0]const u16,
                cch: u32,
                pTopicName: ?[*:0]const u16,
                eAdaptationSettings: u32,
                eRelevance: SPADAPTATIONRELEVANCE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpRecoContext2,
                pAdaptationData: ?[*:0]const u16,
                cch: u32,
                pTopicName: ?[*:0]const u16,
                eAdaptationSettings: u32,
                eRelevance: SPADAPTATIONRELEVANCE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpRecoContext2_SetGrammarOptions(self: *const T, eGrammarOptions: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpRecoContext2.VTable, self.vtable).SetGrammarOptions(@ptrCast(*const ISpRecoContext2, self), eGrammarOptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpRecoContext2_GetGrammarOptions(self: *const T, peGrammarOptions: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpRecoContext2.VTable, self.vtable).GetGrammarOptions(@ptrCast(*const ISpRecoContext2, self), peGrammarOptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpRecoContext2_SetAdaptationData2(self: *const T, pAdaptationData: ?[*:0]const u16, cch: u32, pTopicName: ?[*:0]const u16, eAdaptationSettings: u32, eRelevance: SPADAPTATIONRELEVANCE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpRecoContext2.VTable, self.vtable).SetAdaptationData2(@ptrCast(*const ISpRecoContext2, self), pAdaptationData, cch, pTopicName, eAdaptationSettings, eRelevance);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpProperties_Value = Guid.initString("5b4fb971-b115-4de1-ad97-e482e3bf6ee4");
pub const IID_ISpProperties = &IID_ISpProperties_Value;
pub const ISpProperties = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetPropertyNum: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpProperties,
                pName: ?[*:0]const u16,
                lValue: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpProperties,
                pName: ?[*:0]const u16,
                lValue: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPropertyNum: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpProperties,
                pName: ?[*:0]const u16,
                plValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpProperties,
                pName: ?[*:0]const u16,
                plValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPropertyString: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpProperties,
                pName: ?[*:0]const u16,
                pValue: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpProperties,
                pName: ?[*:0]const u16,
                pValue: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPropertyString: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpProperties,
                pName: ?[*:0]const u16,
                ppCoMemValue: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpProperties,
                pName: ?[*:0]const u16,
                ppCoMemValue: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpProperties_SetPropertyNum(self: *const T, pName: ?[*:0]const u16, lValue: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpProperties.VTable, self.vtable).SetPropertyNum(@ptrCast(*const ISpProperties, self), pName, lValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpProperties_GetPropertyNum(self: *const T, pName: ?[*:0]const u16, plValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpProperties.VTable, self.vtable).GetPropertyNum(@ptrCast(*const ISpProperties, self), pName, plValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpProperties_SetPropertyString(self: *const T, pName: ?[*:0]const u16, pValue: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpProperties.VTable, self.vtable).SetPropertyString(@ptrCast(*const ISpProperties, self), pName, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpProperties_GetPropertyString(self: *const T, pName: ?[*:0]const u16, ppCoMemValue: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpProperties.VTable, self.vtable).GetPropertyString(@ptrCast(*const ISpProperties, self), pName, ppCoMemValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SPRECOGNIZERSTATUS = extern struct {
    AudioStatus: SPAUDIOSTATUS,
    ullRecognitionStreamPos: u64,
    ulStreamNumber: u32,
    ulNumActive: u32,
    clsidEngine: Guid,
    cLangIDs: u32,
    aLangID: [20]u16,
    ullRecognitionStreamTime: u64,
};

pub const SPWAVEFORMATTYPE = enum(i32) {
    INPUT = 0,
    SRENGINE = 1,
};
pub const SPWF_INPUT = SPWAVEFORMATTYPE.INPUT;
pub const SPWF_SRENGINE = SPWAVEFORMATTYPE.SRENGINE;

pub const SPRECOSTATE = enum(i32) {
    INACTIVE = 0,
    ACTIVE = 1,
    ACTIVE_ALWAYS = 2,
    INACTIVE_WITH_PURGE = 3,
    NUM_STATES = 4,
};
pub const SPRST_INACTIVE = SPRECOSTATE.INACTIVE;
pub const SPRST_ACTIVE = SPRECOSTATE.ACTIVE;
pub const SPRST_ACTIVE_ALWAYS = SPRECOSTATE.ACTIVE_ALWAYS;
pub const SPRST_INACTIVE_WITH_PURGE = SPRECOSTATE.INACTIVE_WITH_PURGE;
pub const SPRST_NUM_STATES = SPRECOSTATE.NUM_STATES;

const IID_ISpRecognizer_Value = Guid.initString("c2b5f241-daa0-4507-9e16-5a1eaa2b7a5c");
pub const IID_ISpRecognizer = &IID_ISpRecognizer_Value;
pub const ISpRecognizer = extern struct {
    pub const VTable = extern struct {
        base: ISpProperties.VTable,
        SetRecognizer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpRecognizer,
                pRecognizer: ?*ISpObjectToken,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpRecognizer,
                pRecognizer: ?*ISpObjectToken,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecognizer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpRecognizer,
                ppRecognizer: ?*?*ISpObjectToken,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpRecognizer,
                ppRecognizer: ?*?*ISpObjectToken,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetInput: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpRecognizer,
                pUnkInput: ?*IUnknown,
                fAllowFormatChanges: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpRecognizer,
                pUnkInput: ?*IUnknown,
                fAllowFormatChanges: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInputObjectToken: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpRecognizer,
                ppToken: ?*?*ISpObjectToken,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpRecognizer,
                ppToken: ?*?*ISpObjectToken,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInputStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpRecognizer,
                ppStream: ?*?*ISpStreamFormat,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpRecognizer,
                ppStream: ?*?*ISpStreamFormat,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateRecoContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpRecognizer,
                ppNewCtxt: ?*?*ISpRecoContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpRecognizer,
                ppNewCtxt: ?*?*ISpRecoContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecoProfile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpRecognizer,
                ppToken: ?*?*ISpObjectToken,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpRecognizer,
                ppToken: ?*?*ISpObjectToken,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetRecoProfile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpRecognizer,
                pToken: ?*ISpObjectToken,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpRecognizer,
                pToken: ?*ISpObjectToken,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsSharedInstance: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpRecognizer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpRecognizer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecoState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpRecognizer,
                pState: ?*SPRECOSTATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpRecognizer,
                pState: ?*SPRECOSTATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetRecoState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpRecognizer,
                NewState: SPRECOSTATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpRecognizer,
                NewState: SPRECOSTATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpRecognizer,
                pStatus: ?*SPRECOGNIZERSTATUS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpRecognizer,
                pStatus: ?*SPRECOGNIZERSTATUS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFormat: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpRecognizer,
                WaveFormatType: SPWAVEFORMATTYPE,
                pFormatId: ?*Guid,
                ppCoMemWFEX: ?*?*WAVEFORMATEX,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpRecognizer,
                WaveFormatType: SPWAVEFORMATTYPE,
                pFormatId: ?*Guid,
                ppCoMemWFEX: ?*?*WAVEFORMATEX,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsUISupported: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpRecognizer,
                pszTypeOfUI: ?[*:0]const u16,
                pvExtraData: ?*anyopaque,
                cbExtraData: u32,
                pfSupported: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpRecognizer,
                pszTypeOfUI: ?[*:0]const u16,
                pvExtraData: ?*anyopaque,
                cbExtraData: u32,
                pfSupported: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DisplayUI: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpRecognizer,
                hwndParent: ?HWND,
                pszTitle: ?[*:0]const u16,
                pszTypeOfUI: ?[*:0]const u16,
                pvExtraData: ?*anyopaque,
                cbExtraData: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpRecognizer,
                hwndParent: ?HWND,
                pszTitle: ?[*:0]const u16,
                pszTypeOfUI: ?[*:0]const u16,
                pvExtraData: ?*anyopaque,
                cbExtraData: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EmulateRecognition: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpRecognizer,
                pPhrase: ?*ISpPhrase,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpRecognizer,
                pPhrase: ?*ISpPhrase,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISpProperties.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpRecognizer_SetRecognizer(self: *const T, pRecognizer: ?*ISpObjectToken) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpRecognizer.VTable, self.vtable).SetRecognizer(@ptrCast(*const ISpRecognizer, self), pRecognizer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpRecognizer_GetRecognizer(self: *const T, ppRecognizer: ?*?*ISpObjectToken) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpRecognizer.VTable, self.vtable).GetRecognizer(@ptrCast(*const ISpRecognizer, self), ppRecognizer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpRecognizer_SetInput(self: *const T, pUnkInput: ?*IUnknown, fAllowFormatChanges: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpRecognizer.VTable, self.vtable).SetInput(@ptrCast(*const ISpRecognizer, self), pUnkInput, fAllowFormatChanges);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpRecognizer_GetInputObjectToken(self: *const T, ppToken: ?*?*ISpObjectToken) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpRecognizer.VTable, self.vtable).GetInputObjectToken(@ptrCast(*const ISpRecognizer, self), ppToken);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpRecognizer_GetInputStream(self: *const T, ppStream: ?*?*ISpStreamFormat) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpRecognizer.VTable, self.vtable).GetInputStream(@ptrCast(*const ISpRecognizer, self), ppStream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpRecognizer_CreateRecoContext(self: *const T, ppNewCtxt: ?*?*ISpRecoContext) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpRecognizer.VTable, self.vtable).CreateRecoContext(@ptrCast(*const ISpRecognizer, self), ppNewCtxt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpRecognizer_GetRecoProfile(self: *const T, ppToken: ?*?*ISpObjectToken) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpRecognizer.VTable, self.vtable).GetRecoProfile(@ptrCast(*const ISpRecognizer, self), ppToken);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpRecognizer_SetRecoProfile(self: *const T, pToken: ?*ISpObjectToken) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpRecognizer.VTable, self.vtable).SetRecoProfile(@ptrCast(*const ISpRecognizer, self), pToken);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpRecognizer_IsSharedInstance(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpRecognizer.VTable, self.vtable).IsSharedInstance(@ptrCast(*const ISpRecognizer, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpRecognizer_GetRecoState(self: *const T, pState: ?*SPRECOSTATE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpRecognizer.VTable, self.vtable).GetRecoState(@ptrCast(*const ISpRecognizer, self), pState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpRecognizer_SetRecoState(self: *const T, NewState: SPRECOSTATE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpRecognizer.VTable, self.vtable).SetRecoState(@ptrCast(*const ISpRecognizer, self), NewState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpRecognizer_GetStatus(self: *const T, pStatus: ?*SPRECOGNIZERSTATUS) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpRecognizer.VTable, self.vtable).GetStatus(@ptrCast(*const ISpRecognizer, self), pStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpRecognizer_GetFormat(self: *const T, WaveFormatType: SPWAVEFORMATTYPE, pFormatId: ?*Guid, ppCoMemWFEX: ?*?*WAVEFORMATEX) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpRecognizer.VTable, self.vtable).GetFormat(@ptrCast(*const ISpRecognizer, self), WaveFormatType, pFormatId, ppCoMemWFEX);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpRecognizer_IsUISupported(self: *const T, pszTypeOfUI: ?[*:0]const u16, pvExtraData: ?*anyopaque, cbExtraData: u32, pfSupported: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpRecognizer.VTable, self.vtable).IsUISupported(@ptrCast(*const ISpRecognizer, self), pszTypeOfUI, pvExtraData, cbExtraData, pfSupported);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpRecognizer_DisplayUI(self: *const T, hwndParent: ?HWND, pszTitle: ?[*:0]const u16, pszTypeOfUI: ?[*:0]const u16, pvExtraData: ?*anyopaque, cbExtraData: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpRecognizer.VTable, self.vtable).DisplayUI(@ptrCast(*const ISpRecognizer, self), hwndParent, pszTitle, pszTypeOfUI, pvExtraData, cbExtraData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpRecognizer_EmulateRecognition(self: *const T, pPhrase: ?*ISpPhrase) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpRecognizer.VTable, self.vtable).EmulateRecognition(@ptrCast(*const ISpRecognizer, self), pPhrase);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpSerializeState_Value = Guid.initString("21b501a0-0ec7-46c9-92c3-a2bc784c54b9");
pub const IID_ISpSerializeState = &IID_ISpSerializeState_Value;
pub const ISpSerializeState = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSerializedState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpSerializeState,
                ppbData: ?*?*u8,
                pulSize: ?*u32,
                dwReserved: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpSerializeState,
                ppbData: ?*?*u8,
                pulSize: ?*u32,
                dwReserved: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSerializedState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpSerializeState,
                pbData: ?*u8,
                ulSize: u32,
                dwReserved: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpSerializeState,
                pbData: ?*u8,
                ulSize: u32,
                dwReserved: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpSerializeState_GetSerializedState(self: *const T, ppbData: ?*?*u8, pulSize: ?*u32, dwReserved: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpSerializeState.VTable, self.vtable).GetSerializedState(@ptrCast(*const ISpSerializeState, self), ppbData, pulSize, dwReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpSerializeState_SetSerializedState(self: *const T, pbData: ?*u8, ulSize: u32, dwReserved: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpSerializeState.VTable, self.vtable).SetSerializedState(@ptrCast(*const ISpSerializeState, self), pbData, ulSize, dwReserved);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpRecognizer2_Value = Guid.initString("8fc6d974-c81e-4098-93c5-0147f61ed4d3");
pub const IID_ISpRecognizer2 = &IID_ISpRecognizer2_Value;
pub const ISpRecognizer2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EmulateRecognitionEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpRecognizer2,
                pPhrase: ?*ISpPhrase,
                dwCompareFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpRecognizer2,
                pPhrase: ?*ISpPhrase,
                dwCompareFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTrainingState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpRecognizer2,
                fDoingTraining: BOOL,
                fAdaptFromTrainingData: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpRecognizer2,
                fDoingTraining: BOOL,
                fAdaptFromTrainingData: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ResetAcousticModelAdaptation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpRecognizer2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpRecognizer2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpRecognizer2_EmulateRecognitionEx(self: *const T, pPhrase: ?*ISpPhrase, dwCompareFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpRecognizer2.VTable, self.vtable).EmulateRecognitionEx(@ptrCast(*const ISpRecognizer2, self), pPhrase, dwCompareFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpRecognizer2_SetTrainingState(self: *const T, fDoingTraining: BOOL, fAdaptFromTrainingData: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpRecognizer2.VTable, self.vtable).SetTrainingState(@ptrCast(*const ISpRecognizer2, self), fDoingTraining, fAdaptFromTrainingData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpRecognizer2_ResetAcousticModelAdaptation(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpRecognizer2.VTable, self.vtable).ResetAcousticModelAdaptation(@ptrCast(*const ISpRecognizer2, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SPNORMALIZATIONLIST = extern struct {
    ulSize: u32,
    ppszzNormalizedList: ?*?*u16,
};

const IID_ISpEnginePronunciation_Value = Guid.initString("c360ce4b-76d1-4214-ad68-52657d5083da");
pub const IID_ISpEnginePronunciation = &IID_ISpEnginePronunciation_Value;
pub const ISpEnginePronunciation = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Normalize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpEnginePronunciation,
                pszWord: ?[*:0]const u16,
                pszLeftContext: ?[*:0]const u16,
                pszRightContext: ?[*:0]const u16,
                LangID: u16,
                pNormalizationList: ?*SPNORMALIZATIONLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpEnginePronunciation,
                pszWord: ?[*:0]const u16,
                pszLeftContext: ?[*:0]const u16,
                pszRightContext: ?[*:0]const u16,
                LangID: u16,
                pNormalizationList: ?*SPNORMALIZATIONLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPronunciations: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpEnginePronunciation,
                pszWord: ?[*:0]const u16,
                pszLeftContext: ?[*:0]const u16,
                pszRightContext: ?[*:0]const u16,
                LangID: u16,
                pEnginePronunciationList: ?*SPWORDPRONUNCIATIONLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpEnginePronunciation,
                pszWord: ?[*:0]const u16,
                pszLeftContext: ?[*:0]const u16,
                pszRightContext: ?[*:0]const u16,
                LangID: u16,
                pEnginePronunciationList: ?*SPWORDPRONUNCIATIONLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpEnginePronunciation_Normalize(self: *const T, pszWord: ?[*:0]const u16, pszLeftContext: ?[*:0]const u16, pszRightContext: ?[*:0]const u16, LangID: u16, pNormalizationList: ?*SPNORMALIZATIONLIST) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpEnginePronunciation.VTable, self.vtable).Normalize(@ptrCast(*const ISpEnginePronunciation, self), pszWord, pszLeftContext, pszRightContext, LangID, pNormalizationList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpEnginePronunciation_GetPronunciations(self: *const T, pszWord: ?[*:0]const u16, pszLeftContext: ?[*:0]const u16, pszRightContext: ?[*:0]const u16, LangID: u16, pEnginePronunciationList: ?*SPWORDPRONUNCIATIONLIST) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpEnginePronunciation.VTable, self.vtable).GetPronunciations(@ptrCast(*const ISpEnginePronunciation, self), pszWord, pszLeftContext, pszRightContext, LangID, pEnginePronunciationList);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SPDISPLAYTOKEN = extern struct {
    pszLexical: ?[*:0]const u16,
    pszDisplay: ?[*:0]const u16,
    bDisplayAttributes: u8,
};

pub const SPDISPLAYPHRASE = extern struct {
    ulNumTokens: u32,
    pTokens: ?*SPDISPLAYTOKEN,
};

const IID_ISpDisplayAlternates_Value = Guid.initString("c8d7c7e2-0dde-44b7-afe3-b0c991fbeb5e");
pub const IID_ISpDisplayAlternates = &IID_ISpDisplayAlternates_Value;
pub const ISpDisplayAlternates = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDisplayAlternates: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpDisplayAlternates,
                pPhrase: ?*const SPDISPLAYPHRASE,
                cRequestCount: u32,
                ppCoMemPhrases: ?*?*SPDISPLAYPHRASE,
                pcPhrasesReturned: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpDisplayAlternates,
                pPhrase: ?*const SPDISPLAYPHRASE,
                cRequestCount: u32,
                ppCoMemPhrases: ?*?*SPDISPLAYPHRASE,
                pcPhrasesReturned: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFullStopTrailSpace: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpDisplayAlternates,
                ulTrailSpace: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpDisplayAlternates,
                ulTrailSpace: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpDisplayAlternates_GetDisplayAlternates(self: *const T, pPhrase: ?*const SPDISPLAYPHRASE, cRequestCount: u32, ppCoMemPhrases: ?*?*SPDISPLAYPHRASE, pcPhrasesReturned: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpDisplayAlternates.VTable, self.vtable).GetDisplayAlternates(@ptrCast(*const ISpDisplayAlternates, self), pPhrase, cRequestCount, ppCoMemPhrases, pcPhrasesReturned);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpDisplayAlternates_SetFullStopTrailSpace(self: *const T, ulTrailSpace: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpDisplayAlternates.VTable, self.vtable).SetFullStopTrailSpace(@ptrCast(*const ISpDisplayAlternates, self), ulTrailSpace);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DISPID_SpeechDataKey = enum(i32) {
    SetBinaryValue = 1,
    GetBinaryValue = 2,
    SetStringValue = 3,
    GetStringValue = 4,
    SetLongValue = 5,
    GetlongValue = 6,
    OpenKey = 7,
    CreateKey = 8,
    DeleteKey = 9,
    DeleteValue = 10,
    EnumKeys = 11,
    EnumValues = 12,
};
pub const DISPID_SDKSetBinaryValue = DISPID_SpeechDataKey.SetBinaryValue;
pub const DISPID_SDKGetBinaryValue = DISPID_SpeechDataKey.GetBinaryValue;
pub const DISPID_SDKSetStringValue = DISPID_SpeechDataKey.SetStringValue;
pub const DISPID_SDKGetStringValue = DISPID_SpeechDataKey.GetStringValue;
pub const DISPID_SDKSetLongValue = DISPID_SpeechDataKey.SetLongValue;
pub const DISPID_SDKGetlongValue = DISPID_SpeechDataKey.GetlongValue;
pub const DISPID_SDKOpenKey = DISPID_SpeechDataKey.OpenKey;
pub const DISPID_SDKCreateKey = DISPID_SpeechDataKey.CreateKey;
pub const DISPID_SDKDeleteKey = DISPID_SpeechDataKey.DeleteKey;
pub const DISPID_SDKDeleteValue = DISPID_SpeechDataKey.DeleteValue;
pub const DISPID_SDKEnumKeys = DISPID_SpeechDataKey.EnumKeys;
pub const DISPID_SDKEnumValues = DISPID_SpeechDataKey.EnumValues;

pub const DISPID_SpeechObjectToken = enum(i32) {
    Id = 1,
    DataKey = 2,
    Category = 3,
    GetDescription = 4,
    SetId = 5,
    GetAttribute = 6,
    CreateInstance = 7,
    Remove = 8,
    GetStorageFileName = 9,
    RemoveStorageFileName = 10,
    IsUISupported = 11,
    DisplayUI = 12,
    MatchesAttributes = 13,
};
pub const DISPID_SOTId = DISPID_SpeechObjectToken.Id;
pub const DISPID_SOTDataKey = DISPID_SpeechObjectToken.DataKey;
pub const DISPID_SOTCategory = DISPID_SpeechObjectToken.Category;
pub const DISPID_SOTGetDescription = DISPID_SpeechObjectToken.GetDescription;
pub const DISPID_SOTSetId = DISPID_SpeechObjectToken.SetId;
pub const DISPID_SOTGetAttribute = DISPID_SpeechObjectToken.GetAttribute;
pub const DISPID_SOTCreateInstance = DISPID_SpeechObjectToken.CreateInstance;
pub const DISPID_SOTRemove = DISPID_SpeechObjectToken.Remove;
pub const DISPID_SOTGetStorageFileName = DISPID_SpeechObjectToken.GetStorageFileName;
pub const DISPID_SOTRemoveStorageFileName = DISPID_SpeechObjectToken.RemoveStorageFileName;
pub const DISPID_SOTIsUISupported = DISPID_SpeechObjectToken.IsUISupported;
pub const DISPID_SOTDisplayUI = DISPID_SpeechObjectToken.DisplayUI;
pub const DISPID_SOTMatchesAttributes = DISPID_SpeechObjectToken.MatchesAttributes;

pub const SpeechDataKeyLocation = enum(i32) {
    DefaultLocation = 0,
    CurrentUser = 1,
    LocalMachine = 2,
    CurrentConfig = 5,
};
pub const SDKLDefaultLocation = SpeechDataKeyLocation.DefaultLocation;
pub const SDKLCurrentUser = SpeechDataKeyLocation.CurrentUser;
pub const SDKLLocalMachine = SpeechDataKeyLocation.LocalMachine;
pub const SDKLCurrentConfig = SpeechDataKeyLocation.CurrentConfig;

pub const SpeechTokenContext = enum(u32) {
    InprocServer = 1,
    InprocHandler = 2,
    LocalServer = 4,
    RemoteServer = 16,
    All = 23,
};
pub const STCInprocServer = SpeechTokenContext.InprocServer;
pub const STCInprocHandler = SpeechTokenContext.InprocHandler;
pub const STCLocalServer = SpeechTokenContext.LocalServer;
pub const STCRemoteServer = SpeechTokenContext.RemoteServer;
pub const STCAll = SpeechTokenContext.All;

pub const SpeechTokenShellFolder = enum(i32) {
    AppData = 26,
    LocalAppData = 28,
    CommonAppData = 35,
    FlagCreate = 32768,
};
pub const STSF_AppData = SpeechTokenShellFolder.AppData;
pub const STSF_LocalAppData = SpeechTokenShellFolder.LocalAppData;
pub const STSF_CommonAppData = SpeechTokenShellFolder.CommonAppData;
pub const STSF_FlagCreate = SpeechTokenShellFolder.FlagCreate;

pub const DISPID_SpeechObjectTokens = enum(i32) {
    Count = 1,
    Item = 0,
    _NewEnum = -4,
};
pub const DISPID_SOTsCount = DISPID_SpeechObjectTokens.Count;
pub const DISPID_SOTsItem = DISPID_SpeechObjectTokens.Item;
pub const DISPID_SOTs_NewEnum = DISPID_SpeechObjectTokens._NewEnum;

pub const DISPID_SpeechObjectTokenCategory = enum(i32) {
    Id = 1,
    Default = 2,
    SetId = 3,
    GetDataKey = 4,
    EnumerateTokens = 5,
};
pub const DISPID_SOTCId = DISPID_SpeechObjectTokenCategory.Id;
pub const DISPID_SOTCDefault = DISPID_SpeechObjectTokenCategory.Default;
pub const DISPID_SOTCSetId = DISPID_SpeechObjectTokenCategory.SetId;
pub const DISPID_SOTCGetDataKey = DISPID_SpeechObjectTokenCategory.GetDataKey;
pub const DISPID_SOTCEnumerateTokens = DISPID_SpeechObjectTokenCategory.EnumerateTokens;

pub const SpeechAudioFormatType = enum(i32) {
    Default = -1,
    NoAssignedFormat = 0,
    Text = 1,
    NonStandardFormat = 2,
    ExtendedAudioFormat = 3,
    @"8kHz8BitMono" = 4,
    @"8kHz8BitStereo" = 5,
    @"8kHz16BitMono" = 6,
    @"8kHz16BitStereo" = 7,
    @"11kHz8BitMono" = 8,
    @"11kHz8BitStereo" = 9,
    @"11kHz16BitMono" = 10,
    @"11kHz16BitStereo" = 11,
    @"12kHz8BitMono" = 12,
    @"12kHz8BitStereo" = 13,
    @"12kHz16BitMono" = 14,
    @"12kHz16BitStereo" = 15,
    @"16kHz8BitMono" = 16,
    @"16kHz8BitStereo" = 17,
    @"16kHz16BitMono" = 18,
    @"16kHz16BitStereo" = 19,
    @"22kHz8BitMono" = 20,
    @"22kHz8BitStereo" = 21,
    @"22kHz16BitMono" = 22,
    @"22kHz16BitStereo" = 23,
    @"24kHz8BitMono" = 24,
    @"24kHz8BitStereo" = 25,
    @"24kHz16BitMono" = 26,
    @"24kHz16BitStereo" = 27,
    @"32kHz8BitMono" = 28,
    @"32kHz8BitStereo" = 29,
    @"32kHz16BitMono" = 30,
    @"32kHz16BitStereo" = 31,
    @"44kHz8BitMono" = 32,
    @"44kHz8BitStereo" = 33,
    @"44kHz16BitMono" = 34,
    @"44kHz16BitStereo" = 35,
    @"48kHz8BitMono" = 36,
    @"48kHz8BitStereo" = 37,
    @"48kHz16BitMono" = 38,
    @"48kHz16BitStereo" = 39,
    TrueSpeech_8kHz1BitMono = 40,
    CCITT_ALaw_8kHzMono = 41,
    CCITT_ALaw_8kHzStereo = 42,
    CCITT_ALaw_11kHzMono = 43,
    CCITT_ALaw_11kHzStereo = 44,
    CCITT_ALaw_22kHzMono = 45,
    CCITT_ALaw_22kHzStereo = 46,
    CCITT_ALaw_44kHzMono = 47,
    CCITT_ALaw_44kHzStereo = 48,
    CCITT_uLaw_8kHzMono = 49,
    CCITT_uLaw_8kHzStereo = 50,
    CCITT_uLaw_11kHzMono = 51,
    CCITT_uLaw_11kHzStereo = 52,
    CCITT_uLaw_22kHzMono = 53,
    CCITT_uLaw_22kHzStereo = 54,
    CCITT_uLaw_44kHzMono = 55,
    CCITT_uLaw_44kHzStereo = 56,
    ADPCM_8kHzMono = 57,
    ADPCM_8kHzStereo = 58,
    ADPCM_11kHzMono = 59,
    ADPCM_11kHzStereo = 60,
    ADPCM_22kHzMono = 61,
    ADPCM_22kHzStereo = 62,
    ADPCM_44kHzMono = 63,
    ADPCM_44kHzStereo = 64,
    GSM610_8kHzMono = 65,
    GSM610_11kHzMono = 66,
    GSM610_22kHzMono = 67,
    GSM610_44kHzMono = 68,
};
pub const SAFTDefault = SpeechAudioFormatType.Default;
pub const SAFTNoAssignedFormat = SpeechAudioFormatType.NoAssignedFormat;
pub const SAFTText = SpeechAudioFormatType.Text;
pub const SAFTNonStandardFormat = SpeechAudioFormatType.NonStandardFormat;
pub const SAFTExtendedAudioFormat = SpeechAudioFormatType.ExtendedAudioFormat;
pub const SAFT8kHz8BitMono = SpeechAudioFormatType.@"8kHz8BitMono";
pub const SAFT8kHz8BitStereo = SpeechAudioFormatType.@"8kHz8BitStereo";
pub const SAFT8kHz16BitMono = SpeechAudioFormatType.@"8kHz16BitMono";
pub const SAFT8kHz16BitStereo = SpeechAudioFormatType.@"8kHz16BitStereo";
pub const SAFT11kHz8BitMono = SpeechAudioFormatType.@"11kHz8BitMono";
pub const SAFT11kHz8BitStereo = SpeechAudioFormatType.@"11kHz8BitStereo";
pub const SAFT11kHz16BitMono = SpeechAudioFormatType.@"11kHz16BitMono";
pub const SAFT11kHz16BitStereo = SpeechAudioFormatType.@"11kHz16BitStereo";
pub const SAFT12kHz8BitMono = SpeechAudioFormatType.@"12kHz8BitMono";
pub const SAFT12kHz8BitStereo = SpeechAudioFormatType.@"12kHz8BitStereo";
pub const SAFT12kHz16BitMono = SpeechAudioFormatType.@"12kHz16BitMono";
pub const SAFT12kHz16BitStereo = SpeechAudioFormatType.@"12kHz16BitStereo";
pub const SAFT16kHz8BitMono = SpeechAudioFormatType.@"16kHz8BitMono";
pub const SAFT16kHz8BitStereo = SpeechAudioFormatType.@"16kHz8BitStereo";
pub const SAFT16kHz16BitMono = SpeechAudioFormatType.@"16kHz16BitMono";
pub const SAFT16kHz16BitStereo = SpeechAudioFormatType.@"16kHz16BitStereo";
pub const SAFT22kHz8BitMono = SpeechAudioFormatType.@"22kHz8BitMono";
pub const SAFT22kHz8BitStereo = SpeechAudioFormatType.@"22kHz8BitStereo";
pub const SAFT22kHz16BitMono = SpeechAudioFormatType.@"22kHz16BitMono";
pub const SAFT22kHz16BitStereo = SpeechAudioFormatType.@"22kHz16BitStereo";
pub const SAFT24kHz8BitMono = SpeechAudioFormatType.@"24kHz8BitMono";
pub const SAFT24kHz8BitStereo = SpeechAudioFormatType.@"24kHz8BitStereo";
pub const SAFT24kHz16BitMono = SpeechAudioFormatType.@"24kHz16BitMono";
pub const SAFT24kHz16BitStereo = SpeechAudioFormatType.@"24kHz16BitStereo";
pub const SAFT32kHz8BitMono = SpeechAudioFormatType.@"32kHz8BitMono";
pub const SAFT32kHz8BitStereo = SpeechAudioFormatType.@"32kHz8BitStereo";
pub const SAFT32kHz16BitMono = SpeechAudioFormatType.@"32kHz16BitMono";
pub const SAFT32kHz16BitStereo = SpeechAudioFormatType.@"32kHz16BitStereo";
pub const SAFT44kHz8BitMono = SpeechAudioFormatType.@"44kHz8BitMono";
pub const SAFT44kHz8BitStereo = SpeechAudioFormatType.@"44kHz8BitStereo";
pub const SAFT44kHz16BitMono = SpeechAudioFormatType.@"44kHz16BitMono";
pub const SAFT44kHz16BitStereo = SpeechAudioFormatType.@"44kHz16BitStereo";
pub const SAFT48kHz8BitMono = SpeechAudioFormatType.@"48kHz8BitMono";
pub const SAFT48kHz8BitStereo = SpeechAudioFormatType.@"48kHz8BitStereo";
pub const SAFT48kHz16BitMono = SpeechAudioFormatType.@"48kHz16BitMono";
pub const SAFT48kHz16BitStereo = SpeechAudioFormatType.@"48kHz16BitStereo";
pub const SAFTTrueSpeech_8kHz1BitMono = SpeechAudioFormatType.TrueSpeech_8kHz1BitMono;
pub const SAFTCCITT_ALaw_8kHzMono = SpeechAudioFormatType.CCITT_ALaw_8kHzMono;
pub const SAFTCCITT_ALaw_8kHzStereo = SpeechAudioFormatType.CCITT_ALaw_8kHzStereo;
pub const SAFTCCITT_ALaw_11kHzMono = SpeechAudioFormatType.CCITT_ALaw_11kHzMono;
pub const SAFTCCITT_ALaw_11kHzStereo = SpeechAudioFormatType.CCITT_ALaw_11kHzStereo;
pub const SAFTCCITT_ALaw_22kHzMono = SpeechAudioFormatType.CCITT_ALaw_22kHzMono;
pub const SAFTCCITT_ALaw_22kHzStereo = SpeechAudioFormatType.CCITT_ALaw_22kHzStereo;
pub const SAFTCCITT_ALaw_44kHzMono = SpeechAudioFormatType.CCITT_ALaw_44kHzMono;
pub const SAFTCCITT_ALaw_44kHzStereo = SpeechAudioFormatType.CCITT_ALaw_44kHzStereo;
pub const SAFTCCITT_uLaw_8kHzMono = SpeechAudioFormatType.CCITT_uLaw_8kHzMono;
pub const SAFTCCITT_uLaw_8kHzStereo = SpeechAudioFormatType.CCITT_uLaw_8kHzStereo;
pub const SAFTCCITT_uLaw_11kHzMono = SpeechAudioFormatType.CCITT_uLaw_11kHzMono;
pub const SAFTCCITT_uLaw_11kHzStereo = SpeechAudioFormatType.CCITT_uLaw_11kHzStereo;
pub const SAFTCCITT_uLaw_22kHzMono = SpeechAudioFormatType.CCITT_uLaw_22kHzMono;
pub const SAFTCCITT_uLaw_22kHzStereo = SpeechAudioFormatType.CCITT_uLaw_22kHzStereo;
pub const SAFTCCITT_uLaw_44kHzMono = SpeechAudioFormatType.CCITT_uLaw_44kHzMono;
pub const SAFTCCITT_uLaw_44kHzStereo = SpeechAudioFormatType.CCITT_uLaw_44kHzStereo;
pub const SAFTADPCM_8kHzMono = SpeechAudioFormatType.ADPCM_8kHzMono;
pub const SAFTADPCM_8kHzStereo = SpeechAudioFormatType.ADPCM_8kHzStereo;
pub const SAFTADPCM_11kHzMono = SpeechAudioFormatType.ADPCM_11kHzMono;
pub const SAFTADPCM_11kHzStereo = SpeechAudioFormatType.ADPCM_11kHzStereo;
pub const SAFTADPCM_22kHzMono = SpeechAudioFormatType.ADPCM_22kHzMono;
pub const SAFTADPCM_22kHzStereo = SpeechAudioFormatType.ADPCM_22kHzStereo;
pub const SAFTADPCM_44kHzMono = SpeechAudioFormatType.ADPCM_44kHzMono;
pub const SAFTADPCM_44kHzStereo = SpeechAudioFormatType.ADPCM_44kHzStereo;
pub const SAFTGSM610_8kHzMono = SpeechAudioFormatType.GSM610_8kHzMono;
pub const SAFTGSM610_11kHzMono = SpeechAudioFormatType.GSM610_11kHzMono;
pub const SAFTGSM610_22kHzMono = SpeechAudioFormatType.GSM610_22kHzMono;
pub const SAFTGSM610_44kHzMono = SpeechAudioFormatType.GSM610_44kHzMono;

pub const DISPID_SpeechAudioFormat = enum(i32) {
    Type = 1,
    Guid = 2,
    GetWaveFormatEx = 3,
    SetWaveFormatEx = 4,
};
pub const DISPID_SAFType = DISPID_SpeechAudioFormat.Type;
pub const DISPID_SAFGuid = DISPID_SpeechAudioFormat.Guid;
pub const DISPID_SAFGetWaveFormatEx = DISPID_SpeechAudioFormat.GetWaveFormatEx;
pub const DISPID_SAFSetWaveFormatEx = DISPID_SpeechAudioFormat.SetWaveFormatEx;

pub const DISPID_SpeechBaseStream = enum(i32) {
    Format = 1,
    Read = 2,
    Write = 3,
    Seek = 4,
};
pub const DISPID_SBSFormat = DISPID_SpeechBaseStream.Format;
pub const DISPID_SBSRead = DISPID_SpeechBaseStream.Read;
pub const DISPID_SBSWrite = DISPID_SpeechBaseStream.Write;
pub const DISPID_SBSSeek = DISPID_SpeechBaseStream.Seek;

pub const SpeechStreamSeekPositionType = enum(u32) {
    Start = 0,
    CurrentPosition = 1,
    End = 2,
};
pub const SSSPTRelativeToStart = SpeechStreamSeekPositionType.Start;
pub const SSSPTRelativeToCurrentPosition = SpeechStreamSeekPositionType.CurrentPosition;
pub const SSSPTRelativeToEnd = SpeechStreamSeekPositionType.End;

pub const DISPID_SpeechAudio = enum(i32) {
    Status = 200,
    BufferInfo = 201,
    DefaultFormat = 202,
    Volume = 203,
    BufferNotifySize = 204,
    EventHandle = 205,
    SetState = 206,
};
pub const DISPID_SAStatus = DISPID_SpeechAudio.Status;
pub const DISPID_SABufferInfo = DISPID_SpeechAudio.BufferInfo;
pub const DISPID_SADefaultFormat = DISPID_SpeechAudio.DefaultFormat;
pub const DISPID_SAVolume = DISPID_SpeechAudio.Volume;
pub const DISPID_SABufferNotifySize = DISPID_SpeechAudio.BufferNotifySize;
pub const DISPID_SAEventHandle = DISPID_SpeechAudio.EventHandle;
pub const DISPID_SASetState = DISPID_SpeechAudio.SetState;

pub const SpeechAudioState = enum(i32) {
    Closed = 0,
    Stop = 1,
    Pause = 2,
    Run = 3,
};
pub const SASClosed = SpeechAudioState.Closed;
pub const SASStop = SpeechAudioState.Stop;
pub const SASPause = SpeechAudioState.Pause;
pub const SASRun = SpeechAudioState.Run;

pub const DISPID_SpeechMMSysAudio = enum(i32) {
    DeviceId = 300,
    LineId = 301,
    MMHandle = 302,
};
pub const DISPID_SMSADeviceId = DISPID_SpeechMMSysAudio.DeviceId;
pub const DISPID_SMSALineId = DISPID_SpeechMMSysAudio.LineId;
pub const DISPID_SMSAMMHandle = DISPID_SpeechMMSysAudio.MMHandle;

pub const DISPID_SpeechFileStream = enum(i32) {
    Open = 100,
    Close = 101,
};
pub const DISPID_SFSOpen = DISPID_SpeechFileStream.Open;
pub const DISPID_SFSClose = DISPID_SpeechFileStream.Close;

pub const SpeechStreamFileMode = enum(i32) {
    OpenForRead = 0,
    OpenReadWrite = 1,
    Create = 2,
    CreateForWrite = 3,
};
pub const SSFMOpenForRead = SpeechStreamFileMode.OpenForRead;
pub const SSFMOpenReadWrite = SpeechStreamFileMode.OpenReadWrite;
pub const SSFMCreate = SpeechStreamFileMode.Create;
pub const SSFMCreateForWrite = SpeechStreamFileMode.CreateForWrite;

pub const DISPID_SpeechCustomStream = enum(i32) {
    m = 100,
};
pub const DISPID_SCSBaseStream = DISPID_SpeechCustomStream.m;

pub const DISPID_SpeechMemoryStream = enum(i32) {
    SetData = 100,
    GetData = 101,
};
pub const DISPID_SMSSetData = DISPID_SpeechMemoryStream.SetData;
pub const DISPID_SMSGetData = DISPID_SpeechMemoryStream.GetData;

pub const DISPID_SpeechAudioStatus = enum(i32) {
    FreeBufferSpace = 1,
    NonBlockingIO = 2,
    State = 3,
    CurrentSeekPosition = 4,
    CurrentDevicePosition = 5,
};
pub const DISPID_SASFreeBufferSpace = DISPID_SpeechAudioStatus.FreeBufferSpace;
pub const DISPID_SASNonBlockingIO = DISPID_SpeechAudioStatus.NonBlockingIO;
pub const DISPID_SASState = DISPID_SpeechAudioStatus.State;
pub const DISPID_SASCurrentSeekPosition = DISPID_SpeechAudioStatus.CurrentSeekPosition;
pub const DISPID_SASCurrentDevicePosition = DISPID_SpeechAudioStatus.CurrentDevicePosition;

pub const DISPID_SpeechAudioBufferInfo = enum(i32) {
    MinNotification = 1,
    BufferSize = 2,
    EventBias = 3,
};
pub const DISPID_SABIMinNotification = DISPID_SpeechAudioBufferInfo.MinNotification;
pub const DISPID_SABIBufferSize = DISPID_SpeechAudioBufferInfo.BufferSize;
pub const DISPID_SABIEventBias = DISPID_SpeechAudioBufferInfo.EventBias;

pub const DISPID_SpeechWaveFormatEx = enum(i32) {
    FormatTag = 1,
    Channels = 2,
    SamplesPerSec = 3,
    AvgBytesPerSec = 4,
    BlockAlign = 5,
    BitsPerSample = 6,
    ExtraData = 7,
};
pub const DISPID_SWFEFormatTag = DISPID_SpeechWaveFormatEx.FormatTag;
pub const DISPID_SWFEChannels = DISPID_SpeechWaveFormatEx.Channels;
pub const DISPID_SWFESamplesPerSec = DISPID_SpeechWaveFormatEx.SamplesPerSec;
pub const DISPID_SWFEAvgBytesPerSec = DISPID_SpeechWaveFormatEx.AvgBytesPerSec;
pub const DISPID_SWFEBlockAlign = DISPID_SpeechWaveFormatEx.BlockAlign;
pub const DISPID_SWFEBitsPerSample = DISPID_SpeechWaveFormatEx.BitsPerSample;
pub const DISPID_SWFEExtraData = DISPID_SpeechWaveFormatEx.ExtraData;

pub const DISPID_SpeechVoice = enum(i32) {
    Status = 1,
    Voice = 2,
    AudioOutput = 3,
    AudioOutputStream = 4,
    Rate = 5,
    Volume = 6,
    AllowAudioOuputFormatChangesOnNextSet = 7,
    EventInterests = 8,
    Priority = 9,
    AlertBoundary = 10,
    SyncronousSpeakTimeout = 11,
    Speak = 12,
    SpeakStream = 13,
    Pause = 14,
    Resume = 15,
    Skip = 16,
    GetVoices = 17,
    GetAudioOutputs = 18,
    WaitUntilDone = 19,
    SpeakCompleteEvent = 20,
    IsUISupported = 21,
    DisplayUI = 22,
};
pub const DISPID_SVStatus = DISPID_SpeechVoice.Status;
pub const DISPID_SVVoice = DISPID_SpeechVoice.Voice;
pub const DISPID_SVAudioOutput = DISPID_SpeechVoice.AudioOutput;
pub const DISPID_SVAudioOutputStream = DISPID_SpeechVoice.AudioOutputStream;
pub const DISPID_SVRate = DISPID_SpeechVoice.Rate;
pub const DISPID_SVVolume = DISPID_SpeechVoice.Volume;
pub const DISPID_SVAllowAudioOuputFormatChangesOnNextSet = DISPID_SpeechVoice.AllowAudioOuputFormatChangesOnNextSet;
pub const DISPID_SVEventInterests = DISPID_SpeechVoice.EventInterests;
pub const DISPID_SVPriority = DISPID_SpeechVoice.Priority;
pub const DISPID_SVAlertBoundary = DISPID_SpeechVoice.AlertBoundary;
pub const DISPID_SVSyncronousSpeakTimeout = DISPID_SpeechVoice.SyncronousSpeakTimeout;
pub const DISPID_SVSpeak = DISPID_SpeechVoice.Speak;
pub const DISPID_SVSpeakStream = DISPID_SpeechVoice.SpeakStream;
pub const DISPID_SVPause = DISPID_SpeechVoice.Pause;
pub const DISPID_SVResume = DISPID_SpeechVoice.Resume;
pub const DISPID_SVSkip = DISPID_SpeechVoice.Skip;
pub const DISPID_SVGetVoices = DISPID_SpeechVoice.GetVoices;
pub const DISPID_SVGetAudioOutputs = DISPID_SpeechVoice.GetAudioOutputs;
pub const DISPID_SVWaitUntilDone = DISPID_SpeechVoice.WaitUntilDone;
pub const DISPID_SVSpeakCompleteEvent = DISPID_SpeechVoice.SpeakCompleteEvent;
pub const DISPID_SVIsUISupported = DISPID_SpeechVoice.IsUISupported;
pub const DISPID_SVDisplayUI = DISPID_SpeechVoice.DisplayUI;

pub const SpeechVoicePriority = enum(i32) {
    Normal = 0,
    Alert = 1,
    Over = 2,
};
pub const SVPNormal = SpeechVoicePriority.Normal;
pub const SVPAlert = SpeechVoicePriority.Alert;
pub const SVPOver = SpeechVoicePriority.Over;

pub const SpeechVoiceSpeakFlags = enum(i32) {
    Default = 0,
    lagsAsync = 1,
    PurgeBeforeSpeak = 2,
    IsFilename = 4,
    IsXML = 8,
    IsNotXML = 16,
    PersistXML = 32,
    NLPSpeakPunc = 64,
    ParseSapi = 128,
    ParseSsml = 256,
    // ParseAutodetect = 0, this enum value conflicts with Default
    // NLPMask = 64, this enum value conflicts with NLPSpeakPunc
    ParseMask = 384,
    VoiceMask = 511,
    UnusedFlags = -512,
};
pub const SVSFDefault = SpeechVoiceSpeakFlags.Default;
pub const SVSFlagsAsync = SpeechVoiceSpeakFlags.lagsAsync;
pub const SVSFPurgeBeforeSpeak = SpeechVoiceSpeakFlags.PurgeBeforeSpeak;
pub const SVSFIsFilename = SpeechVoiceSpeakFlags.IsFilename;
pub const SVSFIsXML = SpeechVoiceSpeakFlags.IsXML;
pub const SVSFIsNotXML = SpeechVoiceSpeakFlags.IsNotXML;
pub const SVSFPersistXML = SpeechVoiceSpeakFlags.PersistXML;
pub const SVSFNLPSpeakPunc = SpeechVoiceSpeakFlags.NLPSpeakPunc;
pub const SVSFParseSapi = SpeechVoiceSpeakFlags.ParseSapi;
pub const SVSFParseSsml = SpeechVoiceSpeakFlags.ParseSsml;
pub const SVSFParseAutodetect = SpeechVoiceSpeakFlags.Default;
pub const SVSFNLPMask = SpeechVoiceSpeakFlags.NLPSpeakPunc;
pub const SVSFParseMask = SpeechVoiceSpeakFlags.ParseMask;
pub const SVSFVoiceMask = SpeechVoiceSpeakFlags.VoiceMask;
pub const SVSFUnusedFlags = SpeechVoiceSpeakFlags.UnusedFlags;

pub const SpeechVoiceEvents = enum(i32) {
    StartInputStream = 2,
    EndInputStream = 4,
    VoiceChange = 8,
    Bookmark = 16,
    WordBoundary = 32,
    Phoneme = 64,
    SentenceBoundary = 128,
    Viseme = 256,
    AudioLevel = 512,
    Private = 32768,
    AllEvents = 33790,
};
pub const SVEStartInputStream = SpeechVoiceEvents.StartInputStream;
pub const SVEEndInputStream = SpeechVoiceEvents.EndInputStream;
pub const SVEVoiceChange = SpeechVoiceEvents.VoiceChange;
pub const SVEBookmark = SpeechVoiceEvents.Bookmark;
pub const SVEWordBoundary = SpeechVoiceEvents.WordBoundary;
pub const SVEPhoneme = SpeechVoiceEvents.Phoneme;
pub const SVESentenceBoundary = SpeechVoiceEvents.SentenceBoundary;
pub const SVEViseme = SpeechVoiceEvents.Viseme;
pub const SVEAudioLevel = SpeechVoiceEvents.AudioLevel;
pub const SVEPrivate = SpeechVoiceEvents.Private;
pub const SVEAllEvents = SpeechVoiceEvents.AllEvents;

pub const DISPID_SpeechVoiceStatus = enum(i32) {
    CurrentStreamNumber = 1,
    LastStreamNumberQueued = 2,
    LastResult = 3,
    RunningState = 4,
    InputWordPosition = 5,
    InputWordLength = 6,
    InputSentencePosition = 7,
    InputSentenceLength = 8,
    LastBookmark = 9,
    LastBookmarkId = 10,
    PhonemeId = 11,
    VisemeId = 12,
};
pub const DISPID_SVSCurrentStreamNumber = DISPID_SpeechVoiceStatus.CurrentStreamNumber;
pub const DISPID_SVSLastStreamNumberQueued = DISPID_SpeechVoiceStatus.LastStreamNumberQueued;
pub const DISPID_SVSLastResult = DISPID_SpeechVoiceStatus.LastResult;
pub const DISPID_SVSRunningState = DISPID_SpeechVoiceStatus.RunningState;
pub const DISPID_SVSInputWordPosition = DISPID_SpeechVoiceStatus.InputWordPosition;
pub const DISPID_SVSInputWordLength = DISPID_SpeechVoiceStatus.InputWordLength;
pub const DISPID_SVSInputSentencePosition = DISPID_SpeechVoiceStatus.InputSentencePosition;
pub const DISPID_SVSInputSentenceLength = DISPID_SpeechVoiceStatus.InputSentenceLength;
pub const DISPID_SVSLastBookmark = DISPID_SpeechVoiceStatus.LastBookmark;
pub const DISPID_SVSLastBookmarkId = DISPID_SpeechVoiceStatus.LastBookmarkId;
pub const DISPID_SVSPhonemeId = DISPID_SpeechVoiceStatus.PhonemeId;
pub const DISPID_SVSVisemeId = DISPID_SpeechVoiceStatus.VisemeId;

pub const SpeechRunState = enum(i32) {
    Done = 1,
    IsSpeaking = 2,
};
pub const SRSEDone = SpeechRunState.Done;
pub const SRSEIsSpeaking = SpeechRunState.IsSpeaking;

pub const SpeechVisemeType = enum(i32) {
    @"0" = 0,
    @"1" = 1,
    @"2" = 2,
    @"3" = 3,
    @"4" = 4,
    @"5" = 5,
    @"6" = 6,
    @"7" = 7,
    @"8" = 8,
    @"9" = 9,
    @"10" = 10,
    @"11" = 11,
    @"12" = 12,
    @"13" = 13,
    @"14" = 14,
    @"15" = 15,
    @"16" = 16,
    @"17" = 17,
    @"18" = 18,
    @"19" = 19,
    @"20" = 20,
    @"21" = 21,
};
pub const SVP_0 = SpeechVisemeType.@"0";
pub const SVP_1 = SpeechVisemeType.@"1";
pub const SVP_2 = SpeechVisemeType.@"2";
pub const SVP_3 = SpeechVisemeType.@"3";
pub const SVP_4 = SpeechVisemeType.@"4";
pub const SVP_5 = SpeechVisemeType.@"5";
pub const SVP_6 = SpeechVisemeType.@"6";
pub const SVP_7 = SpeechVisemeType.@"7";
pub const SVP_8 = SpeechVisemeType.@"8";
pub const SVP_9 = SpeechVisemeType.@"9";
pub const SVP_10 = SpeechVisemeType.@"10";
pub const SVP_11 = SpeechVisemeType.@"11";
pub const SVP_12 = SpeechVisemeType.@"12";
pub const SVP_13 = SpeechVisemeType.@"13";
pub const SVP_14 = SpeechVisemeType.@"14";
pub const SVP_15 = SpeechVisemeType.@"15";
pub const SVP_16 = SpeechVisemeType.@"16";
pub const SVP_17 = SpeechVisemeType.@"17";
pub const SVP_18 = SpeechVisemeType.@"18";
pub const SVP_19 = SpeechVisemeType.@"19";
pub const SVP_20 = SpeechVisemeType.@"20";
pub const SVP_21 = SpeechVisemeType.@"21";

pub const SpeechVisemeFeature = enum(i32) {
    None = 0,
    Stressed = 1,
    Emphasis = 2,
};
pub const SVF_None = SpeechVisemeFeature.None;
pub const SVF_Stressed = SpeechVisemeFeature.Stressed;
pub const SVF_Emphasis = SpeechVisemeFeature.Emphasis;

pub const DISPID_SpeechVoiceEvent = enum(i32) {
    StreamStart = 1,
    StreamEnd = 2,
    VoiceChange = 3,
    Bookmark = 4,
    Word = 5,
    Phoneme = 6,
    SentenceBoundary = 7,
    Viseme = 8,
    AudioLevel = 9,
    EnginePrivate = 10,
};
pub const DISPID_SVEStreamStart = DISPID_SpeechVoiceEvent.StreamStart;
pub const DISPID_SVEStreamEnd = DISPID_SpeechVoiceEvent.StreamEnd;
pub const DISPID_SVEVoiceChange = DISPID_SpeechVoiceEvent.VoiceChange;
pub const DISPID_SVEBookmark = DISPID_SpeechVoiceEvent.Bookmark;
pub const DISPID_SVEWord = DISPID_SpeechVoiceEvent.Word;
pub const DISPID_SVEPhoneme = DISPID_SpeechVoiceEvent.Phoneme;
pub const DISPID_SVESentenceBoundary = DISPID_SpeechVoiceEvent.SentenceBoundary;
pub const DISPID_SVEViseme = DISPID_SpeechVoiceEvent.Viseme;
pub const DISPID_SVEAudioLevel = DISPID_SpeechVoiceEvent.AudioLevel;
pub const DISPID_SVEEnginePrivate = DISPID_SpeechVoiceEvent.EnginePrivate;

pub const DISPID_SpeechRecognizer = enum(i32) {
    RRecognizer = 1,
    RAllowAudioInputFormatChangesOnNextSet = 2,
    RAudioInput = 3,
    RAudioInputStream = 4,
    RIsShared = 5,
    RState = 6,
    RStatus = 7,
    RProfile = 8,
    REmulateRecognition = 9,
    RCreateRecoContext = 10,
    RGetFormat = 11,
    RSetPropertyNumber = 12,
    RGetPropertyNumber = 13,
    RSetPropertyString = 14,
    RGetPropertyString = 15,
    RIsUISupported = 16,
    RDisplayUI = 17,
    RGetRecognizers = 18,
    VGetAudioInputs = 19,
    VGetProfiles = 20,
};
pub const DISPID_SRRecognizer = DISPID_SpeechRecognizer.RRecognizer;
pub const DISPID_SRAllowAudioInputFormatChangesOnNextSet = DISPID_SpeechRecognizer.RAllowAudioInputFormatChangesOnNextSet;
pub const DISPID_SRAudioInput = DISPID_SpeechRecognizer.RAudioInput;
pub const DISPID_SRAudioInputStream = DISPID_SpeechRecognizer.RAudioInputStream;
pub const DISPID_SRIsShared = DISPID_SpeechRecognizer.RIsShared;
pub const DISPID_SRState = DISPID_SpeechRecognizer.RState;
pub const DISPID_SRStatus = DISPID_SpeechRecognizer.RStatus;
pub const DISPID_SRProfile = DISPID_SpeechRecognizer.RProfile;
pub const DISPID_SREmulateRecognition = DISPID_SpeechRecognizer.REmulateRecognition;
pub const DISPID_SRCreateRecoContext = DISPID_SpeechRecognizer.RCreateRecoContext;
pub const DISPID_SRGetFormat = DISPID_SpeechRecognizer.RGetFormat;
pub const DISPID_SRSetPropertyNumber = DISPID_SpeechRecognizer.RSetPropertyNumber;
pub const DISPID_SRGetPropertyNumber = DISPID_SpeechRecognizer.RGetPropertyNumber;
pub const DISPID_SRSetPropertyString = DISPID_SpeechRecognizer.RSetPropertyString;
pub const DISPID_SRGetPropertyString = DISPID_SpeechRecognizer.RGetPropertyString;
pub const DISPID_SRIsUISupported = DISPID_SpeechRecognizer.RIsUISupported;
pub const DISPID_SRDisplayUI = DISPID_SpeechRecognizer.RDisplayUI;
pub const DISPID_SRGetRecognizers = DISPID_SpeechRecognizer.RGetRecognizers;
pub const DISPID_SVGetAudioInputs = DISPID_SpeechRecognizer.VGetAudioInputs;
pub const DISPID_SVGetProfiles = DISPID_SpeechRecognizer.VGetProfiles;

pub const SpeechRecognizerState = enum(i32) {
    Inactive = 0,
    Active = 1,
    ActiveAlways = 2,
    InactiveWithPurge = 3,
};
pub const SRSInactive = SpeechRecognizerState.Inactive;
pub const SRSActive = SpeechRecognizerState.Active;
pub const SRSActiveAlways = SpeechRecognizerState.ActiveAlways;
pub const SRSInactiveWithPurge = SpeechRecognizerState.InactiveWithPurge;

pub const SpeechDisplayAttributes = enum(i32) {
    No_Trailing_Space = 0,
    One_Trailing_Space = 2,
    Two_Trailing_Spaces = 4,
    Consume_Leading_Spaces = 8,
};
pub const SDA_No_Trailing_Space = SpeechDisplayAttributes.No_Trailing_Space;
pub const SDA_One_Trailing_Space = SpeechDisplayAttributes.One_Trailing_Space;
pub const SDA_Two_Trailing_Spaces = SpeechDisplayAttributes.Two_Trailing_Spaces;
pub const SDA_Consume_Leading_Spaces = SpeechDisplayAttributes.Consume_Leading_Spaces;

pub const SpeechFormatType = enum(i32) {
    Input = 0,
    SREngine = 1,
};
pub const SFTInput = SpeechFormatType.Input;
pub const SFTSREngine = SpeechFormatType.SREngine;

pub const SpeechEmulationCompareFlags = enum(i32) {
    IgnoreCase = 1,
    IgnoreKanaType = 65536,
    IgnoreWidth = 131072,
    NoSpecialChars = 536870912,
    EmulateResult = 1073741824,
    Default = 196609,
};
pub const SECFIgnoreCase = SpeechEmulationCompareFlags.IgnoreCase;
pub const SECFIgnoreKanaType = SpeechEmulationCompareFlags.IgnoreKanaType;
pub const SECFIgnoreWidth = SpeechEmulationCompareFlags.IgnoreWidth;
pub const SECFNoSpecialChars = SpeechEmulationCompareFlags.NoSpecialChars;
pub const SECFEmulateResult = SpeechEmulationCompareFlags.EmulateResult;
pub const SECFDefault = SpeechEmulationCompareFlags.Default;

pub const DISPID_SpeechRecognizerStatus = enum(i32) {
    AudioStatus = 1,
    CurrentStreamPosition = 2,
    CurrentStreamNumber = 3,
    NumberOfActiveRules = 4,
    ClsidEngine = 5,
    SupportedLanguages = 6,
};
pub const DISPID_SRSAudioStatus = DISPID_SpeechRecognizerStatus.AudioStatus;
pub const DISPID_SRSCurrentStreamPosition = DISPID_SpeechRecognizerStatus.CurrentStreamPosition;
pub const DISPID_SRSCurrentStreamNumber = DISPID_SpeechRecognizerStatus.CurrentStreamNumber;
pub const DISPID_SRSNumberOfActiveRules = DISPID_SpeechRecognizerStatus.NumberOfActiveRules;
pub const DISPID_SRSClsidEngine = DISPID_SpeechRecognizerStatus.ClsidEngine;
pub const DISPID_SRSSupportedLanguages = DISPID_SpeechRecognizerStatus.SupportedLanguages;

pub const DISPID_SpeechRecoContext = enum(i32) {
    CRecognizer = 1,
    CAudioInInterferenceStatus = 2,
    CRequestedUIType = 3,
    CVoice = 4,
    AllowVoiceFormatMatchingOnNextSet = 5,
    CVoicePurgeEvent = 6,
    CEventInterests = 7,
    CCmdMaxAlternates = 8,
    CState = 9,
    CRetainedAudio = 10,
    CRetainedAudioFormat = 11,
    CPause = 12,
    CResume = 13,
    CCreateGrammar = 14,
    CCreateResultFromMemory = 15,
    CBookmark = 16,
    CSetAdaptationData = 17,
};
pub const DISPID_SRCRecognizer = DISPID_SpeechRecoContext.CRecognizer;
pub const DISPID_SRCAudioInInterferenceStatus = DISPID_SpeechRecoContext.CAudioInInterferenceStatus;
pub const DISPID_SRCRequestedUIType = DISPID_SpeechRecoContext.CRequestedUIType;
pub const DISPID_SRCVoice = DISPID_SpeechRecoContext.CVoice;
pub const DISPID_SRAllowVoiceFormatMatchingOnNextSet = DISPID_SpeechRecoContext.AllowVoiceFormatMatchingOnNextSet;
pub const DISPID_SRCVoicePurgeEvent = DISPID_SpeechRecoContext.CVoicePurgeEvent;
pub const DISPID_SRCEventInterests = DISPID_SpeechRecoContext.CEventInterests;
pub const DISPID_SRCCmdMaxAlternates = DISPID_SpeechRecoContext.CCmdMaxAlternates;
pub const DISPID_SRCState = DISPID_SpeechRecoContext.CState;
pub const DISPID_SRCRetainedAudio = DISPID_SpeechRecoContext.CRetainedAudio;
pub const DISPID_SRCRetainedAudioFormat = DISPID_SpeechRecoContext.CRetainedAudioFormat;
pub const DISPID_SRCPause = DISPID_SpeechRecoContext.CPause;
pub const DISPID_SRCResume = DISPID_SpeechRecoContext.CResume;
pub const DISPID_SRCCreateGrammar = DISPID_SpeechRecoContext.CCreateGrammar;
pub const DISPID_SRCCreateResultFromMemory = DISPID_SpeechRecoContext.CCreateResultFromMemory;
pub const DISPID_SRCBookmark = DISPID_SpeechRecoContext.CBookmark;
pub const DISPID_SRCSetAdaptationData = DISPID_SpeechRecoContext.CSetAdaptationData;

pub const SpeechRetainedAudioOptions = enum(i32) {
    None = 0,
    RetainAudio = 1,
};
pub const SRAONone = SpeechRetainedAudioOptions.None;
pub const SRAORetainAudio = SpeechRetainedAudioOptions.RetainAudio;

pub const SpeechBookmarkOptions = enum(i32) {
    None = 0,
    Pause = 1,
};
pub const SBONone = SpeechBookmarkOptions.None;
pub const SBOPause = SpeechBookmarkOptions.Pause;

pub const SpeechInterference = enum(i32) {
    None = 0,
    Noise = 1,
    NoSignal = 2,
    TooLoud = 3,
    TooQuiet = 4,
    TooFast = 5,
    TooSlow = 6,
};
pub const SINone = SpeechInterference.None;
pub const SINoise = SpeechInterference.Noise;
pub const SINoSignal = SpeechInterference.NoSignal;
pub const SITooLoud = SpeechInterference.TooLoud;
pub const SITooQuiet = SpeechInterference.TooQuiet;
pub const SITooFast = SpeechInterference.TooFast;
pub const SITooSlow = SpeechInterference.TooSlow;

pub const SpeechRecoEvents = enum(i32) {
    StreamEnd = 1,
    SoundStart = 2,
    SoundEnd = 4,
    PhraseStart = 8,
    Recognition = 16,
    Hypothesis = 32,
    Bookmark = 64,
    PropertyNumChange = 128,
    PropertyStringChange = 256,
    FalseRecognition = 512,
    Interference = 1024,
    RequestUI = 2048,
    StateChange = 4096,
    Adaptation = 8192,
    StreamStart = 16384,
    RecoOtherContext = 32768,
    AudioLevel = 65536,
    Private = 262144,
    AllEvents = 393215,
};
pub const SREStreamEnd = SpeechRecoEvents.StreamEnd;
pub const SRESoundStart = SpeechRecoEvents.SoundStart;
pub const SRESoundEnd = SpeechRecoEvents.SoundEnd;
pub const SREPhraseStart = SpeechRecoEvents.PhraseStart;
pub const SRERecognition = SpeechRecoEvents.Recognition;
pub const SREHypothesis = SpeechRecoEvents.Hypothesis;
pub const SREBookmark = SpeechRecoEvents.Bookmark;
pub const SREPropertyNumChange = SpeechRecoEvents.PropertyNumChange;
pub const SREPropertyStringChange = SpeechRecoEvents.PropertyStringChange;
pub const SREFalseRecognition = SpeechRecoEvents.FalseRecognition;
pub const SREInterference = SpeechRecoEvents.Interference;
pub const SRERequestUI = SpeechRecoEvents.RequestUI;
pub const SREStateChange = SpeechRecoEvents.StateChange;
pub const SREAdaptation = SpeechRecoEvents.Adaptation;
pub const SREStreamStart = SpeechRecoEvents.StreamStart;
pub const SRERecoOtherContext = SpeechRecoEvents.RecoOtherContext;
pub const SREAudioLevel = SpeechRecoEvents.AudioLevel;
pub const SREPrivate = SpeechRecoEvents.Private;
pub const SREAllEvents = SpeechRecoEvents.AllEvents;

pub const SpeechRecoContextState = enum(i32) {
    Disabled = 0,
    Enabled = 1,
};
pub const SRCS_Disabled = SpeechRecoContextState.Disabled;
pub const SRCS_Enabled = SpeechRecoContextState.Enabled;

pub const DISPIDSPRG = enum(i32) {
    Id = 1,
    RecoContext = 2,
    State = 3,
    Rules = 4,
    Reset = 5,
    Commit = 6,
    CmdLoadFromFile = 7,
    CmdLoadFromObject = 8,
    CmdLoadFromResource = 9,
    CmdLoadFromMemory = 10,
    CmdLoadFromProprietaryGrammar = 11,
    CmdSetRuleState = 12,
    CmdSetRuleIdState = 13,
    DictationLoad = 14,
    DictationUnload = 15,
    DictationSetState = 16,
    SetWordSequenceData = 17,
    SetTextSelection = 18,
    IsPronounceable = 19,
};
pub const DISPID_SRGId = DISPIDSPRG.Id;
pub const DISPID_SRGRecoContext = DISPIDSPRG.RecoContext;
pub const DISPID_SRGState = DISPIDSPRG.State;
pub const DISPID_SRGRules = DISPIDSPRG.Rules;
pub const DISPID_SRGReset = DISPIDSPRG.Reset;
pub const DISPID_SRGCommit = DISPIDSPRG.Commit;
pub const DISPID_SRGCmdLoadFromFile = DISPIDSPRG.CmdLoadFromFile;
pub const DISPID_SRGCmdLoadFromObject = DISPIDSPRG.CmdLoadFromObject;
pub const DISPID_SRGCmdLoadFromResource = DISPIDSPRG.CmdLoadFromResource;
pub const DISPID_SRGCmdLoadFromMemory = DISPIDSPRG.CmdLoadFromMemory;
pub const DISPID_SRGCmdLoadFromProprietaryGrammar = DISPIDSPRG.CmdLoadFromProprietaryGrammar;
pub const DISPID_SRGCmdSetRuleState = DISPIDSPRG.CmdSetRuleState;
pub const DISPID_SRGCmdSetRuleIdState = DISPIDSPRG.CmdSetRuleIdState;
pub const DISPID_SRGDictationLoad = DISPIDSPRG.DictationLoad;
pub const DISPID_SRGDictationUnload = DISPIDSPRG.DictationUnload;
pub const DISPID_SRGDictationSetState = DISPIDSPRG.DictationSetState;
pub const DISPID_SRGSetWordSequenceData = DISPIDSPRG.SetWordSequenceData;
pub const DISPID_SRGSetTextSelection = DISPIDSPRG.SetTextSelection;
pub const DISPID_SRGIsPronounceable = DISPIDSPRG.IsPronounceable;

pub const SpeechLoadOption = enum(i32) {
    Static = 0,
    Dynamic = 1,
};
pub const SLOStatic = SpeechLoadOption.Static;
pub const SLODynamic = SpeechLoadOption.Dynamic;

pub const SpeechWordPronounceable = enum(i32) {
    UnknownWordUnpronounceable = 0,
    UnknownWordPronounceable = 1,
    KnownWordPronounceable = 2,
};
pub const SWPUnknownWordUnpronounceable = SpeechWordPronounceable.UnknownWordUnpronounceable;
pub const SWPUnknownWordPronounceable = SpeechWordPronounceable.UnknownWordPronounceable;
pub const SWPKnownWordPronounceable = SpeechWordPronounceable.KnownWordPronounceable;

pub const SpeechGrammarState = enum(i32) {
    Enabled = 1,
    Disabled = 0,
    Exclusive = 3,
};
pub const SGSEnabled = SpeechGrammarState.Enabled;
pub const SGSDisabled = SpeechGrammarState.Disabled;
pub const SGSExclusive = SpeechGrammarState.Exclusive;

pub const SpeechRuleState = enum(i32) {
    Inactive = 0,
    Active = 1,
    ActiveWithAutoPause = 3,
    ActiveUserDelimited = 4,
};
pub const SGDSInactive = SpeechRuleState.Inactive;
pub const SGDSActive = SpeechRuleState.Active;
pub const SGDSActiveWithAutoPause = SpeechRuleState.ActiveWithAutoPause;
pub const SGDSActiveUserDelimited = SpeechRuleState.ActiveUserDelimited;

pub const SpeechRuleAttributes = enum(i32) {
    TopLevel = 1,
    DefaultToActive = 2,
    Export = 4,
    Import = 8,
    Interpreter = 16,
    Dynamic = 32,
    Root = 64,
};
pub const SRATopLevel = SpeechRuleAttributes.TopLevel;
pub const SRADefaultToActive = SpeechRuleAttributes.DefaultToActive;
pub const SRAExport = SpeechRuleAttributes.Export;
pub const SRAImport = SpeechRuleAttributes.Import;
pub const SRAInterpreter = SpeechRuleAttributes.Interpreter;
pub const SRADynamic = SpeechRuleAttributes.Dynamic;
pub const SRARoot = SpeechRuleAttributes.Root;

pub const SpeechGrammarWordType = enum(i32) {
    Display = 0,
    Lexical = 1,
    Pronounciation = 2,
    LexicalNoSpecialChars = 3,
};
pub const SGDisplay = SpeechGrammarWordType.Display;
pub const SGLexical = SpeechGrammarWordType.Lexical;
pub const SGPronounciation = SpeechGrammarWordType.Pronounciation;
pub const SGLexicalNoSpecialChars = SpeechGrammarWordType.LexicalNoSpecialChars;

pub const DISPID_SpeechRecoContextEvents = enum(i32) {
    StartStream = 1,
    EndStream = 2,
    Bookmark = 3,
    SoundStart = 4,
    SoundEnd = 5,
    PhraseStart = 6,
    Recognition = 7,
    Hypothesis = 8,
    PropertyNumberChange = 9,
    PropertyStringChange = 10,
    FalseRecognition = 11,
    Interference = 12,
    RequestUI = 13,
    RecognizerStateChange = 14,
    Adaptation = 15,
    RecognitionForOtherContext = 16,
    AudioLevel = 17,
    EnginePrivate = 18,
};
pub const DISPID_SRCEStartStream = DISPID_SpeechRecoContextEvents.StartStream;
pub const DISPID_SRCEEndStream = DISPID_SpeechRecoContextEvents.EndStream;
pub const DISPID_SRCEBookmark = DISPID_SpeechRecoContextEvents.Bookmark;
pub const DISPID_SRCESoundStart = DISPID_SpeechRecoContextEvents.SoundStart;
pub const DISPID_SRCESoundEnd = DISPID_SpeechRecoContextEvents.SoundEnd;
pub const DISPID_SRCEPhraseStart = DISPID_SpeechRecoContextEvents.PhraseStart;
pub const DISPID_SRCERecognition = DISPID_SpeechRecoContextEvents.Recognition;
pub const DISPID_SRCEHypothesis = DISPID_SpeechRecoContextEvents.Hypothesis;
pub const DISPID_SRCEPropertyNumberChange = DISPID_SpeechRecoContextEvents.PropertyNumberChange;
pub const DISPID_SRCEPropertyStringChange = DISPID_SpeechRecoContextEvents.PropertyStringChange;
pub const DISPID_SRCEFalseRecognition = DISPID_SpeechRecoContextEvents.FalseRecognition;
pub const DISPID_SRCEInterference = DISPID_SpeechRecoContextEvents.Interference;
pub const DISPID_SRCERequestUI = DISPID_SpeechRecoContextEvents.RequestUI;
pub const DISPID_SRCERecognizerStateChange = DISPID_SpeechRecoContextEvents.RecognizerStateChange;
pub const DISPID_SRCEAdaptation = DISPID_SpeechRecoContextEvents.Adaptation;
pub const DISPID_SRCERecognitionForOtherContext = DISPID_SpeechRecoContextEvents.RecognitionForOtherContext;
pub const DISPID_SRCEAudioLevel = DISPID_SpeechRecoContextEvents.AudioLevel;
pub const DISPID_SRCEEnginePrivate = DISPID_SpeechRecoContextEvents.EnginePrivate;

pub const SpeechRecognitionType = enum(i32) {
    Standard = 0,
    Autopause = 1,
    Emulated = 2,
    SMLTimeout = 4,
    ExtendableParse = 8,
    ReSent = 16,
};
pub const SRTStandard = SpeechRecognitionType.Standard;
pub const SRTAutopause = SpeechRecognitionType.Autopause;
pub const SRTEmulated = SpeechRecognitionType.Emulated;
pub const SRTSMLTimeout = SpeechRecognitionType.SMLTimeout;
pub const SRTExtendableParse = SpeechRecognitionType.ExtendableParse;
pub const SRTReSent = SpeechRecognitionType.ReSent;

pub const DISPID_SpeechGrammarRule = enum(i32) {
    Attributes = 1,
    InitialState = 2,
    Name = 3,
    Id = 4,
    Clear = 5,
    AddResource = 6,
    AddState = 7,
};
pub const DISPID_SGRAttributes = DISPID_SpeechGrammarRule.Attributes;
pub const DISPID_SGRInitialState = DISPID_SpeechGrammarRule.InitialState;
pub const DISPID_SGRName = DISPID_SpeechGrammarRule.Name;
pub const DISPID_SGRId = DISPID_SpeechGrammarRule.Id;
pub const DISPID_SGRClear = DISPID_SpeechGrammarRule.Clear;
pub const DISPID_SGRAddResource = DISPID_SpeechGrammarRule.AddResource;
pub const DISPID_SGRAddState = DISPID_SpeechGrammarRule.AddState;

pub const DISPID_SpeechGrammarRules = enum(i32) {
    Count = 1,
    Dynamic = 2,
    Add = 3,
    Commit = 4,
    CommitAndSave = 5,
    FindRule = 6,
    Item = 0,
    _NewEnum = -4,
};
pub const DISPID_SGRsCount = DISPID_SpeechGrammarRules.Count;
pub const DISPID_SGRsDynamic = DISPID_SpeechGrammarRules.Dynamic;
pub const DISPID_SGRsAdd = DISPID_SpeechGrammarRules.Add;
pub const DISPID_SGRsCommit = DISPID_SpeechGrammarRules.Commit;
pub const DISPID_SGRsCommitAndSave = DISPID_SpeechGrammarRules.CommitAndSave;
pub const DISPID_SGRsFindRule = DISPID_SpeechGrammarRules.FindRule;
pub const DISPID_SGRsItem = DISPID_SpeechGrammarRules.Item;
pub const DISPID_SGRs_NewEnum = DISPID_SpeechGrammarRules._NewEnum;

pub const DISPID_SpeechGrammarRuleState = enum(i32) {
    Rule = 1,
    Transitions = 2,
    AddWordTransition = 3,
    AddRuleTransition = 4,
    AddSpecialTransition = 5,
};
pub const DISPID_SGRSRule = DISPID_SpeechGrammarRuleState.Rule;
pub const DISPID_SGRSTransitions = DISPID_SpeechGrammarRuleState.Transitions;
pub const DISPID_SGRSAddWordTransition = DISPID_SpeechGrammarRuleState.AddWordTransition;
pub const DISPID_SGRSAddRuleTransition = DISPID_SpeechGrammarRuleState.AddRuleTransition;
pub const DISPID_SGRSAddSpecialTransition = DISPID_SpeechGrammarRuleState.AddSpecialTransition;

pub const SpeechSpecialTransitionType = enum(i32) {
    Wildcard = 1,
    Dictation = 2,
    TextBuffer = 3,
};
pub const SSTTWildcard = SpeechSpecialTransitionType.Wildcard;
pub const SSTTDictation = SpeechSpecialTransitionType.Dictation;
pub const SSTTTextBuffer = SpeechSpecialTransitionType.TextBuffer;

pub const DISPID_SpeechGrammarRuleStateTransitions = enum(i32) {
    Count = 1,
    Item = 0,
    _NewEnum = -4,
};
pub const DISPID_SGRSTsCount = DISPID_SpeechGrammarRuleStateTransitions.Count;
pub const DISPID_SGRSTsItem = DISPID_SpeechGrammarRuleStateTransitions.Item;
pub const DISPID_SGRSTs_NewEnum = DISPID_SpeechGrammarRuleStateTransitions._NewEnum;

pub const DISPID_SpeechGrammarRuleStateTransition = enum(i32) {
    Type = 1,
    Text = 2,
    Rule = 3,
    Weight = 4,
    PropertyName = 5,
    PropertyId = 6,
    PropertyValue = 7,
    NextState = 8,
};
pub const DISPID_SGRSTType = DISPID_SpeechGrammarRuleStateTransition.Type;
pub const DISPID_SGRSTText = DISPID_SpeechGrammarRuleStateTransition.Text;
pub const DISPID_SGRSTRule = DISPID_SpeechGrammarRuleStateTransition.Rule;
pub const DISPID_SGRSTWeight = DISPID_SpeechGrammarRuleStateTransition.Weight;
pub const DISPID_SGRSTPropertyName = DISPID_SpeechGrammarRuleStateTransition.PropertyName;
pub const DISPID_SGRSTPropertyId = DISPID_SpeechGrammarRuleStateTransition.PropertyId;
pub const DISPID_SGRSTPropertyValue = DISPID_SpeechGrammarRuleStateTransition.PropertyValue;
pub const DISPID_SGRSTNextState = DISPID_SpeechGrammarRuleStateTransition.NextState;

pub const SpeechGrammarRuleStateTransitionType = enum(i32) {
    Epsilon = 0,
    Word = 1,
    Rule = 2,
    Dictation = 3,
    Wildcard = 4,
    TextBuffer = 5,
};
pub const SGRSTTEpsilon = SpeechGrammarRuleStateTransitionType.Epsilon;
pub const SGRSTTWord = SpeechGrammarRuleStateTransitionType.Word;
pub const SGRSTTRule = SpeechGrammarRuleStateTransitionType.Rule;
pub const SGRSTTDictation = SpeechGrammarRuleStateTransitionType.Dictation;
pub const SGRSTTWildcard = SpeechGrammarRuleStateTransitionType.Wildcard;
pub const SGRSTTTextBuffer = SpeechGrammarRuleStateTransitionType.TextBuffer;

pub const DISPIDSPTSI = enum(i32) {
    ActiveOffset = 1,
    ActiveLength = 2,
    SelectionOffset = 3,
    SelectionLength = 4,
};
pub const DISPIDSPTSI_ActiveOffset = DISPIDSPTSI.ActiveOffset;
pub const DISPIDSPTSI_ActiveLength = DISPIDSPTSI.ActiveLength;
pub const DISPIDSPTSI_SelectionOffset = DISPIDSPTSI.SelectionOffset;
pub const DISPIDSPTSI_SelectionLength = DISPIDSPTSI.SelectionLength;

pub const DISPID_SpeechRecoResult = enum(i32) {
    RecoContext = 1,
    Times = 2,
    AudioFormat = 3,
    PhraseInfo = 4,
    Alternates = 5,
    Audio = 6,
    SpeakAudio = 7,
    SaveToMemory = 8,
    DiscardResultInfo = 9,
};
pub const DISPID_SRRRecoContext = DISPID_SpeechRecoResult.RecoContext;
pub const DISPID_SRRTimes = DISPID_SpeechRecoResult.Times;
pub const DISPID_SRRAudioFormat = DISPID_SpeechRecoResult.AudioFormat;
pub const DISPID_SRRPhraseInfo = DISPID_SpeechRecoResult.PhraseInfo;
pub const DISPID_SRRAlternates = DISPID_SpeechRecoResult.Alternates;
pub const DISPID_SRRAudio = DISPID_SpeechRecoResult.Audio;
pub const DISPID_SRRSpeakAudio = DISPID_SpeechRecoResult.SpeakAudio;
pub const DISPID_SRRSaveToMemory = DISPID_SpeechRecoResult.SaveToMemory;
pub const DISPID_SRRDiscardResultInfo = DISPID_SpeechRecoResult.DiscardResultInfo;

pub const SpeechDiscardType = enum(i32) {
    Property = 1,
    Replacement = 2,
    Rule = 4,
    DisplayText = 8,
    LexicalForm = 16,
    Pronunciation = 32,
    Audio = 64,
    Alternates = 128,
    All = 255,
};
pub const SDTProperty = SpeechDiscardType.Property;
pub const SDTReplacement = SpeechDiscardType.Replacement;
pub const SDTRule = SpeechDiscardType.Rule;
pub const SDTDisplayText = SpeechDiscardType.DisplayText;
pub const SDTLexicalForm = SpeechDiscardType.LexicalForm;
pub const SDTPronunciation = SpeechDiscardType.Pronunciation;
pub const SDTAudio = SpeechDiscardType.Audio;
pub const SDTAlternates = SpeechDiscardType.Alternates;
pub const SDTAll = SpeechDiscardType.All;

pub const DISPID_SpeechXMLRecoResult = enum(i32) {
    Result = 10,
    ErrorInfo = 11,
};
pub const DISPID_SRRGetXMLResult = DISPID_SpeechXMLRecoResult.Result;
pub const DISPID_SRRGetXMLErrorInfo = DISPID_SpeechXMLRecoResult.ErrorInfo;

pub const DISPID_SpeechRecoResult2 = enum(i32) {
    k = 12,
};
pub const DISPID_SRRSetTextFeedback = DISPID_SpeechRecoResult2.k;

pub const DISPID_SpeechPhraseBuilder = enum(i32) {
    y = 1,
};
pub const DISPID_SPPBRestorePhraseFromMemory = DISPID_SpeechPhraseBuilder.y;

pub const DISPID_SpeechRecoResultTimes = enum(i32) {
    StreamTime = 1,
    Length = 2,
    TickCount = 3,
    OffsetFromStart = 4,
};
pub const DISPID_SRRTStreamTime = DISPID_SpeechRecoResultTimes.StreamTime;
pub const DISPID_SRRTLength = DISPID_SpeechRecoResultTimes.Length;
pub const DISPID_SRRTTickCount = DISPID_SpeechRecoResultTimes.TickCount;
pub const DISPID_SRRTOffsetFromStart = DISPID_SpeechRecoResultTimes.OffsetFromStart;

pub const DISPID_SpeechPhraseAlternate = enum(i32) {
    RecoResult = 1,
    StartElementInResult = 2,
    NumberOfElementsInResult = 3,
    PhraseInfo = 4,
    Commit = 5,
};
pub const DISPID_SPARecoResult = DISPID_SpeechPhraseAlternate.RecoResult;
pub const DISPID_SPAStartElementInResult = DISPID_SpeechPhraseAlternate.StartElementInResult;
pub const DISPID_SPANumberOfElementsInResult = DISPID_SpeechPhraseAlternate.NumberOfElementsInResult;
pub const DISPID_SPAPhraseInfo = DISPID_SpeechPhraseAlternate.PhraseInfo;
pub const DISPID_SPACommit = DISPID_SpeechPhraseAlternate.Commit;

pub const DISPID_SpeechPhraseAlternates = enum(i32) {
    Count = 1,
    Item = 0,
    _NewEnum = -4,
};
pub const DISPID_SPAsCount = DISPID_SpeechPhraseAlternates.Count;
pub const DISPID_SPAsItem = DISPID_SpeechPhraseAlternates.Item;
pub const DISPID_SPAs_NewEnum = DISPID_SpeechPhraseAlternates._NewEnum;

pub const DISPID_SpeechPhraseInfo = enum(i32) {
    LanguageId = 1,
    GrammarId = 2,
    StartTime = 3,
    AudioStreamPosition = 4,
    AudioSizeBytes = 5,
    RetainedSizeBytes = 6,
    AudioSizeTime = 7,
    Rule = 8,
    Properties = 9,
    Elements = 10,
    Replacements = 11,
    EngineId = 12,
    EnginePrivateData = 13,
    SaveToMemory = 14,
    GetText = 15,
    GetDisplayAttributes = 16,
};
pub const DISPID_SPILanguageId = DISPID_SpeechPhraseInfo.LanguageId;
pub const DISPID_SPIGrammarId = DISPID_SpeechPhraseInfo.GrammarId;
pub const DISPID_SPIStartTime = DISPID_SpeechPhraseInfo.StartTime;
pub const DISPID_SPIAudioStreamPosition = DISPID_SpeechPhraseInfo.AudioStreamPosition;
pub const DISPID_SPIAudioSizeBytes = DISPID_SpeechPhraseInfo.AudioSizeBytes;
pub const DISPID_SPIRetainedSizeBytes = DISPID_SpeechPhraseInfo.RetainedSizeBytes;
pub const DISPID_SPIAudioSizeTime = DISPID_SpeechPhraseInfo.AudioSizeTime;
pub const DISPID_SPIRule = DISPID_SpeechPhraseInfo.Rule;
pub const DISPID_SPIProperties = DISPID_SpeechPhraseInfo.Properties;
pub const DISPID_SPIElements = DISPID_SpeechPhraseInfo.Elements;
pub const DISPID_SPIReplacements = DISPID_SpeechPhraseInfo.Replacements;
pub const DISPID_SPIEngineId = DISPID_SpeechPhraseInfo.EngineId;
pub const DISPID_SPIEnginePrivateData = DISPID_SpeechPhraseInfo.EnginePrivateData;
pub const DISPID_SPISaveToMemory = DISPID_SpeechPhraseInfo.SaveToMemory;
pub const DISPID_SPIGetText = DISPID_SpeechPhraseInfo.GetText;
pub const DISPID_SPIGetDisplayAttributes = DISPID_SpeechPhraseInfo.GetDisplayAttributes;

pub const DISPID_SpeechPhraseElement = enum(i32) {
    AudioTimeOffset = 1,
    AudioSizeTime = 2,
    AudioStreamOffset = 3,
    AudioSizeBytes = 4,
    RetainedStreamOffset = 5,
    RetainedSizeBytes = 6,
    DisplayText = 7,
    LexicalForm = 8,
    Pronunciation = 9,
    DisplayAttributes = 10,
    RequiredConfidence = 11,
    ActualConfidence = 12,
    EngineConfidence = 13,
};
pub const DISPID_SPEAudioTimeOffset = DISPID_SpeechPhraseElement.AudioTimeOffset;
pub const DISPID_SPEAudioSizeTime = DISPID_SpeechPhraseElement.AudioSizeTime;
pub const DISPID_SPEAudioStreamOffset = DISPID_SpeechPhraseElement.AudioStreamOffset;
pub const DISPID_SPEAudioSizeBytes = DISPID_SpeechPhraseElement.AudioSizeBytes;
pub const DISPID_SPERetainedStreamOffset = DISPID_SpeechPhraseElement.RetainedStreamOffset;
pub const DISPID_SPERetainedSizeBytes = DISPID_SpeechPhraseElement.RetainedSizeBytes;
pub const DISPID_SPEDisplayText = DISPID_SpeechPhraseElement.DisplayText;
pub const DISPID_SPELexicalForm = DISPID_SpeechPhraseElement.LexicalForm;
pub const DISPID_SPEPronunciation = DISPID_SpeechPhraseElement.Pronunciation;
pub const DISPID_SPEDisplayAttributes = DISPID_SpeechPhraseElement.DisplayAttributes;
pub const DISPID_SPERequiredConfidence = DISPID_SpeechPhraseElement.RequiredConfidence;
pub const DISPID_SPEActualConfidence = DISPID_SpeechPhraseElement.ActualConfidence;
pub const DISPID_SPEEngineConfidence = DISPID_SpeechPhraseElement.EngineConfidence;

pub const SpeechEngineConfidence = enum(i32) {
    LowConfidence = -1,
    NormalConfidence = 0,
    HighConfidence = 1,
};
pub const SECLowConfidence = SpeechEngineConfidence.LowConfidence;
pub const SECNormalConfidence = SpeechEngineConfidence.NormalConfidence;
pub const SECHighConfidence = SpeechEngineConfidence.HighConfidence;

pub const DISPID_SpeechPhraseElements = enum(i32) {
    Count = 1,
    Item = 0,
    _NewEnum = -4,
};
pub const DISPID_SPEsCount = DISPID_SpeechPhraseElements.Count;
pub const DISPID_SPEsItem = DISPID_SpeechPhraseElements.Item;
pub const DISPID_SPEs_NewEnum = DISPID_SpeechPhraseElements._NewEnum;

pub const DISPID_SpeechPhraseReplacement = enum(i32) {
    DisplayAttributes = 1,
    Text = 2,
    FirstElement = 3,
    NumberOfElements = 4,
};
pub const DISPID_SPRDisplayAttributes = DISPID_SpeechPhraseReplacement.DisplayAttributes;
pub const DISPID_SPRText = DISPID_SpeechPhraseReplacement.Text;
pub const DISPID_SPRFirstElement = DISPID_SpeechPhraseReplacement.FirstElement;
pub const DISPID_SPRNumberOfElements = DISPID_SpeechPhraseReplacement.NumberOfElements;

pub const DISPID_SpeechPhraseReplacements = enum(i32) {
    Count = 1,
    Item = 0,
    _NewEnum = -4,
};
pub const DISPID_SPRsCount = DISPID_SpeechPhraseReplacements.Count;
pub const DISPID_SPRsItem = DISPID_SpeechPhraseReplacements.Item;
pub const DISPID_SPRs_NewEnum = DISPID_SpeechPhraseReplacements._NewEnum;

pub const DISPID_SpeechPhraseProperty = enum(i32) {
    Name = 1,
    Id = 2,
    Value = 3,
    FirstElement = 4,
    NumberOfElements = 5,
    EngineConfidence = 6,
    Confidence = 7,
    Parent = 8,
    Children = 9,
};
pub const DISPID_SPPName = DISPID_SpeechPhraseProperty.Name;
pub const DISPID_SPPId = DISPID_SpeechPhraseProperty.Id;
pub const DISPID_SPPValue = DISPID_SpeechPhraseProperty.Value;
pub const DISPID_SPPFirstElement = DISPID_SpeechPhraseProperty.FirstElement;
pub const DISPID_SPPNumberOfElements = DISPID_SpeechPhraseProperty.NumberOfElements;
pub const DISPID_SPPEngineConfidence = DISPID_SpeechPhraseProperty.EngineConfidence;
pub const DISPID_SPPConfidence = DISPID_SpeechPhraseProperty.Confidence;
pub const DISPID_SPPParent = DISPID_SpeechPhraseProperty.Parent;
pub const DISPID_SPPChildren = DISPID_SpeechPhraseProperty.Children;

pub const DISPID_SpeechPhraseProperties = enum(i32) {
    Count = 1,
    Item = 0,
    _NewEnum = -4,
};
pub const DISPID_SPPsCount = DISPID_SpeechPhraseProperties.Count;
pub const DISPID_SPPsItem = DISPID_SpeechPhraseProperties.Item;
pub const DISPID_SPPs_NewEnum = DISPID_SpeechPhraseProperties._NewEnum;

pub const DISPID_SpeechPhraseRule = enum(i32) {
    Name = 1,
    Id = 2,
    FirstElement = 3,
    NumberOfElements = 4,
    Parent = 5,
    Children = 6,
    Confidence = 7,
    EngineConfidence = 8,
};
pub const DISPID_SPRuleName = DISPID_SpeechPhraseRule.Name;
pub const DISPID_SPRuleId = DISPID_SpeechPhraseRule.Id;
pub const DISPID_SPRuleFirstElement = DISPID_SpeechPhraseRule.FirstElement;
pub const DISPID_SPRuleNumberOfElements = DISPID_SpeechPhraseRule.NumberOfElements;
pub const DISPID_SPRuleParent = DISPID_SpeechPhraseRule.Parent;
pub const DISPID_SPRuleChildren = DISPID_SpeechPhraseRule.Children;
pub const DISPID_SPRuleConfidence = DISPID_SpeechPhraseRule.Confidence;
pub const DISPID_SPRuleEngineConfidence = DISPID_SpeechPhraseRule.EngineConfidence;

pub const DISPID_SpeechPhraseRules = enum(i32) {
    Count = 1,
    Item = 0,
    _NewEnum = -4,
};
pub const DISPID_SPRulesCount = DISPID_SpeechPhraseRules.Count;
pub const DISPID_SPRulesItem = DISPID_SpeechPhraseRules.Item;
pub const DISPID_SPRules_NewEnum = DISPID_SpeechPhraseRules._NewEnum;

pub const DISPID_SpeechLexicon = enum(i32) {
    GenerationId = 1,
    GetWords = 2,
    AddPronunciation = 3,
    AddPronunciationByPhoneIds = 4,
    RemovePronunciation = 5,
    RemovePronunciationByPhoneIds = 6,
    GetPronunciations = 7,
    GetGenerationChange = 8,
};
pub const DISPID_SLGenerationId = DISPID_SpeechLexicon.GenerationId;
pub const DISPID_SLGetWords = DISPID_SpeechLexicon.GetWords;
pub const DISPID_SLAddPronunciation = DISPID_SpeechLexicon.AddPronunciation;
pub const DISPID_SLAddPronunciationByPhoneIds = DISPID_SpeechLexicon.AddPronunciationByPhoneIds;
pub const DISPID_SLRemovePronunciation = DISPID_SpeechLexicon.RemovePronunciation;
pub const DISPID_SLRemovePronunciationByPhoneIds = DISPID_SpeechLexicon.RemovePronunciationByPhoneIds;
pub const DISPID_SLGetPronunciations = DISPID_SpeechLexicon.GetPronunciations;
pub const DISPID_SLGetGenerationChange = DISPID_SpeechLexicon.GetGenerationChange;

pub const SpeechLexiconType = enum(i32) {
    User = 1,
    App = 2,
};
pub const SLTUser = SpeechLexiconType.User;
pub const SLTApp = SpeechLexiconType.App;

pub const SpeechPartOfSpeech = enum(i32) {
    NotOverriden = -1,
    Unknown = 0,
    Noun = 4096,
    Verb = 8192,
    Modifier = 12288,
    Function = 16384,
    Interjection = 20480,
    LMA = 28672,
    SuppressWord = 61440,
};
pub const SPSNotOverriden = SpeechPartOfSpeech.NotOverriden;
pub const SPSUnknown = SpeechPartOfSpeech.Unknown;
pub const SPSNoun = SpeechPartOfSpeech.Noun;
pub const SPSVerb = SpeechPartOfSpeech.Verb;
pub const SPSModifier = SpeechPartOfSpeech.Modifier;
pub const SPSFunction = SpeechPartOfSpeech.Function;
pub const SPSInterjection = SpeechPartOfSpeech.Interjection;
pub const SPSLMA = SpeechPartOfSpeech.LMA;
pub const SPSSuppressWord = SpeechPartOfSpeech.SuppressWord;

pub const DISPID_SpeechLexiconWords = enum(i32) {
    Count = 1,
    Item = 0,
    _NewEnum = -4,
};
pub const DISPID_SLWsCount = DISPID_SpeechLexiconWords.Count;
pub const DISPID_SLWsItem = DISPID_SpeechLexiconWords.Item;
pub const DISPID_SLWs_NewEnum = DISPID_SpeechLexiconWords._NewEnum;

pub const SpeechWordType = enum(i32) {
    Added = 1,
    Deleted = 2,
};
pub const SWTAdded = SpeechWordType.Added;
pub const SWTDeleted = SpeechWordType.Deleted;

pub const DISPID_SpeechLexiconWord = enum(i32) {
    LangId = 1,
    Type = 2,
    Word = 3,
    Pronunciations = 4,
};
pub const DISPID_SLWLangId = DISPID_SpeechLexiconWord.LangId;
pub const DISPID_SLWType = DISPID_SpeechLexiconWord.Type;
pub const DISPID_SLWWord = DISPID_SpeechLexiconWord.Word;
pub const DISPID_SLWPronunciations = DISPID_SpeechLexiconWord.Pronunciations;

pub const DISPID_SpeechLexiconProns = enum(i32) {
    Count = 1,
    Item = 0,
    _NewEnum = -4,
};
pub const DISPID_SLPsCount = DISPID_SpeechLexiconProns.Count;
pub const DISPID_SLPsItem = DISPID_SpeechLexiconProns.Item;
pub const DISPID_SLPs_NewEnum = DISPID_SpeechLexiconProns._NewEnum;

pub const DISPID_SpeechLexiconPronunciation = enum(i32) {
    Type = 1,
    LangId = 2,
    PartOfSpeech = 3,
    PhoneIds = 4,
    Symbolic = 5,
};
pub const DISPID_SLPType = DISPID_SpeechLexiconPronunciation.Type;
pub const DISPID_SLPLangId = DISPID_SpeechLexiconPronunciation.LangId;
pub const DISPID_SLPPartOfSpeech = DISPID_SpeechLexiconPronunciation.PartOfSpeech;
pub const DISPID_SLPPhoneIds = DISPID_SpeechLexiconPronunciation.PhoneIds;
pub const DISPID_SLPSymbolic = DISPID_SpeechLexiconPronunciation.Symbolic;

pub const DISPID_SpeechPhoneConverter = enum(i32) {
    LangId = 1,
    PhoneToId = 2,
    IdToPhone = 3,
};
pub const DISPID_SPCLangId = DISPID_SpeechPhoneConverter.LangId;
pub const DISPID_SPCPhoneToId = DISPID_SpeechPhoneConverter.PhoneToId;
pub const DISPID_SPCIdToPhone = DISPID_SpeechPhoneConverter.IdToPhone;

const IID_ISpeechDataKey_Value = Guid.initString("ce17c09b-4efa-44d5-a4c9-59d9585ab0cd");
pub const IID_ISpeechDataKey = &IID_ISpeechDataKey_Value;
pub const ISpeechDataKey = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        SetBinaryValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechDataKey,
                ValueName: ?BSTR,
                Value: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechDataKey,
                ValueName: ?BSTR,
                Value: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBinaryValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechDataKey,
                ValueName: ?BSTR,
                Value: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechDataKey,
                ValueName: ?BSTR,
                Value: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetStringValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechDataKey,
                ValueName: ?BSTR,
                Value: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechDataKey,
                ValueName: ?BSTR,
                Value: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStringValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechDataKey,
                ValueName: ?BSTR,
                Value: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechDataKey,
                ValueName: ?BSTR,
                Value: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetLongValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechDataKey,
                ValueName: ?BSTR,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechDataKey,
                ValueName: ?BSTR,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLongValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechDataKey,
                ValueName: ?BSTR,
                Value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechDataKey,
                ValueName: ?BSTR,
                Value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenKey: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechDataKey,
                SubKeyName: ?BSTR,
                SubKey: ?*?*ISpeechDataKey,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechDataKey,
                SubKeyName: ?BSTR,
                SubKey: ?*?*ISpeechDataKey,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateKey: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechDataKey,
                SubKeyName: ?BSTR,
                SubKey: ?*?*ISpeechDataKey,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechDataKey,
                SubKeyName: ?BSTR,
                SubKey: ?*?*ISpeechDataKey,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeleteKey: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechDataKey,
                SubKeyName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechDataKey,
                SubKeyName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeleteValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechDataKey,
                ValueName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechDataKey,
                ValueName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumKeys: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechDataKey,
                Index: i32,
                SubKeyName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechDataKey,
                Index: i32,
                SubKeyName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumValues: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechDataKey,
                Index: i32,
                ValueName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechDataKey,
                Index: i32,
                ValueName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechDataKey_SetBinaryValue(self: *const T, ValueName: ?BSTR, Value: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechDataKey.VTable, self.vtable).SetBinaryValue(@ptrCast(*const ISpeechDataKey, self), ValueName, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechDataKey_GetBinaryValue(self: *const T, ValueName: ?BSTR, Value: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechDataKey.VTable, self.vtable).GetBinaryValue(@ptrCast(*const ISpeechDataKey, self), ValueName, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechDataKey_SetStringValue(self: *const T, ValueName: ?BSTR, Value: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechDataKey.VTable, self.vtable).SetStringValue(@ptrCast(*const ISpeechDataKey, self), ValueName, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechDataKey_GetStringValue(self: *const T, ValueName: ?BSTR, Value: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechDataKey.VTable, self.vtable).GetStringValue(@ptrCast(*const ISpeechDataKey, self), ValueName, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechDataKey_SetLongValue(self: *const T, ValueName: ?BSTR, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechDataKey.VTable, self.vtable).SetLongValue(@ptrCast(*const ISpeechDataKey, self), ValueName, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechDataKey_GetLongValue(self: *const T, ValueName: ?BSTR, Value: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechDataKey.VTable, self.vtable).GetLongValue(@ptrCast(*const ISpeechDataKey, self), ValueName, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechDataKey_OpenKey(self: *const T, SubKeyName: ?BSTR, SubKey: ?*?*ISpeechDataKey) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechDataKey.VTable, self.vtable).OpenKey(@ptrCast(*const ISpeechDataKey, self), SubKeyName, SubKey);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechDataKey_CreateKey(self: *const T, SubKeyName: ?BSTR, SubKey: ?*?*ISpeechDataKey) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechDataKey.VTable, self.vtable).CreateKey(@ptrCast(*const ISpeechDataKey, self), SubKeyName, SubKey);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechDataKey_DeleteKey(self: *const T, SubKeyName: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechDataKey.VTable, self.vtable).DeleteKey(@ptrCast(*const ISpeechDataKey, self), SubKeyName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechDataKey_DeleteValue(self: *const T, ValueName: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechDataKey.VTable, self.vtable).DeleteValue(@ptrCast(*const ISpeechDataKey, self), ValueName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechDataKey_EnumKeys(self: *const T, Index: i32, SubKeyName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechDataKey.VTable, self.vtable).EnumKeys(@ptrCast(*const ISpeechDataKey, self), Index, SubKeyName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechDataKey_EnumValues(self: *const T, Index: i32, ValueName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechDataKey.VTable, self.vtable).EnumValues(@ptrCast(*const ISpeechDataKey, self), Index, ValueName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechObjectToken_Value = Guid.initString("c74a3adc-b727-4500-a84a-b526721c8b8c");
pub const IID_ISpeechObjectToken = &IID_ISpeechObjectToken_Value;
pub const ISpeechObjectToken = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Id: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechObjectToken,
                ObjectId: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechObjectToken,
                ObjectId: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DataKey: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechObjectToken,
                DataKey: ?*?*ISpeechDataKey,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechObjectToken,
                DataKey: ?*?*ISpeechDataKey,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Category: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechObjectToken,
                Category: ?*?*ISpeechObjectTokenCategory,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechObjectToken,
                Category: ?*?*ISpeechObjectTokenCategory,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechObjectToken,
                Locale: i32,
                Description: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechObjectToken,
                Locale: i32,
                Description: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechObjectToken,
                Id: ?BSTR,
                CategoryID: ?BSTR,
                CreateIfNotExist: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechObjectToken,
                Id: ?BSTR,
                CategoryID: ?BSTR,
                CreateIfNotExist: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAttribute: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechObjectToken,
                AttributeName: ?BSTR,
                AttributeValue: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechObjectToken,
                AttributeName: ?BSTR,
                AttributeValue: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateInstance: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechObjectToken,
                pUnkOuter: ?*IUnknown,
                ClsContext: SpeechTokenContext,
                Object: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechObjectToken,
                pUnkOuter: ?*IUnknown,
                ClsContext: SpeechTokenContext,
                Object: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Remove: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechObjectToken,
                ObjectStorageCLSID: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechObjectToken,
                ObjectStorageCLSID: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStorageFileName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechObjectToken,
                ObjectStorageCLSID: ?BSTR,
                KeyName: ?BSTR,
                FileName: ?BSTR,
                Folder: SpeechTokenShellFolder,
                FilePath: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechObjectToken,
                ObjectStorageCLSID: ?BSTR,
                KeyName: ?BSTR,
                FileName: ?BSTR,
                Folder: SpeechTokenShellFolder,
                FilePath: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveStorageFileName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechObjectToken,
                ObjectStorageCLSID: ?BSTR,
                KeyName: ?BSTR,
                DeleteFileA: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechObjectToken,
                ObjectStorageCLSID: ?BSTR,
                KeyName: ?BSTR,
                DeleteFileA: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsUISupported: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechObjectToken,
                TypeOfUI: ?BSTR,
                ExtraData: ?*const VARIANT,
                Object: ?*IUnknown,
                Supported: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechObjectToken,
                TypeOfUI: ?BSTR,
                ExtraData: ?*const VARIANT,
                Object: ?*IUnknown,
                Supported: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DisplayUI: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechObjectToken,
                hWnd: i32,
                Title: ?BSTR,
                TypeOfUI: ?BSTR,
                ExtraData: ?*const VARIANT,
                Object: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechObjectToken,
                hWnd: i32,
                Title: ?BSTR,
                TypeOfUI: ?BSTR,
                ExtraData: ?*const VARIANT,
                Object: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        MatchesAttributes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechObjectToken,
                Attributes: ?BSTR,
                Matches: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechObjectToken,
                Attributes: ?BSTR,
                Matches: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechObjectToken_get_Id(self: *const T, ObjectId: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechObjectToken.VTable, self.vtable).get_Id(@ptrCast(*const ISpeechObjectToken, self), ObjectId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechObjectToken_get_DataKey(self: *const T, DataKey: ?*?*ISpeechDataKey) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechObjectToken.VTable, self.vtable).get_DataKey(@ptrCast(*const ISpeechObjectToken, self), DataKey);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechObjectToken_get_Category(self: *const T, Category: ?*?*ISpeechObjectTokenCategory) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechObjectToken.VTable, self.vtable).get_Category(@ptrCast(*const ISpeechObjectToken, self), Category);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechObjectToken_GetDescription(self: *const T, Locale: i32, Description: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechObjectToken.VTable, self.vtable).GetDescription(@ptrCast(*const ISpeechObjectToken, self), Locale, Description);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechObjectToken_SetId(self: *const T, Id: ?BSTR, CategoryID: ?BSTR, CreateIfNotExist: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechObjectToken.VTable, self.vtable).SetId(@ptrCast(*const ISpeechObjectToken, self), Id, CategoryID, CreateIfNotExist);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechObjectToken_GetAttribute(self: *const T, AttributeName: ?BSTR, AttributeValue: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechObjectToken.VTable, self.vtable).GetAttribute(@ptrCast(*const ISpeechObjectToken, self), AttributeName, AttributeValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechObjectToken_CreateInstance(self: *const T, pUnkOuter: ?*IUnknown, ClsContext: SpeechTokenContext, Object: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechObjectToken.VTable, self.vtable).CreateInstance(@ptrCast(*const ISpeechObjectToken, self), pUnkOuter, ClsContext, Object);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechObjectToken_Remove(self: *const T, ObjectStorageCLSID: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechObjectToken.VTable, self.vtable).Remove(@ptrCast(*const ISpeechObjectToken, self), ObjectStorageCLSID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechObjectToken_GetStorageFileName(self: *const T, ObjectStorageCLSID: ?BSTR, KeyName: ?BSTR, FileName: ?BSTR, Folder: SpeechTokenShellFolder, FilePath: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechObjectToken.VTable, self.vtable).GetStorageFileName(@ptrCast(*const ISpeechObjectToken, self), ObjectStorageCLSID, KeyName, FileName, Folder, FilePath);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechObjectToken_RemoveStorageFileName(self: *const T, ObjectStorageCLSID: ?BSTR, KeyName: ?BSTR, DeleteFileA: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechObjectToken.VTable, self.vtable).RemoveStorageFileName(@ptrCast(*const ISpeechObjectToken, self), ObjectStorageCLSID, KeyName, DeleteFileA);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechObjectToken_IsUISupported(self: *const T, TypeOfUI: ?BSTR, ExtraData: ?*const VARIANT, Object: ?*IUnknown, Supported: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechObjectToken.VTable, self.vtable).IsUISupported(@ptrCast(*const ISpeechObjectToken, self), TypeOfUI, ExtraData, Object, Supported);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechObjectToken_DisplayUI(self: *const T, hWnd: i32, Title: ?BSTR, TypeOfUI: ?BSTR, ExtraData: ?*const VARIANT, Object: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechObjectToken.VTable, self.vtable).DisplayUI(@ptrCast(*const ISpeechObjectToken, self), hWnd, Title, TypeOfUI, ExtraData, Object);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechObjectToken_MatchesAttributes(self: *const T, Attributes: ?BSTR, Matches: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechObjectToken.VTable, self.vtable).MatchesAttributes(@ptrCast(*const ISpeechObjectToken, self), Attributes, Matches);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechObjectTokens_Value = Guid.initString("9285b776-2e7b-4bc0-b53e-580eb6fa967f");
pub const IID_ISpeechObjectTokens = &IID_ISpeechObjectTokens_Value;
pub const ISpeechObjectTokens = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechObjectTokens,
                Count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechObjectTokens,
                Count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Item: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechObjectTokens,
                Index: i32,
                Token: ?*?*ISpeechObjectToken,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechObjectTokens,
                Index: i32,
                Token: ?*?*ISpeechObjectToken,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechObjectTokens,
                ppEnumVARIANT: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechObjectTokens,
                ppEnumVARIANT: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechObjectTokens_get_Count(self: *const T, Count: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechObjectTokens.VTable, self.vtable).get_Count(@ptrCast(*const ISpeechObjectTokens, self), Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechObjectTokens_Item(self: *const T, Index: i32, Token: ?*?*ISpeechObjectToken) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechObjectTokens.VTable, self.vtable).Item(@ptrCast(*const ISpeechObjectTokens, self), Index, Token);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechObjectTokens_get__NewEnum(self: *const T, ppEnumVARIANT: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechObjectTokens.VTable, self.vtable).get__NewEnum(@ptrCast(*const ISpeechObjectTokens, self), ppEnumVARIANT);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechObjectTokenCategory_Value = Guid.initString("ca7eac50-2d01-4145-86d4-5ae7d70f4469");
pub const IID_ISpeechObjectTokenCategory = &IID_ISpeechObjectTokenCategory_Value;
pub const ISpeechObjectTokenCategory = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Id: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechObjectTokenCategory,
                Id: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechObjectTokenCategory,
                Id: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Default: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechObjectTokenCategory,
                TokenId: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechObjectTokenCategory,
                TokenId: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Default: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechObjectTokenCategory,
                TokenId: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechObjectTokenCategory,
                TokenId: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechObjectTokenCategory,
                Id: ?BSTR,
                CreateIfNotExist: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechObjectTokenCategory,
                Id: ?BSTR,
                CreateIfNotExist: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDataKey: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechObjectTokenCategory,
                Location: SpeechDataKeyLocation,
                DataKey: ?*?*ISpeechDataKey,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechObjectTokenCategory,
                Location: SpeechDataKeyLocation,
                DataKey: ?*?*ISpeechDataKey,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumerateTokens: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechObjectTokenCategory,
                RequiredAttributes: ?BSTR,
                OptionalAttributes: ?BSTR,
                Tokens: ?*?*ISpeechObjectTokens,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechObjectTokenCategory,
                RequiredAttributes: ?BSTR,
                OptionalAttributes: ?BSTR,
                Tokens: ?*?*ISpeechObjectTokens,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechObjectTokenCategory_get_Id(self: *const T, Id: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechObjectTokenCategory.VTable, self.vtable).get_Id(@ptrCast(*const ISpeechObjectTokenCategory, self), Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechObjectTokenCategory_put_Default(self: *const T, TokenId: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechObjectTokenCategory.VTable, self.vtable).put_Default(@ptrCast(*const ISpeechObjectTokenCategory, self), TokenId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechObjectTokenCategory_get_Default(self: *const T, TokenId: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechObjectTokenCategory.VTable, self.vtable).get_Default(@ptrCast(*const ISpeechObjectTokenCategory, self), TokenId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechObjectTokenCategory_SetId(self: *const T, Id: ?BSTR, CreateIfNotExist: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechObjectTokenCategory.VTable, self.vtable).SetId(@ptrCast(*const ISpeechObjectTokenCategory, self), Id, CreateIfNotExist);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechObjectTokenCategory_GetDataKey(self: *const T, Location: SpeechDataKeyLocation, DataKey: ?*?*ISpeechDataKey) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechObjectTokenCategory.VTable, self.vtable).GetDataKey(@ptrCast(*const ISpeechObjectTokenCategory, self), Location, DataKey);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechObjectTokenCategory_EnumerateTokens(self: *const T, RequiredAttributes: ?BSTR, OptionalAttributes: ?BSTR, Tokens: ?*?*ISpeechObjectTokens) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechObjectTokenCategory.VTable, self.vtable).EnumerateTokens(@ptrCast(*const ISpeechObjectTokenCategory, self), RequiredAttributes, OptionalAttributes, Tokens);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechAudioBufferInfo_Value = Guid.initString("11b103d8-1142-4edf-a093-82fb3915f8cc");
pub const IID_ISpeechAudioBufferInfo = &IID_ISpeechAudioBufferInfo_Value;
pub const ISpeechAudioBufferInfo = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MinNotification: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechAudioBufferInfo,
                MinNotification: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechAudioBufferInfo,
                MinNotification: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MinNotification: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechAudioBufferInfo,
                MinNotification: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechAudioBufferInfo,
                MinNotification: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BufferSize: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechAudioBufferInfo,
                BufferSize: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechAudioBufferInfo,
                BufferSize: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BufferSize: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechAudioBufferInfo,
                BufferSize: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechAudioBufferInfo,
                BufferSize: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EventBias: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechAudioBufferInfo,
                EventBias: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechAudioBufferInfo,
                EventBias: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_EventBias: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechAudioBufferInfo,
                EventBias: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechAudioBufferInfo,
                EventBias: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechAudioBufferInfo_get_MinNotification(self: *const T, MinNotification: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechAudioBufferInfo.VTable, self.vtable).get_MinNotification(@ptrCast(*const ISpeechAudioBufferInfo, self), MinNotification);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechAudioBufferInfo_put_MinNotification(self: *const T, MinNotification: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechAudioBufferInfo.VTable, self.vtable).put_MinNotification(@ptrCast(*const ISpeechAudioBufferInfo, self), MinNotification);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechAudioBufferInfo_get_BufferSize(self: *const T, BufferSize: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechAudioBufferInfo.VTable, self.vtable).get_BufferSize(@ptrCast(*const ISpeechAudioBufferInfo, self), BufferSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechAudioBufferInfo_put_BufferSize(self: *const T, BufferSize: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechAudioBufferInfo.VTable, self.vtable).put_BufferSize(@ptrCast(*const ISpeechAudioBufferInfo, self), BufferSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechAudioBufferInfo_get_EventBias(self: *const T, EventBias: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechAudioBufferInfo.VTable, self.vtable).get_EventBias(@ptrCast(*const ISpeechAudioBufferInfo, self), EventBias);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechAudioBufferInfo_put_EventBias(self: *const T, EventBias: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechAudioBufferInfo.VTable, self.vtable).put_EventBias(@ptrCast(*const ISpeechAudioBufferInfo, self), EventBias);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechAudioStatus_Value = Guid.initString("c62d9c91-7458-47f6-862d-1ef86fb0b278");
pub const IID_ISpeechAudioStatus = &IID_ISpeechAudioStatus_Value;
pub const ISpeechAudioStatus = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FreeBufferSpace: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechAudioStatus,
                FreeBufferSpace: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechAudioStatus,
                FreeBufferSpace: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NonBlockingIO: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechAudioStatus,
                NonBlockingIO: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechAudioStatus,
                NonBlockingIO: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_State: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechAudioStatus,
                State: ?*SpeechAudioState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechAudioStatus,
                State: ?*SpeechAudioState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentSeekPosition: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechAudioStatus,
                CurrentSeekPosition: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechAudioStatus,
                CurrentSeekPosition: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentDevicePosition: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechAudioStatus,
                CurrentDevicePosition: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechAudioStatus,
                CurrentDevicePosition: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechAudioStatus_get_FreeBufferSpace(self: *const T, FreeBufferSpace: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechAudioStatus.VTable, self.vtable).get_FreeBufferSpace(@ptrCast(*const ISpeechAudioStatus, self), FreeBufferSpace);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechAudioStatus_get_NonBlockingIO(self: *const T, NonBlockingIO: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechAudioStatus.VTable, self.vtable).get_NonBlockingIO(@ptrCast(*const ISpeechAudioStatus, self), NonBlockingIO);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechAudioStatus_get_State(self: *const T, State: ?*SpeechAudioState) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechAudioStatus.VTable, self.vtable).get_State(@ptrCast(*const ISpeechAudioStatus, self), State);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechAudioStatus_get_CurrentSeekPosition(self: *const T, CurrentSeekPosition: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechAudioStatus.VTable, self.vtable).get_CurrentSeekPosition(@ptrCast(*const ISpeechAudioStatus, self), CurrentSeekPosition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechAudioStatus_get_CurrentDevicePosition(self: *const T, CurrentDevicePosition: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechAudioStatus.VTable, self.vtable).get_CurrentDevicePosition(@ptrCast(*const ISpeechAudioStatus, self), CurrentDevicePosition);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechAudioFormat_Value = Guid.initString("e6e9c590-3e18-40e3-8299-061f98bde7c7");
pub const IID_ISpeechAudioFormat = &IID_ISpeechAudioFormat_Value;
pub const ISpeechAudioFormat = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Type: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechAudioFormat,
                AudioFormat: ?*SpeechAudioFormatType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechAudioFormat,
                AudioFormat: ?*SpeechAudioFormatType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Type: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechAudioFormat,
                AudioFormat: SpeechAudioFormatType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechAudioFormat,
                AudioFormat: SpeechAudioFormatType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Guid: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechAudioFormat,
                Guid: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechAudioFormat,
                Guid: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Guid: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechAudioFormat,
                Guid: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechAudioFormat,
                Guid: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetWaveFormatEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechAudioFormat,
                SpeechWaveFormatEx: ?*?*ISpeechWaveFormatEx,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechAudioFormat,
                SpeechWaveFormatEx: ?*?*ISpeechWaveFormatEx,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetWaveFormatEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechAudioFormat,
                SpeechWaveFormatEx: ?*ISpeechWaveFormatEx,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechAudioFormat,
                SpeechWaveFormatEx: ?*ISpeechWaveFormatEx,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechAudioFormat_get_Type(self: *const T, AudioFormat: ?*SpeechAudioFormatType) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechAudioFormat.VTable, self.vtable).get_Type(@ptrCast(*const ISpeechAudioFormat, self), AudioFormat);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechAudioFormat_put_Type(self: *const T, AudioFormat: SpeechAudioFormatType) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechAudioFormat.VTable, self.vtable).put_Type(@ptrCast(*const ISpeechAudioFormat, self), AudioFormat);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechAudioFormat_get_Guid(self: *const T, _param_Guid: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechAudioFormat.VTable, self.vtable).get_Guid(@ptrCast(*const ISpeechAudioFormat, self), _param_Guid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechAudioFormat_put_Guid(self: *const T, _param_Guid: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechAudioFormat.VTable, self.vtable).put_Guid(@ptrCast(*const ISpeechAudioFormat, self), _param_Guid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechAudioFormat_GetWaveFormatEx(self: *const T, SpeechWaveFormatEx: ?*?*ISpeechWaveFormatEx) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechAudioFormat.VTable, self.vtable).GetWaveFormatEx(@ptrCast(*const ISpeechAudioFormat, self), SpeechWaveFormatEx);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechAudioFormat_SetWaveFormatEx(self: *const T, SpeechWaveFormatEx: ?*ISpeechWaveFormatEx) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechAudioFormat.VTable, self.vtable).SetWaveFormatEx(@ptrCast(*const ISpeechAudioFormat, self), SpeechWaveFormatEx);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechWaveFormatEx_Value = Guid.initString("7a1ef0d5-1581-4741-88e4-209a49f11a10");
pub const IID_ISpeechWaveFormatEx = &IID_ISpeechWaveFormatEx_Value;
pub const ISpeechWaveFormatEx = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FormatTag: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechWaveFormatEx,
                FormatTag: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechWaveFormatEx,
                FormatTag: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_FormatTag: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechWaveFormatEx,
                FormatTag: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechWaveFormatEx,
                FormatTag: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Channels: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechWaveFormatEx,
                Channels: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechWaveFormatEx,
                Channels: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Channels: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechWaveFormatEx,
                Channels: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechWaveFormatEx,
                Channels: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SamplesPerSec: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechWaveFormatEx,
                SamplesPerSec: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechWaveFormatEx,
                SamplesPerSec: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SamplesPerSec: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechWaveFormatEx,
                SamplesPerSec: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechWaveFormatEx,
                SamplesPerSec: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AvgBytesPerSec: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechWaveFormatEx,
                AvgBytesPerSec: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechWaveFormatEx,
                AvgBytesPerSec: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AvgBytesPerSec: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechWaveFormatEx,
                AvgBytesPerSec: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechWaveFormatEx,
                AvgBytesPerSec: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BlockAlign: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechWaveFormatEx,
                BlockAlign: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechWaveFormatEx,
                BlockAlign: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BlockAlign: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechWaveFormatEx,
                BlockAlign: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechWaveFormatEx,
                BlockAlign: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BitsPerSample: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechWaveFormatEx,
                BitsPerSample: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechWaveFormatEx,
                BitsPerSample: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BitsPerSample: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechWaveFormatEx,
                BitsPerSample: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechWaveFormatEx,
                BitsPerSample: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ExtraData: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechWaveFormatEx,
                ExtraData: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechWaveFormatEx,
                ExtraData: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ExtraData: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechWaveFormatEx,
                ExtraData: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechWaveFormatEx,
                ExtraData: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechWaveFormatEx_get_FormatTag(self: *const T, FormatTag: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechWaveFormatEx.VTable, self.vtable).get_FormatTag(@ptrCast(*const ISpeechWaveFormatEx, self), FormatTag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechWaveFormatEx_put_FormatTag(self: *const T, FormatTag: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechWaveFormatEx.VTable, self.vtable).put_FormatTag(@ptrCast(*const ISpeechWaveFormatEx, self), FormatTag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechWaveFormatEx_get_Channels(self: *const T, Channels: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechWaveFormatEx.VTable, self.vtable).get_Channels(@ptrCast(*const ISpeechWaveFormatEx, self), Channels);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechWaveFormatEx_put_Channels(self: *const T, Channels: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechWaveFormatEx.VTable, self.vtable).put_Channels(@ptrCast(*const ISpeechWaveFormatEx, self), Channels);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechWaveFormatEx_get_SamplesPerSec(self: *const T, SamplesPerSec: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechWaveFormatEx.VTable, self.vtable).get_SamplesPerSec(@ptrCast(*const ISpeechWaveFormatEx, self), SamplesPerSec);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechWaveFormatEx_put_SamplesPerSec(self: *const T, SamplesPerSec: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechWaveFormatEx.VTable, self.vtable).put_SamplesPerSec(@ptrCast(*const ISpeechWaveFormatEx, self), SamplesPerSec);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechWaveFormatEx_get_AvgBytesPerSec(self: *const T, AvgBytesPerSec: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechWaveFormatEx.VTable, self.vtable).get_AvgBytesPerSec(@ptrCast(*const ISpeechWaveFormatEx, self), AvgBytesPerSec);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechWaveFormatEx_put_AvgBytesPerSec(self: *const T, AvgBytesPerSec: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechWaveFormatEx.VTable, self.vtable).put_AvgBytesPerSec(@ptrCast(*const ISpeechWaveFormatEx, self), AvgBytesPerSec);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechWaveFormatEx_get_BlockAlign(self: *const T, BlockAlign: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechWaveFormatEx.VTable, self.vtable).get_BlockAlign(@ptrCast(*const ISpeechWaveFormatEx, self), BlockAlign);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechWaveFormatEx_put_BlockAlign(self: *const T, BlockAlign: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechWaveFormatEx.VTable, self.vtable).put_BlockAlign(@ptrCast(*const ISpeechWaveFormatEx, self), BlockAlign);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechWaveFormatEx_get_BitsPerSample(self: *const T, BitsPerSample: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechWaveFormatEx.VTable, self.vtable).get_BitsPerSample(@ptrCast(*const ISpeechWaveFormatEx, self), BitsPerSample);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechWaveFormatEx_put_BitsPerSample(self: *const T, BitsPerSample: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechWaveFormatEx.VTable, self.vtable).put_BitsPerSample(@ptrCast(*const ISpeechWaveFormatEx, self), BitsPerSample);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechWaveFormatEx_get_ExtraData(self: *const T, ExtraData: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechWaveFormatEx.VTable, self.vtable).get_ExtraData(@ptrCast(*const ISpeechWaveFormatEx, self), ExtraData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechWaveFormatEx_put_ExtraData(self: *const T, ExtraData: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechWaveFormatEx.VTable, self.vtable).put_ExtraData(@ptrCast(*const ISpeechWaveFormatEx, self), ExtraData);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechBaseStream_Value = Guid.initString("6450336f-7d49-4ced-8097-49d6dee37294");
pub const IID_ISpeechBaseStream = &IID_ISpeechBaseStream_Value;
pub const ISpeechBaseStream = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Format: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechBaseStream,
                AudioFormat: ?*?*ISpeechAudioFormat,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechBaseStream,
                AudioFormat: ?*?*ISpeechAudioFormat,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        putref_Format: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechBaseStream,
                AudioFormat: ?*ISpeechAudioFormat,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechBaseStream,
                AudioFormat: ?*ISpeechAudioFormat,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Read: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechBaseStream,
                Buffer: ?*VARIANT,
                NumberOfBytes: i32,
                BytesRead: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechBaseStream,
                Buffer: ?*VARIANT,
                NumberOfBytes: i32,
                BytesRead: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Write: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechBaseStream,
                Buffer: VARIANT,
                BytesWritten: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechBaseStream,
                Buffer: VARIANT,
                BytesWritten: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Seek: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechBaseStream,
                Position: VARIANT,
                Origin: SpeechStreamSeekPositionType,
                NewPosition: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechBaseStream,
                Position: VARIANT,
                Origin: SpeechStreamSeekPositionType,
                NewPosition: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechBaseStream_get_Format(self: *const T, AudioFormat: ?*?*ISpeechAudioFormat) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechBaseStream.VTable, self.vtable).get_Format(@ptrCast(*const ISpeechBaseStream, self), AudioFormat);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechBaseStream_putref_Format(self: *const T, AudioFormat: ?*ISpeechAudioFormat) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechBaseStream.VTable, self.vtable).putref_Format(@ptrCast(*const ISpeechBaseStream, self), AudioFormat);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechBaseStream_Read(self: *const T, Buffer: ?*VARIANT, NumberOfBytes: i32, BytesRead: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechBaseStream.VTable, self.vtable).Read(@ptrCast(*const ISpeechBaseStream, self), Buffer, NumberOfBytes, BytesRead);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechBaseStream_Write(self: *const T, Buffer: VARIANT, BytesWritten: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechBaseStream.VTable, self.vtable).Write(@ptrCast(*const ISpeechBaseStream, self), Buffer, BytesWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechBaseStream_Seek(self: *const T, Position: VARIANT, Origin: SpeechStreamSeekPositionType, NewPosition: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechBaseStream.VTable, self.vtable).Seek(@ptrCast(*const ISpeechBaseStream, self), Position, Origin, NewPosition);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechFileStream_Value = Guid.initString("af67f125-ab39-4e93-b4a2-cc2e66e182a7");
pub const IID_ISpeechFileStream = &IID_ISpeechFileStream_Value;
pub const ISpeechFileStream = extern struct {
    pub const VTable = extern struct {
        base: ISpeechBaseStream.VTable,
        Open: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechFileStream,
                FileName: ?BSTR,
                FileMode: SpeechStreamFileMode,
                DoEvents: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechFileStream,
                FileName: ?BSTR,
                FileMode: SpeechStreamFileMode,
                DoEvents: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Close: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechFileStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechFileStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISpeechBaseStream.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechFileStream_Open(self: *const T, FileName: ?BSTR, FileMode: SpeechStreamFileMode, DoEvents: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechFileStream.VTable, self.vtable).Open(@ptrCast(*const ISpeechFileStream, self), FileName, FileMode, DoEvents);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechFileStream_Close(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechFileStream.VTable, self.vtable).Close(@ptrCast(*const ISpeechFileStream, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechMemoryStream_Value = Guid.initString("eeb14b68-808b-4abe-a5ea-b51da7588008");
pub const IID_ISpeechMemoryStream = &IID_ISpeechMemoryStream_Value;
pub const ISpeechMemoryStream = extern struct {
    pub const VTable = extern struct {
        base: ISpeechBaseStream.VTable,
        SetData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechMemoryStream,
                Data: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechMemoryStream,
                Data: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechMemoryStream,
                pData: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechMemoryStream,
                pData: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISpeechBaseStream.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechMemoryStream_SetData(self: *const T, Data: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechMemoryStream.VTable, self.vtable).SetData(@ptrCast(*const ISpeechMemoryStream, self), Data);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechMemoryStream_GetData(self: *const T, pData: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechMemoryStream.VTable, self.vtable).GetData(@ptrCast(*const ISpeechMemoryStream, self), pData);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechCustomStream_Value = Guid.initString("1a9e9f4f-104f-4db8-a115-efd7fd0c97ae");
pub const IID_ISpeechCustomStream = &IID_ISpeechCustomStream_Value;
pub const ISpeechCustomStream = extern struct {
    pub const VTable = extern struct {
        base: ISpeechBaseStream.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BaseStream: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechCustomStream,
                ppUnkStream: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechCustomStream,
                ppUnkStream: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        putref_BaseStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechCustomStream,
                pUnkStream: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechCustomStream,
                pUnkStream: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISpeechBaseStream.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechCustomStream_get_BaseStream(self: *const T, ppUnkStream: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechCustomStream.VTable, self.vtable).get_BaseStream(@ptrCast(*const ISpeechCustomStream, self), ppUnkStream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechCustomStream_putref_BaseStream(self: *const T, pUnkStream: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechCustomStream.VTable, self.vtable).putref_BaseStream(@ptrCast(*const ISpeechCustomStream, self), pUnkStream);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechAudio_Value = Guid.initString("cff8e175-019e-11d3-a08e-00c04f8ef9b5");
pub const IID_ISpeechAudio = &IID_ISpeechAudio_Value;
pub const ISpeechAudio = extern struct {
    pub const VTable = extern struct {
        base: ISpeechBaseStream.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Status: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechAudio,
                Status: ?*?*ISpeechAudioStatus,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechAudio,
                Status: ?*?*ISpeechAudioStatus,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BufferInfo: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechAudio,
                BufferInfo: ?*?*ISpeechAudioBufferInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechAudio,
                BufferInfo: ?*?*ISpeechAudioBufferInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DefaultFormat: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechAudio,
                StreamFormat: ?*?*ISpeechAudioFormat,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechAudio,
                StreamFormat: ?*?*ISpeechAudioFormat,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Volume: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechAudio,
                Volume: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechAudio,
                Volume: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Volume: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechAudio,
                Volume: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechAudio,
                Volume: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BufferNotifySize: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechAudio,
                BufferNotifySize: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechAudio,
                BufferNotifySize: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BufferNotifySize: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechAudio,
                BufferNotifySize: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechAudio,
                BufferNotifySize: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EventHandle: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechAudio,
                EventHandle: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechAudio,
                EventHandle: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechAudio,
                State: SpeechAudioState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechAudio,
                State: SpeechAudioState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISpeechBaseStream.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechAudio_get_Status(self: *const T, Status: ?*?*ISpeechAudioStatus) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechAudio.VTable, self.vtable).get_Status(@ptrCast(*const ISpeechAudio, self), Status);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechAudio_get_BufferInfo(self: *const T, BufferInfo: ?*?*ISpeechAudioBufferInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechAudio.VTable, self.vtable).get_BufferInfo(@ptrCast(*const ISpeechAudio, self), BufferInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechAudio_get_DefaultFormat(self: *const T, StreamFormat: ?*?*ISpeechAudioFormat) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechAudio.VTable, self.vtable).get_DefaultFormat(@ptrCast(*const ISpeechAudio, self), StreamFormat);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechAudio_get_Volume(self: *const T, Volume: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechAudio.VTable, self.vtable).get_Volume(@ptrCast(*const ISpeechAudio, self), Volume);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechAudio_put_Volume(self: *const T, Volume: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechAudio.VTable, self.vtable).put_Volume(@ptrCast(*const ISpeechAudio, self), Volume);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechAudio_get_BufferNotifySize(self: *const T, BufferNotifySize: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechAudio.VTable, self.vtable).get_BufferNotifySize(@ptrCast(*const ISpeechAudio, self), BufferNotifySize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechAudio_put_BufferNotifySize(self: *const T, BufferNotifySize: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechAudio.VTable, self.vtable).put_BufferNotifySize(@ptrCast(*const ISpeechAudio, self), BufferNotifySize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechAudio_get_EventHandle(self: *const T, EventHandle: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechAudio.VTable, self.vtable).get_EventHandle(@ptrCast(*const ISpeechAudio, self), EventHandle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechAudio_SetState(self: *const T, State: SpeechAudioState) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechAudio.VTable, self.vtable).SetState(@ptrCast(*const ISpeechAudio, self), State);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechMMSysAudio_Value = Guid.initString("3c76af6d-1fd7-4831-81d1-3b71d5a13c44");
pub const IID_ISpeechMMSysAudio = &IID_ISpeechMMSysAudio_Value;
pub const ISpeechMMSysAudio = extern struct {
    pub const VTable = extern struct {
        base: ISpeechAudio.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DeviceId: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechMMSysAudio,
                DeviceId: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechMMSysAudio,
                DeviceId: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DeviceId: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechMMSysAudio,
                DeviceId: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechMMSysAudio,
                DeviceId: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LineId: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechMMSysAudio,
                LineId: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechMMSysAudio,
                LineId: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_LineId: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechMMSysAudio,
                LineId: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechMMSysAudio,
                LineId: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MMHandle: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechMMSysAudio,
                Handle: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechMMSysAudio,
                Handle: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISpeechAudio.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechMMSysAudio_get_DeviceId(self: *const T, DeviceId: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechMMSysAudio.VTable, self.vtable).get_DeviceId(@ptrCast(*const ISpeechMMSysAudio, self), DeviceId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechMMSysAudio_put_DeviceId(self: *const T, DeviceId: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechMMSysAudio.VTable, self.vtable).put_DeviceId(@ptrCast(*const ISpeechMMSysAudio, self), DeviceId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechMMSysAudio_get_LineId(self: *const T, LineId: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechMMSysAudio.VTable, self.vtable).get_LineId(@ptrCast(*const ISpeechMMSysAudio, self), LineId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechMMSysAudio_put_LineId(self: *const T, LineId: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechMMSysAudio.VTable, self.vtable).put_LineId(@ptrCast(*const ISpeechMMSysAudio, self), LineId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechMMSysAudio_get_MMHandle(self: *const T, Handle: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechMMSysAudio.VTable, self.vtable).get_MMHandle(@ptrCast(*const ISpeechMMSysAudio, self), Handle);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechVoice_Value = Guid.initString("269316d8-57bd-11d2-9eee-00c04f797396");
pub const IID_ISpeechVoice = &IID_ISpeechVoice_Value;
pub const ISpeechVoice = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Status: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechVoice,
                Status: ?*?*ISpeechVoiceStatus,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechVoice,
                Status: ?*?*ISpeechVoiceStatus,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Voice: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechVoice,
                Voice: ?*?*ISpeechObjectToken,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechVoice,
                Voice: ?*?*ISpeechObjectToken,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        putref_Voice: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechVoice,
                Voice: ?*ISpeechObjectToken,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechVoice,
                Voice: ?*ISpeechObjectToken,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AudioOutput: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechVoice,
                AudioOutput: ?*?*ISpeechObjectToken,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechVoice,
                AudioOutput: ?*?*ISpeechObjectToken,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        putref_AudioOutput: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechVoice,
                AudioOutput: ?*ISpeechObjectToken,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechVoice,
                AudioOutput: ?*ISpeechObjectToken,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AudioOutputStream: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechVoice,
                AudioOutputStream: ?*?*ISpeechBaseStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechVoice,
                AudioOutputStream: ?*?*ISpeechBaseStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        putref_AudioOutputStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechVoice,
                AudioOutputStream: ?*ISpeechBaseStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechVoice,
                AudioOutputStream: ?*ISpeechBaseStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Rate: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechVoice,
                Rate: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechVoice,
                Rate: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Rate: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechVoice,
                Rate: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechVoice,
                Rate: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Volume: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechVoice,
                Volume: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechVoice,
                Volume: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Volume: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechVoice,
                Volume: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechVoice,
                Volume: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AllowAudioOutputFormatChangesOnNextSet: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechVoice,
                Allow: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechVoice,
                Allow: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AllowAudioOutputFormatChangesOnNextSet: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechVoice,
                Allow: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechVoice,
                Allow: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EventInterests: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechVoice,
                EventInterestFlags: ?*SpeechVoiceEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechVoice,
                EventInterestFlags: ?*SpeechVoiceEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_EventInterests: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechVoice,
                EventInterestFlags: SpeechVoiceEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechVoice,
                EventInterestFlags: SpeechVoiceEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Priority: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechVoice,
                Priority: SpeechVoicePriority,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechVoice,
                Priority: SpeechVoicePriority,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Priority: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechVoice,
                Priority: ?*SpeechVoicePriority,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechVoice,
                Priority: ?*SpeechVoicePriority,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AlertBoundary: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechVoice,
                Boundary: SpeechVoiceEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechVoice,
                Boundary: SpeechVoiceEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AlertBoundary: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechVoice,
                Boundary: ?*SpeechVoiceEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechVoice,
                Boundary: ?*SpeechVoiceEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SynchronousSpeakTimeout: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechVoice,
                msTimeout: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechVoice,
                msTimeout: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SynchronousSpeakTimeout: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechVoice,
                msTimeout: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechVoice,
                msTimeout: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Speak: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechVoice,
                Text: ?BSTR,
                Flags: SpeechVoiceSpeakFlags,
                StreamNumber: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechVoice,
                Text: ?BSTR,
                Flags: SpeechVoiceSpeakFlags,
                StreamNumber: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SpeakStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechVoice,
                Stream: ?*ISpeechBaseStream,
                Flags: SpeechVoiceSpeakFlags,
                StreamNumber: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechVoice,
                Stream: ?*ISpeechBaseStream,
                Flags: SpeechVoiceSpeakFlags,
                StreamNumber: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Pause: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechVoice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechVoice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Resume: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechVoice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechVoice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechVoice,
                Type: ?BSTR,
                NumItems: i32,
                NumSkipped: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechVoice,
                Type: ?BSTR,
                NumItems: i32,
                NumSkipped: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVoices: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechVoice,
                RequiredAttributes: ?BSTR,
                OptionalAttributes: ?BSTR,
                ObjectTokens: ?*?*ISpeechObjectTokens,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechVoice,
                RequiredAttributes: ?BSTR,
                OptionalAttributes: ?BSTR,
                ObjectTokens: ?*?*ISpeechObjectTokens,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAudioOutputs: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechVoice,
                RequiredAttributes: ?BSTR,
                OptionalAttributes: ?BSTR,
                ObjectTokens: ?*?*ISpeechObjectTokens,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechVoice,
                RequiredAttributes: ?BSTR,
                OptionalAttributes: ?BSTR,
                ObjectTokens: ?*?*ISpeechObjectTokens,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WaitUntilDone: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechVoice,
                msTimeout: i32,
                Done: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechVoice,
                msTimeout: i32,
                Done: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SpeakCompleteEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechVoice,
                Handle: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechVoice,
                Handle: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsUISupported: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechVoice,
                TypeOfUI: ?BSTR,
                ExtraData: ?*const VARIANT,
                Supported: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechVoice,
                TypeOfUI: ?BSTR,
                ExtraData: ?*const VARIANT,
                Supported: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DisplayUI: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechVoice,
                hWndParent: i32,
                Title: ?BSTR,
                TypeOfUI: ?BSTR,
                ExtraData: ?*const VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechVoice,
                hWndParent: i32,
                Title: ?BSTR,
                TypeOfUI: ?BSTR,
                ExtraData: ?*const VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechVoice_get_Status(self: *const T, Status: ?*?*ISpeechVoiceStatus) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechVoice.VTable, self.vtable).get_Status(@ptrCast(*const ISpeechVoice, self), Status);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechVoice_get_Voice(self: *const T, Voice: ?*?*ISpeechObjectToken) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechVoice.VTable, self.vtable).get_Voice(@ptrCast(*const ISpeechVoice, self), Voice);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechVoice_putref_Voice(self: *const T, Voice: ?*ISpeechObjectToken) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechVoice.VTable, self.vtable).putref_Voice(@ptrCast(*const ISpeechVoice, self), Voice);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechVoice_get_AudioOutput(self: *const T, AudioOutput: ?*?*ISpeechObjectToken) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechVoice.VTable, self.vtable).get_AudioOutput(@ptrCast(*const ISpeechVoice, self), AudioOutput);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechVoice_putref_AudioOutput(self: *const T, AudioOutput: ?*ISpeechObjectToken) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechVoice.VTable, self.vtable).putref_AudioOutput(@ptrCast(*const ISpeechVoice, self), AudioOutput);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechVoice_get_AudioOutputStream(self: *const T, AudioOutputStream: ?*?*ISpeechBaseStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechVoice.VTable, self.vtable).get_AudioOutputStream(@ptrCast(*const ISpeechVoice, self), AudioOutputStream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechVoice_putref_AudioOutputStream(self: *const T, AudioOutputStream: ?*ISpeechBaseStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechVoice.VTable, self.vtable).putref_AudioOutputStream(@ptrCast(*const ISpeechVoice, self), AudioOutputStream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechVoice_get_Rate(self: *const T, Rate: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechVoice.VTable, self.vtable).get_Rate(@ptrCast(*const ISpeechVoice, self), Rate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechVoice_put_Rate(self: *const T, Rate: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechVoice.VTable, self.vtable).put_Rate(@ptrCast(*const ISpeechVoice, self), Rate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechVoice_get_Volume(self: *const T, Volume: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechVoice.VTable, self.vtable).get_Volume(@ptrCast(*const ISpeechVoice, self), Volume);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechVoice_put_Volume(self: *const T, Volume: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechVoice.VTable, self.vtable).put_Volume(@ptrCast(*const ISpeechVoice, self), Volume);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechVoice_put_AllowAudioOutputFormatChangesOnNextSet(self: *const T, Allow: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechVoice.VTable, self.vtable).put_AllowAudioOutputFormatChangesOnNextSet(@ptrCast(*const ISpeechVoice, self), Allow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechVoice_get_AllowAudioOutputFormatChangesOnNextSet(self: *const T, Allow: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechVoice.VTable, self.vtable).get_AllowAudioOutputFormatChangesOnNextSet(@ptrCast(*const ISpeechVoice, self), Allow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechVoice_get_EventInterests(self: *const T, EventInterestFlags: ?*SpeechVoiceEvents) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechVoice.VTable, self.vtable).get_EventInterests(@ptrCast(*const ISpeechVoice, self), EventInterestFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechVoice_put_EventInterests(self: *const T, EventInterestFlags: SpeechVoiceEvents) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechVoice.VTable, self.vtable).put_EventInterests(@ptrCast(*const ISpeechVoice, self), EventInterestFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechVoice_put_Priority(self: *const T, Priority: SpeechVoicePriority) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechVoice.VTable, self.vtable).put_Priority(@ptrCast(*const ISpeechVoice, self), Priority);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechVoice_get_Priority(self: *const T, Priority: ?*SpeechVoicePriority) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechVoice.VTable, self.vtable).get_Priority(@ptrCast(*const ISpeechVoice, self), Priority);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechVoice_put_AlertBoundary(self: *const T, Boundary: SpeechVoiceEvents) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechVoice.VTable, self.vtable).put_AlertBoundary(@ptrCast(*const ISpeechVoice, self), Boundary);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechVoice_get_AlertBoundary(self: *const T, Boundary: ?*SpeechVoiceEvents) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechVoice.VTable, self.vtable).get_AlertBoundary(@ptrCast(*const ISpeechVoice, self), Boundary);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechVoice_put_SynchronousSpeakTimeout(self: *const T, msTimeout: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechVoice.VTable, self.vtable).put_SynchronousSpeakTimeout(@ptrCast(*const ISpeechVoice, self), msTimeout);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechVoice_get_SynchronousSpeakTimeout(self: *const T, msTimeout: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechVoice.VTable, self.vtable).get_SynchronousSpeakTimeout(@ptrCast(*const ISpeechVoice, self), msTimeout);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechVoice_Speak(self: *const T, Text: ?BSTR, Flags: SpeechVoiceSpeakFlags, StreamNumber: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechVoice.VTable, self.vtable).Speak(@ptrCast(*const ISpeechVoice, self), Text, Flags, StreamNumber);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechVoice_SpeakStream(self: *const T, Stream: ?*ISpeechBaseStream, Flags: SpeechVoiceSpeakFlags, StreamNumber: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechVoice.VTable, self.vtable).SpeakStream(@ptrCast(*const ISpeechVoice, self), Stream, Flags, StreamNumber);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechVoice_Pause(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechVoice.VTable, self.vtable).Pause(@ptrCast(*const ISpeechVoice, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechVoice_Resume(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechVoice.VTable, self.vtable).Resume(@ptrCast(*const ISpeechVoice, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechVoice_Skip(self: *const T, Type: ?BSTR, NumItems: i32, NumSkipped: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechVoice.VTable, self.vtable).Skip(@ptrCast(*const ISpeechVoice, self), Type, NumItems, NumSkipped);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechVoice_GetVoices(self: *const T, RequiredAttributes: ?BSTR, OptionalAttributes: ?BSTR, ObjectTokens: ?*?*ISpeechObjectTokens) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechVoice.VTable, self.vtable).GetVoices(@ptrCast(*const ISpeechVoice, self), RequiredAttributes, OptionalAttributes, ObjectTokens);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechVoice_GetAudioOutputs(self: *const T, RequiredAttributes: ?BSTR, OptionalAttributes: ?BSTR, ObjectTokens: ?*?*ISpeechObjectTokens) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechVoice.VTable, self.vtable).GetAudioOutputs(@ptrCast(*const ISpeechVoice, self), RequiredAttributes, OptionalAttributes, ObjectTokens);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechVoice_WaitUntilDone(self: *const T, msTimeout: i32, Done: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechVoice.VTable, self.vtable).WaitUntilDone(@ptrCast(*const ISpeechVoice, self), msTimeout, Done);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechVoice_SpeakCompleteEvent(self: *const T, Handle: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechVoice.VTable, self.vtable).SpeakCompleteEvent(@ptrCast(*const ISpeechVoice, self), Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechVoice_IsUISupported(self: *const T, TypeOfUI: ?BSTR, ExtraData: ?*const VARIANT, Supported: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechVoice.VTable, self.vtable).IsUISupported(@ptrCast(*const ISpeechVoice, self), TypeOfUI, ExtraData, Supported);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechVoice_DisplayUI(self: *const T, hWndParent: i32, Title: ?BSTR, TypeOfUI: ?BSTR, ExtraData: ?*const VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechVoice.VTable, self.vtable).DisplayUI(@ptrCast(*const ISpeechVoice, self), hWndParent, Title, TypeOfUI, ExtraData);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechVoiceStatus_Value = Guid.initString("8be47b07-57f6-11d2-9eee-00c04f797396");
pub const IID_ISpeechVoiceStatus = &IID_ISpeechVoiceStatus_Value;
pub const ISpeechVoiceStatus = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentStreamNumber: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechVoiceStatus,
                StreamNumber: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechVoiceStatus,
                StreamNumber: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LastStreamNumberQueued: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechVoiceStatus,
                StreamNumber: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechVoiceStatus,
                StreamNumber: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LastHResult: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechVoiceStatus,
                HResult: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechVoiceStatus,
                HResult: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RunningState: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechVoiceStatus,
                State: ?*SpeechRunState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechVoiceStatus,
                State: ?*SpeechRunState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InputWordPosition: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechVoiceStatus,
                Position: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechVoiceStatus,
                Position: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InputWordLength: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechVoiceStatus,
                Length: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechVoiceStatus,
                Length: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InputSentencePosition: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechVoiceStatus,
                Position: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechVoiceStatus,
                Position: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InputSentenceLength: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechVoiceStatus,
                Length: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechVoiceStatus,
                Length: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LastBookmark: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechVoiceStatus,
                Bookmark: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechVoiceStatus,
                Bookmark: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LastBookmarkId: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechVoiceStatus,
                BookmarkId: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechVoiceStatus,
                BookmarkId: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PhonemeId: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechVoiceStatus,
                PhoneId: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechVoiceStatus,
                PhoneId: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_VisemeId: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechVoiceStatus,
                VisemeId: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechVoiceStatus,
                VisemeId: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechVoiceStatus_get_CurrentStreamNumber(self: *const T, StreamNumber: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechVoiceStatus.VTable, self.vtable).get_CurrentStreamNumber(@ptrCast(*const ISpeechVoiceStatus, self), StreamNumber);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechVoiceStatus_get_LastStreamNumberQueued(self: *const T, StreamNumber: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechVoiceStatus.VTable, self.vtable).get_LastStreamNumberQueued(@ptrCast(*const ISpeechVoiceStatus, self), StreamNumber);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechVoiceStatus_get_LastHResult(self: *const T, HResult: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechVoiceStatus.VTable, self.vtable).get_LastHResult(@ptrCast(*const ISpeechVoiceStatus, self), HResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechVoiceStatus_get_RunningState(self: *const T, State: ?*SpeechRunState) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechVoiceStatus.VTable, self.vtable).get_RunningState(@ptrCast(*const ISpeechVoiceStatus, self), State);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechVoiceStatus_get_InputWordPosition(self: *const T, Position: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechVoiceStatus.VTable, self.vtable).get_InputWordPosition(@ptrCast(*const ISpeechVoiceStatus, self), Position);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechVoiceStatus_get_InputWordLength(self: *const T, Length: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechVoiceStatus.VTable, self.vtable).get_InputWordLength(@ptrCast(*const ISpeechVoiceStatus, self), Length);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechVoiceStatus_get_InputSentencePosition(self: *const T, Position: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechVoiceStatus.VTable, self.vtable).get_InputSentencePosition(@ptrCast(*const ISpeechVoiceStatus, self), Position);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechVoiceStatus_get_InputSentenceLength(self: *const T, Length: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechVoiceStatus.VTable, self.vtable).get_InputSentenceLength(@ptrCast(*const ISpeechVoiceStatus, self), Length);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechVoiceStatus_get_LastBookmark(self: *const T, Bookmark: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechVoiceStatus.VTable, self.vtable).get_LastBookmark(@ptrCast(*const ISpeechVoiceStatus, self), Bookmark);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechVoiceStatus_get_LastBookmarkId(self: *const T, BookmarkId: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechVoiceStatus.VTable, self.vtable).get_LastBookmarkId(@ptrCast(*const ISpeechVoiceStatus, self), BookmarkId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechVoiceStatus_get_PhonemeId(self: *const T, PhoneId: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechVoiceStatus.VTable, self.vtable).get_PhonemeId(@ptrCast(*const ISpeechVoiceStatus, self), PhoneId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechVoiceStatus_get_VisemeId(self: *const T, VisemeId: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechVoiceStatus.VTable, self.vtable).get_VisemeId(@ptrCast(*const ISpeechVoiceStatus, self), VisemeId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID__ISpeechVoiceEvents_Value = Guid.initString("a372acd1-3bef-4bbd-8ffb-cb3e2b416af8");
pub const IID__ISpeechVoiceEvents = &IID__ISpeechVoiceEvents_Value;
pub const _ISpeechVoiceEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechRecognizer_Value = Guid.initString("2d5f1c0c-bd75-4b08-9478-3b11fea2586c");
pub const IID_ISpeechRecognizer = &IID_ISpeechRecognizer_Value;
pub const ISpeechRecognizer = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        putref_Recognizer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechRecognizer,
                Recognizer: ?*ISpeechObjectToken,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechRecognizer,
                Recognizer: ?*ISpeechObjectToken,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Recognizer: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechRecognizer,
                Recognizer: ?*?*ISpeechObjectToken,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechRecognizer,
                Recognizer: ?*?*ISpeechObjectToken,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AllowAudioInputFormatChangesOnNextSet: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechRecognizer,
                Allow: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechRecognizer,
                Allow: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AllowAudioInputFormatChangesOnNextSet: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechRecognizer,
                Allow: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechRecognizer,
                Allow: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        putref_AudioInput: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechRecognizer,
                AudioInput: ?*ISpeechObjectToken,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechRecognizer,
                AudioInput: ?*ISpeechObjectToken,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AudioInput: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechRecognizer,
                AudioInput: ?*?*ISpeechObjectToken,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechRecognizer,
                AudioInput: ?*?*ISpeechObjectToken,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        putref_AudioInputStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechRecognizer,
                AudioInputStream: ?*ISpeechBaseStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechRecognizer,
                AudioInputStream: ?*ISpeechBaseStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AudioInputStream: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechRecognizer,
                AudioInputStream: ?*?*ISpeechBaseStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechRecognizer,
                AudioInputStream: ?*?*ISpeechBaseStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsShared: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechRecognizer,
                Shared: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechRecognizer,
                Shared: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_State: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechRecognizer,
                State: SpeechRecognizerState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechRecognizer,
                State: SpeechRecognizerState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_State: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechRecognizer,
                State: ?*SpeechRecognizerState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechRecognizer,
                State: ?*SpeechRecognizerState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Status: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechRecognizer,
                Status: ?*?*ISpeechRecognizerStatus,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechRecognizer,
                Status: ?*?*ISpeechRecognizerStatus,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        putref_Profile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechRecognizer,
                Profile: ?*ISpeechObjectToken,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechRecognizer,
                Profile: ?*ISpeechObjectToken,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Profile: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechRecognizer,
                Profile: ?*?*ISpeechObjectToken,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechRecognizer,
                Profile: ?*?*ISpeechObjectToken,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EmulateRecognition: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechRecognizer,
                TextElements: VARIANT,
                ElementDisplayAttributes: ?*VARIANT,
                LanguageId: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechRecognizer,
                TextElements: VARIANT,
                ElementDisplayAttributes: ?*VARIANT,
                LanguageId: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateRecoContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechRecognizer,
                NewContext: ?*?*ISpeechRecoContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechRecognizer,
                NewContext: ?*?*ISpeechRecoContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFormat: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechRecognizer,
                Type: SpeechFormatType,
                Format: ?*?*ISpeechAudioFormat,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechRecognizer,
                Type: SpeechFormatType,
                Format: ?*?*ISpeechAudioFormat,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPropertyNumber: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechRecognizer,
                Name: ?BSTR,
                Value: i32,
                Supported: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechRecognizer,
                Name: ?BSTR,
                Value: i32,
                Supported: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPropertyNumber: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechRecognizer,
                Name: ?BSTR,
                Value: ?*i32,
                Supported: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechRecognizer,
                Name: ?BSTR,
                Value: ?*i32,
                Supported: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPropertyString: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechRecognizer,
                Name: ?BSTR,
                Value: ?BSTR,
                Supported: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechRecognizer,
                Name: ?BSTR,
                Value: ?BSTR,
                Supported: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPropertyString: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechRecognizer,
                Name: ?BSTR,
                Value: ?*?BSTR,
                Supported: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechRecognizer,
                Name: ?BSTR,
                Value: ?*?BSTR,
                Supported: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsUISupported: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechRecognizer,
                TypeOfUI: ?BSTR,
                ExtraData: ?*const VARIANT,
                Supported: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechRecognizer,
                TypeOfUI: ?BSTR,
                ExtraData: ?*const VARIANT,
                Supported: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DisplayUI: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechRecognizer,
                hWndParent: i32,
                Title: ?BSTR,
                TypeOfUI: ?BSTR,
                ExtraData: ?*const VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechRecognizer,
                hWndParent: i32,
                Title: ?BSTR,
                TypeOfUI: ?BSTR,
                ExtraData: ?*const VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecognizers: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechRecognizer,
                RequiredAttributes: ?BSTR,
                OptionalAttributes: ?BSTR,
                ObjectTokens: ?*?*ISpeechObjectTokens,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechRecognizer,
                RequiredAttributes: ?BSTR,
                OptionalAttributes: ?BSTR,
                ObjectTokens: ?*?*ISpeechObjectTokens,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAudioInputs: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechRecognizer,
                RequiredAttributes: ?BSTR,
                OptionalAttributes: ?BSTR,
                ObjectTokens: ?*?*ISpeechObjectTokens,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechRecognizer,
                RequiredAttributes: ?BSTR,
                OptionalAttributes: ?BSTR,
                ObjectTokens: ?*?*ISpeechObjectTokens,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProfiles: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechRecognizer,
                RequiredAttributes: ?BSTR,
                OptionalAttributes: ?BSTR,
                ObjectTokens: ?*?*ISpeechObjectTokens,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechRecognizer,
                RequiredAttributes: ?BSTR,
                OptionalAttributes: ?BSTR,
                ObjectTokens: ?*?*ISpeechObjectTokens,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecognizer_putref_Recognizer(self: *const T, Recognizer: ?*ISpeechObjectToken) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecognizer.VTable, self.vtable).putref_Recognizer(@ptrCast(*const ISpeechRecognizer, self), Recognizer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecognizer_get_Recognizer(self: *const T, Recognizer: ?*?*ISpeechObjectToken) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecognizer.VTable, self.vtable).get_Recognizer(@ptrCast(*const ISpeechRecognizer, self), Recognizer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecognizer_put_AllowAudioInputFormatChangesOnNextSet(self: *const T, Allow: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecognizer.VTable, self.vtable).put_AllowAudioInputFormatChangesOnNextSet(@ptrCast(*const ISpeechRecognizer, self), Allow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecognizer_get_AllowAudioInputFormatChangesOnNextSet(self: *const T, Allow: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecognizer.VTable, self.vtable).get_AllowAudioInputFormatChangesOnNextSet(@ptrCast(*const ISpeechRecognizer, self), Allow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecognizer_putref_AudioInput(self: *const T, AudioInput: ?*ISpeechObjectToken) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecognizer.VTable, self.vtable).putref_AudioInput(@ptrCast(*const ISpeechRecognizer, self), AudioInput);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecognizer_get_AudioInput(self: *const T, AudioInput: ?*?*ISpeechObjectToken) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecognizer.VTable, self.vtable).get_AudioInput(@ptrCast(*const ISpeechRecognizer, self), AudioInput);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecognizer_putref_AudioInputStream(self: *const T, AudioInputStream: ?*ISpeechBaseStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecognizer.VTable, self.vtable).putref_AudioInputStream(@ptrCast(*const ISpeechRecognizer, self), AudioInputStream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecognizer_get_AudioInputStream(self: *const T, AudioInputStream: ?*?*ISpeechBaseStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecognizer.VTable, self.vtable).get_AudioInputStream(@ptrCast(*const ISpeechRecognizer, self), AudioInputStream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecognizer_get_IsShared(self: *const T, Shared: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecognizer.VTable, self.vtable).get_IsShared(@ptrCast(*const ISpeechRecognizer, self), Shared);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecognizer_put_State(self: *const T, State: SpeechRecognizerState) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecognizer.VTable, self.vtable).put_State(@ptrCast(*const ISpeechRecognizer, self), State);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecognizer_get_State(self: *const T, State: ?*SpeechRecognizerState) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecognizer.VTable, self.vtable).get_State(@ptrCast(*const ISpeechRecognizer, self), State);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecognizer_get_Status(self: *const T, Status: ?*?*ISpeechRecognizerStatus) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecognizer.VTable, self.vtable).get_Status(@ptrCast(*const ISpeechRecognizer, self), Status);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecognizer_putref_Profile(self: *const T, Profile: ?*ISpeechObjectToken) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecognizer.VTable, self.vtable).putref_Profile(@ptrCast(*const ISpeechRecognizer, self), Profile);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecognizer_get_Profile(self: *const T, Profile: ?*?*ISpeechObjectToken) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecognizer.VTable, self.vtable).get_Profile(@ptrCast(*const ISpeechRecognizer, self), Profile);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecognizer_EmulateRecognition(self: *const T, TextElements: VARIANT, ElementDisplayAttributes: ?*VARIANT, LanguageId: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecognizer.VTable, self.vtable).EmulateRecognition(@ptrCast(*const ISpeechRecognizer, self), TextElements, ElementDisplayAttributes, LanguageId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecognizer_CreateRecoContext(self: *const T, NewContext: ?*?*ISpeechRecoContext) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecognizer.VTable, self.vtable).CreateRecoContext(@ptrCast(*const ISpeechRecognizer, self), NewContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecognizer_GetFormat(self: *const T, Type: SpeechFormatType, Format: ?*?*ISpeechAudioFormat) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecognizer.VTable, self.vtable).GetFormat(@ptrCast(*const ISpeechRecognizer, self), Type, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecognizer_SetPropertyNumber(self: *const T, Name: ?BSTR, Value: i32, Supported: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecognizer.VTable, self.vtable).SetPropertyNumber(@ptrCast(*const ISpeechRecognizer, self), Name, Value, Supported);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecognizer_GetPropertyNumber(self: *const T, Name: ?BSTR, Value: ?*i32, Supported: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecognizer.VTable, self.vtable).GetPropertyNumber(@ptrCast(*const ISpeechRecognizer, self), Name, Value, Supported);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecognizer_SetPropertyString(self: *const T, Name: ?BSTR, Value: ?BSTR, Supported: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecognizer.VTable, self.vtable).SetPropertyString(@ptrCast(*const ISpeechRecognizer, self), Name, Value, Supported);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecognizer_GetPropertyString(self: *const T, Name: ?BSTR, Value: ?*?BSTR, Supported: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecognizer.VTable, self.vtable).GetPropertyString(@ptrCast(*const ISpeechRecognizer, self), Name, Value, Supported);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecognizer_IsUISupported(self: *const T, TypeOfUI: ?BSTR, ExtraData: ?*const VARIANT, Supported: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecognizer.VTable, self.vtable).IsUISupported(@ptrCast(*const ISpeechRecognizer, self), TypeOfUI, ExtraData, Supported);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecognizer_DisplayUI(self: *const T, hWndParent: i32, Title: ?BSTR, TypeOfUI: ?BSTR, ExtraData: ?*const VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecognizer.VTable, self.vtable).DisplayUI(@ptrCast(*const ISpeechRecognizer, self), hWndParent, Title, TypeOfUI, ExtraData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecognizer_GetRecognizers(self: *const T, RequiredAttributes: ?BSTR, OptionalAttributes: ?BSTR, ObjectTokens: ?*?*ISpeechObjectTokens) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecognizer.VTable, self.vtable).GetRecognizers(@ptrCast(*const ISpeechRecognizer, self), RequiredAttributes, OptionalAttributes, ObjectTokens);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecognizer_GetAudioInputs(self: *const T, RequiredAttributes: ?BSTR, OptionalAttributes: ?BSTR, ObjectTokens: ?*?*ISpeechObjectTokens) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecognizer.VTable, self.vtable).GetAudioInputs(@ptrCast(*const ISpeechRecognizer, self), RequiredAttributes, OptionalAttributes, ObjectTokens);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecognizer_GetProfiles(self: *const T, RequiredAttributes: ?BSTR, OptionalAttributes: ?BSTR, ObjectTokens: ?*?*ISpeechObjectTokens) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecognizer.VTable, self.vtable).GetProfiles(@ptrCast(*const ISpeechRecognizer, self), RequiredAttributes, OptionalAttributes, ObjectTokens);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechRecognizerStatus_Value = Guid.initString("bff9e781-53ec-484e-bb8a-0e1b5551e35c");
pub const IID_ISpeechRecognizerStatus = &IID_ISpeechRecognizerStatus_Value;
pub const ISpeechRecognizerStatus = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AudioStatus: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechRecognizerStatus,
                AudioStatus: ?*?*ISpeechAudioStatus,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechRecognizerStatus,
                AudioStatus: ?*?*ISpeechAudioStatus,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentStreamPosition: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechRecognizerStatus,
                pCurrentStreamPos: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechRecognizerStatus,
                pCurrentStreamPos: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentStreamNumber: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechRecognizerStatus,
                StreamNumber: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechRecognizerStatus,
                StreamNumber: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NumberOfActiveRules: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechRecognizerStatus,
                NumberOfActiveRules: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechRecognizerStatus,
                NumberOfActiveRules: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ClsidEngine: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechRecognizerStatus,
                ClsidEngine: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechRecognizerStatus,
                ClsidEngine: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SupportedLanguages: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechRecognizerStatus,
                SupportedLanguages: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechRecognizerStatus,
                SupportedLanguages: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecognizerStatus_get_AudioStatus(self: *const T, AudioStatus: ?*?*ISpeechAudioStatus) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecognizerStatus.VTable, self.vtable).get_AudioStatus(@ptrCast(*const ISpeechRecognizerStatus, self), AudioStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecognizerStatus_get_CurrentStreamPosition(self: *const T, pCurrentStreamPos: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecognizerStatus.VTable, self.vtable).get_CurrentStreamPosition(@ptrCast(*const ISpeechRecognizerStatus, self), pCurrentStreamPos);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecognizerStatus_get_CurrentStreamNumber(self: *const T, StreamNumber: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecognizerStatus.VTable, self.vtable).get_CurrentStreamNumber(@ptrCast(*const ISpeechRecognizerStatus, self), StreamNumber);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecognizerStatus_get_NumberOfActiveRules(self: *const T, NumberOfActiveRules: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecognizerStatus.VTable, self.vtable).get_NumberOfActiveRules(@ptrCast(*const ISpeechRecognizerStatus, self), NumberOfActiveRules);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecognizerStatus_get_ClsidEngine(self: *const T, ClsidEngine: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecognizerStatus.VTable, self.vtable).get_ClsidEngine(@ptrCast(*const ISpeechRecognizerStatus, self), ClsidEngine);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecognizerStatus_get_SupportedLanguages(self: *const T, SupportedLanguages: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecognizerStatus.VTable, self.vtable).get_SupportedLanguages(@ptrCast(*const ISpeechRecognizerStatus, self), SupportedLanguages);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechRecoContext_Value = Guid.initString("580aa49d-7e1e-4809-b8e2-57da806104b8");
pub const IID_ISpeechRecoContext = &IID_ISpeechRecoContext_Value;
pub const ISpeechRecoContext = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Recognizer: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechRecoContext,
                Recognizer: ?*?*ISpeechRecognizer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechRecoContext,
                Recognizer: ?*?*ISpeechRecognizer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AudioInputInterferenceStatus: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechRecoContext,
                Interference: ?*SpeechInterference,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechRecoContext,
                Interference: ?*SpeechInterference,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RequestedUIType: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechRecoContext,
                UIType: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechRecoContext,
                UIType: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        putref_Voice: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechRecoContext,
                Voice: ?*ISpeechVoice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechRecoContext,
                Voice: ?*ISpeechVoice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Voice: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechRecoContext,
                Voice: ?*?*ISpeechVoice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechRecoContext,
                Voice: ?*?*ISpeechVoice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AllowVoiceFormatMatchingOnNextSet: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechRecoContext,
                Allow: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechRecoContext,
                Allow: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AllowVoiceFormatMatchingOnNextSet: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechRecoContext,
                pAllow: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechRecoContext,
                pAllow: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_VoicePurgeEvent: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechRecoContext,
                EventInterest: SpeechRecoEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechRecoContext,
                EventInterest: SpeechRecoEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_VoicePurgeEvent: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechRecoContext,
                EventInterest: ?*SpeechRecoEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechRecoContext,
                EventInterest: ?*SpeechRecoEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_EventInterests: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechRecoContext,
                EventInterest: SpeechRecoEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechRecoContext,
                EventInterest: SpeechRecoEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EventInterests: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechRecoContext,
                EventInterest: ?*SpeechRecoEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechRecoContext,
                EventInterest: ?*SpeechRecoEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_CmdMaxAlternates: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechRecoContext,
                MaxAlternates: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechRecoContext,
                MaxAlternates: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CmdMaxAlternates: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechRecoContext,
                MaxAlternates: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechRecoContext,
                MaxAlternates: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_State: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechRecoContext,
                State: SpeechRecoContextState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechRecoContext,
                State: SpeechRecoContextState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_State: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechRecoContext,
                State: ?*SpeechRecoContextState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechRecoContext,
                State: ?*SpeechRecoContextState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_RetainedAudio: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechRecoContext,
                Option: SpeechRetainedAudioOptions,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechRecoContext,
                Option: SpeechRetainedAudioOptions,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RetainedAudio: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechRecoContext,
                Option: ?*SpeechRetainedAudioOptions,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechRecoContext,
                Option: ?*SpeechRetainedAudioOptions,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        putref_RetainedAudioFormat: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechRecoContext,
                Format: ?*ISpeechAudioFormat,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechRecoContext,
                Format: ?*ISpeechAudioFormat,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RetainedAudioFormat: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechRecoContext,
                Format: ?*?*ISpeechAudioFormat,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechRecoContext,
                Format: ?*?*ISpeechAudioFormat,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Pause: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechRecoContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechRecoContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Resume: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechRecoContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechRecoContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateGrammar: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechRecoContext,
                GrammarId: VARIANT,
                Grammar: ?*?*ISpeechRecoGrammar,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechRecoContext,
                GrammarId: VARIANT,
                Grammar: ?*?*ISpeechRecoGrammar,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateResultFromMemory: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechRecoContext,
                ResultBlock: ?*VARIANT,
                Result: ?*?*ISpeechRecoResult,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechRecoContext,
                ResultBlock: ?*VARIANT,
                Result: ?*?*ISpeechRecoResult,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Bookmark: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechRecoContext,
                Options: SpeechBookmarkOptions,
                StreamPos: VARIANT,
                BookmarkId: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechRecoContext,
                Options: SpeechBookmarkOptions,
                StreamPos: VARIANT,
                BookmarkId: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetAdaptationData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechRecoContext,
                AdaptationString: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechRecoContext,
                AdaptationString: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecoContext_get_Recognizer(self: *const T, Recognizer: ?*?*ISpeechRecognizer) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecoContext.VTable, self.vtable).get_Recognizer(@ptrCast(*const ISpeechRecoContext, self), Recognizer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecoContext_get_AudioInputInterferenceStatus(self: *const T, Interference: ?*SpeechInterference) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecoContext.VTable, self.vtable).get_AudioInputInterferenceStatus(@ptrCast(*const ISpeechRecoContext, self), Interference);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecoContext_get_RequestedUIType(self: *const T, UIType: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecoContext.VTable, self.vtable).get_RequestedUIType(@ptrCast(*const ISpeechRecoContext, self), UIType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecoContext_putref_Voice(self: *const T, Voice: ?*ISpeechVoice) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecoContext.VTable, self.vtable).putref_Voice(@ptrCast(*const ISpeechRecoContext, self), Voice);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecoContext_get_Voice(self: *const T, Voice: ?*?*ISpeechVoice) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecoContext.VTable, self.vtable).get_Voice(@ptrCast(*const ISpeechRecoContext, self), Voice);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecoContext_put_AllowVoiceFormatMatchingOnNextSet(self: *const T, Allow: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecoContext.VTable, self.vtable).put_AllowVoiceFormatMatchingOnNextSet(@ptrCast(*const ISpeechRecoContext, self), Allow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecoContext_get_AllowVoiceFormatMatchingOnNextSet(self: *const T, pAllow: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecoContext.VTable, self.vtable).get_AllowVoiceFormatMatchingOnNextSet(@ptrCast(*const ISpeechRecoContext, self), pAllow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecoContext_put_VoicePurgeEvent(self: *const T, EventInterest: SpeechRecoEvents) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecoContext.VTable, self.vtable).put_VoicePurgeEvent(@ptrCast(*const ISpeechRecoContext, self), EventInterest);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecoContext_get_VoicePurgeEvent(self: *const T, EventInterest: ?*SpeechRecoEvents) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecoContext.VTable, self.vtable).get_VoicePurgeEvent(@ptrCast(*const ISpeechRecoContext, self), EventInterest);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecoContext_put_EventInterests(self: *const T, EventInterest: SpeechRecoEvents) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecoContext.VTable, self.vtable).put_EventInterests(@ptrCast(*const ISpeechRecoContext, self), EventInterest);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecoContext_get_EventInterests(self: *const T, EventInterest: ?*SpeechRecoEvents) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecoContext.VTable, self.vtable).get_EventInterests(@ptrCast(*const ISpeechRecoContext, self), EventInterest);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecoContext_put_CmdMaxAlternates(self: *const T, MaxAlternates: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecoContext.VTable, self.vtable).put_CmdMaxAlternates(@ptrCast(*const ISpeechRecoContext, self), MaxAlternates);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecoContext_get_CmdMaxAlternates(self: *const T, MaxAlternates: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecoContext.VTable, self.vtable).get_CmdMaxAlternates(@ptrCast(*const ISpeechRecoContext, self), MaxAlternates);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecoContext_put_State(self: *const T, State: SpeechRecoContextState) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecoContext.VTable, self.vtable).put_State(@ptrCast(*const ISpeechRecoContext, self), State);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecoContext_get_State(self: *const T, State: ?*SpeechRecoContextState) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecoContext.VTable, self.vtable).get_State(@ptrCast(*const ISpeechRecoContext, self), State);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecoContext_put_RetainedAudio(self: *const T, Option: SpeechRetainedAudioOptions) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecoContext.VTable, self.vtable).put_RetainedAudio(@ptrCast(*const ISpeechRecoContext, self), Option);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecoContext_get_RetainedAudio(self: *const T, Option: ?*SpeechRetainedAudioOptions) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecoContext.VTable, self.vtable).get_RetainedAudio(@ptrCast(*const ISpeechRecoContext, self), Option);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecoContext_putref_RetainedAudioFormat(self: *const T, Format: ?*ISpeechAudioFormat) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecoContext.VTable, self.vtable).putref_RetainedAudioFormat(@ptrCast(*const ISpeechRecoContext, self), Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecoContext_get_RetainedAudioFormat(self: *const T, Format: ?*?*ISpeechAudioFormat) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecoContext.VTable, self.vtable).get_RetainedAudioFormat(@ptrCast(*const ISpeechRecoContext, self), Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecoContext_Pause(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecoContext.VTable, self.vtable).Pause(@ptrCast(*const ISpeechRecoContext, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecoContext_Resume(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecoContext.VTable, self.vtable).Resume(@ptrCast(*const ISpeechRecoContext, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecoContext_CreateGrammar(self: *const T, GrammarId: VARIANT, Grammar: ?*?*ISpeechRecoGrammar) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecoContext.VTable, self.vtable).CreateGrammar(@ptrCast(*const ISpeechRecoContext, self), GrammarId, Grammar);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecoContext_CreateResultFromMemory(self: *const T, ResultBlock: ?*VARIANT, Result: ?*?*ISpeechRecoResult) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecoContext.VTable, self.vtable).CreateResultFromMemory(@ptrCast(*const ISpeechRecoContext, self), ResultBlock, Result);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecoContext_Bookmark(self: *const T, Options: SpeechBookmarkOptions, StreamPos: VARIANT, BookmarkId: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecoContext.VTable, self.vtable).Bookmark(@ptrCast(*const ISpeechRecoContext, self), Options, StreamPos, BookmarkId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecoContext_SetAdaptationData(self: *const T, AdaptationString: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecoContext.VTable, self.vtable).SetAdaptationData(@ptrCast(*const ISpeechRecoContext, self), AdaptationString);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechRecoGrammar_Value = Guid.initString("b6d6f79f-2158-4e50-b5bc-9a9ccd852a09");
pub const IID_ISpeechRecoGrammar = &IID_ISpeechRecoGrammar_Value;
pub const ISpeechRecoGrammar = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Id: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechRecoGrammar,
                Id: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechRecoGrammar,
                Id: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RecoContext: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechRecoGrammar,
                RecoContext: ?*?*ISpeechRecoContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechRecoGrammar,
                RecoContext: ?*?*ISpeechRecoContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_State: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechRecoGrammar,
                State: SpeechGrammarState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechRecoGrammar,
                State: SpeechGrammarState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_State: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechRecoGrammar,
                State: ?*SpeechGrammarState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechRecoGrammar,
                State: ?*SpeechGrammarState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Rules: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechRecoGrammar,
                Rules: ?*?*ISpeechGrammarRules,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechRecoGrammar,
                Rules: ?*?*ISpeechGrammarRules,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechRecoGrammar,
                NewLanguage: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechRecoGrammar,
                NewLanguage: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CmdLoadFromFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechRecoGrammar,
                FileName: ?BSTR,
                LoadOption: SpeechLoadOption,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechRecoGrammar,
                FileName: ?BSTR,
                LoadOption: SpeechLoadOption,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CmdLoadFromObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechRecoGrammar,
                ClassId: ?BSTR,
                GrammarName: ?BSTR,
                LoadOption: SpeechLoadOption,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechRecoGrammar,
                ClassId: ?BSTR,
                GrammarName: ?BSTR,
                LoadOption: SpeechLoadOption,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CmdLoadFromResource: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechRecoGrammar,
                hModule: i32,
                ResourceName: VARIANT,
                ResourceType: VARIANT,
                LanguageId: i32,
                LoadOption: SpeechLoadOption,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechRecoGrammar,
                hModule: i32,
                ResourceName: VARIANT,
                ResourceType: VARIANT,
                LanguageId: i32,
                LoadOption: SpeechLoadOption,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CmdLoadFromMemory: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechRecoGrammar,
                GrammarData: VARIANT,
                LoadOption: SpeechLoadOption,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechRecoGrammar,
                GrammarData: VARIANT,
                LoadOption: SpeechLoadOption,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CmdLoadFromProprietaryGrammar: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechRecoGrammar,
                ProprietaryGuid: ?BSTR,
                ProprietaryString: ?BSTR,
                ProprietaryData: VARIANT,
                LoadOption: SpeechLoadOption,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechRecoGrammar,
                ProprietaryGuid: ?BSTR,
                ProprietaryString: ?BSTR,
                ProprietaryData: VARIANT,
                LoadOption: SpeechLoadOption,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CmdSetRuleState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechRecoGrammar,
                Name: ?BSTR,
                State: SpeechRuleState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechRecoGrammar,
                Name: ?BSTR,
                State: SpeechRuleState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CmdSetRuleIdState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechRecoGrammar,
                RuleId: i32,
                State: SpeechRuleState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechRecoGrammar,
                RuleId: i32,
                State: SpeechRuleState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DictationLoad: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechRecoGrammar,
                TopicName: ?BSTR,
                LoadOption: SpeechLoadOption,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechRecoGrammar,
                TopicName: ?BSTR,
                LoadOption: SpeechLoadOption,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DictationUnload: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechRecoGrammar,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechRecoGrammar,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DictationSetState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechRecoGrammar,
                State: SpeechRuleState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechRecoGrammar,
                State: SpeechRuleState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetWordSequenceData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechRecoGrammar,
                Text: ?BSTR,
                TextLength: i32,
                Info: ?*ISpeechTextSelectionInformation,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechRecoGrammar,
                Text: ?BSTR,
                TextLength: i32,
                Info: ?*ISpeechTextSelectionInformation,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTextSelection: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechRecoGrammar,
                Info: ?*ISpeechTextSelectionInformation,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechRecoGrammar,
                Info: ?*ISpeechTextSelectionInformation,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsPronounceable: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechRecoGrammar,
                Word: ?BSTR,
                WordPronounceable: ?*SpeechWordPronounceable,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechRecoGrammar,
                Word: ?BSTR,
                WordPronounceable: ?*SpeechWordPronounceable,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecoGrammar_get_Id(self: *const T, Id: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecoGrammar.VTable, self.vtable).get_Id(@ptrCast(*const ISpeechRecoGrammar, self), Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecoGrammar_get_RecoContext(self: *const T, RecoContext: ?*?*ISpeechRecoContext) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecoGrammar.VTable, self.vtable).get_RecoContext(@ptrCast(*const ISpeechRecoGrammar, self), RecoContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecoGrammar_put_State(self: *const T, State: SpeechGrammarState) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecoGrammar.VTable, self.vtable).put_State(@ptrCast(*const ISpeechRecoGrammar, self), State);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecoGrammar_get_State(self: *const T, State: ?*SpeechGrammarState) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecoGrammar.VTable, self.vtable).get_State(@ptrCast(*const ISpeechRecoGrammar, self), State);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecoGrammar_get_Rules(self: *const T, Rules: ?*?*ISpeechGrammarRules) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecoGrammar.VTable, self.vtable).get_Rules(@ptrCast(*const ISpeechRecoGrammar, self), Rules);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecoGrammar_Reset(self: *const T, NewLanguage: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecoGrammar.VTable, self.vtable).Reset(@ptrCast(*const ISpeechRecoGrammar, self), NewLanguage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecoGrammar_CmdLoadFromFile(self: *const T, FileName: ?BSTR, LoadOption: SpeechLoadOption) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecoGrammar.VTable, self.vtable).CmdLoadFromFile(@ptrCast(*const ISpeechRecoGrammar, self), FileName, LoadOption);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecoGrammar_CmdLoadFromObject(self: *const T, ClassId: ?BSTR, GrammarName: ?BSTR, LoadOption: SpeechLoadOption) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecoGrammar.VTable, self.vtable).CmdLoadFromObject(@ptrCast(*const ISpeechRecoGrammar, self), ClassId, GrammarName, LoadOption);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecoGrammar_CmdLoadFromResource(self: *const T, hModule: i32, ResourceName: VARIANT, ResourceType: VARIANT, LanguageId: i32, LoadOption: SpeechLoadOption) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecoGrammar.VTable, self.vtable).CmdLoadFromResource(@ptrCast(*const ISpeechRecoGrammar, self), hModule, ResourceName, ResourceType, LanguageId, LoadOption);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecoGrammar_CmdLoadFromMemory(self: *const T, GrammarData: VARIANT, LoadOption: SpeechLoadOption) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecoGrammar.VTable, self.vtable).CmdLoadFromMemory(@ptrCast(*const ISpeechRecoGrammar, self), GrammarData, LoadOption);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecoGrammar_CmdLoadFromProprietaryGrammar(self: *const T, ProprietaryGuid: ?BSTR, ProprietaryString: ?BSTR, ProprietaryData: VARIANT, LoadOption: SpeechLoadOption) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecoGrammar.VTable, self.vtable).CmdLoadFromProprietaryGrammar(@ptrCast(*const ISpeechRecoGrammar, self), ProprietaryGuid, ProprietaryString, ProprietaryData, LoadOption);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecoGrammar_CmdSetRuleState(self: *const T, Name: ?BSTR, State: SpeechRuleState) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecoGrammar.VTable, self.vtable).CmdSetRuleState(@ptrCast(*const ISpeechRecoGrammar, self), Name, State);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecoGrammar_CmdSetRuleIdState(self: *const T, RuleId: i32, State: SpeechRuleState) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecoGrammar.VTable, self.vtable).CmdSetRuleIdState(@ptrCast(*const ISpeechRecoGrammar, self), RuleId, State);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecoGrammar_DictationLoad(self: *const T, TopicName: ?BSTR, LoadOption: SpeechLoadOption) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecoGrammar.VTable, self.vtable).DictationLoad(@ptrCast(*const ISpeechRecoGrammar, self), TopicName, LoadOption);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecoGrammar_DictationUnload(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecoGrammar.VTable, self.vtable).DictationUnload(@ptrCast(*const ISpeechRecoGrammar, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecoGrammar_DictationSetState(self: *const T, State: SpeechRuleState) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecoGrammar.VTable, self.vtable).DictationSetState(@ptrCast(*const ISpeechRecoGrammar, self), State);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecoGrammar_SetWordSequenceData(self: *const T, Text: ?BSTR, TextLength: i32, Info: ?*ISpeechTextSelectionInformation) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecoGrammar.VTable, self.vtable).SetWordSequenceData(@ptrCast(*const ISpeechRecoGrammar, self), Text, TextLength, Info);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecoGrammar_SetTextSelection(self: *const T, Info: ?*ISpeechTextSelectionInformation) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecoGrammar.VTable, self.vtable).SetTextSelection(@ptrCast(*const ISpeechRecoGrammar, self), Info);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecoGrammar_IsPronounceable(self: *const T, Word: ?BSTR, WordPronounceable: ?*SpeechWordPronounceable) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecoGrammar.VTable, self.vtable).IsPronounceable(@ptrCast(*const ISpeechRecoGrammar, self), Word, WordPronounceable);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID__ISpeechRecoContextEvents_Value = Guid.initString("7b8fcb42-0e9d-4f00-a048-7b04d6179d3d");
pub const IID__ISpeechRecoContextEvents = &IID__ISpeechRecoContextEvents_Value;
pub const _ISpeechRecoContextEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechGrammarRule_Value = Guid.initString("afe719cf-5dd1-44f2-999c-7a399f1cfccc");
pub const IID_ISpeechGrammarRule = &IID_ISpeechGrammarRule_Value;
pub const ISpeechGrammarRule = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Attributes: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechGrammarRule,
                Attributes: ?*SpeechRuleAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechGrammarRule,
                Attributes: ?*SpeechRuleAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InitialState: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechGrammarRule,
                State: ?*?*ISpeechGrammarRuleState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechGrammarRule,
                State: ?*?*ISpeechGrammarRuleState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechGrammarRule,
                Name: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechGrammarRule,
                Name: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Id: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechGrammarRule,
                Id: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechGrammarRule,
                Id: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clear: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechGrammarRule,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechGrammarRule,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddResource: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechGrammarRule,
                ResourceName: ?BSTR,
                ResourceValue: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechGrammarRule,
                ResourceName: ?BSTR,
                ResourceValue: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechGrammarRule,
                State: ?*?*ISpeechGrammarRuleState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechGrammarRule,
                State: ?*?*ISpeechGrammarRuleState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechGrammarRule_get_Attributes(self: *const T, Attributes: ?*SpeechRuleAttributes) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechGrammarRule.VTable, self.vtable).get_Attributes(@ptrCast(*const ISpeechGrammarRule, self), Attributes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechGrammarRule_get_InitialState(self: *const T, State: ?*?*ISpeechGrammarRuleState) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechGrammarRule.VTable, self.vtable).get_InitialState(@ptrCast(*const ISpeechGrammarRule, self), State);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechGrammarRule_get_Name(self: *const T, Name: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechGrammarRule.VTable, self.vtable).get_Name(@ptrCast(*const ISpeechGrammarRule, self), Name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechGrammarRule_get_Id(self: *const T, Id: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechGrammarRule.VTable, self.vtable).get_Id(@ptrCast(*const ISpeechGrammarRule, self), Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechGrammarRule_Clear(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechGrammarRule.VTable, self.vtable).Clear(@ptrCast(*const ISpeechGrammarRule, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechGrammarRule_AddResource(self: *const T, ResourceName: ?BSTR, ResourceValue: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechGrammarRule.VTable, self.vtable).AddResource(@ptrCast(*const ISpeechGrammarRule, self), ResourceName, ResourceValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechGrammarRule_AddState(self: *const T, State: ?*?*ISpeechGrammarRuleState) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechGrammarRule.VTable, self.vtable).AddState(@ptrCast(*const ISpeechGrammarRule, self), State);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechGrammarRules_Value = Guid.initString("6ffa3b44-fc2d-40d1-8afc-32911c7f1ad1");
pub const IID_ISpeechGrammarRules = &IID_ISpeechGrammarRules_Value;
pub const ISpeechGrammarRules = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechGrammarRules,
                Count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechGrammarRules,
                Count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindRule: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechGrammarRules,
                RuleNameOrId: VARIANT,
                Rule: ?*?*ISpeechGrammarRule,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechGrammarRules,
                RuleNameOrId: VARIANT,
                Rule: ?*?*ISpeechGrammarRule,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Item: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechGrammarRules,
                Index: i32,
                Rule: ?*?*ISpeechGrammarRule,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechGrammarRules,
                Index: i32,
                Rule: ?*?*ISpeechGrammarRule,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechGrammarRules,
                EnumVARIANT: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechGrammarRules,
                EnumVARIANT: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Dynamic: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechGrammarRules,
                Dynamic: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechGrammarRules,
                Dynamic: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Add: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechGrammarRules,
                RuleName: ?BSTR,
                Attributes: SpeechRuleAttributes,
                RuleId: i32,
                Rule: ?*?*ISpeechGrammarRule,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechGrammarRules,
                RuleName: ?BSTR,
                Attributes: SpeechRuleAttributes,
                RuleId: i32,
                Rule: ?*?*ISpeechGrammarRule,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Commit: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechGrammarRules,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechGrammarRules,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CommitAndSave: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechGrammarRules,
                ErrorText: ?*?BSTR,
                SaveStream: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechGrammarRules,
                ErrorText: ?*?BSTR,
                SaveStream: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechGrammarRules_get_Count(self: *const T, Count: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechGrammarRules.VTable, self.vtable).get_Count(@ptrCast(*const ISpeechGrammarRules, self), Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechGrammarRules_FindRule(self: *const T, RuleNameOrId: VARIANT, Rule: ?*?*ISpeechGrammarRule) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechGrammarRules.VTable, self.vtable).FindRule(@ptrCast(*const ISpeechGrammarRules, self), RuleNameOrId, Rule);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechGrammarRules_Item(self: *const T, Index: i32, Rule: ?*?*ISpeechGrammarRule) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechGrammarRules.VTable, self.vtable).Item(@ptrCast(*const ISpeechGrammarRules, self), Index, Rule);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechGrammarRules_get__NewEnum(self: *const T, EnumVARIANT: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechGrammarRules.VTable, self.vtable).get__NewEnum(@ptrCast(*const ISpeechGrammarRules, self), EnumVARIANT);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechGrammarRules_get_Dynamic(self: *const T, Dynamic: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechGrammarRules.VTable, self.vtable).get_Dynamic(@ptrCast(*const ISpeechGrammarRules, self), Dynamic);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechGrammarRules_Add(self: *const T, RuleName: ?BSTR, Attributes: SpeechRuleAttributes, RuleId: i32, Rule: ?*?*ISpeechGrammarRule) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechGrammarRules.VTable, self.vtable).Add(@ptrCast(*const ISpeechGrammarRules, self), RuleName, Attributes, RuleId, Rule);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechGrammarRules_Commit(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechGrammarRules.VTable, self.vtable).Commit(@ptrCast(*const ISpeechGrammarRules, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechGrammarRules_CommitAndSave(self: *const T, ErrorText: ?*?BSTR, SaveStream: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechGrammarRules.VTable, self.vtable).CommitAndSave(@ptrCast(*const ISpeechGrammarRules, self), ErrorText, SaveStream);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechGrammarRuleState_Value = Guid.initString("d4286f2c-ee67-45ae-b928-28d695362eda");
pub const IID_ISpeechGrammarRuleState = &IID_ISpeechGrammarRuleState_Value;
pub const ISpeechGrammarRuleState = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Rule: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechGrammarRuleState,
                Rule: ?*?*ISpeechGrammarRule,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechGrammarRuleState,
                Rule: ?*?*ISpeechGrammarRule,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Transitions: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechGrammarRuleState,
                Transitions: ?*?*ISpeechGrammarRuleStateTransitions,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechGrammarRuleState,
                Transitions: ?*?*ISpeechGrammarRuleStateTransitions,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddWordTransition: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechGrammarRuleState,
                DestState: ?*ISpeechGrammarRuleState,
                Words: ?BSTR,
                Separators: ?BSTR,
                Type: SpeechGrammarWordType,
                PropertyName: ?BSTR,
                PropertyId: i32,
                PropertyValue: ?*VARIANT,
                Weight: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechGrammarRuleState,
                DestState: ?*ISpeechGrammarRuleState,
                Words: ?BSTR,
                Separators: ?BSTR,
                Type: SpeechGrammarWordType,
                PropertyName: ?BSTR,
                PropertyId: i32,
                PropertyValue: ?*VARIANT,
                Weight: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddRuleTransition: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechGrammarRuleState,
                DestinationState: ?*ISpeechGrammarRuleState,
                Rule: ?*ISpeechGrammarRule,
                PropertyName: ?BSTR,
                PropertyId: i32,
                PropertyValue: ?*VARIANT,
                Weight: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechGrammarRuleState,
                DestinationState: ?*ISpeechGrammarRuleState,
                Rule: ?*ISpeechGrammarRule,
                PropertyName: ?BSTR,
                PropertyId: i32,
                PropertyValue: ?*VARIANT,
                Weight: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddSpecialTransition: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechGrammarRuleState,
                DestinationState: ?*ISpeechGrammarRuleState,
                Type: SpeechSpecialTransitionType,
                PropertyName: ?BSTR,
                PropertyId: i32,
                PropertyValue: ?*VARIANT,
                Weight: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechGrammarRuleState,
                DestinationState: ?*ISpeechGrammarRuleState,
                Type: SpeechSpecialTransitionType,
                PropertyName: ?BSTR,
                PropertyId: i32,
                PropertyValue: ?*VARIANT,
                Weight: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechGrammarRuleState_get_Rule(self: *const T, Rule: ?*?*ISpeechGrammarRule) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechGrammarRuleState.VTable, self.vtable).get_Rule(@ptrCast(*const ISpeechGrammarRuleState, self), Rule);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechGrammarRuleState_get_Transitions(self: *const T, Transitions: ?*?*ISpeechGrammarRuleStateTransitions) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechGrammarRuleState.VTable, self.vtable).get_Transitions(@ptrCast(*const ISpeechGrammarRuleState, self), Transitions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechGrammarRuleState_AddWordTransition(self: *const T, DestState: ?*ISpeechGrammarRuleState, Words: ?BSTR, Separators: ?BSTR, Type: SpeechGrammarWordType, PropertyName: ?BSTR, PropertyId: i32, PropertyValue: ?*VARIANT, Weight: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechGrammarRuleState.VTable, self.vtable).AddWordTransition(@ptrCast(*const ISpeechGrammarRuleState, self), DestState, Words, Separators, Type, PropertyName, PropertyId, PropertyValue, Weight);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechGrammarRuleState_AddRuleTransition(self: *const T, DestinationState: ?*ISpeechGrammarRuleState, Rule: ?*ISpeechGrammarRule, PropertyName: ?BSTR, PropertyId: i32, PropertyValue: ?*VARIANT, Weight: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechGrammarRuleState.VTable, self.vtable).AddRuleTransition(@ptrCast(*const ISpeechGrammarRuleState, self), DestinationState, Rule, PropertyName, PropertyId, PropertyValue, Weight);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechGrammarRuleState_AddSpecialTransition(self: *const T, DestinationState: ?*ISpeechGrammarRuleState, Type: SpeechSpecialTransitionType, PropertyName: ?BSTR, PropertyId: i32, PropertyValue: ?*VARIANT, Weight: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechGrammarRuleState.VTable, self.vtable).AddSpecialTransition(@ptrCast(*const ISpeechGrammarRuleState, self), DestinationState, Type, PropertyName, PropertyId, PropertyValue, Weight);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechGrammarRuleStateTransition_Value = Guid.initString("cafd1db1-41d1-4a06-9863-e2e81da17a9a");
pub const IID_ISpeechGrammarRuleStateTransition = &IID_ISpeechGrammarRuleStateTransition_Value;
pub const ISpeechGrammarRuleStateTransition = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Type: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechGrammarRuleStateTransition,
                Type: ?*SpeechGrammarRuleStateTransitionType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechGrammarRuleStateTransition,
                Type: ?*SpeechGrammarRuleStateTransitionType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Text: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechGrammarRuleStateTransition,
                Text: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechGrammarRuleStateTransition,
                Text: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Rule: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechGrammarRuleStateTransition,
                Rule: ?*?*ISpeechGrammarRule,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechGrammarRuleStateTransition,
                Rule: ?*?*ISpeechGrammarRule,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Weight: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechGrammarRuleStateTransition,
                Weight: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechGrammarRuleStateTransition,
                Weight: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PropertyName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechGrammarRuleStateTransition,
                PropertyName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechGrammarRuleStateTransition,
                PropertyName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PropertyId: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechGrammarRuleStateTransition,
                PropertyId: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechGrammarRuleStateTransition,
                PropertyId: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PropertyValue: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechGrammarRuleStateTransition,
                PropertyValue: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechGrammarRuleStateTransition,
                PropertyValue: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NextState: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechGrammarRuleStateTransition,
                NextState: ?*?*ISpeechGrammarRuleState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechGrammarRuleStateTransition,
                NextState: ?*?*ISpeechGrammarRuleState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechGrammarRuleStateTransition_get_Type(self: *const T, Type: ?*SpeechGrammarRuleStateTransitionType) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechGrammarRuleStateTransition.VTable, self.vtable).get_Type(@ptrCast(*const ISpeechGrammarRuleStateTransition, self), Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechGrammarRuleStateTransition_get_Text(self: *const T, Text: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechGrammarRuleStateTransition.VTable, self.vtable).get_Text(@ptrCast(*const ISpeechGrammarRuleStateTransition, self), Text);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechGrammarRuleStateTransition_get_Rule(self: *const T, Rule: ?*?*ISpeechGrammarRule) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechGrammarRuleStateTransition.VTable, self.vtable).get_Rule(@ptrCast(*const ISpeechGrammarRuleStateTransition, self), Rule);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechGrammarRuleStateTransition_get_Weight(self: *const T, Weight: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechGrammarRuleStateTransition.VTable, self.vtable).get_Weight(@ptrCast(*const ISpeechGrammarRuleStateTransition, self), Weight);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechGrammarRuleStateTransition_get_PropertyName(self: *const T, PropertyName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechGrammarRuleStateTransition.VTable, self.vtable).get_PropertyName(@ptrCast(*const ISpeechGrammarRuleStateTransition, self), PropertyName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechGrammarRuleStateTransition_get_PropertyId(self: *const T, PropertyId: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechGrammarRuleStateTransition.VTable, self.vtable).get_PropertyId(@ptrCast(*const ISpeechGrammarRuleStateTransition, self), PropertyId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechGrammarRuleStateTransition_get_PropertyValue(self: *const T, PropertyValue: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechGrammarRuleStateTransition.VTable, self.vtable).get_PropertyValue(@ptrCast(*const ISpeechGrammarRuleStateTransition, self), PropertyValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechGrammarRuleStateTransition_get_NextState(self: *const T, NextState: ?*?*ISpeechGrammarRuleState) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechGrammarRuleStateTransition.VTable, self.vtable).get_NextState(@ptrCast(*const ISpeechGrammarRuleStateTransition, self), NextState);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechGrammarRuleStateTransitions_Value = Guid.initString("eabce657-75bc-44a2-aa7f-c56476742963");
pub const IID_ISpeechGrammarRuleStateTransitions = &IID_ISpeechGrammarRuleStateTransitions_Value;
pub const ISpeechGrammarRuleStateTransitions = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechGrammarRuleStateTransitions,
                Count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechGrammarRuleStateTransitions,
                Count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Item: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechGrammarRuleStateTransitions,
                Index: i32,
                Transition: ?*?*ISpeechGrammarRuleStateTransition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechGrammarRuleStateTransitions,
                Index: i32,
                Transition: ?*?*ISpeechGrammarRuleStateTransition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechGrammarRuleStateTransitions,
                EnumVARIANT: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechGrammarRuleStateTransitions,
                EnumVARIANT: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechGrammarRuleStateTransitions_get_Count(self: *const T, Count: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechGrammarRuleStateTransitions.VTable, self.vtable).get_Count(@ptrCast(*const ISpeechGrammarRuleStateTransitions, self), Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechGrammarRuleStateTransitions_Item(self: *const T, Index: i32, Transition: ?*?*ISpeechGrammarRuleStateTransition) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechGrammarRuleStateTransitions.VTable, self.vtable).Item(@ptrCast(*const ISpeechGrammarRuleStateTransitions, self), Index, Transition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechGrammarRuleStateTransitions_get__NewEnum(self: *const T, EnumVARIANT: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechGrammarRuleStateTransitions.VTable, self.vtable).get__NewEnum(@ptrCast(*const ISpeechGrammarRuleStateTransitions, self), EnumVARIANT);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechTextSelectionInformation_Value = Guid.initString("3b9c7e7a-6eee-4ded-9092-11657279adbe");
pub const IID_ISpeechTextSelectionInformation = &IID_ISpeechTextSelectionInformation_Value;
pub const ISpeechTextSelectionInformation = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ActiveOffset: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechTextSelectionInformation,
                ActiveOffset: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechTextSelectionInformation,
                ActiveOffset: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ActiveOffset: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechTextSelectionInformation,
                ActiveOffset: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechTextSelectionInformation,
                ActiveOffset: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ActiveLength: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechTextSelectionInformation,
                ActiveLength: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechTextSelectionInformation,
                ActiveLength: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ActiveLength: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechTextSelectionInformation,
                ActiveLength: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechTextSelectionInformation,
                ActiveLength: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SelectionOffset: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechTextSelectionInformation,
                SelectionOffset: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechTextSelectionInformation,
                SelectionOffset: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SelectionOffset: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechTextSelectionInformation,
                SelectionOffset: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechTextSelectionInformation,
                SelectionOffset: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SelectionLength: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechTextSelectionInformation,
                SelectionLength: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechTextSelectionInformation,
                SelectionLength: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SelectionLength: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechTextSelectionInformation,
                SelectionLength: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechTextSelectionInformation,
                SelectionLength: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechTextSelectionInformation_put_ActiveOffset(self: *const T, ActiveOffset: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechTextSelectionInformation.VTable, self.vtable).put_ActiveOffset(@ptrCast(*const ISpeechTextSelectionInformation, self), ActiveOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechTextSelectionInformation_get_ActiveOffset(self: *const T, ActiveOffset: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechTextSelectionInformation.VTable, self.vtable).get_ActiveOffset(@ptrCast(*const ISpeechTextSelectionInformation, self), ActiveOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechTextSelectionInformation_put_ActiveLength(self: *const T, ActiveLength: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechTextSelectionInformation.VTable, self.vtable).put_ActiveLength(@ptrCast(*const ISpeechTextSelectionInformation, self), ActiveLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechTextSelectionInformation_get_ActiveLength(self: *const T, ActiveLength: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechTextSelectionInformation.VTable, self.vtable).get_ActiveLength(@ptrCast(*const ISpeechTextSelectionInformation, self), ActiveLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechTextSelectionInformation_put_SelectionOffset(self: *const T, SelectionOffset: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechTextSelectionInformation.VTable, self.vtable).put_SelectionOffset(@ptrCast(*const ISpeechTextSelectionInformation, self), SelectionOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechTextSelectionInformation_get_SelectionOffset(self: *const T, SelectionOffset: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechTextSelectionInformation.VTable, self.vtable).get_SelectionOffset(@ptrCast(*const ISpeechTextSelectionInformation, self), SelectionOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechTextSelectionInformation_put_SelectionLength(self: *const T, SelectionLength: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechTextSelectionInformation.VTable, self.vtable).put_SelectionLength(@ptrCast(*const ISpeechTextSelectionInformation, self), SelectionLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechTextSelectionInformation_get_SelectionLength(self: *const T, SelectionLength: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechTextSelectionInformation.VTable, self.vtable).get_SelectionLength(@ptrCast(*const ISpeechTextSelectionInformation, self), SelectionLength);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechRecoResult_Value = Guid.initString("ed2879cf-ced9-4ee6-a534-de0191d5468d");
pub const IID_ISpeechRecoResult = &IID_ISpeechRecoResult_Value;
pub const ISpeechRecoResult = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RecoContext: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechRecoResult,
                RecoContext: ?*?*ISpeechRecoContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechRecoResult,
                RecoContext: ?*?*ISpeechRecoContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Times: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechRecoResult,
                Times: ?*?*ISpeechRecoResultTimes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechRecoResult,
                Times: ?*?*ISpeechRecoResultTimes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        putref_AudioFormat: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechRecoResult,
                Format: ?*ISpeechAudioFormat,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechRecoResult,
                Format: ?*ISpeechAudioFormat,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AudioFormat: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechRecoResult,
                Format: ?*?*ISpeechAudioFormat,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechRecoResult,
                Format: ?*?*ISpeechAudioFormat,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PhraseInfo: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechRecoResult,
                PhraseInfo: ?*?*ISpeechPhraseInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechRecoResult,
                PhraseInfo: ?*?*ISpeechPhraseInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Alternates: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechRecoResult,
                RequestCount: i32,
                StartElement: i32,
                Elements: i32,
                Alternates: ?*?*ISpeechPhraseAlternates,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechRecoResult,
                RequestCount: i32,
                StartElement: i32,
                Elements: i32,
                Alternates: ?*?*ISpeechPhraseAlternates,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Audio: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechRecoResult,
                StartElement: i32,
                Elements: i32,
                Stream: ?*?*ISpeechMemoryStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechRecoResult,
                StartElement: i32,
                Elements: i32,
                Stream: ?*?*ISpeechMemoryStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SpeakAudio: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechRecoResult,
                StartElement: i32,
                Elements: i32,
                Flags: SpeechVoiceSpeakFlags,
                StreamNumber: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechRecoResult,
                StartElement: i32,
                Elements: i32,
                Flags: SpeechVoiceSpeakFlags,
                StreamNumber: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SaveToMemory: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechRecoResult,
                ResultBlock: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechRecoResult,
                ResultBlock: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DiscardResultInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechRecoResult,
                ValueTypes: SpeechDiscardType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechRecoResult,
                ValueTypes: SpeechDiscardType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecoResult_get_RecoContext(self: *const T, RecoContext: ?*?*ISpeechRecoContext) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecoResult.VTable, self.vtable).get_RecoContext(@ptrCast(*const ISpeechRecoResult, self), RecoContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecoResult_get_Times(self: *const T, Times: ?*?*ISpeechRecoResultTimes) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecoResult.VTable, self.vtable).get_Times(@ptrCast(*const ISpeechRecoResult, self), Times);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecoResult_putref_AudioFormat(self: *const T, Format: ?*ISpeechAudioFormat) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecoResult.VTable, self.vtable).putref_AudioFormat(@ptrCast(*const ISpeechRecoResult, self), Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecoResult_get_AudioFormat(self: *const T, Format: ?*?*ISpeechAudioFormat) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecoResult.VTable, self.vtable).get_AudioFormat(@ptrCast(*const ISpeechRecoResult, self), Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecoResult_get_PhraseInfo(self: *const T, PhraseInfo: ?*?*ISpeechPhraseInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecoResult.VTable, self.vtable).get_PhraseInfo(@ptrCast(*const ISpeechRecoResult, self), PhraseInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecoResult_Alternates(self: *const T, RequestCount: i32, StartElement: i32, Elements: i32, Alternates: ?*?*ISpeechPhraseAlternates) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecoResult.VTable, self.vtable).Alternates(@ptrCast(*const ISpeechRecoResult, self), RequestCount, StartElement, Elements, Alternates);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecoResult_Audio(self: *const T, StartElement: i32, Elements: i32, Stream: ?*?*ISpeechMemoryStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecoResult.VTable, self.vtable).Audio(@ptrCast(*const ISpeechRecoResult, self), StartElement, Elements, Stream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecoResult_SpeakAudio(self: *const T, StartElement: i32, Elements: i32, Flags: SpeechVoiceSpeakFlags, StreamNumber: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecoResult.VTable, self.vtable).SpeakAudio(@ptrCast(*const ISpeechRecoResult, self), StartElement, Elements, Flags, StreamNumber);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecoResult_SaveToMemory(self: *const T, ResultBlock: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecoResult.VTable, self.vtable).SaveToMemory(@ptrCast(*const ISpeechRecoResult, self), ResultBlock);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecoResult_DiscardResultInfo(self: *const T, ValueTypes: SpeechDiscardType) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecoResult.VTable, self.vtable).DiscardResultInfo(@ptrCast(*const ISpeechRecoResult, self), ValueTypes);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechRecoResult2_Value = Guid.initString("8e0a246d-d3c8-45de-8657-04290c458c3c");
pub const IID_ISpeechRecoResult2 = &IID_ISpeechRecoResult2_Value;
pub const ISpeechRecoResult2 = extern struct {
    pub const VTable = extern struct {
        base: ISpeechRecoResult.VTable,
        SetTextFeedback: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechRecoResult2,
                Feedback: ?BSTR,
                WasSuccessful: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechRecoResult2,
                Feedback: ?BSTR,
                WasSuccessful: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISpeechRecoResult.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecoResult2_SetTextFeedback(self: *const T, Feedback: ?BSTR, WasSuccessful: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecoResult2.VTable, self.vtable).SetTextFeedback(@ptrCast(*const ISpeechRecoResult2, self), Feedback, WasSuccessful);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechRecoResultTimes_Value = Guid.initString("62b3b8fb-f6e7-41be-bdcb-056b1c29efc0");
pub const IID_ISpeechRecoResultTimes = &IID_ISpeechRecoResultTimes_Value;
pub const ISpeechRecoResultTimes = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StreamTime: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechRecoResultTimes,
                Time: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechRecoResultTimes,
                Time: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Length: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechRecoResultTimes,
                Length: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechRecoResultTimes,
                Length: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TickCount: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechRecoResultTimes,
                TickCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechRecoResultTimes,
                TickCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_OffsetFromStart: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechRecoResultTimes,
                OffsetFromStart: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechRecoResultTimes,
                OffsetFromStart: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecoResultTimes_get_StreamTime(self: *const T, Time: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecoResultTimes.VTable, self.vtable).get_StreamTime(@ptrCast(*const ISpeechRecoResultTimes, self), Time);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecoResultTimes_get_Length(self: *const T, Length: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecoResultTimes.VTable, self.vtable).get_Length(@ptrCast(*const ISpeechRecoResultTimes, self), Length);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecoResultTimes_get_TickCount(self: *const T, TickCount: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecoResultTimes.VTable, self.vtable).get_TickCount(@ptrCast(*const ISpeechRecoResultTimes, self), TickCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecoResultTimes_get_OffsetFromStart(self: *const T, OffsetFromStart: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecoResultTimes.VTable, self.vtable).get_OffsetFromStart(@ptrCast(*const ISpeechRecoResultTimes, self), OffsetFromStart);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechPhraseAlternate_Value = Guid.initString("27864a2a-2b9f-4cb8-92d3-0d2722fd1e73");
pub const IID_ISpeechPhraseAlternate = &IID_ISpeechPhraseAlternate_Value;
pub const ISpeechPhraseAlternate = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RecoResult: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechPhraseAlternate,
                RecoResult: ?*?*ISpeechRecoResult,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechPhraseAlternate,
                RecoResult: ?*?*ISpeechRecoResult,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StartElementInResult: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechPhraseAlternate,
                StartElement: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechPhraseAlternate,
                StartElement: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NumberOfElementsInResult: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechPhraseAlternate,
                NumberOfElements: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechPhraseAlternate,
                NumberOfElements: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PhraseInfo: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechPhraseAlternate,
                PhraseInfo: ?*?*ISpeechPhraseInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechPhraseAlternate,
                PhraseInfo: ?*?*ISpeechPhraseInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Commit: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechPhraseAlternate,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechPhraseAlternate,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechPhraseAlternate_get_RecoResult(self: *const T, RecoResult: ?*?*ISpeechRecoResult) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechPhraseAlternate.VTable, self.vtable).get_RecoResult(@ptrCast(*const ISpeechPhraseAlternate, self), RecoResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechPhraseAlternate_get_StartElementInResult(self: *const T, StartElement: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechPhraseAlternate.VTable, self.vtable).get_StartElementInResult(@ptrCast(*const ISpeechPhraseAlternate, self), StartElement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechPhraseAlternate_get_NumberOfElementsInResult(self: *const T, NumberOfElements: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechPhraseAlternate.VTable, self.vtable).get_NumberOfElementsInResult(@ptrCast(*const ISpeechPhraseAlternate, self), NumberOfElements);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechPhraseAlternate_get_PhraseInfo(self: *const T, PhraseInfo: ?*?*ISpeechPhraseInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechPhraseAlternate.VTable, self.vtable).get_PhraseInfo(@ptrCast(*const ISpeechPhraseAlternate, self), PhraseInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechPhraseAlternate_Commit(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechPhraseAlternate.VTable, self.vtable).Commit(@ptrCast(*const ISpeechPhraseAlternate, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechPhraseAlternates_Value = Guid.initString("b238b6d5-f276-4c3d-a6c1-2974801c3cc2");
pub const IID_ISpeechPhraseAlternates = &IID_ISpeechPhraseAlternates_Value;
pub const ISpeechPhraseAlternates = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechPhraseAlternates,
                Count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechPhraseAlternates,
                Count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Item: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechPhraseAlternates,
                Index: i32,
                PhraseAlternate: ?*?*ISpeechPhraseAlternate,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechPhraseAlternates,
                Index: i32,
                PhraseAlternate: ?*?*ISpeechPhraseAlternate,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechPhraseAlternates,
                EnumVARIANT: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechPhraseAlternates,
                EnumVARIANT: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechPhraseAlternates_get_Count(self: *const T, Count: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechPhraseAlternates.VTable, self.vtable).get_Count(@ptrCast(*const ISpeechPhraseAlternates, self), Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechPhraseAlternates_Item(self: *const T, Index: i32, PhraseAlternate: ?*?*ISpeechPhraseAlternate) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechPhraseAlternates.VTable, self.vtable).Item(@ptrCast(*const ISpeechPhraseAlternates, self), Index, PhraseAlternate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechPhraseAlternates_get__NewEnum(self: *const T, EnumVARIANT: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechPhraseAlternates.VTable, self.vtable).get__NewEnum(@ptrCast(*const ISpeechPhraseAlternates, self), EnumVARIANT);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechPhraseInfo_Value = Guid.initString("961559cf-4e67-4662-8bf0-d93f1fcd61b3");
pub const IID_ISpeechPhraseInfo = &IID_ISpeechPhraseInfo_Value;
pub const ISpeechPhraseInfo = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LanguageId: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechPhraseInfo,
                LanguageId: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechPhraseInfo,
                LanguageId: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_GrammarId: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechPhraseInfo,
                GrammarId: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechPhraseInfo,
                GrammarId: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StartTime: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechPhraseInfo,
                StartTime: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechPhraseInfo,
                StartTime: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AudioStreamPosition: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechPhraseInfo,
                AudioStreamPosition: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechPhraseInfo,
                AudioStreamPosition: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AudioSizeBytes: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechPhraseInfo,
                pAudioSizeBytes: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechPhraseInfo,
                pAudioSizeBytes: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RetainedSizeBytes: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechPhraseInfo,
                RetainedSizeBytes: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechPhraseInfo,
                RetainedSizeBytes: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AudioSizeTime: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechPhraseInfo,
                AudioSizeTime: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechPhraseInfo,
                AudioSizeTime: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Rule: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechPhraseInfo,
                Rule: ?*?*ISpeechPhraseRule,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechPhraseInfo,
                Rule: ?*?*ISpeechPhraseRule,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Properties: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechPhraseInfo,
                Properties: ?*?*ISpeechPhraseProperties,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechPhraseInfo,
                Properties: ?*?*ISpeechPhraseProperties,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Elements: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechPhraseInfo,
                Elements: ?*?*ISpeechPhraseElements,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechPhraseInfo,
                Elements: ?*?*ISpeechPhraseElements,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Replacements: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechPhraseInfo,
                Replacements: ?*?*ISpeechPhraseReplacements,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechPhraseInfo,
                Replacements: ?*?*ISpeechPhraseReplacements,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EngineId: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechPhraseInfo,
                EngineIdGuid: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechPhraseInfo,
                EngineIdGuid: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EnginePrivateData: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechPhraseInfo,
                PrivateData: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechPhraseInfo,
                PrivateData: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SaveToMemory: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechPhraseInfo,
                PhraseBlock: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechPhraseInfo,
                PhraseBlock: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetText: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechPhraseInfo,
                StartElement: i32,
                Elements: i32,
                UseReplacements: i16,
                Text: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechPhraseInfo,
                StartElement: i32,
                Elements: i32,
                UseReplacements: i16,
                Text: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDisplayAttributes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechPhraseInfo,
                StartElement: i32,
                Elements: i32,
                UseReplacements: i16,
                DisplayAttributes: ?*SpeechDisplayAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechPhraseInfo,
                StartElement: i32,
                Elements: i32,
                UseReplacements: i16,
                DisplayAttributes: ?*SpeechDisplayAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechPhraseInfo_get_LanguageId(self: *const T, LanguageId: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechPhraseInfo.VTable, self.vtable).get_LanguageId(@ptrCast(*const ISpeechPhraseInfo, self), LanguageId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechPhraseInfo_get_GrammarId(self: *const T, GrammarId: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechPhraseInfo.VTable, self.vtable).get_GrammarId(@ptrCast(*const ISpeechPhraseInfo, self), GrammarId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechPhraseInfo_get_StartTime(self: *const T, StartTime: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechPhraseInfo.VTable, self.vtable).get_StartTime(@ptrCast(*const ISpeechPhraseInfo, self), StartTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechPhraseInfo_get_AudioStreamPosition(self: *const T, AudioStreamPosition: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechPhraseInfo.VTable, self.vtable).get_AudioStreamPosition(@ptrCast(*const ISpeechPhraseInfo, self), AudioStreamPosition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechPhraseInfo_get_AudioSizeBytes(self: *const T, pAudioSizeBytes: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechPhraseInfo.VTable, self.vtable).get_AudioSizeBytes(@ptrCast(*const ISpeechPhraseInfo, self), pAudioSizeBytes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechPhraseInfo_get_RetainedSizeBytes(self: *const T, RetainedSizeBytes: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechPhraseInfo.VTable, self.vtable).get_RetainedSizeBytes(@ptrCast(*const ISpeechPhraseInfo, self), RetainedSizeBytes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechPhraseInfo_get_AudioSizeTime(self: *const T, AudioSizeTime: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechPhraseInfo.VTable, self.vtable).get_AudioSizeTime(@ptrCast(*const ISpeechPhraseInfo, self), AudioSizeTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechPhraseInfo_get_Rule(self: *const T, Rule: ?*?*ISpeechPhraseRule) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechPhraseInfo.VTable, self.vtable).get_Rule(@ptrCast(*const ISpeechPhraseInfo, self), Rule);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechPhraseInfo_get_Properties(self: *const T, Properties: ?*?*ISpeechPhraseProperties) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechPhraseInfo.VTable, self.vtable).get_Properties(@ptrCast(*const ISpeechPhraseInfo, self), Properties);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechPhraseInfo_get_Elements(self: *const T, Elements: ?*?*ISpeechPhraseElements) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechPhraseInfo.VTable, self.vtable).get_Elements(@ptrCast(*const ISpeechPhraseInfo, self), Elements);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechPhraseInfo_get_Replacements(self: *const T, Replacements: ?*?*ISpeechPhraseReplacements) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechPhraseInfo.VTable, self.vtable).get_Replacements(@ptrCast(*const ISpeechPhraseInfo, self), Replacements);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechPhraseInfo_get_EngineId(self: *const T, EngineIdGuid: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechPhraseInfo.VTable, self.vtable).get_EngineId(@ptrCast(*const ISpeechPhraseInfo, self), EngineIdGuid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechPhraseInfo_get_EnginePrivateData(self: *const T, PrivateData: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechPhraseInfo.VTable, self.vtable).get_EnginePrivateData(@ptrCast(*const ISpeechPhraseInfo, self), PrivateData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechPhraseInfo_SaveToMemory(self: *const T, PhraseBlock: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechPhraseInfo.VTable, self.vtable).SaveToMemory(@ptrCast(*const ISpeechPhraseInfo, self), PhraseBlock);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechPhraseInfo_GetText(self: *const T, StartElement: i32, Elements: i32, UseReplacements: i16, Text: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechPhraseInfo.VTable, self.vtable).GetText(@ptrCast(*const ISpeechPhraseInfo, self), StartElement, Elements, UseReplacements, Text);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechPhraseInfo_GetDisplayAttributes(self: *const T, StartElement: i32, Elements: i32, UseReplacements: i16, DisplayAttributes: ?*SpeechDisplayAttributes) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechPhraseInfo.VTable, self.vtable).GetDisplayAttributes(@ptrCast(*const ISpeechPhraseInfo, self), StartElement, Elements, UseReplacements, DisplayAttributes);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechPhraseElement_Value = Guid.initString("e6176f96-e373-4801-b223-3b62c068c0b4");
pub const IID_ISpeechPhraseElement = &IID_ISpeechPhraseElement_Value;
pub const ISpeechPhraseElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AudioTimeOffset: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechPhraseElement,
                AudioTimeOffset: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechPhraseElement,
                AudioTimeOffset: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AudioSizeTime: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechPhraseElement,
                AudioSizeTime: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechPhraseElement,
                AudioSizeTime: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AudioStreamOffset: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechPhraseElement,
                AudioStreamOffset: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechPhraseElement,
                AudioStreamOffset: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AudioSizeBytes: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechPhraseElement,
                AudioSizeBytes: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechPhraseElement,
                AudioSizeBytes: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RetainedStreamOffset: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechPhraseElement,
                RetainedStreamOffset: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechPhraseElement,
                RetainedStreamOffset: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RetainedSizeBytes: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechPhraseElement,
                RetainedSizeBytes: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechPhraseElement,
                RetainedSizeBytes: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DisplayText: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechPhraseElement,
                DisplayText: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechPhraseElement,
                DisplayText: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LexicalForm: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechPhraseElement,
                LexicalForm: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechPhraseElement,
                LexicalForm: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Pronunciation: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechPhraseElement,
                Pronunciation: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechPhraseElement,
                Pronunciation: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DisplayAttributes: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechPhraseElement,
                DisplayAttributes: ?*SpeechDisplayAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechPhraseElement,
                DisplayAttributes: ?*SpeechDisplayAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RequiredConfidence: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechPhraseElement,
                RequiredConfidence: ?*SpeechEngineConfidence,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechPhraseElement,
                RequiredConfidence: ?*SpeechEngineConfidence,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ActualConfidence: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechPhraseElement,
                ActualConfidence: ?*SpeechEngineConfidence,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechPhraseElement,
                ActualConfidence: ?*SpeechEngineConfidence,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EngineConfidence: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechPhraseElement,
                EngineConfidence: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechPhraseElement,
                EngineConfidence: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechPhraseElement_get_AudioTimeOffset(self: *const T, AudioTimeOffset: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechPhraseElement.VTable, self.vtable).get_AudioTimeOffset(@ptrCast(*const ISpeechPhraseElement, self), AudioTimeOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechPhraseElement_get_AudioSizeTime(self: *const T, AudioSizeTime: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechPhraseElement.VTable, self.vtable).get_AudioSizeTime(@ptrCast(*const ISpeechPhraseElement, self), AudioSizeTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechPhraseElement_get_AudioStreamOffset(self: *const T, AudioStreamOffset: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechPhraseElement.VTable, self.vtable).get_AudioStreamOffset(@ptrCast(*const ISpeechPhraseElement, self), AudioStreamOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechPhraseElement_get_AudioSizeBytes(self: *const T, AudioSizeBytes: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechPhraseElement.VTable, self.vtable).get_AudioSizeBytes(@ptrCast(*const ISpeechPhraseElement, self), AudioSizeBytes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechPhraseElement_get_RetainedStreamOffset(self: *const T, RetainedStreamOffset: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechPhraseElement.VTable, self.vtable).get_RetainedStreamOffset(@ptrCast(*const ISpeechPhraseElement, self), RetainedStreamOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechPhraseElement_get_RetainedSizeBytes(self: *const T, RetainedSizeBytes: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechPhraseElement.VTable, self.vtable).get_RetainedSizeBytes(@ptrCast(*const ISpeechPhraseElement, self), RetainedSizeBytes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechPhraseElement_get_DisplayText(self: *const T, DisplayText: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechPhraseElement.VTable, self.vtable).get_DisplayText(@ptrCast(*const ISpeechPhraseElement, self), DisplayText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechPhraseElement_get_LexicalForm(self: *const T, LexicalForm: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechPhraseElement.VTable, self.vtable).get_LexicalForm(@ptrCast(*const ISpeechPhraseElement, self), LexicalForm);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechPhraseElement_get_Pronunciation(self: *const T, Pronunciation: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechPhraseElement.VTable, self.vtable).get_Pronunciation(@ptrCast(*const ISpeechPhraseElement, self), Pronunciation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechPhraseElement_get_DisplayAttributes(self: *const T, DisplayAttributes: ?*SpeechDisplayAttributes) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechPhraseElement.VTable, self.vtable).get_DisplayAttributes(@ptrCast(*const ISpeechPhraseElement, self), DisplayAttributes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechPhraseElement_get_RequiredConfidence(self: *const T, RequiredConfidence: ?*SpeechEngineConfidence) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechPhraseElement.VTable, self.vtable).get_RequiredConfidence(@ptrCast(*const ISpeechPhraseElement, self), RequiredConfidence);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechPhraseElement_get_ActualConfidence(self: *const T, ActualConfidence: ?*SpeechEngineConfidence) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechPhraseElement.VTable, self.vtable).get_ActualConfidence(@ptrCast(*const ISpeechPhraseElement, self), ActualConfidence);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechPhraseElement_get_EngineConfidence(self: *const T, EngineConfidence: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechPhraseElement.VTable, self.vtable).get_EngineConfidence(@ptrCast(*const ISpeechPhraseElement, self), EngineConfidence);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechPhraseElements_Value = Guid.initString("0626b328-3478-467d-a0b3-d0853b93dda3");
pub const IID_ISpeechPhraseElements = &IID_ISpeechPhraseElements_Value;
pub const ISpeechPhraseElements = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechPhraseElements,
                Count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechPhraseElements,
                Count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Item: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechPhraseElements,
                Index: i32,
                Element: ?*?*ISpeechPhraseElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechPhraseElements,
                Index: i32,
                Element: ?*?*ISpeechPhraseElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechPhraseElements,
                EnumVARIANT: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechPhraseElements,
                EnumVARIANT: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechPhraseElements_get_Count(self: *const T, Count: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechPhraseElements.VTable, self.vtable).get_Count(@ptrCast(*const ISpeechPhraseElements, self), Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechPhraseElements_Item(self: *const T, Index: i32, Element: ?*?*ISpeechPhraseElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechPhraseElements.VTable, self.vtable).Item(@ptrCast(*const ISpeechPhraseElements, self), Index, Element);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechPhraseElements_get__NewEnum(self: *const T, EnumVARIANT: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechPhraseElements.VTable, self.vtable).get__NewEnum(@ptrCast(*const ISpeechPhraseElements, self), EnumVARIANT);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechPhraseReplacement_Value = Guid.initString("2890a410-53a7-4fb5-94ec-06d4998e3d02");
pub const IID_ISpeechPhraseReplacement = &IID_ISpeechPhraseReplacement_Value;
pub const ISpeechPhraseReplacement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DisplayAttributes: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechPhraseReplacement,
                DisplayAttributes: ?*SpeechDisplayAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechPhraseReplacement,
                DisplayAttributes: ?*SpeechDisplayAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Text: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechPhraseReplacement,
                Text: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechPhraseReplacement,
                Text: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FirstElement: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechPhraseReplacement,
                FirstElement: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechPhraseReplacement,
                FirstElement: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NumberOfElements: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechPhraseReplacement,
                NumberOfElements: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechPhraseReplacement,
                NumberOfElements: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechPhraseReplacement_get_DisplayAttributes(self: *const T, DisplayAttributes: ?*SpeechDisplayAttributes) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechPhraseReplacement.VTable, self.vtable).get_DisplayAttributes(@ptrCast(*const ISpeechPhraseReplacement, self), DisplayAttributes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechPhraseReplacement_get_Text(self: *const T, Text: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechPhraseReplacement.VTable, self.vtable).get_Text(@ptrCast(*const ISpeechPhraseReplacement, self), Text);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechPhraseReplacement_get_FirstElement(self: *const T, FirstElement: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechPhraseReplacement.VTable, self.vtable).get_FirstElement(@ptrCast(*const ISpeechPhraseReplacement, self), FirstElement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechPhraseReplacement_get_NumberOfElements(self: *const T, NumberOfElements: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechPhraseReplacement.VTable, self.vtable).get_NumberOfElements(@ptrCast(*const ISpeechPhraseReplacement, self), NumberOfElements);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechPhraseReplacements_Value = Guid.initString("38bc662f-2257-4525-959e-2069d2596c05");
pub const IID_ISpeechPhraseReplacements = &IID_ISpeechPhraseReplacements_Value;
pub const ISpeechPhraseReplacements = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechPhraseReplacements,
                Count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechPhraseReplacements,
                Count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Item: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechPhraseReplacements,
                Index: i32,
                Reps: ?*?*ISpeechPhraseReplacement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechPhraseReplacements,
                Index: i32,
                Reps: ?*?*ISpeechPhraseReplacement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechPhraseReplacements,
                EnumVARIANT: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechPhraseReplacements,
                EnumVARIANT: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechPhraseReplacements_get_Count(self: *const T, Count: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechPhraseReplacements.VTable, self.vtable).get_Count(@ptrCast(*const ISpeechPhraseReplacements, self), Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechPhraseReplacements_Item(self: *const T, Index: i32, Reps: ?*?*ISpeechPhraseReplacement) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechPhraseReplacements.VTable, self.vtable).Item(@ptrCast(*const ISpeechPhraseReplacements, self), Index, Reps);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechPhraseReplacements_get__NewEnum(self: *const T, EnumVARIANT: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechPhraseReplacements.VTable, self.vtable).get__NewEnum(@ptrCast(*const ISpeechPhraseReplacements, self), EnumVARIANT);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechPhraseProperty_Value = Guid.initString("ce563d48-961e-4732-a2e1-378a42b430be");
pub const IID_ISpeechPhraseProperty = &IID_ISpeechPhraseProperty_Value;
pub const ISpeechPhraseProperty = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechPhraseProperty,
                Name: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechPhraseProperty,
                Name: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Id: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechPhraseProperty,
                Id: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechPhraseProperty,
                Id: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Value: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechPhraseProperty,
                Value: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechPhraseProperty,
                Value: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FirstElement: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechPhraseProperty,
                FirstElement: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechPhraseProperty,
                FirstElement: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NumberOfElements: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechPhraseProperty,
                NumberOfElements: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechPhraseProperty,
                NumberOfElements: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EngineConfidence: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechPhraseProperty,
                Confidence: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechPhraseProperty,
                Confidence: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Confidence: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechPhraseProperty,
                Confidence: ?*SpeechEngineConfidence,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechPhraseProperty,
                Confidence: ?*SpeechEngineConfidence,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Parent: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechPhraseProperty,
                ParentProperty: ?*?*ISpeechPhraseProperty,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechPhraseProperty,
                ParentProperty: ?*?*ISpeechPhraseProperty,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Children: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechPhraseProperty,
                Children: ?*?*ISpeechPhraseProperties,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechPhraseProperty,
                Children: ?*?*ISpeechPhraseProperties,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechPhraseProperty_get_Name(self: *const T, Name: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechPhraseProperty.VTable, self.vtable).get_Name(@ptrCast(*const ISpeechPhraseProperty, self), Name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechPhraseProperty_get_Id(self: *const T, Id: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechPhraseProperty.VTable, self.vtable).get_Id(@ptrCast(*const ISpeechPhraseProperty, self), Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechPhraseProperty_get_Value(self: *const T, Value: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechPhraseProperty.VTable, self.vtable).get_Value(@ptrCast(*const ISpeechPhraseProperty, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechPhraseProperty_get_FirstElement(self: *const T, FirstElement: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechPhraseProperty.VTable, self.vtable).get_FirstElement(@ptrCast(*const ISpeechPhraseProperty, self), FirstElement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechPhraseProperty_get_NumberOfElements(self: *const T, NumberOfElements: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechPhraseProperty.VTable, self.vtable).get_NumberOfElements(@ptrCast(*const ISpeechPhraseProperty, self), NumberOfElements);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechPhraseProperty_get_EngineConfidence(self: *const T, Confidence: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechPhraseProperty.VTable, self.vtable).get_EngineConfidence(@ptrCast(*const ISpeechPhraseProperty, self), Confidence);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechPhraseProperty_get_Confidence(self: *const T, Confidence: ?*SpeechEngineConfidence) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechPhraseProperty.VTable, self.vtable).get_Confidence(@ptrCast(*const ISpeechPhraseProperty, self), Confidence);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechPhraseProperty_get_Parent(self: *const T, ParentProperty: ?*?*ISpeechPhraseProperty) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechPhraseProperty.VTable, self.vtable).get_Parent(@ptrCast(*const ISpeechPhraseProperty, self), ParentProperty);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechPhraseProperty_get_Children(self: *const T, Children: ?*?*ISpeechPhraseProperties) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechPhraseProperty.VTable, self.vtable).get_Children(@ptrCast(*const ISpeechPhraseProperty, self), Children);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechPhraseProperties_Value = Guid.initString("08166b47-102e-4b23-a599-bdb98dbfd1f4");
pub const IID_ISpeechPhraseProperties = &IID_ISpeechPhraseProperties_Value;
pub const ISpeechPhraseProperties = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechPhraseProperties,
                Count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechPhraseProperties,
                Count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Item: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechPhraseProperties,
                Index: i32,
                Property: ?*?*ISpeechPhraseProperty,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechPhraseProperties,
                Index: i32,
                Property: ?*?*ISpeechPhraseProperty,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechPhraseProperties,
                EnumVARIANT: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechPhraseProperties,
                EnumVARIANT: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechPhraseProperties_get_Count(self: *const T, Count: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechPhraseProperties.VTable, self.vtable).get_Count(@ptrCast(*const ISpeechPhraseProperties, self), Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechPhraseProperties_Item(self: *const T, Index: i32, Property: ?*?*ISpeechPhraseProperty) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechPhraseProperties.VTable, self.vtable).Item(@ptrCast(*const ISpeechPhraseProperties, self), Index, Property);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechPhraseProperties_get__NewEnum(self: *const T, EnumVARIANT: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechPhraseProperties.VTable, self.vtable).get__NewEnum(@ptrCast(*const ISpeechPhraseProperties, self), EnumVARIANT);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechPhraseRule_Value = Guid.initString("a7bfe112-a4a0-48d9-b602-c313843f6964");
pub const IID_ISpeechPhraseRule = &IID_ISpeechPhraseRule_Value;
pub const ISpeechPhraseRule = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechPhraseRule,
                Name: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechPhraseRule,
                Name: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Id: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechPhraseRule,
                Id: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechPhraseRule,
                Id: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FirstElement: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechPhraseRule,
                FirstElement: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechPhraseRule,
                FirstElement: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NumberOfElements: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechPhraseRule,
                NumberOfElements: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechPhraseRule,
                NumberOfElements: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Parent: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechPhraseRule,
                Parent: ?*?*ISpeechPhraseRule,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechPhraseRule,
                Parent: ?*?*ISpeechPhraseRule,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Children: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechPhraseRule,
                Children: ?*?*ISpeechPhraseRules,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechPhraseRule,
                Children: ?*?*ISpeechPhraseRules,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Confidence: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechPhraseRule,
                ActualConfidence: ?*SpeechEngineConfidence,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechPhraseRule,
                ActualConfidence: ?*SpeechEngineConfidence,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EngineConfidence: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechPhraseRule,
                EngineConfidence: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechPhraseRule,
                EngineConfidence: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechPhraseRule_get_Name(self: *const T, Name: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechPhraseRule.VTable, self.vtable).get_Name(@ptrCast(*const ISpeechPhraseRule, self), Name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechPhraseRule_get_Id(self: *const T, Id: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechPhraseRule.VTable, self.vtable).get_Id(@ptrCast(*const ISpeechPhraseRule, self), Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechPhraseRule_get_FirstElement(self: *const T, FirstElement: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechPhraseRule.VTable, self.vtable).get_FirstElement(@ptrCast(*const ISpeechPhraseRule, self), FirstElement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechPhraseRule_get_NumberOfElements(self: *const T, NumberOfElements: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechPhraseRule.VTable, self.vtable).get_NumberOfElements(@ptrCast(*const ISpeechPhraseRule, self), NumberOfElements);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechPhraseRule_get_Parent(self: *const T, Parent: ?*?*ISpeechPhraseRule) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechPhraseRule.VTable, self.vtable).get_Parent(@ptrCast(*const ISpeechPhraseRule, self), Parent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechPhraseRule_get_Children(self: *const T, Children: ?*?*ISpeechPhraseRules) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechPhraseRule.VTable, self.vtable).get_Children(@ptrCast(*const ISpeechPhraseRule, self), Children);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechPhraseRule_get_Confidence(self: *const T, ActualConfidence: ?*SpeechEngineConfidence) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechPhraseRule.VTable, self.vtable).get_Confidence(@ptrCast(*const ISpeechPhraseRule, self), ActualConfidence);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechPhraseRule_get_EngineConfidence(self: *const T, EngineConfidence: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechPhraseRule.VTable, self.vtable).get_EngineConfidence(@ptrCast(*const ISpeechPhraseRule, self), EngineConfidence);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechPhraseRules_Value = Guid.initString("9047d593-01dd-4b72-81a3-e4a0ca69f407");
pub const IID_ISpeechPhraseRules = &IID_ISpeechPhraseRules_Value;
pub const ISpeechPhraseRules = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechPhraseRules,
                Count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechPhraseRules,
                Count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Item: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechPhraseRules,
                Index: i32,
                Rule: ?*?*ISpeechPhraseRule,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechPhraseRules,
                Index: i32,
                Rule: ?*?*ISpeechPhraseRule,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechPhraseRules,
                EnumVARIANT: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechPhraseRules,
                EnumVARIANT: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechPhraseRules_get_Count(self: *const T, Count: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechPhraseRules.VTable, self.vtable).get_Count(@ptrCast(*const ISpeechPhraseRules, self), Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechPhraseRules_Item(self: *const T, Index: i32, Rule: ?*?*ISpeechPhraseRule) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechPhraseRules.VTable, self.vtable).Item(@ptrCast(*const ISpeechPhraseRules, self), Index, Rule);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechPhraseRules_get__NewEnum(self: *const T, EnumVARIANT: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechPhraseRules.VTable, self.vtable).get__NewEnum(@ptrCast(*const ISpeechPhraseRules, self), EnumVARIANT);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechLexicon_Value = Guid.initString("3da7627a-c7ae-4b23-8708-638c50362c25");
pub const IID_ISpeechLexicon = &IID_ISpeechLexicon_Value;
pub const ISpeechLexicon = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_GenerationId: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechLexicon,
                GenerationId: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechLexicon,
                GenerationId: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetWords: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechLexicon,
                Flags: SpeechLexiconType,
                GenerationID: ?*i32,
                Words: ?*?*ISpeechLexiconWords,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechLexicon,
                Flags: SpeechLexiconType,
                GenerationID: ?*i32,
                Words: ?*?*ISpeechLexiconWords,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddPronunciation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechLexicon,
                bstrWord: ?BSTR,
                LangId: i32,
                PartOfSpeech: SpeechPartOfSpeech,
                bstrPronunciation: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechLexicon,
                bstrWord: ?BSTR,
                LangId: i32,
                PartOfSpeech: SpeechPartOfSpeech,
                bstrPronunciation: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddPronunciationByPhoneIds: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechLexicon,
                bstrWord: ?BSTR,
                LangId: i32,
                PartOfSpeech: SpeechPartOfSpeech,
                PhoneIds: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechLexicon,
                bstrWord: ?BSTR,
                LangId: i32,
                PartOfSpeech: SpeechPartOfSpeech,
                PhoneIds: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemovePronunciation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechLexicon,
                bstrWord: ?BSTR,
                LangId: i32,
                PartOfSpeech: SpeechPartOfSpeech,
                bstrPronunciation: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechLexicon,
                bstrWord: ?BSTR,
                LangId: i32,
                PartOfSpeech: SpeechPartOfSpeech,
                bstrPronunciation: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemovePronunciationByPhoneIds: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechLexicon,
                bstrWord: ?BSTR,
                LangId: i32,
                PartOfSpeech: SpeechPartOfSpeech,
                PhoneIds: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechLexicon,
                bstrWord: ?BSTR,
                LangId: i32,
                PartOfSpeech: SpeechPartOfSpeech,
                PhoneIds: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPronunciations: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechLexicon,
                bstrWord: ?BSTR,
                LangId: i32,
                TypeFlags: SpeechLexiconType,
                ppPronunciations: ?*?*ISpeechLexiconPronunciations,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechLexicon,
                bstrWord: ?BSTR,
                LangId: i32,
                TypeFlags: SpeechLexiconType,
                ppPronunciations: ?*?*ISpeechLexiconPronunciations,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetGenerationChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechLexicon,
                GenerationID: ?*i32,
                ppWords: ?*?*ISpeechLexiconWords,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechLexicon,
                GenerationID: ?*i32,
                ppWords: ?*?*ISpeechLexiconWords,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechLexicon_get_GenerationId(self: *const T, GenerationId: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechLexicon.VTable, self.vtable).get_GenerationId(@ptrCast(*const ISpeechLexicon, self), GenerationId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechLexicon_GetWords(self: *const T, Flags: SpeechLexiconType, GenerationID: ?*i32, Words: ?*?*ISpeechLexiconWords) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechLexicon.VTable, self.vtable).GetWords(@ptrCast(*const ISpeechLexicon, self), Flags, GenerationID, Words);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechLexicon_AddPronunciation(self: *const T, bstrWord: ?BSTR, LangId: i32, PartOfSpeech: SpeechPartOfSpeech, bstrPronunciation: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechLexicon.VTable, self.vtable).AddPronunciation(@ptrCast(*const ISpeechLexicon, self), bstrWord, LangId, PartOfSpeech, bstrPronunciation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechLexicon_AddPronunciationByPhoneIds(self: *const T, bstrWord: ?BSTR, LangId: i32, PartOfSpeech: SpeechPartOfSpeech, PhoneIds: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechLexicon.VTable, self.vtable).AddPronunciationByPhoneIds(@ptrCast(*const ISpeechLexicon, self), bstrWord, LangId, PartOfSpeech, PhoneIds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechLexicon_RemovePronunciation(self: *const T, bstrWord: ?BSTR, LangId: i32, PartOfSpeech: SpeechPartOfSpeech, bstrPronunciation: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechLexicon.VTable, self.vtable).RemovePronunciation(@ptrCast(*const ISpeechLexicon, self), bstrWord, LangId, PartOfSpeech, bstrPronunciation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechLexicon_RemovePronunciationByPhoneIds(self: *const T, bstrWord: ?BSTR, LangId: i32, PartOfSpeech: SpeechPartOfSpeech, PhoneIds: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechLexicon.VTable, self.vtable).RemovePronunciationByPhoneIds(@ptrCast(*const ISpeechLexicon, self), bstrWord, LangId, PartOfSpeech, PhoneIds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechLexicon_GetPronunciations(self: *const T, bstrWord: ?BSTR, LangId: i32, TypeFlags: SpeechLexiconType, ppPronunciations: ?*?*ISpeechLexiconPronunciations) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechLexicon.VTable, self.vtable).GetPronunciations(@ptrCast(*const ISpeechLexicon, self), bstrWord, LangId, TypeFlags, ppPronunciations);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechLexicon_GetGenerationChange(self: *const T, GenerationID: ?*i32, ppWords: ?*?*ISpeechLexiconWords) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechLexicon.VTable, self.vtable).GetGenerationChange(@ptrCast(*const ISpeechLexicon, self), GenerationID, ppWords);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechLexiconWords_Value = Guid.initString("8d199862-415e-47d5-ac4f-faa608b424e6");
pub const IID_ISpeechLexiconWords = &IID_ISpeechLexiconWords_Value;
pub const ISpeechLexiconWords = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechLexiconWords,
                Count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechLexiconWords,
                Count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Item: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechLexiconWords,
                Index: i32,
                Word: ?*?*ISpeechLexiconWord,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechLexiconWords,
                Index: i32,
                Word: ?*?*ISpeechLexiconWord,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechLexiconWords,
                EnumVARIANT: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechLexiconWords,
                EnumVARIANT: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechLexiconWords_get_Count(self: *const T, Count: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechLexiconWords.VTable, self.vtable).get_Count(@ptrCast(*const ISpeechLexiconWords, self), Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechLexiconWords_Item(self: *const T, Index: i32, Word: ?*?*ISpeechLexiconWord) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechLexiconWords.VTable, self.vtable).Item(@ptrCast(*const ISpeechLexiconWords, self), Index, Word);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechLexiconWords_get__NewEnum(self: *const T, EnumVARIANT: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechLexiconWords.VTable, self.vtable).get__NewEnum(@ptrCast(*const ISpeechLexiconWords, self), EnumVARIANT);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechLexiconWord_Value = Guid.initString("4e5b933c-c9be-48ed-8842-1ee51bb1d4ff");
pub const IID_ISpeechLexiconWord = &IID_ISpeechLexiconWord_Value;
pub const ISpeechLexiconWord = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LangId: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechLexiconWord,
                LangId: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechLexiconWord,
                LangId: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Type: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechLexiconWord,
                WordType: ?*SpeechWordType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechLexiconWord,
                WordType: ?*SpeechWordType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Word: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechLexiconWord,
                Word: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechLexiconWord,
                Word: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Pronunciations: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechLexiconWord,
                Pronunciations: ?*?*ISpeechLexiconPronunciations,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechLexiconWord,
                Pronunciations: ?*?*ISpeechLexiconPronunciations,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechLexiconWord_get_LangId(self: *const T, LangId: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechLexiconWord.VTable, self.vtable).get_LangId(@ptrCast(*const ISpeechLexiconWord, self), LangId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechLexiconWord_get_Type(self: *const T, WordType: ?*SpeechWordType) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechLexiconWord.VTable, self.vtable).get_Type(@ptrCast(*const ISpeechLexiconWord, self), WordType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechLexiconWord_get_Word(self: *const T, Word: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechLexiconWord.VTable, self.vtable).get_Word(@ptrCast(*const ISpeechLexiconWord, self), Word);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechLexiconWord_get_Pronunciations(self: *const T, Pronunciations: ?*?*ISpeechLexiconPronunciations) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechLexiconWord.VTable, self.vtable).get_Pronunciations(@ptrCast(*const ISpeechLexiconWord, self), Pronunciations);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechLexiconPronunciations_Value = Guid.initString("72829128-5682-4704-a0d4-3e2bb6f2ead3");
pub const IID_ISpeechLexiconPronunciations = &IID_ISpeechLexiconPronunciations_Value;
pub const ISpeechLexiconPronunciations = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechLexiconPronunciations,
                Count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechLexiconPronunciations,
                Count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Item: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechLexiconPronunciations,
                Index: i32,
                Pronunciation: ?*?*ISpeechLexiconPronunciation,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechLexiconPronunciations,
                Index: i32,
                Pronunciation: ?*?*ISpeechLexiconPronunciation,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechLexiconPronunciations,
                EnumVARIANT: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechLexiconPronunciations,
                EnumVARIANT: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechLexiconPronunciations_get_Count(self: *const T, Count: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechLexiconPronunciations.VTable, self.vtable).get_Count(@ptrCast(*const ISpeechLexiconPronunciations, self), Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechLexiconPronunciations_Item(self: *const T, Index: i32, Pronunciation: ?*?*ISpeechLexiconPronunciation) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechLexiconPronunciations.VTable, self.vtable).Item(@ptrCast(*const ISpeechLexiconPronunciations, self), Index, Pronunciation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechLexiconPronunciations_get__NewEnum(self: *const T, EnumVARIANT: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechLexiconPronunciations.VTable, self.vtable).get__NewEnum(@ptrCast(*const ISpeechLexiconPronunciations, self), EnumVARIANT);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechLexiconPronunciation_Value = Guid.initString("95252c5d-9e43-4f4a-9899-48ee73352f9f");
pub const IID_ISpeechLexiconPronunciation = &IID_ISpeechLexiconPronunciation_Value;
pub const ISpeechLexiconPronunciation = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Type: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechLexiconPronunciation,
                LexiconType: ?*SpeechLexiconType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechLexiconPronunciation,
                LexiconType: ?*SpeechLexiconType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LangId: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechLexiconPronunciation,
                LangId: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechLexiconPronunciation,
                LangId: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PartOfSpeech: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechLexiconPronunciation,
                PartOfSpeech: ?*SpeechPartOfSpeech,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechLexiconPronunciation,
                PartOfSpeech: ?*SpeechPartOfSpeech,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PhoneIds: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechLexiconPronunciation,
                PhoneIds: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechLexiconPronunciation,
                PhoneIds: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Symbolic: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechLexiconPronunciation,
                Symbolic: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechLexiconPronunciation,
                Symbolic: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechLexiconPronunciation_get_Type(self: *const T, LexiconType: ?*SpeechLexiconType) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechLexiconPronunciation.VTable, self.vtable).get_Type(@ptrCast(*const ISpeechLexiconPronunciation, self), LexiconType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechLexiconPronunciation_get_LangId(self: *const T, LangId: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechLexiconPronunciation.VTable, self.vtable).get_LangId(@ptrCast(*const ISpeechLexiconPronunciation, self), LangId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechLexiconPronunciation_get_PartOfSpeech(self: *const T, PartOfSpeech: ?*SpeechPartOfSpeech) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechLexiconPronunciation.VTable, self.vtable).get_PartOfSpeech(@ptrCast(*const ISpeechLexiconPronunciation, self), PartOfSpeech);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechLexiconPronunciation_get_PhoneIds(self: *const T, PhoneIds: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechLexiconPronunciation.VTable, self.vtable).get_PhoneIds(@ptrCast(*const ISpeechLexiconPronunciation, self), PhoneIds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechLexiconPronunciation_get_Symbolic(self: *const T, Symbolic: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechLexiconPronunciation.VTable, self.vtable).get_Symbolic(@ptrCast(*const ISpeechLexiconPronunciation, self), Symbolic);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechXMLRecoResult_Value = Guid.initString("aaec54af-8f85-4924-944d-b79d39d72e19");
pub const IID_ISpeechXMLRecoResult = &IID_ISpeechXMLRecoResult_Value;
pub const ISpeechXMLRecoResult = extern struct {
    pub const VTable = extern struct {
        base: ISpeechRecoResult.VTable,
        GetXMLResult: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechXMLRecoResult,
                Options: SPXMLRESULTOPTIONS,
                pResult: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechXMLRecoResult,
                Options: SPXMLRESULTOPTIONS,
                pResult: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetXMLErrorInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechXMLRecoResult,
                LineNumber: ?*i32,
                ScriptLine: ?*?BSTR,
                Source: ?*?BSTR,
                Description: ?*?BSTR,
                ResultCode: ?*i32,
                IsError: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechXMLRecoResult,
                LineNumber: ?*i32,
                ScriptLine: ?*?BSTR,
                Source: ?*?BSTR,
                Description: ?*?BSTR,
                ResultCode: ?*i32,
                IsError: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISpeechRecoResult.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechXMLRecoResult_GetXMLResult(self: *const T, Options: SPXMLRESULTOPTIONS, pResult: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechXMLRecoResult.VTable, self.vtable).GetXMLResult(@ptrCast(*const ISpeechXMLRecoResult, self), Options, pResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechXMLRecoResult_GetXMLErrorInfo(self: *const T, LineNumber: ?*i32, ScriptLine: ?*?BSTR, Source: ?*?BSTR, Description: ?*?BSTR, ResultCode: ?*i32, IsError: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechXMLRecoResult.VTable, self.vtable).GetXMLErrorInfo(@ptrCast(*const ISpeechXMLRecoResult, self), LineNumber, ScriptLine, Source, Description, ResultCode, IsError);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechRecoResultDispatch_Value = Guid.initString("6d60eb64-aced-40a6-bbf3-4e557f71dee2");
pub const IID_ISpeechRecoResultDispatch = &IID_ISpeechRecoResultDispatch_Value;
pub const ISpeechRecoResultDispatch = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RecoContext: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechRecoResultDispatch,
                RecoContext: ?*?*ISpeechRecoContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechRecoResultDispatch,
                RecoContext: ?*?*ISpeechRecoContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Times: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechRecoResultDispatch,
                Times: ?*?*ISpeechRecoResultTimes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechRecoResultDispatch,
                Times: ?*?*ISpeechRecoResultTimes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        putref_AudioFormat: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechRecoResultDispatch,
                Format: ?*ISpeechAudioFormat,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechRecoResultDispatch,
                Format: ?*ISpeechAudioFormat,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AudioFormat: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechRecoResultDispatch,
                Format: ?*?*ISpeechAudioFormat,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechRecoResultDispatch,
                Format: ?*?*ISpeechAudioFormat,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PhraseInfo: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechRecoResultDispatch,
                PhraseInfo: ?*?*ISpeechPhraseInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechRecoResultDispatch,
                PhraseInfo: ?*?*ISpeechPhraseInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Alternates: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechRecoResultDispatch,
                RequestCount: i32,
                StartElement: i32,
                Elements: i32,
                Alternates: ?*?*ISpeechPhraseAlternates,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechRecoResultDispatch,
                RequestCount: i32,
                StartElement: i32,
                Elements: i32,
                Alternates: ?*?*ISpeechPhraseAlternates,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Audio: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechRecoResultDispatch,
                StartElement: i32,
                Elements: i32,
                Stream: ?*?*ISpeechMemoryStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechRecoResultDispatch,
                StartElement: i32,
                Elements: i32,
                Stream: ?*?*ISpeechMemoryStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SpeakAudio: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechRecoResultDispatch,
                StartElement: i32,
                Elements: i32,
                Flags: SpeechVoiceSpeakFlags,
                StreamNumber: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechRecoResultDispatch,
                StartElement: i32,
                Elements: i32,
                Flags: SpeechVoiceSpeakFlags,
                StreamNumber: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SaveToMemory: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechRecoResultDispatch,
                ResultBlock: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechRecoResultDispatch,
                ResultBlock: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DiscardResultInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechRecoResultDispatch,
                ValueTypes: SpeechDiscardType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechRecoResultDispatch,
                ValueTypes: SpeechDiscardType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetXMLResult: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechRecoResultDispatch,
                Options: SPXMLRESULTOPTIONS,
                pResult: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechRecoResultDispatch,
                Options: SPXMLRESULTOPTIONS,
                pResult: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetXMLErrorInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechRecoResultDispatch,
                LineNumber: ?*i32,
                ScriptLine: ?*?BSTR,
                Source: ?*?BSTR,
                Description: ?*?BSTR,
                ResultCode: ?*HRESULT,
                IsError: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechRecoResultDispatch,
                LineNumber: ?*i32,
                ScriptLine: ?*?BSTR,
                Source: ?*?BSTR,
                Description: ?*?BSTR,
                ResultCode: ?*HRESULT,
                IsError: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTextFeedback: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechRecoResultDispatch,
                Feedback: ?BSTR,
                WasSuccessful: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechRecoResultDispatch,
                Feedback: ?BSTR,
                WasSuccessful: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecoResultDispatch_get_RecoContext(self: *const T, RecoContext: ?*?*ISpeechRecoContext) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecoResultDispatch.VTable, self.vtable).get_RecoContext(@ptrCast(*const ISpeechRecoResultDispatch, self), RecoContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecoResultDispatch_get_Times(self: *const T, Times: ?*?*ISpeechRecoResultTimes) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecoResultDispatch.VTable, self.vtable).get_Times(@ptrCast(*const ISpeechRecoResultDispatch, self), Times);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecoResultDispatch_putref_AudioFormat(self: *const T, Format: ?*ISpeechAudioFormat) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecoResultDispatch.VTable, self.vtable).putref_AudioFormat(@ptrCast(*const ISpeechRecoResultDispatch, self), Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecoResultDispatch_get_AudioFormat(self: *const T, Format: ?*?*ISpeechAudioFormat) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecoResultDispatch.VTable, self.vtable).get_AudioFormat(@ptrCast(*const ISpeechRecoResultDispatch, self), Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecoResultDispatch_get_PhraseInfo(self: *const T, PhraseInfo: ?*?*ISpeechPhraseInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecoResultDispatch.VTable, self.vtable).get_PhraseInfo(@ptrCast(*const ISpeechRecoResultDispatch, self), PhraseInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecoResultDispatch_Alternates(self: *const T, RequestCount: i32, StartElement: i32, Elements: i32, Alternates: ?*?*ISpeechPhraseAlternates) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecoResultDispatch.VTable, self.vtable).Alternates(@ptrCast(*const ISpeechRecoResultDispatch, self), RequestCount, StartElement, Elements, Alternates);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecoResultDispatch_Audio(self: *const T, StartElement: i32, Elements: i32, Stream: ?*?*ISpeechMemoryStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecoResultDispatch.VTable, self.vtable).Audio(@ptrCast(*const ISpeechRecoResultDispatch, self), StartElement, Elements, Stream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecoResultDispatch_SpeakAudio(self: *const T, StartElement: i32, Elements: i32, Flags: SpeechVoiceSpeakFlags, StreamNumber: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecoResultDispatch.VTable, self.vtable).SpeakAudio(@ptrCast(*const ISpeechRecoResultDispatch, self), StartElement, Elements, Flags, StreamNumber);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecoResultDispatch_SaveToMemory(self: *const T, ResultBlock: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecoResultDispatch.VTable, self.vtable).SaveToMemory(@ptrCast(*const ISpeechRecoResultDispatch, self), ResultBlock);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecoResultDispatch_DiscardResultInfo(self: *const T, ValueTypes: SpeechDiscardType) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecoResultDispatch.VTable, self.vtable).DiscardResultInfo(@ptrCast(*const ISpeechRecoResultDispatch, self), ValueTypes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecoResultDispatch_GetXMLResult(self: *const T, Options: SPXMLRESULTOPTIONS, pResult: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecoResultDispatch.VTable, self.vtable).GetXMLResult(@ptrCast(*const ISpeechRecoResultDispatch, self), Options, pResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecoResultDispatch_GetXMLErrorInfo(self: *const T, LineNumber: ?*i32, ScriptLine: ?*?BSTR, Source: ?*?BSTR, Description: ?*?BSTR, ResultCode: ?*HRESULT, IsError: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecoResultDispatch.VTable, self.vtable).GetXMLErrorInfo(@ptrCast(*const ISpeechRecoResultDispatch, self), LineNumber, ScriptLine, Source, Description, ResultCode, IsError);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechRecoResultDispatch_SetTextFeedback(self: *const T, Feedback: ?BSTR, WasSuccessful: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechRecoResultDispatch.VTable, self.vtable).SetTextFeedback(@ptrCast(*const ISpeechRecoResultDispatch, self), Feedback, WasSuccessful);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechPhraseInfoBuilder_Value = Guid.initString("3b151836-df3a-4e0a-846c-d2adc9334333");
pub const IID_ISpeechPhraseInfoBuilder = &IID_ISpeechPhraseInfoBuilder_Value;
pub const ISpeechPhraseInfoBuilder = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        RestorePhraseFromMemory: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechPhraseInfoBuilder,
                PhraseInMemory: ?*VARIANT,
                PhraseInfo: ?*?*ISpeechPhraseInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechPhraseInfoBuilder,
                PhraseInMemory: ?*VARIANT,
                PhraseInfo: ?*?*ISpeechPhraseInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechPhraseInfoBuilder_RestorePhraseFromMemory(self: *const T, PhraseInMemory: ?*VARIANT, PhraseInfo: ?*?*ISpeechPhraseInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechPhraseInfoBuilder.VTable, self.vtable).RestorePhraseFromMemory(@ptrCast(*const ISpeechPhraseInfoBuilder, self), PhraseInMemory, PhraseInfo);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechPhoneConverter_Value = Guid.initString("c3e4f353-433f-43d6-89a1-6a62a7054c3d");
pub const IID_ISpeechPhoneConverter = &IID_ISpeechPhoneConverter_Value;
pub const ISpeechPhoneConverter = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LanguageId: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechPhoneConverter,
                LanguageId: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechPhoneConverter,
                LanguageId: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_LanguageId: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISpeechPhoneConverter,
                LanguageId: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISpeechPhoneConverter,
                LanguageId: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PhoneToId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechPhoneConverter,
                Phonemes: ?BSTR,
                IdArray: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechPhoneConverter,
                Phonemes: ?BSTR,
                IdArray: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IdToPhone: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpeechPhoneConverter,
                IdArray: VARIANT,
                Phonemes: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpeechPhoneConverter,
                IdArray: VARIANT,
                Phonemes: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechPhoneConverter_get_LanguageId(self: *const T, LanguageId: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechPhoneConverter.VTable, self.vtable).get_LanguageId(@ptrCast(*const ISpeechPhoneConverter, self), LanguageId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechPhoneConverter_put_LanguageId(self: *const T, LanguageId: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechPhoneConverter.VTable, self.vtable).put_LanguageId(@ptrCast(*const ISpeechPhoneConverter, self), LanguageId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechPhoneConverter_PhoneToId(self: *const T, Phonemes: ?BSTR, IdArray: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechPhoneConverter.VTable, self.vtable).PhoneToId(@ptrCast(*const ISpeechPhoneConverter, self), Phonemes, IdArray);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechPhoneConverter_IdToPhone(self: *const T, IdArray: VARIANT, Phonemes: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechPhoneConverter.VTable, self.vtable).IdToPhone(@ptrCast(*const ISpeechPhoneConverter, self), IdArray, Phonemes);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};


//--------------------------------------------------------------------------------
// Section: Functions (0)
//--------------------------------------------------------------------------------

//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
    },
    .wide => struct {
    },
    .unspecified => if (@import("builtin").is_test) struct {
    } else struct {
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (19)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const BOOL = @import("../foundation.zig").BOOL;
const BSTR = @import("../foundation.zig").BSTR;
const FILETIME = @import("../foundation.zig").FILETIME;
const HANDLE = @import("../foundation.zig").HANDLE;
const HINSTANCE = @import("../foundation.zig").HINSTANCE;
const HKEY = @import("../system/registry.zig").HKEY;
const HRESULT = @import("../foundation.zig").HRESULT;
const HWND = @import("../foundation.zig").HWND;
const IDispatch = @import("../system/com.zig").IDispatch;
const IInternetSecurityManager = @import("../system/com/urlmon.zig").IInternetSecurityManager;
const IServiceProvider = @import("../system/com.zig").IServiceProvider;
const IStream = @import("../system/com.zig").IStream;
const IUnknown = @import("../system/com.zig").IUnknown;
const LPARAM = @import("../foundation.zig").LPARAM;
const PWSTR = @import("../foundation.zig").PWSTR;
const VARIANT = @import("../system/com.zig").VARIANT;
const WAVEFORMATEX = @import("../media/audio.zig").WAVEFORMATEX;
const WPARAM = @import("../foundation.zig").WPARAM;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "SPNOTIFYCALLBACK")) { _ = SPNOTIFYCALLBACK; }

    @setEvalBranchQuota(
        comptime @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        if (decl.is_pub) {
            _ = @field(@This(), decl.name);
        }
    }
}
