//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (224)
//--------------------------------------------------------------------------------
pub const FXEQ_MIN_FRAMERATE = @as(u32, 22000);
pub const FXEQ_MAX_FRAMERATE = @as(u32, 48000);
pub const FXEQ_MIN_FREQUENCY_CENTER = @as(f32, 20);
pub const FXEQ_MAX_FREQUENCY_CENTER = @as(f32, 20000);
pub const FXEQ_DEFAULT_FREQUENCY_CENTER_0 = @as(f32, 100);
pub const FXEQ_DEFAULT_FREQUENCY_CENTER_1 = @as(f32, 800);
pub const FXEQ_DEFAULT_FREQUENCY_CENTER_2 = @as(f32, 2000);
pub const FXEQ_DEFAULT_FREQUENCY_CENTER_3 = @as(f32, 10000);
pub const FXEQ_MIN_GAIN = @as(f32, 1.26e-1);
pub const FXEQ_MAX_GAIN = @as(f32, 7.94e0);
pub const FXEQ_DEFAULT_GAIN = @as(f32, 1);
pub const FXEQ_MIN_BANDWIDTH = @as(f32, 1e-1);
pub const FXEQ_MAX_BANDWIDTH = @as(f32, 2);
pub const FXEQ_DEFAULT_BANDWIDTH = @as(f32, 1);
pub const FXMASTERINGLIMITER_MIN_RELEASE = @as(u32, 1);
pub const FXMASTERINGLIMITER_MAX_RELEASE = @as(u32, 20);
pub const FXMASTERINGLIMITER_DEFAULT_RELEASE = @as(u32, 6);
pub const FXMASTERINGLIMITER_MIN_LOUDNESS = @as(u32, 1);
pub const FXMASTERINGLIMITER_MAX_LOUDNESS = @as(u32, 1800);
pub const FXMASTERINGLIMITER_DEFAULT_LOUDNESS = @as(u32, 1000);
pub const FXREVERB_MIN_DIFFUSION = @as(f32, 0);
pub const FXREVERB_MAX_DIFFUSION = @as(f32, 1);
pub const FXREVERB_DEFAULT_DIFFUSION = @as(f32, 9e-1);
pub const FXREVERB_MIN_ROOMSIZE = @as(f32, 1e-4);
pub const FXREVERB_MAX_ROOMSIZE = @as(f32, 1);
pub const FXREVERB_DEFAULT_ROOMSIZE = @as(f32, 6e-1);
pub const FXLOUDNESS_DEFAULT_MOMENTARY_MS = @as(u32, 400);
pub const FXLOUDNESS_DEFAULT_SHORTTERM_MS = @as(u32, 3000);
pub const FXECHO_MIN_WETDRYMIX = @as(f32, 0);
pub const FXECHO_MAX_WETDRYMIX = @as(f32, 1);
pub const FXECHO_DEFAULT_WETDRYMIX = @as(f32, 5e-1);
pub const FXECHO_MIN_FEEDBACK = @as(f32, 0);
pub const FXECHO_MAX_FEEDBACK = @as(f32, 1);
pub const FXECHO_DEFAULT_FEEDBACK = @as(f32, 5e-1);
pub const FXECHO_MIN_DELAY = @as(f32, 1);
pub const FXECHO_MAX_DELAY = @as(f32, 2000);
pub const FXECHO_DEFAULT_DELAY = @as(f32, 500);
pub const XAUDIO2_DLL_A = "xaudio2_9.dll";
pub const XAUDIO2_DLL_W = "xaudio2_9.dll";
pub const XAUDIO2D_DLL_A = "xaudio2_9d.dll";
pub const XAUDIO2D_DLL_W = "xaudio2_9d.dll";
pub const XAUDIO2_DLL = "xaudio2_9.dll";
pub const XAUDIO2D_DLL = "xaudio2_9d.dll";
pub const XAUDIO2_MAX_BUFFER_BYTES = @as(u32, 2147483648);
pub const XAUDIO2_MAX_QUEUED_BUFFERS = @as(u32, 64);
pub const XAUDIO2_MAX_BUFFERS_SYSTEM = @as(u32, 2);
pub const XAUDIO2_MAX_AUDIO_CHANNELS = @as(u32, 64);
pub const XAUDIO2_MIN_SAMPLE_RATE = @as(u32, 1000);
pub const XAUDIO2_MAX_SAMPLE_RATE = @as(u32, 200000);
pub const XAUDIO2_MAX_VOLUME_LEVEL = @as(f32, 16777216);
pub const XAUDIO2_MAX_FREQ_RATIO = @as(f32, 1024);
pub const XAUDIO2_DEFAULT_FREQ_RATIO = @as(f32, 2);
pub const XAUDIO2_MAX_FILTER_ONEOVERQ = @as(f32, 1.5e0);
pub const XAUDIO2_MAX_FILTER_FREQUENCY = @as(f32, 1);
pub const XAUDIO2_MAX_LOOP_COUNT = @as(u32, 254);
pub const XAUDIO2_MAX_INSTANCES = @as(u32, 8);
pub const XAUDIO2_MAX_RATIO_TIMES_RATE_XMA_MONO = @as(u32, 600000);
pub const XAUDIO2_MAX_RATIO_TIMES_RATE_XMA_MULTICHANNEL = @as(u32, 300000);
pub const XAUDIO2_COMMIT_NOW = @as(u32, 0);
pub const XAUDIO2_COMMIT_ALL = @as(u32, 0);
pub const XAUDIO2_NO_LOOP_REGION = @as(u32, 0);
pub const XAUDIO2_LOOP_INFINITE = @as(u32, 255);
pub const XAUDIO2_DEFAULT_CHANNELS = @as(u32, 0);
pub const XAUDIO2_DEFAULT_SAMPLERATE = @as(u32, 0);
pub const XAUDIO2_DEBUG_ENGINE = @as(u32, 1);
pub const XAUDIO2_VOICE_NOPITCH = @as(u32, 2);
pub const XAUDIO2_VOICE_NOSRC = @as(u32, 4);
pub const XAUDIO2_VOICE_USEFILTER = @as(u32, 8);
pub const XAUDIO2_PLAY_TAILS = @as(u32, 32);
pub const XAUDIO2_END_OF_STREAM = @as(u32, 64);
pub const XAUDIO2_SEND_USEFILTER = @as(u32, 128);
pub const XAUDIO2_VOICE_NOSAMPLESPLAYED = @as(u32, 256);
pub const XAUDIO2_STOP_ENGINE_WHEN_IDLE = @as(u32, 8192);
pub const XAUDIO2_1024_QUANTUM = @as(u32, 32768);
pub const XAUDIO2_NO_VIRTUAL_AUDIO_CLIENT = @as(u32, 65536);
pub const XAUDIO2_DEFAULT_FILTER_FREQUENCY = @as(f32, 1);
pub const XAUDIO2_DEFAULT_FILTER_ONEOVERQ = @as(f32, 1);
pub const XAUDIO2_QUANTUM_NUMERATOR = @as(u32, 1);
pub const XAUDIO2_QUANTUM_DENOMINATOR = @as(u32, 100);
pub const FACILITY_XAUDIO2 = @as(u32, 2198);
pub const XAUDIO2_E_INVALID_CALL = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2003435519));
pub const XAUDIO2_E_XMA_DECODER_ERROR = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2003435518));
pub const XAUDIO2_E_XAPO_CREATION_FAILED = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2003435517));
pub const XAUDIO2_E_DEVICE_INVALIDATED = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2003435516));
pub const Processor1 = @as(u32, 1);
pub const Processor2 = @as(u32, 2);
pub const Processor3 = @as(u32, 4);
pub const Processor4 = @as(u32, 8);
pub const Processor5 = @as(u32, 16);
pub const Processor6 = @as(u32, 32);
pub const Processor7 = @as(u32, 64);
pub const Processor8 = @as(u32, 128);
pub const Processor9 = @as(u32, 256);
pub const Processor10 = @as(u32, 512);
pub const Processor11 = @as(u32, 1024);
pub const Processor12 = @as(u32, 2048);
pub const Processor13 = @as(u32, 4096);
pub const Processor14 = @as(u32, 8192);
pub const Processor15 = @as(u32, 16384);
pub const Processor16 = @as(u32, 32768);
pub const Processor17 = @as(u32, 65536);
pub const Processor18 = @as(u32, 131072);
pub const Processor19 = @as(u32, 262144);
pub const Processor20 = @as(u32, 524288);
pub const Processor21 = @as(u32, 1048576);
pub const Processor22 = @as(u32, 2097152);
pub const Processor23 = @as(u32, 4194304);
pub const Processor24 = @as(u32, 8388608);
pub const Processor25 = @as(u32, 16777216);
pub const Processor26 = @as(u32, 33554432);
pub const Processor27 = @as(u32, 67108864);
pub const Processor28 = @as(u32, 134217728);
pub const Processor29 = @as(u32, 268435456);
pub const Processor30 = @as(u32, 536870912);
pub const Processor31 = @as(u32, 1073741824);
pub const Processor32 = @as(u32, 2147483648);
pub const XAUDIO2_ANY_PROCESSOR = @as(u32, 4294967295);
pub const XAUDIO2_USE_DEFAULT_PROCESSOR = @as(u32, 0);
pub const XAUDIO2_DEFAULT_PROCESSOR = @as(u32, 1);
pub const XAUDIO2_LOG_ERRORS = @as(u32, 1);
pub const XAUDIO2_LOG_WARNINGS = @as(u32, 2);
pub const XAUDIO2_LOG_INFO = @as(u32, 4);
pub const XAUDIO2_LOG_DETAIL = @as(u32, 8);
pub const XAUDIO2_LOG_API_CALLS = @as(u32, 16);
pub const XAUDIO2_LOG_FUNC_CALLS = @as(u32, 32);
pub const XAUDIO2_LOG_TIMING = @as(u32, 64);
pub const XAUDIO2_LOG_LOCKS = @as(u32, 128);
pub const XAUDIO2_LOG_MEMORY = @as(u32, 256);
pub const XAUDIO2_LOG_STREAMING = @as(u32, 4096);
pub const XAUDIO2FX_REVERB_MIN_FRAMERATE = @as(u32, 20000);
pub const XAUDIO2FX_REVERB_MAX_FRAMERATE = @as(u32, 48000);
pub const XAUDIO2FX_REVERB_MIN_WET_DRY_MIX = @as(f32, 0);
pub const XAUDIO2FX_REVERB_MIN_REFLECTIONS_DELAY = @as(u32, 0);
pub const XAUDIO2FX_REVERB_MIN_REVERB_DELAY = @as(u32, 0);
pub const XAUDIO2FX_REVERB_MIN_REAR_DELAY = @as(u32, 0);
pub const XAUDIO2FX_REVERB_MIN_7POINT1_SIDE_DELAY = @as(u32, 0);
pub const XAUDIO2FX_REVERB_MIN_7POINT1_REAR_DELAY = @as(u32, 0);
pub const XAUDIO2FX_REVERB_MIN_POSITION = @as(u32, 0);
pub const XAUDIO2FX_REVERB_MIN_DIFFUSION = @as(u32, 0);
pub const XAUDIO2FX_REVERB_MIN_LOW_EQ_GAIN = @as(u32, 0);
pub const XAUDIO2FX_REVERB_MIN_LOW_EQ_CUTOFF = @as(u32, 0);
pub const XAUDIO2FX_REVERB_MIN_HIGH_EQ_GAIN = @as(u32, 0);
pub const XAUDIO2FX_REVERB_MIN_HIGH_EQ_CUTOFF = @as(u32, 0);
pub const XAUDIO2FX_REVERB_MIN_ROOM_FILTER_FREQ = @as(f32, 20);
pub const XAUDIO2FX_REVERB_MIN_ROOM_FILTER_MAIN = @as(f32, -100);
pub const XAUDIO2FX_REVERB_MIN_ROOM_FILTER_HF = @as(f32, -100);
pub const XAUDIO2FX_REVERB_MIN_REFLECTIONS_GAIN = @as(f32, -100);
pub const XAUDIO2FX_REVERB_MIN_REVERB_GAIN = @as(f32, -100);
pub const XAUDIO2FX_REVERB_MIN_DECAY_TIME = @as(f32, 1e-1);
pub const XAUDIO2FX_REVERB_MIN_DENSITY = @as(f32, 0);
pub const XAUDIO2FX_REVERB_MIN_ROOM_SIZE = @as(f32, 0);
pub const XAUDIO2FX_REVERB_MAX_WET_DRY_MIX = @as(f32, 100);
pub const XAUDIO2FX_REVERB_MAX_REFLECTIONS_DELAY = @as(u32, 300);
pub const XAUDIO2FX_REVERB_MAX_REVERB_DELAY = @as(u32, 85);
pub const XAUDIO2FX_REVERB_MAX_REAR_DELAY = @as(u32, 5);
pub const XAUDIO2FX_REVERB_MAX_7POINT1_SIDE_DELAY = @as(u32, 5);
pub const XAUDIO2FX_REVERB_MAX_7POINT1_REAR_DELAY = @as(u32, 20);
pub const XAUDIO2FX_REVERB_MAX_POSITION = @as(u32, 30);
pub const XAUDIO2FX_REVERB_MAX_DIFFUSION = @as(u32, 15);
pub const XAUDIO2FX_REVERB_MAX_LOW_EQ_GAIN = @as(u32, 12);
pub const XAUDIO2FX_REVERB_MAX_LOW_EQ_CUTOFF = @as(u32, 9);
pub const XAUDIO2FX_REVERB_MAX_HIGH_EQ_GAIN = @as(u32, 8);
pub const XAUDIO2FX_REVERB_MAX_HIGH_EQ_CUTOFF = @as(u32, 14);
pub const XAUDIO2FX_REVERB_MAX_ROOM_FILTER_FREQ = @as(f32, 20000);
pub const XAUDIO2FX_REVERB_MAX_ROOM_FILTER_MAIN = @as(f32, 0);
pub const XAUDIO2FX_REVERB_MAX_ROOM_FILTER_HF = @as(f32, 0);
pub const XAUDIO2FX_REVERB_MAX_REFLECTIONS_GAIN = @as(f32, 20);
pub const XAUDIO2FX_REVERB_MAX_REVERB_GAIN = @as(f32, 20);
pub const XAUDIO2FX_REVERB_MAX_DENSITY = @as(f32, 100);
pub const XAUDIO2FX_REVERB_MAX_ROOM_SIZE = @as(f32, 100);
pub const XAUDIO2FX_REVERB_DEFAULT_WET_DRY_MIX = @as(f32, 100);
pub const XAUDIO2FX_REVERB_DEFAULT_REFLECTIONS_DELAY = @as(u32, 5);
pub const XAUDIO2FX_REVERB_DEFAULT_REVERB_DELAY = @as(u32, 5);
pub const XAUDIO2FX_REVERB_DEFAULT_REAR_DELAY = @as(u32, 5);
pub const XAUDIO2FX_REVERB_DEFAULT_7POINT1_SIDE_DELAY = @as(u32, 5);
pub const XAUDIO2FX_REVERB_DEFAULT_7POINT1_REAR_DELAY = @as(u32, 20);
pub const XAUDIO2FX_REVERB_DEFAULT_POSITION = @as(u32, 6);
pub const XAUDIO2FX_REVERB_DEFAULT_POSITION_MATRIX = @as(u32, 27);
pub const XAUDIO2FX_REVERB_DEFAULT_EARLY_DIFFUSION = @as(u32, 8);
pub const XAUDIO2FX_REVERB_DEFAULT_LATE_DIFFUSION = @as(u32, 8);
pub const XAUDIO2FX_REVERB_DEFAULT_LOW_EQ_GAIN = @as(u32, 8);
pub const XAUDIO2FX_REVERB_DEFAULT_LOW_EQ_CUTOFF = @as(u32, 4);
pub const XAUDIO2FX_REVERB_DEFAULT_HIGH_EQ_GAIN = @as(u32, 8);
pub const XAUDIO2FX_REVERB_DEFAULT_HIGH_EQ_CUTOFF = @as(u32, 4);
pub const XAUDIO2FX_REVERB_DEFAULT_ROOM_FILTER_FREQ = @as(f32, 5000);
pub const XAUDIO2FX_REVERB_DEFAULT_ROOM_FILTER_MAIN = @as(f32, 0);
pub const XAUDIO2FX_REVERB_DEFAULT_ROOM_FILTER_HF = @as(f32, 0);
pub const XAUDIO2FX_REVERB_DEFAULT_REFLECTIONS_GAIN = @as(f32, 0);
pub const XAUDIO2FX_REVERB_DEFAULT_REVERB_GAIN = @as(f32, 0);
pub const XAUDIO2FX_REVERB_DEFAULT_DECAY_TIME = @as(f32, 1);
pub const XAUDIO2FX_REVERB_DEFAULT_DENSITY = @as(f32, 100);
pub const XAUDIO2FX_REVERB_DEFAULT_ROOM_SIZE = @as(f32, 100);
pub const XAUDIO2FX_REVERB_DEFAULT_DISABLE_LATE_FIELD = @as(u32, 0);
pub const HRTF_MAX_GAIN_LIMIT = @as(f32, 12);
pub const HRTF_MIN_GAIN_LIMIT = @as(f32, -96);
pub const HRTF_MIN_UNITY_GAIN_DISTANCE = @as(f32, 5e-2);
pub const HRTF_DEFAULT_UNITY_GAIN_DISTANCE = @as(f32, 1);
pub const FACILITY_XAPO = @as(u32, 2199);
pub const XAPO_E_FORMAT_UNSUPPORTED = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2003369983));
pub const XAPO_MIN_CHANNELS = @as(u32, 1);
pub const XAPO_MAX_CHANNELS = @as(u32, 64);
pub const XAPO_MIN_FRAMERATE = @as(u32, 1000);
pub const XAPO_MAX_FRAMERATE = @as(u32, 200000);
pub const XAPO_REGISTRATION_STRING_LENGTH = @as(u32, 256);
pub const XAPO_FLAG_CHANNELS_MUST_MATCH = @as(u32, 1);
pub const XAPO_FLAG_FRAMERATE_MUST_MATCH = @as(u32, 2);
pub const XAPO_FLAG_BITSPERSAMPLE_MUST_MATCH = @as(u32, 4);
pub const XAPO_FLAG_BUFFERCOUNT_MUST_MATCH = @as(u32, 8);
pub const XAPO_FLAG_INPLACE_REQUIRED = @as(u32, 32);
pub const XAPO_FLAG_INPLACE_SUPPORTED = @as(u32, 16);
pub const SPEAKER_MONO = @as(u32, 4);
pub const X3DAUDIO_HANDLE_BYTESIZE = @as(u32, 20);
pub const X3DAUDIO_PI = @as(f32, 3.1415927e0);
pub const X3DAUDIO_2PI = @as(f32, 6.2831855e0);
pub const X3DAUDIO_SPEED_OF_SOUND = @as(f32, 3.435e2);
pub const X3DAUDIO_CALCULATE_MATRIX = @as(u32, 1);
pub const X3DAUDIO_CALCULATE_DELAY = @as(u32, 2);
pub const X3DAUDIO_CALCULATE_LPF_DIRECT = @as(u32, 4);
pub const X3DAUDIO_CALCULATE_LPF_REVERB = @as(u32, 8);
pub const X3DAUDIO_CALCULATE_REVERB = @as(u32, 16);
pub const X3DAUDIO_CALCULATE_DOPPLER = @as(u32, 32);
pub const X3DAUDIO_CALCULATE_EMITTER_ANGLE = @as(u32, 64);
pub const X3DAUDIO_CALCULATE_ZEROCENTER = @as(u32, 65536);
pub const X3DAUDIO_CALCULATE_REDIRECT_TO_LFE = @as(u32, 131072);

//--------------------------------------------------------------------------------
// Section: Types (51)
//--------------------------------------------------------------------------------
pub const XAPO_REGISTRATION_PROPERTIES = extern struct {
    clsid: Guid align(1),
    FriendlyName: [256]u16 align(1),
    CopyrightInfo: [256]u16 align(1),
    MajorVersion: u32 align(1),
    MinorVersion: u32 align(1),
    Flags: u32 align(1),
    MinInputBufferCount: u32 align(1),
    MaxInputBufferCount: u32 align(1),
    MinOutputBufferCount: u32 align(1),
    MaxOutputBufferCount: u32 align(1),
};

pub const XAPO_LOCKFORPROCESS_PARAMETERS = extern struct {
    pFormat: ?*const WAVEFORMATEX align(1),
    MaxFrameCount: u32 align(1),
};

pub const XAPO_BUFFER_FLAGS = enum(i32) {
    SILENT = 0,
    VALID = 1,
};
pub const XAPO_BUFFER_SILENT = XAPO_BUFFER_FLAGS.SILENT;
pub const XAPO_BUFFER_VALID = XAPO_BUFFER_FLAGS.VALID;

pub const XAPO_PROCESS_BUFFER_PARAMETERS = extern struct {
    pBuffer: ?*anyopaque align(1),
    BufferFlags: XAPO_BUFFER_FLAGS align(1),
    ValidFrameCount: u32 align(1),
};

const IID_IXAPO_Value = Guid.initString("a410b984-9839-4819-a0be-2856ae6b3adb");
pub const IID_IXAPO = &IID_IXAPO_Value;
pub const IXAPO = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetRegistrationProperties: *const fn(
            self: *const IXAPO,
            ppRegistrationProperties: ?*?*XAPO_REGISTRATION_PROPERTIES,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsInputFormatSupported: *const fn(
            self: *const IXAPO,
            pOutputFormat: ?*const WAVEFORMATEX,
            pRequestedInputFormat: ?*const WAVEFORMATEX,
            ppSupportedInputFormat: ?*?*WAVEFORMATEX,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsOutputFormatSupported: *const fn(
            self: *const IXAPO,
            pInputFormat: ?*const WAVEFORMATEX,
            pRequestedOutputFormat: ?*const WAVEFORMATEX,
            ppSupportedOutputFormat: ?*?*WAVEFORMATEX,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Initialize: *const fn(
            self: *const IXAPO,
            // TODO: what to do with BytesParamIndex 1?
            pData: ?*const anyopaque,
            DataByteSize: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: *const fn(
            self: *const IXAPO,
        ) callconv(@import("std").os.windows.WINAPI) void,
        LockForProcess: *const fn(
            self: *const IXAPO,
            InputLockedParameterCount: u32,
            pInputLockedParameters: ?[*]const XAPO_LOCKFORPROCESS_PARAMETERS,
            OutputLockedParameterCount: u32,
            pOutputLockedParameters: ?[*]const XAPO_LOCKFORPROCESS_PARAMETERS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnlockForProcess: *const fn(
            self: *const IXAPO,
        ) callconv(@import("std").os.windows.WINAPI) void,
        Process: *const fn(
            self: *const IXAPO,
            InputProcessParameterCount: u32,
            pInputProcessParameters: ?[*]const XAPO_PROCESS_BUFFER_PARAMETERS,
            OutputProcessParameterCount: u32,
            pOutputProcessParameters: ?[*]XAPO_PROCESS_BUFFER_PARAMETERS,
            IsEnabled: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) void,
        CalcInputFrames: *const fn(
            self: *const IXAPO,
            OutputFrameCount: u32,
        ) callconv(@import("std").os.windows.WINAPI) u32,
        CalcOutputFrames: *const fn(
            self: *const IXAPO,
            InputFrameCount: u32,
        ) callconv(@import("std").os.windows.WINAPI) u32,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn GetRegistrationProperties(self: *const IXAPO, ppRegistrationProperties: ?*?*XAPO_REGISTRATION_PROPERTIES) callconv(.Inline) HRESULT {
        return self.vtable.GetRegistrationProperties(self, ppRegistrationProperties);
    }
    pub fn IsInputFormatSupported(self: *const IXAPO, pOutputFormat: ?*const WAVEFORMATEX, pRequestedInputFormat: ?*const WAVEFORMATEX, ppSupportedInputFormat: ?*?*WAVEFORMATEX) callconv(.Inline) HRESULT {
        return self.vtable.IsInputFormatSupported(self, pOutputFormat, pRequestedInputFormat, ppSupportedInputFormat);
    }
    pub fn IsOutputFormatSupported(self: *const IXAPO, pInputFormat: ?*const WAVEFORMATEX, pRequestedOutputFormat: ?*const WAVEFORMATEX, ppSupportedOutputFormat: ?*?*WAVEFORMATEX) callconv(.Inline) HRESULT {
        return self.vtable.IsOutputFormatSupported(self, pInputFormat, pRequestedOutputFormat, ppSupportedOutputFormat);
    }
    pub fn Initialize(self: *const IXAPO, pData: ?*const anyopaque, DataByteSize: u32) callconv(.Inline) HRESULT {
        return self.vtable.Initialize(self, pData, DataByteSize);
    }
    pub fn Reset(self: *const IXAPO) callconv(.Inline) void {
        return self.vtable.Reset(self);
    }
    pub fn LockForProcess(self: *const IXAPO, InputLockedParameterCount: u32, pInputLockedParameters: ?[*]const XAPO_LOCKFORPROCESS_PARAMETERS, OutputLockedParameterCount: u32, pOutputLockedParameters: ?[*]const XAPO_LOCKFORPROCESS_PARAMETERS) callconv(.Inline) HRESULT {
        return self.vtable.LockForProcess(self, InputLockedParameterCount, pInputLockedParameters, OutputLockedParameterCount, pOutputLockedParameters);
    }
    pub fn UnlockForProcess(self: *const IXAPO) callconv(.Inline) void {
        return self.vtable.UnlockForProcess(self);
    }
    pub fn Process(self: *const IXAPO, InputProcessParameterCount: u32, pInputProcessParameters: ?[*]const XAPO_PROCESS_BUFFER_PARAMETERS, OutputProcessParameterCount: u32, pOutputProcessParameters: ?[*]XAPO_PROCESS_BUFFER_PARAMETERS, IsEnabled: BOOL) callconv(.Inline) void {
        return self.vtable.Process(self, InputProcessParameterCount, pInputProcessParameters, OutputProcessParameterCount, pOutputProcessParameters, IsEnabled);
    }
    pub fn CalcInputFrames(self: *const IXAPO, OutputFrameCount: u32) callconv(.Inline) u32 {
        return self.vtable.CalcInputFrames(self, OutputFrameCount);
    }
    pub fn CalcOutputFrames(self: *const IXAPO, InputFrameCount: u32) callconv(.Inline) u32 {
        return self.vtable.CalcOutputFrames(self, InputFrameCount);
    }
};

const IID_IXAPOParameters_Value = Guid.initString("26d95c66-80f2-499a-ad54-5ae7f01c6d98");
pub const IID_IXAPOParameters = &IID_IXAPOParameters_Value;
pub const IXAPOParameters = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetParameters: *const fn(
            self: *const IXAPOParameters,
            // TODO: what to do with BytesParamIndex 1?
            pParameters: ?*const anyopaque,
            ParameterByteSize: u32,
        ) callconv(@import("std").os.windows.WINAPI) void,
        GetParameters: *const fn(
            self: *const IXAPOParameters,
            // TODO: what to do with BytesParamIndex 1?
            pParameters: ?*anyopaque,
            ParameterByteSize: u32,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn SetParameters(self: *const IXAPOParameters, pParameters: ?*const anyopaque, ParameterByteSize: u32) callconv(.Inline) void {
        return self.vtable.SetParameters(self, pParameters, ParameterByteSize);
    }
    pub fn GetParameters(self: *const IXAPOParameters, pParameters: ?*anyopaque, ParameterByteSize: u32) callconv(.Inline) void {
        return self.vtable.GetParameters(self, pParameters, ParameterByteSize);
    }
};

const CLSID_FXEQ_Value = Guid.initString("f5e01117-d6c4-485a-a3f5-695196f3dbfa");
pub const CLSID_FXEQ = &CLSID_FXEQ_Value;

const CLSID_FXMasteringLimiter_Value = Guid.initString("c4137916-2be1-46fd-8599-441536f49856");
pub const CLSID_FXMasteringLimiter = &CLSID_FXMasteringLimiter_Value;

const CLSID_FXReverb_Value = Guid.initString("7d9aca56-cb68-4807-b632-b137352e8596");
pub const CLSID_FXReverb = &CLSID_FXReverb_Value;

const CLSID_FXEcho_Value = Guid.initString("5039d740-f736-449a-84d3-a56202557b87");
pub const CLSID_FXEcho = &CLSID_FXEcho_Value;

pub const FXEQ_PARAMETERS = extern struct {
    FrequencyCenter0: f32 align(1),
    Gain0: f32 align(1),
    Bandwidth0: f32 align(1),
    FrequencyCenter1: f32 align(1),
    Gain1: f32 align(1),
    Bandwidth1: f32 align(1),
    FrequencyCenter2: f32 align(1),
    Gain2: f32 align(1),
    Bandwidth2: f32 align(1),
    FrequencyCenter3: f32 align(1),
    Gain3: f32 align(1),
    Bandwidth3: f32 align(1),
};

pub const FXMASTERINGLIMITER_PARAMETERS = extern struct {
    Release: u32 align(1),
    Loudness: u32 align(1),
};

pub const FXREVERB_PARAMETERS = extern struct {
    Diffusion: f32 align(1),
    RoomSize: f32 align(1),
};

pub const FXECHO_INITDATA = extern struct {
    MaxDelay: f32 align(1),
};

pub const FXECHO_PARAMETERS = extern struct {
    WetDryMix: f32 align(1),
    Feedback: f32 align(1),
    Delay: f32 align(1),
};

pub const XAUDIO2_VOICE_DETAILS = extern struct {
    CreationFlags: u32 align(1),
    ActiveFlags: u32 align(1),
    InputChannels: u32 align(1),
    InputSampleRate: u32 align(1),
};

pub const XAUDIO2_SEND_DESCRIPTOR = extern struct {
    Flags: u32 align(1),
    pOutputVoice: ?*IXAudio2Voice align(1),
};

pub const XAUDIO2_VOICE_SENDS = extern struct {
    SendCount: u32 align(1),
    pSends: ?*XAUDIO2_SEND_DESCRIPTOR align(1),
};

pub const XAUDIO2_EFFECT_DESCRIPTOR = extern struct {
    pEffect: ?*IUnknown align(1),
    InitialState: BOOL align(1),
    OutputChannels: u32 align(1),
};

pub const XAUDIO2_EFFECT_CHAIN = extern struct {
    EffectCount: u32 align(1),
    pEffectDescriptors: ?*XAUDIO2_EFFECT_DESCRIPTOR align(1),
};

pub const XAUDIO2_FILTER_TYPE = enum(i32) {
    LowPassFilter = 0,
    BandPassFilter = 1,
    HighPassFilter = 2,
    NotchFilter = 3,
    LowPassOnePoleFilter = 4,
    HighPassOnePoleFilter = 5,
};
pub const LowPassFilter = XAUDIO2_FILTER_TYPE.LowPassFilter;
pub const BandPassFilter = XAUDIO2_FILTER_TYPE.BandPassFilter;
pub const HighPassFilter = XAUDIO2_FILTER_TYPE.HighPassFilter;
pub const NotchFilter = XAUDIO2_FILTER_TYPE.NotchFilter;
pub const LowPassOnePoleFilter = XAUDIO2_FILTER_TYPE.LowPassOnePoleFilter;
pub const HighPassOnePoleFilter = XAUDIO2_FILTER_TYPE.HighPassOnePoleFilter;

pub const XAUDIO2_FILTER_PARAMETERS = extern struct {
    Type: XAUDIO2_FILTER_TYPE align(1),
    Frequency: f32 align(1),
    OneOverQ: f32 align(1),
};

pub const XAUDIO2_BUFFER = extern struct {
    Flags: u32 align(1),
    AudioBytes: u32 align(1),
    pAudioData: ?*const u8 align(1),
    PlayBegin: u32 align(1),
    PlayLength: u32 align(1),
    LoopBegin: u32 align(1),
    LoopLength: u32 align(1),
    LoopCount: u32 align(1),
    pContext: ?*anyopaque align(1),
};

pub const XAUDIO2_BUFFER_WMA = extern struct {
    pDecodedPacketCumulativeBytes: ?*const u32 align(1),
    PacketCount: u32 align(1),
};

pub const XAUDIO2_VOICE_STATE = extern struct {
    pCurrentBufferContext: ?*anyopaque align(1),
    BuffersQueued: u32 align(1),
    SamplesPlayed: u64 align(1),
};

pub const XAUDIO2_PERFORMANCE_DATA = extern struct {
    AudioCyclesSinceLastQuery: u64 align(1),
    TotalCyclesSinceLastQuery: u64 align(1),
    MinimumCyclesPerQuantum: u32 align(1),
    MaximumCyclesPerQuantum: u32 align(1),
    MemoryUsageInBytes: u32 align(1),
    CurrentLatencyInSamples: u32 align(1),
    GlitchesSinceEngineStarted: u32 align(1),
    ActiveSourceVoiceCount: u32 align(1),
    TotalSourceVoiceCount: u32 align(1),
    ActiveSubmixVoiceCount: u32 align(1),
    ActiveResamplerCount: u32 align(1),
    ActiveMatrixMixCount: u32 align(1),
    ActiveXmaSourceVoices: u32 align(1),
    ActiveXmaStreams: u32 align(1),
};

pub const XAUDIO2_DEBUG_CONFIGURATION = extern struct {
    TraceMask: u32 align(1),
    BreakMask: u32 align(1),
    LogThreadID: BOOL align(1),
    LogFileline: BOOL align(1),
    LogFunctionName: BOOL align(1),
    LogTiming: BOOL align(1),
};

const IID_IXAudio2_Value = Guid.initString("2b02e3cf-2e0b-4ec3-be45-1b2a3fe7210d");
pub const IID_IXAudio2 = &IID_IXAudio2_Value;
pub const IXAudio2 = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RegisterForCallbacks: *const fn(
            self: *const IXAudio2,
            pCallback: ?*IXAudio2EngineCallback,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterForCallbacks: *const fn(
            self: *const IXAudio2,
            pCallback: ?*IXAudio2EngineCallback,
        ) callconv(@import("std").os.windows.WINAPI) void,
        CreateSourceVoice: *const fn(
            self: *const IXAudio2,
            ppSourceVoice: ?*?*IXAudio2SourceVoice,
            pSourceFormat: ?*const WAVEFORMATEX,
            Flags: u32,
            MaxFrequencyRatio: f32,
            pCallback: ?*IXAudio2VoiceCallback,
            pSendList: ?*const XAUDIO2_VOICE_SENDS,
            pEffectChain: ?*const XAUDIO2_EFFECT_CHAIN,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateSubmixVoice: *const fn(
            self: *const IXAudio2,
            ppSubmixVoice: ?*?*IXAudio2SubmixVoice,
            InputChannels: u32,
            InputSampleRate: u32,
            Flags: u32,
            ProcessingStage: u32,
            pSendList: ?*const XAUDIO2_VOICE_SENDS,
            pEffectChain: ?*const XAUDIO2_EFFECT_CHAIN,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateMasteringVoice: *const fn(
            self: *const IXAudio2,
            ppMasteringVoice: ?*?*IXAudio2MasteringVoice,
            InputChannels: u32,
            InputSampleRate: u32,
            Flags: u32,
            szDeviceId: ?[*:0]const u16,
            pEffectChain: ?*const XAUDIO2_EFFECT_CHAIN,
            StreamCategory: AUDIO_STREAM_CATEGORY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StartEngine: *const fn(
            self: *const IXAudio2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StopEngine: *const fn(
            self: *const IXAudio2,
        ) callconv(@import("std").os.windows.WINAPI) void,
        CommitChanges: *const fn(
            self: *const IXAudio2,
            OperationSet: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPerformanceData: *const fn(
            self: *const IXAudio2,
            pPerfData: ?*XAUDIO2_PERFORMANCE_DATA,
        ) callconv(@import("std").os.windows.WINAPI) void,
        SetDebugConfiguration: *const fn(
            self: *const IXAudio2,
            pDebugConfiguration: ?*const XAUDIO2_DEBUG_CONFIGURATION,
            pReserved: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn RegisterForCallbacks(self: *const IXAudio2, pCallback: ?*IXAudio2EngineCallback) callconv(.Inline) HRESULT {
        return self.vtable.RegisterForCallbacks(self, pCallback);
    }
    pub fn UnregisterForCallbacks(self: *const IXAudio2, pCallback: ?*IXAudio2EngineCallback) callconv(.Inline) void {
        return self.vtable.UnregisterForCallbacks(self, pCallback);
    }
    pub fn CreateSourceVoice(self: *const IXAudio2, ppSourceVoice: ?*?*IXAudio2SourceVoice, pSourceFormat: ?*const WAVEFORMATEX, Flags: u32, MaxFrequencyRatio: f32, pCallback: ?*IXAudio2VoiceCallback, pSendList: ?*const XAUDIO2_VOICE_SENDS, pEffectChain: ?*const XAUDIO2_EFFECT_CHAIN) callconv(.Inline) HRESULT {
        return self.vtable.CreateSourceVoice(self, ppSourceVoice, pSourceFormat, Flags, MaxFrequencyRatio, pCallback, pSendList, pEffectChain);
    }
    pub fn CreateSubmixVoice(self: *const IXAudio2, ppSubmixVoice: ?*?*IXAudio2SubmixVoice, InputChannels: u32, InputSampleRate: u32, Flags: u32, ProcessingStage: u32, pSendList: ?*const XAUDIO2_VOICE_SENDS, pEffectChain: ?*const XAUDIO2_EFFECT_CHAIN) callconv(.Inline) HRESULT {
        return self.vtable.CreateSubmixVoice(self, ppSubmixVoice, InputChannels, InputSampleRate, Flags, ProcessingStage, pSendList, pEffectChain);
    }
    pub fn CreateMasteringVoice(self: *const IXAudio2, ppMasteringVoice: ?*?*IXAudio2MasteringVoice, InputChannels: u32, InputSampleRate: u32, Flags: u32, szDeviceId: ?[*:0]const u16, pEffectChain: ?*const XAUDIO2_EFFECT_CHAIN, StreamCategory: AUDIO_STREAM_CATEGORY) callconv(.Inline) HRESULT {
        return self.vtable.CreateMasteringVoice(self, ppMasteringVoice, InputChannels, InputSampleRate, Flags, szDeviceId, pEffectChain, StreamCategory);
    }
    pub fn StartEngine(self: *const IXAudio2) callconv(.Inline) HRESULT {
        return self.vtable.StartEngine(self);
    }
    pub fn StopEngine(self: *const IXAudio2) callconv(.Inline) void {
        return self.vtable.StopEngine(self);
    }
    pub fn CommitChanges(self: *const IXAudio2, OperationSet: u32) callconv(.Inline) HRESULT {
        return self.vtable.CommitChanges(self, OperationSet);
    }
    pub fn GetPerformanceData(self: *const IXAudio2, pPerfData: ?*XAUDIO2_PERFORMANCE_DATA) callconv(.Inline) void {
        return self.vtable.GetPerformanceData(self, pPerfData);
    }
    pub fn SetDebugConfiguration(self: *const IXAudio2, pDebugConfiguration: ?*const XAUDIO2_DEBUG_CONFIGURATION, pReserved: ?*anyopaque) callconv(.Inline) void {
        return self.vtable.SetDebugConfiguration(self, pDebugConfiguration, pReserved);
    }
};

const IID_IXAudio2Extension_Value = Guid.initString("84ac29bb-d619-44d2-b197-e4acf7df3ed6");
pub const IID_IXAudio2Extension = &IID_IXAudio2Extension_Value;
pub const IXAudio2Extension = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetProcessingQuantum: *const fn(
            self: *const IXAudio2Extension,
            quantumNumerator: ?*u32,
            quantumDenominator: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) void,
        GetProcessor: *const fn(
            self: *const IXAudio2Extension,
            processor: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn GetProcessingQuantum(self: *const IXAudio2Extension, quantumNumerator: ?*u32, quantumDenominator: ?*u32) callconv(.Inline) void {
        return self.vtable.GetProcessingQuantum(self, quantumNumerator, quantumDenominator);
    }
    pub fn GetProcessor(self: *const IXAudio2Extension, processor: ?*u32) callconv(.Inline) void {
        return self.vtable.GetProcessor(self, processor);
    }
};

pub const IXAudio2Voice = extern union {
    pub const VTable = extern struct {
        GetVoiceDetails: *const fn(
            self: *const IXAudio2Voice,
            pVoiceDetails: ?*XAUDIO2_VOICE_DETAILS,
        ) callconv(@import("std").os.windows.WINAPI) void,
        SetOutputVoices: *const fn(
            self: *const IXAudio2Voice,
            pSendList: ?*const XAUDIO2_VOICE_SENDS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEffectChain: *const fn(
            self: *const IXAudio2Voice,
            pEffectChain: ?*const XAUDIO2_EFFECT_CHAIN,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnableEffect: *const fn(
            self: *const IXAudio2Voice,
            EffectIndex: u32,
            OperationSet: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DisableEffect: *const fn(
            self: *const IXAudio2Voice,
            EffectIndex: u32,
            OperationSet: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEffectState: *const fn(
            self: *const IXAudio2Voice,
            EffectIndex: u32,
            pEnabled: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) void,
        SetEffectParameters: *const fn(
            self: *const IXAudio2Voice,
            EffectIndex: u32,
            // TODO: what to do with BytesParamIndex 2?
            pParameters: ?*const anyopaque,
            ParametersByteSize: u32,
            OperationSet: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEffectParameters: *const fn(
            self: *const IXAudio2Voice,
            EffectIndex: u32,
            // TODO: what to do with BytesParamIndex 2?
            pParameters: ?*anyopaque,
            ParametersByteSize: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFilterParameters: *const fn(
            self: *const IXAudio2Voice,
            pParameters: ?*const XAUDIO2_FILTER_PARAMETERS,
            OperationSet: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFilterParameters: *const fn(
            self: *const IXAudio2Voice,
            pParameters: ?*XAUDIO2_FILTER_PARAMETERS,
        ) callconv(@import("std").os.windows.WINAPI) void,
        SetOutputFilterParameters: *const fn(
            self: *const IXAudio2Voice,
            pDestinationVoice: ?*IXAudio2Voice,
            pParameters: ?*const XAUDIO2_FILTER_PARAMETERS,
            OperationSet: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOutputFilterParameters: *const fn(
            self: *const IXAudio2Voice,
            pDestinationVoice: ?*IXAudio2Voice,
            pParameters: ?*XAUDIO2_FILTER_PARAMETERS,
        ) callconv(@import("std").os.windows.WINAPI) void,
        SetVolume: *const fn(
            self: *const IXAudio2Voice,
            Volume: f32,
            OperationSet: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVolume: *const fn(
            self: *const IXAudio2Voice,
            pVolume: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) void,
        SetChannelVolumes: *const fn(
            self: *const IXAudio2Voice,
            Channels: u32,
            pVolumes: [*]const f32,
            OperationSet: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetChannelVolumes: *const fn(
            self: *const IXAudio2Voice,
            Channels: u32,
            pVolumes: [*]f32,
        ) callconv(@import("std").os.windows.WINAPI) void,
        SetOutputMatrix: *const fn(
            self: *const IXAudio2Voice,
            pDestinationVoice: ?*IXAudio2Voice,
            SourceChannels: u32,
            DestinationChannels: u32,
            pLevelMatrix: ?*const f32,
            OperationSet: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOutputMatrix: *const fn(
            self: *const IXAudio2Voice,
            pDestinationVoice: ?*IXAudio2Voice,
            SourceChannels: u32,
            DestinationChannels: u32,
            pLevelMatrix: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) void,
        DestroyVoice: *const fn(
            self: *const IXAudio2Voice,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    pub fn GetVoiceDetails(self: *const IXAudio2Voice, pVoiceDetails: ?*XAUDIO2_VOICE_DETAILS) callconv(.Inline) void {
        return self.vtable.GetVoiceDetails(self, pVoiceDetails);
    }
    pub fn SetOutputVoices(self: *const IXAudio2Voice, pSendList: ?*const XAUDIO2_VOICE_SENDS) callconv(.Inline) HRESULT {
        return self.vtable.SetOutputVoices(self, pSendList);
    }
    pub fn SetEffectChain(self: *const IXAudio2Voice, pEffectChain: ?*const XAUDIO2_EFFECT_CHAIN) callconv(.Inline) HRESULT {
        return self.vtable.SetEffectChain(self, pEffectChain);
    }
    pub fn EnableEffect(self: *const IXAudio2Voice, EffectIndex: u32, OperationSet: u32) callconv(.Inline) HRESULT {
        return self.vtable.EnableEffect(self, EffectIndex, OperationSet);
    }
    pub fn DisableEffect(self: *const IXAudio2Voice, EffectIndex: u32, OperationSet: u32) callconv(.Inline) HRESULT {
        return self.vtable.DisableEffect(self, EffectIndex, OperationSet);
    }
    pub fn GetEffectState(self: *const IXAudio2Voice, EffectIndex: u32, pEnabled: ?*BOOL) callconv(.Inline) void {
        return self.vtable.GetEffectState(self, EffectIndex, pEnabled);
    }
    pub fn SetEffectParameters(self: *const IXAudio2Voice, EffectIndex: u32, pParameters: ?*const anyopaque, ParametersByteSize: u32, OperationSet: u32) callconv(.Inline) HRESULT {
        return self.vtable.SetEffectParameters(self, EffectIndex, pParameters, ParametersByteSize, OperationSet);
    }
    pub fn GetEffectParameters(self: *const IXAudio2Voice, EffectIndex: u32, pParameters: ?*anyopaque, ParametersByteSize: u32) callconv(.Inline) HRESULT {
        return self.vtable.GetEffectParameters(self, EffectIndex, pParameters, ParametersByteSize);
    }
    pub fn SetFilterParameters(self: *const IXAudio2Voice, pParameters: ?*const XAUDIO2_FILTER_PARAMETERS, OperationSet: u32) callconv(.Inline) HRESULT {
        return self.vtable.SetFilterParameters(self, pParameters, OperationSet);
    }
    pub fn GetFilterParameters(self: *const IXAudio2Voice, pParameters: ?*XAUDIO2_FILTER_PARAMETERS) callconv(.Inline) void {
        return self.vtable.GetFilterParameters(self, pParameters);
    }
    pub fn SetOutputFilterParameters(self: *const IXAudio2Voice, pDestinationVoice: ?*IXAudio2Voice, pParameters: ?*const XAUDIO2_FILTER_PARAMETERS, OperationSet: u32) callconv(.Inline) HRESULT {
        return self.vtable.SetOutputFilterParameters(self, pDestinationVoice, pParameters, OperationSet);
    }
    pub fn GetOutputFilterParameters(self: *const IXAudio2Voice, pDestinationVoice: ?*IXAudio2Voice, pParameters: ?*XAUDIO2_FILTER_PARAMETERS) callconv(.Inline) void {
        return self.vtable.GetOutputFilterParameters(self, pDestinationVoice, pParameters);
    }
    pub fn SetVolume(self: *const IXAudio2Voice, Volume: f32, OperationSet: u32) callconv(.Inline) HRESULT {
        return self.vtable.SetVolume(self, Volume, OperationSet);
    }
    pub fn GetVolume(self: *const IXAudio2Voice, pVolume: ?*f32) callconv(.Inline) void {
        return self.vtable.GetVolume(self, pVolume);
    }
    pub fn SetChannelVolumes(self: *const IXAudio2Voice, Channels: u32, pVolumes: [*]const f32, OperationSet: u32) callconv(.Inline) HRESULT {
        return self.vtable.SetChannelVolumes(self, Channels, pVolumes, OperationSet);
    }
    pub fn GetChannelVolumes(self: *const IXAudio2Voice, Channels: u32, pVolumes: [*]f32) callconv(.Inline) void {
        return self.vtable.GetChannelVolumes(self, Channels, pVolumes);
    }
    pub fn SetOutputMatrix(self: *const IXAudio2Voice, pDestinationVoice: ?*IXAudio2Voice, SourceChannels: u32, DestinationChannels: u32, pLevelMatrix: ?*const f32, OperationSet: u32) callconv(.Inline) HRESULT {
        return self.vtable.SetOutputMatrix(self, pDestinationVoice, SourceChannels, DestinationChannels, pLevelMatrix, OperationSet);
    }
    pub fn GetOutputMatrix(self: *const IXAudio2Voice, pDestinationVoice: ?*IXAudio2Voice, SourceChannels: u32, DestinationChannels: u32, pLevelMatrix: ?*f32) callconv(.Inline) void {
        return self.vtable.GetOutputMatrix(self, pDestinationVoice, SourceChannels, DestinationChannels, pLevelMatrix);
    }
    pub fn DestroyVoice(self: *const IXAudio2Voice) callconv(.Inline) void {
        return self.vtable.DestroyVoice(self);
    }
};

pub const IXAudio2SourceVoice = extern union {
    pub const VTable = extern struct {
        base: IXAudio2Voice.VTable,
        Start: *const fn(
            self: *const IXAudio2SourceVoice,
            Flags: u32,
            OperationSet: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Stop: *const fn(
            self: *const IXAudio2SourceVoice,
            Flags: u32,
            OperationSet: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SubmitSourceBuffer: *const fn(
            self: *const IXAudio2SourceVoice,
            pBuffer: ?*const XAUDIO2_BUFFER,
            pBufferWMA: ?*const XAUDIO2_BUFFER_WMA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FlushSourceBuffers: *const fn(
            self: *const IXAudio2SourceVoice,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Discontinuity: *const fn(
            self: *const IXAudio2SourceVoice,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ExitLoop: *const fn(
            self: *const IXAudio2SourceVoice,
            OperationSet: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetState: *const fn(
            self: *const IXAudio2SourceVoice,
            pVoiceState: ?*XAUDIO2_VOICE_STATE,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) void,
        SetFrequencyRatio: *const fn(
            self: *const IXAudio2SourceVoice,
            Ratio: f32,
            OperationSet: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFrequencyRatio: *const fn(
            self: *const IXAudio2SourceVoice,
            pRatio: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) void,
        SetSourceSampleRate: *const fn(
            self: *const IXAudio2SourceVoice,
            NewSourceSampleRate: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IXAudio2Voice: IXAudio2Voice,
    pub fn Start(self: *const IXAudio2SourceVoice, Flags: u32, OperationSet: u32) callconv(.Inline) HRESULT {
        return self.vtable.Start(self, Flags, OperationSet);
    }
    pub fn Stop(self: *const IXAudio2SourceVoice, Flags: u32, OperationSet: u32) callconv(.Inline) HRESULT {
        return self.vtable.Stop(self, Flags, OperationSet);
    }
    pub fn SubmitSourceBuffer(self: *const IXAudio2SourceVoice, pBuffer: ?*const XAUDIO2_BUFFER, pBufferWMA: ?*const XAUDIO2_BUFFER_WMA) callconv(.Inline) HRESULT {
        return self.vtable.SubmitSourceBuffer(self, pBuffer, pBufferWMA);
    }
    pub fn FlushSourceBuffers(self: *const IXAudio2SourceVoice) callconv(.Inline) HRESULT {
        return self.vtable.FlushSourceBuffers(self);
    }
    pub fn Discontinuity(self: *const IXAudio2SourceVoice) callconv(.Inline) HRESULT {
        return self.vtable.Discontinuity(self);
    }
    pub fn ExitLoop(self: *const IXAudio2SourceVoice, OperationSet: u32) callconv(.Inline) HRESULT {
        return self.vtable.ExitLoop(self, OperationSet);
    }
    pub fn GetState(self: *const IXAudio2SourceVoice, pVoiceState: ?*XAUDIO2_VOICE_STATE, Flags: u32) callconv(.Inline) void {
        return self.vtable.GetState(self, pVoiceState, Flags);
    }
    pub fn SetFrequencyRatio(self: *const IXAudio2SourceVoice, Ratio: f32, OperationSet: u32) callconv(.Inline) HRESULT {
        return self.vtable.SetFrequencyRatio(self, Ratio, OperationSet);
    }
    pub fn GetFrequencyRatio(self: *const IXAudio2SourceVoice, pRatio: ?*f32) callconv(.Inline) void {
        return self.vtable.GetFrequencyRatio(self, pRatio);
    }
    pub fn SetSourceSampleRate(self: *const IXAudio2SourceVoice, NewSourceSampleRate: u32) callconv(.Inline) HRESULT {
        return self.vtable.SetSourceSampleRate(self, NewSourceSampleRate);
    }
};

pub const IXAudio2SubmixVoice = extern union {
    pub const VTable = extern struct {
        base: IXAudio2Voice.VTable,
    };
    vtable: *const VTable,
    IXAudio2Voice: IXAudio2Voice,
};

pub const IXAudio2MasteringVoice = extern union {
    pub const VTable = extern struct {
        base: IXAudio2Voice.VTable,
        GetChannelMask: *const fn(
            self: *const IXAudio2MasteringVoice,
            pChannelmask: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IXAudio2Voice: IXAudio2Voice,
    pub fn GetChannelMask(self: *const IXAudio2MasteringVoice, pChannelmask: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.GetChannelMask(self, pChannelmask);
    }
};

pub const IXAudio2EngineCallback = extern union {
    pub const VTable = extern struct {
        OnProcessingPassStart: *const fn(
            self: *const IXAudio2EngineCallback,
        ) callconv(@import("std").os.windows.WINAPI) void,
        OnProcessingPassEnd: *const fn(
            self: *const IXAudio2EngineCallback,
        ) callconv(@import("std").os.windows.WINAPI) void,
        OnCriticalError: *const fn(
            self: *const IXAudio2EngineCallback,
            Error: HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    pub fn OnProcessingPassStart(self: *const IXAudio2EngineCallback) callconv(.Inline) void {
        return self.vtable.OnProcessingPassStart(self);
    }
    pub fn OnProcessingPassEnd(self: *const IXAudio2EngineCallback) callconv(.Inline) void {
        return self.vtable.OnProcessingPassEnd(self);
    }
    pub fn OnCriticalError(self: *const IXAudio2EngineCallback, Error: HRESULT) callconv(.Inline) void {
        return self.vtable.OnCriticalError(self, Error);
    }
};

pub const IXAudio2VoiceCallback = extern union {
    pub const VTable = extern struct {
        OnVoiceProcessingPassStart: *const fn(
            self: *const IXAudio2VoiceCallback,
            BytesRequired: u32,
        ) callconv(@import("std").os.windows.WINAPI) void,
        OnVoiceProcessingPassEnd: *const fn(
            self: *const IXAudio2VoiceCallback,
        ) callconv(@import("std").os.windows.WINAPI) void,
        OnStreamEnd: *const fn(
            self: *const IXAudio2VoiceCallback,
        ) callconv(@import("std").os.windows.WINAPI) void,
        OnBufferStart: *const fn(
            self: *const IXAudio2VoiceCallback,
            pBufferContext: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) void,
        OnBufferEnd: *const fn(
            self: *const IXAudio2VoiceCallback,
            pBufferContext: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) void,
        OnLoopEnd: *const fn(
            self: *const IXAudio2VoiceCallback,
            pBufferContext: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) void,
        OnVoiceError: *const fn(
            self: *const IXAudio2VoiceCallback,
            pBufferContext: ?*anyopaque,
            Error: HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    pub fn OnVoiceProcessingPassStart(self: *const IXAudio2VoiceCallback, BytesRequired: u32) callconv(.Inline) void {
        return self.vtable.OnVoiceProcessingPassStart(self, BytesRequired);
    }
    pub fn OnVoiceProcessingPassEnd(self: *const IXAudio2VoiceCallback) callconv(.Inline) void {
        return self.vtable.OnVoiceProcessingPassEnd(self);
    }
    pub fn OnStreamEnd(self: *const IXAudio2VoiceCallback) callconv(.Inline) void {
        return self.vtable.OnStreamEnd(self);
    }
    pub fn OnBufferStart(self: *const IXAudio2VoiceCallback, pBufferContext: ?*anyopaque) callconv(.Inline) void {
        return self.vtable.OnBufferStart(self, pBufferContext);
    }
    pub fn OnBufferEnd(self: *const IXAudio2VoiceCallback, pBufferContext: ?*anyopaque) callconv(.Inline) void {
        return self.vtable.OnBufferEnd(self, pBufferContext);
    }
    pub fn OnLoopEnd(self: *const IXAudio2VoiceCallback, pBufferContext: ?*anyopaque) callconv(.Inline) void {
        return self.vtable.OnLoopEnd(self, pBufferContext);
    }
    pub fn OnVoiceError(self: *const IXAudio2VoiceCallback, pBufferContext: ?*anyopaque, Error: HRESULT) callconv(.Inline) void {
        return self.vtable.OnVoiceError(self, pBufferContext, Error);
    }
};

const CLSID_AudioVolumeMeter_Value = Guid.initString("4fc3b166-972a-40cf-bc37-7db03db2fba3");
pub const CLSID_AudioVolumeMeter = &CLSID_AudioVolumeMeter_Value;

const CLSID_AudioReverb_Value = Guid.initString("c2633b16-471b-4498-b8c5-4f0959e2ec09");
pub const CLSID_AudioReverb = &CLSID_AudioReverb_Value;

pub const XAUDIO2FX_VOLUMEMETER_LEVELS = extern struct {
    pPeakLevels: ?*f32 align(1),
    pRMSLevels: ?*f32 align(1),
    ChannelCount: u32 align(1),
};

pub const XAUDIO2FX_REVERB_PARAMETERS = extern struct {
    WetDryMix: f32 align(1),
    ReflectionsDelay: u32 align(1),
    ReverbDelay: u8 align(1),
    RearDelay: u8 align(1),
    SideDelay: u8 align(1),
    PositionLeft: u8 align(1),
    PositionRight: u8 align(1),
    PositionMatrixLeft: u8 align(1),
    PositionMatrixRight: u8 align(1),
    EarlyDiffusion: u8 align(1),
    LateDiffusion: u8 align(1),
    LowEQGain: u8 align(1),
    LowEQCutoff: u8 align(1),
    HighEQGain: u8 align(1),
    HighEQCutoff: u8 align(1),
    RoomFilterFreq: f32 align(1),
    RoomFilterMain: f32 align(1),
    RoomFilterHF: f32 align(1),
    ReflectionsGain: f32 align(1),
    ReverbGain: f32 align(1),
    DecayTime: f32 align(1),
    Density: f32 align(1),
    RoomSize: f32 align(1),
    DisableLateField: BOOL align(1),
};

pub const XAUDIO2FX_REVERB_I3DL2_PARAMETERS = extern struct {
    WetDryMix: f32 align(1),
    Room: i32 align(1),
    RoomHF: i32 align(1),
    RoomRolloffFactor: f32 align(1),
    DecayTime: f32 align(1),
    DecayHFRatio: f32 align(1),
    Reflections: i32 align(1),
    ReflectionsDelay: f32 align(1),
    Reverb: i32 align(1),
    ReverbDelay: f32 align(1),
    Diffusion: f32 align(1),
    Density: f32 align(1),
    HFReference: f32 align(1),
};

pub const HrtfPosition = extern struct {
    x: f32,
    y: f32,
    z: f32,
};

pub const HrtfOrientation = extern struct {
    element: [9]f32,
};

pub const HrtfDirectivityType = enum(i32) {
    OmniDirectional = 0,
    Cardioid = 1,
    Cone = 2,
};
pub const OmniDirectional = HrtfDirectivityType.OmniDirectional;
pub const Cardioid = HrtfDirectivityType.Cardioid;
pub const Cone = HrtfDirectivityType.Cone;

pub const HrtfEnvironment = enum(i32) {
    Small = 0,
    Medium = 1,
    Large = 2,
    Outdoors = 3,
};
pub const Small = HrtfEnvironment.Small;
pub const Medium = HrtfEnvironment.Medium;
pub const Large = HrtfEnvironment.Large;
pub const Outdoors = HrtfEnvironment.Outdoors;

pub const HrtfDirectivity = extern struct {
    type: HrtfDirectivityType,
    scaling: f32,
};

pub const HrtfDirectivityCardioid = extern struct {
    directivity: HrtfDirectivity,
    order: f32,
};

pub const HrtfDirectivityCone = extern struct {
    directivity: HrtfDirectivity,
    innerAngle: f32,
    outerAngle: f32,
};

pub const HrtfDistanceDecayType = enum(i32) {
    NaturalDecay = 0,
    CustomDecay = 1,
};
pub const NaturalDecay = HrtfDistanceDecayType.NaturalDecay;
pub const CustomDecay = HrtfDistanceDecayType.CustomDecay;

pub const HrtfDistanceDecay = extern struct {
    type: HrtfDistanceDecayType,
    maxGain: f32,
    minGain: f32,
    unityGainDistance: f32,
    cutoffDistance: f32,
};

pub const HrtfApoInit = extern struct {
    distanceDecay: ?*HrtfDistanceDecay,
    directivity: ?*HrtfDirectivity,
};

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IXAPOHrtfParameters_Value = Guid.initString("15b3cd66-e9de-4464-b6e6-2bc3cf63d455");
pub const IID_IXAPOHrtfParameters = &IID_IXAPOHrtfParameters_Value;
pub const IXAPOHrtfParameters = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetSourcePosition: *const fn(
            self: *const IXAPOHrtfParameters,
            position: ?*const HrtfPosition,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSourceOrientation: *const fn(
            self: *const IXAPOHrtfParameters,
            orientation: ?*const HrtfOrientation,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSourceGain: *const fn(
            self: *const IXAPOHrtfParameters,
            gain: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEnvironment: *const fn(
            self: *const IXAPOHrtfParameters,
            environment: HrtfEnvironment,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn SetSourcePosition(self: *const IXAPOHrtfParameters, position: ?*const HrtfPosition) callconv(.Inline) HRESULT {
        return self.vtable.SetSourcePosition(self, position);
    }
    pub fn SetSourceOrientation(self: *const IXAPOHrtfParameters, orientation: ?*const HrtfOrientation) callconv(.Inline) HRESULT {
        return self.vtable.SetSourceOrientation(self, orientation);
    }
    pub fn SetSourceGain(self: *const IXAPOHrtfParameters, gain: f32) callconv(.Inline) HRESULT {
        return self.vtable.SetSourceGain(self, gain);
    }
    pub fn SetEnvironment(self: *const IXAPOHrtfParameters, environment: HrtfEnvironment) callconv(.Inline) HRESULT {
        return self.vtable.SetEnvironment(self, environment);
    }
};


//--------------------------------------------------------------------------------
// Section: Functions (5)
//--------------------------------------------------------------------------------
pub extern "xaudio2_8" fn CreateFX(
    clsid: ?*const Guid,
    pEffect: ?*?*IUnknown,
    // TODO: what to do with BytesParamIndex 3?
    pInitDat: ?*const anyopaque,
    InitDataByteSize: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "xaudio2_8" fn XAudio2CreateWithVersionInfo(
    ppXAudio2: ?*?*IXAudio2,
    Flags: u32,
    XAudio2Processor: u32,
    ntddiVersion: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "xaudio2_8" fn CreateAudioVolumeMeter(
    ppApo: ?*?*IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "xaudio2_8" fn CreateAudioReverb(
    ppApo: ?*?*IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "hrtfapo" fn CreateHrtfApo(
    init: ?*const HrtfApoInit,
    xApo: **IXAPO,
) callconv(@import("std").os.windows.WINAPI) HRESULT;


//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
//--------------------------------------------------------------------------------
// Section: Imports (7)
//--------------------------------------------------------------------------------
const Guid = @import("../../zig.zig").Guid;
const AUDIO_STREAM_CATEGORY = @import("../../media/audio.zig").AUDIO_STREAM_CATEGORY;
const BOOL = @import("../../foundation.zig").BOOL;
const HRESULT = @import("../../foundation.zig").HRESULT;
const IUnknown = @import("../../system/com.zig").IUnknown;
const PWSTR = @import("../../foundation.zig").PWSTR;
const WAVEFORMATEX = @import("../../media/audio.zig").WAVEFORMATEX;

test {
    @setEvalBranchQuota(
        comptime @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        _ = @field(@This(), decl.name);
    }
}
