//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (218)
//--------------------------------------------------------------------------------
pub const FXEQ_MIN_FRAMERATE = @as(u32, 22000);
pub const FXEQ_MAX_FRAMERATE = @as(u32, 48000);
pub const FXEQ_MIN_FREQUENCY_CENTER = @as(f32, 20);
pub const FXEQ_MAX_FREQUENCY_CENTER = @as(f32, 20000);
pub const FXEQ_DEFAULT_FREQUENCY_CENTER_0 = @as(f32, 100);
pub const FXEQ_DEFAULT_FREQUENCY_CENTER_1 = @as(f32, 800);
pub const FXEQ_DEFAULT_FREQUENCY_CENTER_2 = @as(f32, 2000);
pub const FXEQ_DEFAULT_FREQUENCY_CENTER_3 = @as(f32, 10000);
pub const FXEQ_MIN_GAIN = @as(f32, 1.26e-01);
pub const FXEQ_MAX_GAIN = @as(f32, 7.94e+00);
pub const FXEQ_DEFAULT_GAIN = @as(f32, 1);
pub const FXEQ_MIN_BANDWIDTH = @as(f32, 1.0e-01);
pub const FXEQ_MAX_BANDWIDTH = @as(f32, 2);
pub const FXEQ_DEFAULT_BANDWIDTH = @as(f32, 1);
pub const FXMASTERINGLIMITER_MIN_RELEASE = @as(u32, 1);
pub const FXMASTERINGLIMITER_MAX_RELEASE = @as(u32, 20);
pub const FXMASTERINGLIMITER_DEFAULT_RELEASE = @as(u32, 6);
pub const FXMASTERINGLIMITER_MIN_LOUDNESS = @as(u32, 1);
pub const FXMASTERINGLIMITER_MAX_LOUDNESS = @as(u32, 1800);
pub const FXMASTERINGLIMITER_DEFAULT_LOUDNESS = @as(u32, 1000);
pub const FXREVERB_MIN_DIFFUSION = @as(f32, 0);
pub const FXREVERB_MAX_DIFFUSION = @as(f32, 1);
pub const FXREVERB_DEFAULT_DIFFUSION = @as(f32, 9.0e-01);
pub const FXREVERB_MIN_ROOMSIZE = @as(f32, 1.0e-04);
pub const FXREVERB_MAX_ROOMSIZE = @as(f32, 1);
pub const FXREVERB_DEFAULT_ROOMSIZE = @as(f32, 6.0e-01);
pub const FXLOUDNESS_DEFAULT_MOMENTARY_MS = @as(u32, 400);
pub const FXLOUDNESS_DEFAULT_SHORTTERM_MS = @as(u32, 3000);
pub const FXECHO_MIN_WETDRYMIX = @as(f32, 0);
pub const FXECHO_MAX_WETDRYMIX = @as(f32, 1);
pub const FXECHO_DEFAULT_WETDRYMIX = @as(f32, 5.0e-01);
pub const FXECHO_MIN_FEEDBACK = @as(f32, 0);
pub const FXECHO_MAX_FEEDBACK = @as(f32, 1);
pub const FXECHO_DEFAULT_FEEDBACK = @as(f32, 5.0e-01);
pub const FXECHO_MIN_DELAY = @as(f32, 1);
pub const FXECHO_MAX_DELAY = @as(f32, 2000);
pub const FXECHO_DEFAULT_DELAY = @as(f32, 500);
pub const XAUDIO2_MAX_BUFFER_BYTES = @as(u32, 2147483648);
pub const XAUDIO2_MAX_QUEUED_BUFFERS = @as(u32, 64);
pub const XAUDIO2_MAX_BUFFERS_SYSTEM = @as(u32, 2);
pub const XAUDIO2_MAX_AUDIO_CHANNELS = @as(u32, 64);
pub const XAUDIO2_MIN_SAMPLE_RATE = @as(u32, 1000);
pub const XAUDIO2_MAX_SAMPLE_RATE = @as(u32, 200000);
pub const XAUDIO2_MAX_VOLUME_LEVEL = @as(f32, 16777216);
pub const XAUDIO2_MAX_FREQ_RATIO = @as(f32, 1024);
pub const XAUDIO2_DEFAULT_FREQ_RATIO = @as(f32, 2);
pub const XAUDIO2_MAX_FILTER_ONEOVERQ = @as(f32, 1.5e+00);
pub const XAUDIO2_MAX_FILTER_FREQUENCY = @as(f32, 1);
pub const XAUDIO2_MAX_LOOP_COUNT = @as(u32, 254);
pub const XAUDIO2_MAX_INSTANCES = @as(u32, 8);
pub const XAUDIO2_MAX_RATIO_TIMES_RATE_XMA_MONO = @as(u32, 600000);
pub const XAUDIO2_MAX_RATIO_TIMES_RATE_XMA_MULTICHANNEL = @as(u32, 300000);
pub const XAUDIO2_COMMIT_NOW = @as(u32, 0);
pub const XAUDIO2_COMMIT_ALL = @as(u32, 0);
pub const XAUDIO2_NO_LOOP_REGION = @as(u32, 0);
pub const XAUDIO2_LOOP_INFINITE = @as(u32, 255);
pub const XAUDIO2_DEFAULT_CHANNELS = @as(u32, 0);
pub const XAUDIO2_DEFAULT_SAMPLERATE = @as(u32, 0);
pub const XAUDIO2_DEBUG_ENGINE = @as(u32, 1);
pub const XAUDIO2_VOICE_NOPITCH = @as(u32, 2);
pub const XAUDIO2_VOICE_NOSRC = @as(u32, 4);
pub const XAUDIO2_VOICE_USEFILTER = @as(u32, 8);
pub const XAUDIO2_PLAY_TAILS = @as(u32, 32);
pub const XAUDIO2_END_OF_STREAM = @as(u32, 64);
pub const XAUDIO2_SEND_USEFILTER = @as(u32, 128);
pub const XAUDIO2_VOICE_NOSAMPLESPLAYED = @as(u32, 256);
pub const XAUDIO2_STOP_ENGINE_WHEN_IDLE = @as(u32, 8192);
pub const XAUDIO2_1024_QUANTUM = @as(u32, 32768);
pub const XAUDIO2_NO_VIRTUAL_AUDIO_CLIENT = @as(u32, 65536);
pub const XAUDIO2_DEFAULT_FILTER_FREQUENCY = @as(f32, 1);
pub const XAUDIO2_DEFAULT_FILTER_ONEOVERQ = @as(f32, 1);
pub const XAUDIO2_QUANTUM_NUMERATOR = @as(u32, 1);
pub const XAUDIO2_QUANTUM_DENOMINATOR = @as(u32, 100);
pub const FACILITY_XAUDIO2 = @as(u32, 2198);
pub const XAUDIO2_E_INVALID_CALL = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2003435519));
pub const XAUDIO2_E_XMA_DECODER_ERROR = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2003435518));
pub const XAUDIO2_E_XAPO_CREATION_FAILED = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2003435517));
pub const XAUDIO2_E_DEVICE_INVALIDATED = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2003435516));
pub const Processor1 = @as(u32, 1);
pub const Processor2 = @as(u32, 2);
pub const Processor3 = @as(u32, 4);
pub const Processor4 = @as(u32, 8);
pub const Processor5 = @as(u32, 16);
pub const Processor6 = @as(u32, 32);
pub const Processor7 = @as(u32, 64);
pub const Processor8 = @as(u32, 128);
pub const Processor9 = @as(u32, 256);
pub const Processor10 = @as(u32, 512);
pub const Processor11 = @as(u32, 1024);
pub const Processor12 = @as(u32, 2048);
pub const Processor13 = @as(u32, 4096);
pub const Processor14 = @as(u32, 8192);
pub const Processor15 = @as(u32, 16384);
pub const Processor16 = @as(u32, 32768);
pub const Processor17 = @as(u32, 65536);
pub const Processor18 = @as(u32, 131072);
pub const Processor19 = @as(u32, 262144);
pub const Processor20 = @as(u32, 524288);
pub const Processor21 = @as(u32, 1048576);
pub const Processor22 = @as(u32, 2097152);
pub const Processor23 = @as(u32, 4194304);
pub const Processor24 = @as(u32, 8388608);
pub const Processor25 = @as(u32, 16777216);
pub const Processor26 = @as(u32, 33554432);
pub const Processor27 = @as(u32, 67108864);
pub const Processor28 = @as(u32, 134217728);
pub const Processor29 = @as(u32, 268435456);
pub const Processor30 = @as(u32, 536870912);
pub const Processor31 = @as(u32, 1073741824);
pub const Processor32 = @as(u32, 2147483648);
pub const XAUDIO2_ANY_PROCESSOR = @as(u32, 4294967295);
pub const XAUDIO2_USE_DEFAULT_PROCESSOR = @as(u32, 0);
pub const XAUDIO2_DEFAULT_PROCESSOR = @as(u32, 1);
pub const XAUDIO2_LOG_ERRORS = @as(u32, 1);
pub const XAUDIO2_LOG_WARNINGS = @as(u32, 2);
pub const XAUDIO2_LOG_INFO = @as(u32, 4);
pub const XAUDIO2_LOG_DETAIL = @as(u32, 8);
pub const XAUDIO2_LOG_API_CALLS = @as(u32, 16);
pub const XAUDIO2_LOG_FUNC_CALLS = @as(u32, 32);
pub const XAUDIO2_LOG_TIMING = @as(u32, 64);
pub const XAUDIO2_LOG_LOCKS = @as(u32, 128);
pub const XAUDIO2_LOG_MEMORY = @as(u32, 256);
pub const XAUDIO2_LOG_STREAMING = @as(u32, 4096);
pub const XAUDIO2FX_REVERB_MIN_FRAMERATE = @as(u32, 20000);
pub const XAUDIO2FX_REVERB_MAX_FRAMERATE = @as(u32, 48000);
pub const XAUDIO2FX_REVERB_MIN_WET_DRY_MIX = @as(f32, 0);
pub const XAUDIO2FX_REVERB_MIN_REFLECTIONS_DELAY = @as(u32, 0);
pub const XAUDIO2FX_REVERB_MIN_REVERB_DELAY = @as(u32, 0);
pub const XAUDIO2FX_REVERB_MIN_REAR_DELAY = @as(u32, 0);
pub const XAUDIO2FX_REVERB_MIN_7POINT1_SIDE_DELAY = @as(u32, 0);
pub const XAUDIO2FX_REVERB_MIN_7POINT1_REAR_DELAY = @as(u32, 0);
pub const XAUDIO2FX_REVERB_MIN_POSITION = @as(u32, 0);
pub const XAUDIO2FX_REVERB_MIN_DIFFUSION = @as(u32, 0);
pub const XAUDIO2FX_REVERB_MIN_LOW_EQ_GAIN = @as(u32, 0);
pub const XAUDIO2FX_REVERB_MIN_LOW_EQ_CUTOFF = @as(u32, 0);
pub const XAUDIO2FX_REVERB_MIN_HIGH_EQ_GAIN = @as(u32, 0);
pub const XAUDIO2FX_REVERB_MIN_HIGH_EQ_CUTOFF = @as(u32, 0);
pub const XAUDIO2FX_REVERB_MIN_ROOM_FILTER_FREQ = @as(f32, 20);
pub const XAUDIO2FX_REVERB_MIN_ROOM_FILTER_MAIN = @as(f32, -100);
pub const XAUDIO2FX_REVERB_MIN_ROOM_FILTER_HF = @as(f32, -100);
pub const XAUDIO2FX_REVERB_MIN_REFLECTIONS_GAIN = @as(f32, -100);
pub const XAUDIO2FX_REVERB_MIN_REVERB_GAIN = @as(f32, -100);
pub const XAUDIO2FX_REVERB_MIN_DECAY_TIME = @as(f32, 1.0e-01);
pub const XAUDIO2FX_REVERB_MIN_DENSITY = @as(f32, 0);
pub const XAUDIO2FX_REVERB_MIN_ROOM_SIZE = @as(f32, 0);
pub const XAUDIO2FX_REVERB_MAX_WET_DRY_MIX = @as(f32, 100);
pub const XAUDIO2FX_REVERB_MAX_REFLECTIONS_DELAY = @as(u32, 300);
pub const XAUDIO2FX_REVERB_MAX_REVERB_DELAY = @as(u32, 85);
pub const XAUDIO2FX_REVERB_MAX_REAR_DELAY = @as(u32, 5);
pub const XAUDIO2FX_REVERB_MAX_7POINT1_SIDE_DELAY = @as(u32, 5);
pub const XAUDIO2FX_REVERB_MAX_7POINT1_REAR_DELAY = @as(u32, 20);
pub const XAUDIO2FX_REVERB_MAX_POSITION = @as(u32, 30);
pub const XAUDIO2FX_REVERB_MAX_DIFFUSION = @as(u32, 15);
pub const XAUDIO2FX_REVERB_MAX_LOW_EQ_GAIN = @as(u32, 12);
pub const XAUDIO2FX_REVERB_MAX_LOW_EQ_CUTOFF = @as(u32, 9);
pub const XAUDIO2FX_REVERB_MAX_HIGH_EQ_GAIN = @as(u32, 8);
pub const XAUDIO2FX_REVERB_MAX_HIGH_EQ_CUTOFF = @as(u32, 14);
pub const XAUDIO2FX_REVERB_MAX_ROOM_FILTER_FREQ = @as(f32, 20000);
pub const XAUDIO2FX_REVERB_MAX_ROOM_FILTER_MAIN = @as(f32, 0);
pub const XAUDIO2FX_REVERB_MAX_ROOM_FILTER_HF = @as(f32, 0);
pub const XAUDIO2FX_REVERB_MAX_REFLECTIONS_GAIN = @as(f32, 20);
pub const XAUDIO2FX_REVERB_MAX_REVERB_GAIN = @as(f32, 20);
pub const XAUDIO2FX_REVERB_MAX_DENSITY = @as(f32, 100);
pub const XAUDIO2FX_REVERB_MAX_ROOM_SIZE = @as(f32, 100);
pub const XAUDIO2FX_REVERB_DEFAULT_WET_DRY_MIX = @as(f32, 100);
pub const XAUDIO2FX_REVERB_DEFAULT_REFLECTIONS_DELAY = @as(u32, 5);
pub const XAUDIO2FX_REVERB_DEFAULT_REVERB_DELAY = @as(u32, 5);
pub const XAUDIO2FX_REVERB_DEFAULT_REAR_DELAY = @as(u32, 5);
pub const XAUDIO2FX_REVERB_DEFAULT_7POINT1_SIDE_DELAY = @as(u32, 5);
pub const XAUDIO2FX_REVERB_DEFAULT_7POINT1_REAR_DELAY = @as(u32, 20);
pub const XAUDIO2FX_REVERB_DEFAULT_POSITION = @as(u32, 6);
pub const XAUDIO2FX_REVERB_DEFAULT_POSITION_MATRIX = @as(u32, 27);
pub const XAUDIO2FX_REVERB_DEFAULT_EARLY_DIFFUSION = @as(u32, 8);
pub const XAUDIO2FX_REVERB_DEFAULT_LATE_DIFFUSION = @as(u32, 8);
pub const XAUDIO2FX_REVERB_DEFAULT_LOW_EQ_GAIN = @as(u32, 8);
pub const XAUDIO2FX_REVERB_DEFAULT_LOW_EQ_CUTOFF = @as(u32, 4);
pub const XAUDIO2FX_REVERB_DEFAULT_HIGH_EQ_GAIN = @as(u32, 8);
pub const XAUDIO2FX_REVERB_DEFAULT_HIGH_EQ_CUTOFF = @as(u32, 4);
pub const XAUDIO2FX_REVERB_DEFAULT_ROOM_FILTER_FREQ = @as(f32, 5000);
pub const XAUDIO2FX_REVERB_DEFAULT_ROOM_FILTER_MAIN = @as(f32, 0);
pub const XAUDIO2FX_REVERB_DEFAULT_ROOM_FILTER_HF = @as(f32, 0);
pub const XAUDIO2FX_REVERB_DEFAULT_REFLECTIONS_GAIN = @as(f32, 0);
pub const XAUDIO2FX_REVERB_DEFAULT_REVERB_GAIN = @as(f32, 0);
pub const XAUDIO2FX_REVERB_DEFAULT_DECAY_TIME = @as(f32, 1);
pub const XAUDIO2FX_REVERB_DEFAULT_DENSITY = @as(f32, 100);
pub const XAUDIO2FX_REVERB_DEFAULT_ROOM_SIZE = @as(f32, 100);
pub const XAUDIO2FX_REVERB_DEFAULT_DISABLE_LATE_FIELD = @as(u32, 0);
pub const HRTF_MAX_GAIN_LIMIT = @as(f32, 12);
pub const HRTF_MIN_GAIN_LIMIT = @as(f32, -96);
pub const HRTF_MIN_UNITY_GAIN_DISTANCE = @as(f32, 5.0e-02);
pub const HRTF_DEFAULT_UNITY_GAIN_DISTANCE = @as(f32, 1);
pub const FACILITY_XAPO = @as(u32, 2199);
pub const XAPO_E_FORMAT_UNSUPPORTED = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2003369983));
pub const XAPO_MIN_CHANNELS = @as(u32, 1);
pub const XAPO_MAX_CHANNELS = @as(u32, 64);
pub const XAPO_MIN_FRAMERATE = @as(u32, 1000);
pub const XAPO_MAX_FRAMERATE = @as(u32, 200000);
pub const XAPO_REGISTRATION_STRING_LENGTH = @as(u32, 256);
pub const XAPO_FLAG_CHANNELS_MUST_MATCH = @as(u32, 1);
pub const XAPO_FLAG_FRAMERATE_MUST_MATCH = @as(u32, 2);
pub const XAPO_FLAG_BITSPERSAMPLE_MUST_MATCH = @as(u32, 4);
pub const XAPO_FLAG_BUFFERCOUNT_MUST_MATCH = @as(u32, 8);
pub const XAPO_FLAG_INPLACE_REQUIRED = @as(u32, 32);
pub const XAPO_FLAG_INPLACE_SUPPORTED = @as(u32, 16);
pub const SPEAKER_MONO = @as(u32, 4);
pub const X3DAUDIO_HANDLE_BYTESIZE = @as(u32, 20);
pub const X3DAUDIO_PI = @as(f32, 3.1415927e+00);
pub const X3DAUDIO_2PI = @as(f32, 6.2831855e+00);
pub const X3DAUDIO_SPEED_OF_SOUND = @as(f32, 3.435e+02);
pub const X3DAUDIO_CALCULATE_MATRIX = @as(u32, 1);
pub const X3DAUDIO_CALCULATE_DELAY = @as(u32, 2);
pub const X3DAUDIO_CALCULATE_LPF_DIRECT = @as(u32, 4);
pub const X3DAUDIO_CALCULATE_LPF_REVERB = @as(u32, 8);
pub const X3DAUDIO_CALCULATE_REVERB = @as(u32, 16);
pub const X3DAUDIO_CALCULATE_DOPPLER = @as(u32, 32);
pub const X3DAUDIO_CALCULATE_EMITTER_ANGLE = @as(u32, 64);
pub const X3DAUDIO_CALCULATE_ZEROCENTER = @as(u32, 65536);
pub const X3DAUDIO_CALCULATE_REDIRECT_TO_LFE = @as(u32, 131072);

//--------------------------------------------------------------------------------
// Section: Types (51)
//--------------------------------------------------------------------------------
pub const XAPO_REGISTRATION_PROPERTIES = extern struct {
    clsid: Guid align(1),
    FriendlyName: [256]u16 align(1),
    CopyrightInfo: [256]u16 align(1),
    MajorVersion: u32 align(1),
    MinorVersion: u32 align(1),
    Flags: u32 align(1),
    MinInputBufferCount: u32 align(1),
    MaxInputBufferCount: u32 align(1),
    MinOutputBufferCount: u32 align(1),
    MaxOutputBufferCount: u32 align(1),
};

pub const XAPO_LOCKFORPROCESS_PARAMETERS = extern struct {
    pFormat: ?*const WAVEFORMATEX align(1),
    MaxFrameCount: u32 align(1),
};

pub const XAPO_BUFFER_FLAGS = enum(i32) {
    SILENT = 0,
    VALID = 1,
};
pub const XAPO_BUFFER_SILENT = XAPO_BUFFER_FLAGS.SILENT;
pub const XAPO_BUFFER_VALID = XAPO_BUFFER_FLAGS.VALID;

pub const XAPO_PROCESS_BUFFER_PARAMETERS = extern struct {
    pBuffer: ?*anyopaque align(1),
    BufferFlags: XAPO_BUFFER_FLAGS align(1),
    ValidFrameCount: u32 align(1),
};

const IID_IXAPO_Value = Guid.initString("a410b984-9839-4819-a0be-2856ae6b3adb");
pub const IID_IXAPO = &IID_IXAPO_Value;
pub const IXAPO = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetRegistrationProperties: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXAPO,
                ppRegistrationProperties: ?*?*XAPO_REGISTRATION_PROPERTIES,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXAPO,
                ppRegistrationProperties: ?*?*XAPO_REGISTRATION_PROPERTIES,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsInputFormatSupported: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXAPO,
                pOutputFormat: ?*const WAVEFORMATEX,
                pRequestedInputFormat: ?*const WAVEFORMATEX,
                ppSupportedInputFormat: ?*?*WAVEFORMATEX,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXAPO,
                pOutputFormat: ?*const WAVEFORMATEX,
                pRequestedInputFormat: ?*const WAVEFORMATEX,
                ppSupportedInputFormat: ?*?*WAVEFORMATEX,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsOutputFormatSupported: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXAPO,
                pInputFormat: ?*const WAVEFORMATEX,
                pRequestedOutputFormat: ?*const WAVEFORMATEX,
                ppSupportedOutputFormat: ?*?*WAVEFORMATEX,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXAPO,
                pInputFormat: ?*const WAVEFORMATEX,
                pRequestedOutputFormat: ?*const WAVEFORMATEX,
                ppSupportedOutputFormat: ?*?*WAVEFORMATEX,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXAPO,
                // TODO: what to do with BytesParamIndex 1?
                pData: ?*const anyopaque,
                DataByteSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXAPO,
                // TODO: what to do with BytesParamIndex 1?
                pData: ?*const anyopaque,
                DataByteSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXAPO,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IXAPO,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        LockForProcess: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXAPO,
                InputLockedParameterCount: u32,
                pInputLockedParameters: ?[*]const XAPO_LOCKFORPROCESS_PARAMETERS,
                OutputLockedParameterCount: u32,
                pOutputLockedParameters: ?[*]const XAPO_LOCKFORPROCESS_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXAPO,
                InputLockedParameterCount: u32,
                pInputLockedParameters: ?[*]const XAPO_LOCKFORPROCESS_PARAMETERS,
                OutputLockedParameterCount: u32,
                pOutputLockedParameters: ?[*]const XAPO_LOCKFORPROCESS_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnlockForProcess: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXAPO,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IXAPO,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        Process: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXAPO,
                InputProcessParameterCount: u32,
                pInputProcessParameters: ?[*]const XAPO_PROCESS_BUFFER_PARAMETERS,
                OutputProcessParameterCount: u32,
                pOutputProcessParameters: ?[*]XAPO_PROCESS_BUFFER_PARAMETERS,
                IsEnabled: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IXAPO,
                InputProcessParameterCount: u32,
                pInputProcessParameters: ?[*]const XAPO_PROCESS_BUFFER_PARAMETERS,
                OutputProcessParameterCount: u32,
                pOutputProcessParameters: ?[*]XAPO_PROCESS_BUFFER_PARAMETERS,
                IsEnabled: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        CalcInputFrames: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXAPO,
                OutputFrameCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn (
                self: *const IXAPO,
                OutputFrameCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
        CalcOutputFrames: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXAPO,
                InputFrameCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn (
                self: *const IXAPO,
                InputFrameCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXAPO_GetRegistrationProperties(self: *const T, ppRegistrationProperties: ?*?*XAPO_REGISTRATION_PROPERTIES) HRESULT {
                return @as(*const IXAPO.VTable, @ptrCast(self.vtable)).GetRegistrationProperties(@as(*const IXAPO, @ptrCast(self)), ppRegistrationProperties);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXAPO_IsInputFormatSupported(self: *const T, pOutputFormat: ?*const WAVEFORMATEX, pRequestedInputFormat: ?*const WAVEFORMATEX, ppSupportedInputFormat: ?*?*WAVEFORMATEX) HRESULT {
                return @as(*const IXAPO.VTable, @ptrCast(self.vtable)).IsInputFormatSupported(@as(*const IXAPO, @ptrCast(self)), pOutputFormat, pRequestedInputFormat, ppSupportedInputFormat);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXAPO_IsOutputFormatSupported(self: *const T, pInputFormat: ?*const WAVEFORMATEX, pRequestedOutputFormat: ?*const WAVEFORMATEX, ppSupportedOutputFormat: ?*?*WAVEFORMATEX) HRESULT {
                return @as(*const IXAPO.VTable, @ptrCast(self.vtable)).IsOutputFormatSupported(@as(*const IXAPO, @ptrCast(self)), pInputFormat, pRequestedOutputFormat, ppSupportedOutputFormat);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXAPO_Initialize(self: *const T, pData: ?*const anyopaque, DataByteSize: u32) HRESULT {
                return @as(*const IXAPO.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IXAPO, @ptrCast(self)), pData, DataByteSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXAPO_Reset(self: *const T) void {
                return @as(*const IXAPO.VTable, @ptrCast(self.vtable)).Reset(@as(*const IXAPO, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXAPO_LockForProcess(self: *const T, InputLockedParameterCount: u32, pInputLockedParameters: ?[*]const XAPO_LOCKFORPROCESS_PARAMETERS, OutputLockedParameterCount: u32, pOutputLockedParameters: ?[*]const XAPO_LOCKFORPROCESS_PARAMETERS) HRESULT {
                return @as(*const IXAPO.VTable, @ptrCast(self.vtable)).LockForProcess(@as(*const IXAPO, @ptrCast(self)), InputLockedParameterCount, pInputLockedParameters, OutputLockedParameterCount, pOutputLockedParameters);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXAPO_UnlockForProcess(self: *const T) void {
                return @as(*const IXAPO.VTable, @ptrCast(self.vtable)).UnlockForProcess(@as(*const IXAPO, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXAPO_Process(self: *const T, InputProcessParameterCount: u32, pInputProcessParameters: ?[*]const XAPO_PROCESS_BUFFER_PARAMETERS, OutputProcessParameterCount: u32, pOutputProcessParameters: ?[*]XAPO_PROCESS_BUFFER_PARAMETERS, IsEnabled: BOOL) void {
                return @as(*const IXAPO.VTable, @ptrCast(self.vtable)).Process(@as(*const IXAPO, @ptrCast(self)), InputProcessParameterCount, pInputProcessParameters, OutputProcessParameterCount, pOutputProcessParameters, IsEnabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXAPO_CalcInputFrames(self: *const T, OutputFrameCount: u32) u32 {
                return @as(*const IXAPO.VTable, @ptrCast(self.vtable)).CalcInputFrames(@as(*const IXAPO, @ptrCast(self)), OutputFrameCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXAPO_CalcOutputFrames(self: *const T, InputFrameCount: u32) u32 {
                return @as(*const IXAPO.VTable, @ptrCast(self.vtable)).CalcOutputFrames(@as(*const IXAPO, @ptrCast(self)), InputFrameCount);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IXAPOParameters_Value = Guid.initString("26d95c66-80f2-499a-ad54-5ae7f01c6d98");
pub const IID_IXAPOParameters = &IID_IXAPOParameters_Value;
pub const IXAPOParameters = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXAPOParameters,
                // TODO: what to do with BytesParamIndex 1?
                pParameters: ?*const anyopaque,
                ParameterByteSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IXAPOParameters,
                // TODO: what to do with BytesParamIndex 1?
                pParameters: ?*const anyopaque,
                ParameterByteSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        GetParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXAPOParameters,
                // TODO: what to do with BytesParamIndex 1?
                pParameters: ?*anyopaque,
                ParameterByteSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IXAPOParameters,
                // TODO: what to do with BytesParamIndex 1?
                pParameters: ?*anyopaque,
                ParameterByteSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXAPOParameters_SetParameters(self: *const T, pParameters: ?*const anyopaque, ParameterByteSize: u32) void {
                return @as(*const IXAPOParameters.VTable, @ptrCast(self.vtable)).SetParameters(@as(*const IXAPOParameters, @ptrCast(self)), pParameters, ParameterByteSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXAPOParameters_GetParameters(self: *const T, pParameters: ?*anyopaque, ParameterByteSize: u32) void {
                return @as(*const IXAPOParameters.VTable, @ptrCast(self.vtable)).GetParameters(@as(*const IXAPOParameters, @ptrCast(self)), pParameters, ParameterByteSize);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const CLSID_FXEQ_Value = Guid.initString("f5e01117-d6c4-485a-a3f5-695196f3dbfa");
pub const CLSID_FXEQ = &CLSID_FXEQ_Value;

const CLSID_FXMasteringLimiter_Value = Guid.initString("c4137916-2be1-46fd-8599-441536f49856");
pub const CLSID_FXMasteringLimiter = &CLSID_FXMasteringLimiter_Value;

const CLSID_FXReverb_Value = Guid.initString("7d9aca56-cb68-4807-b632-b137352e8596");
pub const CLSID_FXReverb = &CLSID_FXReverb_Value;

const CLSID_FXEcho_Value = Guid.initString("5039d740-f736-449a-84d3-a56202557b87");
pub const CLSID_FXEcho = &CLSID_FXEcho_Value;

pub const FXEQ_PARAMETERS = extern struct {
    FrequencyCenter0: f32 align(1),
    Gain0: f32 align(1),
    Bandwidth0: f32 align(1),
    FrequencyCenter1: f32 align(1),
    Gain1: f32 align(1),
    Bandwidth1: f32 align(1),
    FrequencyCenter2: f32 align(1),
    Gain2: f32 align(1),
    Bandwidth2: f32 align(1),
    FrequencyCenter3: f32 align(1),
    Gain3: f32 align(1),
    Bandwidth3: f32 align(1),
};

pub const FXMASTERINGLIMITER_PARAMETERS = extern struct {
    Release: u32 align(1),
    Loudness: u32 align(1),
};

pub const FXREVERB_PARAMETERS = extern struct {
    Diffusion: f32 align(1),
    RoomSize: f32 align(1),
};

pub const FXECHO_INITDATA = extern struct {
    MaxDelay: f32 align(1),
};

pub const FXECHO_PARAMETERS = extern struct {
    WetDryMix: f32 align(1),
    Feedback: f32 align(1),
    Delay: f32 align(1),
};

pub const XAUDIO2_VOICE_DETAILS = extern struct {
    CreationFlags: u32 align(1),
    ActiveFlags: u32 align(1),
    InputChannels: u32 align(1),
    InputSampleRate: u32 align(1),
};

pub const XAUDIO2_SEND_DESCRIPTOR = extern struct {
    Flags: u32 align(1),
    pOutputVoice: ?*IXAudio2Voice align(1),
};

pub const XAUDIO2_VOICE_SENDS = extern struct {
    SendCount: u32 align(1),
    pSends: ?*XAUDIO2_SEND_DESCRIPTOR align(1),
};

pub const XAUDIO2_EFFECT_DESCRIPTOR = extern struct {
    pEffect: ?*IUnknown align(1),
    InitialState: BOOL align(1),
    OutputChannels: u32 align(1),
};

pub const XAUDIO2_EFFECT_CHAIN = extern struct {
    EffectCount: u32 align(1),
    pEffectDescriptors: ?*XAUDIO2_EFFECT_DESCRIPTOR align(1),
};

pub const XAUDIO2_FILTER_TYPE = enum(i32) {
    LowPassFilter = 0,
    BandPassFilter = 1,
    HighPassFilter = 2,
    NotchFilter = 3,
    LowPassOnePoleFilter = 4,
    HighPassOnePoleFilter = 5,
};
pub const LowPassFilter = XAUDIO2_FILTER_TYPE.LowPassFilter;
pub const BandPassFilter = XAUDIO2_FILTER_TYPE.BandPassFilter;
pub const HighPassFilter = XAUDIO2_FILTER_TYPE.HighPassFilter;
pub const NotchFilter = XAUDIO2_FILTER_TYPE.NotchFilter;
pub const LowPassOnePoleFilter = XAUDIO2_FILTER_TYPE.LowPassOnePoleFilter;
pub const HighPassOnePoleFilter = XAUDIO2_FILTER_TYPE.HighPassOnePoleFilter;

pub const XAUDIO2_FILTER_PARAMETERS = extern struct {
    Type: XAUDIO2_FILTER_TYPE align(1),
    Frequency: f32 align(1),
    OneOverQ: f32 align(1),
};

pub const XAUDIO2_BUFFER = extern struct {
    Flags: u32 align(1),
    AudioBytes: u32 align(1),
    pAudioData: ?*const u8 align(1),
    PlayBegin: u32 align(1),
    PlayLength: u32 align(1),
    LoopBegin: u32 align(1),
    LoopLength: u32 align(1),
    LoopCount: u32 align(1),
    pContext: ?*anyopaque align(1),
};

pub const XAUDIO2_BUFFER_WMA = extern struct {
    pDecodedPacketCumulativeBytes: ?*const u32 align(1),
    PacketCount: u32 align(1),
};

pub const XAUDIO2_VOICE_STATE = extern struct {
    pCurrentBufferContext: ?*anyopaque align(1),
    BuffersQueued: u32 align(1),
    SamplesPlayed: u64 align(1),
};

pub const XAUDIO2_PERFORMANCE_DATA = extern struct {
    AudioCyclesSinceLastQuery: u64 align(1),
    TotalCyclesSinceLastQuery: u64 align(1),
    MinimumCyclesPerQuantum: u32 align(1),
    MaximumCyclesPerQuantum: u32 align(1),
    MemoryUsageInBytes: u32 align(1),
    CurrentLatencyInSamples: u32 align(1),
    GlitchesSinceEngineStarted: u32 align(1),
    ActiveSourceVoiceCount: u32 align(1),
    TotalSourceVoiceCount: u32 align(1),
    ActiveSubmixVoiceCount: u32 align(1),
    ActiveResamplerCount: u32 align(1),
    ActiveMatrixMixCount: u32 align(1),
    ActiveXmaSourceVoices: u32 align(1),
    ActiveXmaStreams: u32 align(1),
};

pub const XAUDIO2_DEBUG_CONFIGURATION = extern struct {
    TraceMask: u32 align(1),
    BreakMask: u32 align(1),
    LogThreadID: BOOL align(1),
    LogFileline: BOOL align(1),
    LogFunctionName: BOOL align(1),
    LogTiming: BOOL align(1),
};

const IID_IXAudio2_Value = Guid.initString("2b02e3cf-2e0b-4ec3-be45-1b2a3fe7210d");
pub const IID_IXAudio2 = &IID_IXAudio2_Value;
pub const IXAudio2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RegisterForCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXAudio2,
                pCallback: ?*IXAudio2EngineCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXAudio2,
                pCallback: ?*IXAudio2EngineCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnregisterForCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXAudio2,
                pCallback: ?*IXAudio2EngineCallback,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IXAudio2,
                pCallback: ?*IXAudio2EngineCallback,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        CreateSourceVoice: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXAudio2,
                ppSourceVoice: ?*?*IXAudio2SourceVoice,
                pSourceFormat: ?*const WAVEFORMATEX,
                Flags: u32,
                MaxFrequencyRatio: f32,
                pCallback: ?*IXAudio2VoiceCallback,
                pSendList: ?*const XAUDIO2_VOICE_SENDS,
                pEffectChain: ?*const XAUDIO2_EFFECT_CHAIN,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXAudio2,
                ppSourceVoice: ?*?*IXAudio2SourceVoice,
                pSourceFormat: ?*const WAVEFORMATEX,
                Flags: u32,
                MaxFrequencyRatio: f32,
                pCallback: ?*IXAudio2VoiceCallback,
                pSendList: ?*const XAUDIO2_VOICE_SENDS,
                pEffectChain: ?*const XAUDIO2_EFFECT_CHAIN,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateSubmixVoice: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXAudio2,
                ppSubmixVoice: ?*?*IXAudio2SubmixVoice,
                InputChannels: u32,
                InputSampleRate: u32,
                Flags: u32,
                ProcessingStage: u32,
                pSendList: ?*const XAUDIO2_VOICE_SENDS,
                pEffectChain: ?*const XAUDIO2_EFFECT_CHAIN,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXAudio2,
                ppSubmixVoice: ?*?*IXAudio2SubmixVoice,
                InputChannels: u32,
                InputSampleRate: u32,
                Flags: u32,
                ProcessingStage: u32,
                pSendList: ?*const XAUDIO2_VOICE_SENDS,
                pEffectChain: ?*const XAUDIO2_EFFECT_CHAIN,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateMasteringVoice: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXAudio2,
                ppMasteringVoice: ?*?*IXAudio2MasteringVoice,
                InputChannels: u32,
                InputSampleRate: u32,
                Flags: u32,
                szDeviceId: ?[*:0]const u16,
                pEffectChain: ?*const XAUDIO2_EFFECT_CHAIN,
                StreamCategory: AUDIO_STREAM_CATEGORY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXAudio2,
                ppMasteringVoice: ?*?*IXAudio2MasteringVoice,
                InputChannels: u32,
                InputSampleRate: u32,
                Flags: u32,
                szDeviceId: ?[*:0]const u16,
                pEffectChain: ?*const XAUDIO2_EFFECT_CHAIN,
                StreamCategory: AUDIO_STREAM_CATEGORY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartEngine: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXAudio2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXAudio2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StopEngine: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXAudio2,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IXAudio2,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        CommitChanges: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXAudio2,
                OperationSet: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXAudio2,
                OperationSet: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPerformanceData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXAudio2,
                pPerfData: ?*XAUDIO2_PERFORMANCE_DATA,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IXAudio2,
                pPerfData: ?*XAUDIO2_PERFORMANCE_DATA,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        SetDebugConfiguration: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXAudio2,
                pDebugConfiguration: ?*const XAUDIO2_DEBUG_CONFIGURATION,
                pReserved: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IXAudio2,
                pDebugConfiguration: ?*const XAUDIO2_DEBUG_CONFIGURATION,
                pReserved: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXAudio2_RegisterForCallbacks(self: *const T, pCallback: ?*IXAudio2EngineCallback) HRESULT {
                return @as(*const IXAudio2.VTable, @ptrCast(self.vtable)).RegisterForCallbacks(@as(*const IXAudio2, @ptrCast(self)), pCallback);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXAudio2_UnregisterForCallbacks(self: *const T, pCallback: ?*IXAudio2EngineCallback) void {
                return @as(*const IXAudio2.VTable, @ptrCast(self.vtable)).UnregisterForCallbacks(@as(*const IXAudio2, @ptrCast(self)), pCallback);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXAudio2_CreateSourceVoice(self: *const T, ppSourceVoice: ?*?*IXAudio2SourceVoice, pSourceFormat: ?*const WAVEFORMATEX, Flags: u32, MaxFrequencyRatio: f32, pCallback: ?*IXAudio2VoiceCallback, pSendList: ?*const XAUDIO2_VOICE_SENDS, pEffectChain: ?*const XAUDIO2_EFFECT_CHAIN) HRESULT {
                return @as(*const IXAudio2.VTable, @ptrCast(self.vtable)).CreateSourceVoice(@as(*const IXAudio2, @ptrCast(self)), ppSourceVoice, pSourceFormat, Flags, MaxFrequencyRatio, pCallback, pSendList, pEffectChain);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXAudio2_CreateSubmixVoice(self: *const T, ppSubmixVoice: ?*?*IXAudio2SubmixVoice, InputChannels: u32, InputSampleRate: u32, Flags: u32, ProcessingStage: u32, pSendList: ?*const XAUDIO2_VOICE_SENDS, pEffectChain: ?*const XAUDIO2_EFFECT_CHAIN) HRESULT {
                return @as(*const IXAudio2.VTable, @ptrCast(self.vtable)).CreateSubmixVoice(@as(*const IXAudio2, @ptrCast(self)), ppSubmixVoice, InputChannels, InputSampleRate, Flags, ProcessingStage, pSendList, pEffectChain);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXAudio2_CreateMasteringVoice(self: *const T, ppMasteringVoice: ?*?*IXAudio2MasteringVoice, InputChannels: u32, InputSampleRate: u32, Flags: u32, szDeviceId: ?[*:0]const u16, pEffectChain: ?*const XAUDIO2_EFFECT_CHAIN, StreamCategory: AUDIO_STREAM_CATEGORY) HRESULT {
                return @as(*const IXAudio2.VTable, @ptrCast(self.vtable)).CreateMasteringVoice(@as(*const IXAudio2, @ptrCast(self)), ppMasteringVoice, InputChannels, InputSampleRate, Flags, szDeviceId, pEffectChain, StreamCategory);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXAudio2_StartEngine(self: *const T) HRESULT {
                return @as(*const IXAudio2.VTable, @ptrCast(self.vtable)).StartEngine(@as(*const IXAudio2, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXAudio2_StopEngine(self: *const T) void {
                return @as(*const IXAudio2.VTable, @ptrCast(self.vtable)).StopEngine(@as(*const IXAudio2, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXAudio2_CommitChanges(self: *const T, OperationSet: u32) HRESULT {
                return @as(*const IXAudio2.VTable, @ptrCast(self.vtable)).CommitChanges(@as(*const IXAudio2, @ptrCast(self)), OperationSet);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXAudio2_GetPerformanceData(self: *const T, pPerfData: ?*XAUDIO2_PERFORMANCE_DATA) void {
                return @as(*const IXAudio2.VTable, @ptrCast(self.vtable)).GetPerformanceData(@as(*const IXAudio2, @ptrCast(self)), pPerfData);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXAudio2_SetDebugConfiguration(self: *const T, pDebugConfiguration: ?*const XAUDIO2_DEBUG_CONFIGURATION, pReserved: ?*anyopaque) void {
                return @as(*const IXAudio2.VTable, @ptrCast(self.vtable)).SetDebugConfiguration(@as(*const IXAudio2, @ptrCast(self)), pDebugConfiguration, pReserved);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IXAudio2Extension_Value = Guid.initString("84ac29bb-d619-44d2-b197-e4acf7df3ed6");
pub const IID_IXAudio2Extension = &IID_IXAudio2Extension_Value;
pub const IXAudio2Extension = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetProcessingQuantum: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXAudio2Extension,
                quantumNumerator: ?*u32,
                quantumDenominator: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IXAudio2Extension,
                quantumNumerator: ?*u32,
                quantumDenominator: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        GetProcessor: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXAudio2Extension,
                processor: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IXAudio2Extension,
                processor: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXAudio2Extension_GetProcessingQuantum(self: *const T, quantumNumerator: ?*u32, quantumDenominator: ?*u32) void {
                return @as(*const IXAudio2Extension.VTable, @ptrCast(self.vtable)).GetProcessingQuantum(@as(*const IXAudio2Extension, @ptrCast(self)), quantumNumerator, quantumDenominator);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXAudio2Extension_GetProcessor(self: *const T, processor: ?*u32) void {
                return @as(*const IXAudio2Extension.VTable, @ptrCast(self.vtable)).GetProcessor(@as(*const IXAudio2Extension, @ptrCast(self)), processor);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const IXAudio2Voice = extern struct {
    pub const VTable = extern struct {
        GetVoiceDetails: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXAudio2Voice,
                pVoiceDetails: ?*XAUDIO2_VOICE_DETAILS,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IXAudio2Voice,
                pVoiceDetails: ?*XAUDIO2_VOICE_DETAILS,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        SetOutputVoices: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXAudio2Voice,
                pSendList: ?*const XAUDIO2_VOICE_SENDS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXAudio2Voice,
                pSendList: ?*const XAUDIO2_VOICE_SENDS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEffectChain: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXAudio2Voice,
                pEffectChain: ?*const XAUDIO2_EFFECT_CHAIN,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXAudio2Voice,
                pEffectChain: ?*const XAUDIO2_EFFECT_CHAIN,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnableEffect: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXAudio2Voice,
                EffectIndex: u32,
                OperationSet: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXAudio2Voice,
                EffectIndex: u32,
                OperationSet: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DisableEffect: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXAudio2Voice,
                EffectIndex: u32,
                OperationSet: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXAudio2Voice,
                EffectIndex: u32,
                OperationSet: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEffectState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXAudio2Voice,
                EffectIndex: u32,
                pEnabled: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IXAudio2Voice,
                EffectIndex: u32,
                pEnabled: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        SetEffectParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXAudio2Voice,
                EffectIndex: u32,
                // TODO: what to do with BytesParamIndex 2?
                pParameters: ?*const anyopaque,
                ParametersByteSize: u32,
                OperationSet: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXAudio2Voice,
                EffectIndex: u32,
                // TODO: what to do with BytesParamIndex 2?
                pParameters: ?*const anyopaque,
                ParametersByteSize: u32,
                OperationSet: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEffectParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXAudio2Voice,
                EffectIndex: u32,
                // TODO: what to do with BytesParamIndex 2?
                pParameters: ?*anyopaque,
                ParametersByteSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXAudio2Voice,
                EffectIndex: u32,
                // TODO: what to do with BytesParamIndex 2?
                pParameters: ?*anyopaque,
                ParametersByteSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFilterParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXAudio2Voice,
                pParameters: ?*const XAUDIO2_FILTER_PARAMETERS,
                OperationSet: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXAudio2Voice,
                pParameters: ?*const XAUDIO2_FILTER_PARAMETERS,
                OperationSet: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFilterParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXAudio2Voice,
                pParameters: ?*XAUDIO2_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IXAudio2Voice,
                pParameters: ?*XAUDIO2_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        SetOutputFilterParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXAudio2Voice,
                pDestinationVoice: ?*IXAudio2Voice,
                pParameters: ?*const XAUDIO2_FILTER_PARAMETERS,
                OperationSet: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXAudio2Voice,
                pDestinationVoice: ?*IXAudio2Voice,
                pParameters: ?*const XAUDIO2_FILTER_PARAMETERS,
                OperationSet: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputFilterParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXAudio2Voice,
                pDestinationVoice: ?*IXAudio2Voice,
                pParameters: ?*XAUDIO2_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IXAudio2Voice,
                pDestinationVoice: ?*IXAudio2Voice,
                pParameters: ?*XAUDIO2_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        SetVolume: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXAudio2Voice,
                Volume: f32,
                OperationSet: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXAudio2Voice,
                Volume: f32,
                OperationSet: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVolume: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXAudio2Voice,
                pVolume: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IXAudio2Voice,
                pVolume: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        SetChannelVolumes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXAudio2Voice,
                Channels: u32,
                pVolumes: [*]const f32,
                OperationSet: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXAudio2Voice,
                Channels: u32,
                pVolumes: [*]const f32,
                OperationSet: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetChannelVolumes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXAudio2Voice,
                Channels: u32,
                pVolumes: [*]f32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IXAudio2Voice,
                Channels: u32,
                pVolumes: [*]f32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        SetOutputMatrix: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXAudio2Voice,
                pDestinationVoice: ?*IXAudio2Voice,
                SourceChannels: u32,
                DestinationChannels: u32,
                pLevelMatrix: ?*const f32,
                OperationSet: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXAudio2Voice,
                pDestinationVoice: ?*IXAudio2Voice,
                SourceChannels: u32,
                DestinationChannels: u32,
                pLevelMatrix: ?*const f32,
                OperationSet: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputMatrix: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXAudio2Voice,
                pDestinationVoice: ?*IXAudio2Voice,
                SourceChannels: u32,
                DestinationChannels: u32,
                pLevelMatrix: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IXAudio2Voice,
                pDestinationVoice: ?*IXAudio2Voice,
                SourceChannels: u32,
                DestinationChannels: u32,
                pLevelMatrix: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        DestroyVoice: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXAudio2Voice,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IXAudio2Voice,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXAudio2Voice_GetVoiceDetails(self: *const T, pVoiceDetails: ?*XAUDIO2_VOICE_DETAILS) void {
                return @as(*const IXAudio2Voice.VTable, @ptrCast(self.vtable)).GetVoiceDetails(@as(*const IXAudio2Voice, @ptrCast(self)), pVoiceDetails);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXAudio2Voice_SetOutputVoices(self: *const T, pSendList: ?*const XAUDIO2_VOICE_SENDS) HRESULT {
                return @as(*const IXAudio2Voice.VTable, @ptrCast(self.vtable)).SetOutputVoices(@as(*const IXAudio2Voice, @ptrCast(self)), pSendList);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXAudio2Voice_SetEffectChain(self: *const T, pEffectChain: ?*const XAUDIO2_EFFECT_CHAIN) HRESULT {
                return @as(*const IXAudio2Voice.VTable, @ptrCast(self.vtable)).SetEffectChain(@as(*const IXAudio2Voice, @ptrCast(self)), pEffectChain);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXAudio2Voice_EnableEffect(self: *const T, EffectIndex: u32, OperationSet: u32) HRESULT {
                return @as(*const IXAudio2Voice.VTable, @ptrCast(self.vtable)).EnableEffect(@as(*const IXAudio2Voice, @ptrCast(self)), EffectIndex, OperationSet);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXAudio2Voice_DisableEffect(self: *const T, EffectIndex: u32, OperationSet: u32) HRESULT {
                return @as(*const IXAudio2Voice.VTable, @ptrCast(self.vtable)).DisableEffect(@as(*const IXAudio2Voice, @ptrCast(self)), EffectIndex, OperationSet);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXAudio2Voice_GetEffectState(self: *const T, EffectIndex: u32, pEnabled: ?*BOOL) void {
                return @as(*const IXAudio2Voice.VTable, @ptrCast(self.vtable)).GetEffectState(@as(*const IXAudio2Voice, @ptrCast(self)), EffectIndex, pEnabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXAudio2Voice_SetEffectParameters(self: *const T, EffectIndex: u32, pParameters: ?*const anyopaque, ParametersByteSize: u32, OperationSet: u32) HRESULT {
                return @as(*const IXAudio2Voice.VTable, @ptrCast(self.vtable)).SetEffectParameters(@as(*const IXAudio2Voice, @ptrCast(self)), EffectIndex, pParameters, ParametersByteSize, OperationSet);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXAudio2Voice_GetEffectParameters(self: *const T, EffectIndex: u32, pParameters: ?*anyopaque, ParametersByteSize: u32) HRESULT {
                return @as(*const IXAudio2Voice.VTable, @ptrCast(self.vtable)).GetEffectParameters(@as(*const IXAudio2Voice, @ptrCast(self)), EffectIndex, pParameters, ParametersByteSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXAudio2Voice_SetFilterParameters(self: *const T, pParameters: ?*const XAUDIO2_FILTER_PARAMETERS, OperationSet: u32) HRESULT {
                return @as(*const IXAudio2Voice.VTable, @ptrCast(self.vtable)).SetFilterParameters(@as(*const IXAudio2Voice, @ptrCast(self)), pParameters, OperationSet);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXAudio2Voice_GetFilterParameters(self: *const T, pParameters: ?*XAUDIO2_FILTER_PARAMETERS) void {
                return @as(*const IXAudio2Voice.VTable, @ptrCast(self.vtable)).GetFilterParameters(@as(*const IXAudio2Voice, @ptrCast(self)), pParameters);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXAudio2Voice_SetOutputFilterParameters(self: *const T, pDestinationVoice: ?*IXAudio2Voice, pParameters: ?*const XAUDIO2_FILTER_PARAMETERS, OperationSet: u32) HRESULT {
                return @as(*const IXAudio2Voice.VTable, @ptrCast(self.vtable)).SetOutputFilterParameters(@as(*const IXAudio2Voice, @ptrCast(self)), pDestinationVoice, pParameters, OperationSet);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXAudio2Voice_GetOutputFilterParameters(self: *const T, pDestinationVoice: ?*IXAudio2Voice, pParameters: ?*XAUDIO2_FILTER_PARAMETERS) void {
                return @as(*const IXAudio2Voice.VTable, @ptrCast(self.vtable)).GetOutputFilterParameters(@as(*const IXAudio2Voice, @ptrCast(self)), pDestinationVoice, pParameters);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXAudio2Voice_SetVolume(self: *const T, Volume: f32, OperationSet: u32) HRESULT {
                return @as(*const IXAudio2Voice.VTable, @ptrCast(self.vtable)).SetVolume(@as(*const IXAudio2Voice, @ptrCast(self)), Volume, OperationSet);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXAudio2Voice_GetVolume(self: *const T, pVolume: ?*f32) void {
                return @as(*const IXAudio2Voice.VTable, @ptrCast(self.vtable)).GetVolume(@as(*const IXAudio2Voice, @ptrCast(self)), pVolume);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXAudio2Voice_SetChannelVolumes(self: *const T, Channels: u32, pVolumes: [*]const f32, OperationSet: u32) HRESULT {
                return @as(*const IXAudio2Voice.VTable, @ptrCast(self.vtable)).SetChannelVolumes(@as(*const IXAudio2Voice, @ptrCast(self)), Channels, pVolumes, OperationSet);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXAudio2Voice_GetChannelVolumes(self: *const T, Channels: u32, pVolumes: [*]f32) void {
                return @as(*const IXAudio2Voice.VTable, @ptrCast(self.vtable)).GetChannelVolumes(@as(*const IXAudio2Voice, @ptrCast(self)), Channels, pVolumes);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXAudio2Voice_SetOutputMatrix(self: *const T, pDestinationVoice: ?*IXAudio2Voice, SourceChannels: u32, DestinationChannels: u32, pLevelMatrix: ?*const f32, OperationSet: u32) HRESULT {
                return @as(*const IXAudio2Voice.VTable, @ptrCast(self.vtable)).SetOutputMatrix(@as(*const IXAudio2Voice, @ptrCast(self)), pDestinationVoice, SourceChannels, DestinationChannels, pLevelMatrix, OperationSet);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXAudio2Voice_GetOutputMatrix(self: *const T, pDestinationVoice: ?*IXAudio2Voice, SourceChannels: u32, DestinationChannels: u32, pLevelMatrix: ?*f32) void {
                return @as(*const IXAudio2Voice.VTable, @ptrCast(self.vtable)).GetOutputMatrix(@as(*const IXAudio2Voice, @ptrCast(self)), pDestinationVoice, SourceChannels, DestinationChannels, pLevelMatrix);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXAudio2Voice_DestroyVoice(self: *const T) void {
                return @as(*const IXAudio2Voice.VTable, @ptrCast(self.vtable)).DestroyVoice(@as(*const IXAudio2Voice, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const IXAudio2SourceVoice = extern struct {
    pub const VTable = extern struct {
        base: IXAudio2Voice.VTable,
        Start: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXAudio2SourceVoice,
                Flags: u32,
                OperationSet: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXAudio2SourceVoice,
                Flags: u32,
                OperationSet: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Stop: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXAudio2SourceVoice,
                Flags: u32,
                OperationSet: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXAudio2SourceVoice,
                Flags: u32,
                OperationSet: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SubmitSourceBuffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXAudio2SourceVoice,
                pBuffer: ?*const XAUDIO2_BUFFER,
                pBufferWMA: ?*const XAUDIO2_BUFFER_WMA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXAudio2SourceVoice,
                pBuffer: ?*const XAUDIO2_BUFFER,
                pBufferWMA: ?*const XAUDIO2_BUFFER_WMA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FlushSourceBuffers: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXAudio2SourceVoice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXAudio2SourceVoice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Discontinuity: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXAudio2SourceVoice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXAudio2SourceVoice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExitLoop: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXAudio2SourceVoice,
                OperationSet: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXAudio2SourceVoice,
                OperationSet: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXAudio2SourceVoice,
                pVoiceState: ?*XAUDIO2_VOICE_STATE,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IXAudio2SourceVoice,
                pVoiceState: ?*XAUDIO2_VOICE_STATE,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        SetFrequencyRatio: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXAudio2SourceVoice,
                Ratio: f32,
                OperationSet: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXAudio2SourceVoice,
                Ratio: f32,
                OperationSet: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFrequencyRatio: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXAudio2SourceVoice,
                pRatio: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IXAudio2SourceVoice,
                pRatio: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        SetSourceSampleRate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXAudio2SourceVoice,
                NewSourceSampleRate: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXAudio2SourceVoice,
                NewSourceSampleRate: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IXAudio2Voice.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXAudio2SourceVoice_Start(self: *const T, Flags: u32, OperationSet: u32) HRESULT {
                return @as(*const IXAudio2SourceVoice.VTable, @ptrCast(self.vtable)).Start(@as(*const IXAudio2SourceVoice, @ptrCast(self)), Flags, OperationSet);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXAudio2SourceVoice_Stop(self: *const T, Flags: u32, OperationSet: u32) HRESULT {
                return @as(*const IXAudio2SourceVoice.VTable, @ptrCast(self.vtable)).Stop(@as(*const IXAudio2SourceVoice, @ptrCast(self)), Flags, OperationSet);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXAudio2SourceVoice_SubmitSourceBuffer(self: *const T, pBuffer: ?*const XAUDIO2_BUFFER, pBufferWMA: ?*const XAUDIO2_BUFFER_WMA) HRESULT {
                return @as(*const IXAudio2SourceVoice.VTable, @ptrCast(self.vtable)).SubmitSourceBuffer(@as(*const IXAudio2SourceVoice, @ptrCast(self)), pBuffer, pBufferWMA);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXAudio2SourceVoice_FlushSourceBuffers(self: *const T) HRESULT {
                return @as(*const IXAudio2SourceVoice.VTable, @ptrCast(self.vtable)).FlushSourceBuffers(@as(*const IXAudio2SourceVoice, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXAudio2SourceVoice_Discontinuity(self: *const T) HRESULT {
                return @as(*const IXAudio2SourceVoice.VTable, @ptrCast(self.vtable)).Discontinuity(@as(*const IXAudio2SourceVoice, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXAudio2SourceVoice_ExitLoop(self: *const T, OperationSet: u32) HRESULT {
                return @as(*const IXAudio2SourceVoice.VTable, @ptrCast(self.vtable)).ExitLoop(@as(*const IXAudio2SourceVoice, @ptrCast(self)), OperationSet);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXAudio2SourceVoice_GetState(self: *const T, pVoiceState: ?*XAUDIO2_VOICE_STATE, Flags: u32) void {
                return @as(*const IXAudio2SourceVoice.VTable, @ptrCast(self.vtable)).GetState(@as(*const IXAudio2SourceVoice, @ptrCast(self)), pVoiceState, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXAudio2SourceVoice_SetFrequencyRatio(self: *const T, Ratio: f32, OperationSet: u32) HRESULT {
                return @as(*const IXAudio2SourceVoice.VTable, @ptrCast(self.vtable)).SetFrequencyRatio(@as(*const IXAudio2SourceVoice, @ptrCast(self)), Ratio, OperationSet);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXAudio2SourceVoice_GetFrequencyRatio(self: *const T, pRatio: ?*f32) void {
                return @as(*const IXAudio2SourceVoice.VTable, @ptrCast(self.vtable)).GetFrequencyRatio(@as(*const IXAudio2SourceVoice, @ptrCast(self)), pRatio);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXAudio2SourceVoice_SetSourceSampleRate(self: *const T, NewSourceSampleRate: u32) HRESULT {
                return @as(*const IXAudio2SourceVoice.VTable, @ptrCast(self.vtable)).SetSourceSampleRate(@as(*const IXAudio2SourceVoice, @ptrCast(self)), NewSourceSampleRate);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const IXAudio2SubmixVoice = extern struct {
    pub const VTable = extern struct {
        base: IXAudio2Voice.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IXAudio2Voice.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const IXAudio2MasteringVoice = extern struct {
    pub const VTable = extern struct {
        base: IXAudio2Voice.VTable,
        GetChannelMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXAudio2MasteringVoice,
                pChannelmask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXAudio2MasteringVoice,
                pChannelmask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IXAudio2Voice.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXAudio2MasteringVoice_GetChannelMask(self: *const T, pChannelmask: ?*u32) HRESULT {
                return @as(*const IXAudio2MasteringVoice.VTable, @ptrCast(self.vtable)).GetChannelMask(@as(*const IXAudio2MasteringVoice, @ptrCast(self)), pChannelmask);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const IXAudio2EngineCallback = extern struct {
    pub const VTable = extern struct {
        OnProcessingPassStart: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXAudio2EngineCallback,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IXAudio2EngineCallback,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        OnProcessingPassEnd: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXAudio2EngineCallback,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IXAudio2EngineCallback,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        OnCriticalError: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXAudio2EngineCallback,
                Error: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IXAudio2EngineCallback,
                Error: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXAudio2EngineCallback_OnProcessingPassStart(self: *const T) void {
                return @as(*const IXAudio2EngineCallback.VTable, @ptrCast(self.vtable)).OnProcessingPassStart(@as(*const IXAudio2EngineCallback, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXAudio2EngineCallback_OnProcessingPassEnd(self: *const T) void {
                return @as(*const IXAudio2EngineCallback.VTable, @ptrCast(self.vtable)).OnProcessingPassEnd(@as(*const IXAudio2EngineCallback, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXAudio2EngineCallback_OnCriticalError(self: *const T, Error: HRESULT) void {
                return @as(*const IXAudio2EngineCallback.VTable, @ptrCast(self.vtable)).OnCriticalError(@as(*const IXAudio2EngineCallback, @ptrCast(self)), Error);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const IXAudio2VoiceCallback = extern struct {
    pub const VTable = extern struct {
        OnVoiceProcessingPassStart: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXAudio2VoiceCallback,
                BytesRequired: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IXAudio2VoiceCallback,
                BytesRequired: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        OnVoiceProcessingPassEnd: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXAudio2VoiceCallback,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IXAudio2VoiceCallback,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        OnStreamEnd: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXAudio2VoiceCallback,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IXAudio2VoiceCallback,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        OnBufferStart: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXAudio2VoiceCallback,
                pBufferContext: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IXAudio2VoiceCallback,
                pBufferContext: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        OnBufferEnd: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXAudio2VoiceCallback,
                pBufferContext: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IXAudio2VoiceCallback,
                pBufferContext: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        OnLoopEnd: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXAudio2VoiceCallback,
                pBufferContext: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IXAudio2VoiceCallback,
                pBufferContext: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        OnVoiceError: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXAudio2VoiceCallback,
                pBufferContext: ?*anyopaque,
                Error: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IXAudio2VoiceCallback,
                pBufferContext: ?*anyopaque,
                Error: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXAudio2VoiceCallback_OnVoiceProcessingPassStart(self: *const T, BytesRequired: u32) void {
                return @as(*const IXAudio2VoiceCallback.VTable, @ptrCast(self.vtable)).OnVoiceProcessingPassStart(@as(*const IXAudio2VoiceCallback, @ptrCast(self)), BytesRequired);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXAudio2VoiceCallback_OnVoiceProcessingPassEnd(self: *const T) void {
                return @as(*const IXAudio2VoiceCallback.VTable, @ptrCast(self.vtable)).OnVoiceProcessingPassEnd(@as(*const IXAudio2VoiceCallback, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXAudio2VoiceCallback_OnStreamEnd(self: *const T) void {
                return @as(*const IXAudio2VoiceCallback.VTable, @ptrCast(self.vtable)).OnStreamEnd(@as(*const IXAudio2VoiceCallback, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXAudio2VoiceCallback_OnBufferStart(self: *const T, pBufferContext: ?*anyopaque) void {
                return @as(*const IXAudio2VoiceCallback.VTable, @ptrCast(self.vtable)).OnBufferStart(@as(*const IXAudio2VoiceCallback, @ptrCast(self)), pBufferContext);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXAudio2VoiceCallback_OnBufferEnd(self: *const T, pBufferContext: ?*anyopaque) void {
                return @as(*const IXAudio2VoiceCallback.VTable, @ptrCast(self.vtable)).OnBufferEnd(@as(*const IXAudio2VoiceCallback, @ptrCast(self)), pBufferContext);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXAudio2VoiceCallback_OnLoopEnd(self: *const T, pBufferContext: ?*anyopaque) void {
                return @as(*const IXAudio2VoiceCallback.VTable, @ptrCast(self.vtable)).OnLoopEnd(@as(*const IXAudio2VoiceCallback, @ptrCast(self)), pBufferContext);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXAudio2VoiceCallback_OnVoiceError(self: *const T, pBufferContext: ?*anyopaque, Error: HRESULT) void {
                return @as(*const IXAudio2VoiceCallback.VTable, @ptrCast(self.vtable)).OnVoiceError(@as(*const IXAudio2VoiceCallback, @ptrCast(self)), pBufferContext, Error);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const CLSID_AudioVolumeMeter_Value = Guid.initString("4fc3b166-972a-40cf-bc37-7db03db2fba3");
pub const CLSID_AudioVolumeMeter = &CLSID_AudioVolumeMeter_Value;

const CLSID_AudioReverb_Value = Guid.initString("c2633b16-471b-4498-b8c5-4f0959e2ec09");
pub const CLSID_AudioReverb = &CLSID_AudioReverb_Value;

pub const XAUDIO2FX_VOLUMEMETER_LEVELS = extern struct {
    pPeakLevels: ?*f32 align(1),
    pRMSLevels: ?*f32 align(1),
    ChannelCount: u32 align(1),
};

pub const XAUDIO2FX_REVERB_PARAMETERS = extern struct {
    WetDryMix: f32 align(1),
    ReflectionsDelay: u32 align(1),
    ReverbDelay: u8 align(1),
    RearDelay: u8 align(1),
    SideDelay: u8 align(1),
    PositionLeft: u8 align(1),
    PositionRight: u8 align(1),
    PositionMatrixLeft: u8 align(1),
    PositionMatrixRight: u8 align(1),
    EarlyDiffusion: u8 align(1),
    LateDiffusion: u8 align(1),
    LowEQGain: u8 align(1),
    LowEQCutoff: u8 align(1),
    HighEQGain: u8 align(1),
    HighEQCutoff: u8 align(1),
    RoomFilterFreq: f32 align(1),
    RoomFilterMain: f32 align(1),
    RoomFilterHF: f32 align(1),
    ReflectionsGain: f32 align(1),
    ReverbGain: f32 align(1),
    DecayTime: f32 align(1),
    Density: f32 align(1),
    RoomSize: f32 align(1),
    DisableLateField: BOOL align(1),
};

pub const XAUDIO2FX_REVERB_I3DL2_PARAMETERS = extern struct {
    WetDryMix: f32 align(1),
    Room: i32 align(1),
    RoomHF: i32 align(1),
    RoomRolloffFactor: f32 align(1),
    DecayTime: f32 align(1),
    DecayHFRatio: f32 align(1),
    Reflections: i32 align(1),
    ReflectionsDelay: f32 align(1),
    Reverb: i32 align(1),
    ReverbDelay: f32 align(1),
    Diffusion: f32 align(1),
    Density: f32 align(1),
    HFReference: f32 align(1),
};

pub const HrtfPosition = extern struct {
    x: f32,
    y: f32,
    z: f32,
};

pub const HrtfOrientation = extern struct {
    element: [9]f32,
};

pub const HrtfDirectivityType = enum(i32) {
    OmniDirectional = 0,
    Cardioid = 1,
    Cone = 2,
};
pub const OmniDirectional = HrtfDirectivityType.OmniDirectional;
pub const Cardioid = HrtfDirectivityType.Cardioid;
pub const Cone = HrtfDirectivityType.Cone;

pub const HrtfEnvironment = enum(i32) {
    Small = 0,
    Medium = 1,
    Large = 2,
    Outdoors = 3,
};
pub const Small = HrtfEnvironment.Small;
pub const Medium = HrtfEnvironment.Medium;
pub const Large = HrtfEnvironment.Large;
pub const Outdoors = HrtfEnvironment.Outdoors;

pub const HrtfDirectivity = extern struct {
    type: HrtfDirectivityType,
    scaling: f32,
};

pub const HrtfDirectivityCardioid = extern struct {
    directivity: HrtfDirectivity,
    order: f32,
};

pub const HrtfDirectivityCone = extern struct {
    directivity: HrtfDirectivity,
    innerAngle: f32,
    outerAngle: f32,
};

pub const HrtfDistanceDecayType = enum(i32) {
    NaturalDecay = 0,
    CustomDecay = 1,
};
pub const NaturalDecay = HrtfDistanceDecayType.NaturalDecay;
pub const CustomDecay = HrtfDistanceDecayType.CustomDecay;

pub const HrtfDistanceDecay = extern struct {
    type: HrtfDistanceDecayType,
    maxGain: f32,
    minGain: f32,
    unityGainDistance: f32,
    cutoffDistance: f32,
};

pub const HrtfApoInit = extern struct {
    distanceDecay: ?*HrtfDistanceDecay,
    directivity: ?*HrtfDirectivity,
};

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IXAPOHrtfParameters_Value = Guid.initString("15b3cd66-e9de-4464-b6e6-2bc3cf63d455");
pub const IID_IXAPOHrtfParameters = &IID_IXAPOHrtfParameters_Value;
pub const IXAPOHrtfParameters = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetSourcePosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXAPOHrtfParameters,
                position: ?*const HrtfPosition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXAPOHrtfParameters,
                position: ?*const HrtfPosition,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSourceOrientation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXAPOHrtfParameters,
                orientation: ?*const HrtfOrientation,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXAPOHrtfParameters,
                orientation: ?*const HrtfOrientation,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSourceGain: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXAPOHrtfParameters,
                gain: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXAPOHrtfParameters,
                gain: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEnvironment: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXAPOHrtfParameters,
                environment: HrtfEnvironment,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXAPOHrtfParameters,
                environment: HrtfEnvironment,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXAPOHrtfParameters_SetSourcePosition(self: *const T, position: ?*const HrtfPosition) HRESULT {
                return @as(*const IXAPOHrtfParameters.VTable, @ptrCast(self.vtable)).SetSourcePosition(@as(*const IXAPOHrtfParameters, @ptrCast(self)), position);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXAPOHrtfParameters_SetSourceOrientation(self: *const T, orientation: ?*const HrtfOrientation) HRESULT {
                return @as(*const IXAPOHrtfParameters.VTable, @ptrCast(self.vtable)).SetSourceOrientation(@as(*const IXAPOHrtfParameters, @ptrCast(self)), orientation);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXAPOHrtfParameters_SetSourceGain(self: *const T, gain: f32) HRESULT {
                return @as(*const IXAPOHrtfParameters.VTable, @ptrCast(self.vtable)).SetSourceGain(@as(*const IXAPOHrtfParameters, @ptrCast(self)), gain);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXAPOHrtfParameters_SetEnvironment(self: *const T, environment: HrtfEnvironment) HRESULT {
                return @as(*const IXAPOHrtfParameters.VTable, @ptrCast(self.vtable)).SetEnvironment(@as(*const IXAPOHrtfParameters, @ptrCast(self)), environment);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

//--------------------------------------------------------------------------------
// Section: Functions (5)
//--------------------------------------------------------------------------------
pub extern "xaudio2_8" fn CreateFX(
    clsid: ?*const Guid,
    pEffect: ?*?*IUnknown,
    // TODO: what to do with BytesParamIndex 3?
    pInitDat: ?*const anyopaque,
    InitDataByteSize: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "xaudio2_8" fn XAudio2CreateWithVersionInfo(
    ppXAudio2: ?*?*IXAudio2,
    Flags: u32,
    XAudio2Processor: u32,
    ntddiVersion: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "xaudio2_8" fn CreateAudioVolumeMeter(
    ppApo: ?*?*IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "xaudio2_8" fn CreateAudioReverb(
    ppApo: ?*?*IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "hrtfapo" fn CreateHrtfApo(
    init: ?*const HrtfApoInit,
    xApo: ?*?*IXAPO,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../../zig.zig").unicode_mode) {
    .ansi => struct {},
    .wide => struct {},
    .unspecified => if (@import("builtin").is_test) struct {} else struct {},
};
//--------------------------------------------------------------------------------
// Section: Imports (7)
//--------------------------------------------------------------------------------
const Guid = @import("../../zig.zig").Guid;
const AUDIO_STREAM_CATEGORY = @import("../../media/audio.zig").AUDIO_STREAM_CATEGORY;
const BOOL = @import("../../foundation.zig").BOOL;
const HRESULT = @import("../../foundation.zig").HRESULT;
const IUnknown = @import("../../system/com.zig").IUnknown;
const PWSTR = @import("../../foundation.zig").PWSTR;
const WAVEFORMATEX = @import("../../media/audio.zig").WAVEFORMATEX;

test {
    @setEvalBranchQuota(comptime @import("std").meta.declarations(@This()).len * 3);

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        if (decl.is_pub) {
            _ = @field(@This(), decl.name);
        }
    }
}
