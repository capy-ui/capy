//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (53)
//--------------------------------------------------------------------------------
pub const APOERR_ALREADY_INITIALIZED = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2005073919));
pub const APOERR_NOT_INITIALIZED = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2005073918));
pub const APOERR_FORMAT_NOT_SUPPORTED = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2005073917));
pub const APOERR_INVALID_APO_CLSID = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2005073916));
pub const APOERR_BUFFERS_OVERLAP = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2005073915));
pub const APOERR_ALREADY_UNLOCKED = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2005073914));
pub const APOERR_NUM_CONNECTIONS_INVALID = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2005073913));
pub const APOERR_INVALID_OUTPUT_MAXFRAMECOUNT = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2005073912));
pub const APOERR_INVALID_CONNECTION_FORMAT = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2005073911));
pub const APOERR_APO_LOCKED = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2005073910));
pub const APOERR_INVALID_COEFFCOUNT = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2005073909));
pub const APOERR_INVALID_COEFFICIENT = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2005073908));
pub const APOERR_INVALID_CURVE_PARAM = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2005073907));
pub const APOERR_INVALID_INPUTID = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2005073906));
pub const AUDIO_MIN_FRAMERATE = @as(f64, 10);
pub const AUDIO_MAX_FRAMERATE = @as(f64, 384000);
pub const AUDIO_MIN_CHANNELS = @as(u32, 1);
pub const AUDIO_MAX_CHANNELS = @as(u32, 4096);
pub const PKEY_FX_Association = PROPERTYKEY { .fmtid = Guid.initString("d04e05a6-594b-4fb6-a80d-01af5eed7d1d"), .pid = 0 };
pub const PKEY_FX_PreMixEffectClsid = PROPERTYKEY { .fmtid = Guid.initString("d04e05a6-594b-4fb6-a80d-01af5eed7d1d"), .pid = 1 };
pub const PKEY_FX_PostMixEffectClsid = PROPERTYKEY { .fmtid = Guid.initString("d04e05a6-594b-4fb6-a80d-01af5eed7d1d"), .pid = 2 };
pub const PKEY_FX_UserInterfaceClsid = PROPERTYKEY { .fmtid = Guid.initString("d04e05a6-594b-4fb6-a80d-01af5eed7d1d"), .pid = 3 };
pub const PKEY_FX_FriendlyName = PROPERTYKEY { .fmtid = Guid.initString("d04e05a6-594b-4fb6-a80d-01af5eed7d1d"), .pid = 4 };
pub const PKEY_FX_StreamEffectClsid = PROPERTYKEY { .fmtid = Guid.initString("d04e05a6-594b-4fb6-a80d-01af5eed7d1d"), .pid = 5 };
pub const PKEY_FX_ModeEffectClsid = PROPERTYKEY { .fmtid = Guid.initString("d04e05a6-594b-4fb6-a80d-01af5eed7d1d"), .pid = 6 };
pub const PKEY_FX_EndpointEffectClsid = PROPERTYKEY { .fmtid = Guid.initString("d04e05a6-594b-4fb6-a80d-01af5eed7d1d"), .pid = 7 };
pub const PKEY_FX_KeywordDetector_StreamEffectClsid = PROPERTYKEY { .fmtid = Guid.initString("d04e05a6-594b-4fb6-a80d-01af5eed7d1d"), .pid = 8 };
pub const PKEY_FX_KeywordDetector_ModeEffectClsid = PROPERTYKEY { .fmtid = Guid.initString("d04e05a6-594b-4fb6-a80d-01af5eed7d1d"), .pid = 9 };
pub const PKEY_FX_KeywordDetector_EndpointEffectClsid = PROPERTYKEY { .fmtid = Guid.initString("d04e05a6-594b-4fb6-a80d-01af5eed7d1d"), .pid = 10 };
pub const PKEY_FX_Offload_StreamEffectClsid = PROPERTYKEY { .fmtid = Guid.initString("d04e05a6-594b-4fb6-a80d-01af5eed7d1d"), .pid = 11 };
pub const PKEY_FX_Offload_ModeEffectClsid = PROPERTYKEY { .fmtid = Guid.initString("d04e05a6-594b-4fb6-a80d-01af5eed7d1d"), .pid = 12 };
pub const PKEY_CompositeFX_StreamEffectClsid = PROPERTYKEY { .fmtid = Guid.initString("d04e05a6-594b-4fb6-a80d-01af5eed7d1d"), .pid = 13 };
pub const PKEY_CompositeFX_ModeEffectClsid = PROPERTYKEY { .fmtid = Guid.initString("d04e05a6-594b-4fb6-a80d-01af5eed7d1d"), .pid = 14 };
pub const PKEY_CompositeFX_EndpointEffectClsid = PROPERTYKEY { .fmtid = Guid.initString("d04e05a6-594b-4fb6-a80d-01af5eed7d1d"), .pid = 15 };
pub const PKEY_CompositeFX_KeywordDetector_StreamEffectClsid = PROPERTYKEY { .fmtid = Guid.initString("d04e05a6-594b-4fb6-a80d-01af5eed7d1d"), .pid = 16 };
pub const PKEY_CompositeFX_KeywordDetector_ModeEffectClsid = PROPERTYKEY { .fmtid = Guid.initString("d04e05a6-594b-4fb6-a80d-01af5eed7d1d"), .pid = 17 };
pub const PKEY_CompositeFX_KeywordDetector_EndpointEffectClsid = PROPERTYKEY { .fmtid = Guid.initString("d04e05a6-594b-4fb6-a80d-01af5eed7d1d"), .pid = 18 };
pub const PKEY_CompositeFX_Offload_StreamEffectClsid = PROPERTYKEY { .fmtid = Guid.initString("d04e05a6-594b-4fb6-a80d-01af5eed7d1d"), .pid = 19 };
pub const PKEY_CompositeFX_Offload_ModeEffectClsid = PROPERTYKEY { .fmtid = Guid.initString("d04e05a6-594b-4fb6-a80d-01af5eed7d1d"), .pid = 20 };
pub const PKEY_SFX_ProcessingModes_Supported_For_Streaming = PROPERTYKEY { .fmtid = Guid.initString("d3993a3f-99c2-4402-b5ec-a92a0367664b"), .pid = 5 };
pub const PKEY_MFX_ProcessingModes_Supported_For_Streaming = PROPERTYKEY { .fmtid = Guid.initString("d3993a3f-99c2-4402-b5ec-a92a0367664b"), .pid = 6 };
pub const PKEY_EFX_ProcessingModes_Supported_For_Streaming = PROPERTYKEY { .fmtid = Guid.initString("d3993a3f-99c2-4402-b5ec-a92a0367664b"), .pid = 7 };
pub const PKEY_SFX_KeywordDetector_ProcessingModes_Supported_For_Streaming = PROPERTYKEY { .fmtid = Guid.initString("d3993a3f-99c2-4402-b5ec-a92a0367664b"), .pid = 8 };
pub const PKEY_MFX_KeywordDetector_ProcessingModes_Supported_For_Streaming = PROPERTYKEY { .fmtid = Guid.initString("d3993a3f-99c2-4402-b5ec-a92a0367664b"), .pid = 9 };
pub const PKEY_EFX_KeywordDetector_ProcessingModes_Supported_For_Streaming = PROPERTYKEY { .fmtid = Guid.initString("d3993a3f-99c2-4402-b5ec-a92a0367664b"), .pid = 10 };
pub const PKEY_SFX_Offload_ProcessingModes_Supported_For_Streaming = PROPERTYKEY { .fmtid = Guid.initString("d3993a3f-99c2-4402-b5ec-a92a0367664b"), .pid = 11 };
pub const PKEY_MFX_Offload_ProcessingModes_Supported_For_Streaming = PROPERTYKEY { .fmtid = Guid.initString("d3993a3f-99c2-4402-b5ec-a92a0367664b"), .pid = 12 };
pub const PKEY_APO_SWFallback_ProcessingModes = PROPERTYKEY { .fmtid = Guid.initString("d3993a3f-99c2-4402-b5ec-a92a0367664b"), .pid = 13 };
pub const SID_AudioProcessingObjectRTQueue = Guid.initString("458c1a1f-6899-4c12-99ac-e2e6ac253104");
pub const SID_AudioProcessingObjectLoggingService = Guid.initString("8b8008af-09f9-456e-a173-bdb58499bce7");
pub const AUDIOMEDIATYPE_EQUAL_FORMAT_TYPES = @as(u32, 2);
pub const AUDIOMEDIATYPE_EQUAL_FORMAT_DATA = @as(u32, 4);
pub const AUDIOMEDIATYPE_EQUAL_FORMAT_USER_DATA = @as(u32, 8);

//--------------------------------------------------------------------------------
// Section: Types (44)
//--------------------------------------------------------------------------------
pub const UNCOMPRESSEDAUDIOFORMAT = extern struct {
    guidFormatType: Guid,
    dwSamplesPerFrame: u32,
    dwBytesPerSampleContainer: u32,
    dwValidBitsPerSample: u32,
    fFramesPerSecond: f32,
    dwChannelMask: u32,
};

const IID_IAudioMediaType_Value = Guid.initString("4e997f73-b71f-4798-873b-ed7dfcf15b4d");
pub const IID_IAudioMediaType = &IID_IAudioMediaType_Value;
pub const IAudioMediaType = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IsCompressedFormat: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioMediaType,
                pfCompressed: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAudioMediaType,
                pfCompressed: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsEqual: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioMediaType,
                pIAudioType: ?*IAudioMediaType,
                pdwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAudioMediaType,
                pIAudioType: ?*IAudioMediaType,
                pdwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAudioFormat: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioMediaType,
            ) callconv(@import("std").os.windows.WINAPI) ?*WAVEFORMATEX,
            else => *const fn(
                self: *const IAudioMediaType,
            ) callconv(@import("std").os.windows.WINAPI) ?*WAVEFORMATEX,
        },
        GetUncompressedAudioFormat: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioMediaType,
                pUncompressedAudioFormat: ?*UNCOMPRESSEDAUDIOFORMAT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAudioMediaType,
                pUncompressedAudioFormat: ?*UNCOMPRESSEDAUDIOFORMAT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioMediaType_IsCompressedFormat(self: *const T, pfCompressed: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioMediaType.VTable, self.vtable).IsCompressedFormat(@ptrCast(*const IAudioMediaType, self), pfCompressed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioMediaType_IsEqual(self: *const T, pIAudioType: ?*IAudioMediaType, pdwFlags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioMediaType.VTable, self.vtable).IsEqual(@ptrCast(*const IAudioMediaType, self), pIAudioType, pdwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioMediaType_GetAudioFormat(self: *const T) callconv(.Inline) ?*WAVEFORMATEX {
            return @ptrCast(*const IAudioMediaType.VTable, self.vtable).GetAudioFormat(@ptrCast(*const IAudioMediaType, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioMediaType_GetUncompressedAudioFormat(self: *const T, pUncompressedAudioFormat: ?*UNCOMPRESSEDAUDIOFORMAT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioMediaType.VTable, self.vtable).GetUncompressedAudioFormat(@ptrCast(*const IAudioMediaType, self), pUncompressedAudioFormat);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const APO_BUFFER_FLAGS = enum(i32) {
    INVALID = 0,
    VALID = 1,
    SILENT = 2,
};
pub const BUFFER_INVALID = APO_BUFFER_FLAGS.INVALID;
pub const BUFFER_VALID = APO_BUFFER_FLAGS.VALID;
pub const BUFFER_SILENT = APO_BUFFER_FLAGS.SILENT;

pub const APO_CONNECTION_PROPERTY = extern struct {
    pBuffer: usize,
    u32ValidFrameCount: u32,
    u32BufferFlags: APO_BUFFER_FLAGS,
    u32Signature: u32,
};

pub const APO_CONNECTION_PROPERTY_V2 = extern struct {
    property: APO_CONNECTION_PROPERTY,
    u64QPCTime: u64,
};

pub const APO_CONNECTION_BUFFER_TYPE = enum(i32) {
    ALLOCATED = 0,
    EXTERNAL = 1,
    DEPENDANT = 2,
};
pub const APO_CONNECTION_BUFFER_TYPE_ALLOCATED = APO_CONNECTION_BUFFER_TYPE.ALLOCATED;
pub const APO_CONNECTION_BUFFER_TYPE_EXTERNAL = APO_CONNECTION_BUFFER_TYPE.EXTERNAL;
pub const APO_CONNECTION_BUFFER_TYPE_DEPENDANT = APO_CONNECTION_BUFFER_TYPE.DEPENDANT;

pub const APO_CONNECTION_DESCRIPTOR = extern struct {
    Type: APO_CONNECTION_BUFFER_TYPE,
    pBuffer: usize,
    u32MaxFrameCount: u32,
    pFormat: ?*IAudioMediaType,
    u32Signature: u32,
};

pub const APO_FLAG = enum(i32) {
    NONE = 0,
    INPLACE = 1,
    SAMPLESPERFRAME_MUST_MATCH = 2,
    FRAMESPERSECOND_MUST_MATCH = 4,
    BITSPERSAMPLE_MUST_MATCH = 8,
    MIXER = 16,
    DEFAULT = 14,
};
pub const APO_FLAG_NONE = APO_FLAG.NONE;
pub const APO_FLAG_INPLACE = APO_FLAG.INPLACE;
pub const APO_FLAG_SAMPLESPERFRAME_MUST_MATCH = APO_FLAG.SAMPLESPERFRAME_MUST_MATCH;
pub const APO_FLAG_FRAMESPERSECOND_MUST_MATCH = APO_FLAG.FRAMESPERSECOND_MUST_MATCH;
pub const APO_FLAG_BITSPERSAMPLE_MUST_MATCH = APO_FLAG.BITSPERSAMPLE_MUST_MATCH;
pub const APO_FLAG_MIXER = APO_FLAG.MIXER;
pub const APO_FLAG_DEFAULT = APO_FLAG.DEFAULT;

pub const APO_REG_PROPERTIES = extern struct {
    clsid: Guid,
    Flags: APO_FLAG,
    szFriendlyName: [256]u16,
    szCopyrightInfo: [256]u16,
    u32MajorVersion: u32,
    u32MinorVersion: u32,
    u32MinInputConnections: u32,
    u32MaxInputConnections: u32,
    u32MinOutputConnections: u32,
    u32MaxOutputConnections: u32,
    u32MaxInstances: u32,
    u32NumAPOInterfaces: u32,
    iidAPOInterfaceList: [1]Guid,
};

pub const APOInitBaseStruct = extern struct {
    cbSize: u32,
    clsid: Guid,
};

pub const AUDIO_FLOW_TYPE = enum(i32) {
    LL = 0,
    SH = 1,
};
pub const AUDIO_FLOW_PULL = AUDIO_FLOW_TYPE.LL;
pub const AUDIO_FLOW_PUSH = AUDIO_FLOW_TYPE.SH;

pub const EAudioConstriction = enum(i32) {
    Off = 0,
    @"48_16" = 1,
    @"44_16" = 2,
    @"14_14" = 3,
    Mute = 4,
};
pub const eAudioConstrictionOff = EAudioConstriction.Off;
pub const eAudioConstriction48_16 = EAudioConstriction.@"48_16";
pub const eAudioConstriction44_16 = EAudioConstriction.@"44_16";
pub const eAudioConstriction14_14 = EAudioConstriction.@"14_14";
pub const eAudioConstrictionMute = EAudioConstriction.Mute;

const IID_IAudioProcessingObjectRT_Value = Guid.initString("9e1d6a6d-ddbc-4e95-a4c7-ad64ba37846c");
pub const IID_IAudioProcessingObjectRT = &IID_IAudioProcessingObjectRT_Value;
pub const IAudioProcessingObjectRT = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        APOProcess: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioProcessingObjectRT,
                u32NumInputConnections: u32,
                ppInputConnections: ?*?*APO_CONNECTION_PROPERTY,
                u32NumOutputConnections: u32,
                ppOutputConnections: ?*?*APO_CONNECTION_PROPERTY,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const IAudioProcessingObjectRT,
                u32NumInputConnections: u32,
                ppInputConnections: ?*?*APO_CONNECTION_PROPERTY,
                u32NumOutputConnections: u32,
                ppOutputConnections: ?*?*APO_CONNECTION_PROPERTY,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        CalcInputFrames: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioProcessingObjectRT,
                u32OutputFrameCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn(
                self: *const IAudioProcessingObjectRT,
                u32OutputFrameCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
        CalcOutputFrames: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioProcessingObjectRT,
                u32InputFrameCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn(
                self: *const IAudioProcessingObjectRT,
                u32InputFrameCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioProcessingObjectRT_APOProcess(self: *const T, u32NumInputConnections: u32, ppInputConnections: ?*?*APO_CONNECTION_PROPERTY, u32NumOutputConnections: u32, ppOutputConnections: ?*?*APO_CONNECTION_PROPERTY) callconv(.Inline) void {
            return @ptrCast(*const IAudioProcessingObjectRT.VTable, self.vtable).APOProcess(@ptrCast(*const IAudioProcessingObjectRT, self), u32NumInputConnections, ppInputConnections, u32NumOutputConnections, ppOutputConnections);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioProcessingObjectRT_CalcInputFrames(self: *const T, u32OutputFrameCount: u32) callconv(.Inline) u32 {
            return @ptrCast(*const IAudioProcessingObjectRT.VTable, self.vtable).CalcInputFrames(@ptrCast(*const IAudioProcessingObjectRT, self), u32OutputFrameCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioProcessingObjectRT_CalcOutputFrames(self: *const T, u32InputFrameCount: u32) callconv(.Inline) u32 {
            return @ptrCast(*const IAudioProcessingObjectRT.VTable, self.vtable).CalcOutputFrames(@ptrCast(*const IAudioProcessingObjectRT, self), u32InputFrameCount);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAudioProcessingObjectVBR_Value = Guid.initString("7ba1db8f-78ad-49cd-9591-f79d80a17c81");
pub const IID_IAudioProcessingObjectVBR = &IID_IAudioProcessingObjectVBR_Value;
pub const IAudioProcessingObjectVBR = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CalcMaxInputFrames: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioProcessingObjectVBR,
                u32MaxOutputFrameCount: u32,
                pu32InputFrameCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAudioProcessingObjectVBR,
                u32MaxOutputFrameCount: u32,
                pu32InputFrameCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CalcMaxOutputFrames: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioProcessingObjectVBR,
                u32MaxInputFrameCount: u32,
                pu32OutputFrameCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAudioProcessingObjectVBR,
                u32MaxInputFrameCount: u32,
                pu32OutputFrameCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioProcessingObjectVBR_CalcMaxInputFrames(self: *const T, u32MaxOutputFrameCount: u32, pu32InputFrameCount: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioProcessingObjectVBR.VTable, self.vtable).CalcMaxInputFrames(@ptrCast(*const IAudioProcessingObjectVBR, self), u32MaxOutputFrameCount, pu32InputFrameCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioProcessingObjectVBR_CalcMaxOutputFrames(self: *const T, u32MaxInputFrameCount: u32, pu32OutputFrameCount: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioProcessingObjectVBR.VTable, self.vtable).CalcMaxOutputFrames(@ptrCast(*const IAudioProcessingObjectVBR, self), u32MaxInputFrameCount, pu32OutputFrameCount);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAudioProcessingObjectConfiguration_Value = Guid.initString("0e5ed805-aba6-49c3-8f9a-2b8c889c4fa8");
pub const IID_IAudioProcessingObjectConfiguration = &IID_IAudioProcessingObjectConfiguration_Value;
pub const IAudioProcessingObjectConfiguration = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        LockForProcess: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioProcessingObjectConfiguration,
                u32NumInputConnections: u32,
                ppInputConnections: ?*?*APO_CONNECTION_DESCRIPTOR,
                u32NumOutputConnections: u32,
                ppOutputConnections: ?*?*APO_CONNECTION_DESCRIPTOR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAudioProcessingObjectConfiguration,
                u32NumInputConnections: u32,
                ppInputConnections: ?*?*APO_CONNECTION_DESCRIPTOR,
                u32NumOutputConnections: u32,
                ppOutputConnections: ?*?*APO_CONNECTION_DESCRIPTOR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnlockForProcess: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioProcessingObjectConfiguration,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAudioProcessingObjectConfiguration,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioProcessingObjectConfiguration_LockForProcess(self: *const T, u32NumInputConnections: u32, ppInputConnections: ?*?*APO_CONNECTION_DESCRIPTOR, u32NumOutputConnections: u32, ppOutputConnections: ?*?*APO_CONNECTION_DESCRIPTOR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioProcessingObjectConfiguration.VTable, self.vtable).LockForProcess(@ptrCast(*const IAudioProcessingObjectConfiguration, self), u32NumInputConnections, ppInputConnections, u32NumOutputConnections, ppOutputConnections);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioProcessingObjectConfiguration_UnlockForProcess(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioProcessingObjectConfiguration.VTable, self.vtable).UnlockForProcess(@ptrCast(*const IAudioProcessingObjectConfiguration, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAudioProcessingObject_Value = Guid.initString("fd7f2b29-24d0-4b5c-b177-592c39f9ca10");
pub const IID_IAudioProcessingObject = &IID_IAudioProcessingObject_Value;
pub const IAudioProcessingObject = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioProcessingObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAudioProcessingObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLatency: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioProcessingObject,
                pTime: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAudioProcessingObject,
                pTime: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRegistrationProperties: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioProcessingObject,
                ppRegProps: ?*?*APO_REG_PROPERTIES,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAudioProcessingObject,
                ppRegProps: ?*?*APO_REG_PROPERTIES,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioProcessingObject,
                cbDataSize: u32,
                pbyData: [*:0]u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAudioProcessingObject,
                cbDataSize: u32,
                pbyData: [*:0]u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsInputFormatSupported: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioProcessingObject,
                pOppositeFormat: ?*IAudioMediaType,
                pRequestedInputFormat: ?*IAudioMediaType,
                ppSupportedInputFormat: ?*?*IAudioMediaType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAudioProcessingObject,
                pOppositeFormat: ?*IAudioMediaType,
                pRequestedInputFormat: ?*IAudioMediaType,
                ppSupportedInputFormat: ?*?*IAudioMediaType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsOutputFormatSupported: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioProcessingObject,
                pOppositeFormat: ?*IAudioMediaType,
                pRequestedOutputFormat: ?*IAudioMediaType,
                ppSupportedOutputFormat: ?*?*IAudioMediaType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAudioProcessingObject,
                pOppositeFormat: ?*IAudioMediaType,
                pRequestedOutputFormat: ?*IAudioMediaType,
                ppSupportedOutputFormat: ?*?*IAudioMediaType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInputChannelCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioProcessingObject,
                pu32ChannelCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAudioProcessingObject,
                pu32ChannelCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioProcessingObject_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioProcessingObject.VTable, self.vtable).Reset(@ptrCast(*const IAudioProcessingObject, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioProcessingObject_GetLatency(self: *const T, pTime: ?*i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioProcessingObject.VTable, self.vtable).GetLatency(@ptrCast(*const IAudioProcessingObject, self), pTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioProcessingObject_GetRegistrationProperties(self: *const T, ppRegProps: ?*?*APO_REG_PROPERTIES) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioProcessingObject.VTable, self.vtable).GetRegistrationProperties(@ptrCast(*const IAudioProcessingObject, self), ppRegProps);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioProcessingObject_Initialize(self: *const T, cbDataSize: u32, pbyData: [*:0]u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioProcessingObject.VTable, self.vtable).Initialize(@ptrCast(*const IAudioProcessingObject, self), cbDataSize, pbyData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioProcessingObject_IsInputFormatSupported(self: *const T, pOppositeFormat: ?*IAudioMediaType, pRequestedInputFormat: ?*IAudioMediaType, ppSupportedInputFormat: ?*?*IAudioMediaType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioProcessingObject.VTable, self.vtable).IsInputFormatSupported(@ptrCast(*const IAudioProcessingObject, self), pOppositeFormat, pRequestedInputFormat, ppSupportedInputFormat);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioProcessingObject_IsOutputFormatSupported(self: *const T, pOppositeFormat: ?*IAudioMediaType, pRequestedOutputFormat: ?*IAudioMediaType, ppSupportedOutputFormat: ?*?*IAudioMediaType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioProcessingObject.VTable, self.vtable).IsOutputFormatSupported(@ptrCast(*const IAudioProcessingObject, self), pOppositeFormat, pRequestedOutputFormat, ppSupportedOutputFormat);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioProcessingObject_GetInputChannelCount(self: *const T, pu32ChannelCount: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioProcessingObject.VTable, self.vtable).GetInputChannelCount(@ptrCast(*const IAudioProcessingObject, self), pu32ChannelCount);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAudioDeviceModulesClient_Value = Guid.initString("98f37dac-d0b6-49f5-896a-aa4d169a4c48");
pub const IID_IAudioDeviceModulesClient = &IID_IAudioDeviceModulesClient_Value;
pub const IAudioDeviceModulesClient = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetAudioDeviceModulesManager: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioDeviceModulesClient,
                pAudioDeviceModulesManager: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAudioDeviceModulesClient,
                pAudioDeviceModulesManager: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioDeviceModulesClient_SetAudioDeviceModulesManager(self: *const T, pAudioDeviceModulesManager: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioDeviceModulesClient.VTable, self.vtable).SetAudioDeviceModulesManager(@ptrCast(*const IAudioDeviceModulesClient, self), pAudioDeviceModulesManager);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const FNAPONOTIFICATIONCALLBACK = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        pProperties: ?*APO_REG_PROPERTIES,
        pvRefData: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
        pProperties: ?*APO_REG_PROPERTIES,
        pvRefData: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

const IID_IAudioSystemEffects_Value = Guid.initString("5fa00f27-add6-499a-8a9d-6b98521fa75b");
pub const IID_IAudioSystemEffects = &IID_IAudioSystemEffects_Value;
pub const IAudioSystemEffects = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAudioSystemEffects2_Value = Guid.initString("bafe99d2-7436-44ce-9e0e-4d89afbfff56");
pub const IID_IAudioSystemEffects2 = &IID_IAudioSystemEffects2_Value;
pub const IAudioSystemEffects2 = extern struct {
    pub const VTable = extern struct {
        base: IAudioSystemEffects.VTable,
        GetEffectsList: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioSystemEffects2,
                ppEffectsIds: ?*?*Guid,
                pcEffects: ?*u32,
                Event: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAudioSystemEffects2,
                ppEffectsIds: ?*?*Guid,
                pcEffects: ?*u32,
                Event: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IAudioSystemEffects.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioSystemEffects2_GetEffectsList(self: *const T, ppEffectsIds: ?*?*Guid, pcEffects: ?*u32, Event: ?HANDLE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioSystemEffects2.VTable, self.vtable).GetEffectsList(@ptrCast(*const IAudioSystemEffects2, self), ppEffectsIds, pcEffects, Event);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAudioSystemEffectsCustomFormats_Value = Guid.initString("b1176e34-bb7f-4f05-bebd-1b18a534e097");
pub const IID_IAudioSystemEffectsCustomFormats = &IID_IAudioSystemEffectsCustomFormats_Value;
pub const IAudioSystemEffectsCustomFormats = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetFormatCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioSystemEffectsCustomFormats,
                pcFormats: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAudioSystemEffectsCustomFormats,
                pcFormats: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFormat: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioSystemEffectsCustomFormats,
                nFormat: u32,
                ppFormat: ?*?*IAudioMediaType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAudioSystemEffectsCustomFormats,
                nFormat: u32,
                ppFormat: ?*?*IAudioMediaType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFormatRepresentation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioSystemEffectsCustomFormats,
                nFormat: u32,
                ppwstrFormatRep: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAudioSystemEffectsCustomFormats,
                nFormat: u32,
                ppwstrFormatRep: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioSystemEffectsCustomFormats_GetFormatCount(self: *const T, pcFormats: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioSystemEffectsCustomFormats.VTable, self.vtable).GetFormatCount(@ptrCast(*const IAudioSystemEffectsCustomFormats, self), pcFormats);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioSystemEffectsCustomFormats_GetFormat(self: *const T, nFormat: u32, ppFormat: ?*?*IAudioMediaType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioSystemEffectsCustomFormats.VTable, self.vtable).GetFormat(@ptrCast(*const IAudioSystemEffectsCustomFormats, self), nFormat, ppFormat);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioSystemEffectsCustomFormats_GetFormatRepresentation(self: *const T, nFormat: u32, ppwstrFormatRep: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioSystemEffectsCustomFormats.VTable, self.vtable).GetFormatRepresentation(@ptrCast(*const IAudioSystemEffectsCustomFormats, self), nFormat, ppwstrFormatRep);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IApoAuxiliaryInputConfiguration_Value = Guid.initString("4ceb0aab-fa19-48ed-a857-87771ae1b768");
pub const IID_IApoAuxiliaryInputConfiguration = &IID_IApoAuxiliaryInputConfiguration_Value;
pub const IApoAuxiliaryInputConfiguration = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddAuxiliaryInput: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IApoAuxiliaryInputConfiguration,
                dwInputId: u32,
                cbDataSize: u32,
                pbyData: [*:0]u8,
                pInputConnection: ?*APO_CONNECTION_DESCRIPTOR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IApoAuxiliaryInputConfiguration,
                dwInputId: u32,
                cbDataSize: u32,
                pbyData: [*:0]u8,
                pInputConnection: ?*APO_CONNECTION_DESCRIPTOR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveAuxiliaryInput: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IApoAuxiliaryInputConfiguration,
                dwInputId: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IApoAuxiliaryInputConfiguration,
                dwInputId: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsInputFormatSupported: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IApoAuxiliaryInputConfiguration,
                pRequestedInputFormat: ?*IAudioMediaType,
                ppSupportedInputFormat: ?*?*IAudioMediaType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IApoAuxiliaryInputConfiguration,
                pRequestedInputFormat: ?*IAudioMediaType,
                ppSupportedInputFormat: ?*?*IAudioMediaType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IApoAuxiliaryInputConfiguration_AddAuxiliaryInput(self: *const T, dwInputId: u32, cbDataSize: u32, pbyData: [*:0]u8, pInputConnection: ?*APO_CONNECTION_DESCRIPTOR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IApoAuxiliaryInputConfiguration.VTable, self.vtable).AddAuxiliaryInput(@ptrCast(*const IApoAuxiliaryInputConfiguration, self), dwInputId, cbDataSize, pbyData, pInputConnection);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IApoAuxiliaryInputConfiguration_RemoveAuxiliaryInput(self: *const T, dwInputId: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IApoAuxiliaryInputConfiguration.VTable, self.vtable).RemoveAuxiliaryInput(@ptrCast(*const IApoAuxiliaryInputConfiguration, self), dwInputId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IApoAuxiliaryInputConfiguration_IsInputFormatSupported(self: *const T, pRequestedInputFormat: ?*IAudioMediaType, ppSupportedInputFormat: ?*?*IAudioMediaType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IApoAuxiliaryInputConfiguration.VTable, self.vtable).IsInputFormatSupported(@ptrCast(*const IApoAuxiliaryInputConfiguration, self), pRequestedInputFormat, ppSupportedInputFormat);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IApoAuxiliaryInputRT_Value = Guid.initString("f851809c-c177-49a0-b1b2-b66f017943ab");
pub const IID_IApoAuxiliaryInputRT = &IID_IApoAuxiliaryInputRT_Value;
pub const IApoAuxiliaryInputRT = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AcceptInput: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IApoAuxiliaryInputRT,
                dwInputId: u32,
                pInputConnection: ?*const APO_CONNECTION_PROPERTY,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const IApoAuxiliaryInputRT,
                dwInputId: u32,
                pInputConnection: ?*const APO_CONNECTION_PROPERTY,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IApoAuxiliaryInputRT_AcceptInput(self: *const T, dwInputId: u32, pInputConnection: ?*const APO_CONNECTION_PROPERTY) callconv(.Inline) void {
            return @ptrCast(*const IApoAuxiliaryInputRT.VTable, self.vtable).AcceptInput(@ptrCast(*const IApoAuxiliaryInputRT, self), dwInputId, pInputConnection);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IApoAcousticEchoCancellation_Value = Guid.initString("25385759-3236-4101-a943-25693dfb5d2d");
pub const IID_IApoAcousticEchoCancellation = &IID_IApoAcousticEchoCancellation_Value;
pub const IApoAcousticEchoCancellation = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const APOInitSystemEffects = extern struct {
    APOInit: APOInitBaseStruct,
    pAPOEndpointProperties: ?*IPropertyStore,
    pAPOSystemEffectsProperties: ?*IPropertyStore,
    pReserved: ?*anyopaque,
    pDeviceCollection: ?*IMMDeviceCollection,
};

pub const APOInitSystemEffects2 = extern struct {
    APOInit: APOInitBaseStruct,
    pAPOEndpointProperties: ?*IPropertyStore,
    pAPOSystemEffectsProperties: ?*IPropertyStore,
    pReserved: ?*anyopaque,
    pDeviceCollection: ?*IMMDeviceCollection,
    nSoftwareIoDeviceInCollection: u32,
    nSoftwareIoConnectorIndex: u32,
    AudioProcessingMode: Guid,
    InitializeForDiscoveryOnly: BOOL,
};

pub const AudioFXExtensionParams = extern struct {
    AddPageParam: LPARAM,
    pwstrEndpointID: ?PWSTR,
    pFxProperties: ?*IPropertyStore,
};

pub const AUDIO_SYSTEMEFFECT_STATE = enum(i32) {
    FF = 0,
    N = 1,
};
pub const AUDIO_SYSTEMEFFECT_STATE_OFF = AUDIO_SYSTEMEFFECT_STATE.FF;
pub const AUDIO_SYSTEMEFFECT_STATE_ON = AUDIO_SYSTEMEFFECT_STATE.N;

pub const AUDIO_SYSTEMEFFECT = extern struct {
    id: Guid,
    canSetState: BOOL,
    state: AUDIO_SYSTEMEFFECT_STATE,
};

const IID_IAudioSystemEffects3_Value = Guid.initString("c58b31cd-fc6a-4255-bc1f-ad29bb0a4a17");
pub const IID_IAudioSystemEffects3 = &IID_IAudioSystemEffects3_Value;
pub const IAudioSystemEffects3 = extern struct {
    pub const VTable = extern struct {
        base: IAudioSystemEffects2.VTable,
        GetControllableSystemEffectsList: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioSystemEffects3,
                effects: ?*?*AUDIO_SYSTEMEFFECT,
                numEffects: ?*u32,
                event: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAudioSystemEffects3,
                effects: ?*?*AUDIO_SYSTEMEFFECT,
                numEffects: ?*u32,
                event: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetAudioSystemEffectState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioSystemEffects3,
                effectId: Guid,
                state: AUDIO_SYSTEMEFFECT_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAudioSystemEffects3,
                effectId: Guid,
                state: AUDIO_SYSTEMEFFECT_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IAudioSystemEffects2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioSystemEffects3_GetControllableSystemEffectsList(self: *const T, effects: ?*?*AUDIO_SYSTEMEFFECT, numEffects: ?*u32, event: ?HANDLE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioSystemEffects3.VTable, self.vtable).GetControllableSystemEffectsList(@ptrCast(*const IAudioSystemEffects3, self), effects, numEffects, event);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioSystemEffects3_SetAudioSystemEffectState(self: *const T, effectId: Guid, state: AUDIO_SYSTEMEFFECT_STATE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioSystemEffects3.VTable, self.vtable).SetAudioSystemEffectState(@ptrCast(*const IAudioSystemEffects3, self), effectId, state);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const APOInitSystemEffects3 = extern struct {
    APOInit: APOInitBaseStruct,
    pAPOEndpointProperties: ?*IPropertyStore,
    pServiceProvider: ?*IServiceProvider,
    pDeviceCollection: ?*IMMDeviceCollection,
    nSoftwareIoDeviceInCollection: u32,
    nSoftwareIoConnectorIndex: u32,
    AudioProcessingMode: Guid,
    InitializeForDiscoveryOnly: BOOL,
};

const IID_IAudioProcessingObjectRTQueueService_Value = Guid.initString("acd65e2f-955b-4b57-b9bf-ac297bb752c9");
pub const IID_IAudioProcessingObjectRTQueueService = &IID_IAudioProcessingObjectRTQueueService_Value;
pub const IAudioProcessingObjectRTQueueService = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetRealTimeWorkQueue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioProcessingObjectRTQueueService,
                workQueueId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAudioProcessingObjectRTQueueService,
                workQueueId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioProcessingObjectRTQueueService_GetRealTimeWorkQueue(self: *const T, workQueueId: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioProcessingObjectRTQueueService.VTable, self.vtable).GetRealTimeWorkQueue(@ptrCast(*const IAudioProcessingObjectRTQueueService, self), workQueueId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const APO_LOG_LEVEL = enum(i32) {
    ALWAYS = 0,
    CRITICAL = 1,
    ERROR = 2,
    WARNING = 3,
    INFO = 4,
    VERBOSE = 5,
};
pub const APO_LOG_LEVEL_ALWAYS = APO_LOG_LEVEL.ALWAYS;
pub const APO_LOG_LEVEL_CRITICAL = APO_LOG_LEVEL.CRITICAL;
pub const APO_LOG_LEVEL_ERROR = APO_LOG_LEVEL.ERROR;
pub const APO_LOG_LEVEL_WARNING = APO_LOG_LEVEL.WARNING;
pub const APO_LOG_LEVEL_INFO = APO_LOG_LEVEL.INFO;
pub const APO_LOG_LEVEL_VERBOSE = APO_LOG_LEVEL.VERBOSE;

const IID_IAudioProcessingObjectLoggingService_Value = Guid.initString("698f0107-1745-4708-95a5-d84478a62a65");
pub const IID_IAudioProcessingObjectLoggingService = &IID_IAudioProcessingObjectLoggingService_Value;
pub const IAudioProcessingObjectLoggingService = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ApoLog: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioProcessingObjectLoggingService,
                level: APO_LOG_LEVEL,
                format: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const IAudioProcessingObjectLoggingService,
                level: APO_LOG_LEVEL,
                format: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioProcessingObjectLoggingService_ApoLog(self: *const T, level: APO_LOG_LEVEL, format: ?[*:0]const u16) callconv(.Inline) void {
            return @ptrCast(*const IAudioProcessingObjectLoggingService.VTable, self.vtable).ApoLog(@ptrCast(*const IAudioProcessingObjectLoggingService, self), level, format);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const APO_NOTIFICATION_TYPE = enum(i32) {
    NONE = 0,
    ENDPOINT_VOLUME = 1,
    ENDPOINT_PROPERTY_CHANGE = 2,
    SYSTEM_EFFECTS_PROPERTY_CHANGE = 3,
};
pub const APO_NOTIFICATION_TYPE_NONE = APO_NOTIFICATION_TYPE.NONE;
pub const APO_NOTIFICATION_TYPE_ENDPOINT_VOLUME = APO_NOTIFICATION_TYPE.ENDPOINT_VOLUME;
pub const APO_NOTIFICATION_TYPE_ENDPOINT_PROPERTY_CHANGE = APO_NOTIFICATION_TYPE.ENDPOINT_PROPERTY_CHANGE;
pub const APO_NOTIFICATION_TYPE_SYSTEM_EFFECTS_PROPERTY_CHANGE = APO_NOTIFICATION_TYPE.SYSTEM_EFFECTS_PROPERTY_CHANGE;

pub const AUDIO_ENDPOINT_VOLUME_CHANGE_NOTIFICATION = extern struct {
    endpoint: ?*IMMDevice,
    volume: ?*AUDIO_VOLUME_NOTIFICATION_DATA,
};

pub const AUDIO_ENDPOINT_PROPERTY_CHANGE_NOTIFICATION = extern struct {
    endpoint: ?*IMMDevice,
    propertyStore: ?*IPropertyStore,
    propertyKey: PROPERTYKEY,
};

pub const AUDIO_SYSTEMEFFECTS_PROPERTY_CHANGE_NOTIFICATION = extern struct {
    endpoint: ?*IMMDevice,
    propertyStoreContext: Guid,
    propertyStoreType: __MIDL___MIDL_itf_mmdeviceapi_0000_0008_0002,
    propertyStore: ?*IPropertyStore,
    propertyKey: PROPERTYKEY,
};

pub const APO_NOTIFICATION = extern struct {
    type: APO_NOTIFICATION_TYPE,
    Anonymous: extern union {
        audioEndpointVolumeChange: AUDIO_ENDPOINT_VOLUME_CHANGE_NOTIFICATION,
        audioEndpointPropertyChange: AUDIO_ENDPOINT_PROPERTY_CHANGE_NOTIFICATION,
        audioSystemEffectsPropertyChange: AUDIO_SYSTEMEFFECTS_PROPERTY_CHANGE_NOTIFICATION,
    },
};

pub const AUDIO_ENDPOINT_VOLUME_APO_NOTIFICATION_DESCRIPTOR = extern struct {
    device: ?*IMMDevice,
};

pub const AUDIO_ENDPOINT_PROPERTY_CHANGE_APO_NOTIFICATION_DESCRIPTOR = extern struct {
    device: ?*IMMDevice,
};

pub const AUDIO_SYSTEMEFFECTS_PROPERTY_CHANGE_APO_NOTIFICATION_DESCRIPTOR = extern struct {
    device: ?*IMMDevice,
    propertyStoreContext: Guid,
};

pub const APO_NOTIFICATION_DESCRIPTOR = extern struct {
    type: APO_NOTIFICATION_TYPE,
    Anonymous: extern union {
        audioEndpointVolume: AUDIO_ENDPOINT_VOLUME_APO_NOTIFICATION_DESCRIPTOR,
        audioEndpointPropertyChange: AUDIO_ENDPOINT_PROPERTY_CHANGE_APO_NOTIFICATION_DESCRIPTOR,
        audioSystemEffectsPropertyChange: AUDIO_SYSTEMEFFECTS_PROPERTY_CHANGE_APO_NOTIFICATION_DESCRIPTOR,
    },
};

const IID_IAudioProcessingObjectNotifications_Value = Guid.initString("56b0c76f-02fd-4b21-a52e-9f8219fc86e4");
pub const IID_IAudioProcessingObjectNotifications = &IID_IAudioProcessingObjectNotifications_Value;
pub const IAudioProcessingObjectNotifications = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetApoNotificationRegistrationInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioProcessingObjectNotifications,
                apoNotifications: [*]?*APO_NOTIFICATION_DESCRIPTOR,
                count: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAudioProcessingObjectNotifications,
                apoNotifications: [*]?*APO_NOTIFICATION_DESCRIPTOR,
                count: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        HandleNotification: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioProcessingObjectNotifications,
                apoNotification: ?*APO_NOTIFICATION,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const IAudioProcessingObjectNotifications,
                apoNotification: ?*APO_NOTIFICATION,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioProcessingObjectNotifications_GetApoNotificationRegistrationInfo(self: *const T, apoNotifications: [*]?*APO_NOTIFICATION_DESCRIPTOR, count: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioProcessingObjectNotifications.VTable, self.vtable).GetApoNotificationRegistrationInfo(@ptrCast(*const IAudioProcessingObjectNotifications, self), apoNotifications, count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioProcessingObjectNotifications_HandleNotification(self: *const T, apoNotification: ?*APO_NOTIFICATION) callconv(.Inline) void {
            return @ptrCast(*const IAudioProcessingObjectNotifications.VTable, self.vtable).HandleNotification(@ptrCast(*const IAudioProcessingObjectNotifications, self), apoNotification);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};


//--------------------------------------------------------------------------------
// Section: Functions (0)
//--------------------------------------------------------------------------------

//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../../zig.zig").unicode_mode) {
    .ansi => struct {
    },
    .wide => struct {
    },
    .unspecified => if (@import("builtin").is_test) struct {
    } else struct {
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (15)
//--------------------------------------------------------------------------------
const Guid = @import("../../zig.zig").Guid;
const __MIDL___MIDL_itf_mmdeviceapi_0000_0008_0002 = @import("../../media/audio.zig").__MIDL___MIDL_itf_mmdeviceapi_0000_0008_0002;
const AUDIO_VOLUME_NOTIFICATION_DATA = @import("../../media/audio.zig").AUDIO_VOLUME_NOTIFICATION_DATA;
const BOOL = @import("../../foundation.zig").BOOL;
const HANDLE = @import("../../foundation.zig").HANDLE;
const HRESULT = @import("../../foundation.zig").HRESULT;
const IMMDevice = @import("../../media/audio.zig").IMMDevice;
const IMMDeviceCollection = @import("../../media/audio.zig").IMMDeviceCollection;
const IPropertyStore = @import("../../ui/shell/properties_system.zig").IPropertyStore;
const IServiceProvider = @import("../../system/com.zig").IServiceProvider;
const IUnknown = @import("../../system/com.zig").IUnknown;
const LPARAM = @import("../../foundation.zig").LPARAM;
const PROPERTYKEY = @import("../../ui/shell/properties_system.zig").PROPERTYKEY;
const PWSTR = @import("../../foundation.zig").PWSTR;
const WAVEFORMATEX = @import("../../media/audio.zig").WAVEFORMATEX;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "FNAPONOTIFICATIONCALLBACK")) { _ = FNAPONOTIFICATIONCALLBACK; }

    @setEvalBranchQuota(
        comptime @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        if (decl.is_pub) {
            _ = @field(@This(), decl.name);
        }
    }
}
