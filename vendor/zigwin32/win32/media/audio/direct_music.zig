//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (236)
//--------------------------------------------------------------------------------
pub const DMUS_MAX_DESCRIPTION = @as(u32, 128);
pub const DMUS_MAX_DRIVER = @as(u32, 128);
pub const DMUS_EFFECT_NONE = @as(u32, 0);
pub const DMUS_EFFECT_REVERB = @as(u32, 1);
pub const DMUS_EFFECT_CHORUS = @as(u32, 2);
pub const DMUS_EFFECT_DELAY = @as(u32, 4);
pub const DMUS_PC_INPUTCLASS = @as(u32, 0);
pub const DMUS_PC_OUTPUTCLASS = @as(u32, 1);
pub const DMUS_PC_DLS = @as(u32, 1);
pub const DMUS_PC_EXTERNAL = @as(u32, 2);
pub const DMUS_PC_SOFTWARESYNTH = @as(u32, 4);
pub const DMUS_PC_MEMORYSIZEFIXED = @as(u32, 8);
pub const DMUS_PC_GMINHARDWARE = @as(u32, 16);
pub const DMUS_PC_GSINHARDWARE = @as(u32, 32);
pub const DMUS_PC_XGINHARDWARE = @as(u32, 64);
pub const DMUS_PC_DIRECTSOUND = @as(u32, 128);
pub const DMUS_PC_SHAREABLE = @as(u32, 256);
pub const DMUS_PC_DLS2 = @as(u32, 512);
pub const DMUS_PC_AUDIOPATH = @as(u32, 1024);
pub const DMUS_PC_WAVE = @as(u32, 2048);
pub const DMUS_PC_SYSTEMMEMORY = @as(u32, 2147483647);
pub const DMUS_PORT_WINMM_DRIVER = @as(u32, 0);
pub const DMUS_PORT_USER_MODE_SYNTH = @as(u32, 1);
pub const DMUS_PORT_KERNEL_MODE = @as(u32, 2);
pub const DMUS_PORTPARAMS_VOICES = @as(u32, 1);
pub const DMUS_PORTPARAMS_CHANNELGROUPS = @as(u32, 2);
pub const DMUS_PORTPARAMS_AUDIOCHANNELS = @as(u32, 4);
pub const DMUS_PORTPARAMS_SAMPLERATE = @as(u32, 8);
pub const DMUS_PORTPARAMS_EFFECTS = @as(u32, 32);
pub const DMUS_PORTPARAMS_SHARE = @as(u32, 64);
pub const DMUS_PORTPARAMS_FEATURES = @as(u32, 128);
pub const DMUS_PORT_FEATURE_AUDIOPATH = @as(u32, 1);
pub const DMUS_PORT_FEATURE_STREAMING = @as(u32, 2);
pub const DMUS_SYNTHSTATS_VOICES = @as(u32, 1);
pub const DMUS_SYNTHSTATS_TOTAL_CPU = @as(u32, 2);
pub const DMUS_SYNTHSTATS_CPU_PER_VOICE = @as(u32, 4);
pub const DMUS_SYNTHSTATS_LOST_NOTES = @as(u32, 8);
pub const DMUS_SYNTHSTATS_PEAK_VOLUME = @as(u32, 16);
pub const DMUS_SYNTHSTATS_FREE_MEMORY = @as(u32, 32);
pub const DMUS_SYNTHSTATS_SYSTEMMEMORY = @as(u32, 2147483647);
pub const DMUS_CLOCKF_GLOBAL = @as(u32, 1);
pub const DSBUSID_FIRST_SPKR_LOC = @as(u32, 0);
pub const DSBUSID_FRONT_LEFT = @as(u32, 0);
pub const DSBUSID_LEFT = @as(u32, 0);
pub const DSBUSID_FRONT_RIGHT = @as(u32, 1);
pub const DSBUSID_RIGHT = @as(u32, 1);
pub const DSBUSID_FRONT_CENTER = @as(u32, 2);
pub const DSBUSID_LOW_FREQUENCY = @as(u32, 3);
pub const DSBUSID_BACK_LEFT = @as(u32, 4);
pub const DSBUSID_BACK_RIGHT = @as(u32, 5);
pub const DSBUSID_FRONT_LEFT_OF_CENTER = @as(u32, 6);
pub const DSBUSID_FRONT_RIGHT_OF_CENTER = @as(u32, 7);
pub const DSBUSID_BACK_CENTER = @as(u32, 8);
pub const DSBUSID_SIDE_LEFT = @as(u32, 9);
pub const DSBUSID_SIDE_RIGHT = @as(u32, 10);
pub const DSBUSID_TOP_CENTER = @as(u32, 11);
pub const DSBUSID_TOP_FRONT_LEFT = @as(u32, 12);
pub const DSBUSID_TOP_FRONT_CENTER = @as(u32, 13);
pub const DSBUSID_TOP_FRONT_RIGHT = @as(u32, 14);
pub const DSBUSID_TOP_BACK_LEFT = @as(u32, 15);
pub const DSBUSID_TOP_BACK_CENTER = @as(u32, 16);
pub const DSBUSID_TOP_BACK_RIGHT = @as(u32, 17);
pub const DSBUSID_LAST_SPKR_LOC = @as(u32, 17);
pub const DSBUSID_REVERB_SEND = @as(u32, 64);
pub const DSBUSID_CHORUS_SEND = @as(u32, 65);
pub const DSBUSID_DYNAMIC_0 = @as(u32, 512);
pub const DSBUSID_NULL = @as(u32, 4294967295);
pub const DAUD_CRITICAL_VOICE_PRIORITY = @as(u32, 4026531840);
pub const DAUD_HIGH_VOICE_PRIORITY = @as(u32, 3221225472);
pub const DAUD_STANDARD_VOICE_PRIORITY = @as(u32, 2147483648);
pub const DAUD_LOW_VOICE_PRIORITY = @as(u32, 1073741824);
pub const DAUD_PERSIST_VOICE_PRIORITY = @as(u32, 268435456);
pub const DAUD_CHAN1_VOICE_PRIORITY_OFFSET = @as(u32, 14);
pub const DAUD_CHAN2_VOICE_PRIORITY_OFFSET = @as(u32, 13);
pub const DAUD_CHAN3_VOICE_PRIORITY_OFFSET = @as(u32, 12);
pub const DAUD_CHAN4_VOICE_PRIORITY_OFFSET = @as(u32, 11);
pub const DAUD_CHAN5_VOICE_PRIORITY_OFFSET = @as(u32, 10);
pub const DAUD_CHAN6_VOICE_PRIORITY_OFFSET = @as(u32, 9);
pub const DAUD_CHAN7_VOICE_PRIORITY_OFFSET = @as(u32, 8);
pub const DAUD_CHAN8_VOICE_PRIORITY_OFFSET = @as(u32, 7);
pub const DAUD_CHAN9_VOICE_PRIORITY_OFFSET = @as(u32, 6);
pub const DAUD_CHAN10_VOICE_PRIORITY_OFFSET = @as(u32, 15);
pub const DAUD_CHAN11_VOICE_PRIORITY_OFFSET = @as(u32, 5);
pub const DAUD_CHAN12_VOICE_PRIORITY_OFFSET = @as(u32, 4);
pub const DAUD_CHAN13_VOICE_PRIORITY_OFFSET = @as(u32, 3);
pub const DAUD_CHAN14_VOICE_PRIORITY_OFFSET = @as(u32, 2);
pub const DAUD_CHAN15_VOICE_PRIORITY_OFFSET = @as(u32, 1);
pub const DAUD_CHAN16_VOICE_PRIORITY_OFFSET = @as(u32, 0);
pub const CLSID_DirectMusic = Guid.initString("636b9f10-0c7d-11d1-95b2-0020afdc7421");
pub const CLSID_DirectMusicCollection = Guid.initString("480ff4b0-28b2-11d1-bef7-00c04fbf8fef");
pub const CLSID_DirectMusicSynth = Guid.initString("58c2b4d0-46e7-11d1-89ac-00a0c9054129");
pub const GUID_DMUS_PROP_GM_Hardware = Guid.initString("178f2f24-c364-11d1-a760-0000f875ac12");
pub const GUID_DMUS_PROP_GS_Hardware = Guid.initString("178f2f25-c364-11d1-a760-0000f875ac12");
pub const GUID_DMUS_PROP_XG_Hardware = Guid.initString("178f2f26-c364-11d1-a760-0000f875ac12");
pub const GUID_DMUS_PROP_XG_Capable = Guid.initString("6496aba1-61b0-11d2-afa6-00aa0024d8b6");
pub const GUID_DMUS_PROP_GS_Capable = Guid.initString("6496aba2-61b0-11d2-afa6-00aa0024d8b6");
pub const GUID_DMUS_PROP_DLS1 = Guid.initString("178f2f27-c364-11d1-a760-0000f875ac12");
pub const GUID_DMUS_PROP_DLS2 = Guid.initString("f14599e5-4689-11d2-afa6-00aa0024d8b6");
pub const GUID_DMUS_PROP_INSTRUMENT2 = Guid.initString("865fd372-9f67-11d2-872a-00600893b1bd");
pub const GUID_DMUS_PROP_SynthSink_DSOUND = Guid.initString("0aa97844-c877-11d1-870c-00600893b1bd");
pub const GUID_DMUS_PROP_SynthSink_WAVE = Guid.initString("0aa97845-c877-11d1-870c-00600893b1bd");
pub const GUID_DMUS_PROP_SampleMemorySize = Guid.initString("178f2f28-c364-11d1-a760-0000f875ac12");
pub const GUID_DMUS_PROP_SamplePlaybackRate = Guid.initString("2a91f713-a4bf-11d2-bbdf-00600833dbd8");
pub const GUID_DMUS_PROP_WriteLatency = Guid.initString("268a0fa0-60f2-11d2-afa6-00aa0024d8b6");
pub const GUID_DMUS_PROP_WritePeriod = Guid.initString("268a0fa1-60f2-11d2-afa6-00aa0024d8b6");
pub const GUID_DMUS_PROP_MemorySize = Guid.initString("178f2f28-c364-11d1-a760-0000f875ac12");
pub const GUID_DMUS_PROP_WavesReverb = Guid.initString("04cb5622-32e5-11d2-afa6-00aa0024d8b6");
pub const GUID_DMUS_PROP_Effects = Guid.initString("cda8d611-684a-11d2-871e-00600893b1bd");
pub const GUID_DMUS_PROP_LegacyCaps = Guid.initString("cfa7cdc2-00a1-11d2-aad5-0000f875ac12");
pub const GUID_DMUS_PROP_Volume = Guid.initString("fedfae25-e46e-11d1-aace-0000f875ac12");
pub const DMUS_VOLUME_MAX = @as(u32, 2000);
pub const DMUS_VOLUME_MIN = @as(i32, -20000);
pub const DMUS_EVENT_STRUCTURED = @as(u32, 1);
pub const DMUS_DOWNLOADINFO_INSTRUMENT = @as(u32, 1);
pub const DMUS_DOWNLOADINFO_WAVE = @as(u32, 2);
pub const DMUS_DOWNLOADINFO_INSTRUMENT2 = @as(u32, 3);
pub const DMUS_DOWNLOADINFO_WAVEARTICULATION = @as(u32, 4);
pub const DMUS_DOWNLOADINFO_STREAMINGWAVE = @as(u32, 5);
pub const DMUS_DOWNLOADINFO_ONESHOTWAVE = @as(u32, 6);
pub const DMUS_DEFAULT_SIZE_OFFSETTABLE = @as(u32, 1);
pub const DMUS_INSTRUMENT_GM_INSTRUMENT = @as(u32, 1);
pub const DMUS_MIN_DATA_SIZE = @as(u32, 4);
pub const CONN_SRC_NONE = @as(u32, 0);
pub const CONN_SRC_LFO = @as(u32, 1);
pub const CONN_SRC_KEYONVELOCITY = @as(u32, 2);
pub const CONN_SRC_KEYNUMBER = @as(u32, 3);
pub const CONN_SRC_EG1 = @as(u32, 4);
pub const CONN_SRC_EG2 = @as(u32, 5);
pub const CONN_SRC_PITCHWHEEL = @as(u32, 6);
pub const CONN_SRC_CC1 = @as(u32, 129);
pub const CONN_SRC_CC7 = @as(u32, 135);
pub const CONN_SRC_CC10 = @as(u32, 138);
pub const CONN_SRC_CC11 = @as(u32, 139);
pub const CONN_DST_NONE = @as(u32, 0);
pub const CONN_DST_ATTENUATION = @as(u32, 1);
pub const CONN_DST_PITCH = @as(u32, 3);
pub const CONN_DST_PAN = @as(u32, 4);
pub const CONN_DST_LFO_FREQUENCY = @as(u32, 260);
pub const CONN_DST_LFO_STARTDELAY = @as(u32, 261);
pub const CONN_DST_EG1_ATTACKTIME = @as(u32, 518);
pub const CONN_DST_EG1_DECAYTIME = @as(u32, 519);
pub const CONN_DST_EG1_RELEASETIME = @as(u32, 521);
pub const CONN_DST_EG1_SUSTAINLEVEL = @as(u32, 522);
pub const CONN_DST_EG2_ATTACKTIME = @as(u32, 778);
pub const CONN_DST_EG2_DECAYTIME = @as(u32, 779);
pub const CONN_DST_EG2_RELEASETIME = @as(u32, 781);
pub const CONN_DST_EG2_SUSTAINLEVEL = @as(u32, 782);
pub const CONN_TRN_NONE = @as(u32, 0);
pub const CONN_TRN_CONCAVE = @as(u32, 1);
pub const F_INSTRUMENT_DRUMS = @as(u32, 2147483648);
pub const F_RGN_OPTION_SELFNONEXCLUSIVE = @as(u32, 1);
pub const WAVELINK_CHANNEL_LEFT = @as(i32, 1);
pub const WAVELINK_CHANNEL_RIGHT = @as(i32, 2);
pub const F_WAVELINK_PHASE_MASTER = @as(u32, 1);
pub const POOL_CUE_NULL = @as(i32, -1);
pub const F_WSMP_NO_TRUNCATION = @as(i32, 1);
pub const F_WSMP_NO_COMPRESSION = @as(i32, 2);
pub const WLOOP_TYPE_FORWARD = @as(u32, 0);
pub const CONN_SRC_POLYPRESSURE = @as(u32, 7);
pub const CONN_SRC_CHANNELPRESSURE = @as(u32, 8);
pub const CONN_SRC_VIBRATO = @as(u32, 9);
pub const CONN_SRC_MONOPRESSURE = @as(u32, 10);
pub const CONN_SRC_CC91 = @as(u32, 219);
pub const CONN_SRC_CC93 = @as(u32, 221);
pub const CONN_DST_GAIN = @as(u32, 1);
pub const CONN_DST_KEYNUMBER = @as(u32, 5);
pub const CONN_DST_LEFT = @as(u32, 16);
pub const CONN_DST_RIGHT = @as(u32, 17);
pub const CONN_DST_CENTER = @as(u32, 18);
pub const CONN_DST_LEFTREAR = @as(u32, 19);
pub const CONN_DST_RIGHTREAR = @as(u32, 20);
pub const CONN_DST_LFE_CHANNEL = @as(u32, 21);
pub const CONN_DST_CHORUS = @as(u32, 128);
pub const CONN_DST_REVERB = @as(u32, 129);
pub const CONN_DST_VIB_FREQUENCY = @as(u32, 276);
pub const CONN_DST_VIB_STARTDELAY = @as(u32, 277);
pub const CONN_DST_EG1_DELAYTIME = @as(u32, 523);
pub const CONN_DST_EG1_HOLDTIME = @as(u32, 524);
pub const CONN_DST_EG1_SHUTDOWNTIME = @as(u32, 525);
pub const CONN_DST_EG2_DELAYTIME = @as(u32, 783);
pub const CONN_DST_EG2_HOLDTIME = @as(u32, 784);
pub const CONN_DST_FILTER_CUTOFF = @as(u32, 1280);
pub const CONN_DST_FILTER_Q = @as(u32, 1281);
pub const CONN_TRN_CONVEX = @as(u32, 2);
pub const CONN_TRN_SWITCH = @as(u32, 3);
pub const DLS_CDL_AND = @as(u32, 1);
pub const DLS_CDL_OR = @as(u32, 2);
pub const DLS_CDL_XOR = @as(u32, 3);
pub const DLS_CDL_ADD = @as(u32, 4);
pub const DLS_CDL_SUBTRACT = @as(u32, 5);
pub const DLS_CDL_MULTIPLY = @as(u32, 6);
pub const DLS_CDL_DIVIDE = @as(u32, 7);
pub const DLS_CDL_LOGICAL_AND = @as(u32, 8);
pub const DLS_CDL_LOGICAL_OR = @as(u32, 9);
pub const DLS_CDL_LT = @as(u32, 10);
pub const DLS_CDL_LE = @as(u32, 11);
pub const DLS_CDL_GT = @as(u32, 12);
pub const DLS_CDL_GE = @as(u32, 13);
pub const DLS_CDL_EQ = @as(u32, 14);
pub const DLS_CDL_NOT = @as(u32, 15);
pub const DLS_CDL_CONST = @as(u32, 16);
pub const DLS_CDL_QUERY = @as(u32, 17);
pub const DLS_CDL_QUERYSUPPORTED = @as(u32, 18);
pub const WLOOP_TYPE_RELEASE = @as(u32, 2);
pub const F_WAVELINK_MULTICHANNEL = @as(u32, 2);
pub const DLSID_GMInHardware = Guid.initString("178f2f24-c364-11d1-a760-0000f875ac12");
pub const DLSID_GSInHardware = Guid.initString("178f2f25-c364-11d1-a760-0000f875ac12");
pub const DLSID_XGInHardware = Guid.initString("178f2f26-c364-11d1-a760-0000f875ac12");
pub const DLSID_SupportsDLS1 = Guid.initString("178f2f27-c364-11d1-a760-0000f875ac12");
pub const DLSID_SupportsDLS2 = Guid.initString("f14599e5-4689-11d2-afa6-00aa0024d8b6");
pub const DLSID_SampleMemorySize = Guid.initString("178f2f28-c364-11d1-a760-0000f875ac12");
pub const DLSID_ManufacturersID = Guid.initString("b03e1181-8095-11d2-a1ef-00600833dbd8");
pub const DLSID_ProductID = Guid.initString("b03e1182-8095-11d2-a1ef-00600833dbd8");
pub const DLSID_SamplePlaybackRate = Guid.initString("2a91f713-a4bf-11d2-bbdf-00600833dbd8");
pub const REFRESH_F_LASTBUFFER = @as(u32, 1);
pub const CLSID_DirectMusicSynthSink = Guid.initString("aec17ce3-a514-11d1-afa6-00aa0024d8b6");
pub const GUID_DMUS_PROP_SetSynthSink = Guid.initString("0a3a5ba5-37b6-11d2-b9f9-0000f875ac12");
pub const GUID_DMUS_PROP_SinkUsesDSound = Guid.initString("be208857-8952-11d2-ba1c-0000f875ac12");
pub const CLSID_DirectSoundPrivate = Guid.initString("11ab3ec0-25ec-11d1-a4d8-00c04fc28aca");
pub const DSPROPSETID_DirectSoundDevice = Guid.initString("84624f82-25ec-11d1-a4d8-00c04fc28aca");
pub const DV_DVSD_NTSC_FRAMESIZE = @as(i32, 120000);
pub const DV_DVSD_PAL_FRAMESIZE = @as(i32, 144000);
pub const DV_SMCHN = @as(u32, 57344);
pub const DV_AUDIOMODE = @as(u32, 3840);
pub const DV_AUDIOSMP = @as(u32, 939524096);
pub const DV_AUDIOQU = @as(u32, 117440512);
pub const DV_NTSCPAL = @as(u32, 2097152);
pub const DV_STYPE = @as(u32, 2031616);
pub const DV_NTSC = @as(u32, 0);
pub const DV_PAL = @as(u32, 1);
pub const DV_SD = @as(u32, 0);
pub const DV_HD = @as(u32, 1);
pub const DV_SL = @as(u32, 2);
pub const DV_CAP_AUD16Bits = @as(u32, 0);
pub const DV_CAP_AUD12Bits = @as(u32, 1);
pub const SIZE_DVINFO = @as(u32, 32);

//--------------------------------------------------------------------------------
// Section: Types (74)
//--------------------------------------------------------------------------------
pub const DLSID = extern struct {
    ulData1: u32,
    usData2: u16,
    usData3: u16,
    abData4: [8]u8,
};

pub const DLSVERSION = extern struct {
    dwVersionMS: u32,
    dwVersionLS: u32,
};

pub const CONNECTION = extern struct {
    usSource: u16,
    usControl: u16,
    usDestination: u16,
    usTransform: u16,
    lScale: i32,
};

pub const CONNECTIONLIST = extern struct {
    cbSize: u32,
    cConnections: u32,
};

pub const RGNRANGE = extern struct {
    usLow: u16,
    usHigh: u16,
};

pub const MIDILOCALE = extern struct {
    ulBank: u32,
    ulInstrument: u32,
};

pub const RGNHEADER = extern struct {
    RangeKey: RGNRANGE,
    RangeVelocity: RGNRANGE,
    fusOptions: u16,
    usKeyGroup: u16,
};

pub const INSTHEADER = extern struct {
    cRegions: u32,
    Locale: MIDILOCALE,
};

pub const DLSHEADER = extern struct {
    cInstruments: u32,
};

pub const WAVELINK = extern struct {
    fusOptions: u16,
    usPhaseGroup: u16,
    ulChannel: u32,
    ulTableIndex: u32,
};

pub const POOLCUE = extern struct {
    ulOffset: u32,
};

pub const POOLTABLE = extern struct {
    cbSize: u32,
    cCues: u32,
};

pub const _rwsmp = extern struct {
    cbSize: u32,
    usUnityNote: u16,
    sFineTune: i16,
    lAttenuation: i32,
    fulOptions: u32,
    cSampleLoops: u32,
};

pub const _rloop = extern struct {
    cbSize: u32,
    ulType: u32,
    ulStart: u32,
    ulLength: u32,
};

pub const DMUS_DOWNLOADINFO = extern struct {
    dwDLType: u32,
    dwDLId: u32,
    dwNumOffsetTableEntries: u32,
    cbSize: u32,
};

pub const DMUS_OFFSETTABLE = extern struct {
    ulOffsetTable: [1]u32,
};

pub const DMUS_INSTRUMENT = extern struct {
    ulPatch: u32,
    ulFirstRegionIdx: u32,
    ulGlobalArtIdx: u32,
    ulFirstExtCkIdx: u32,
    ulCopyrightIdx: u32,
    ulFlags: u32,
};

pub const DMUS_REGION = extern struct {
    RangeKey: RGNRANGE,
    RangeVelocity: RGNRANGE,
    fusOptions: u16,
    usKeyGroup: u16,
    ulRegionArtIdx: u32,
    ulNextRegionIdx: u32,
    ulFirstExtCkIdx: u32,
    WaveLink: WAVELINK,
    WSMP: _rwsmp,
    WLOOP: [1]_rloop,
};

pub const DMUS_LFOPARAMS = extern struct {
    pcFrequency: i32,
    tcDelay: i32,
    gcVolumeScale: i32,
    pcPitchScale: i32,
    gcMWToVolume: i32,
    pcMWToPitch: i32,
};

pub const DMUS_VEGPARAMS = extern struct {
    tcAttack: i32,
    tcDecay: i32,
    ptSustain: i32,
    tcRelease: i32,
    tcVel2Attack: i32,
    tcKey2Decay: i32,
};

pub const DMUS_PEGPARAMS = extern struct {
    tcAttack: i32,
    tcDecay: i32,
    ptSustain: i32,
    tcRelease: i32,
    tcVel2Attack: i32,
    tcKey2Decay: i32,
    pcRange: i32,
};

pub const DMUS_MSCPARAMS = extern struct {
    ptDefaultPan: i32,
};

pub const DMUS_ARTICPARAMS = extern struct {
    LFO: DMUS_LFOPARAMS,
    VolEG: DMUS_VEGPARAMS,
    PitchEG: DMUS_PEGPARAMS,
    Misc: DMUS_MSCPARAMS,
};

pub const DMUS_ARTICULATION = extern struct {
    ulArt1Idx: u32,
    ulFirstExtCkIdx: u32,
};

pub const DMUS_ARTICULATION2 = extern struct {
    ulArtIdx: u32,
    ulFirstExtCkIdx: u32,
    ulNextArtIdx: u32,
};

pub const DMUS_EXTENSIONCHUNK = extern struct {
    cbSize: u32,
    ulNextExtCkIdx: u32,
    ExtCkID: u32,
    byExtCk: [4]u8,
};

pub const DMUS_COPYRIGHT = extern struct {
    cbSize: u32,
    byCopyright: [4]u8,
};

pub const DMUS_WAVEDATA = extern struct {
    cbSize: u32,
    byData: [4]u8,
};

pub const DMUS_WAVE = extern struct {
    ulFirstExtCkIdx: u32,
    ulCopyrightIdx: u32,
    ulWaveDataIdx: u32,
    WaveformatEx: WAVEFORMATEX,
};

pub const DMUS_NOTERANGE = extern struct {
    dwLowNote: u32,
    dwHighNote: u32,
};

pub const DMUS_WAVEARTDL = extern struct {
    ulDownloadIdIdx: u32,
    ulBus: u32,
    ulBuffers: u32,
    ulMasterDLId: u32,
    usOptions: u16,
};

pub const DMUS_WAVEDL = extern struct {
    cbWaveData: u32,
};

pub const DMUS_EVENTHEADER = extern struct {
    cbEvent: u32 align(4),
    dwChannelGroup: u32 align(4),
    rtDelta: i64 align(4),
    dwFlags: u32 align(4),
};

pub const DMUS_BUFFERDESC = extern struct {
    dwSize: u32,
    dwFlags: u32,
    guidBufferFormat: Guid,
    cbBuffer: u32,
};

pub const DMUS_PORTCAPS = extern struct {
    dwSize: u32,
    dwFlags: u32,
    guidPort: Guid,
    dwClass: u32,
    dwType: u32,
    dwMemorySize: u32,
    dwMaxChannelGroups: u32,
    dwMaxVoices: u32,
    dwMaxAudioChannels: u32,
    dwEffectFlags: u32,
    wszDescription: [128]u16,
};

pub const _DMUS_PORTPARAMS = extern struct {
    dwSize: u32,
    dwValidParams: u32,
    dwVoices: u32,
    dwChannelGroups: u32,
    dwAudioChannels: u32,
    dwSampleRate: u32,
    dwEffectFlags: u32,
    fShare: BOOL,
};

pub const DMUS_PORTPARAMS8 = extern struct {
    dwSize: u32,
    dwValidParams: u32,
    dwVoices: u32,
    dwChannelGroups: u32,
    dwAudioChannels: u32,
    dwSampleRate: u32,
    dwEffectFlags: u32,
    fShare: BOOL,
    dwFeatures: u32,
};

pub const DMUS_SYNTHSTATS = extern struct {
    dwSize: u32,
    dwValidStats: u32,
    dwVoices: u32,
    dwTotalCPU: u32,
    dwCPUPerVoice: u32,
    dwLostNotes: u32,
    dwFreeMemory: u32,
    lPeakVolume: i32,
};

pub const DMUS_SYNTHSTATS8 = extern struct {
    dwSize: u32,
    dwValidStats: u32,
    dwVoices: u32,
    dwTotalCPU: u32,
    dwCPUPerVoice: u32,
    dwLostNotes: u32,
    dwFreeMemory: u32,
    lPeakVolume: i32,
    dwSynthMemUse: u32,
};

pub const DMUS_WAVES_REVERB_PARAMS = extern struct {
    fInGain: f32,
    fReverbMix: f32,
    fReverbTime: f32,
    fHighFreqRTRatio: f32,
};

pub const DMUS_CLOCKTYPE = enum(i32) {
    SYSTEM = 0,
    WAVE = 1,
};
pub const DMUS_CLOCK_SYSTEM = DMUS_CLOCKTYPE.SYSTEM;
pub const DMUS_CLOCK_WAVE = DMUS_CLOCKTYPE.WAVE;

pub const DMUS_CLOCKINFO7 = extern struct {
    dwSize: u32,
    ctType: DMUS_CLOCKTYPE,
    guidClock: Guid,
    wszDescription: [128]u16,
};

pub const DMUS_CLOCKINFO8 = extern struct {
    dwSize: u32,
    ctType: DMUS_CLOCKTYPE,
    guidClock: Guid,
    wszDescription: [128]u16,
    dwFlags: u32,
};

const IID_IDirectMusic_Value = Guid.initString("6536115a-7b2d-11d2-ba18-0000f875ac12");
pub const IID_IDirectMusic = &IID_IDirectMusic_Value;
pub const IDirectMusic = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EnumPort: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectMusic,
                dwIndex: u32,
                pPortCaps: ?*DMUS_PORTCAPS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectMusic,
                dwIndex: u32,
                pPortCaps: ?*DMUS_PORTCAPS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateMusicBuffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectMusic,
                pBufferDesc: ?*DMUS_BUFFERDESC,
                ppBuffer: ?*?*IDirectMusicBuffer,
                pUnkOuter: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectMusic,
                pBufferDesc: ?*DMUS_BUFFERDESC,
                ppBuffer: ?*?*IDirectMusicBuffer,
                pUnkOuter: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreatePort: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectMusic,
                rclsidPort: ?*const Guid,
                pPortParams: ?*DMUS_PORTPARAMS8,
                ppPort: ?*?*IDirectMusicPort,
                pUnkOuter: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectMusic,
                rclsidPort: ?*const Guid,
                pPortParams: ?*DMUS_PORTPARAMS8,
                ppPort: ?*?*IDirectMusicPort,
                pUnkOuter: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumMasterClock: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectMusic,
                dwIndex: u32,
                lpClockInfo: ?*DMUS_CLOCKINFO8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectMusic,
                dwIndex: u32,
                lpClockInfo: ?*DMUS_CLOCKINFO8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMasterClock: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectMusic,
                pguidClock: ?*Guid,
                ppReferenceClock: ?*?*IReferenceClock,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectMusic,
                pguidClock: ?*Guid,
                ppReferenceClock: ?*?*IReferenceClock,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetMasterClock: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectMusic,
                rguidClock: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectMusic,
                rguidClock: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Activate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectMusic,
                fEnable: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectMusic,
                fEnable: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDefaultPort: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectMusic,
                pguidPort: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectMusic,
                pguidPort: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDirectSound: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectMusic,
                pDirectSound: ?*IDirectSound,
                hWnd: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectMusic,
                pDirectSound: ?*IDirectSound,
                hWnd: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectMusic_EnumPort(self: *const T, dwIndex: u32, pPortCaps: ?*DMUS_PORTCAPS) HRESULT {
                return @as(*const IDirectMusic.VTable, @ptrCast(self.vtable)).EnumPort(@as(*const IDirectMusic, @ptrCast(self)), dwIndex, pPortCaps);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectMusic_CreateMusicBuffer(self: *const T, pBufferDesc: ?*DMUS_BUFFERDESC, ppBuffer: ?*?*IDirectMusicBuffer, pUnkOuter: ?*IUnknown) HRESULT {
                return @as(*const IDirectMusic.VTable, @ptrCast(self.vtable)).CreateMusicBuffer(@as(*const IDirectMusic, @ptrCast(self)), pBufferDesc, ppBuffer, pUnkOuter);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectMusic_CreatePort(self: *const T, rclsidPort: ?*const Guid, pPortParams: ?*DMUS_PORTPARAMS8, ppPort: ?*?*IDirectMusicPort, pUnkOuter: ?*IUnknown) HRESULT {
                return @as(*const IDirectMusic.VTable, @ptrCast(self.vtable)).CreatePort(@as(*const IDirectMusic, @ptrCast(self)), rclsidPort, pPortParams, ppPort, pUnkOuter);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectMusic_EnumMasterClock(self: *const T, dwIndex: u32, lpClockInfo: ?*DMUS_CLOCKINFO8) HRESULT {
                return @as(*const IDirectMusic.VTable, @ptrCast(self.vtable)).EnumMasterClock(@as(*const IDirectMusic, @ptrCast(self)), dwIndex, lpClockInfo);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectMusic_GetMasterClock(self: *const T, pguidClock: ?*Guid, ppReferenceClock: ?*?*IReferenceClock) HRESULT {
                return @as(*const IDirectMusic.VTable, @ptrCast(self.vtable)).GetMasterClock(@as(*const IDirectMusic, @ptrCast(self)), pguidClock, ppReferenceClock);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectMusic_SetMasterClock(self: *const T, rguidClock: ?*const Guid) HRESULT {
                return @as(*const IDirectMusic.VTable, @ptrCast(self.vtable)).SetMasterClock(@as(*const IDirectMusic, @ptrCast(self)), rguidClock);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectMusic_Activate(self: *const T, fEnable: BOOL) HRESULT {
                return @as(*const IDirectMusic.VTable, @ptrCast(self.vtable)).Activate(@as(*const IDirectMusic, @ptrCast(self)), fEnable);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectMusic_GetDefaultPort(self: *const T, pguidPort: ?*Guid) HRESULT {
                return @as(*const IDirectMusic.VTable, @ptrCast(self.vtable)).GetDefaultPort(@as(*const IDirectMusic, @ptrCast(self)), pguidPort);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectMusic_SetDirectSound(self: *const T, pDirectSound: ?*IDirectSound, hWnd: ?HWND) HRESULT {
                return @as(*const IDirectMusic.VTable, @ptrCast(self.vtable)).SetDirectSound(@as(*const IDirectMusic, @ptrCast(self)), pDirectSound, hWnd);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDirectMusic8_Value = Guid.initString("2d3629f7-813d-4939-8508-f05c6b75fd97");
pub const IID_IDirectMusic8 = &IID_IDirectMusic8_Value;
pub const IDirectMusic8 = extern struct {
    pub const VTable = extern struct {
        base: IDirectMusic.VTable,
        SetExternalMasterClock: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectMusic8,
                pClock: ?*IReferenceClock,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectMusic8,
                pClock: ?*IReferenceClock,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDirectMusic.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectMusic8_SetExternalMasterClock(self: *const T, pClock: ?*IReferenceClock) HRESULT {
                return @as(*const IDirectMusic8.VTable, @ptrCast(self.vtable)).SetExternalMasterClock(@as(*const IDirectMusic8, @ptrCast(self)), pClock);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDirectMusicBuffer_Value = Guid.initString("d2ac2878-b39b-11d1-8704-00600893b1bd");
pub const IID_IDirectMusicBuffer = &IID_IDirectMusicBuffer_Value;
pub const IDirectMusicBuffer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Flush: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectMusicBuffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectMusicBuffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TotalTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectMusicBuffer,
                prtTime: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectMusicBuffer,
                prtTime: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PackStructured: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectMusicBuffer,
                rt: i64,
                dwChannelGroup: u32,
                dwChannelMessage: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectMusicBuffer,
                rt: i64,
                dwChannelGroup: u32,
                dwChannelMessage: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PackUnstructured: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectMusicBuffer,
                rt: i64,
                dwChannelGroup: u32,
                cb: u32,
                lpb: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectMusicBuffer,
                rt: i64,
                dwChannelGroup: u32,
                cb: u32,
                lpb: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ResetReadPtr: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectMusicBuffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectMusicBuffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNextEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectMusicBuffer,
                prt: ?*i64,
                pdwChannelGroup: ?*u32,
                pdwLength: ?*u32,
                ppData: ?*?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectMusicBuffer,
                prt: ?*i64,
                pdwChannelGroup: ?*u32,
                pdwLength: ?*u32,
                ppData: ?*?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRawBufferPtr: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectMusicBuffer,
                ppData: ?*?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectMusicBuffer,
                ppData: ?*?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStartTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectMusicBuffer,
                prt: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectMusicBuffer,
                prt: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetUsedBytes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectMusicBuffer,
                pcb: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectMusicBuffer,
                pcb: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMaxBytes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectMusicBuffer,
                pcb: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectMusicBuffer,
                pcb: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBufferFormat: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectMusicBuffer,
                pGuidFormat: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectMusicBuffer,
                pGuidFormat: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetStartTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectMusicBuffer,
                rt: i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectMusicBuffer,
                rt: i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetUsedBytes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectMusicBuffer,
                cb: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectMusicBuffer,
                cb: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectMusicBuffer_Flush(self: *const T) HRESULT {
                return @as(*const IDirectMusicBuffer.VTable, @ptrCast(self.vtable)).Flush(@as(*const IDirectMusicBuffer, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectMusicBuffer_TotalTime(self: *const T, prtTime: ?*i64) HRESULT {
                return @as(*const IDirectMusicBuffer.VTable, @ptrCast(self.vtable)).TotalTime(@as(*const IDirectMusicBuffer, @ptrCast(self)), prtTime);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectMusicBuffer_PackStructured(self: *const T, rt: i64, dwChannelGroup: u32, dwChannelMessage: u32) HRESULT {
                return @as(*const IDirectMusicBuffer.VTable, @ptrCast(self.vtable)).PackStructured(@as(*const IDirectMusicBuffer, @ptrCast(self)), rt, dwChannelGroup, dwChannelMessage);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectMusicBuffer_PackUnstructured(self: *const T, rt: i64, dwChannelGroup: u32, cb: u32, lpb: ?*u8) HRESULT {
                return @as(*const IDirectMusicBuffer.VTable, @ptrCast(self.vtable)).PackUnstructured(@as(*const IDirectMusicBuffer, @ptrCast(self)), rt, dwChannelGroup, cb, lpb);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectMusicBuffer_ResetReadPtr(self: *const T) HRESULT {
                return @as(*const IDirectMusicBuffer.VTable, @ptrCast(self.vtable)).ResetReadPtr(@as(*const IDirectMusicBuffer, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectMusicBuffer_GetNextEvent(self: *const T, prt: ?*i64, pdwChannelGroup: ?*u32, pdwLength: ?*u32, ppData: ?*?*u8) HRESULT {
                return @as(*const IDirectMusicBuffer.VTable, @ptrCast(self.vtable)).GetNextEvent(@as(*const IDirectMusicBuffer, @ptrCast(self)), prt, pdwChannelGroup, pdwLength, ppData);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectMusicBuffer_GetRawBufferPtr(self: *const T, ppData: ?*?*u8) HRESULT {
                return @as(*const IDirectMusicBuffer.VTable, @ptrCast(self.vtable)).GetRawBufferPtr(@as(*const IDirectMusicBuffer, @ptrCast(self)), ppData);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectMusicBuffer_GetStartTime(self: *const T, prt: ?*i64) HRESULT {
                return @as(*const IDirectMusicBuffer.VTable, @ptrCast(self.vtable)).GetStartTime(@as(*const IDirectMusicBuffer, @ptrCast(self)), prt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectMusicBuffer_GetUsedBytes(self: *const T, pcb: ?*u32) HRESULT {
                return @as(*const IDirectMusicBuffer.VTable, @ptrCast(self.vtable)).GetUsedBytes(@as(*const IDirectMusicBuffer, @ptrCast(self)), pcb);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectMusicBuffer_GetMaxBytes(self: *const T, pcb: ?*u32) HRESULT {
                return @as(*const IDirectMusicBuffer.VTable, @ptrCast(self.vtable)).GetMaxBytes(@as(*const IDirectMusicBuffer, @ptrCast(self)), pcb);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectMusicBuffer_GetBufferFormat(self: *const T, pGuidFormat: ?*Guid) HRESULT {
                return @as(*const IDirectMusicBuffer.VTable, @ptrCast(self.vtable)).GetBufferFormat(@as(*const IDirectMusicBuffer, @ptrCast(self)), pGuidFormat);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectMusicBuffer_SetStartTime(self: *const T, rt: i64) HRESULT {
                return @as(*const IDirectMusicBuffer.VTable, @ptrCast(self.vtable)).SetStartTime(@as(*const IDirectMusicBuffer, @ptrCast(self)), rt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectMusicBuffer_SetUsedBytes(self: *const T, cb: u32) HRESULT {
                return @as(*const IDirectMusicBuffer.VTable, @ptrCast(self.vtable)).SetUsedBytes(@as(*const IDirectMusicBuffer, @ptrCast(self)), cb);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDirectMusicInstrument_Value = Guid.initString("d2ac287d-b39b-11d1-8704-00600893b1bd");
pub const IID_IDirectMusicInstrument = &IID_IDirectMusicInstrument_Value;
pub const IDirectMusicInstrument = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPatch: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectMusicInstrument,
                pdwPatch: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectMusicInstrument,
                pdwPatch: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPatch: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectMusicInstrument,
                dwPatch: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectMusicInstrument,
                dwPatch: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectMusicInstrument_GetPatch(self: *const T, pdwPatch: ?*u32) HRESULT {
                return @as(*const IDirectMusicInstrument.VTable, @ptrCast(self.vtable)).GetPatch(@as(*const IDirectMusicInstrument, @ptrCast(self)), pdwPatch);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectMusicInstrument_SetPatch(self: *const T, dwPatch: u32) HRESULT {
                return @as(*const IDirectMusicInstrument.VTable, @ptrCast(self.vtable)).SetPatch(@as(*const IDirectMusicInstrument, @ptrCast(self)), dwPatch);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDirectMusicDownloadedInstrument_Value = Guid.initString("d2ac287e-b39b-11d1-8704-00600893b1bd");
pub const IID_IDirectMusicDownloadedInstrument = &IID_IDirectMusicDownloadedInstrument_Value;
pub const IDirectMusicDownloadedInstrument = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDirectMusicCollection_Value = Guid.initString("d2ac287c-b39b-11d1-8704-00600893b1bd");
pub const IID_IDirectMusicCollection = &IID_IDirectMusicCollection_Value;
pub const IDirectMusicCollection = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetInstrument: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectMusicCollection,
                dwPatch: u32,
                ppInstrument: ?*?*IDirectMusicInstrument,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectMusicCollection,
                dwPatch: u32,
                ppInstrument: ?*?*IDirectMusicInstrument,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumInstrument: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectMusicCollection,
                dwIndex: u32,
                pdwPatch: ?*u32,
                pwszName: ?PWSTR,
                dwNameLen: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectMusicCollection,
                dwIndex: u32,
                pdwPatch: ?*u32,
                pwszName: ?PWSTR,
                dwNameLen: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectMusicCollection_GetInstrument(self: *const T, dwPatch: u32, ppInstrument: ?*?*IDirectMusicInstrument) HRESULT {
                return @as(*const IDirectMusicCollection.VTable, @ptrCast(self.vtable)).GetInstrument(@as(*const IDirectMusicCollection, @ptrCast(self)), dwPatch, ppInstrument);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectMusicCollection_EnumInstrument(self: *const T, dwIndex: u32, pdwPatch: ?*u32, pwszName: ?PWSTR, dwNameLen: u32) HRESULT {
                return @as(*const IDirectMusicCollection.VTable, @ptrCast(self.vtable)).EnumInstrument(@as(*const IDirectMusicCollection, @ptrCast(self)), dwIndex, pdwPatch, pwszName, dwNameLen);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDirectMusicDownload_Value = Guid.initString("d2ac287b-b39b-11d1-8704-00600893b1bd");
pub const IID_IDirectMusicDownload = &IID_IDirectMusicDownload_Value;
pub const IDirectMusicDownload = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetBuffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectMusicDownload,
                ppvBuffer: ?*?*anyopaque,
                pdwSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectMusicDownload,
                ppvBuffer: ?*?*anyopaque,
                pdwSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectMusicDownload_GetBuffer(self: *const T, ppvBuffer: ?*?*anyopaque, pdwSize: ?*u32) HRESULT {
                return @as(*const IDirectMusicDownload.VTable, @ptrCast(self.vtable)).GetBuffer(@as(*const IDirectMusicDownload, @ptrCast(self)), ppvBuffer, pdwSize);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDirectMusicPortDownload_Value = Guid.initString("d2ac287a-b39b-11d1-8704-00600893b1bd");
pub const IID_IDirectMusicPortDownload = &IID_IDirectMusicPortDownload_Value;
pub const IDirectMusicPortDownload = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetBuffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectMusicPortDownload,
                dwDLId: u32,
                ppIDMDownload: ?*?*IDirectMusicDownload,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectMusicPortDownload,
                dwDLId: u32,
                ppIDMDownload: ?*?*IDirectMusicDownload,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AllocateBuffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectMusicPortDownload,
                dwSize: u32,
                ppIDMDownload: ?*?*IDirectMusicDownload,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectMusicPortDownload,
                dwSize: u32,
                ppIDMDownload: ?*?*IDirectMusicDownload,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDLId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectMusicPortDownload,
                pdwStartDLId: ?*u32,
                dwCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectMusicPortDownload,
                pdwStartDLId: ?*u32,
                dwCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAppend: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectMusicPortDownload,
                pdwAppend: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectMusicPortDownload,
                pdwAppend: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Download: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectMusicPortDownload,
                pIDMDownload: ?*IDirectMusicDownload,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectMusicPortDownload,
                pIDMDownload: ?*IDirectMusicDownload,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Unload: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectMusicPortDownload,
                pIDMDownload: ?*IDirectMusicDownload,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectMusicPortDownload,
                pIDMDownload: ?*IDirectMusicDownload,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectMusicPortDownload_GetBuffer(self: *const T, dwDLId: u32, ppIDMDownload: ?*?*IDirectMusicDownload) HRESULT {
                return @as(*const IDirectMusicPortDownload.VTable, @ptrCast(self.vtable)).GetBuffer(@as(*const IDirectMusicPortDownload, @ptrCast(self)), dwDLId, ppIDMDownload);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectMusicPortDownload_AllocateBuffer(self: *const T, dwSize: u32, ppIDMDownload: ?*?*IDirectMusicDownload) HRESULT {
                return @as(*const IDirectMusicPortDownload.VTable, @ptrCast(self.vtable)).AllocateBuffer(@as(*const IDirectMusicPortDownload, @ptrCast(self)), dwSize, ppIDMDownload);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectMusicPortDownload_GetDLId(self: *const T, pdwStartDLId: ?*u32, dwCount: u32) HRESULT {
                return @as(*const IDirectMusicPortDownload.VTable, @ptrCast(self.vtable)).GetDLId(@as(*const IDirectMusicPortDownload, @ptrCast(self)), pdwStartDLId, dwCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectMusicPortDownload_GetAppend(self: *const T, pdwAppend: ?*u32) HRESULT {
                return @as(*const IDirectMusicPortDownload.VTable, @ptrCast(self.vtable)).GetAppend(@as(*const IDirectMusicPortDownload, @ptrCast(self)), pdwAppend);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectMusicPortDownload_Download(self: *const T, pIDMDownload: ?*IDirectMusicDownload) HRESULT {
                return @as(*const IDirectMusicPortDownload.VTable, @ptrCast(self.vtable)).Download(@as(*const IDirectMusicPortDownload, @ptrCast(self)), pIDMDownload);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectMusicPortDownload_Unload(self: *const T, pIDMDownload: ?*IDirectMusicDownload) HRESULT {
                return @as(*const IDirectMusicPortDownload.VTable, @ptrCast(self.vtable)).Unload(@as(*const IDirectMusicPortDownload, @ptrCast(self)), pIDMDownload);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDirectMusicPort_Value = Guid.initString("08f2d8c9-37c2-11d2-b9f9-0000f875ac12");
pub const IID_IDirectMusicPort = &IID_IDirectMusicPort_Value;
pub const IDirectMusicPort = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        PlayBuffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectMusicPort,
                pBuffer: ?*IDirectMusicBuffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectMusicPort,
                pBuffer: ?*IDirectMusicBuffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetReadNotificationHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectMusicPort,
                hEvent: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectMusicPort,
                hEvent: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Read: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectMusicPort,
                pBuffer: ?*IDirectMusicBuffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectMusicPort,
                pBuffer: ?*IDirectMusicBuffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DownloadInstrument: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectMusicPort,
                pInstrument: ?*IDirectMusicInstrument,
                ppDownloadedInstrument: ?*?*IDirectMusicDownloadedInstrument,
                pNoteRanges: ?*DMUS_NOTERANGE,
                dwNumNoteRanges: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectMusicPort,
                pInstrument: ?*IDirectMusicInstrument,
                ppDownloadedInstrument: ?*?*IDirectMusicDownloadedInstrument,
                pNoteRanges: ?*DMUS_NOTERANGE,
                dwNumNoteRanges: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnloadInstrument: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectMusicPort,
                pDownloadedInstrument: ?*IDirectMusicDownloadedInstrument,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectMusicPort,
                pDownloadedInstrument: ?*IDirectMusicDownloadedInstrument,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLatencyClock: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectMusicPort,
                ppClock: ?*?*IReferenceClock,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectMusicPort,
                ppClock: ?*?*IReferenceClock,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRunningStats: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectMusicPort,
                pStats: ?*DMUS_SYNTHSTATS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectMusicPort,
                pStats: ?*DMUS_SYNTHSTATS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Compact: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectMusicPort,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectMusicPort,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCaps: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectMusicPort,
                pPortCaps: ?*DMUS_PORTCAPS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectMusicPort,
                pPortCaps: ?*DMUS_PORTCAPS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeviceIoControl: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectMusicPort,
                dwIoControlCode: u32,
                lpInBuffer: ?*anyopaque,
                nInBufferSize: u32,
                lpOutBuffer: ?*anyopaque,
                nOutBufferSize: u32,
                lpBytesReturned: ?*u32,
                lpOverlapped: ?*OVERLAPPED,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectMusicPort,
                dwIoControlCode: u32,
                lpInBuffer: ?*anyopaque,
                nInBufferSize: u32,
                lpOutBuffer: ?*anyopaque,
                nOutBufferSize: u32,
                lpBytesReturned: ?*u32,
                lpOverlapped: ?*OVERLAPPED,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetNumChannelGroups: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectMusicPort,
                dwChannelGroups: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectMusicPort,
                dwChannelGroups: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumChannelGroups: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectMusicPort,
                pdwChannelGroups: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectMusicPort,
                pdwChannelGroups: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Activate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectMusicPort,
                fActive: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectMusicPort,
                fActive: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetChannelPriority: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectMusicPort,
                dwChannelGroup: u32,
                dwChannel: u32,
                dwPriority: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectMusicPort,
                dwChannelGroup: u32,
                dwChannel: u32,
                dwPriority: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetChannelPriority: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectMusicPort,
                dwChannelGroup: u32,
                dwChannel: u32,
                pdwPriority: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectMusicPort,
                dwChannelGroup: u32,
                dwChannel: u32,
                pdwPriority: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDirectSound: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectMusicPort,
                pDirectSound: ?*IDirectSound,
                pDirectSoundBuffer: ?*IDirectSoundBuffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectMusicPort,
                pDirectSound: ?*IDirectSound,
                pDirectSoundBuffer: ?*IDirectSoundBuffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFormat: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectMusicPort,
                pWaveFormatEx: ?*WAVEFORMATEX,
                pdwWaveFormatExSize: ?*u32,
                pdwBufferSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectMusicPort,
                pWaveFormatEx: ?*WAVEFORMATEX,
                pdwWaveFormatExSize: ?*u32,
                pdwBufferSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectMusicPort_PlayBuffer(self: *const T, pBuffer: ?*IDirectMusicBuffer) HRESULT {
                return @as(*const IDirectMusicPort.VTable, @ptrCast(self.vtable)).PlayBuffer(@as(*const IDirectMusicPort, @ptrCast(self)), pBuffer);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectMusicPort_SetReadNotificationHandle(self: *const T, hEvent: ?HANDLE) HRESULT {
                return @as(*const IDirectMusicPort.VTable, @ptrCast(self.vtable)).SetReadNotificationHandle(@as(*const IDirectMusicPort, @ptrCast(self)), hEvent);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectMusicPort_Read(self: *const T, pBuffer: ?*IDirectMusicBuffer) HRESULT {
                return @as(*const IDirectMusicPort.VTable, @ptrCast(self.vtable)).Read(@as(*const IDirectMusicPort, @ptrCast(self)), pBuffer);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectMusicPort_DownloadInstrument(self: *const T, pInstrument: ?*IDirectMusicInstrument, ppDownloadedInstrument: ?*?*IDirectMusicDownloadedInstrument, pNoteRanges: ?*DMUS_NOTERANGE, dwNumNoteRanges: u32) HRESULT {
                return @as(*const IDirectMusicPort.VTable, @ptrCast(self.vtable)).DownloadInstrument(@as(*const IDirectMusicPort, @ptrCast(self)), pInstrument, ppDownloadedInstrument, pNoteRanges, dwNumNoteRanges);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectMusicPort_UnloadInstrument(self: *const T, pDownloadedInstrument: ?*IDirectMusicDownloadedInstrument) HRESULT {
                return @as(*const IDirectMusicPort.VTable, @ptrCast(self.vtable)).UnloadInstrument(@as(*const IDirectMusicPort, @ptrCast(self)), pDownloadedInstrument);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectMusicPort_GetLatencyClock(self: *const T, ppClock: ?*?*IReferenceClock) HRESULT {
                return @as(*const IDirectMusicPort.VTable, @ptrCast(self.vtable)).GetLatencyClock(@as(*const IDirectMusicPort, @ptrCast(self)), ppClock);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectMusicPort_GetRunningStats(self: *const T, pStats: ?*DMUS_SYNTHSTATS) HRESULT {
                return @as(*const IDirectMusicPort.VTable, @ptrCast(self.vtable)).GetRunningStats(@as(*const IDirectMusicPort, @ptrCast(self)), pStats);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectMusicPort_Compact(self: *const T) HRESULT {
                return @as(*const IDirectMusicPort.VTable, @ptrCast(self.vtable)).Compact(@as(*const IDirectMusicPort, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectMusicPort_GetCaps(self: *const T, pPortCaps: ?*DMUS_PORTCAPS) HRESULT {
                return @as(*const IDirectMusicPort.VTable, @ptrCast(self.vtable)).GetCaps(@as(*const IDirectMusicPort, @ptrCast(self)), pPortCaps);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectMusicPort_DeviceIoControl(self: *const T, dwIoControlCode: u32, lpInBuffer: ?*anyopaque, nInBufferSize: u32, lpOutBuffer: ?*anyopaque, nOutBufferSize: u32, lpBytesReturned: ?*u32, lpOverlapped: ?*OVERLAPPED) HRESULT {
                return @as(*const IDirectMusicPort.VTable, @ptrCast(self.vtable)).DeviceIoControl(@as(*const IDirectMusicPort, @ptrCast(self)), dwIoControlCode, lpInBuffer, nInBufferSize, lpOutBuffer, nOutBufferSize, lpBytesReturned, lpOverlapped);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectMusicPort_SetNumChannelGroups(self: *const T, dwChannelGroups: u32) HRESULT {
                return @as(*const IDirectMusicPort.VTable, @ptrCast(self.vtable)).SetNumChannelGroups(@as(*const IDirectMusicPort, @ptrCast(self)), dwChannelGroups);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectMusicPort_GetNumChannelGroups(self: *const T, pdwChannelGroups: ?*u32) HRESULT {
                return @as(*const IDirectMusicPort.VTable, @ptrCast(self.vtable)).GetNumChannelGroups(@as(*const IDirectMusicPort, @ptrCast(self)), pdwChannelGroups);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectMusicPort_Activate(self: *const T, fActive: BOOL) HRESULT {
                return @as(*const IDirectMusicPort.VTable, @ptrCast(self.vtable)).Activate(@as(*const IDirectMusicPort, @ptrCast(self)), fActive);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectMusicPort_SetChannelPriority(self: *const T, dwChannelGroup: u32, dwChannel: u32, dwPriority: u32) HRESULT {
                return @as(*const IDirectMusicPort.VTable, @ptrCast(self.vtable)).SetChannelPriority(@as(*const IDirectMusicPort, @ptrCast(self)), dwChannelGroup, dwChannel, dwPriority);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectMusicPort_GetChannelPriority(self: *const T, dwChannelGroup: u32, dwChannel: u32, pdwPriority: ?*u32) HRESULT {
                return @as(*const IDirectMusicPort.VTable, @ptrCast(self.vtable)).GetChannelPriority(@as(*const IDirectMusicPort, @ptrCast(self)), dwChannelGroup, dwChannel, pdwPriority);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectMusicPort_SetDirectSound(self: *const T, pDirectSound: ?*IDirectSound, pDirectSoundBuffer: ?*IDirectSoundBuffer) HRESULT {
                return @as(*const IDirectMusicPort.VTable, @ptrCast(self.vtable)).SetDirectSound(@as(*const IDirectMusicPort, @ptrCast(self)), pDirectSound, pDirectSoundBuffer);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectMusicPort_GetFormat(self: *const T, pWaveFormatEx: ?*WAVEFORMATEX, pdwWaveFormatExSize: ?*u32, pdwBufferSize: ?*u32) HRESULT {
                return @as(*const IDirectMusicPort.VTable, @ptrCast(self.vtable)).GetFormat(@as(*const IDirectMusicPort, @ptrCast(self)), pWaveFormatEx, pdwWaveFormatExSize, pdwBufferSize);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDirectMusicThru_Value = Guid.initString("ced153e7-3606-11d2-b9f9-0000f875ac12");
pub const IID_IDirectMusicThru = &IID_IDirectMusicThru_Value;
pub const IDirectMusicThru = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ThruChannel: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectMusicThru,
                dwSourceChannelGroup: u32,
                dwSourceChannel: u32,
                dwDestinationChannelGroup: u32,
                dwDestinationChannel: u32,
                pDestinationPort: ?*IDirectMusicPort,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectMusicThru,
                dwSourceChannelGroup: u32,
                dwSourceChannel: u32,
                dwDestinationChannelGroup: u32,
                dwDestinationChannel: u32,
                pDestinationPort: ?*IDirectMusicPort,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectMusicThru_ThruChannel(self: *const T, dwSourceChannelGroup: u32, dwSourceChannel: u32, dwDestinationChannelGroup: u32, dwDestinationChannel: u32, pDestinationPort: ?*IDirectMusicPort) HRESULT {
                return @as(*const IDirectMusicThru.VTable, @ptrCast(self.vtable)).ThruChannel(@as(*const IDirectMusicThru, @ptrCast(self)), dwSourceChannelGroup, dwSourceChannel, dwDestinationChannelGroup, dwDestinationChannel, pDestinationPort);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DMUS_VOICE_STATE = extern struct {
    bExists: BOOL,
    spPosition: u64,
};

const IID_IDirectMusicSynth_Value = Guid.initString("09823661-5c85-11d2-afa6-00aa0024d8b6");
pub const IID_IDirectMusicSynth = &IID_IDirectMusicSynth_Value;
pub const IDirectMusicSynth = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Open: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectMusicSynth,
                pPortParams: ?*DMUS_PORTPARAMS8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectMusicSynth,
                pPortParams: ?*DMUS_PORTPARAMS8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Close: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectMusicSynth,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectMusicSynth,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetNumChannelGroups: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectMusicSynth,
                dwGroups: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectMusicSynth,
                dwGroups: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Download: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectMusicSynth,
                phDownload: ?*?HANDLE,
                pvData: ?*anyopaque,
                pbFree: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectMusicSynth,
                phDownload: ?*?HANDLE,
                pvData: ?*anyopaque,
                pbFree: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Unload: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectMusicSynth,
                hDownload: ?HANDLE,
                lpFreeHandle: isize,
                hUserData: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectMusicSynth,
                hDownload: ?HANDLE,
                lpFreeHandle: isize,
                hUserData: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PlayBuffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectMusicSynth,
                rt: i64,
                pbBuffer: ?*u8,
                cbBuffer: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectMusicSynth,
                rt: i64,
                pbBuffer: ?*u8,
                cbBuffer: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRunningStats: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectMusicSynth,
                pStats: ?*DMUS_SYNTHSTATS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectMusicSynth,
                pStats: ?*DMUS_SYNTHSTATS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPortCaps: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectMusicSynth,
                pCaps: ?*DMUS_PORTCAPS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectMusicSynth,
                pCaps: ?*DMUS_PORTCAPS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetMasterClock: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectMusicSynth,
                pClock: ?*IReferenceClock,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectMusicSynth,
                pClock: ?*IReferenceClock,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLatencyClock: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectMusicSynth,
                ppClock: ?*?*IReferenceClock,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectMusicSynth,
                ppClock: ?*?*IReferenceClock,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Activate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectMusicSynth,
                fEnable: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectMusicSynth,
                fEnable: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSynthSink: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectMusicSynth,
                pSynthSink: ?*IDirectMusicSynthSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectMusicSynth,
                pSynthSink: ?*IDirectMusicSynthSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Render: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectMusicSynth,
                pBuffer: ?*i16,
                dwLength: u32,
                llPosition: i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectMusicSynth,
                pBuffer: ?*i16,
                dwLength: u32,
                llPosition: i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetChannelPriority: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectMusicSynth,
                dwChannelGroup: u32,
                dwChannel: u32,
                dwPriority: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectMusicSynth,
                dwChannelGroup: u32,
                dwChannel: u32,
                dwPriority: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetChannelPriority: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectMusicSynth,
                dwChannelGroup: u32,
                dwChannel: u32,
                pdwPriority: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectMusicSynth,
                dwChannelGroup: u32,
                dwChannel: u32,
                pdwPriority: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFormat: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectMusicSynth,
                pWaveFormatEx: ?*WAVEFORMATEX,
                pdwWaveFormatExSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectMusicSynth,
                pWaveFormatEx: ?*WAVEFORMATEX,
                pdwWaveFormatExSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAppend: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectMusicSynth,
                pdwAppend: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectMusicSynth,
                pdwAppend: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectMusicSynth_Open(self: *const T, pPortParams: ?*DMUS_PORTPARAMS8) HRESULT {
                return @as(*const IDirectMusicSynth.VTable, @ptrCast(self.vtable)).Open(@as(*const IDirectMusicSynth, @ptrCast(self)), pPortParams);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectMusicSynth_Close(self: *const T) HRESULT {
                return @as(*const IDirectMusicSynth.VTable, @ptrCast(self.vtable)).Close(@as(*const IDirectMusicSynth, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectMusicSynth_SetNumChannelGroups(self: *const T, dwGroups: u32) HRESULT {
                return @as(*const IDirectMusicSynth.VTable, @ptrCast(self.vtable)).SetNumChannelGroups(@as(*const IDirectMusicSynth, @ptrCast(self)), dwGroups);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectMusicSynth_Download(self: *const T, phDownload: ?*?HANDLE, pvData: ?*anyopaque, pbFree: ?*i32) HRESULT {
                return @as(*const IDirectMusicSynth.VTable, @ptrCast(self.vtable)).Download(@as(*const IDirectMusicSynth, @ptrCast(self)), phDownload, pvData, pbFree);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectMusicSynth_Unload(self: *const T, hDownload: ?HANDLE, lpFreeHandle: isize, hUserData: ?HANDLE) HRESULT {
                return @as(*const IDirectMusicSynth.VTable, @ptrCast(self.vtable)).Unload(@as(*const IDirectMusicSynth, @ptrCast(self)), hDownload, lpFreeHandle, hUserData);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectMusicSynth_PlayBuffer(self: *const T, rt: i64, pbBuffer: ?*u8, cbBuffer: u32) HRESULT {
                return @as(*const IDirectMusicSynth.VTable, @ptrCast(self.vtable)).PlayBuffer(@as(*const IDirectMusicSynth, @ptrCast(self)), rt, pbBuffer, cbBuffer);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectMusicSynth_GetRunningStats(self: *const T, pStats: ?*DMUS_SYNTHSTATS) HRESULT {
                return @as(*const IDirectMusicSynth.VTable, @ptrCast(self.vtable)).GetRunningStats(@as(*const IDirectMusicSynth, @ptrCast(self)), pStats);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectMusicSynth_GetPortCaps(self: *const T, pCaps: ?*DMUS_PORTCAPS) HRESULT {
                return @as(*const IDirectMusicSynth.VTable, @ptrCast(self.vtable)).GetPortCaps(@as(*const IDirectMusicSynth, @ptrCast(self)), pCaps);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectMusicSynth_SetMasterClock(self: *const T, pClock: ?*IReferenceClock) HRESULT {
                return @as(*const IDirectMusicSynth.VTable, @ptrCast(self.vtable)).SetMasterClock(@as(*const IDirectMusicSynth, @ptrCast(self)), pClock);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectMusicSynth_GetLatencyClock(self: *const T, ppClock: ?*?*IReferenceClock) HRESULT {
                return @as(*const IDirectMusicSynth.VTable, @ptrCast(self.vtable)).GetLatencyClock(@as(*const IDirectMusicSynth, @ptrCast(self)), ppClock);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectMusicSynth_Activate(self: *const T, fEnable: BOOL) HRESULT {
                return @as(*const IDirectMusicSynth.VTable, @ptrCast(self.vtable)).Activate(@as(*const IDirectMusicSynth, @ptrCast(self)), fEnable);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectMusicSynth_SetSynthSink(self: *const T, pSynthSink: ?*IDirectMusicSynthSink) HRESULT {
                return @as(*const IDirectMusicSynth.VTable, @ptrCast(self.vtable)).SetSynthSink(@as(*const IDirectMusicSynth, @ptrCast(self)), pSynthSink);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectMusicSynth_Render(self: *const T, pBuffer: ?*i16, dwLength: u32, llPosition: i64) HRESULT {
                return @as(*const IDirectMusicSynth.VTable, @ptrCast(self.vtable)).Render(@as(*const IDirectMusicSynth, @ptrCast(self)), pBuffer, dwLength, llPosition);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectMusicSynth_SetChannelPriority(self: *const T, dwChannelGroup: u32, dwChannel: u32, dwPriority: u32) HRESULT {
                return @as(*const IDirectMusicSynth.VTable, @ptrCast(self.vtable)).SetChannelPriority(@as(*const IDirectMusicSynth, @ptrCast(self)), dwChannelGroup, dwChannel, dwPriority);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectMusicSynth_GetChannelPriority(self: *const T, dwChannelGroup: u32, dwChannel: u32, pdwPriority: ?*u32) HRESULT {
                return @as(*const IDirectMusicSynth.VTable, @ptrCast(self.vtable)).GetChannelPriority(@as(*const IDirectMusicSynth, @ptrCast(self)), dwChannelGroup, dwChannel, pdwPriority);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectMusicSynth_GetFormat(self: *const T, pWaveFormatEx: ?*WAVEFORMATEX, pdwWaveFormatExSize: ?*u32) HRESULT {
                return @as(*const IDirectMusicSynth.VTable, @ptrCast(self.vtable)).GetFormat(@as(*const IDirectMusicSynth, @ptrCast(self)), pWaveFormatEx, pdwWaveFormatExSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectMusicSynth_GetAppend(self: *const T, pdwAppend: ?*u32) HRESULT {
                return @as(*const IDirectMusicSynth.VTable, @ptrCast(self.vtable)).GetAppend(@as(*const IDirectMusicSynth, @ptrCast(self)), pdwAppend);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDirectMusicSynth8_Value = Guid.initString("53cab625-2711-4c9f-9de7-1b7f925f6fc8");
pub const IID_IDirectMusicSynth8 = &IID_IDirectMusicSynth8_Value;
pub const IDirectMusicSynth8 = extern struct {
    pub const VTable = extern struct {
        base: IDirectMusicSynth.VTable,
        PlayVoice: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectMusicSynth8,
                rt: i64,
                dwVoiceId: u32,
                dwChannelGroup: u32,
                dwChannel: u32,
                dwDLId: u32,
                prPitch: i32,
                vrVolume: i32,
                stVoiceStart: u64,
                stLoopStart: u64,
                stLoopEnd: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectMusicSynth8,
                rt: i64,
                dwVoiceId: u32,
                dwChannelGroup: u32,
                dwChannel: u32,
                dwDLId: u32,
                prPitch: i32,
                vrVolume: i32,
                stVoiceStart: u64,
                stLoopStart: u64,
                stLoopEnd: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StopVoice: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectMusicSynth8,
                rt: i64,
                dwVoiceId: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectMusicSynth8,
                rt: i64,
                dwVoiceId: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVoiceState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectMusicSynth8,
                dwVoice: ?*u32,
                cbVoice: u32,
                dwVoiceState: ?*DMUS_VOICE_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectMusicSynth8,
                dwVoice: ?*u32,
                cbVoice: u32,
                dwVoiceState: ?*DMUS_VOICE_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Refresh: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectMusicSynth8,
                dwDownloadID: u32,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectMusicSynth8,
                dwDownloadID: u32,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AssignChannelToBuses: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectMusicSynth8,
                dwChannelGroup: u32,
                dwChannel: u32,
                pdwBuses: ?*u32,
                cBuses: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectMusicSynth8,
                dwChannelGroup: u32,
                dwChannel: u32,
                pdwBuses: ?*u32,
                cBuses: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDirectMusicSynth.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectMusicSynth8_PlayVoice(self: *const T, rt: i64, dwVoiceId: u32, dwChannelGroup: u32, dwChannel: u32, dwDLId: u32, prPitch: i32, vrVolume: i32, stVoiceStart: u64, stLoopStart: u64, stLoopEnd: u64) HRESULT {
                return @as(*const IDirectMusicSynth8.VTable, @ptrCast(self.vtable)).PlayVoice(@as(*const IDirectMusicSynth8, @ptrCast(self)), rt, dwVoiceId, dwChannelGroup, dwChannel, dwDLId, prPitch, vrVolume, stVoiceStart, stLoopStart, stLoopEnd);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectMusicSynth8_StopVoice(self: *const T, rt: i64, dwVoiceId: u32) HRESULT {
                return @as(*const IDirectMusicSynth8.VTable, @ptrCast(self.vtable)).StopVoice(@as(*const IDirectMusicSynth8, @ptrCast(self)), rt, dwVoiceId);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectMusicSynth8_GetVoiceState(self: *const T, dwVoice: ?*u32, cbVoice: u32, dwVoiceState: ?*DMUS_VOICE_STATE) HRESULT {
                return @as(*const IDirectMusicSynth8.VTable, @ptrCast(self.vtable)).GetVoiceState(@as(*const IDirectMusicSynth8, @ptrCast(self)), dwVoice, cbVoice, dwVoiceState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectMusicSynth8_Refresh(self: *const T, dwDownloadID: u32, dwFlags: u32) HRESULT {
                return @as(*const IDirectMusicSynth8.VTable, @ptrCast(self.vtable)).Refresh(@as(*const IDirectMusicSynth8, @ptrCast(self)), dwDownloadID, dwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectMusicSynth8_AssignChannelToBuses(self: *const T, dwChannelGroup: u32, dwChannel: u32, pdwBuses: ?*u32, cBuses: u32) HRESULT {
                return @as(*const IDirectMusicSynth8.VTable, @ptrCast(self.vtable)).AssignChannelToBuses(@as(*const IDirectMusicSynth8, @ptrCast(self)), dwChannelGroup, dwChannel, pdwBuses, cBuses);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDirectMusicSynthSink_Value = Guid.initString("09823663-5c85-11d2-afa6-00aa0024d8b6");
pub const IID_IDirectMusicSynthSink = &IID_IDirectMusicSynthSink_Value;
pub const IDirectMusicSynthSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Init: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectMusicSynthSink,
                pSynth: ?*IDirectMusicSynth,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectMusicSynthSink,
                pSynth: ?*IDirectMusicSynth,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetMasterClock: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectMusicSynthSink,
                pClock: ?*IReferenceClock,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectMusicSynthSink,
                pClock: ?*IReferenceClock,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLatencyClock: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectMusicSynthSink,
                ppClock: ?*?*IReferenceClock,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectMusicSynthSink,
                ppClock: ?*?*IReferenceClock,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Activate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectMusicSynthSink,
                fEnable: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectMusicSynthSink,
                fEnable: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SampleToRefTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectMusicSynthSink,
                llSampleTime: i64,
                prfTime: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectMusicSynthSink,
                llSampleTime: i64,
                prfTime: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RefTimeToSample: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectMusicSynthSink,
                rfTime: i64,
                pllSampleTime: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectMusicSynthSink,
                rfTime: i64,
                pllSampleTime: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDirectSound: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectMusicSynthSink,
                pDirectSound: ?*IDirectSound,
                pDirectSoundBuffer: ?*IDirectSoundBuffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectMusicSynthSink,
                pDirectSound: ?*IDirectSound,
                pDirectSoundBuffer: ?*IDirectSoundBuffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDesiredBufferSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectMusicSynthSink,
                pdwBufferSizeInSamples: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectMusicSynthSink,
                pdwBufferSizeInSamples: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectMusicSynthSink_Init(self: *const T, pSynth: ?*IDirectMusicSynth) HRESULT {
                return @as(*const IDirectMusicSynthSink.VTable, @ptrCast(self.vtable)).Init(@as(*const IDirectMusicSynthSink, @ptrCast(self)), pSynth);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectMusicSynthSink_SetMasterClock(self: *const T, pClock: ?*IReferenceClock) HRESULT {
                return @as(*const IDirectMusicSynthSink.VTable, @ptrCast(self.vtable)).SetMasterClock(@as(*const IDirectMusicSynthSink, @ptrCast(self)), pClock);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectMusicSynthSink_GetLatencyClock(self: *const T, ppClock: ?*?*IReferenceClock) HRESULT {
                return @as(*const IDirectMusicSynthSink.VTable, @ptrCast(self.vtable)).GetLatencyClock(@as(*const IDirectMusicSynthSink, @ptrCast(self)), ppClock);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectMusicSynthSink_Activate(self: *const T, fEnable: BOOL) HRESULT {
                return @as(*const IDirectMusicSynthSink.VTable, @ptrCast(self.vtable)).Activate(@as(*const IDirectMusicSynthSink, @ptrCast(self)), fEnable);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectMusicSynthSink_SampleToRefTime(self: *const T, llSampleTime: i64, prfTime: ?*i64) HRESULT {
                return @as(*const IDirectMusicSynthSink.VTable, @ptrCast(self.vtable)).SampleToRefTime(@as(*const IDirectMusicSynthSink, @ptrCast(self)), llSampleTime, prfTime);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectMusicSynthSink_RefTimeToSample(self: *const T, rfTime: i64, pllSampleTime: ?*i64) HRESULT {
                return @as(*const IDirectMusicSynthSink.VTable, @ptrCast(self.vtable)).RefTimeToSample(@as(*const IDirectMusicSynthSink, @ptrCast(self)), rfTime, pllSampleTime);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectMusicSynthSink_SetDirectSound(self: *const T, pDirectSound: ?*IDirectSound, pDirectSoundBuffer: ?*IDirectSoundBuffer) HRESULT {
                return @as(*const IDirectMusicSynthSink.VTable, @ptrCast(self.vtable)).SetDirectSound(@as(*const IDirectMusicSynthSink, @ptrCast(self)), pDirectSound, pDirectSoundBuffer);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectMusicSynthSink_GetDesiredBufferSize(self: *const T, pdwBufferSizeInSamples: ?*u32) HRESULT {
                return @as(*const IDirectMusicSynthSink.VTable, @ptrCast(self.vtable)).GetDesiredBufferSize(@as(*const IDirectMusicSynthSink, @ptrCast(self)), pdwBufferSizeInSamples);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DSPROPERTY_DIRECTSOUNDDEVICE = enum(i32) {
    WAVEDEVICEMAPPING_A = 1,
    DESCRIPTION_1 = 2,
    ENUMERATE_1 = 3,
    WAVEDEVICEMAPPING_W = 4,
    DESCRIPTION_A = 5,
    DESCRIPTION_W = 6,
    ENUMERATE_A = 7,
    ENUMERATE_W = 8,
};
pub const DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_A = DSPROPERTY_DIRECTSOUNDDEVICE.WAVEDEVICEMAPPING_A;
pub const DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_1 = DSPROPERTY_DIRECTSOUNDDEVICE.DESCRIPTION_1;
pub const DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_1 = DSPROPERTY_DIRECTSOUNDDEVICE.ENUMERATE_1;
pub const DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_W = DSPROPERTY_DIRECTSOUNDDEVICE.WAVEDEVICEMAPPING_W;
pub const DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_A = DSPROPERTY_DIRECTSOUNDDEVICE.DESCRIPTION_A;
pub const DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_W = DSPROPERTY_DIRECTSOUNDDEVICE.DESCRIPTION_W;
pub const DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_A = DSPROPERTY_DIRECTSOUNDDEVICE.ENUMERATE_A;
pub const DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_W = DSPROPERTY_DIRECTSOUNDDEVICE.ENUMERATE_W;

pub const DIRECTSOUNDDEVICE_TYPE = enum(i32) {
    EMULATED = 0,
    VXD = 1,
    WDM = 2,
};
pub const DIRECTSOUNDDEVICE_TYPE_EMULATED = DIRECTSOUNDDEVICE_TYPE.EMULATED;
pub const DIRECTSOUNDDEVICE_TYPE_VXD = DIRECTSOUNDDEVICE_TYPE.VXD;
pub const DIRECTSOUNDDEVICE_TYPE_WDM = DIRECTSOUNDDEVICE_TYPE.WDM;

pub const DIRECTSOUNDDEVICE_DATAFLOW = enum(i32) {
    RENDER = 0,
    CAPTURE = 1,
};
pub const DIRECTSOUNDDEVICE_DATAFLOW_RENDER = DIRECTSOUNDDEVICE_DATAFLOW.RENDER;
pub const DIRECTSOUNDDEVICE_DATAFLOW_CAPTURE = DIRECTSOUNDDEVICE_DATAFLOW.CAPTURE;

pub const DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_A_DATA = extern struct {
    DeviceName: ?PSTR,
    DataFlow: DIRECTSOUNDDEVICE_DATAFLOW,
    DeviceId: Guid,
};

pub const DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_W_DATA = extern struct {
    DeviceName: ?PWSTR,
    DataFlow: DIRECTSOUNDDEVICE_DATAFLOW,
    DeviceId: Guid,
};

pub const DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_1_DATA = extern struct {
    DeviceId: Guid,
    DescriptionA: [256]CHAR,
    DescriptionW: [256]u16,
    ModuleA: [260]CHAR,
    ModuleW: [260]u16,
    Type: DIRECTSOUNDDEVICE_TYPE,
    DataFlow: DIRECTSOUNDDEVICE_DATAFLOW,
    WaveDeviceId: u32,
    Devnode: u32,
};

pub const DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_A_DATA = extern struct {
    Type: DIRECTSOUNDDEVICE_TYPE,
    DataFlow: DIRECTSOUNDDEVICE_DATAFLOW,
    DeviceId: Guid,
    Description: ?PSTR,
    Module: ?PSTR,
    Interface: ?PSTR,
    WaveDeviceId: u32,
};

pub const DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_W_DATA = extern struct {
    Type: DIRECTSOUNDDEVICE_TYPE,
    DataFlow: DIRECTSOUNDDEVICE_DATAFLOW,
    DeviceId: Guid,
    Description: ?PWSTR,
    Module: ?PWSTR,
    Interface: ?PWSTR,
    WaveDeviceId: u32,
};

pub const LPFNDIRECTSOUNDDEVICEENUMERATECALLBACK1 = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        param0: ?*DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_1_DATA,
        param1: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn (
        param0: ?*DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_1_DATA,
        param1: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
};

pub const LPFNDIRECTSOUNDDEVICEENUMERATECALLBACKA = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        param0: ?*DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_A_DATA,
        param1: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn (
        param0: ?*DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_A_DATA,
        param1: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
};

pub const LPFNDIRECTSOUNDDEVICEENUMERATECALLBACKW = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        param0: ?*DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_W_DATA,
        param1: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn (
        param0: ?*DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_W_DATA,
        param1: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
};

pub const DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_1_DATA = extern struct {
    Callback: ?LPFNDIRECTSOUNDDEVICEENUMERATECALLBACK1,
    Context: ?*anyopaque,
};

pub const DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_A_DATA = extern struct {
    Callback: ?LPFNDIRECTSOUNDDEVICEENUMERATECALLBACKA,
    Context: ?*anyopaque,
};

pub const DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_W_DATA = extern struct {
    Callback: ?LPFNDIRECTSOUNDDEVICEENUMERATECALLBACKW,
    Context: ?*anyopaque,
};

pub const Tag_DVAudInfo = extern struct {
    bAudStyle: [2]u8,
    bAudQu: [2]u8,
    bNumAudPin: u8,
    wAvgSamplesPerPinPerFrm: [2]u16,
    wBlkMode: u16,
    wDIFMode: u16,
    wBlkDiv: u16,
};

pub const MDEVICECAPSEX = extern struct {
    cbSize: u32 align(1),
    pCaps: ?*anyopaque align(1),
};

pub const MIDIOPENDESC = extern struct {
    hMidi: ?HMIDI align(1),
    dwCallback: usize align(1),
    dwInstance: usize align(1),
    dnDevNode: usize align(1),
    cIds: u32 align(1),
    rgIds: [1]MIDIOPENSTRMID align(1),
};

//--------------------------------------------------------------------------------
// Section: Functions (0)
//--------------------------------------------------------------------------------

//--------------------------------------------------------------------------------
// Section: Unicode Aliases (1)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../../zig.zig").unicode_mode) {
    .ansi => struct {
        pub const LPFNDIRECTSOUNDDEVICEENUMERATECALLBACK = thismodule.LPFNDIRECTSOUNDDEVICEENUMERATECALLBACKA;
    },
    .wide => struct {
        pub const LPFNDIRECTSOUNDDEVICEENUMERATECALLBACK = thismodule.LPFNDIRECTSOUNDDEVICEENUMERATECALLBACKW;
    },
    .unspecified => if (@import("builtin").is_test) struct {
        pub const LPFNDIRECTSOUNDDEVICEENUMERATECALLBACK = *opaque {};
    } else struct {
        pub const LPFNDIRECTSOUNDDEVICEENUMERATECALLBACK = @compileError("'LPFNDIRECTSOUNDDEVICEENUMERATECALLBACK' requires that UNICODE be set to true or false in the root module");
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (16)
//--------------------------------------------------------------------------------
const Guid = @import("../../zig.zig").Guid;
const BOOL = @import("../../foundation.zig").BOOL;
const CHAR = @import("../../foundation.zig").CHAR;
const HANDLE = @import("../../foundation.zig").HANDLE;
const HMIDI = @import("../../media/audio.zig").HMIDI;
const HRESULT = @import("../../foundation.zig").HRESULT;
const HWND = @import("../../foundation.zig").HWND;
const IDirectSound = @import("../../media/audio/direct_sound.zig").IDirectSound;
const IDirectSoundBuffer = @import("../../media/audio/direct_sound.zig").IDirectSoundBuffer;
const IReferenceClock = @import("../../media.zig").IReferenceClock;
const IUnknown = @import("../../system/com.zig").IUnknown;
const MIDIOPENSTRMID = @import("../../media/multimedia.zig").MIDIOPENSTRMID;
const OVERLAPPED = @import("../../system/io.zig").OVERLAPPED;
const PSTR = @import("../../foundation.zig").PSTR;
const PWSTR = @import("../../foundation.zig").PWSTR;
const WAVEFORMATEX = @import("../../media/audio.zig").WAVEFORMATEX;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "LPFNDIRECTSOUNDDEVICEENUMERATECALLBACK1")) {
        _ = LPFNDIRECTSOUNDDEVICEENUMERATECALLBACK1;
    }
    if (@hasDecl(@This(), "LPFNDIRECTSOUNDDEVICEENUMERATECALLBACKA")) {
        _ = LPFNDIRECTSOUNDDEVICEENUMERATECALLBACKA;
    }
    if (@hasDecl(@This(), "LPFNDIRECTSOUNDDEVICEENUMERATECALLBACKW")) {
        _ = LPFNDIRECTSOUNDDEVICEENUMERATECALLBACKW;
    }

    @setEvalBranchQuota(comptime @import("std").meta.declarations(@This()).len * 3);

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        if (decl.is_pub) {
            _ = @field(@This(), decl.name);
        }
    }
}
